
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:46:36.316] plan(): Setting new future strategy stack:
[17:46:36.317] List of future strategies:
[17:46:36.317] 1. sequential:
[17:46:36.317]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.317]    - tweaked: FALSE
[17:46:36.317]    - call: future::plan("sequential")
[17:46:36.328] plan(): nbrOfWorkers() = 1
> 
> message("*** %<-% ...")
*** %<-% ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** %%<-%% with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     rm(list = intersect(c("x", "y"), ls()))
+ 
+     message("** Future evaluation without globals")
+     v1 %<-% { x <- 1 }
+     stopifnot(!exists("x", inherits = FALSE), identical(v1, 1))
+ 
+     message("** Future evaluation with globals")
+     a <- 2
+     v2 %<-% { x <- a }
+     stopifnot(!exists("x", inherits = FALSE), identical(v2, a))
+ 
+     message("** Future evaluation with errors")
+     v3 %<-% {
+       x <- 3
+       stop("Woops!")
+       x
+     }
+     stopifnot(!exists("x", inherits = FALSE))
+     res <- tryCatch(identical(v3, 3), error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     y <- listenv::listenv()
+     for (ii in 1:3) {
+       y[[ii]] %<-% {
+         if (ii %% 2 == 0) stop("Woops!")
+         ii
+       }
+     }
+     res <- tryCatch(as.list(y), error = identity)
+     stopifnot(inherits(res, "error"))
+     z <- y[c(1, 3)]
+     z <- unlist(z)
+     stopifnot(all(z == c(1, 3)))
+     res <- tryCatch(y[[2]], error = identity)
+     stopifnot(inherits(res, "error"))
+     res <- tryCatch(y[1:2], error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     message("** Future evaluation with a poor-man's \"progress bar\"")
+     v4 %<-% {
+       cat("Processing: ")
+       for (ii in 1:10) { cat(".") }
+       cat(" [100%]\n")
+       4
+     }
+ 
+ 
+     message("** Collecting results")
+     printf("v1 = %s\n", v1)
+     stopifnot(v1 == 1)
+ 
+     printf("v2 = %s\n", v2)
+     stopifnot(v2 == a)
+ 
+     stopifnot(tryCatch({
+       printf("v3 = %s\n", v3)
+     }, error = function(ex) {
+       printf("v3: <%s> (as expect)\n", class(ex)[1])
+       TRUE
+     }))
+ 
+     printf("v4 = %s\n", v4)
+     #stopifnot(v4 == 4)
+ 
+ 
+     message("** Left-to-right and right-to-left future assignments")
+     c %<-% 1
+     printf("c = %s\n", c)
+     1 %->% d
+     printf("d = %s\n", d)
+     stopifnot(d == c)
+ 
+ 
+ 
+     message("** Nested future assignments")
+     a %<-% {
+       b <- 1
+       c %<-% 2
+       3 -> d
+       4 %->% e
+       b + c + d + e
+     }
+     printf("a = %s\n", a)
+     stopifnot(a == 10)
+ 
+     { a + 1 } %->% b
+     printf("b = %s\n", b)
+     stopifnot(b == a + 1)
+ 
+     message(sprintf("*** %%<-%% with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** %<-% with ‘sequential’ futures ...
[17:46:36.384] plan(): Setting new future strategy stack:
[17:46:36.384] List of future strategies:
[17:46:36.384] 1. sequential:
[17:46:36.384]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.384]    - tweaked: FALSE
[17:46:36.384]    - call: plan(strategy)
[17:46:36.396] plan(): nbrOfWorkers() = 1
** Future evaluation without globals
[17:46:36.397] getGlobalsAndPackages() ...
[17:46:36.398] Searching for globals...
[17:46:36.402] - globals found: [2] ‘{’, ‘<-’
[17:46:36.402] Searching for globals ... DONE
[17:46:36.402] Resolving globals: FALSE
[17:46:36.402] 
[17:46:36.403] 
[17:46:36.403] getGlobalsAndPackages() ... DONE
[17:46:36.403] run() for ‘Future’ ...
[17:46:36.403] - state: ‘created’
[17:46:36.404] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.404] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.404] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.404]   - Field: ‘label’
[17:46:36.404]   - Field: ‘local’
[17:46:36.404]   - Field: ‘owner’
[17:46:36.404]   - Field: ‘envir’
[17:46:36.404]   - Field: ‘packages’
[17:46:36.405]   - Field: ‘gc’
[17:46:36.405]   - Field: ‘conditions’
[17:46:36.405]   - Field: ‘expr’
[17:46:36.405]   - Field: ‘uuid’
[17:46:36.405]   - Field: ‘seed’
[17:46:36.405]   - Field: ‘version’
[17:46:36.405]   - Field: ‘result’
[17:46:36.405]   - Field: ‘asynchronous’
[17:46:36.405]   - Field: ‘calls’
[17:46:36.405]   - Field: ‘globals’
[17:46:36.405]   - Field: ‘stdout’
[17:46:36.405]   - Field: ‘earlySignal’
[17:46:36.406]   - Field: ‘lazy’
[17:46:36.406]   - Field: ‘state’
[17:46:36.406] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.406] - Launch lazy future ...
[17:46:36.406] Packages needed by the future expression (n = 0): <none>
[17:46:36.407] Packages needed by future strategies (n = 0): <none>
[17:46:36.407] {
[17:46:36.407]     {
[17:46:36.407]         {
[17:46:36.407]             ...future.startTime <- base::Sys.time()
[17:46:36.407]             {
[17:46:36.407]                 {
[17:46:36.407]                   {
[17:46:36.407]                     base::local({
[17:46:36.407]                       has_future <- base::requireNamespace("future", 
[17:46:36.407]                         quietly = TRUE)
[17:46:36.407]                       if (has_future) {
[17:46:36.407]                         ns <- base::getNamespace("future")
[17:46:36.407]                         version <- ns[[".package"]][["version"]]
[17:46:36.407]                         if (is.null(version)) 
[17:46:36.407]                           version <- utils::packageVersion("future")
[17:46:36.407]                       }
[17:46:36.407]                       else {
[17:46:36.407]                         version <- NULL
[17:46:36.407]                       }
[17:46:36.407]                       if (!has_future || version < "1.8.0") {
[17:46:36.407]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.407]                           "", base::R.version$version.string), 
[17:46:36.407]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:36.407]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.407]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.407]                             "release", "version")], collapse = " "), 
[17:46:36.407]                           hostname = base::Sys.info()[["nodename"]])
[17:46:36.407]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.407]                           info)
[17:46:36.407]                         info <- base::paste(info, collapse = "; ")
[17:46:36.407]                         if (!has_future) {
[17:46:36.407]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.407]                             info)
[17:46:36.407]                         }
[17:46:36.407]                         else {
[17:46:36.407]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.407]                             info, version)
[17:46:36.407]                         }
[17:46:36.407]                         base::stop(msg)
[17:46:36.407]                       }
[17:46:36.407]                     })
[17:46:36.407]                   }
[17:46:36.407]                   ...future.strategy.old <- future::plan("list")
[17:46:36.407]                   options(future.plan = NULL)
[17:46:36.407]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.407]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.407]                 }
[17:46:36.407]                 ...future.workdir <- getwd()
[17:46:36.407]             }
[17:46:36.407]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.407]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.407]         }
[17:46:36.407]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.407]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.407]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.407]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.407]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.407]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.407]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.407]             base::names(...future.oldOptions))
[17:46:36.407]     }
[17:46:36.407]     if (FALSE) {
[17:46:36.407]     }
[17:46:36.407]     else {
[17:46:36.407]         if (TRUE) {
[17:46:36.407]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.407]                 open = "w")
[17:46:36.407]         }
[17:46:36.407]         else {
[17:46:36.407]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.407]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.407]         }
[17:46:36.407]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.407]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.407]             base::sink(type = "output", split = FALSE)
[17:46:36.407]             base::close(...future.stdout)
[17:46:36.407]         }, add = TRUE)
[17:46:36.407]     }
[17:46:36.407]     ...future.frame <- base::sys.nframe()
[17:46:36.407]     ...future.conditions <- base::list()
[17:46:36.407]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.407]     if (FALSE) {
[17:46:36.407]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.407]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.407]     }
[17:46:36.407]     ...future.result <- base::tryCatch({
[17:46:36.407]         base::withCallingHandlers({
[17:46:36.407]             ...future.value <- base::withVisible(base::local({
[17:46:36.407]                 x <- 1
[17:46:36.407]             }))
[17:46:36.407]             future::FutureResult(value = ...future.value$value, 
[17:46:36.407]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.407]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.407]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.407]                     ...future.globalenv.names))
[17:46:36.407]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.407]         }, condition = base::local({
[17:46:36.407]             c <- base::c
[17:46:36.407]             inherits <- base::inherits
[17:46:36.407]             invokeRestart <- base::invokeRestart
[17:46:36.407]             length <- base::length
[17:46:36.407]             list <- base::list
[17:46:36.407]             seq.int <- base::seq.int
[17:46:36.407]             signalCondition <- base::signalCondition
[17:46:36.407]             sys.calls <- base::sys.calls
[17:46:36.407]             `[[` <- base::`[[`
[17:46:36.407]             `+` <- base::`+`
[17:46:36.407]             `<<-` <- base::`<<-`
[17:46:36.407]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.407]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.407]                   3L)]
[17:46:36.407]             }
[17:46:36.407]             function(cond) {
[17:46:36.407]                 is_error <- inherits(cond, "error")
[17:46:36.407]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.407]                   NULL)
[17:46:36.407]                 if (is_error) {
[17:46:36.407]                   sessionInformation <- function() {
[17:46:36.407]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.407]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.407]                       search = base::search(), system = base::Sys.info())
[17:46:36.407]                   }
[17:46:36.407]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.407]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.407]                     cond$call), session = sessionInformation(), 
[17:46:36.407]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.407]                   signalCondition(cond)
[17:46:36.407]                 }
[17:46:36.407]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.407]                 "immediateCondition"))) {
[17:46:36.407]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.407]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.407]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.407]                   if (TRUE && !signal) {
[17:46:36.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.407]                     {
[17:46:36.407]                       inherits <- base::inherits
[17:46:36.407]                       invokeRestart <- base::invokeRestart
[17:46:36.407]                       is.null <- base::is.null
[17:46:36.407]                       muffled <- FALSE
[17:46:36.407]                       if (inherits(cond, "message")) {
[17:46:36.407]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.407]                         if (muffled) 
[17:46:36.407]                           invokeRestart("muffleMessage")
[17:46:36.407]                       }
[17:46:36.407]                       else if (inherits(cond, "warning")) {
[17:46:36.407]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.407]                         if (muffled) 
[17:46:36.407]                           invokeRestart("muffleWarning")
[17:46:36.407]                       }
[17:46:36.407]                       else if (inherits(cond, "condition")) {
[17:46:36.407]                         if (!is.null(pattern)) {
[17:46:36.407]                           computeRestarts <- base::computeRestarts
[17:46:36.407]                           grepl <- base::grepl
[17:46:36.407]                           restarts <- computeRestarts(cond)
[17:46:36.407]                           for (restart in restarts) {
[17:46:36.407]                             name <- restart$name
[17:46:36.407]                             if (is.null(name)) 
[17:46:36.407]                               next
[17:46:36.407]                             if (!grepl(pattern, name)) 
[17:46:36.407]                               next
[17:46:36.407]                             invokeRestart(restart)
[17:46:36.407]                             muffled <- TRUE
[17:46:36.407]                             break
[17:46:36.407]                           }
[17:46:36.407]                         }
[17:46:36.407]                       }
[17:46:36.407]                       invisible(muffled)
[17:46:36.407]                     }
[17:46:36.407]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.407]                   }
[17:46:36.407]                 }
[17:46:36.407]                 else {
[17:46:36.407]                   if (TRUE) {
[17:46:36.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.407]                     {
[17:46:36.407]                       inherits <- base::inherits
[17:46:36.407]                       invokeRestart <- base::invokeRestart
[17:46:36.407]                       is.null <- base::is.null
[17:46:36.407]                       muffled <- FALSE
[17:46:36.407]                       if (inherits(cond, "message")) {
[17:46:36.407]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.407]                         if (muffled) 
[17:46:36.407]                           invokeRestart("muffleMessage")
[17:46:36.407]                       }
[17:46:36.407]                       else if (inherits(cond, "warning")) {
[17:46:36.407]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.407]                         if (muffled) 
[17:46:36.407]                           invokeRestart("muffleWarning")
[17:46:36.407]                       }
[17:46:36.407]                       else if (inherits(cond, "condition")) {
[17:46:36.407]                         if (!is.null(pattern)) {
[17:46:36.407]                           computeRestarts <- base::computeRestarts
[17:46:36.407]                           grepl <- base::grepl
[17:46:36.407]                           restarts <- computeRestarts(cond)
[17:46:36.407]                           for (restart in restarts) {
[17:46:36.407]                             name <- restart$name
[17:46:36.407]                             if (is.null(name)) 
[17:46:36.407]                               next
[17:46:36.407]                             if (!grepl(pattern, name)) 
[17:46:36.407]                               next
[17:46:36.407]                             invokeRestart(restart)
[17:46:36.407]                             muffled <- TRUE
[17:46:36.407]                             break
[17:46:36.407]                           }
[17:46:36.407]                         }
[17:46:36.407]                       }
[17:46:36.407]                       invisible(muffled)
[17:46:36.407]                     }
[17:46:36.407]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.407]                   }
[17:46:36.407]                 }
[17:46:36.407]             }
[17:46:36.407]         }))
[17:46:36.407]     }, error = function(ex) {
[17:46:36.407]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.407]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.407]                 ...future.rng), started = ...future.startTime, 
[17:46:36.407]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.407]             version = "1.8"), class = "FutureResult")
[17:46:36.407]     }, finally = {
[17:46:36.407]         if (!identical(...future.workdir, getwd())) 
[17:46:36.407]             setwd(...future.workdir)
[17:46:36.407]         {
[17:46:36.407]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.407]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.407]             }
[17:46:36.407]             base::options(...future.oldOptions)
[17:46:36.407]             if (.Platform$OS.type == "windows") {
[17:46:36.407]                 old_names <- names(...future.oldEnvVars)
[17:46:36.407]                 envs <- base::Sys.getenv()
[17:46:36.407]                 names <- names(envs)
[17:46:36.407]                 common <- intersect(names, old_names)
[17:46:36.407]                 added <- setdiff(names, old_names)
[17:46:36.407]                 removed <- setdiff(old_names, names)
[17:46:36.407]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.407]                   envs[common]]
[17:46:36.407]                 NAMES <- toupper(changed)
[17:46:36.407]                 args <- list()
[17:46:36.407]                 for (kk in seq_along(NAMES)) {
[17:46:36.407]                   name <- changed[[kk]]
[17:46:36.407]                   NAME <- NAMES[[kk]]
[17:46:36.407]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.407]                     next
[17:46:36.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.407]                 }
[17:46:36.407]                 NAMES <- toupper(added)
[17:46:36.407]                 for (kk in seq_along(NAMES)) {
[17:46:36.407]                   name <- added[[kk]]
[17:46:36.407]                   NAME <- NAMES[[kk]]
[17:46:36.407]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.407]                     next
[17:46:36.407]                   args[[name]] <- ""
[17:46:36.407]                 }
[17:46:36.407]                 NAMES <- toupper(removed)
[17:46:36.407]                 for (kk in seq_along(NAMES)) {
[17:46:36.407]                   name <- removed[[kk]]
[17:46:36.407]                   NAME <- NAMES[[kk]]
[17:46:36.407]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.407]                     next
[17:46:36.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.407]                 }
[17:46:36.407]                 if (length(args) > 0) 
[17:46:36.407]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.407]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.407]             }
[17:46:36.407]             else {
[17:46:36.407]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.407]             }
[17:46:36.407]             {
[17:46:36.407]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.407]                   0L) {
[17:46:36.407]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.407]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.407]                   base::options(opts)
[17:46:36.407]                 }
[17:46:36.407]                 {
[17:46:36.407]                   {
[17:46:36.407]                     NULL
[17:46:36.407]                     RNGkind("Mersenne-Twister")
[17:46:36.407]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.407]                       inherits = FALSE)
[17:46:36.407]                   }
[17:46:36.407]                   options(future.plan = NULL)
[17:46:36.407]                   if (is.na(NA_character_)) 
[17:46:36.407]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.407]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.407]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.407]                     .init = FALSE)
[17:46:36.407]                 }
[17:46:36.407]             }
[17:46:36.407]         }
[17:46:36.407]     })
[17:46:36.407]     if (TRUE) {
[17:46:36.407]         base::sink(type = "output", split = FALSE)
[17:46:36.407]         if (TRUE) {
[17:46:36.407]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.407]         }
[17:46:36.407]         else {
[17:46:36.407]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.407]         }
[17:46:36.407]         base::close(...future.stdout)
[17:46:36.407]         ...future.stdout <- NULL
[17:46:36.407]     }
[17:46:36.407]     ...future.result$conditions <- ...future.conditions
[17:46:36.407]     ...future.result$finished <- base::Sys.time()
[17:46:36.407]     ...future.result
[17:46:36.407] }
[17:46:36.409] plan(): Setting new future strategy stack:
[17:46:36.409] List of future strategies:
[17:46:36.409] 1. sequential:
[17:46:36.409]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.409]    - tweaked: FALSE
[17:46:36.409]    - call: NULL
[17:46:36.410] plan(): nbrOfWorkers() = 1
[17:46:36.411] plan(): Setting new future strategy stack:
[17:46:36.411] List of future strategies:
[17:46:36.411] 1. sequential:
[17:46:36.411]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.411]    - tweaked: FALSE
[17:46:36.411]    - call: plan(strategy)
[17:46:36.411] plan(): nbrOfWorkers() = 1
[17:46:36.411] SequentialFuture started (and completed)
[17:46:36.412] - Launch lazy future ... done
[17:46:36.412] run() for ‘SequentialFuture’ ... done
** Future evaluation with globals
[17:46:36.413] getGlobalsAndPackages() ...
[17:46:36.413] Searching for globals...
[17:46:36.414] - globals found: [3] ‘{’, ‘<-’, ‘a’
[17:46:36.414] Searching for globals ... DONE
[17:46:36.414] Resolving globals: FALSE
[17:46:36.414] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:36.415] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:46:36.415] - globals: [1] ‘a’
[17:46:36.415] 
[17:46:36.415] getGlobalsAndPackages() ... DONE
[17:46:36.415] run() for ‘Future’ ...
[17:46:36.415] - state: ‘created’
[17:46:36.416] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.416] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.416] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.416]   - Field: ‘label’
[17:46:36.416]   - Field: ‘local’
[17:46:36.416]   - Field: ‘owner’
[17:46:36.416]   - Field: ‘envir’
[17:46:36.416]   - Field: ‘packages’
[17:46:36.417]   - Field: ‘gc’
[17:46:36.417]   - Field: ‘conditions’
[17:46:36.417]   - Field: ‘expr’
[17:46:36.417]   - Field: ‘uuid’
[17:46:36.417]   - Field: ‘seed’
[17:46:36.417]   - Field: ‘version’
[17:46:36.417]   - Field: ‘result’
[17:46:36.417]   - Field: ‘asynchronous’
[17:46:36.417]   - Field: ‘calls’
[17:46:36.417]   - Field: ‘globals’
[17:46:36.417]   - Field: ‘stdout’
[17:46:36.417]   - Field: ‘earlySignal’
[17:46:36.418]   - Field: ‘lazy’
[17:46:36.418]   - Field: ‘state’
[17:46:36.418] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.418] - Launch lazy future ...
[17:46:36.418] Packages needed by the future expression (n = 0): <none>
[17:46:36.418] Packages needed by future strategies (n = 0): <none>
[17:46:36.418] {
[17:46:36.418]     {
[17:46:36.418]         {
[17:46:36.418]             ...future.startTime <- base::Sys.time()
[17:46:36.418]             {
[17:46:36.418]                 {
[17:46:36.418]                   {
[17:46:36.418]                     base::local({
[17:46:36.418]                       has_future <- base::requireNamespace("future", 
[17:46:36.418]                         quietly = TRUE)
[17:46:36.418]                       if (has_future) {
[17:46:36.418]                         ns <- base::getNamespace("future")
[17:46:36.418]                         version <- ns[[".package"]][["version"]]
[17:46:36.418]                         if (is.null(version)) 
[17:46:36.418]                           version <- utils::packageVersion("future")
[17:46:36.418]                       }
[17:46:36.418]                       else {
[17:46:36.418]                         version <- NULL
[17:46:36.418]                       }
[17:46:36.418]                       if (!has_future || version < "1.8.0") {
[17:46:36.418]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.418]                           "", base::R.version$version.string), 
[17:46:36.418]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:36.418]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.418]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.418]                             "release", "version")], collapse = " "), 
[17:46:36.418]                           hostname = base::Sys.info()[["nodename"]])
[17:46:36.418]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.418]                           info)
[17:46:36.418]                         info <- base::paste(info, collapse = "; ")
[17:46:36.418]                         if (!has_future) {
[17:46:36.418]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.418]                             info)
[17:46:36.418]                         }
[17:46:36.418]                         else {
[17:46:36.418]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.418]                             info, version)
[17:46:36.418]                         }
[17:46:36.418]                         base::stop(msg)
[17:46:36.418]                       }
[17:46:36.418]                     })
[17:46:36.418]                   }
[17:46:36.418]                   ...future.strategy.old <- future::plan("list")
[17:46:36.418]                   options(future.plan = NULL)
[17:46:36.418]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.418]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.418]                 }
[17:46:36.418]                 ...future.workdir <- getwd()
[17:46:36.418]             }
[17:46:36.418]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.418]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.418]         }
[17:46:36.418]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.418]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.418]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.418]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.418]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.418]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.418]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.418]             base::names(...future.oldOptions))
[17:46:36.418]     }
[17:46:36.418]     if (FALSE) {
[17:46:36.418]     }
[17:46:36.418]     else {
[17:46:36.418]         if (TRUE) {
[17:46:36.418]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.418]                 open = "w")
[17:46:36.418]         }
[17:46:36.418]         else {
[17:46:36.418]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.418]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.418]         }
[17:46:36.418]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.418]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.418]             base::sink(type = "output", split = FALSE)
[17:46:36.418]             base::close(...future.stdout)
[17:46:36.418]         }, add = TRUE)
[17:46:36.418]     }
[17:46:36.418]     ...future.frame <- base::sys.nframe()
[17:46:36.418]     ...future.conditions <- base::list()
[17:46:36.418]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.418]     if (FALSE) {
[17:46:36.418]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.418]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.418]     }
[17:46:36.418]     ...future.result <- base::tryCatch({
[17:46:36.418]         base::withCallingHandlers({
[17:46:36.418]             ...future.value <- base::withVisible(base::local({
[17:46:36.418]                 x <- a
[17:46:36.418]             }))
[17:46:36.418]             future::FutureResult(value = ...future.value$value, 
[17:46:36.418]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.418]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.418]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.418]                     ...future.globalenv.names))
[17:46:36.418]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.418]         }, condition = base::local({
[17:46:36.418]             c <- base::c
[17:46:36.418]             inherits <- base::inherits
[17:46:36.418]             invokeRestart <- base::invokeRestart
[17:46:36.418]             length <- base::length
[17:46:36.418]             list <- base::list
[17:46:36.418]             seq.int <- base::seq.int
[17:46:36.418]             signalCondition <- base::signalCondition
[17:46:36.418]             sys.calls <- base::sys.calls
[17:46:36.418]             `[[` <- base::`[[`
[17:46:36.418]             `+` <- base::`+`
[17:46:36.418]             `<<-` <- base::`<<-`
[17:46:36.418]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.418]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.418]                   3L)]
[17:46:36.418]             }
[17:46:36.418]             function(cond) {
[17:46:36.418]                 is_error <- inherits(cond, "error")
[17:46:36.418]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.418]                   NULL)
[17:46:36.418]                 if (is_error) {
[17:46:36.418]                   sessionInformation <- function() {
[17:46:36.418]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.418]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.418]                       search = base::search(), system = base::Sys.info())
[17:46:36.418]                   }
[17:46:36.418]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.418]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.418]                     cond$call), session = sessionInformation(), 
[17:46:36.418]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.418]                   signalCondition(cond)
[17:46:36.418]                 }
[17:46:36.418]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.418]                 "immediateCondition"))) {
[17:46:36.418]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.418]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.418]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.418]                   if (TRUE && !signal) {
[17:46:36.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.418]                     {
[17:46:36.418]                       inherits <- base::inherits
[17:46:36.418]                       invokeRestart <- base::invokeRestart
[17:46:36.418]                       is.null <- base::is.null
[17:46:36.418]                       muffled <- FALSE
[17:46:36.418]                       if (inherits(cond, "message")) {
[17:46:36.418]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.418]                         if (muffled) 
[17:46:36.418]                           invokeRestart("muffleMessage")
[17:46:36.418]                       }
[17:46:36.418]                       else if (inherits(cond, "warning")) {
[17:46:36.418]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.418]                         if (muffled) 
[17:46:36.418]                           invokeRestart("muffleWarning")
[17:46:36.418]                       }
[17:46:36.418]                       else if (inherits(cond, "condition")) {
[17:46:36.418]                         if (!is.null(pattern)) {
[17:46:36.418]                           computeRestarts <- base::computeRestarts
[17:46:36.418]                           grepl <- base::grepl
[17:46:36.418]                           restarts <- computeRestarts(cond)
[17:46:36.418]                           for (restart in restarts) {
[17:46:36.418]                             name <- restart$name
[17:46:36.418]                             if (is.null(name)) 
[17:46:36.418]                               next
[17:46:36.418]                             if (!grepl(pattern, name)) 
[17:46:36.418]                               next
[17:46:36.418]                             invokeRestart(restart)
[17:46:36.418]                             muffled <- TRUE
[17:46:36.418]                             break
[17:46:36.418]                           }
[17:46:36.418]                         }
[17:46:36.418]                       }
[17:46:36.418]                       invisible(muffled)
[17:46:36.418]                     }
[17:46:36.418]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.418]                   }
[17:46:36.418]                 }
[17:46:36.418]                 else {
[17:46:36.418]                   if (TRUE) {
[17:46:36.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.418]                     {
[17:46:36.418]                       inherits <- base::inherits
[17:46:36.418]                       invokeRestart <- base::invokeRestart
[17:46:36.418]                       is.null <- base::is.null
[17:46:36.418]                       muffled <- FALSE
[17:46:36.418]                       if (inherits(cond, "message")) {
[17:46:36.418]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.418]                         if (muffled) 
[17:46:36.418]                           invokeRestart("muffleMessage")
[17:46:36.418]                       }
[17:46:36.418]                       else if (inherits(cond, "warning")) {
[17:46:36.418]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.418]                         if (muffled) 
[17:46:36.418]                           invokeRestart("muffleWarning")
[17:46:36.418]                       }
[17:46:36.418]                       else if (inherits(cond, "condition")) {
[17:46:36.418]                         if (!is.null(pattern)) {
[17:46:36.418]                           computeRestarts <- base::computeRestarts
[17:46:36.418]                           grepl <- base::grepl
[17:46:36.418]                           restarts <- computeRestarts(cond)
[17:46:36.418]                           for (restart in restarts) {
[17:46:36.418]                             name <- restart$name
[17:46:36.418]                             if (is.null(name)) 
[17:46:36.418]                               next
[17:46:36.418]                             if (!grepl(pattern, name)) 
[17:46:36.418]                               next
[17:46:36.418]                             invokeRestart(restart)
[17:46:36.418]                             muffled <- TRUE
[17:46:36.418]                             break
[17:46:36.418]                           }
[17:46:36.418]                         }
[17:46:36.418]                       }
[17:46:36.418]                       invisible(muffled)
[17:46:36.418]                     }
[17:46:36.418]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.418]                   }
[17:46:36.418]                 }
[17:46:36.418]             }
[17:46:36.418]         }))
[17:46:36.418]     }, error = function(ex) {
[17:46:36.418]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.418]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.418]                 ...future.rng), started = ...future.startTime, 
[17:46:36.418]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.418]             version = "1.8"), class = "FutureResult")
[17:46:36.418]     }, finally = {
[17:46:36.418]         if (!identical(...future.workdir, getwd())) 
[17:46:36.418]             setwd(...future.workdir)
[17:46:36.418]         {
[17:46:36.418]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.418]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.418]             }
[17:46:36.418]             base::options(...future.oldOptions)
[17:46:36.418]             if (.Platform$OS.type == "windows") {
[17:46:36.418]                 old_names <- names(...future.oldEnvVars)
[17:46:36.418]                 envs <- base::Sys.getenv()
[17:46:36.418]                 names <- names(envs)
[17:46:36.418]                 common <- intersect(names, old_names)
[17:46:36.418]                 added <- setdiff(names, old_names)
[17:46:36.418]                 removed <- setdiff(old_names, names)
[17:46:36.418]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.418]                   envs[common]]
[17:46:36.418]                 NAMES <- toupper(changed)
[17:46:36.418]                 args <- list()
[17:46:36.418]                 for (kk in seq_along(NAMES)) {
[17:46:36.418]                   name <- changed[[kk]]
[17:46:36.418]                   NAME <- NAMES[[kk]]
[17:46:36.418]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.418]                     next
[17:46:36.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.418]                 }
[17:46:36.418]                 NAMES <- toupper(added)
[17:46:36.418]                 for (kk in seq_along(NAMES)) {
[17:46:36.418]                   name <- added[[kk]]
[17:46:36.418]                   NAME <- NAMES[[kk]]
[17:46:36.418]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.418]                     next
[17:46:36.418]                   args[[name]] <- ""
[17:46:36.418]                 }
[17:46:36.418]                 NAMES <- toupper(removed)
[17:46:36.418]                 for (kk in seq_along(NAMES)) {
[17:46:36.418]                   name <- removed[[kk]]
[17:46:36.418]                   NAME <- NAMES[[kk]]
[17:46:36.418]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.418]                     next
[17:46:36.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.418]                 }
[17:46:36.418]                 if (length(args) > 0) 
[17:46:36.418]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.418]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.418]             }
[17:46:36.418]             else {
[17:46:36.418]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.418]             }
[17:46:36.418]             {
[17:46:36.418]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.418]                   0L) {
[17:46:36.418]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.418]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.418]                   base::options(opts)
[17:46:36.418]                 }
[17:46:36.418]                 {
[17:46:36.418]                   {
[17:46:36.418]                     NULL
[17:46:36.418]                     RNGkind("Mersenne-Twister")
[17:46:36.418]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.418]                       inherits = FALSE)
[17:46:36.418]                   }
[17:46:36.418]                   options(future.plan = NULL)
[17:46:36.418]                   if (is.na(NA_character_)) 
[17:46:36.418]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.418]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.418]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.418]                     .init = FALSE)
[17:46:36.418]                 }
[17:46:36.418]             }
[17:46:36.418]         }
[17:46:36.418]     })
[17:46:36.418]     if (TRUE) {
[17:46:36.418]         base::sink(type = "output", split = FALSE)
[17:46:36.418]         if (TRUE) {
[17:46:36.418]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.418]         }
[17:46:36.418]         else {
[17:46:36.418]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.418]         }
[17:46:36.418]         base::close(...future.stdout)
[17:46:36.418]         ...future.stdout <- NULL
[17:46:36.418]     }
[17:46:36.418]     ...future.result$conditions <- ...future.conditions
[17:46:36.418]     ...future.result$finished <- base::Sys.time()
[17:46:36.418]     ...future.result
[17:46:36.418] }
[17:46:36.420] assign_globals() ...
[17:46:36.420] List of 1
[17:46:36.420]  $ a: num 2
[17:46:36.420]  - attr(*, "where")=List of 1
[17:46:36.420]   ..$ a:<environment: R_EmptyEnv> 
[17:46:36.420]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:36.420]  - attr(*, "resolved")= logi FALSE
[17:46:36.420]  - attr(*, "total_size")= num 56
[17:46:36.420]  - attr(*, "already-done")= logi TRUE
[17:46:36.425] - copied ‘a’ to environment
[17:46:36.425] assign_globals() ... done
[17:46:36.425] plan(): Setting new future strategy stack:
[17:46:36.425] List of future strategies:
[17:46:36.425] 1. sequential:
[17:46:36.425]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.425]    - tweaked: FALSE
[17:46:36.425]    - call: NULL
[17:46:36.426] plan(): nbrOfWorkers() = 1
[17:46:36.426] plan(): Setting new future strategy stack:
[17:46:36.426] List of future strategies:
[17:46:36.426] 1. sequential:
[17:46:36.426]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.426]    - tweaked: FALSE
[17:46:36.426]    - call: plan(strategy)
[17:46:36.427] plan(): nbrOfWorkers() = 1
[17:46:36.427] SequentialFuture started (and completed)
[17:46:36.427] - Launch lazy future ... done
[17:46:36.427] run() for ‘SequentialFuture’ ... done
** Future evaluation with errors
[17:46:36.428] getGlobalsAndPackages() ...
[17:46:36.428] Searching for globals...
[17:46:36.433] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[17:46:36.433] Searching for globals ... DONE
[17:46:36.434] Resolving globals: FALSE
[17:46:36.434] 
[17:46:36.434] 
[17:46:36.434] getGlobalsAndPackages() ... DONE
[17:46:36.434] run() for ‘Future’ ...
[17:46:36.434] - state: ‘created’
[17:46:36.434] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.435] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.435] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.435]   - Field: ‘label’
[17:46:36.435]   - Field: ‘local’
[17:46:36.435]   - Field: ‘owner’
[17:46:36.435]   - Field: ‘envir’
[17:46:36.435]   - Field: ‘packages’
[17:46:36.435]   - Field: ‘gc’
[17:46:36.436]   - Field: ‘conditions’
[17:46:36.436]   - Field: ‘expr’
[17:46:36.436]   - Field: ‘uuid’
[17:46:36.436]   - Field: ‘seed’
[17:46:36.436]   - Field: ‘version’
[17:46:36.436]   - Field: ‘result’
[17:46:36.436]   - Field: ‘asynchronous’
[17:46:36.436]   - Field: ‘calls’
[17:46:36.436]   - Field: ‘globals’
[17:46:36.436]   - Field: ‘stdout’
[17:46:36.436]   - Field: ‘earlySignal’
[17:46:36.436]   - Field: ‘lazy’
[17:46:36.437]   - Field: ‘state’
[17:46:36.437] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.437] - Launch lazy future ...
[17:46:36.437] Packages needed by the future expression (n = 0): <none>
[17:46:36.437] Packages needed by future strategies (n = 0): <none>
[17:46:36.437] {
[17:46:36.437]     {
[17:46:36.437]         {
[17:46:36.437]             ...future.startTime <- base::Sys.time()
[17:46:36.437]             {
[17:46:36.437]                 {
[17:46:36.437]                   {
[17:46:36.437]                     base::local({
[17:46:36.437]                       has_future <- base::requireNamespace("future", 
[17:46:36.437]                         quietly = TRUE)
[17:46:36.437]                       if (has_future) {
[17:46:36.437]                         ns <- base::getNamespace("future")
[17:46:36.437]                         version <- ns[[".package"]][["version"]]
[17:46:36.437]                         if (is.null(version)) 
[17:46:36.437]                           version <- utils::packageVersion("future")
[17:46:36.437]                       }
[17:46:36.437]                       else {
[17:46:36.437]                         version <- NULL
[17:46:36.437]                       }
[17:46:36.437]                       if (!has_future || version < "1.8.0") {
[17:46:36.437]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.437]                           "", base::R.version$version.string), 
[17:46:36.437]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:36.437]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.437]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.437]                             "release", "version")], collapse = " "), 
[17:46:36.437]                           hostname = base::Sys.info()[["nodename"]])
[17:46:36.437]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.437]                           info)
[17:46:36.437]                         info <- base::paste(info, collapse = "; ")
[17:46:36.437]                         if (!has_future) {
[17:46:36.437]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.437]                             info)
[17:46:36.437]                         }
[17:46:36.437]                         else {
[17:46:36.437]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.437]                             info, version)
[17:46:36.437]                         }
[17:46:36.437]                         base::stop(msg)
[17:46:36.437]                       }
[17:46:36.437]                     })
[17:46:36.437]                   }
[17:46:36.437]                   ...future.strategy.old <- future::plan("list")
[17:46:36.437]                   options(future.plan = NULL)
[17:46:36.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.437]                 }
[17:46:36.437]                 ...future.workdir <- getwd()
[17:46:36.437]             }
[17:46:36.437]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.437]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.437]         }
[17:46:36.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.437]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.437]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.437]             base::names(...future.oldOptions))
[17:46:36.437]     }
[17:46:36.437]     if (FALSE) {
[17:46:36.437]     }
[17:46:36.437]     else {
[17:46:36.437]         if (TRUE) {
[17:46:36.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.437]                 open = "w")
[17:46:36.437]         }
[17:46:36.437]         else {
[17:46:36.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.437]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.437]         }
[17:46:36.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.437]             base::sink(type = "output", split = FALSE)
[17:46:36.437]             base::close(...future.stdout)
[17:46:36.437]         }, add = TRUE)
[17:46:36.437]     }
[17:46:36.437]     ...future.frame <- base::sys.nframe()
[17:46:36.437]     ...future.conditions <- base::list()
[17:46:36.437]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.437]     if (FALSE) {
[17:46:36.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.437]     }
[17:46:36.437]     ...future.result <- base::tryCatch({
[17:46:36.437]         base::withCallingHandlers({
[17:46:36.437]             ...future.value <- base::withVisible(base::local({
[17:46:36.437]                 x <- 3
[17:46:36.437]                 stop("Woops!")
[17:46:36.437]                 x
[17:46:36.437]             }))
[17:46:36.437]             future::FutureResult(value = ...future.value$value, 
[17:46:36.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.437]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.437]                     ...future.globalenv.names))
[17:46:36.437]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.437]         }, condition = base::local({
[17:46:36.437]             c <- base::c
[17:46:36.437]             inherits <- base::inherits
[17:46:36.437]             invokeRestart <- base::invokeRestart
[17:46:36.437]             length <- base::length
[17:46:36.437]             list <- base::list
[17:46:36.437]             seq.int <- base::seq.int
[17:46:36.437]             signalCondition <- base::signalCondition
[17:46:36.437]             sys.calls <- base::sys.calls
[17:46:36.437]             `[[` <- base::`[[`
[17:46:36.437]             `+` <- base::`+`
[17:46:36.437]             `<<-` <- base::`<<-`
[17:46:36.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.437]                   3L)]
[17:46:36.437]             }
[17:46:36.437]             function(cond) {
[17:46:36.437]                 is_error <- inherits(cond, "error")
[17:46:36.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.437]                   NULL)
[17:46:36.437]                 if (is_error) {
[17:46:36.437]                   sessionInformation <- function() {
[17:46:36.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.437]                       search = base::search(), system = base::Sys.info())
[17:46:36.437]                   }
[17:46:36.437]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.437]                     cond$call), session = sessionInformation(), 
[17:46:36.437]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.437]                   signalCondition(cond)
[17:46:36.437]                 }
[17:46:36.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.437]                 "immediateCondition"))) {
[17:46:36.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.437]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.437]                   if (TRUE && !signal) {
[17:46:36.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.437]                     {
[17:46:36.437]                       inherits <- base::inherits
[17:46:36.437]                       invokeRestart <- base::invokeRestart
[17:46:36.437]                       is.null <- base::is.null
[17:46:36.437]                       muffled <- FALSE
[17:46:36.437]                       if (inherits(cond, "message")) {
[17:46:36.437]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.437]                         if (muffled) 
[17:46:36.437]                           invokeRestart("muffleMessage")
[17:46:36.437]                       }
[17:46:36.437]                       else if (inherits(cond, "warning")) {
[17:46:36.437]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.437]                         if (muffled) 
[17:46:36.437]                           invokeRestart("muffleWarning")
[17:46:36.437]                       }
[17:46:36.437]                       else if (inherits(cond, "condition")) {
[17:46:36.437]                         if (!is.null(pattern)) {
[17:46:36.437]                           computeRestarts <- base::computeRestarts
[17:46:36.437]                           grepl <- base::grepl
[17:46:36.437]                           restarts <- computeRestarts(cond)
[17:46:36.437]                           for (restart in restarts) {
[17:46:36.437]                             name <- restart$name
[17:46:36.437]                             if (is.null(name)) 
[17:46:36.437]                               next
[17:46:36.437]                             if (!grepl(pattern, name)) 
[17:46:36.437]                               next
[17:46:36.437]                             invokeRestart(restart)
[17:46:36.437]                             muffled <- TRUE
[17:46:36.437]                             break
[17:46:36.437]                           }
[17:46:36.437]                         }
[17:46:36.437]                       }
[17:46:36.437]                       invisible(muffled)
[17:46:36.437]                     }
[17:46:36.437]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.437]                   }
[17:46:36.437]                 }
[17:46:36.437]                 else {
[17:46:36.437]                   if (TRUE) {
[17:46:36.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.437]                     {
[17:46:36.437]                       inherits <- base::inherits
[17:46:36.437]                       invokeRestart <- base::invokeRestart
[17:46:36.437]                       is.null <- base::is.null
[17:46:36.437]                       muffled <- FALSE
[17:46:36.437]                       if (inherits(cond, "message")) {
[17:46:36.437]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.437]                         if (muffled) 
[17:46:36.437]                           invokeRestart("muffleMessage")
[17:46:36.437]                       }
[17:46:36.437]                       else if (inherits(cond, "warning")) {
[17:46:36.437]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.437]                         if (muffled) 
[17:46:36.437]                           invokeRestart("muffleWarning")
[17:46:36.437]                       }
[17:46:36.437]                       else if (inherits(cond, "condition")) {
[17:46:36.437]                         if (!is.null(pattern)) {
[17:46:36.437]                           computeRestarts <- base::computeRestarts
[17:46:36.437]                           grepl <- base::grepl
[17:46:36.437]                           restarts <- computeRestarts(cond)
[17:46:36.437]                           for (restart in restarts) {
[17:46:36.437]                             name <- restart$name
[17:46:36.437]                             if (is.null(name)) 
[17:46:36.437]                               next
[17:46:36.437]                             if (!grepl(pattern, name)) 
[17:46:36.437]                               next
[17:46:36.437]                             invokeRestart(restart)
[17:46:36.437]                             muffled <- TRUE
[17:46:36.437]                             break
[17:46:36.437]                           }
[17:46:36.437]                         }
[17:46:36.437]                       }
[17:46:36.437]                       invisible(muffled)
[17:46:36.437]                     }
[17:46:36.437]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.437]                   }
[17:46:36.437]                 }
[17:46:36.437]             }
[17:46:36.437]         }))
[17:46:36.437]     }, error = function(ex) {
[17:46:36.437]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.437]                 ...future.rng), started = ...future.startTime, 
[17:46:36.437]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.437]             version = "1.8"), class = "FutureResult")
[17:46:36.437]     }, finally = {
[17:46:36.437]         if (!identical(...future.workdir, getwd())) 
[17:46:36.437]             setwd(...future.workdir)
[17:46:36.437]         {
[17:46:36.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.437]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.437]             }
[17:46:36.437]             base::options(...future.oldOptions)
[17:46:36.437]             if (.Platform$OS.type == "windows") {
[17:46:36.437]                 old_names <- names(...future.oldEnvVars)
[17:46:36.437]                 envs <- base::Sys.getenv()
[17:46:36.437]                 names <- names(envs)
[17:46:36.437]                 common <- intersect(names, old_names)
[17:46:36.437]                 added <- setdiff(names, old_names)
[17:46:36.437]                 removed <- setdiff(old_names, names)
[17:46:36.437]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.437]                   envs[common]]
[17:46:36.437]                 NAMES <- toupper(changed)
[17:46:36.437]                 args <- list()
[17:46:36.437]                 for (kk in seq_along(NAMES)) {
[17:46:36.437]                   name <- changed[[kk]]
[17:46:36.437]                   NAME <- NAMES[[kk]]
[17:46:36.437]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.437]                     next
[17:46:36.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.437]                 }
[17:46:36.437]                 NAMES <- toupper(added)
[17:46:36.437]                 for (kk in seq_along(NAMES)) {
[17:46:36.437]                   name <- added[[kk]]
[17:46:36.437]                   NAME <- NAMES[[kk]]
[17:46:36.437]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.437]                     next
[17:46:36.437]                   args[[name]] <- ""
[17:46:36.437]                 }
[17:46:36.437]                 NAMES <- toupper(removed)
[17:46:36.437]                 for (kk in seq_along(NAMES)) {
[17:46:36.437]                   name <- removed[[kk]]
[17:46:36.437]                   NAME <- NAMES[[kk]]
[17:46:36.437]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.437]                     next
[17:46:36.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.437]                 }
[17:46:36.437]                 if (length(args) > 0) 
[17:46:36.437]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.437]             }
[17:46:36.437]             else {
[17:46:36.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.437]             }
[17:46:36.437]             {
[17:46:36.437]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.437]                   0L) {
[17:46:36.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.437]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.437]                   base::options(opts)
[17:46:36.437]                 }
[17:46:36.437]                 {
[17:46:36.437]                   {
[17:46:36.437]                     NULL
[17:46:36.437]                     RNGkind("Mersenne-Twister")
[17:46:36.437]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.437]                       inherits = FALSE)
[17:46:36.437]                   }
[17:46:36.437]                   options(future.plan = NULL)
[17:46:36.437]                   if (is.na(NA_character_)) 
[17:46:36.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.437]                     .init = FALSE)
[17:46:36.437]                 }
[17:46:36.437]             }
[17:46:36.437]         }
[17:46:36.437]     })
[17:46:36.437]     if (TRUE) {
[17:46:36.437]         base::sink(type = "output", split = FALSE)
[17:46:36.437]         if (TRUE) {
[17:46:36.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.437]         }
[17:46:36.437]         else {
[17:46:36.437]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.437]         }
[17:46:36.437]         base::close(...future.stdout)
[17:46:36.437]         ...future.stdout <- NULL
[17:46:36.437]     }
[17:46:36.437]     ...future.result$conditions <- ...future.conditions
[17:46:36.437]     ...future.result$finished <- base::Sys.time()
[17:46:36.437]     ...future.result
[17:46:36.437] }
[17:46:36.439] plan(): Setting new future strategy stack:
[17:46:36.439] List of future strategies:
[17:46:36.439] 1. sequential:
[17:46:36.439]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.439]    - tweaked: FALSE
[17:46:36.439]    - call: NULL
[17:46:36.440] plan(): nbrOfWorkers() = 1
[17:46:36.440] plan(): Setting new future strategy stack:
[17:46:36.441] List of future strategies:
[17:46:36.441] 1. sequential:
[17:46:36.441]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.441]    - tweaked: FALSE
[17:46:36.441]    - call: plan(strategy)
[17:46:36.441] plan(): nbrOfWorkers() = 1
[17:46:36.441] SequentialFuture started (and completed)
[17:46:36.441] signalConditions() ...
[17:46:36.441]  - include = ‘immediateCondition’
[17:46:36.441]  - exclude = 
[17:46:36.442]  - resignal = FALSE
[17:46:36.442]  - Number of conditions: 1
[17:46:36.442] signalConditions() ... done
[17:46:36.442] - Launch lazy future ... done
[17:46:36.442] run() for ‘SequentialFuture’ ... done
[17:46:36.442] signalConditions() ...
[17:46:36.442]  - include = ‘immediateCondition’
[17:46:36.442]  - exclude = 
[17:46:36.442]  - resignal = FALSE
[17:46:36.442]  - Number of conditions: 1
[17:46:36.442] signalConditions() ... done
[17:46:36.443] Future state: ‘finished’
[17:46:36.443] signalConditions() ...
[17:46:36.443]  - include = ‘condition’
[17:46:36.443]  - exclude = ‘immediateCondition’
[17:46:36.443]  - resignal = TRUE
[17:46:36.443]  - Number of conditions: 1
[17:46:36.443]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:36.443] signalConditions() ... done
[17:46:36.444] getGlobalsAndPackages() ...
[17:46:36.444] Searching for globals...
[17:46:36.446] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:46:36.446] Searching for globals ... DONE
[17:46:36.446] Resolving globals: FALSE
[17:46:36.446] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:36.447] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:46:36.447] - globals: [1] ‘ii’
[17:46:36.447] 
[17:46:36.447] getGlobalsAndPackages() ... DONE
[17:46:36.447] run() for ‘Future’ ...
[17:46:36.447] - state: ‘created’
[17:46:36.447] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.448] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.448] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.448]   - Field: ‘label’
[17:46:36.448]   - Field: ‘local’
[17:46:36.448]   - Field: ‘owner’
[17:46:36.448]   - Field: ‘envir’
[17:46:36.448]   - Field: ‘packages’
[17:46:36.448]   - Field: ‘gc’
[17:46:36.448]   - Field: ‘conditions’
[17:46:36.448]   - Field: ‘expr’
[17:46:36.449]   - Field: ‘uuid’
[17:46:36.449]   - Field: ‘seed’
[17:46:36.449]   - Field: ‘version’
[17:46:36.449]   - Field: ‘result’
[17:46:36.449]   - Field: ‘asynchronous’
[17:46:36.449]   - Field: ‘calls’
[17:46:36.449]   - Field: ‘globals’
[17:46:36.449]   - Field: ‘stdout’
[17:46:36.449]   - Field: ‘earlySignal’
[17:46:36.449]   - Field: ‘lazy’
[17:46:36.449]   - Field: ‘state’
[17:46:36.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.450] - Launch lazy future ...
[17:46:36.450] Packages needed by the future expression (n = 0): <none>
[17:46:36.450] Packages needed by future strategies (n = 0): <none>
[17:46:36.450] {
[17:46:36.450]     {
[17:46:36.450]         {
[17:46:36.450]             ...future.startTime <- base::Sys.time()
[17:46:36.450]             {
[17:46:36.450]                 {
[17:46:36.450]                   {
[17:46:36.450]                     base::local({
[17:46:36.450]                       has_future <- base::requireNamespace("future", 
[17:46:36.450]                         quietly = TRUE)
[17:46:36.450]                       if (has_future) {
[17:46:36.450]                         ns <- base::getNamespace("future")
[17:46:36.450]                         version <- ns[[".package"]][["version"]]
[17:46:36.450]                         if (is.null(version)) 
[17:46:36.450]                           version <- utils::packageVersion("future")
[17:46:36.450]                       }
[17:46:36.450]                       else {
[17:46:36.450]                         version <- NULL
[17:46:36.450]                       }
[17:46:36.450]                       if (!has_future || version < "1.8.0") {
[17:46:36.450]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.450]                           "", base::R.version$version.string), 
[17:46:36.450]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:36.450]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.450]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.450]                             "release", "version")], collapse = " "), 
[17:46:36.450]                           hostname = base::Sys.info()[["nodename"]])
[17:46:36.450]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.450]                           info)
[17:46:36.450]                         info <- base::paste(info, collapse = "; ")
[17:46:36.450]                         if (!has_future) {
[17:46:36.450]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.450]                             info)
[17:46:36.450]                         }
[17:46:36.450]                         else {
[17:46:36.450]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.450]                             info, version)
[17:46:36.450]                         }
[17:46:36.450]                         base::stop(msg)
[17:46:36.450]                       }
[17:46:36.450]                     })
[17:46:36.450]                   }
[17:46:36.450]                   ...future.strategy.old <- future::plan("list")
[17:46:36.450]                   options(future.plan = NULL)
[17:46:36.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.450]                 }
[17:46:36.450]                 ...future.workdir <- getwd()
[17:46:36.450]             }
[17:46:36.450]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.450]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.450]         }
[17:46:36.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.450]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.450]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.450]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.450]             base::names(...future.oldOptions))
[17:46:36.450]     }
[17:46:36.450]     if (FALSE) {
[17:46:36.450]     }
[17:46:36.450]     else {
[17:46:36.450]         if (TRUE) {
[17:46:36.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.450]                 open = "w")
[17:46:36.450]         }
[17:46:36.450]         else {
[17:46:36.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.450]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.450]         }
[17:46:36.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.450]             base::sink(type = "output", split = FALSE)
[17:46:36.450]             base::close(...future.stdout)
[17:46:36.450]         }, add = TRUE)
[17:46:36.450]     }
[17:46:36.450]     ...future.frame <- base::sys.nframe()
[17:46:36.450]     ...future.conditions <- base::list()
[17:46:36.450]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.450]     if (FALSE) {
[17:46:36.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.450]     }
[17:46:36.450]     ...future.result <- base::tryCatch({
[17:46:36.450]         base::withCallingHandlers({
[17:46:36.450]             ...future.value <- base::withVisible(base::local({
[17:46:36.450]                 if (ii%%2 == 0) 
[17:46:36.450]                   stop("Woops!")
[17:46:36.450]                 ii
[17:46:36.450]             }))
[17:46:36.450]             future::FutureResult(value = ...future.value$value, 
[17:46:36.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.450]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.450]                     ...future.globalenv.names))
[17:46:36.450]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.450]         }, condition = base::local({
[17:46:36.450]             c <- base::c
[17:46:36.450]             inherits <- base::inherits
[17:46:36.450]             invokeRestart <- base::invokeRestart
[17:46:36.450]             length <- base::length
[17:46:36.450]             list <- base::list
[17:46:36.450]             seq.int <- base::seq.int
[17:46:36.450]             signalCondition <- base::signalCondition
[17:46:36.450]             sys.calls <- base::sys.calls
[17:46:36.450]             `[[` <- base::`[[`
[17:46:36.450]             `+` <- base::`+`
[17:46:36.450]             `<<-` <- base::`<<-`
[17:46:36.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.450]                   3L)]
[17:46:36.450]             }
[17:46:36.450]             function(cond) {
[17:46:36.450]                 is_error <- inherits(cond, "error")
[17:46:36.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.450]                   NULL)
[17:46:36.450]                 if (is_error) {
[17:46:36.450]                   sessionInformation <- function() {
[17:46:36.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.450]                       search = base::search(), system = base::Sys.info())
[17:46:36.450]                   }
[17:46:36.450]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.450]                     cond$call), session = sessionInformation(), 
[17:46:36.450]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.450]                   signalCondition(cond)
[17:46:36.450]                 }
[17:46:36.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.450]                 "immediateCondition"))) {
[17:46:36.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.450]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.450]                   if (TRUE && !signal) {
[17:46:36.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.450]                     {
[17:46:36.450]                       inherits <- base::inherits
[17:46:36.450]                       invokeRestart <- base::invokeRestart
[17:46:36.450]                       is.null <- base::is.null
[17:46:36.450]                       muffled <- FALSE
[17:46:36.450]                       if (inherits(cond, "message")) {
[17:46:36.450]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.450]                         if (muffled) 
[17:46:36.450]                           invokeRestart("muffleMessage")
[17:46:36.450]                       }
[17:46:36.450]                       else if (inherits(cond, "warning")) {
[17:46:36.450]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.450]                         if (muffled) 
[17:46:36.450]                           invokeRestart("muffleWarning")
[17:46:36.450]                       }
[17:46:36.450]                       else if (inherits(cond, "condition")) {
[17:46:36.450]                         if (!is.null(pattern)) {
[17:46:36.450]                           computeRestarts <- base::computeRestarts
[17:46:36.450]                           grepl <- base::grepl
[17:46:36.450]                           restarts <- computeRestarts(cond)
[17:46:36.450]                           for (restart in restarts) {
[17:46:36.450]                             name <- restart$name
[17:46:36.450]                             if (is.null(name)) 
[17:46:36.450]                               next
[17:46:36.450]                             if (!grepl(pattern, name)) 
[17:46:36.450]                               next
[17:46:36.450]                             invokeRestart(restart)
[17:46:36.450]                             muffled <- TRUE
[17:46:36.450]                             break
[17:46:36.450]                           }
[17:46:36.450]                         }
[17:46:36.450]                       }
[17:46:36.450]                       invisible(muffled)
[17:46:36.450]                     }
[17:46:36.450]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.450]                   }
[17:46:36.450]                 }
[17:46:36.450]                 else {
[17:46:36.450]                   if (TRUE) {
[17:46:36.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.450]                     {
[17:46:36.450]                       inherits <- base::inherits
[17:46:36.450]                       invokeRestart <- base::invokeRestart
[17:46:36.450]                       is.null <- base::is.null
[17:46:36.450]                       muffled <- FALSE
[17:46:36.450]                       if (inherits(cond, "message")) {
[17:46:36.450]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.450]                         if (muffled) 
[17:46:36.450]                           invokeRestart("muffleMessage")
[17:46:36.450]                       }
[17:46:36.450]                       else if (inherits(cond, "warning")) {
[17:46:36.450]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.450]                         if (muffled) 
[17:46:36.450]                           invokeRestart("muffleWarning")
[17:46:36.450]                       }
[17:46:36.450]                       else if (inherits(cond, "condition")) {
[17:46:36.450]                         if (!is.null(pattern)) {
[17:46:36.450]                           computeRestarts <- base::computeRestarts
[17:46:36.450]                           grepl <- base::grepl
[17:46:36.450]                           restarts <- computeRestarts(cond)
[17:46:36.450]                           for (restart in restarts) {
[17:46:36.450]                             name <- restart$name
[17:46:36.450]                             if (is.null(name)) 
[17:46:36.450]                               next
[17:46:36.450]                             if (!grepl(pattern, name)) 
[17:46:36.450]                               next
[17:46:36.450]                             invokeRestart(restart)
[17:46:36.450]                             muffled <- TRUE
[17:46:36.450]                             break
[17:46:36.450]                           }
[17:46:36.450]                         }
[17:46:36.450]                       }
[17:46:36.450]                       invisible(muffled)
[17:46:36.450]                     }
[17:46:36.450]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.450]                   }
[17:46:36.450]                 }
[17:46:36.450]             }
[17:46:36.450]         }))
[17:46:36.450]     }, error = function(ex) {
[17:46:36.450]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.450]                 ...future.rng), started = ...future.startTime, 
[17:46:36.450]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.450]             version = "1.8"), class = "FutureResult")
[17:46:36.450]     }, finally = {
[17:46:36.450]         if (!identical(...future.workdir, getwd())) 
[17:46:36.450]             setwd(...future.workdir)
[17:46:36.450]         {
[17:46:36.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.450]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.450]             }
[17:46:36.450]             base::options(...future.oldOptions)
[17:46:36.450]             if (.Platform$OS.type == "windows") {
[17:46:36.450]                 old_names <- names(...future.oldEnvVars)
[17:46:36.450]                 envs <- base::Sys.getenv()
[17:46:36.450]                 names <- names(envs)
[17:46:36.450]                 common <- intersect(names, old_names)
[17:46:36.450]                 added <- setdiff(names, old_names)
[17:46:36.450]                 removed <- setdiff(old_names, names)
[17:46:36.450]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.450]                   envs[common]]
[17:46:36.450]                 NAMES <- toupper(changed)
[17:46:36.450]                 args <- list()
[17:46:36.450]                 for (kk in seq_along(NAMES)) {
[17:46:36.450]                   name <- changed[[kk]]
[17:46:36.450]                   NAME <- NAMES[[kk]]
[17:46:36.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.450]                     next
[17:46:36.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.450]                 }
[17:46:36.450]                 NAMES <- toupper(added)
[17:46:36.450]                 for (kk in seq_along(NAMES)) {
[17:46:36.450]                   name <- added[[kk]]
[17:46:36.450]                   NAME <- NAMES[[kk]]
[17:46:36.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.450]                     next
[17:46:36.450]                   args[[name]] <- ""
[17:46:36.450]                 }
[17:46:36.450]                 NAMES <- toupper(removed)
[17:46:36.450]                 for (kk in seq_along(NAMES)) {
[17:46:36.450]                   name <- removed[[kk]]
[17:46:36.450]                   NAME <- NAMES[[kk]]
[17:46:36.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.450]                     next
[17:46:36.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.450]                 }
[17:46:36.450]                 if (length(args) > 0) 
[17:46:36.450]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.450]             }
[17:46:36.450]             else {
[17:46:36.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.450]             }
[17:46:36.450]             {
[17:46:36.450]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.450]                   0L) {
[17:46:36.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.450]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.450]                   base::options(opts)
[17:46:36.450]                 }
[17:46:36.450]                 {
[17:46:36.450]                   {
[17:46:36.450]                     NULL
[17:46:36.450]                     RNGkind("Mersenne-Twister")
[17:46:36.450]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.450]                       inherits = FALSE)
[17:46:36.450]                   }
[17:46:36.450]                   options(future.plan = NULL)
[17:46:36.450]                   if (is.na(NA_character_)) 
[17:46:36.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.450]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.450]                     .init = FALSE)
[17:46:36.450]                 }
[17:46:36.450]             }
[17:46:36.450]         }
[17:46:36.450]     })
[17:46:36.450]     if (TRUE) {
[17:46:36.450]         base::sink(type = "output", split = FALSE)
[17:46:36.450]         if (TRUE) {
[17:46:36.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.450]         }
[17:46:36.450]         else {
[17:46:36.450]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.450]         }
[17:46:36.450]         base::close(...future.stdout)
[17:46:36.450]         ...future.stdout <- NULL
[17:46:36.450]     }
[17:46:36.450]     ...future.result$conditions <- ...future.conditions
[17:46:36.450]     ...future.result$finished <- base::Sys.time()
[17:46:36.450]     ...future.result
[17:46:36.450] }
[17:46:36.452] assign_globals() ...
[17:46:36.452] List of 1
[17:46:36.452]  $ ii: int 1
[17:46:36.452]  - attr(*, "where")=List of 1
[17:46:36.452]   ..$ ii:<environment: R_EmptyEnv> 
[17:46:36.452]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:36.452]  - attr(*, "resolved")= logi FALSE
[17:46:36.452]  - attr(*, "total_size")= num 56
[17:46:36.452]  - attr(*, "already-done")= logi TRUE
[17:46:36.454] - copied ‘ii’ to environment
[17:46:36.454] assign_globals() ... done
[17:46:36.454] plan(): Setting new future strategy stack:
[17:46:36.455] List of future strategies:
[17:46:36.455] 1. sequential:
[17:46:36.455]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.455]    - tweaked: FALSE
[17:46:36.455]    - call: NULL
[17:46:36.455] plan(): nbrOfWorkers() = 1
[17:46:36.456] plan(): Setting new future strategy stack:
[17:46:36.456] List of future strategies:
[17:46:36.456] 1. sequential:
[17:46:36.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.456]    - tweaked: FALSE
[17:46:36.456]    - call: plan(strategy)
[17:46:36.456] plan(): nbrOfWorkers() = 1
[17:46:36.456] SequentialFuture started (and completed)
[17:46:36.456] - Launch lazy future ... done
[17:46:36.457] run() for ‘SequentialFuture’ ... done
[17:46:36.457] getGlobalsAndPackages() ...
[17:46:36.457] Searching for globals...
[17:46:36.458] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:46:36.458] Searching for globals ... DONE
[17:46:36.459] Resolving globals: FALSE
[17:46:36.459] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:36.459] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:46:36.459] - globals: [1] ‘ii’
[17:46:36.459] 
[17:46:36.461] getGlobalsAndPackages() ... DONE
[17:46:36.461] run() for ‘Future’ ...
[17:46:36.461] - state: ‘created’
[17:46:36.461] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.461] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.462]   - Field: ‘label’
[17:46:36.462]   - Field: ‘local’
[17:46:36.462]   - Field: ‘owner’
[17:46:36.462]   - Field: ‘envir’
[17:46:36.462]   - Field: ‘packages’
[17:46:36.462]   - Field: ‘gc’
[17:46:36.462]   - Field: ‘conditions’
[17:46:36.462]   - Field: ‘expr’
[17:46:36.462]   - Field: ‘uuid’
[17:46:36.463]   - Field: ‘seed’
[17:46:36.463]   - Field: ‘version’
[17:46:36.463]   - Field: ‘result’
[17:46:36.463]   - Field: ‘asynchronous’
[17:46:36.463]   - Field: ‘calls’
[17:46:36.463]   - Field: ‘globals’
[17:46:36.463]   - Field: ‘stdout’
[17:46:36.463]   - Field: ‘earlySignal’
[17:46:36.463]   - Field: ‘lazy’
[17:46:36.463]   - Field: ‘state’
[17:46:36.463] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.464] - Launch lazy future ...
[17:46:36.464] Packages needed by the future expression (n = 0): <none>
[17:46:36.464] Packages needed by future strategies (n = 0): <none>
[17:46:36.464] {
[17:46:36.464]     {
[17:46:36.464]         {
[17:46:36.464]             ...future.startTime <- base::Sys.time()
[17:46:36.464]             {
[17:46:36.464]                 {
[17:46:36.464]                   {
[17:46:36.464]                     base::local({
[17:46:36.464]                       has_future <- base::requireNamespace("future", 
[17:46:36.464]                         quietly = TRUE)
[17:46:36.464]                       if (has_future) {
[17:46:36.464]                         ns <- base::getNamespace("future")
[17:46:36.464]                         version <- ns[[".package"]][["version"]]
[17:46:36.464]                         if (is.null(version)) 
[17:46:36.464]                           version <- utils::packageVersion("future")
[17:46:36.464]                       }
[17:46:36.464]                       else {
[17:46:36.464]                         version <- NULL
[17:46:36.464]                       }
[17:46:36.464]                       if (!has_future || version < "1.8.0") {
[17:46:36.464]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.464]                           "", base::R.version$version.string), 
[17:46:36.464]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:36.464]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.464]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.464]                             "release", "version")], collapse = " "), 
[17:46:36.464]                           hostname = base::Sys.info()[["nodename"]])
[17:46:36.464]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.464]                           info)
[17:46:36.464]                         info <- base::paste(info, collapse = "; ")
[17:46:36.464]                         if (!has_future) {
[17:46:36.464]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.464]                             info)
[17:46:36.464]                         }
[17:46:36.464]                         else {
[17:46:36.464]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.464]                             info, version)
[17:46:36.464]                         }
[17:46:36.464]                         base::stop(msg)
[17:46:36.464]                       }
[17:46:36.464]                     })
[17:46:36.464]                   }
[17:46:36.464]                   ...future.strategy.old <- future::plan("list")
[17:46:36.464]                   options(future.plan = NULL)
[17:46:36.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.464]                 }
[17:46:36.464]                 ...future.workdir <- getwd()
[17:46:36.464]             }
[17:46:36.464]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.464]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.464]         }
[17:46:36.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.464]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.464]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.464]             base::names(...future.oldOptions))
[17:46:36.464]     }
[17:46:36.464]     if (FALSE) {
[17:46:36.464]     }
[17:46:36.464]     else {
[17:46:36.464]         if (TRUE) {
[17:46:36.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.464]                 open = "w")
[17:46:36.464]         }
[17:46:36.464]         else {
[17:46:36.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.464]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.464]         }
[17:46:36.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.464]             base::sink(type = "output", split = FALSE)
[17:46:36.464]             base::close(...future.stdout)
[17:46:36.464]         }, add = TRUE)
[17:46:36.464]     }
[17:46:36.464]     ...future.frame <- base::sys.nframe()
[17:46:36.464]     ...future.conditions <- base::list()
[17:46:36.464]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.464]     if (FALSE) {
[17:46:36.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.464]     }
[17:46:36.464]     ...future.result <- base::tryCatch({
[17:46:36.464]         base::withCallingHandlers({
[17:46:36.464]             ...future.value <- base::withVisible(base::local({
[17:46:36.464]                 if (ii%%2 == 0) 
[17:46:36.464]                   stop("Woops!")
[17:46:36.464]                 ii
[17:46:36.464]             }))
[17:46:36.464]             future::FutureResult(value = ...future.value$value, 
[17:46:36.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.464]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.464]                     ...future.globalenv.names))
[17:46:36.464]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.464]         }, condition = base::local({
[17:46:36.464]             c <- base::c
[17:46:36.464]             inherits <- base::inherits
[17:46:36.464]             invokeRestart <- base::invokeRestart
[17:46:36.464]             length <- base::length
[17:46:36.464]             list <- base::list
[17:46:36.464]             seq.int <- base::seq.int
[17:46:36.464]             signalCondition <- base::signalCondition
[17:46:36.464]             sys.calls <- base::sys.calls
[17:46:36.464]             `[[` <- base::`[[`
[17:46:36.464]             `+` <- base::`+`
[17:46:36.464]             `<<-` <- base::`<<-`
[17:46:36.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.464]                   3L)]
[17:46:36.464]             }
[17:46:36.464]             function(cond) {
[17:46:36.464]                 is_error <- inherits(cond, "error")
[17:46:36.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.464]                   NULL)
[17:46:36.464]                 if (is_error) {
[17:46:36.464]                   sessionInformation <- function() {
[17:46:36.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.464]                       search = base::search(), system = base::Sys.info())
[17:46:36.464]                   }
[17:46:36.464]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.464]                     cond$call), session = sessionInformation(), 
[17:46:36.464]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.464]                   signalCondition(cond)
[17:46:36.464]                 }
[17:46:36.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.464]                 "immediateCondition"))) {
[17:46:36.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.464]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.464]                   if (TRUE && !signal) {
[17:46:36.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.464]                     {
[17:46:36.464]                       inherits <- base::inherits
[17:46:36.464]                       invokeRestart <- base::invokeRestart
[17:46:36.464]                       is.null <- base::is.null
[17:46:36.464]                       muffled <- FALSE
[17:46:36.464]                       if (inherits(cond, "message")) {
[17:46:36.464]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.464]                         if (muffled) 
[17:46:36.464]                           invokeRestart("muffleMessage")
[17:46:36.464]                       }
[17:46:36.464]                       else if (inherits(cond, "warning")) {
[17:46:36.464]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.464]                         if (muffled) 
[17:46:36.464]                           invokeRestart("muffleWarning")
[17:46:36.464]                       }
[17:46:36.464]                       else if (inherits(cond, "condition")) {
[17:46:36.464]                         if (!is.null(pattern)) {
[17:46:36.464]                           computeRestarts <- base::computeRestarts
[17:46:36.464]                           grepl <- base::grepl
[17:46:36.464]                           restarts <- computeRestarts(cond)
[17:46:36.464]                           for (restart in restarts) {
[17:46:36.464]                             name <- restart$name
[17:46:36.464]                             if (is.null(name)) 
[17:46:36.464]                               next
[17:46:36.464]                             if (!grepl(pattern, name)) 
[17:46:36.464]                               next
[17:46:36.464]                             invokeRestart(restart)
[17:46:36.464]                             muffled <- TRUE
[17:46:36.464]                             break
[17:46:36.464]                           }
[17:46:36.464]                         }
[17:46:36.464]                       }
[17:46:36.464]                       invisible(muffled)
[17:46:36.464]                     }
[17:46:36.464]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.464]                   }
[17:46:36.464]                 }
[17:46:36.464]                 else {
[17:46:36.464]                   if (TRUE) {
[17:46:36.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.464]                     {
[17:46:36.464]                       inherits <- base::inherits
[17:46:36.464]                       invokeRestart <- base::invokeRestart
[17:46:36.464]                       is.null <- base::is.null
[17:46:36.464]                       muffled <- FALSE
[17:46:36.464]                       if (inherits(cond, "message")) {
[17:46:36.464]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.464]                         if (muffled) 
[17:46:36.464]                           invokeRestart("muffleMessage")
[17:46:36.464]                       }
[17:46:36.464]                       else if (inherits(cond, "warning")) {
[17:46:36.464]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.464]                         if (muffled) 
[17:46:36.464]                           invokeRestart("muffleWarning")
[17:46:36.464]                       }
[17:46:36.464]                       else if (inherits(cond, "condition")) {
[17:46:36.464]                         if (!is.null(pattern)) {
[17:46:36.464]                           computeRestarts <- base::computeRestarts
[17:46:36.464]                           grepl <- base::grepl
[17:46:36.464]                           restarts <- computeRestarts(cond)
[17:46:36.464]                           for (restart in restarts) {
[17:46:36.464]                             name <- restart$name
[17:46:36.464]                             if (is.null(name)) 
[17:46:36.464]                               next
[17:46:36.464]                             if (!grepl(pattern, name)) 
[17:46:36.464]                               next
[17:46:36.464]                             invokeRestart(restart)
[17:46:36.464]                             muffled <- TRUE
[17:46:36.464]                             break
[17:46:36.464]                           }
[17:46:36.464]                         }
[17:46:36.464]                       }
[17:46:36.464]                       invisible(muffled)
[17:46:36.464]                     }
[17:46:36.464]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.464]                   }
[17:46:36.464]                 }
[17:46:36.464]             }
[17:46:36.464]         }))
[17:46:36.464]     }, error = function(ex) {
[17:46:36.464]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.464]                 ...future.rng), started = ...future.startTime, 
[17:46:36.464]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.464]             version = "1.8"), class = "FutureResult")
[17:46:36.464]     }, finally = {
[17:46:36.464]         if (!identical(...future.workdir, getwd())) 
[17:46:36.464]             setwd(...future.workdir)
[17:46:36.464]         {
[17:46:36.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.464]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.464]             }
[17:46:36.464]             base::options(...future.oldOptions)
[17:46:36.464]             if (.Platform$OS.type == "windows") {
[17:46:36.464]                 old_names <- names(...future.oldEnvVars)
[17:46:36.464]                 envs <- base::Sys.getenv()
[17:46:36.464]                 names <- names(envs)
[17:46:36.464]                 common <- intersect(names, old_names)
[17:46:36.464]                 added <- setdiff(names, old_names)
[17:46:36.464]                 removed <- setdiff(old_names, names)
[17:46:36.464]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.464]                   envs[common]]
[17:46:36.464]                 NAMES <- toupper(changed)
[17:46:36.464]                 args <- list()
[17:46:36.464]                 for (kk in seq_along(NAMES)) {
[17:46:36.464]                   name <- changed[[kk]]
[17:46:36.464]                   NAME <- NAMES[[kk]]
[17:46:36.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.464]                     next
[17:46:36.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.464]                 }
[17:46:36.464]                 NAMES <- toupper(added)
[17:46:36.464]                 for (kk in seq_along(NAMES)) {
[17:46:36.464]                   name <- added[[kk]]
[17:46:36.464]                   NAME <- NAMES[[kk]]
[17:46:36.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.464]                     next
[17:46:36.464]                   args[[name]] <- ""
[17:46:36.464]                 }
[17:46:36.464]                 NAMES <- toupper(removed)
[17:46:36.464]                 for (kk in seq_along(NAMES)) {
[17:46:36.464]                   name <- removed[[kk]]
[17:46:36.464]                   NAME <- NAMES[[kk]]
[17:46:36.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.464]                     next
[17:46:36.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.464]                 }
[17:46:36.464]                 if (length(args) > 0) 
[17:46:36.464]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.464]             }
[17:46:36.464]             else {
[17:46:36.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.464]             }
[17:46:36.464]             {
[17:46:36.464]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.464]                   0L) {
[17:46:36.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.464]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.464]                   base::options(opts)
[17:46:36.464]                 }
[17:46:36.464]                 {
[17:46:36.464]                   {
[17:46:36.464]                     NULL
[17:46:36.464]                     RNGkind("Mersenne-Twister")
[17:46:36.464]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.464]                       inherits = FALSE)
[17:46:36.464]                   }
[17:46:36.464]                   options(future.plan = NULL)
[17:46:36.464]                   if (is.na(NA_character_)) 
[17:46:36.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.464]                     .init = FALSE)
[17:46:36.464]                 }
[17:46:36.464]             }
[17:46:36.464]         }
[17:46:36.464]     })
[17:46:36.464]     if (TRUE) {
[17:46:36.464]         base::sink(type = "output", split = FALSE)
[17:46:36.464]         if (TRUE) {
[17:46:36.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.464]         }
[17:46:36.464]         else {
[17:46:36.464]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.464]         }
[17:46:36.464]         base::close(...future.stdout)
[17:46:36.464]         ...future.stdout <- NULL
[17:46:36.464]     }
[17:46:36.464]     ...future.result$conditions <- ...future.conditions
[17:46:36.464]     ...future.result$finished <- base::Sys.time()
[17:46:36.464]     ...future.result
[17:46:36.464] }
[17:46:36.466] assign_globals() ...
[17:46:36.466] List of 1
[17:46:36.466]  $ ii: int 2
[17:46:36.466]  - attr(*, "where")=List of 1
[17:46:36.466]   ..$ ii:<environment: R_EmptyEnv> 
[17:46:36.466]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:36.466]  - attr(*, "resolved")= logi FALSE
[17:46:36.466]  - attr(*, "total_size")= num 56
[17:46:36.466]  - attr(*, "already-done")= logi TRUE
[17:46:36.468] - copied ‘ii’ to environment
[17:46:36.468] assign_globals() ... done
[17:46:36.468] plan(): Setting new future strategy stack:
[17:46:36.468] List of future strategies:
[17:46:36.468] 1. sequential:
[17:46:36.468]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.468]    - tweaked: FALSE
[17:46:36.468]    - call: NULL
[17:46:36.469] plan(): nbrOfWorkers() = 1
[17:46:36.470] plan(): Setting new future strategy stack:
[17:46:36.470] List of future strategies:
[17:46:36.470] 1. sequential:
[17:46:36.470]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.470]    - tweaked: FALSE
[17:46:36.470]    - call: plan(strategy)
[17:46:36.470] plan(): nbrOfWorkers() = 1
[17:46:36.470] SequentialFuture started (and completed)
[17:46:36.470] signalConditions() ...
[17:46:36.471]  - include = ‘immediateCondition’
[17:46:36.471]  - exclude = 
[17:46:36.471]  - resignal = FALSE
[17:46:36.471]  - Number of conditions: 1
[17:46:36.471] signalConditions() ... done
[17:46:36.471] - Launch lazy future ... done
[17:46:36.471] run() for ‘SequentialFuture’ ... done
[17:46:36.471] getGlobalsAndPackages() ...
[17:46:36.471] Searching for globals...
[17:46:36.473] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:46:36.473] Searching for globals ... DONE
[17:46:36.473] Resolving globals: FALSE
[17:46:36.473] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:36.474] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:46:36.474] - globals: [1] ‘ii’
[17:46:36.474] 
[17:46:36.474] getGlobalsAndPackages() ... DONE
[17:46:36.474] run() for ‘Future’ ...
[17:46:36.474] - state: ‘created’
[17:46:36.474] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.475] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.475] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.475]   - Field: ‘label’
[17:46:36.475]   - Field: ‘local’
[17:46:36.475]   - Field: ‘owner’
[17:46:36.475]   - Field: ‘envir’
[17:46:36.475]   - Field: ‘packages’
[17:46:36.475]   - Field: ‘gc’
[17:46:36.475]   - Field: ‘conditions’
[17:46:36.476]   - Field: ‘expr’
[17:46:36.476]   - Field: ‘uuid’
[17:46:36.476]   - Field: ‘seed’
[17:46:36.476]   - Field: ‘version’
[17:46:36.476]   - Field: ‘result’
[17:46:36.476]   - Field: ‘asynchronous’
[17:46:36.476]   - Field: ‘calls’
[17:46:36.476]   - Field: ‘globals’
[17:46:36.476]   - Field: ‘stdout’
[17:46:36.476]   - Field: ‘earlySignal’
[17:46:36.476]   - Field: ‘lazy’
[17:46:36.477]   - Field: ‘state’
[17:46:36.477] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.477] - Launch lazy future ...
[17:46:36.477] Packages needed by the future expression (n = 0): <none>
[17:46:36.477] Packages needed by future strategies (n = 0): <none>
[17:46:36.477] {
[17:46:36.477]     {
[17:46:36.477]         {
[17:46:36.477]             ...future.startTime <- base::Sys.time()
[17:46:36.477]             {
[17:46:36.477]                 {
[17:46:36.477]                   {
[17:46:36.477]                     base::local({
[17:46:36.477]                       has_future <- base::requireNamespace("future", 
[17:46:36.477]                         quietly = TRUE)
[17:46:36.477]                       if (has_future) {
[17:46:36.477]                         ns <- base::getNamespace("future")
[17:46:36.477]                         version <- ns[[".package"]][["version"]]
[17:46:36.477]                         if (is.null(version)) 
[17:46:36.477]                           version <- utils::packageVersion("future")
[17:46:36.477]                       }
[17:46:36.477]                       else {
[17:46:36.477]                         version <- NULL
[17:46:36.477]                       }
[17:46:36.477]                       if (!has_future || version < "1.8.0") {
[17:46:36.477]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.477]                           "", base::R.version$version.string), 
[17:46:36.477]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:36.477]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.477]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.477]                             "release", "version")], collapse = " "), 
[17:46:36.477]                           hostname = base::Sys.info()[["nodename"]])
[17:46:36.477]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.477]                           info)
[17:46:36.477]                         info <- base::paste(info, collapse = "; ")
[17:46:36.477]                         if (!has_future) {
[17:46:36.477]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.477]                             info)
[17:46:36.477]                         }
[17:46:36.477]                         else {
[17:46:36.477]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.477]                             info, version)
[17:46:36.477]                         }
[17:46:36.477]                         base::stop(msg)
[17:46:36.477]                       }
[17:46:36.477]                     })
[17:46:36.477]                   }
[17:46:36.477]                   ...future.strategy.old <- future::plan("list")
[17:46:36.477]                   options(future.plan = NULL)
[17:46:36.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.477]                 }
[17:46:36.477]                 ...future.workdir <- getwd()
[17:46:36.477]             }
[17:46:36.477]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.477]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.477]         }
[17:46:36.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.477]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.477]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.477]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.477]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.477]             base::names(...future.oldOptions))
[17:46:36.477]     }
[17:46:36.477]     if (FALSE) {
[17:46:36.477]     }
[17:46:36.477]     else {
[17:46:36.477]         if (TRUE) {
[17:46:36.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.477]                 open = "w")
[17:46:36.477]         }
[17:46:36.477]         else {
[17:46:36.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.477]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.477]         }
[17:46:36.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.477]             base::sink(type = "output", split = FALSE)
[17:46:36.477]             base::close(...future.stdout)
[17:46:36.477]         }, add = TRUE)
[17:46:36.477]     }
[17:46:36.477]     ...future.frame <- base::sys.nframe()
[17:46:36.477]     ...future.conditions <- base::list()
[17:46:36.477]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.477]     if (FALSE) {
[17:46:36.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.477]     }
[17:46:36.477]     ...future.result <- base::tryCatch({
[17:46:36.477]         base::withCallingHandlers({
[17:46:36.477]             ...future.value <- base::withVisible(base::local({
[17:46:36.477]                 if (ii%%2 == 0) 
[17:46:36.477]                   stop("Woops!")
[17:46:36.477]                 ii
[17:46:36.477]             }))
[17:46:36.477]             future::FutureResult(value = ...future.value$value, 
[17:46:36.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.477]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.477]                     ...future.globalenv.names))
[17:46:36.477]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.477]         }, condition = base::local({
[17:46:36.477]             c <- base::c
[17:46:36.477]             inherits <- base::inherits
[17:46:36.477]             invokeRestart <- base::invokeRestart
[17:46:36.477]             length <- base::length
[17:46:36.477]             list <- base::list
[17:46:36.477]             seq.int <- base::seq.int
[17:46:36.477]             signalCondition <- base::signalCondition
[17:46:36.477]             sys.calls <- base::sys.calls
[17:46:36.477]             `[[` <- base::`[[`
[17:46:36.477]             `+` <- base::`+`
[17:46:36.477]             `<<-` <- base::`<<-`
[17:46:36.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.477]                   3L)]
[17:46:36.477]             }
[17:46:36.477]             function(cond) {
[17:46:36.477]                 is_error <- inherits(cond, "error")
[17:46:36.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.477]                   NULL)
[17:46:36.477]                 if (is_error) {
[17:46:36.477]                   sessionInformation <- function() {
[17:46:36.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.477]                       search = base::search(), system = base::Sys.info())
[17:46:36.477]                   }
[17:46:36.477]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.477]                     cond$call), session = sessionInformation(), 
[17:46:36.477]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.477]                   signalCondition(cond)
[17:46:36.477]                 }
[17:46:36.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.477]                 "immediateCondition"))) {
[17:46:36.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.477]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.477]                   if (TRUE && !signal) {
[17:46:36.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.477]                     {
[17:46:36.477]                       inherits <- base::inherits
[17:46:36.477]                       invokeRestart <- base::invokeRestart
[17:46:36.477]                       is.null <- base::is.null
[17:46:36.477]                       muffled <- FALSE
[17:46:36.477]                       if (inherits(cond, "message")) {
[17:46:36.477]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.477]                         if (muffled) 
[17:46:36.477]                           invokeRestart("muffleMessage")
[17:46:36.477]                       }
[17:46:36.477]                       else if (inherits(cond, "warning")) {
[17:46:36.477]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.477]                         if (muffled) 
[17:46:36.477]                           invokeRestart("muffleWarning")
[17:46:36.477]                       }
[17:46:36.477]                       else if (inherits(cond, "condition")) {
[17:46:36.477]                         if (!is.null(pattern)) {
[17:46:36.477]                           computeRestarts <- base::computeRestarts
[17:46:36.477]                           grepl <- base::grepl
[17:46:36.477]                           restarts <- computeRestarts(cond)
[17:46:36.477]                           for (restart in restarts) {
[17:46:36.477]                             name <- restart$name
[17:46:36.477]                             if (is.null(name)) 
[17:46:36.477]                               next
[17:46:36.477]                             if (!grepl(pattern, name)) 
[17:46:36.477]                               next
[17:46:36.477]                             invokeRestart(restart)
[17:46:36.477]                             muffled <- TRUE
[17:46:36.477]                             break
[17:46:36.477]                           }
[17:46:36.477]                         }
[17:46:36.477]                       }
[17:46:36.477]                       invisible(muffled)
[17:46:36.477]                     }
[17:46:36.477]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.477]                   }
[17:46:36.477]                 }
[17:46:36.477]                 else {
[17:46:36.477]                   if (TRUE) {
[17:46:36.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.477]                     {
[17:46:36.477]                       inherits <- base::inherits
[17:46:36.477]                       invokeRestart <- base::invokeRestart
[17:46:36.477]                       is.null <- base::is.null
[17:46:36.477]                       muffled <- FALSE
[17:46:36.477]                       if (inherits(cond, "message")) {
[17:46:36.477]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.477]                         if (muffled) 
[17:46:36.477]                           invokeRestart("muffleMessage")
[17:46:36.477]                       }
[17:46:36.477]                       else if (inherits(cond, "warning")) {
[17:46:36.477]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.477]                         if (muffled) 
[17:46:36.477]                           invokeRestart("muffleWarning")
[17:46:36.477]                       }
[17:46:36.477]                       else if (inherits(cond, "condition")) {
[17:46:36.477]                         if (!is.null(pattern)) {
[17:46:36.477]                           computeRestarts <- base::computeRestarts
[17:46:36.477]                           grepl <- base::grepl
[17:46:36.477]                           restarts <- computeRestarts(cond)
[17:46:36.477]                           for (restart in restarts) {
[17:46:36.477]                             name <- restart$name
[17:46:36.477]                             if (is.null(name)) 
[17:46:36.477]                               next
[17:46:36.477]                             if (!grepl(pattern, name)) 
[17:46:36.477]                               next
[17:46:36.477]                             invokeRestart(restart)
[17:46:36.477]                             muffled <- TRUE
[17:46:36.477]                             break
[17:46:36.477]                           }
[17:46:36.477]                         }
[17:46:36.477]                       }
[17:46:36.477]                       invisible(muffled)
[17:46:36.477]                     }
[17:46:36.477]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.477]                   }
[17:46:36.477]                 }
[17:46:36.477]             }
[17:46:36.477]         }))
[17:46:36.477]     }, error = function(ex) {
[17:46:36.477]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.477]                 ...future.rng), started = ...future.startTime, 
[17:46:36.477]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.477]             version = "1.8"), class = "FutureResult")
[17:46:36.477]     }, finally = {
[17:46:36.477]         if (!identical(...future.workdir, getwd())) 
[17:46:36.477]             setwd(...future.workdir)
[17:46:36.477]         {
[17:46:36.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.477]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.477]             }
[17:46:36.477]             base::options(...future.oldOptions)
[17:46:36.477]             if (.Platform$OS.type == "windows") {
[17:46:36.477]                 old_names <- names(...future.oldEnvVars)
[17:46:36.477]                 envs <- base::Sys.getenv()
[17:46:36.477]                 names <- names(envs)
[17:46:36.477]                 common <- intersect(names, old_names)
[17:46:36.477]                 added <- setdiff(names, old_names)
[17:46:36.477]                 removed <- setdiff(old_names, names)
[17:46:36.477]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.477]                   envs[common]]
[17:46:36.477]                 NAMES <- toupper(changed)
[17:46:36.477]                 args <- list()
[17:46:36.477]                 for (kk in seq_along(NAMES)) {
[17:46:36.477]                   name <- changed[[kk]]
[17:46:36.477]                   NAME <- NAMES[[kk]]
[17:46:36.477]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.477]                     next
[17:46:36.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.477]                 }
[17:46:36.477]                 NAMES <- toupper(added)
[17:46:36.477]                 for (kk in seq_along(NAMES)) {
[17:46:36.477]                   name <- added[[kk]]
[17:46:36.477]                   NAME <- NAMES[[kk]]
[17:46:36.477]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.477]                     next
[17:46:36.477]                   args[[name]] <- ""
[17:46:36.477]                 }
[17:46:36.477]                 NAMES <- toupper(removed)
[17:46:36.477]                 for (kk in seq_along(NAMES)) {
[17:46:36.477]                   name <- removed[[kk]]
[17:46:36.477]                   NAME <- NAMES[[kk]]
[17:46:36.477]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.477]                     next
[17:46:36.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.477]                 }
[17:46:36.477]                 if (length(args) > 0) 
[17:46:36.477]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.477]             }
[17:46:36.477]             else {
[17:46:36.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.477]             }
[17:46:36.477]             {
[17:46:36.477]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.477]                   0L) {
[17:46:36.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.477]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.477]                   base::options(opts)
[17:46:36.477]                 }
[17:46:36.477]                 {
[17:46:36.477]                   {
[17:46:36.477]                     NULL
[17:46:36.477]                     RNGkind("Mersenne-Twister")
[17:46:36.477]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.477]                       inherits = FALSE)
[17:46:36.477]                   }
[17:46:36.477]                   options(future.plan = NULL)
[17:46:36.477]                   if (is.na(NA_character_)) 
[17:46:36.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.477]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.477]                     .init = FALSE)
[17:46:36.477]                 }
[17:46:36.477]             }
[17:46:36.477]         }
[17:46:36.477]     })
[17:46:36.477]     if (TRUE) {
[17:46:36.477]         base::sink(type = "output", split = FALSE)
[17:46:36.477]         if (TRUE) {
[17:46:36.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.477]         }
[17:46:36.477]         else {
[17:46:36.477]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.477]         }
[17:46:36.477]         base::close(...future.stdout)
[17:46:36.477]         ...future.stdout <- NULL
[17:46:36.477]     }
[17:46:36.477]     ...future.result$conditions <- ...future.conditions
[17:46:36.477]     ...future.result$finished <- base::Sys.time()
[17:46:36.477]     ...future.result
[17:46:36.477] }
[17:46:36.479] assign_globals() ...
[17:46:36.479] List of 1
[17:46:36.479]  $ ii: int 3
[17:46:36.479]  - attr(*, "where")=List of 1
[17:46:36.479]   ..$ ii:<environment: R_EmptyEnv> 
[17:46:36.479]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:36.479]  - attr(*, "resolved")= logi FALSE
[17:46:36.479]  - attr(*, "total_size")= num 56
[17:46:36.479]  - attr(*, "already-done")= logi TRUE
[17:46:36.481] - copied ‘ii’ to environment
[17:46:36.481] assign_globals() ... done
[17:46:36.482] plan(): Setting new future strategy stack:
[17:46:36.482] List of future strategies:
[17:46:36.482] 1. sequential:
[17:46:36.482]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.482]    - tweaked: FALSE
[17:46:36.482]    - call: NULL
[17:46:36.482] plan(): nbrOfWorkers() = 1
[17:46:36.483] plan(): Setting new future strategy stack:
[17:46:36.483] List of future strategies:
[17:46:36.483] 1. sequential:
[17:46:36.483]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.483]    - tweaked: FALSE
[17:46:36.483]    - call: plan(strategy)
[17:46:36.483] plan(): nbrOfWorkers() = 1
[17:46:36.483] SequentialFuture started (and completed)
[17:46:36.483] - Launch lazy future ... done
[17:46:36.484] run() for ‘SequentialFuture’ ... done
[17:46:36.484] signalConditions() ...
[17:46:36.484]  - include = ‘immediateCondition’
[17:46:36.484]  - exclude = 
[17:46:36.484]  - resignal = FALSE
[17:46:36.484]  - Number of conditions: 1
[17:46:36.484] signalConditions() ... done
[17:46:36.484] Future state: ‘finished’
[17:46:36.485] signalConditions() ...
[17:46:36.485]  - include = ‘condition’
[17:46:36.485]  - exclude = ‘immediateCondition’
[17:46:36.485]  - resignal = TRUE
[17:46:36.485]  - Number of conditions: 1
[17:46:36.485]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:36.485] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[17:46:36.486] signalConditions() ...
[17:46:36.486]  - include = ‘immediateCondition’
[17:46:36.486]  - exclude = 
[17:46:36.486]  - resignal = FALSE
[17:46:36.486]  - Number of conditions: 1
[17:46:36.487] signalConditions() ... done
[17:46:36.487] Future state: ‘finished’
[17:46:36.487] signalConditions() ...
[17:46:36.487]  - include = ‘condition’
[17:46:36.487]  - exclude = ‘immediateCondition’
[17:46:36.487]  - resignal = TRUE
[17:46:36.487]  - Number of conditions: 1
[17:46:36.487]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:36.487] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[17:46:36.488] signalConditions() ...
[17:46:36.489]  - include = ‘immediateCondition’
[17:46:36.489]  - exclude = 
[17:46:36.489]  - resignal = FALSE
[17:46:36.489]  - Number of conditions: 1
[17:46:36.489] signalConditions() ... done
[17:46:36.489] Future state: ‘finished’
[17:46:36.489] signalConditions() ...
[17:46:36.490]  - include = ‘condition’
[17:46:36.490]  - exclude = ‘immediateCondition’
[17:46:36.490]  - resignal = TRUE
[17:46:36.490]  - Number of conditions: 1
[17:46:36.490]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:36.490] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[17:46:36.490] getGlobalsAndPackages() ...
[17:46:36.490] Searching for globals...
[17:46:36.492] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[17:46:36.492] Searching for globals ... DONE
[17:46:36.492] Resolving globals: FALSE
[17:46:36.493] 
[17:46:36.493] 
[17:46:36.493] getGlobalsAndPackages() ... DONE
[17:46:36.493] run() for ‘Future’ ...
[17:46:36.493] - state: ‘created’
[17:46:36.493] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.494] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.494] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.494]   - Field: ‘label’
[17:46:36.494]   - Field: ‘local’
[17:46:36.494]   - Field: ‘owner’
[17:46:36.494]   - Field: ‘envir’
[17:46:36.494]   - Field: ‘packages’
[17:46:36.494]   - Field: ‘gc’
[17:46:36.494]   - Field: ‘conditions’
[17:46:36.494]   - Field: ‘expr’
[17:46:36.494]   - Field: ‘uuid’
[17:46:36.495]   - Field: ‘seed’
[17:46:36.495]   - Field: ‘version’
[17:46:36.495]   - Field: ‘result’
[17:46:36.495]   - Field: ‘asynchronous’
[17:46:36.495]   - Field: ‘calls’
[17:46:36.495]   - Field: ‘globals’
[17:46:36.495]   - Field: ‘stdout’
[17:46:36.495]   - Field: ‘earlySignal’
[17:46:36.495]   - Field: ‘lazy’
[17:46:36.495]   - Field: ‘state’
[17:46:36.495] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.496] - Launch lazy future ...
[17:46:36.496] Packages needed by the future expression (n = 0): <none>
[17:46:36.496] Packages needed by future strategies (n = 0): <none>
[17:46:36.496] {
[17:46:36.496]     {
[17:46:36.496]         {
[17:46:36.496]             ...future.startTime <- base::Sys.time()
[17:46:36.496]             {
[17:46:36.496]                 {
[17:46:36.496]                   {
[17:46:36.496]                     base::local({
[17:46:36.496]                       has_future <- base::requireNamespace("future", 
[17:46:36.496]                         quietly = TRUE)
[17:46:36.496]                       if (has_future) {
[17:46:36.496]                         ns <- base::getNamespace("future")
[17:46:36.496]                         version <- ns[[".package"]][["version"]]
[17:46:36.496]                         if (is.null(version)) 
[17:46:36.496]                           version <- utils::packageVersion("future")
[17:46:36.496]                       }
[17:46:36.496]                       else {
[17:46:36.496]                         version <- NULL
[17:46:36.496]                       }
[17:46:36.496]                       if (!has_future || version < "1.8.0") {
[17:46:36.496]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.496]                           "", base::R.version$version.string), 
[17:46:36.496]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:36.496]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.496]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.496]                             "release", "version")], collapse = " "), 
[17:46:36.496]                           hostname = base::Sys.info()[["nodename"]])
[17:46:36.496]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.496]                           info)
[17:46:36.496]                         info <- base::paste(info, collapse = "; ")
[17:46:36.496]                         if (!has_future) {
[17:46:36.496]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.496]                             info)
[17:46:36.496]                         }
[17:46:36.496]                         else {
[17:46:36.496]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.496]                             info, version)
[17:46:36.496]                         }
[17:46:36.496]                         base::stop(msg)
[17:46:36.496]                       }
[17:46:36.496]                     })
[17:46:36.496]                   }
[17:46:36.496]                   ...future.strategy.old <- future::plan("list")
[17:46:36.496]                   options(future.plan = NULL)
[17:46:36.496]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.496]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.496]                 }
[17:46:36.496]                 ...future.workdir <- getwd()
[17:46:36.496]             }
[17:46:36.496]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.496]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.496]         }
[17:46:36.496]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.496]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.496]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.496]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.496]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.496]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.496]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.496]             base::names(...future.oldOptions))
[17:46:36.496]     }
[17:46:36.496]     if (FALSE) {
[17:46:36.496]     }
[17:46:36.496]     else {
[17:46:36.496]         if (TRUE) {
[17:46:36.496]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.496]                 open = "w")
[17:46:36.496]         }
[17:46:36.496]         else {
[17:46:36.496]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.496]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.496]         }
[17:46:36.496]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.496]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.496]             base::sink(type = "output", split = FALSE)
[17:46:36.496]             base::close(...future.stdout)
[17:46:36.496]         }, add = TRUE)
[17:46:36.496]     }
[17:46:36.496]     ...future.frame <- base::sys.nframe()
[17:46:36.496]     ...future.conditions <- base::list()
[17:46:36.496]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.496]     if (FALSE) {
[17:46:36.496]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.496]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.496]     }
[17:46:36.496]     ...future.result <- base::tryCatch({
[17:46:36.496]         base::withCallingHandlers({
[17:46:36.496]             ...future.value <- base::withVisible(base::local({
[17:46:36.496]                 cat("Processing: ")
[17:46:36.496]                 for (ii in 1:10) {
[17:46:36.496]                   cat(".")
[17:46:36.496]                 }
[17:46:36.496]                 cat(" [100%]\n")
[17:46:36.496]                 4
[17:46:36.496]             }))
[17:46:36.496]             future::FutureResult(value = ...future.value$value, 
[17:46:36.496]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.496]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.496]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.496]                     ...future.globalenv.names))
[17:46:36.496]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.496]         }, condition = base::local({
[17:46:36.496]             c <- base::c
[17:46:36.496]             inherits <- base::inherits
[17:46:36.496]             invokeRestart <- base::invokeRestart
[17:46:36.496]             length <- base::length
[17:46:36.496]             list <- base::list
[17:46:36.496]             seq.int <- base::seq.int
[17:46:36.496]             signalCondition <- base::signalCondition
[17:46:36.496]             sys.calls <- base::sys.calls
[17:46:36.496]             `[[` <- base::`[[`
[17:46:36.496]             `+` <- base::`+`
[17:46:36.496]             `<<-` <- base::`<<-`
[17:46:36.496]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.496]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.496]                   3L)]
[17:46:36.496]             }
[17:46:36.496]             function(cond) {
[17:46:36.496]                 is_error <- inherits(cond, "error")
[17:46:36.496]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.496]                   NULL)
[17:46:36.496]                 if (is_error) {
[17:46:36.496]                   sessionInformation <- function() {
[17:46:36.496]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.496]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.496]                       search = base::search(), system = base::Sys.info())
[17:46:36.496]                   }
[17:46:36.496]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.496]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.496]                     cond$call), session = sessionInformation(), 
[17:46:36.496]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.496]                   signalCondition(cond)
[17:46:36.496]                 }
[17:46:36.496]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.496]                 "immediateCondition"))) {
[17:46:36.496]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.496]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.496]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.496]                   if (TRUE && !signal) {
[17:46:36.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.496]                     {
[17:46:36.496]                       inherits <- base::inherits
[17:46:36.496]                       invokeRestart <- base::invokeRestart
[17:46:36.496]                       is.null <- base::is.null
[17:46:36.496]                       muffled <- FALSE
[17:46:36.496]                       if (inherits(cond, "message")) {
[17:46:36.496]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.496]                         if (muffled) 
[17:46:36.496]                           invokeRestart("muffleMessage")
[17:46:36.496]                       }
[17:46:36.496]                       else if (inherits(cond, "warning")) {
[17:46:36.496]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.496]                         if (muffled) 
[17:46:36.496]                           invokeRestart("muffleWarning")
[17:46:36.496]                       }
[17:46:36.496]                       else if (inherits(cond, "condition")) {
[17:46:36.496]                         if (!is.null(pattern)) {
[17:46:36.496]                           computeRestarts <- base::computeRestarts
[17:46:36.496]                           grepl <- base::grepl
[17:46:36.496]                           restarts <- computeRestarts(cond)
[17:46:36.496]                           for (restart in restarts) {
[17:46:36.496]                             name <- restart$name
[17:46:36.496]                             if (is.null(name)) 
[17:46:36.496]                               next
[17:46:36.496]                             if (!grepl(pattern, name)) 
[17:46:36.496]                               next
[17:46:36.496]                             invokeRestart(restart)
[17:46:36.496]                             muffled <- TRUE
[17:46:36.496]                             break
[17:46:36.496]                           }
[17:46:36.496]                         }
[17:46:36.496]                       }
[17:46:36.496]                       invisible(muffled)
[17:46:36.496]                     }
[17:46:36.496]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.496]                   }
[17:46:36.496]                 }
[17:46:36.496]                 else {
[17:46:36.496]                   if (TRUE) {
[17:46:36.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.496]                     {
[17:46:36.496]                       inherits <- base::inherits
[17:46:36.496]                       invokeRestart <- base::invokeRestart
[17:46:36.496]                       is.null <- base::is.null
[17:46:36.496]                       muffled <- FALSE
[17:46:36.496]                       if (inherits(cond, "message")) {
[17:46:36.496]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.496]                         if (muffled) 
[17:46:36.496]                           invokeRestart("muffleMessage")
[17:46:36.496]                       }
[17:46:36.496]                       else if (inherits(cond, "warning")) {
[17:46:36.496]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.496]                         if (muffled) 
[17:46:36.496]                           invokeRestart("muffleWarning")
[17:46:36.496]                       }
[17:46:36.496]                       else if (inherits(cond, "condition")) {
[17:46:36.496]                         if (!is.null(pattern)) {
[17:46:36.496]                           computeRestarts <- base::computeRestarts
[17:46:36.496]                           grepl <- base::grepl
[17:46:36.496]                           restarts <- computeRestarts(cond)
[17:46:36.496]                           for (restart in restarts) {
[17:46:36.496]                             name <- restart$name
[17:46:36.496]                             if (is.null(name)) 
[17:46:36.496]                               next
[17:46:36.496]                             if (!grepl(pattern, name)) 
[17:46:36.496]                               next
[17:46:36.496]                             invokeRestart(restart)
[17:46:36.496]                             muffled <- TRUE
[17:46:36.496]                             break
[17:46:36.496]                           }
[17:46:36.496]                         }
[17:46:36.496]                       }
[17:46:36.496]                       invisible(muffled)
[17:46:36.496]                     }
[17:46:36.496]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.496]                   }
[17:46:36.496]                 }
[17:46:36.496]             }
[17:46:36.496]         }))
[17:46:36.496]     }, error = function(ex) {
[17:46:36.496]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.496]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.496]                 ...future.rng), started = ...future.startTime, 
[17:46:36.496]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.496]             version = "1.8"), class = "FutureResult")
[17:46:36.496]     }, finally = {
[17:46:36.496]         if (!identical(...future.workdir, getwd())) 
[17:46:36.496]             setwd(...future.workdir)
[17:46:36.496]         {
[17:46:36.496]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.496]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.496]             }
[17:46:36.496]             base::options(...future.oldOptions)
[17:46:36.496]             if (.Platform$OS.type == "windows") {
[17:46:36.496]                 old_names <- names(...future.oldEnvVars)
[17:46:36.496]                 envs <- base::Sys.getenv()
[17:46:36.496]                 names <- names(envs)
[17:46:36.496]                 common <- intersect(names, old_names)
[17:46:36.496]                 added <- setdiff(names, old_names)
[17:46:36.496]                 removed <- setdiff(old_names, names)
[17:46:36.496]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.496]                   envs[common]]
[17:46:36.496]                 NAMES <- toupper(changed)
[17:46:36.496]                 args <- list()
[17:46:36.496]                 for (kk in seq_along(NAMES)) {
[17:46:36.496]                   name <- changed[[kk]]
[17:46:36.496]                   NAME <- NAMES[[kk]]
[17:46:36.496]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.496]                     next
[17:46:36.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.496]                 }
[17:46:36.496]                 NAMES <- toupper(added)
[17:46:36.496]                 for (kk in seq_along(NAMES)) {
[17:46:36.496]                   name <- added[[kk]]
[17:46:36.496]                   NAME <- NAMES[[kk]]
[17:46:36.496]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.496]                     next
[17:46:36.496]                   args[[name]] <- ""
[17:46:36.496]                 }
[17:46:36.496]                 NAMES <- toupper(removed)
[17:46:36.496]                 for (kk in seq_along(NAMES)) {
[17:46:36.496]                   name <- removed[[kk]]
[17:46:36.496]                   NAME <- NAMES[[kk]]
[17:46:36.496]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.496]                     next
[17:46:36.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.496]                 }
[17:46:36.496]                 if (length(args) > 0) 
[17:46:36.496]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.496]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.496]             }
[17:46:36.496]             else {
[17:46:36.496]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.496]             }
[17:46:36.496]             {
[17:46:36.496]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.496]                   0L) {
[17:46:36.496]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.496]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.496]                   base::options(opts)
[17:46:36.496]                 }
[17:46:36.496]                 {
[17:46:36.496]                   {
[17:46:36.496]                     NULL
[17:46:36.496]                     RNGkind("Mersenne-Twister")
[17:46:36.496]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.496]                       inherits = FALSE)
[17:46:36.496]                   }
[17:46:36.496]                   options(future.plan = NULL)
[17:46:36.496]                   if (is.na(NA_character_)) 
[17:46:36.496]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.496]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.496]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.496]                     .init = FALSE)
[17:46:36.496]                 }
[17:46:36.496]             }
[17:46:36.496]         }
[17:46:36.496]     })
[17:46:36.496]     if (TRUE) {
[17:46:36.496]         base::sink(type = "output", split = FALSE)
[17:46:36.496]         if (TRUE) {
[17:46:36.496]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.496]         }
[17:46:36.496]         else {
[17:46:36.496]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.496]         }
[17:46:36.496]         base::close(...future.stdout)
[17:46:36.496]         ...future.stdout <- NULL
[17:46:36.496]     }
[17:46:36.496]     ...future.result$conditions <- ...future.conditions
[17:46:36.496]     ...future.result$finished <- base::Sys.time()
[17:46:36.496]     ...future.result
[17:46:36.496] }
[17:46:36.498] plan(): Setting new future strategy stack:
[17:46:36.498] List of future strategies:
[17:46:36.498] 1. sequential:
[17:46:36.498]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.498]    - tweaked: FALSE
[17:46:36.498]    - call: NULL
[17:46:36.498] plan(): nbrOfWorkers() = 1
[17:46:36.499] plan(): Setting new future strategy stack:
[17:46:36.499] List of future strategies:
[17:46:36.499] 1. sequential:
[17:46:36.499]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.499]    - tweaked: FALSE
[17:46:36.499]    - call: plan(strategy)
[17:46:36.500] plan(): nbrOfWorkers() = 1
[17:46:36.500] SequentialFuture started (and completed)
[17:46:36.500] - Launch lazy future ... done
[17:46:36.500] run() for ‘SequentialFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[17:46:36.501] signalConditions() ...
[17:46:36.501]  - include = ‘immediateCondition’
[17:46:36.501]  - exclude = 
[17:46:36.501]  - resignal = FALSE
[17:46:36.502]  - Number of conditions: 1
[17:46:36.502] signalConditions() ... done
[17:46:36.502] Future state: ‘finished’
[17:46:36.502] signalConditions() ...
[17:46:36.502]  - include = ‘condition’
[17:46:36.502]  - exclude = ‘immediateCondition’
[17:46:36.502]  - resignal = TRUE
[17:46:36.502]  - Number of conditions: 1
[17:46:36.502]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:36.502] signalConditions() ... done
v3: <simpleError> (as expect)
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[17:46:36.503] getGlobalsAndPackages() ...
[17:46:36.503] Searching for globals...
[17:46:36.503] 
[17:46:36.503] Searching for globals ... DONE
[17:46:36.503] - globals: [0] <none>
[17:46:36.503] getGlobalsAndPackages() ... DONE
[17:46:36.504] run() for ‘Future’ ...
[17:46:36.504] - state: ‘created’
[17:46:36.504] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.504] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.504] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.504]   - Field: ‘label’
[17:46:36.504]   - Field: ‘local’
[17:46:36.504]   - Field: ‘owner’
[17:46:36.505]   - Field: ‘envir’
[17:46:36.505]   - Field: ‘packages’
[17:46:36.505]   - Field: ‘gc’
[17:46:36.505]   - Field: ‘conditions’
[17:46:36.505]   - Field: ‘expr’
[17:46:36.505]   - Field: ‘uuid’
[17:46:36.505]   - Field: ‘seed’
[17:46:36.505]   - Field: ‘version’
[17:46:36.505]   - Field: ‘result’
[17:46:36.505]   - Field: ‘asynchronous’
[17:46:36.505]   - Field: ‘calls’
[17:46:36.505]   - Field: ‘globals’
[17:46:36.506]   - Field: ‘stdout’
[17:46:36.506]   - Field: ‘earlySignal’
[17:46:36.506]   - Field: ‘lazy’
[17:46:36.506]   - Field: ‘state’
[17:46:36.506] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.506] - Launch lazy future ...
[17:46:36.506] Packages needed by the future expression (n = 0): <none>
[17:46:36.506] Packages needed by future strategies (n = 0): <none>
[17:46:36.507] {
[17:46:36.507]     {
[17:46:36.507]         {
[17:46:36.507]             ...future.startTime <- base::Sys.time()
[17:46:36.507]             {
[17:46:36.507]                 {
[17:46:36.507]                   {
[17:46:36.507]                     base::local({
[17:46:36.507]                       has_future <- base::requireNamespace("future", 
[17:46:36.507]                         quietly = TRUE)
[17:46:36.507]                       if (has_future) {
[17:46:36.507]                         ns <- base::getNamespace("future")
[17:46:36.507]                         version <- ns[[".package"]][["version"]]
[17:46:36.507]                         if (is.null(version)) 
[17:46:36.507]                           version <- utils::packageVersion("future")
[17:46:36.507]                       }
[17:46:36.507]                       else {
[17:46:36.507]                         version <- NULL
[17:46:36.507]                       }
[17:46:36.507]                       if (!has_future || version < "1.8.0") {
[17:46:36.507]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.507]                           "", base::R.version$version.string), 
[17:46:36.507]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:36.507]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.507]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.507]                             "release", "version")], collapse = " "), 
[17:46:36.507]                           hostname = base::Sys.info()[["nodename"]])
[17:46:36.507]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.507]                           info)
[17:46:36.507]                         info <- base::paste(info, collapse = "; ")
[17:46:36.507]                         if (!has_future) {
[17:46:36.507]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.507]                             info)
[17:46:36.507]                         }
[17:46:36.507]                         else {
[17:46:36.507]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.507]                             info, version)
[17:46:36.507]                         }
[17:46:36.507]                         base::stop(msg)
[17:46:36.507]                       }
[17:46:36.507]                     })
[17:46:36.507]                   }
[17:46:36.507]                   ...future.strategy.old <- future::plan("list")
[17:46:36.507]                   options(future.plan = NULL)
[17:46:36.507]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.507]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.507]                 }
[17:46:36.507]                 ...future.workdir <- getwd()
[17:46:36.507]             }
[17:46:36.507]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.507]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.507]         }
[17:46:36.507]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.507]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.507]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.507]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.507]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.507]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.507]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.507]             base::names(...future.oldOptions))
[17:46:36.507]     }
[17:46:36.507]     if (FALSE) {
[17:46:36.507]     }
[17:46:36.507]     else {
[17:46:36.507]         if (TRUE) {
[17:46:36.507]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.507]                 open = "w")
[17:46:36.507]         }
[17:46:36.507]         else {
[17:46:36.507]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.507]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.507]         }
[17:46:36.507]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.507]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.507]             base::sink(type = "output", split = FALSE)
[17:46:36.507]             base::close(...future.stdout)
[17:46:36.507]         }, add = TRUE)
[17:46:36.507]     }
[17:46:36.507]     ...future.frame <- base::sys.nframe()
[17:46:36.507]     ...future.conditions <- base::list()
[17:46:36.507]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.507]     if (FALSE) {
[17:46:36.507]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.507]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.507]     }
[17:46:36.507]     ...future.result <- base::tryCatch({
[17:46:36.507]         base::withCallingHandlers({
[17:46:36.507]             ...future.value <- base::withVisible(base::local(1))
[17:46:36.507]             future::FutureResult(value = ...future.value$value, 
[17:46:36.507]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.507]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.507]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.507]                     ...future.globalenv.names))
[17:46:36.507]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.507]         }, condition = base::local({
[17:46:36.507]             c <- base::c
[17:46:36.507]             inherits <- base::inherits
[17:46:36.507]             invokeRestart <- base::invokeRestart
[17:46:36.507]             length <- base::length
[17:46:36.507]             list <- base::list
[17:46:36.507]             seq.int <- base::seq.int
[17:46:36.507]             signalCondition <- base::signalCondition
[17:46:36.507]             sys.calls <- base::sys.calls
[17:46:36.507]             `[[` <- base::`[[`
[17:46:36.507]             `+` <- base::`+`
[17:46:36.507]             `<<-` <- base::`<<-`
[17:46:36.507]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.507]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.507]                   3L)]
[17:46:36.507]             }
[17:46:36.507]             function(cond) {
[17:46:36.507]                 is_error <- inherits(cond, "error")
[17:46:36.507]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.507]                   NULL)
[17:46:36.507]                 if (is_error) {
[17:46:36.507]                   sessionInformation <- function() {
[17:46:36.507]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.507]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.507]                       search = base::search(), system = base::Sys.info())
[17:46:36.507]                   }
[17:46:36.507]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.507]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.507]                     cond$call), session = sessionInformation(), 
[17:46:36.507]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.507]                   signalCondition(cond)
[17:46:36.507]                 }
[17:46:36.507]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.507]                 "immediateCondition"))) {
[17:46:36.507]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.507]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.507]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.507]                   if (TRUE && !signal) {
[17:46:36.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.507]                     {
[17:46:36.507]                       inherits <- base::inherits
[17:46:36.507]                       invokeRestart <- base::invokeRestart
[17:46:36.507]                       is.null <- base::is.null
[17:46:36.507]                       muffled <- FALSE
[17:46:36.507]                       if (inherits(cond, "message")) {
[17:46:36.507]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.507]                         if (muffled) 
[17:46:36.507]                           invokeRestart("muffleMessage")
[17:46:36.507]                       }
[17:46:36.507]                       else if (inherits(cond, "warning")) {
[17:46:36.507]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.507]                         if (muffled) 
[17:46:36.507]                           invokeRestart("muffleWarning")
[17:46:36.507]                       }
[17:46:36.507]                       else if (inherits(cond, "condition")) {
[17:46:36.507]                         if (!is.null(pattern)) {
[17:46:36.507]                           computeRestarts <- base::computeRestarts
[17:46:36.507]                           grepl <- base::grepl
[17:46:36.507]                           restarts <- computeRestarts(cond)
[17:46:36.507]                           for (restart in restarts) {
[17:46:36.507]                             name <- restart$name
[17:46:36.507]                             if (is.null(name)) 
[17:46:36.507]                               next
[17:46:36.507]                             if (!grepl(pattern, name)) 
[17:46:36.507]                               next
[17:46:36.507]                             invokeRestart(restart)
[17:46:36.507]                             muffled <- TRUE
[17:46:36.507]                             break
[17:46:36.507]                           }
[17:46:36.507]                         }
[17:46:36.507]                       }
[17:46:36.507]                       invisible(muffled)
[17:46:36.507]                     }
[17:46:36.507]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.507]                   }
[17:46:36.507]                 }
[17:46:36.507]                 else {
[17:46:36.507]                   if (TRUE) {
[17:46:36.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.507]                     {
[17:46:36.507]                       inherits <- base::inherits
[17:46:36.507]                       invokeRestart <- base::invokeRestart
[17:46:36.507]                       is.null <- base::is.null
[17:46:36.507]                       muffled <- FALSE
[17:46:36.507]                       if (inherits(cond, "message")) {
[17:46:36.507]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.507]                         if (muffled) 
[17:46:36.507]                           invokeRestart("muffleMessage")
[17:46:36.507]                       }
[17:46:36.507]                       else if (inherits(cond, "warning")) {
[17:46:36.507]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.507]                         if (muffled) 
[17:46:36.507]                           invokeRestart("muffleWarning")
[17:46:36.507]                       }
[17:46:36.507]                       else if (inherits(cond, "condition")) {
[17:46:36.507]                         if (!is.null(pattern)) {
[17:46:36.507]                           computeRestarts <- base::computeRestarts
[17:46:36.507]                           grepl <- base::grepl
[17:46:36.507]                           restarts <- computeRestarts(cond)
[17:46:36.507]                           for (restart in restarts) {
[17:46:36.507]                             name <- restart$name
[17:46:36.507]                             if (is.null(name)) 
[17:46:36.507]                               next
[17:46:36.507]                             if (!grepl(pattern, name)) 
[17:46:36.507]                               next
[17:46:36.507]                             invokeRestart(restart)
[17:46:36.507]                             muffled <- TRUE
[17:46:36.507]                             break
[17:46:36.507]                           }
[17:46:36.507]                         }
[17:46:36.507]                       }
[17:46:36.507]                       invisible(muffled)
[17:46:36.507]                     }
[17:46:36.507]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.507]                   }
[17:46:36.507]                 }
[17:46:36.507]             }
[17:46:36.507]         }))
[17:46:36.507]     }, error = function(ex) {
[17:46:36.507]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.507]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.507]                 ...future.rng), started = ...future.startTime, 
[17:46:36.507]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.507]             version = "1.8"), class = "FutureResult")
[17:46:36.507]     }, finally = {
[17:46:36.507]         if (!identical(...future.workdir, getwd())) 
[17:46:36.507]             setwd(...future.workdir)
[17:46:36.507]         {
[17:46:36.507]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.507]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.507]             }
[17:46:36.507]             base::options(...future.oldOptions)
[17:46:36.507]             if (.Platform$OS.type == "windows") {
[17:46:36.507]                 old_names <- names(...future.oldEnvVars)
[17:46:36.507]                 envs <- base::Sys.getenv()
[17:46:36.507]                 names <- names(envs)
[17:46:36.507]                 common <- intersect(names, old_names)
[17:46:36.507]                 added <- setdiff(names, old_names)
[17:46:36.507]                 removed <- setdiff(old_names, names)
[17:46:36.507]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.507]                   envs[common]]
[17:46:36.507]                 NAMES <- toupper(changed)
[17:46:36.507]                 args <- list()
[17:46:36.507]                 for (kk in seq_along(NAMES)) {
[17:46:36.507]                   name <- changed[[kk]]
[17:46:36.507]                   NAME <- NAMES[[kk]]
[17:46:36.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.507]                     next
[17:46:36.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.507]                 }
[17:46:36.507]                 NAMES <- toupper(added)
[17:46:36.507]                 for (kk in seq_along(NAMES)) {
[17:46:36.507]                   name <- added[[kk]]
[17:46:36.507]                   NAME <- NAMES[[kk]]
[17:46:36.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.507]                     next
[17:46:36.507]                   args[[name]] <- ""
[17:46:36.507]                 }
[17:46:36.507]                 NAMES <- toupper(removed)
[17:46:36.507]                 for (kk in seq_along(NAMES)) {
[17:46:36.507]                   name <- removed[[kk]]
[17:46:36.507]                   NAME <- NAMES[[kk]]
[17:46:36.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.507]                     next
[17:46:36.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.507]                 }
[17:46:36.507]                 if (length(args) > 0) 
[17:46:36.507]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.507]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.507]             }
[17:46:36.507]             else {
[17:46:36.507]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.507]             }
[17:46:36.507]             {
[17:46:36.507]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.507]                   0L) {
[17:46:36.507]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.507]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.507]                   base::options(opts)
[17:46:36.507]                 }
[17:46:36.507]                 {
[17:46:36.507]                   {
[17:46:36.507]                     NULL
[17:46:36.507]                     RNGkind("Mersenne-Twister")
[17:46:36.507]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.507]                       inherits = FALSE)
[17:46:36.507]                   }
[17:46:36.507]                   options(future.plan = NULL)
[17:46:36.507]                   if (is.na(NA_character_)) 
[17:46:36.507]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.507]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.507]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.507]                     .init = FALSE)
[17:46:36.507]                 }
[17:46:36.507]             }
[17:46:36.507]         }
[17:46:36.507]     })
[17:46:36.507]     if (TRUE) {
[17:46:36.507]         base::sink(type = "output", split = FALSE)
[17:46:36.507]         if (TRUE) {
[17:46:36.507]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.507]         }
[17:46:36.507]         else {
[17:46:36.507]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.507]         }
[17:46:36.507]         base::close(...future.stdout)
[17:46:36.507]         ...future.stdout <- NULL
[17:46:36.507]     }
[17:46:36.507]     ...future.result$conditions <- ...future.conditions
[17:46:36.507]     ...future.result$finished <- base::Sys.time()
[17:46:36.507]     ...future.result
[17:46:36.507] }
[17:46:36.508] plan(): Setting new future strategy stack:
[17:46:36.508] List of future strategies:
[17:46:36.508] 1. sequential:
[17:46:36.508]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.508]    - tweaked: FALSE
[17:46:36.508]    - call: NULL
[17:46:36.509] plan(): nbrOfWorkers() = 1
[17:46:36.509] plan(): Setting new future strategy stack:
[17:46:36.510] List of future strategies:
[17:46:36.510] 1. sequential:
[17:46:36.510]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.510]    - tweaked: FALSE
[17:46:36.510]    - call: plan(strategy)
[17:46:36.510] plan(): nbrOfWorkers() = 1
[17:46:36.510] SequentialFuture started (and completed)
[17:46:36.510] - Launch lazy future ... done
[17:46:36.510] run() for ‘SequentialFuture’ ... done
c = 1
[17:46:36.511] getGlobalsAndPackages() ...
[17:46:36.511] Searching for globals...
[17:46:36.511] 
[17:46:36.511] Searching for globals ... DONE
[17:46:36.511] - globals: [0] <none>
[17:46:36.511] getGlobalsAndPackages() ... DONE
[17:46:36.512] run() for ‘Future’ ...
[17:46:36.512] - state: ‘created’
[17:46:36.512] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.512] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.512] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.512]   - Field: ‘label’
[17:46:36.512]   - Field: ‘local’
[17:46:36.512]   - Field: ‘owner’
[17:46:36.512]   - Field: ‘envir’
[17:46:36.513]   - Field: ‘packages’
[17:46:36.513]   - Field: ‘gc’
[17:46:36.513]   - Field: ‘conditions’
[17:46:36.513]   - Field: ‘expr’
[17:46:36.513]   - Field: ‘uuid’
[17:46:36.513]   - Field: ‘seed’
[17:46:36.513]   - Field: ‘version’
[17:46:36.513]   - Field: ‘result’
[17:46:36.513]   - Field: ‘asynchronous’
[17:46:36.513]   - Field: ‘calls’
[17:46:36.513]   - Field: ‘globals’
[17:46:36.513]   - Field: ‘stdout’
[17:46:36.514]   - Field: ‘earlySignal’
[17:46:36.514]   - Field: ‘lazy’
[17:46:36.514]   - Field: ‘state’
[17:46:36.514] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.514] - Launch lazy future ...
[17:46:36.514] Packages needed by the future expression (n = 0): <none>
[17:46:36.514] Packages needed by future strategies (n = 0): <none>
[17:46:36.515] {
[17:46:36.515]     {
[17:46:36.515]         {
[17:46:36.515]             ...future.startTime <- base::Sys.time()
[17:46:36.515]             {
[17:46:36.515]                 {
[17:46:36.515]                   {
[17:46:36.515]                     base::local({
[17:46:36.515]                       has_future <- base::requireNamespace("future", 
[17:46:36.515]                         quietly = TRUE)
[17:46:36.515]                       if (has_future) {
[17:46:36.515]                         ns <- base::getNamespace("future")
[17:46:36.515]                         version <- ns[[".package"]][["version"]]
[17:46:36.515]                         if (is.null(version)) 
[17:46:36.515]                           version <- utils::packageVersion("future")
[17:46:36.515]                       }
[17:46:36.515]                       else {
[17:46:36.515]                         version <- NULL
[17:46:36.515]                       }
[17:46:36.515]                       if (!has_future || version < "1.8.0") {
[17:46:36.515]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.515]                           "", base::R.version$version.string), 
[17:46:36.515]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:36.515]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.515]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.515]                             "release", "version")], collapse = " "), 
[17:46:36.515]                           hostname = base::Sys.info()[["nodename"]])
[17:46:36.515]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.515]                           info)
[17:46:36.515]                         info <- base::paste(info, collapse = "; ")
[17:46:36.515]                         if (!has_future) {
[17:46:36.515]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.515]                             info)
[17:46:36.515]                         }
[17:46:36.515]                         else {
[17:46:36.515]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.515]                             info, version)
[17:46:36.515]                         }
[17:46:36.515]                         base::stop(msg)
[17:46:36.515]                       }
[17:46:36.515]                     })
[17:46:36.515]                   }
[17:46:36.515]                   ...future.strategy.old <- future::plan("list")
[17:46:36.515]                   options(future.plan = NULL)
[17:46:36.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.515]                 }
[17:46:36.515]                 ...future.workdir <- getwd()
[17:46:36.515]             }
[17:46:36.515]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.515]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.515]         }
[17:46:36.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.515]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.515]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.515]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.515]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.515]             base::names(...future.oldOptions))
[17:46:36.515]     }
[17:46:36.515]     if (FALSE) {
[17:46:36.515]     }
[17:46:36.515]     else {
[17:46:36.515]         if (TRUE) {
[17:46:36.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.515]                 open = "w")
[17:46:36.515]         }
[17:46:36.515]         else {
[17:46:36.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.515]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.515]         }
[17:46:36.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.515]             base::sink(type = "output", split = FALSE)
[17:46:36.515]             base::close(...future.stdout)
[17:46:36.515]         }, add = TRUE)
[17:46:36.515]     }
[17:46:36.515]     ...future.frame <- base::sys.nframe()
[17:46:36.515]     ...future.conditions <- base::list()
[17:46:36.515]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.515]     if (FALSE) {
[17:46:36.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.515]     }
[17:46:36.515]     ...future.result <- base::tryCatch({
[17:46:36.515]         base::withCallingHandlers({
[17:46:36.515]             ...future.value <- base::withVisible(base::local(1))
[17:46:36.515]             future::FutureResult(value = ...future.value$value, 
[17:46:36.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.515]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.515]                     ...future.globalenv.names))
[17:46:36.515]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.515]         }, condition = base::local({
[17:46:36.515]             c <- base::c
[17:46:36.515]             inherits <- base::inherits
[17:46:36.515]             invokeRestart <- base::invokeRestart
[17:46:36.515]             length <- base::length
[17:46:36.515]             list <- base::list
[17:46:36.515]             seq.int <- base::seq.int
[17:46:36.515]             signalCondition <- base::signalCondition
[17:46:36.515]             sys.calls <- base::sys.calls
[17:46:36.515]             `[[` <- base::`[[`
[17:46:36.515]             `+` <- base::`+`
[17:46:36.515]             `<<-` <- base::`<<-`
[17:46:36.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.515]                   3L)]
[17:46:36.515]             }
[17:46:36.515]             function(cond) {
[17:46:36.515]                 is_error <- inherits(cond, "error")
[17:46:36.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.515]                   NULL)
[17:46:36.515]                 if (is_error) {
[17:46:36.515]                   sessionInformation <- function() {
[17:46:36.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.515]                       search = base::search(), system = base::Sys.info())
[17:46:36.515]                   }
[17:46:36.515]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.515]                     cond$call), session = sessionInformation(), 
[17:46:36.515]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.515]                   signalCondition(cond)
[17:46:36.515]                 }
[17:46:36.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.515]                 "immediateCondition"))) {
[17:46:36.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.515]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.515]                   if (TRUE && !signal) {
[17:46:36.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.515]                     {
[17:46:36.515]                       inherits <- base::inherits
[17:46:36.515]                       invokeRestart <- base::invokeRestart
[17:46:36.515]                       is.null <- base::is.null
[17:46:36.515]                       muffled <- FALSE
[17:46:36.515]                       if (inherits(cond, "message")) {
[17:46:36.515]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.515]                         if (muffled) 
[17:46:36.515]                           invokeRestart("muffleMessage")
[17:46:36.515]                       }
[17:46:36.515]                       else if (inherits(cond, "warning")) {
[17:46:36.515]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.515]                         if (muffled) 
[17:46:36.515]                           invokeRestart("muffleWarning")
[17:46:36.515]                       }
[17:46:36.515]                       else if (inherits(cond, "condition")) {
[17:46:36.515]                         if (!is.null(pattern)) {
[17:46:36.515]                           computeRestarts <- base::computeRestarts
[17:46:36.515]                           grepl <- base::grepl
[17:46:36.515]                           restarts <- computeRestarts(cond)
[17:46:36.515]                           for (restart in restarts) {
[17:46:36.515]                             name <- restart$name
[17:46:36.515]                             if (is.null(name)) 
[17:46:36.515]                               next
[17:46:36.515]                             if (!grepl(pattern, name)) 
[17:46:36.515]                               next
[17:46:36.515]                             invokeRestart(restart)
[17:46:36.515]                             muffled <- TRUE
[17:46:36.515]                             break
[17:46:36.515]                           }
[17:46:36.515]                         }
[17:46:36.515]                       }
[17:46:36.515]                       invisible(muffled)
[17:46:36.515]                     }
[17:46:36.515]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.515]                   }
[17:46:36.515]                 }
[17:46:36.515]                 else {
[17:46:36.515]                   if (TRUE) {
[17:46:36.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.515]                     {
[17:46:36.515]                       inherits <- base::inherits
[17:46:36.515]                       invokeRestart <- base::invokeRestart
[17:46:36.515]                       is.null <- base::is.null
[17:46:36.515]                       muffled <- FALSE
[17:46:36.515]                       if (inherits(cond, "message")) {
[17:46:36.515]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.515]                         if (muffled) 
[17:46:36.515]                           invokeRestart("muffleMessage")
[17:46:36.515]                       }
[17:46:36.515]                       else if (inherits(cond, "warning")) {
[17:46:36.515]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.515]                         if (muffled) 
[17:46:36.515]                           invokeRestart("muffleWarning")
[17:46:36.515]                       }
[17:46:36.515]                       else if (inherits(cond, "condition")) {
[17:46:36.515]                         if (!is.null(pattern)) {
[17:46:36.515]                           computeRestarts <- base::computeRestarts
[17:46:36.515]                           grepl <- base::grepl
[17:46:36.515]                           restarts <- computeRestarts(cond)
[17:46:36.515]                           for (restart in restarts) {
[17:46:36.515]                             name <- restart$name
[17:46:36.515]                             if (is.null(name)) 
[17:46:36.515]                               next
[17:46:36.515]                             if (!grepl(pattern, name)) 
[17:46:36.515]                               next
[17:46:36.515]                             invokeRestart(restart)
[17:46:36.515]                             muffled <- TRUE
[17:46:36.515]                             break
[17:46:36.515]                           }
[17:46:36.515]                         }
[17:46:36.515]                       }
[17:46:36.515]                       invisible(muffled)
[17:46:36.515]                     }
[17:46:36.515]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.515]                   }
[17:46:36.515]                 }
[17:46:36.515]             }
[17:46:36.515]         }))
[17:46:36.515]     }, error = function(ex) {
[17:46:36.515]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.515]                 ...future.rng), started = ...future.startTime, 
[17:46:36.515]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.515]             version = "1.8"), class = "FutureResult")
[17:46:36.515]     }, finally = {
[17:46:36.515]         if (!identical(...future.workdir, getwd())) 
[17:46:36.515]             setwd(...future.workdir)
[17:46:36.515]         {
[17:46:36.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.515]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.515]             }
[17:46:36.515]             base::options(...future.oldOptions)
[17:46:36.515]             if (.Platform$OS.type == "windows") {
[17:46:36.515]                 old_names <- names(...future.oldEnvVars)
[17:46:36.515]                 envs <- base::Sys.getenv()
[17:46:36.515]                 names <- names(envs)
[17:46:36.515]                 common <- intersect(names, old_names)
[17:46:36.515]                 added <- setdiff(names, old_names)
[17:46:36.515]                 removed <- setdiff(old_names, names)
[17:46:36.515]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.515]                   envs[common]]
[17:46:36.515]                 NAMES <- toupper(changed)
[17:46:36.515]                 args <- list()
[17:46:36.515]                 for (kk in seq_along(NAMES)) {
[17:46:36.515]                   name <- changed[[kk]]
[17:46:36.515]                   NAME <- NAMES[[kk]]
[17:46:36.515]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.515]                     next
[17:46:36.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.515]                 }
[17:46:36.515]                 NAMES <- toupper(added)
[17:46:36.515]                 for (kk in seq_along(NAMES)) {
[17:46:36.515]                   name <- added[[kk]]
[17:46:36.515]                   NAME <- NAMES[[kk]]
[17:46:36.515]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.515]                     next
[17:46:36.515]                   args[[name]] <- ""
[17:46:36.515]                 }
[17:46:36.515]                 NAMES <- toupper(removed)
[17:46:36.515]                 for (kk in seq_along(NAMES)) {
[17:46:36.515]                   name <- removed[[kk]]
[17:46:36.515]                   NAME <- NAMES[[kk]]
[17:46:36.515]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.515]                     next
[17:46:36.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.515]                 }
[17:46:36.515]                 if (length(args) > 0) 
[17:46:36.515]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.515]             }
[17:46:36.515]             else {
[17:46:36.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.515]             }
[17:46:36.515]             {
[17:46:36.515]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.515]                   0L) {
[17:46:36.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.515]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.515]                   base::options(opts)
[17:46:36.515]                 }
[17:46:36.515]                 {
[17:46:36.515]                   {
[17:46:36.515]                     NULL
[17:46:36.515]                     RNGkind("Mersenne-Twister")
[17:46:36.515]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.515]                       inherits = FALSE)
[17:46:36.515]                   }
[17:46:36.515]                   options(future.plan = NULL)
[17:46:36.515]                   if (is.na(NA_character_)) 
[17:46:36.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.515]                     .init = FALSE)
[17:46:36.515]                 }
[17:46:36.515]             }
[17:46:36.515]         }
[17:46:36.515]     })
[17:46:36.515]     if (TRUE) {
[17:46:36.515]         base::sink(type = "output", split = FALSE)
[17:46:36.515]         if (TRUE) {
[17:46:36.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.515]         }
[17:46:36.515]         else {
[17:46:36.515]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.515]         }
[17:46:36.515]         base::close(...future.stdout)
[17:46:36.515]         ...future.stdout <- NULL
[17:46:36.515]     }
[17:46:36.515]     ...future.result$conditions <- ...future.conditions
[17:46:36.515]     ...future.result$finished <- base::Sys.time()
[17:46:36.515]     ...future.result
[17:46:36.515] }
[17:46:36.517] plan(): Setting new future strategy stack:
[17:46:36.518] List of future strategies:
[17:46:36.518] 1. sequential:
[17:46:36.518]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.518]    - tweaked: FALSE
[17:46:36.518]    - call: NULL
[17:46:36.518] plan(): nbrOfWorkers() = 1
[17:46:36.519] plan(): Setting new future strategy stack:
[17:46:36.519] List of future strategies:
[17:46:36.519] 1. sequential:
[17:46:36.519]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.519]    - tweaked: FALSE
[17:46:36.519]    - call: plan(strategy)
[17:46:36.519] plan(): nbrOfWorkers() = 1
[17:46:36.519] SequentialFuture started (and completed)
[17:46:36.519] - Launch lazy future ... done
[17:46:36.520] run() for ‘SequentialFuture’ ... done
d = 1
** Nested future assignments
[17:46:36.520] getGlobalsAndPackages() ...
[17:46:36.520] Searching for globals...
[17:46:36.523] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[17:46:36.524] Searching for globals ... DONE
[17:46:36.524] Resolving globals: FALSE
[17:46:36.524] 
[17:46:36.524] - packages: [1] ‘future’
[17:46:36.524] getGlobalsAndPackages() ... DONE
[17:46:36.524] run() for ‘Future’ ...
[17:46:36.524] - state: ‘created’
[17:46:36.525] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.525] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.525] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.525]   - Field: ‘label’
[17:46:36.525]   - Field: ‘local’
[17:46:36.525]   - Field: ‘owner’
[17:46:36.525]   - Field: ‘envir’
[17:46:36.525]   - Field: ‘packages’
[17:46:36.525]   - Field: ‘gc’
[17:46:36.526]   - Field: ‘conditions’
[17:46:36.526]   - Field: ‘expr’
[17:46:36.526]   - Field: ‘uuid’
[17:46:36.526]   - Field: ‘seed’
[17:46:36.526]   - Field: ‘version’
[17:46:36.526]   - Field: ‘result’
[17:46:36.526]   - Field: ‘asynchronous’
[17:46:36.526]   - Field: ‘calls’
[17:46:36.526]   - Field: ‘globals’
[17:46:36.526]   - Field: ‘stdout’
[17:46:36.526]   - Field: ‘earlySignal’
[17:46:36.527]   - Field: ‘lazy’
[17:46:36.527]   - Field: ‘state’
[17:46:36.527] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.527] - Launch lazy future ...
[17:46:36.527] Packages needed by the future expression (n = 1): ‘future’
[17:46:36.527] Packages needed by future strategies (n = 0): <none>
[17:46:36.528] {
[17:46:36.528]     {
[17:46:36.528]         {
[17:46:36.528]             ...future.startTime <- base::Sys.time()
[17:46:36.528]             {
[17:46:36.528]                 {
[17:46:36.528]                   {
[17:46:36.528]                     {
[17:46:36.528]                       base::local({
[17:46:36.528]                         has_future <- base::requireNamespace("future", 
[17:46:36.528]                           quietly = TRUE)
[17:46:36.528]                         if (has_future) {
[17:46:36.528]                           ns <- base::getNamespace("future")
[17:46:36.528]                           version <- ns[[".package"]][["version"]]
[17:46:36.528]                           if (is.null(version)) 
[17:46:36.528]                             version <- utils::packageVersion("future")
[17:46:36.528]                         }
[17:46:36.528]                         else {
[17:46:36.528]                           version <- NULL
[17:46:36.528]                         }
[17:46:36.528]                         if (!has_future || version < "1.8.0") {
[17:46:36.528]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.528]                             "", base::R.version$version.string), 
[17:46:36.528]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:36.528]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.528]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.528]                               "release", "version")], collapse = " "), 
[17:46:36.528]                             hostname = base::Sys.info()[["nodename"]])
[17:46:36.528]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.528]                             info)
[17:46:36.528]                           info <- base::paste(info, collapse = "; ")
[17:46:36.528]                           if (!has_future) {
[17:46:36.528]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.528]                               info)
[17:46:36.528]                           }
[17:46:36.528]                           else {
[17:46:36.528]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.528]                               info, version)
[17:46:36.528]                           }
[17:46:36.528]                           base::stop(msg)
[17:46:36.528]                         }
[17:46:36.528]                       })
[17:46:36.528]                     }
[17:46:36.528]                     base::local({
[17:46:36.528]                       for (pkg in "future") {
[17:46:36.528]                         base::loadNamespace(pkg)
[17:46:36.528]                         base::library(pkg, character.only = TRUE)
[17:46:36.528]                       }
[17:46:36.528]                     })
[17:46:36.528]                   }
[17:46:36.528]                   ...future.strategy.old <- future::plan("list")
[17:46:36.528]                   options(future.plan = NULL)
[17:46:36.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.528]                 }
[17:46:36.528]                 ...future.workdir <- getwd()
[17:46:36.528]             }
[17:46:36.528]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.528]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.528]         }
[17:46:36.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.528]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.528]             base::names(...future.oldOptions))
[17:46:36.528]     }
[17:46:36.528]     if (FALSE) {
[17:46:36.528]     }
[17:46:36.528]     else {
[17:46:36.528]         if (TRUE) {
[17:46:36.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.528]                 open = "w")
[17:46:36.528]         }
[17:46:36.528]         else {
[17:46:36.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.528]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.528]         }
[17:46:36.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.528]             base::sink(type = "output", split = FALSE)
[17:46:36.528]             base::close(...future.stdout)
[17:46:36.528]         }, add = TRUE)
[17:46:36.528]     }
[17:46:36.528]     ...future.frame <- base::sys.nframe()
[17:46:36.528]     ...future.conditions <- base::list()
[17:46:36.528]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.528]     if (FALSE) {
[17:46:36.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.528]     }
[17:46:36.528]     ...future.result <- base::tryCatch({
[17:46:36.528]         base::withCallingHandlers({
[17:46:36.528]             ...future.value <- base::withVisible(base::local({
[17:46:36.528]                 b <- 1
[17:46:36.528]                 c %<-% 2
[17:46:36.528]                 d <- 3
[17:46:36.528]                 4 %->% e
[17:46:36.528]                 b + c + d + e
[17:46:36.528]             }))
[17:46:36.528]             future::FutureResult(value = ...future.value$value, 
[17:46:36.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.528]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.528]                     ...future.globalenv.names))
[17:46:36.528]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.528]         }, condition = base::local({
[17:46:36.528]             c <- base::c
[17:46:36.528]             inherits <- base::inherits
[17:46:36.528]             invokeRestart <- base::invokeRestart
[17:46:36.528]             length <- base::length
[17:46:36.528]             list <- base::list
[17:46:36.528]             seq.int <- base::seq.int
[17:46:36.528]             signalCondition <- base::signalCondition
[17:46:36.528]             sys.calls <- base::sys.calls
[17:46:36.528]             `[[` <- base::`[[`
[17:46:36.528]             `+` <- base::`+`
[17:46:36.528]             `<<-` <- base::`<<-`
[17:46:36.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.528]                   3L)]
[17:46:36.528]             }
[17:46:36.528]             function(cond) {
[17:46:36.528]                 is_error <- inherits(cond, "error")
[17:46:36.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.528]                   NULL)
[17:46:36.528]                 if (is_error) {
[17:46:36.528]                   sessionInformation <- function() {
[17:46:36.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.528]                       search = base::search(), system = base::Sys.info())
[17:46:36.528]                   }
[17:46:36.528]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.528]                     cond$call), session = sessionInformation(), 
[17:46:36.528]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.528]                   signalCondition(cond)
[17:46:36.528]                 }
[17:46:36.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.528]                 "immediateCondition"))) {
[17:46:36.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.528]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.528]                   if (TRUE && !signal) {
[17:46:36.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.528]                     {
[17:46:36.528]                       inherits <- base::inherits
[17:46:36.528]                       invokeRestart <- base::invokeRestart
[17:46:36.528]                       is.null <- base::is.null
[17:46:36.528]                       muffled <- FALSE
[17:46:36.528]                       if (inherits(cond, "message")) {
[17:46:36.528]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.528]                         if (muffled) 
[17:46:36.528]                           invokeRestart("muffleMessage")
[17:46:36.528]                       }
[17:46:36.528]                       else if (inherits(cond, "warning")) {
[17:46:36.528]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.528]                         if (muffled) 
[17:46:36.528]                           invokeRestart("muffleWarning")
[17:46:36.528]                       }
[17:46:36.528]                       else if (inherits(cond, "condition")) {
[17:46:36.528]                         if (!is.null(pattern)) {
[17:46:36.528]                           computeRestarts <- base::computeRestarts
[17:46:36.528]                           grepl <- base::grepl
[17:46:36.528]                           restarts <- computeRestarts(cond)
[17:46:36.528]                           for (restart in restarts) {
[17:46:36.528]                             name <- restart$name
[17:46:36.528]                             if (is.null(name)) 
[17:46:36.528]                               next
[17:46:36.528]                             if (!grepl(pattern, name)) 
[17:46:36.528]                               next
[17:46:36.528]                             invokeRestart(restart)
[17:46:36.528]                             muffled <- TRUE
[17:46:36.528]                             break
[17:46:36.528]                           }
[17:46:36.528]                         }
[17:46:36.528]                       }
[17:46:36.528]                       invisible(muffled)
[17:46:36.528]                     }
[17:46:36.528]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.528]                   }
[17:46:36.528]                 }
[17:46:36.528]                 else {
[17:46:36.528]                   if (TRUE) {
[17:46:36.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.528]                     {
[17:46:36.528]                       inherits <- base::inherits
[17:46:36.528]                       invokeRestart <- base::invokeRestart
[17:46:36.528]                       is.null <- base::is.null
[17:46:36.528]                       muffled <- FALSE
[17:46:36.528]                       if (inherits(cond, "message")) {
[17:46:36.528]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.528]                         if (muffled) 
[17:46:36.528]                           invokeRestart("muffleMessage")
[17:46:36.528]                       }
[17:46:36.528]                       else if (inherits(cond, "warning")) {
[17:46:36.528]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.528]                         if (muffled) 
[17:46:36.528]                           invokeRestart("muffleWarning")
[17:46:36.528]                       }
[17:46:36.528]                       else if (inherits(cond, "condition")) {
[17:46:36.528]                         if (!is.null(pattern)) {
[17:46:36.528]                           computeRestarts <- base::computeRestarts
[17:46:36.528]                           grepl <- base::grepl
[17:46:36.528]                           restarts <- computeRestarts(cond)
[17:46:36.528]                           for (restart in restarts) {
[17:46:36.528]                             name <- restart$name
[17:46:36.528]                             if (is.null(name)) 
[17:46:36.528]                               next
[17:46:36.528]                             if (!grepl(pattern, name)) 
[17:46:36.528]                               next
[17:46:36.528]                             invokeRestart(restart)
[17:46:36.528]                             muffled <- TRUE
[17:46:36.528]                             break
[17:46:36.528]                           }
[17:46:36.528]                         }
[17:46:36.528]                       }
[17:46:36.528]                       invisible(muffled)
[17:46:36.528]                     }
[17:46:36.528]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.528]                   }
[17:46:36.528]                 }
[17:46:36.528]             }
[17:46:36.528]         }))
[17:46:36.528]     }, error = function(ex) {
[17:46:36.528]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.528]                 ...future.rng), started = ...future.startTime, 
[17:46:36.528]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.528]             version = "1.8"), class = "FutureResult")
[17:46:36.528]     }, finally = {
[17:46:36.528]         if (!identical(...future.workdir, getwd())) 
[17:46:36.528]             setwd(...future.workdir)
[17:46:36.528]         {
[17:46:36.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.528]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.528]             }
[17:46:36.528]             base::options(...future.oldOptions)
[17:46:36.528]             if (.Platform$OS.type == "windows") {
[17:46:36.528]                 old_names <- names(...future.oldEnvVars)
[17:46:36.528]                 envs <- base::Sys.getenv()
[17:46:36.528]                 names <- names(envs)
[17:46:36.528]                 common <- intersect(names, old_names)
[17:46:36.528]                 added <- setdiff(names, old_names)
[17:46:36.528]                 removed <- setdiff(old_names, names)
[17:46:36.528]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.528]                   envs[common]]
[17:46:36.528]                 NAMES <- toupper(changed)
[17:46:36.528]                 args <- list()
[17:46:36.528]                 for (kk in seq_along(NAMES)) {
[17:46:36.528]                   name <- changed[[kk]]
[17:46:36.528]                   NAME <- NAMES[[kk]]
[17:46:36.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.528]                     next
[17:46:36.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.528]                 }
[17:46:36.528]                 NAMES <- toupper(added)
[17:46:36.528]                 for (kk in seq_along(NAMES)) {
[17:46:36.528]                   name <- added[[kk]]
[17:46:36.528]                   NAME <- NAMES[[kk]]
[17:46:36.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.528]                     next
[17:46:36.528]                   args[[name]] <- ""
[17:46:36.528]                 }
[17:46:36.528]                 NAMES <- toupper(removed)
[17:46:36.528]                 for (kk in seq_along(NAMES)) {
[17:46:36.528]                   name <- removed[[kk]]
[17:46:36.528]                   NAME <- NAMES[[kk]]
[17:46:36.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.528]                     next
[17:46:36.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.528]                 }
[17:46:36.528]                 if (length(args) > 0) 
[17:46:36.528]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.528]             }
[17:46:36.528]             else {
[17:46:36.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.528]             }
[17:46:36.528]             {
[17:46:36.528]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.528]                   0L) {
[17:46:36.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.528]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.528]                   base::options(opts)
[17:46:36.528]                 }
[17:46:36.528]                 {
[17:46:36.528]                   {
[17:46:36.528]                     NULL
[17:46:36.528]                     RNGkind("Mersenne-Twister")
[17:46:36.528]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.528]                       inherits = FALSE)
[17:46:36.528]                   }
[17:46:36.528]                   options(future.plan = NULL)
[17:46:36.528]                   if (is.na(NA_character_)) 
[17:46:36.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.528]                     .init = FALSE)
[17:46:36.528]                 }
[17:46:36.528]             }
[17:46:36.528]         }
[17:46:36.528]     })
[17:46:36.528]     if (TRUE) {
[17:46:36.528]         base::sink(type = "output", split = FALSE)
[17:46:36.528]         if (TRUE) {
[17:46:36.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.528]         }
[17:46:36.528]         else {
[17:46:36.528]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.528]         }
[17:46:36.528]         base::close(...future.stdout)
[17:46:36.528]         ...future.stdout <- NULL
[17:46:36.528]     }
[17:46:36.528]     ...future.result$conditions <- ...future.conditions
[17:46:36.528]     ...future.result$finished <- base::Sys.time()
[17:46:36.528]     ...future.result
[17:46:36.528] }
[17:46:36.529] plan(): Setting new future strategy stack:
[17:46:36.529] List of future strategies:
[17:46:36.529] 1. sequential:
[17:46:36.529]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.529]    - tweaked: FALSE
[17:46:36.529]    - call: NULL
[17:46:36.530] plan(): nbrOfWorkers() = 1
[17:46:36.561] plan(): Setting new future strategy stack:
[17:46:36.561] List of future strategies:
[17:46:36.561] 1. sequential:
[17:46:36.561]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.561]    - tweaked: FALSE
[17:46:36.561]    - call: plan(strategy)
[17:46:36.561] plan(): nbrOfWorkers() = 1
[17:46:36.562] SequentialFuture started (and completed)
[17:46:36.562] signalConditions() ...
[17:46:36.562]  - include = ‘immediateCondition’
[17:46:36.562]  - exclude = 
[17:46:36.562]  - resignal = FALSE
[17:46:36.562]  - Number of conditions: 88
[17:46:36.562] signalConditions() ... done
[17:46:36.562] - Launch lazy future ... done
[17:46:36.562] run() for ‘SequentialFuture’ ... done
[17:46:36.562] signalConditions() ...
[17:46:36.563]  - include = ‘immediateCondition’
[17:46:36.563]  - exclude = 
[17:46:36.563]  - resignal = FALSE
[17:46:36.563]  - Number of conditions: 88
[17:46:36.563] signalConditions() ... done
[17:46:36.563] Future state: ‘finished’
[17:46:36.563] signalConditions() ...
[17:46:36.564]  - include = ‘condition’
[17:46:36.564]  - exclude = ‘immediateCondition’
[17:46:36.564]  - resignal = TRUE
[17:46:36.565]  - Number of conditions: 88
[17:46:36.565]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.530] getGlobalsAndPackages() ...
[17:46:36.565]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.530] Searching for globals...
[17:46:36.565]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.544] 
[17:46:36.565]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.544] Searching for globals ... DONE
[17:46:36.565]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.545] - globals: [0] <none>
[17:46:36.565]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.545] getGlobalsAndPackages() ... DONE
[17:46:36.565]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.545] run() for ‘Future’ ...
[17:46:36.566]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.545] - state: ‘created’
[17:46:36.566]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.545] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.566]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.545] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.566]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.545] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.566]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.546]   - Field: ‘label’
[17:46:36.566]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.546]   - Field: ‘local’
[17:46:36.566]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.546]   - Field: ‘owner’
[17:46:36.566]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.546]   - Field: ‘envir’
[17:46:36.567]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.546]   - Field: ‘packages’
[17:46:36.567]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.546]   - Field: ‘gc’
[17:46:36.567]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.546]   - Field: ‘conditions’
[17:46:36.567]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.546]   - Field: ‘expr’
[17:46:36.567]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.546]   - Field: ‘uuid’
[17:46:36.567]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.546]   - Field: ‘seed’
[17:46:36.567]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.547]   - Field: ‘version’
[17:46:36.567]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.547]   - Field: ‘result’
[17:46:36.568]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.547]   - Field: ‘asynchronous’
[17:46:36.568]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.547]   - Field: ‘calls’
[17:46:36.568]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.547]   - Field: ‘globals’
[17:46:36.568]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.547]   - Field: ‘stdout’
[17:46:36.568]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.547]   - Field: ‘earlySignal’
[17:46:36.568]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.547]   - Field: ‘lazy’
[17:46:36.568]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.547]   - Field: ‘state’
[17:46:36.568]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.547] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.569]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.548] - Launch lazy future ...
[17:46:36.569]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.548] Packages needed by the future expression (n = 0): <none>
[17:46:36.569]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.548] Packages needed by future strategies (n = 0): <none>
[17:46:36.569]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.548] {
[17:46:36.548]     {
[17:46:36.548]         {
[17:46:36.548]             ...future.startTime <- base::Sys.time()
[17:46:36.548]             {
[17:46:36.548]                 {
[17:46:36.548]                   {
[17:46:36.548]                     base::local({
[17:46:36.548]                       has_future <- base::requireNamespace("future", 
[17:46:36.548]                         quietly = TRUE)
[17:46:36.548]                       if (has_future) {
[17:46:36.548]                         ns <- base::getNamespace("future")
[17:46:36.548]                         version <- ns[[".package"]][["version"]]
[17:46:36.548]                         if (is.null(version)) 
[17:46:36.548]                           version <- utils::packageVersion("future")
[17:46:36.548]                       }
[17:46:36.548]                       else {
[17:46:36.548]                         version <- NULL
[17:46:36.548]                       }
[17:46:36.548]                       if (!has_future || version < "1.8.0") {
[17:46:36.548]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.548]                           "", base::R.version$version.string), 
[17:46:36.548]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:36.548]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.548]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.548]                             "release", "version")], collapse = " "), 
[17:46:36.548]                           hostname = base::Sys.info()[["nodename"]])
[17:46:36.548]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.548]                           info)
[17:46:36.548]                         info <- base::paste(info, collapse = "; ")
[17:46:36.548]                         if (!has_future) {
[17:46:36.548]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.548]                             info)
[17:46:36.548]                         }
[17:46:36.548]                         else {
[17:46:36.548]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.548]                             info, version)
[17:46:36.548]                         }
[17:46:36.548]                         base::stop(msg)
[17:46:36.548]                       }
[17:46:36.548]                     })
[17:46:36.548]                   }
[17:46:36.548]                   ...future.strategy.old <- future::plan("list")
[17:46:36.548]                   options(future.plan = NULL)
[17:46:36.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.548]                 }
[17:46:36.548]                 ...future.workdir <- getwd()
[17:46:36.548]             }
[17:46:36.548]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.548]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.548]         }
[17:46:36.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.548]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.548]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.548]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.548]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.548]             base::names(...future.oldOptions))
[17:46:36.548]     }
[17:46:36.548]     if (FALSE) {
[17:46:36.548]     }
[17:46:36.548]     else {
[17:46:36.548]         if (TRUE) {
[17:46:36.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.548]                 open = "w")
[17:46:36.548]         }
[17:46:36.548]         else {
[17:46:36.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.548]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.548]         }
[17:46:36.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.548]             base::sink(type = "output", split = FALSE)
[17:46:36.548]             base::close(...future.stdout)
[17:46:36.548]         }, add = TRUE)
[17:46:36.548]     }
[17:46:36.548]     ...future.frame <- base::sys.nframe()
[17:46:36.548]     ...future.conditions <- base::list()
[17:46:36.548]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.548]     if (FALSE) {
[17:46:36.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.548]     }
[17:46:36.548]     ...future.result <- base::tryCatch({
[17:46:36.548]         base::withCallingHandlers({
[17:46:36.548]             ...future.value <- base::withVisible(base::local(2))
[17:46:36.548]             future::FutureResult(value = ...future.value$value, 
[17:46:36.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.548]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.548]                     ...future.globalenv.names))
[17:46:36.548]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.548]         }, condition = base::local({
[17:46:36.548]             c <- base::c
[17:46:36.548]             inherits <- base::inherits
[17:46:36.548]             invokeRestart <- base::invokeRestart
[17:46:36.548]             length <- base::length
[17:46:36.548]             list <- base::list
[17:46:36.548]             seq.int <- base::seq.int
[17:46:36.548]             signalCondition <- base::signalCondition
[17:46:36.548]             sys.calls <- base::sys.calls
[17:46:36.548]             `[[` <- base::`[[`
[17:46:36.548]             `+` <- base::`+`
[17:46:36.548]             `<<-` <- base::`<<-`
[17:46:36.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.548]                   3L)]
[17:46:36.548]             }
[17:46:36.548]             function(cond) {
[17:46:36.548]                 is_error <- inherits(cond, "error")
[17:46:36.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.548]                   NULL)
[17:46:36.548]                 if (is_error) {
[17:46:36.548]                   sessionInformation <- function() {
[17:46:36.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.548]                       search = base::search(), system = base::Sys.info())
[17:46:36.548]                   }
[17:46:36.548]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.548]                     cond$call), session = sessionInformation(), 
[17:46:36.548]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.548]                   signalCondition(cond)
[17:46:36.548]                 }
[17:46:36.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.548]                 "immediateCondition"))) {
[17:46:36.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.548]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.548]                   if (TRUE && !signal) {
[17:46:36.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.548]                     {
[17:46:36.548]                       inherits <- base::inherits
[17:46:36.548]                       invokeRestart <- base::invokeRestart
[17:46:36.548]                       is.null <- base::is.null
[17:46:36.548]                       muffled <- FALSE
[17:46:36.548]                       if (inherits(cond, "message")) {
[17:46:36.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.548]                         if (muffled) 
[17:46:36.548]                           invokeRestart("muffleMessage")
[17:46:36.548]                       }
[17:46:36.548]                       else if (inherits(cond, "warning")) {
[17:46:36.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.548]                         if (muffled) 
[17:46:36.548]                           invokeRestart("muffleWarning")
[17:46:36.548]                       }
[17:46:36.548]                       else if (inherits(cond, "condition")) {
[17:46:36.548]                         if (!is.null(pattern)) {
[17:46:36.548]                           computeRestarts <- base::computeRestarts
[17:46:36.548]                           grepl <- base::grepl
[17:46:36.548]                           restarts <- computeRestarts(cond)
[17:46:36.548]                           for (restart in restarts) {
[17:46:36.548]                             name <- restart$name
[17:46:36.548]                             if (is.null(name)) 
[17:46:36.548]                               next
[17:46:36.548]                             if (!grepl(pattern, name)) 
[17:46:36.548]                               next
[17:46:36.548]                             invokeRestart(restart)
[17:46:36.548]                             muffled <- TRUE
[17:46:36.548]                             break
[17:46:36.548]                           }
[17:46:36.548]                         }
[17:46:36.548]                       }
[17:46:36.548]                       invisible(muffled)
[17:46:36.548]                     }
[17:46:36.548]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.548]                   }
[17:46:36.548]                 }
[17:46:36.548]                 else {
[17:46:36.548]                   if (TRUE) {
[17:46:36.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.548]                     {
[17:46:36.548]                       inherits <- base::inherits
[17:46:36.548]                       invokeRestart <- base::invokeRestart
[17:46:36.548]                       is.null <- base::is.null
[17:46:36.548]                       muffled <- FALSE
[17:46:36.548]                       if (inherits(cond, "message")) {
[17:46:36.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.548]                         if (muffled) 
[17:46:36.548]                           invokeRestart("muffleMessage")
[17:46:36.548]                       }
[17:46:36.548]                       else if (inherits(cond, "warning")) {
[17:46:36.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.548]                         if (muffled) 
[17:46:36.548]                           invokeRestart("muffleWarning")
[17:46:36.548]                       }
[17:46:36.548]                       else if (inherits(cond, "condition")) {
[17:46:36.548]                         if (!is.null(pattern)) {
[17:46:36.548]                           computeRestarts <- base::computeRestarts
[17:46:36.548]                           grepl <- base::grepl
[17:46:36.548]                           restarts <- computeRestarts(cond)
[17:46:36.548]                           for (restart in restarts) {
[17:46:36.548]                             name <- restart$name
[17:46:36.548]                             if (is.null(name)) 
[17:46:36.548]                               next
[17:46:36.548]                             if (!grepl(pattern, name)) 
[17:46:36.548]                               next
[17:46:36.548]                             invokeRestart(restart)
[17:46:36.548]                             muffled <- TRUE
[17:46:36.548]                             break
[17:46:36.548]                           }
[17:46:36.548]                         }
[17:46:36.548]                       }
[17:46:36.548]                       invisible(muffled)
[17:46:36.548]                     }
[17:46:36.548]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.548]                   }
[17:46:36.548]                 }
[17:46:36.548]             }
[17:46:36.548]         }))
[17:46:36.548]     }, error = function(ex) {
[17:46:36.548]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.548]                 ...future.rng), started = ...future.startTime, 
[17:46:36.548]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.548]             version = "1.8"), class = "FutureResult")
[17:46:36.548]     }, finally = {
[17:46:36.548]         if (!identical(...future.workdir, getwd())) 
[17:46:36.548]             setwd(...future.workdir)
[17:46:36.548]         {
[17:46:36.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.548]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.548]             }
[17:46:36.548]             base::options(...future.oldOptions)
[17:46:36.548]             if (.Platform$OS.type == "windows") {
[17:46:36.548]                 old_names <- names(...future.oldEnvVars)
[17:46:36.548]                 envs <- base::Sys.getenv()
[17:46:36.548]                 names <- names(envs)
[17:46:36.548]                 common <- intersect(names, old_names)
[17:46:36.548]                 added <- setdiff(names, old_names)
[17:46:36.548]                 removed <- setdiff(old_names, names)
[17:46:36.548]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.548]                   envs[common]]
[17:46:36.548]                 NAMES <- toupper(changed)
[17:46:36.548]                 args <- list()
[17:46:36.548]                 for (kk in seq_along(NAMES)) {
[17:46:36.548]                   name <- changed[[kk]]
[17:46:36.548]                   NAME <- NAMES[[kk]]
[17:46:36.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.548]                     next
[17:46:36.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.548]                 }
[17:46:36.548]                 NAMES <- toupper(added)
[17:46:36.548]                 for (kk in seq_along(NAMES)) {
[17:46:36.548]                   name <- added[[kk]]
[17:46:36.548]                   NAME <- NAMES[[kk]]
[17:46:36.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.548]                     next
[17:46:36.548]                   args[[name]] <- ""
[17:46:36.548]                 }
[17:46:36.548]                 NAMES <- toupper(removed)
[17:46:36.548]                 for (kk in seq_along(NAMES)) {
[17:46:36.548]                   name <- removed[[kk]]
[17:46:36.548]                   NAME <- NAMES[[kk]]
[17:46:36.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.548]                     next
[17:46:36.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.548]                 }
[17:46:36.548]                 if (length(args) > 0) 
[17:46:36.548]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.548]             }
[17:46:36.548]             else {
[17:46:36.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.548]             }
[17:46:36.548]             {
[17:46:36.548]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.548]                   0L) {
[17:46:36.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.548]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.548]                   base::options(opts)
[17:46:36.548]                 }
[17:46:36.548]                 {
[17:46:36.548]                   {
[17:46:36.548]                     NULL
[17:46:36.548]                     RNGkind("Mersenne-Twister")
[17:46:36.548]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.548]                       inherits = FALSE)
[17:46:36.548]                   }
[17:46:36.548]                   options(future.plan = NULL)
[17:46:36.548]                   if (is.na(NA_character_)) 
[17:46:36.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.548]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.548]                     .init = FALSE)
[17:46:36.548]                 }
[17:46:36.548]             }
[17:46:36.548]         }
[17:46:36.548]     })
[17:46:36.548]     if (TRUE) {
[17:46:36.548]         base::sink(type = "output", split = FALSE)
[17:46:36.548]         if (TRUE) {
[17:46:36.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.548]         }
[17:46:36.548]         else {
[17:46:36.548]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.548]         }
[17:46:36.548]         base::close(...future.stdout)
[17:46:36.548]         ...future.stdout <- NULL
[17:46:36.548]     }
[17:46:36.548]     ...future.result$conditions <- ...future.conditions
[17:46:36.548]     ...future.result$finished <- base::Sys.time()
[17:46:36.548]     ...future.result
[17:46:36.548] }
[17:46:36.569]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.550] plan(): Setting new future strategy stack:
[17:46:36.569]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.550] List of future strategies:
[17:46:36.550] 1. sequential:
[17:46:36.550]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.550]    - tweaked: FALSE
[17:46:36.550]    - call: NULL
[17:46:36.569]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.550] plan(): nbrOfWorkers() = 1
[17:46:36.569]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.551] plan(): Setting new future strategy stack:
[17:46:36.570]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.551] List of future strategies:
[17:46:36.551] 1. sequential:
[17:46:36.551]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.551]    - tweaked: FALSE
[17:46:36.551]    - call: NULL
[17:46:36.570]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.552] plan(): nbrOfWorkers() = 1
[17:46:36.570]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.552] SequentialFuture started (and completed)
[17:46:36.570]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.552] - Launch lazy future ... done
[17:46:36.570]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.552] run() for ‘SequentialFuture’ ... done
[17:46:36.570]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.552] getGlobalsAndPackages() ...
[17:46:36.570]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.552] Searching for globals...
[17:46:36.570]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.553] 
[17:46:36.570]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.553] Searching for globals ... DONE
[17:46:36.571]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.553] - globals: [0] <none>
[17:46:36.571]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.553] getGlobalsAndPackages() ... DONE
[17:46:36.571]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.553] run() for ‘Future’ ...
[17:46:36.571]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.553] - state: ‘created’
[17:46:36.571]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.553] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.571]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.554] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.571]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.554] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.571]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.554]   - Field: ‘label’
[17:46:36.572]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.554]   - Field: ‘local’
[17:46:36.572]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.554]   - Field: ‘owner’
[17:46:36.572]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.554]   - Field: ‘envir’
[17:46:36.572]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.554]   - Field: ‘packages’
[17:46:36.572]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.554]   - Field: ‘gc’
[17:46:36.572]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.555]   - Field: ‘conditions’
[17:46:36.572]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.555]   - Field: ‘expr’
[17:46:36.572]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.555]   - Field: ‘uuid’
[17:46:36.573]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.555]   - Field: ‘seed’
[17:46:36.573]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.555]   - Field: ‘version’
[17:46:36.573]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.555]   - Field: ‘result’
[17:46:36.573]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.555]   - Field: ‘asynchronous’
[17:46:36.573]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.555]   - Field: ‘calls’
[17:46:36.573]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.555]   - Field: ‘globals’
[17:46:36.573]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.555]   - Field: ‘stdout’
[17:46:36.573]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.556]   - Field: ‘earlySignal’
[17:46:36.574]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.556]   - Field: ‘lazy’
[17:46:36.574]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.556]   - Field: ‘state’
[17:46:36.574]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.556] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.574]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.556] - Launch lazy future ...
[17:46:36.574]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.556] Packages needed by the future expression (n = 0): <none>
[17:46:36.574]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.556] Packages needed by future strategies (n = 0): <none>
[17:46:36.574]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.557] {
[17:46:36.557]     {
[17:46:36.557]         {
[17:46:36.557]             ...future.startTime <- base::Sys.time()
[17:46:36.557]             {
[17:46:36.557]                 {
[17:46:36.557]                   {
[17:46:36.557]                     base::local({
[17:46:36.557]                       has_future <- base::requireNamespace("future", 
[17:46:36.557]                         quietly = TRUE)
[17:46:36.557]                       if (has_future) {
[17:46:36.557]                         ns <- base::getNamespace("future")
[17:46:36.557]                         version <- ns[[".package"]][["version"]]
[17:46:36.557]                         if (is.null(version)) 
[17:46:36.557]                           version <- utils::packageVersion("future")
[17:46:36.557]                       }
[17:46:36.557]                       else {
[17:46:36.557]                         version <- NULL
[17:46:36.557]                       }
[17:46:36.557]                       if (!has_future || version < "1.8.0") {
[17:46:36.557]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.557]                           "", base::R.version$version.string), 
[17:46:36.557]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:36.557]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.557]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.557]                             "release", "version")], collapse = " "), 
[17:46:36.557]                           hostname = base::Sys.info()[["nodename"]])
[17:46:36.557]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.557]                           info)
[17:46:36.557]                         info <- base::paste(info, collapse = "; ")
[17:46:36.557]                         if (!has_future) {
[17:46:36.557]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.557]                             info)
[17:46:36.557]                         }
[17:46:36.557]                         else {
[17:46:36.557]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.557]                             info, version)
[17:46:36.557]                         }
[17:46:36.557]                         base::stop(msg)
[17:46:36.557]                       }
[17:46:36.557]                     })
[17:46:36.557]                   }
[17:46:36.557]                   ...future.strategy.old <- future::plan("list")
[17:46:36.557]                   options(future.plan = NULL)
[17:46:36.557]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.557]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.557]                 }
[17:46:36.557]                 ...future.workdir <- getwd()
[17:46:36.557]             }
[17:46:36.557]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.557]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.557]         }
[17:46:36.557]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.557]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.557]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.557]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.557]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.557]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.557]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.557]             base::names(...future.oldOptions))
[17:46:36.557]     }
[17:46:36.557]     if (FALSE) {
[17:46:36.557]     }
[17:46:36.557]     else {
[17:46:36.557]         if (TRUE) {
[17:46:36.557]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.557]                 open = "w")
[17:46:36.557]         }
[17:46:36.557]         else {
[17:46:36.557]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.557]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.557]         }
[17:46:36.557]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.557]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.557]             base::sink(type = "output", split = FALSE)
[17:46:36.557]             base::close(...future.stdout)
[17:46:36.557]         }, add = TRUE)
[17:46:36.557]     }
[17:46:36.557]     ...future.frame <- base::sys.nframe()
[17:46:36.557]     ...future.conditions <- base::list()
[17:46:36.557]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.557]     if (FALSE) {
[17:46:36.557]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.557]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.557]     }
[17:46:36.557]     ...future.result <- base::tryCatch({
[17:46:36.557]         base::withCallingHandlers({
[17:46:36.557]             ...future.value <- base::withVisible(base::local(4))
[17:46:36.557]             future::FutureResult(value = ...future.value$value, 
[17:46:36.557]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.557]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.557]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.557]                     ...future.globalenv.names))
[17:46:36.557]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.557]         }, condition = base::local({
[17:46:36.557]             c <- base::c
[17:46:36.557]             inherits <- base::inherits
[17:46:36.557]             invokeRestart <- base::invokeRestart
[17:46:36.557]             length <- base::length
[17:46:36.557]             list <- base::list
[17:46:36.557]             seq.int <- base::seq.int
[17:46:36.557]             signalCondition <- base::signalCondition
[17:46:36.557]             sys.calls <- base::sys.calls
[17:46:36.557]             `[[` <- base::`[[`
[17:46:36.557]             `+` <- base::`+`
[17:46:36.557]             `<<-` <- base::`<<-`
[17:46:36.557]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.557]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.557]                   3L)]
[17:46:36.557]             }
[17:46:36.557]             function(cond) {
[17:46:36.557]                 is_error <- inherits(cond, "error")
[17:46:36.557]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.557]                   NULL)
[17:46:36.557]                 if (is_error) {
[17:46:36.557]                   sessionInformation <- function() {
[17:46:36.557]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.557]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.557]                       search = base::search(), system = base::Sys.info())
[17:46:36.557]                   }
[17:46:36.557]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.557]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.557]                     cond$call), session = sessionInformation(), 
[17:46:36.557]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.557]                   signalCondition(cond)
[17:46:36.557]                 }
[17:46:36.557]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.557]                 "immediateCondition"))) {
[17:46:36.557]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.557]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.557]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.557]                   if (TRUE && !signal) {
[17:46:36.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.557]                     {
[17:46:36.557]                       inherits <- base::inherits
[17:46:36.557]                       invokeRestart <- base::invokeRestart
[17:46:36.557]                       is.null <- base::is.null
[17:46:36.557]                       muffled <- FALSE
[17:46:36.557]                       if (inherits(cond, "message")) {
[17:46:36.557]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.557]                         if (muffled) 
[17:46:36.557]                           invokeRestart("muffleMessage")
[17:46:36.557]                       }
[17:46:36.557]                       else if (inherits(cond, "warning")) {
[17:46:36.557]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.557]                         if (muffled) 
[17:46:36.557]                           invokeRestart("muffleWarning")
[17:46:36.557]                       }
[17:46:36.557]                       else if (inherits(cond, "condition")) {
[17:46:36.557]                         if (!is.null(pattern)) {
[17:46:36.557]                           computeRestarts <- base::computeRestarts
[17:46:36.557]                           grepl <- base::grepl
[17:46:36.557]                           restarts <- computeRestarts(cond)
[17:46:36.557]                           for (restart in restarts) {
[17:46:36.557]                             name <- restart$name
[17:46:36.557]                             if (is.null(name)) 
[17:46:36.557]                               next
[17:46:36.557]                             if (!grepl(pattern, name)) 
[17:46:36.557]                               next
[17:46:36.557]                             invokeRestart(restart)
[17:46:36.557]                             muffled <- TRUE
[17:46:36.557]                             break
[17:46:36.557]                           }
[17:46:36.557]                         }
[17:46:36.557]                       }
[17:46:36.557]                       invisible(muffled)
[17:46:36.557]                     }
[17:46:36.557]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.557]                   }
[17:46:36.557]                 }
[17:46:36.557]                 else {
[17:46:36.557]                   if (TRUE) {
[17:46:36.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.557]                     {
[17:46:36.557]                       inherits <- base::inherits
[17:46:36.557]                       invokeRestart <- base::invokeRestart
[17:46:36.557]                       is.null <- base::is.null
[17:46:36.557]                       muffled <- FALSE
[17:46:36.557]                       if (inherits(cond, "message")) {
[17:46:36.557]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.557]                         if (muffled) 
[17:46:36.557]                           invokeRestart("muffleMessage")
[17:46:36.557]                       }
[17:46:36.557]                       else if (inherits(cond, "warning")) {
[17:46:36.557]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.557]                         if (muffled) 
[17:46:36.557]                           invokeRestart("muffleWarning")
[17:46:36.557]                       }
[17:46:36.557]                       else if (inherits(cond, "condition")) {
[17:46:36.557]                         if (!is.null(pattern)) {
[17:46:36.557]                           computeRestarts <- base::computeRestarts
[17:46:36.557]                           grepl <- base::grepl
[17:46:36.557]                           restarts <- computeRestarts(cond)
[17:46:36.557]                           for (restart in restarts) {
[17:46:36.557]                             name <- restart$name
[17:46:36.557]                             if (is.null(name)) 
[17:46:36.557]                               next
[17:46:36.557]                             if (!grepl(pattern, name)) 
[17:46:36.557]                               next
[17:46:36.557]                             invokeRestart(restart)
[17:46:36.557]                             muffled <- TRUE
[17:46:36.557]                             break
[17:46:36.557]                           }
[17:46:36.557]                         }
[17:46:36.557]                       }
[17:46:36.557]                       invisible(muffled)
[17:46:36.557]                     }
[17:46:36.557]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.557]                   }
[17:46:36.557]                 }
[17:46:36.557]             }
[17:46:36.557]         }))
[17:46:36.557]     }, error = function(ex) {
[17:46:36.557]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.557]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.557]                 ...future.rng), started = ...future.startTime, 
[17:46:36.557]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.557]             version = "1.8"), class = "FutureResult")
[17:46:36.557]     }, finally = {
[17:46:36.557]         if (!identical(...future.workdir, getwd())) 
[17:46:36.557]             setwd(...future.workdir)
[17:46:36.557]         {
[17:46:36.557]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.557]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.557]             }
[17:46:36.557]             base::options(...future.oldOptions)
[17:46:36.557]             if (.Platform$OS.type == "windows") {
[17:46:36.557]                 old_names <- names(...future.oldEnvVars)
[17:46:36.557]                 envs <- base::Sys.getenv()
[17:46:36.557]                 names <- names(envs)
[17:46:36.557]                 common <- intersect(names, old_names)
[17:46:36.557]                 added <- setdiff(names, old_names)
[17:46:36.557]                 removed <- setdiff(old_names, names)
[17:46:36.557]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.557]                   envs[common]]
[17:46:36.557]                 NAMES <- toupper(changed)
[17:46:36.557]                 args <- list()
[17:46:36.557]                 for (kk in seq_along(NAMES)) {
[17:46:36.557]                   name <- changed[[kk]]
[17:46:36.557]                   NAME <- NAMES[[kk]]
[17:46:36.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.557]                     next
[17:46:36.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.557]                 }
[17:46:36.557]                 NAMES <- toupper(added)
[17:46:36.557]                 for (kk in seq_along(NAMES)) {
[17:46:36.557]                   name <- added[[kk]]
[17:46:36.557]                   NAME <- NAMES[[kk]]
[17:46:36.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.557]                     next
[17:46:36.557]                   args[[name]] <- ""
[17:46:36.557]                 }
[17:46:36.557]                 NAMES <- toupper(removed)
[17:46:36.557]                 for (kk in seq_along(NAMES)) {
[17:46:36.557]                   name <- removed[[kk]]
[17:46:36.557]                   NAME <- NAMES[[kk]]
[17:46:36.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.557]                     next
[17:46:36.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.557]                 }
[17:46:36.557]                 if (length(args) > 0) 
[17:46:36.557]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.557]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.557]             }
[17:46:36.557]             else {
[17:46:36.557]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.557]             }
[17:46:36.557]             {
[17:46:36.557]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.557]                   0L) {
[17:46:36.557]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.557]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.557]                   base::options(opts)
[17:46:36.557]                 }
[17:46:36.557]                 {
[17:46:36.557]                   {
[17:46:36.557]                     NULL
[17:46:36.557]                     RNGkind("Mersenne-Twister")
[17:46:36.557]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.557]                       inherits = FALSE)
[17:46:36.557]                   }
[17:46:36.557]                   options(future.plan = NULL)
[17:46:36.557]                   if (is.na(NA_character_)) 
[17:46:36.557]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.557]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.557]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.557]                     .init = FALSE)
[17:46:36.557]                 }
[17:46:36.557]             }
[17:46:36.557]         }
[17:46:36.557]     })
[17:46:36.557]     if (TRUE) {
[17:46:36.557]         base::sink(type = "output", split = FALSE)
[17:46:36.557]         if (TRUE) {
[17:46:36.557]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.557]         }
[17:46:36.557]         else {
[17:46:36.557]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.557]         }
[17:46:36.557]         base::close(...future.stdout)
[17:46:36.557]         ...future.stdout <- NULL
[17:46:36.557]     }
[17:46:36.557]     ...future.result$conditions <- ...future.conditions
[17:46:36.557]     ...future.result$finished <- base::Sys.time()
[17:46:36.557]     ...future.result
[17:46:36.557] }
[17:46:36.574]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.558] plan(): Setting new future strategy stack:
[17:46:36.574]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.558] List of future strategies:
[17:46:36.558] 1. sequential:
[17:46:36.558]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.558]    - tweaked: FALSE
[17:46:36.558]    - call: NULL
[17:46:36.575]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.559] plan(): nbrOfWorkers() = 1
[17:46:36.575]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.559] plan(): Setting new future strategy stack:
[17:46:36.575]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.560] List of future strategies:
[17:46:36.560] 1. sequential:
[17:46:36.560]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.560]    - tweaked: FALSE
[17:46:36.560]    - call: NULL
[17:46:36.575]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.560] plan(): nbrOfWorkers() = 1
[17:46:36.575]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.560] SequentialFuture started (and completed)
[17:46:36.575]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.560] - Launch lazy future ... done
[17:46:36.576]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.560] run() for ‘SequentialFuture’ ... done
[17:46:36.576] signalConditions() ... done
a = 10
[17:46:36.576] getGlobalsAndPackages() ...
[17:46:36.576] Searching for globals...
[17:46:36.577] - globals found: [3] ‘{’, ‘+’, ‘a’
[17:46:36.577] Searching for globals ... DONE
[17:46:36.577] Resolving globals: FALSE
[17:46:36.577] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:36.578] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:46:36.578] - globals: [1] ‘a’
[17:46:36.578] 
[17:46:36.578] getGlobalsAndPackages() ... DONE
[17:46:36.578] run() for ‘Future’ ...
[17:46:36.578] - state: ‘created’
[17:46:36.578] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.579] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.579] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.579]   - Field: ‘label’
[17:46:36.579]   - Field: ‘local’
[17:46:36.579]   - Field: ‘owner’
[17:46:36.579]   - Field: ‘envir’
[17:46:36.579]   - Field: ‘packages’
[17:46:36.579]   - Field: ‘gc’
[17:46:36.579]   - Field: ‘conditions’
[17:46:36.579]   - Field: ‘expr’
[17:46:36.580]   - Field: ‘uuid’
[17:46:36.580]   - Field: ‘seed’
[17:46:36.580]   - Field: ‘version’
[17:46:36.580]   - Field: ‘result’
[17:46:36.580]   - Field: ‘asynchronous’
[17:46:36.580]   - Field: ‘calls’
[17:46:36.580]   - Field: ‘globals’
[17:46:36.580]   - Field: ‘stdout’
[17:46:36.580]   - Field: ‘earlySignal’
[17:46:36.580]   - Field: ‘lazy’
[17:46:36.580]   - Field: ‘state’
[17:46:36.580] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.581] - Launch lazy future ...
[17:46:36.581] Packages needed by the future expression (n = 0): <none>
[17:46:36.581] Packages needed by future strategies (n = 0): <none>
[17:46:36.581] {
[17:46:36.581]     {
[17:46:36.581]         {
[17:46:36.581]             ...future.startTime <- base::Sys.time()
[17:46:36.581]             {
[17:46:36.581]                 {
[17:46:36.581]                   {
[17:46:36.581]                     base::local({
[17:46:36.581]                       has_future <- base::requireNamespace("future", 
[17:46:36.581]                         quietly = TRUE)
[17:46:36.581]                       if (has_future) {
[17:46:36.581]                         ns <- base::getNamespace("future")
[17:46:36.581]                         version <- ns[[".package"]][["version"]]
[17:46:36.581]                         if (is.null(version)) 
[17:46:36.581]                           version <- utils::packageVersion("future")
[17:46:36.581]                       }
[17:46:36.581]                       else {
[17:46:36.581]                         version <- NULL
[17:46:36.581]                       }
[17:46:36.581]                       if (!has_future || version < "1.8.0") {
[17:46:36.581]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.581]                           "", base::R.version$version.string), 
[17:46:36.581]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:36.581]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.581]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.581]                             "release", "version")], collapse = " "), 
[17:46:36.581]                           hostname = base::Sys.info()[["nodename"]])
[17:46:36.581]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.581]                           info)
[17:46:36.581]                         info <- base::paste(info, collapse = "; ")
[17:46:36.581]                         if (!has_future) {
[17:46:36.581]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.581]                             info)
[17:46:36.581]                         }
[17:46:36.581]                         else {
[17:46:36.581]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.581]                             info, version)
[17:46:36.581]                         }
[17:46:36.581]                         base::stop(msg)
[17:46:36.581]                       }
[17:46:36.581]                     })
[17:46:36.581]                   }
[17:46:36.581]                   ...future.strategy.old <- future::plan("list")
[17:46:36.581]                   options(future.plan = NULL)
[17:46:36.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.581]                 }
[17:46:36.581]                 ...future.workdir <- getwd()
[17:46:36.581]             }
[17:46:36.581]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.581]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.581]         }
[17:46:36.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.581]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.581]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.581]             base::names(...future.oldOptions))
[17:46:36.581]     }
[17:46:36.581]     if (FALSE) {
[17:46:36.581]     }
[17:46:36.581]     else {
[17:46:36.581]         if (TRUE) {
[17:46:36.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.581]                 open = "w")
[17:46:36.581]         }
[17:46:36.581]         else {
[17:46:36.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.581]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.581]         }
[17:46:36.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.581]             base::sink(type = "output", split = FALSE)
[17:46:36.581]             base::close(...future.stdout)
[17:46:36.581]         }, add = TRUE)
[17:46:36.581]     }
[17:46:36.581]     ...future.frame <- base::sys.nframe()
[17:46:36.581]     ...future.conditions <- base::list()
[17:46:36.581]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.581]     if (FALSE) {
[17:46:36.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.581]     }
[17:46:36.581]     ...future.result <- base::tryCatch({
[17:46:36.581]         base::withCallingHandlers({
[17:46:36.581]             ...future.value <- base::withVisible(base::local({
[17:46:36.581]                 a + 1
[17:46:36.581]             }))
[17:46:36.581]             future::FutureResult(value = ...future.value$value, 
[17:46:36.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.581]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.581]                     ...future.globalenv.names))
[17:46:36.581]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.581]         }, condition = base::local({
[17:46:36.581]             c <- base::c
[17:46:36.581]             inherits <- base::inherits
[17:46:36.581]             invokeRestart <- base::invokeRestart
[17:46:36.581]             length <- base::length
[17:46:36.581]             list <- base::list
[17:46:36.581]             seq.int <- base::seq.int
[17:46:36.581]             signalCondition <- base::signalCondition
[17:46:36.581]             sys.calls <- base::sys.calls
[17:46:36.581]             `[[` <- base::`[[`
[17:46:36.581]             `+` <- base::`+`
[17:46:36.581]             `<<-` <- base::`<<-`
[17:46:36.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.581]                   3L)]
[17:46:36.581]             }
[17:46:36.581]             function(cond) {
[17:46:36.581]                 is_error <- inherits(cond, "error")
[17:46:36.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.581]                   NULL)
[17:46:36.581]                 if (is_error) {
[17:46:36.581]                   sessionInformation <- function() {
[17:46:36.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.581]                       search = base::search(), system = base::Sys.info())
[17:46:36.581]                   }
[17:46:36.581]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.581]                     cond$call), session = sessionInformation(), 
[17:46:36.581]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.581]                   signalCondition(cond)
[17:46:36.581]                 }
[17:46:36.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.581]                 "immediateCondition"))) {
[17:46:36.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.581]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.581]                   if (TRUE && !signal) {
[17:46:36.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.581]                     {
[17:46:36.581]                       inherits <- base::inherits
[17:46:36.581]                       invokeRestart <- base::invokeRestart
[17:46:36.581]                       is.null <- base::is.null
[17:46:36.581]                       muffled <- FALSE
[17:46:36.581]                       if (inherits(cond, "message")) {
[17:46:36.581]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.581]                         if (muffled) 
[17:46:36.581]                           invokeRestart("muffleMessage")
[17:46:36.581]                       }
[17:46:36.581]                       else if (inherits(cond, "warning")) {
[17:46:36.581]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.581]                         if (muffled) 
[17:46:36.581]                           invokeRestart("muffleWarning")
[17:46:36.581]                       }
[17:46:36.581]                       else if (inherits(cond, "condition")) {
[17:46:36.581]                         if (!is.null(pattern)) {
[17:46:36.581]                           computeRestarts <- base::computeRestarts
[17:46:36.581]                           grepl <- base::grepl
[17:46:36.581]                           restarts <- computeRestarts(cond)
[17:46:36.581]                           for (restart in restarts) {
[17:46:36.581]                             name <- restart$name
[17:46:36.581]                             if (is.null(name)) 
[17:46:36.581]                               next
[17:46:36.581]                             if (!grepl(pattern, name)) 
[17:46:36.581]                               next
[17:46:36.581]                             invokeRestart(restart)
[17:46:36.581]                             muffled <- TRUE
[17:46:36.581]                             break
[17:46:36.581]                           }
[17:46:36.581]                         }
[17:46:36.581]                       }
[17:46:36.581]                       invisible(muffled)
[17:46:36.581]                     }
[17:46:36.581]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.581]                   }
[17:46:36.581]                 }
[17:46:36.581]                 else {
[17:46:36.581]                   if (TRUE) {
[17:46:36.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.581]                     {
[17:46:36.581]                       inherits <- base::inherits
[17:46:36.581]                       invokeRestart <- base::invokeRestart
[17:46:36.581]                       is.null <- base::is.null
[17:46:36.581]                       muffled <- FALSE
[17:46:36.581]                       if (inherits(cond, "message")) {
[17:46:36.581]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.581]                         if (muffled) 
[17:46:36.581]                           invokeRestart("muffleMessage")
[17:46:36.581]                       }
[17:46:36.581]                       else if (inherits(cond, "warning")) {
[17:46:36.581]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.581]                         if (muffled) 
[17:46:36.581]                           invokeRestart("muffleWarning")
[17:46:36.581]                       }
[17:46:36.581]                       else if (inherits(cond, "condition")) {
[17:46:36.581]                         if (!is.null(pattern)) {
[17:46:36.581]                           computeRestarts <- base::computeRestarts
[17:46:36.581]                           grepl <- base::grepl
[17:46:36.581]                           restarts <- computeRestarts(cond)
[17:46:36.581]                           for (restart in restarts) {
[17:46:36.581]                             name <- restart$name
[17:46:36.581]                             if (is.null(name)) 
[17:46:36.581]                               next
[17:46:36.581]                             if (!grepl(pattern, name)) 
[17:46:36.581]                               next
[17:46:36.581]                             invokeRestart(restart)
[17:46:36.581]                             muffled <- TRUE
[17:46:36.581]                             break
[17:46:36.581]                           }
[17:46:36.581]                         }
[17:46:36.581]                       }
[17:46:36.581]                       invisible(muffled)
[17:46:36.581]                     }
[17:46:36.581]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.581]                   }
[17:46:36.581]                 }
[17:46:36.581]             }
[17:46:36.581]         }))
[17:46:36.581]     }, error = function(ex) {
[17:46:36.581]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.581]                 ...future.rng), started = ...future.startTime, 
[17:46:36.581]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.581]             version = "1.8"), class = "FutureResult")
[17:46:36.581]     }, finally = {
[17:46:36.581]         if (!identical(...future.workdir, getwd())) 
[17:46:36.581]             setwd(...future.workdir)
[17:46:36.581]         {
[17:46:36.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.581]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.581]             }
[17:46:36.581]             base::options(...future.oldOptions)
[17:46:36.581]             if (.Platform$OS.type == "windows") {
[17:46:36.581]                 old_names <- names(...future.oldEnvVars)
[17:46:36.581]                 envs <- base::Sys.getenv()
[17:46:36.581]                 names <- names(envs)
[17:46:36.581]                 common <- intersect(names, old_names)
[17:46:36.581]                 added <- setdiff(names, old_names)
[17:46:36.581]                 removed <- setdiff(old_names, names)
[17:46:36.581]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.581]                   envs[common]]
[17:46:36.581]                 NAMES <- toupper(changed)
[17:46:36.581]                 args <- list()
[17:46:36.581]                 for (kk in seq_along(NAMES)) {
[17:46:36.581]                   name <- changed[[kk]]
[17:46:36.581]                   NAME <- NAMES[[kk]]
[17:46:36.581]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.581]                     next
[17:46:36.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.581]                 }
[17:46:36.581]                 NAMES <- toupper(added)
[17:46:36.581]                 for (kk in seq_along(NAMES)) {
[17:46:36.581]                   name <- added[[kk]]
[17:46:36.581]                   NAME <- NAMES[[kk]]
[17:46:36.581]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.581]                     next
[17:46:36.581]                   args[[name]] <- ""
[17:46:36.581]                 }
[17:46:36.581]                 NAMES <- toupper(removed)
[17:46:36.581]                 for (kk in seq_along(NAMES)) {
[17:46:36.581]                   name <- removed[[kk]]
[17:46:36.581]                   NAME <- NAMES[[kk]]
[17:46:36.581]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.581]                     next
[17:46:36.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.581]                 }
[17:46:36.581]                 if (length(args) > 0) 
[17:46:36.581]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.581]             }
[17:46:36.581]             else {
[17:46:36.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.581]             }
[17:46:36.581]             {
[17:46:36.581]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.581]                   0L) {
[17:46:36.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.581]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.581]                   base::options(opts)
[17:46:36.581]                 }
[17:46:36.581]                 {
[17:46:36.581]                   {
[17:46:36.581]                     NULL
[17:46:36.581]                     RNGkind("Mersenne-Twister")
[17:46:36.581]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.581]                       inherits = FALSE)
[17:46:36.581]                   }
[17:46:36.581]                   options(future.plan = NULL)
[17:46:36.581]                   if (is.na(NA_character_)) 
[17:46:36.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.581]                     .init = FALSE)
[17:46:36.581]                 }
[17:46:36.581]             }
[17:46:36.581]         }
[17:46:36.581]     })
[17:46:36.581]     if (TRUE) {
[17:46:36.581]         base::sink(type = "output", split = FALSE)
[17:46:36.581]         if (TRUE) {
[17:46:36.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.581]         }
[17:46:36.581]         else {
[17:46:36.581]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.581]         }
[17:46:36.581]         base::close(...future.stdout)
[17:46:36.581]         ...future.stdout <- NULL
[17:46:36.581]     }
[17:46:36.581]     ...future.result$conditions <- ...future.conditions
[17:46:36.581]     ...future.result$finished <- base::Sys.time()
[17:46:36.581]     ...future.result
[17:46:36.581] }
[17:46:36.583] assign_globals() ...
[17:46:36.583] List of 1
[17:46:36.583]  $ a: num 10
[17:46:36.583]  - attr(*, "where")=List of 1
[17:46:36.583]   ..$ a:<environment: R_EmptyEnv> 
[17:46:36.583]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:36.583]  - attr(*, "resolved")= logi FALSE
[17:46:36.583]  - attr(*, "total_size")= num 56
[17:46:36.583]  - attr(*, "already-done")= logi TRUE
[17:46:36.585] - copied ‘a’ to environment
[17:46:36.585] assign_globals() ... done
[17:46:36.586] plan(): Setting new future strategy stack:
[17:46:36.586] List of future strategies:
[17:46:36.586] 1. sequential:
[17:46:36.586]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.586]    - tweaked: FALSE
[17:46:36.586]    - call: NULL
[17:46:36.586] plan(): nbrOfWorkers() = 1
[17:46:36.587] plan(): Setting new future strategy stack:
[17:46:36.587] List of future strategies:
[17:46:36.587] 1. sequential:
[17:46:36.587]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.587]    - tweaked: FALSE
[17:46:36.587]    - call: plan(strategy)
[17:46:36.587] plan(): nbrOfWorkers() = 1
[17:46:36.587] SequentialFuture started (and completed)
[17:46:36.588] - Launch lazy future ... done
[17:46:36.589] run() for ‘SequentialFuture’ ... done
b = 11
*** %<-% with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** %<-% with ‘multicore’ futures ...
[17:46:36.594] plan(): Setting new future strategy stack:
[17:46:36.594] List of future strategies:
[17:46:36.594] 1. multicore:
[17:46:36.594]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:36.594]    - tweaked: FALSE
[17:46:36.594]    - call: plan(strategy)
[17:46:36.598] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[17:46:36.598] getGlobalsAndPackages() ...
[17:46:36.598] Searching for globals...
[17:46:36.599] - globals found: [2] ‘{’, ‘<-’
[17:46:36.599] Searching for globals ... DONE
[17:46:36.599] Resolving globals: FALSE
[17:46:36.600] 
[17:46:36.600] 
[17:46:36.600] getGlobalsAndPackages() ... DONE
[17:46:36.600] run() for ‘Future’ ...
[17:46:36.600] - state: ‘created’
[17:46:36.600] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:36.604] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:36.604] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:36.604]   - Field: ‘label’
[17:46:36.604]   - Field: ‘local’
[17:46:36.604]   - Field: ‘owner’
[17:46:36.604]   - Field: ‘envir’
[17:46:36.604]   - Field: ‘workers’
[17:46:36.604]   - Field: ‘packages’
[17:46:36.604]   - Field: ‘gc’
[17:46:36.604]   - Field: ‘job’
[17:46:36.605]   - Field: ‘conditions’
[17:46:36.605]   - Field: ‘expr’
[17:46:36.605]   - Field: ‘uuid’
[17:46:36.605]   - Field: ‘seed’
[17:46:36.605]   - Field: ‘version’
[17:46:36.605]   - Field: ‘result’
[17:46:36.605]   - Field: ‘asynchronous’
[17:46:36.605]   - Field: ‘calls’
[17:46:36.605]   - Field: ‘globals’
[17:46:36.605]   - Field: ‘stdout’
[17:46:36.605]   - Field: ‘earlySignal’
[17:46:36.606]   - Field: ‘lazy’
[17:46:36.606]   - Field: ‘state’
[17:46:36.606] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:36.606] - Launch lazy future ...
[17:46:36.607] Packages needed by the future expression (n = 0): <none>
[17:46:36.607] Packages needed by future strategies (n = 0): <none>
[17:46:36.607] {
[17:46:36.607]     {
[17:46:36.607]         {
[17:46:36.607]             ...future.startTime <- base::Sys.time()
[17:46:36.607]             {
[17:46:36.607]                 {
[17:46:36.607]                   {
[17:46:36.607]                     {
[17:46:36.607]                       base::local({
[17:46:36.607]                         has_future <- base::requireNamespace("future", 
[17:46:36.607]                           quietly = TRUE)
[17:46:36.607]                         if (has_future) {
[17:46:36.607]                           ns <- base::getNamespace("future")
[17:46:36.607]                           version <- ns[[".package"]][["version"]]
[17:46:36.607]                           if (is.null(version)) 
[17:46:36.607]                             version <- utils::packageVersion("future")
[17:46:36.607]                         }
[17:46:36.607]                         else {
[17:46:36.607]                           version <- NULL
[17:46:36.607]                         }
[17:46:36.607]                         if (!has_future || version < "1.8.0") {
[17:46:36.607]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.607]                             "", base::R.version$version.string), 
[17:46:36.607]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:36.607]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.607]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.607]                               "release", "version")], collapse = " "), 
[17:46:36.607]                             hostname = base::Sys.info()[["nodename"]])
[17:46:36.607]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.607]                             info)
[17:46:36.607]                           info <- base::paste(info, collapse = "; ")
[17:46:36.607]                           if (!has_future) {
[17:46:36.607]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.607]                               info)
[17:46:36.607]                           }
[17:46:36.607]                           else {
[17:46:36.607]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.607]                               info, version)
[17:46:36.607]                           }
[17:46:36.607]                           base::stop(msg)
[17:46:36.607]                         }
[17:46:36.607]                       })
[17:46:36.607]                     }
[17:46:36.607]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:36.607]                     base::options(mc.cores = 1L)
[17:46:36.607]                   }
[17:46:36.607]                   ...future.strategy.old <- future::plan("list")
[17:46:36.607]                   options(future.plan = NULL)
[17:46:36.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.607]                 }
[17:46:36.607]                 ...future.workdir <- getwd()
[17:46:36.607]             }
[17:46:36.607]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.607]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.607]         }
[17:46:36.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.607]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.607]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.607]             base::names(...future.oldOptions))
[17:46:36.607]     }
[17:46:36.607]     if (FALSE) {
[17:46:36.607]     }
[17:46:36.607]     else {
[17:46:36.607]         if (TRUE) {
[17:46:36.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.607]                 open = "w")
[17:46:36.607]         }
[17:46:36.607]         else {
[17:46:36.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.607]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.607]         }
[17:46:36.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.607]             base::sink(type = "output", split = FALSE)
[17:46:36.607]             base::close(...future.stdout)
[17:46:36.607]         }, add = TRUE)
[17:46:36.607]     }
[17:46:36.607]     ...future.frame <- base::sys.nframe()
[17:46:36.607]     ...future.conditions <- base::list()
[17:46:36.607]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.607]     if (FALSE) {
[17:46:36.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.607]     }
[17:46:36.607]     ...future.result <- base::tryCatch({
[17:46:36.607]         base::withCallingHandlers({
[17:46:36.607]             ...future.value <- base::withVisible(base::local({
[17:46:36.607]                 withCallingHandlers({
[17:46:36.607]                   {
[17:46:36.607]                     x <- 1
[17:46:36.607]                   }
[17:46:36.607]                 }, immediateCondition = function(cond) {
[17:46:36.607]                   save_rds <- function (object, pathname, ...) 
[17:46:36.607]                   {
[17:46:36.607]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:36.607]                     if (file_test("-f", pathname_tmp)) {
[17:46:36.607]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.607]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:36.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.607]                         fi_tmp[["mtime"]])
[17:46:36.607]                     }
[17:46:36.607]                     tryCatch({
[17:46:36.607]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:36.607]                     }, error = function(ex) {
[17:46:36.607]                       msg <- conditionMessage(ex)
[17:46:36.607]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.607]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:36.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.607]                         fi_tmp[["mtime"]], msg)
[17:46:36.607]                       ex$message <- msg
[17:46:36.607]                       stop(ex)
[17:46:36.607]                     })
[17:46:36.607]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:36.607]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:36.607]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:36.607]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.607]                       fi <- file.info(pathname)
[17:46:36.607]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:36.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.607]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:36.607]                         fi[["size"]], fi[["mtime"]])
[17:46:36.607]                       stop(msg)
[17:46:36.607]                     }
[17:46:36.607]                     invisible(pathname)
[17:46:36.607]                   }
[17:46:36.607]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:36.607]                     rootPath = tempdir()) 
[17:46:36.607]                   {
[17:46:36.607]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:36.607]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:36.607]                       tmpdir = path, fileext = ".rds")
[17:46:36.607]                     save_rds(obj, file)
[17:46:36.607]                   }
[17:46:36.607]                   saveImmediateCondition(cond, path = "/tmp/RtmpzxgiTZ/.future/immediateConditions")
[17:46:36.607]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.607]                   {
[17:46:36.607]                     inherits <- base::inherits
[17:46:36.607]                     invokeRestart <- base::invokeRestart
[17:46:36.607]                     is.null <- base::is.null
[17:46:36.607]                     muffled <- FALSE
[17:46:36.607]                     if (inherits(cond, "message")) {
[17:46:36.607]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:36.607]                       if (muffled) 
[17:46:36.607]                         invokeRestart("muffleMessage")
[17:46:36.607]                     }
[17:46:36.607]                     else if (inherits(cond, "warning")) {
[17:46:36.607]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:36.607]                       if (muffled) 
[17:46:36.607]                         invokeRestart("muffleWarning")
[17:46:36.607]                     }
[17:46:36.607]                     else if (inherits(cond, "condition")) {
[17:46:36.607]                       if (!is.null(pattern)) {
[17:46:36.607]                         computeRestarts <- base::computeRestarts
[17:46:36.607]                         grepl <- base::grepl
[17:46:36.607]                         restarts <- computeRestarts(cond)
[17:46:36.607]                         for (restart in restarts) {
[17:46:36.607]                           name <- restart$name
[17:46:36.607]                           if (is.null(name)) 
[17:46:36.607]                             next
[17:46:36.607]                           if (!grepl(pattern, name)) 
[17:46:36.607]                             next
[17:46:36.607]                           invokeRestart(restart)
[17:46:36.607]                           muffled <- TRUE
[17:46:36.607]                           break
[17:46:36.607]                         }
[17:46:36.607]                       }
[17:46:36.607]                     }
[17:46:36.607]                     invisible(muffled)
[17:46:36.607]                   }
[17:46:36.607]                   muffleCondition(cond)
[17:46:36.607]                 })
[17:46:36.607]             }))
[17:46:36.607]             future::FutureResult(value = ...future.value$value, 
[17:46:36.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.607]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.607]                     ...future.globalenv.names))
[17:46:36.607]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.607]         }, condition = base::local({
[17:46:36.607]             c <- base::c
[17:46:36.607]             inherits <- base::inherits
[17:46:36.607]             invokeRestart <- base::invokeRestart
[17:46:36.607]             length <- base::length
[17:46:36.607]             list <- base::list
[17:46:36.607]             seq.int <- base::seq.int
[17:46:36.607]             signalCondition <- base::signalCondition
[17:46:36.607]             sys.calls <- base::sys.calls
[17:46:36.607]             `[[` <- base::`[[`
[17:46:36.607]             `+` <- base::`+`
[17:46:36.607]             `<<-` <- base::`<<-`
[17:46:36.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.607]                   3L)]
[17:46:36.607]             }
[17:46:36.607]             function(cond) {
[17:46:36.607]                 is_error <- inherits(cond, "error")
[17:46:36.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.607]                   NULL)
[17:46:36.607]                 if (is_error) {
[17:46:36.607]                   sessionInformation <- function() {
[17:46:36.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.607]                       search = base::search(), system = base::Sys.info())
[17:46:36.607]                   }
[17:46:36.607]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.607]                     cond$call), session = sessionInformation(), 
[17:46:36.607]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.607]                   signalCondition(cond)
[17:46:36.607]                 }
[17:46:36.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.607]                 "immediateCondition"))) {
[17:46:36.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.607]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.607]                   if (TRUE && !signal) {
[17:46:36.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.607]                     {
[17:46:36.607]                       inherits <- base::inherits
[17:46:36.607]                       invokeRestart <- base::invokeRestart
[17:46:36.607]                       is.null <- base::is.null
[17:46:36.607]                       muffled <- FALSE
[17:46:36.607]                       if (inherits(cond, "message")) {
[17:46:36.607]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.607]                         if (muffled) 
[17:46:36.607]                           invokeRestart("muffleMessage")
[17:46:36.607]                       }
[17:46:36.607]                       else if (inherits(cond, "warning")) {
[17:46:36.607]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.607]                         if (muffled) 
[17:46:36.607]                           invokeRestart("muffleWarning")
[17:46:36.607]                       }
[17:46:36.607]                       else if (inherits(cond, "condition")) {
[17:46:36.607]                         if (!is.null(pattern)) {
[17:46:36.607]                           computeRestarts <- base::computeRestarts
[17:46:36.607]                           grepl <- base::grepl
[17:46:36.607]                           restarts <- computeRestarts(cond)
[17:46:36.607]                           for (restart in restarts) {
[17:46:36.607]                             name <- restart$name
[17:46:36.607]                             if (is.null(name)) 
[17:46:36.607]                               next
[17:46:36.607]                             if (!grepl(pattern, name)) 
[17:46:36.607]                               next
[17:46:36.607]                             invokeRestart(restart)
[17:46:36.607]                             muffled <- TRUE
[17:46:36.607]                             break
[17:46:36.607]                           }
[17:46:36.607]                         }
[17:46:36.607]                       }
[17:46:36.607]                       invisible(muffled)
[17:46:36.607]                     }
[17:46:36.607]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.607]                   }
[17:46:36.607]                 }
[17:46:36.607]                 else {
[17:46:36.607]                   if (TRUE) {
[17:46:36.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.607]                     {
[17:46:36.607]                       inherits <- base::inherits
[17:46:36.607]                       invokeRestart <- base::invokeRestart
[17:46:36.607]                       is.null <- base::is.null
[17:46:36.607]                       muffled <- FALSE
[17:46:36.607]                       if (inherits(cond, "message")) {
[17:46:36.607]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.607]                         if (muffled) 
[17:46:36.607]                           invokeRestart("muffleMessage")
[17:46:36.607]                       }
[17:46:36.607]                       else if (inherits(cond, "warning")) {
[17:46:36.607]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.607]                         if (muffled) 
[17:46:36.607]                           invokeRestart("muffleWarning")
[17:46:36.607]                       }
[17:46:36.607]                       else if (inherits(cond, "condition")) {
[17:46:36.607]                         if (!is.null(pattern)) {
[17:46:36.607]                           computeRestarts <- base::computeRestarts
[17:46:36.607]                           grepl <- base::grepl
[17:46:36.607]                           restarts <- computeRestarts(cond)
[17:46:36.607]                           for (restart in restarts) {
[17:46:36.607]                             name <- restart$name
[17:46:36.607]                             if (is.null(name)) 
[17:46:36.607]                               next
[17:46:36.607]                             if (!grepl(pattern, name)) 
[17:46:36.607]                               next
[17:46:36.607]                             invokeRestart(restart)
[17:46:36.607]                             muffled <- TRUE
[17:46:36.607]                             break
[17:46:36.607]                           }
[17:46:36.607]                         }
[17:46:36.607]                       }
[17:46:36.607]                       invisible(muffled)
[17:46:36.607]                     }
[17:46:36.607]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.607]                   }
[17:46:36.607]                 }
[17:46:36.607]             }
[17:46:36.607]         }))
[17:46:36.607]     }, error = function(ex) {
[17:46:36.607]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.607]                 ...future.rng), started = ...future.startTime, 
[17:46:36.607]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.607]             version = "1.8"), class = "FutureResult")
[17:46:36.607]     }, finally = {
[17:46:36.607]         if (!identical(...future.workdir, getwd())) 
[17:46:36.607]             setwd(...future.workdir)
[17:46:36.607]         {
[17:46:36.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.607]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.607]             }
[17:46:36.607]             base::options(...future.oldOptions)
[17:46:36.607]             if (.Platform$OS.type == "windows") {
[17:46:36.607]                 old_names <- names(...future.oldEnvVars)
[17:46:36.607]                 envs <- base::Sys.getenv()
[17:46:36.607]                 names <- names(envs)
[17:46:36.607]                 common <- intersect(names, old_names)
[17:46:36.607]                 added <- setdiff(names, old_names)
[17:46:36.607]                 removed <- setdiff(old_names, names)
[17:46:36.607]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.607]                   envs[common]]
[17:46:36.607]                 NAMES <- toupper(changed)
[17:46:36.607]                 args <- list()
[17:46:36.607]                 for (kk in seq_along(NAMES)) {
[17:46:36.607]                   name <- changed[[kk]]
[17:46:36.607]                   NAME <- NAMES[[kk]]
[17:46:36.607]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.607]                     next
[17:46:36.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.607]                 }
[17:46:36.607]                 NAMES <- toupper(added)
[17:46:36.607]                 for (kk in seq_along(NAMES)) {
[17:46:36.607]                   name <- added[[kk]]
[17:46:36.607]                   NAME <- NAMES[[kk]]
[17:46:36.607]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.607]                     next
[17:46:36.607]                   args[[name]] <- ""
[17:46:36.607]                 }
[17:46:36.607]                 NAMES <- toupper(removed)
[17:46:36.607]                 for (kk in seq_along(NAMES)) {
[17:46:36.607]                   name <- removed[[kk]]
[17:46:36.607]                   NAME <- NAMES[[kk]]
[17:46:36.607]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.607]                     next
[17:46:36.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.607]                 }
[17:46:36.607]                 if (length(args) > 0) 
[17:46:36.607]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.607]             }
[17:46:36.607]             else {
[17:46:36.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.607]             }
[17:46:36.607]             {
[17:46:36.607]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.607]                   0L) {
[17:46:36.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.607]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.607]                   base::options(opts)
[17:46:36.607]                 }
[17:46:36.607]                 {
[17:46:36.607]                   {
[17:46:36.607]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:36.607]                     NULL
[17:46:36.607]                   }
[17:46:36.607]                   options(future.plan = NULL)
[17:46:36.607]                   if (is.na(NA_character_)) 
[17:46:36.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.607]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.607]                     .init = FALSE)
[17:46:36.607]                 }
[17:46:36.607]             }
[17:46:36.607]         }
[17:46:36.607]     })
[17:46:36.607]     if (TRUE) {
[17:46:36.607]         base::sink(type = "output", split = FALSE)
[17:46:36.607]         if (TRUE) {
[17:46:36.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.607]         }
[17:46:36.607]         else {
[17:46:36.607]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.607]         }
[17:46:36.607]         base::close(...future.stdout)
[17:46:36.607]         ...future.stdout <- NULL
[17:46:36.607]     }
[17:46:36.607]     ...future.result$conditions <- ...future.conditions
[17:46:36.607]     ...future.result$finished <- base::Sys.time()
[17:46:36.607]     ...future.result
[17:46:36.607] }
[17:46:36.609] requestCore(): workers = 2
[17:46:36.612] MulticoreFuture started
[17:46:36.613] - Launch lazy future ... done
[17:46:36.613] plan(): Setting new future strategy stack:
[17:46:36.613] run() for ‘MulticoreFuture’ ... done
[17:46:36.613] List of future strategies:
[17:46:36.613] 1. sequential:
[17:46:36.613]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.613]    - tweaked: FALSE
[17:46:36.613]    - call: NULL
[17:46:36.614] plan(): nbrOfWorkers() = 1
[17:46:36.614] result() for MulticoreFuture ...
[17:46:36.616] plan(): Setting new future strategy stack:
[17:46:36.616] List of future strategies:
[17:46:36.616] 1. multicore:
[17:46:36.616]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:36.616]    - tweaked: FALSE
[17:46:36.616]    - call: plan(strategy)
[17:46:36.621] plan(): nbrOfWorkers() = 2
[17:46:36.625] result() for MulticoreFuture ...
[17:46:36.626] result() for MulticoreFuture ... done
[17:46:36.626] result() for MulticoreFuture ... done
[17:46:36.626] result() for MulticoreFuture ...
[17:46:36.626] result() for MulticoreFuture ... done
** Future evaluation with globals
[17:46:36.626] getGlobalsAndPackages() ...
[17:46:36.626] Searching for globals...
[17:46:36.628] - globals found: [3] ‘{’, ‘<-’, ‘a’
[17:46:36.628] Searching for globals ... DONE
[17:46:36.628] Resolving globals: FALSE
[17:46:36.629] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:36.629] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:46:36.629] - globals: [1] ‘a’
[17:46:36.629] 
[17:46:36.629] getGlobalsAndPackages() ... DONE
[17:46:36.630] run() for ‘Future’ ...
[17:46:36.630] - state: ‘created’
[17:46:36.630] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:36.636] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:36.637] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:36.637]   - Field: ‘label’
[17:46:36.637]   - Field: ‘local’
[17:46:36.637]   - Field: ‘owner’
[17:46:36.637]   - Field: ‘envir’
[17:46:36.637]   - Field: ‘workers’
[17:46:36.637]   - Field: ‘packages’
[17:46:36.638]   - Field: ‘gc’
[17:46:36.638]   - Field: ‘job’
[17:46:36.638]   - Field: ‘conditions’
[17:46:36.638]   - Field: ‘expr’
[17:46:36.638]   - Field: ‘uuid’
[17:46:36.638]   - Field: ‘seed’
[17:46:36.638]   - Field: ‘version’
[17:46:36.638]   - Field: ‘result’
[17:46:36.639]   - Field: ‘asynchronous’
[17:46:36.639]   - Field: ‘calls’
[17:46:36.639]   - Field: ‘globals’
[17:46:36.639]   - Field: ‘stdout’
[17:46:36.639]   - Field: ‘earlySignal’
[17:46:36.639]   - Field: ‘lazy’
[17:46:36.639]   - Field: ‘state’
[17:46:36.639] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:36.640] - Launch lazy future ...
[17:46:36.640] Packages needed by the future expression (n = 0): <none>
[17:46:36.640] Packages needed by future strategies (n = 0): <none>
[17:46:36.641] {
[17:46:36.641]     {
[17:46:36.641]         {
[17:46:36.641]             ...future.startTime <- base::Sys.time()
[17:46:36.641]             {
[17:46:36.641]                 {
[17:46:36.641]                   {
[17:46:36.641]                     {
[17:46:36.641]                       base::local({
[17:46:36.641]                         has_future <- base::requireNamespace("future", 
[17:46:36.641]                           quietly = TRUE)
[17:46:36.641]                         if (has_future) {
[17:46:36.641]                           ns <- base::getNamespace("future")
[17:46:36.641]                           version <- ns[[".package"]][["version"]]
[17:46:36.641]                           if (is.null(version)) 
[17:46:36.641]                             version <- utils::packageVersion("future")
[17:46:36.641]                         }
[17:46:36.641]                         else {
[17:46:36.641]                           version <- NULL
[17:46:36.641]                         }
[17:46:36.641]                         if (!has_future || version < "1.8.0") {
[17:46:36.641]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.641]                             "", base::R.version$version.string), 
[17:46:36.641]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:36.641]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.641]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.641]                               "release", "version")], collapse = " "), 
[17:46:36.641]                             hostname = base::Sys.info()[["nodename"]])
[17:46:36.641]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.641]                             info)
[17:46:36.641]                           info <- base::paste(info, collapse = "; ")
[17:46:36.641]                           if (!has_future) {
[17:46:36.641]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.641]                               info)
[17:46:36.641]                           }
[17:46:36.641]                           else {
[17:46:36.641]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.641]                               info, version)
[17:46:36.641]                           }
[17:46:36.641]                           base::stop(msg)
[17:46:36.641]                         }
[17:46:36.641]                       })
[17:46:36.641]                     }
[17:46:36.641]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:36.641]                     base::options(mc.cores = 1L)
[17:46:36.641]                   }
[17:46:36.641]                   ...future.strategy.old <- future::plan("list")
[17:46:36.641]                   options(future.plan = NULL)
[17:46:36.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.641]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.641]                 }
[17:46:36.641]                 ...future.workdir <- getwd()
[17:46:36.641]             }
[17:46:36.641]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.641]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.641]         }
[17:46:36.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.641]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.641]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.641]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.641]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.641]             base::names(...future.oldOptions))
[17:46:36.641]     }
[17:46:36.641]     if (FALSE) {
[17:46:36.641]     }
[17:46:36.641]     else {
[17:46:36.641]         if (TRUE) {
[17:46:36.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.641]                 open = "w")
[17:46:36.641]         }
[17:46:36.641]         else {
[17:46:36.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.641]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.641]         }
[17:46:36.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.641]             base::sink(type = "output", split = FALSE)
[17:46:36.641]             base::close(...future.stdout)
[17:46:36.641]         }, add = TRUE)
[17:46:36.641]     }
[17:46:36.641]     ...future.frame <- base::sys.nframe()
[17:46:36.641]     ...future.conditions <- base::list()
[17:46:36.641]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.641]     if (FALSE) {
[17:46:36.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.641]     }
[17:46:36.641]     ...future.result <- base::tryCatch({
[17:46:36.641]         base::withCallingHandlers({
[17:46:36.641]             ...future.value <- base::withVisible(base::local({
[17:46:36.641]                 withCallingHandlers({
[17:46:36.641]                   {
[17:46:36.641]                     x <- a
[17:46:36.641]                   }
[17:46:36.641]                 }, immediateCondition = function(cond) {
[17:46:36.641]                   save_rds <- function (object, pathname, ...) 
[17:46:36.641]                   {
[17:46:36.641]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:36.641]                     if (file_test("-f", pathname_tmp)) {
[17:46:36.641]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.641]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:36.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.641]                         fi_tmp[["mtime"]])
[17:46:36.641]                     }
[17:46:36.641]                     tryCatch({
[17:46:36.641]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:36.641]                     }, error = function(ex) {
[17:46:36.641]                       msg <- conditionMessage(ex)
[17:46:36.641]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.641]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:36.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.641]                         fi_tmp[["mtime"]], msg)
[17:46:36.641]                       ex$message <- msg
[17:46:36.641]                       stop(ex)
[17:46:36.641]                     })
[17:46:36.641]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:36.641]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:36.641]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:36.641]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.641]                       fi <- file.info(pathname)
[17:46:36.641]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:36.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.641]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:36.641]                         fi[["size"]], fi[["mtime"]])
[17:46:36.641]                       stop(msg)
[17:46:36.641]                     }
[17:46:36.641]                     invisible(pathname)
[17:46:36.641]                   }
[17:46:36.641]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:36.641]                     rootPath = tempdir()) 
[17:46:36.641]                   {
[17:46:36.641]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:36.641]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:36.641]                       tmpdir = path, fileext = ".rds")
[17:46:36.641]                     save_rds(obj, file)
[17:46:36.641]                   }
[17:46:36.641]                   saveImmediateCondition(cond, path = "/tmp/RtmpzxgiTZ/.future/immediateConditions")
[17:46:36.641]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.641]                   {
[17:46:36.641]                     inherits <- base::inherits
[17:46:36.641]                     invokeRestart <- base::invokeRestart
[17:46:36.641]                     is.null <- base::is.null
[17:46:36.641]                     muffled <- FALSE
[17:46:36.641]                     if (inherits(cond, "message")) {
[17:46:36.641]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:36.641]                       if (muffled) 
[17:46:36.641]                         invokeRestart("muffleMessage")
[17:46:36.641]                     }
[17:46:36.641]                     else if (inherits(cond, "warning")) {
[17:46:36.641]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:36.641]                       if (muffled) 
[17:46:36.641]                         invokeRestart("muffleWarning")
[17:46:36.641]                     }
[17:46:36.641]                     else if (inherits(cond, "condition")) {
[17:46:36.641]                       if (!is.null(pattern)) {
[17:46:36.641]                         computeRestarts <- base::computeRestarts
[17:46:36.641]                         grepl <- base::grepl
[17:46:36.641]                         restarts <- computeRestarts(cond)
[17:46:36.641]                         for (restart in restarts) {
[17:46:36.641]                           name <- restart$name
[17:46:36.641]                           if (is.null(name)) 
[17:46:36.641]                             next
[17:46:36.641]                           if (!grepl(pattern, name)) 
[17:46:36.641]                             next
[17:46:36.641]                           invokeRestart(restart)
[17:46:36.641]                           muffled <- TRUE
[17:46:36.641]                           break
[17:46:36.641]                         }
[17:46:36.641]                       }
[17:46:36.641]                     }
[17:46:36.641]                     invisible(muffled)
[17:46:36.641]                   }
[17:46:36.641]                   muffleCondition(cond)
[17:46:36.641]                 })
[17:46:36.641]             }))
[17:46:36.641]             future::FutureResult(value = ...future.value$value, 
[17:46:36.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.641]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.641]                     ...future.globalenv.names))
[17:46:36.641]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.641]         }, condition = base::local({
[17:46:36.641]             c <- base::c
[17:46:36.641]             inherits <- base::inherits
[17:46:36.641]             invokeRestart <- base::invokeRestart
[17:46:36.641]             length <- base::length
[17:46:36.641]             list <- base::list
[17:46:36.641]             seq.int <- base::seq.int
[17:46:36.641]             signalCondition <- base::signalCondition
[17:46:36.641]             sys.calls <- base::sys.calls
[17:46:36.641]             `[[` <- base::`[[`
[17:46:36.641]             `+` <- base::`+`
[17:46:36.641]             `<<-` <- base::`<<-`
[17:46:36.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.641]                   3L)]
[17:46:36.641]             }
[17:46:36.641]             function(cond) {
[17:46:36.641]                 is_error <- inherits(cond, "error")
[17:46:36.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.641]                   NULL)
[17:46:36.641]                 if (is_error) {
[17:46:36.641]                   sessionInformation <- function() {
[17:46:36.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.641]                       search = base::search(), system = base::Sys.info())
[17:46:36.641]                   }
[17:46:36.641]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.641]                     cond$call), session = sessionInformation(), 
[17:46:36.641]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.641]                   signalCondition(cond)
[17:46:36.641]                 }
[17:46:36.641]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.641]                 "immediateCondition"))) {
[17:46:36.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.641]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.641]                   if (TRUE && !signal) {
[17:46:36.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.641]                     {
[17:46:36.641]                       inherits <- base::inherits
[17:46:36.641]                       invokeRestart <- base::invokeRestart
[17:46:36.641]                       is.null <- base::is.null
[17:46:36.641]                       muffled <- FALSE
[17:46:36.641]                       if (inherits(cond, "message")) {
[17:46:36.641]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.641]                         if (muffled) 
[17:46:36.641]                           invokeRestart("muffleMessage")
[17:46:36.641]                       }
[17:46:36.641]                       else if (inherits(cond, "warning")) {
[17:46:36.641]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.641]                         if (muffled) 
[17:46:36.641]                           invokeRestart("muffleWarning")
[17:46:36.641]                       }
[17:46:36.641]                       else if (inherits(cond, "condition")) {
[17:46:36.641]                         if (!is.null(pattern)) {
[17:46:36.641]                           computeRestarts <- base::computeRestarts
[17:46:36.641]                           grepl <- base::grepl
[17:46:36.641]                           restarts <- computeRestarts(cond)
[17:46:36.641]                           for (restart in restarts) {
[17:46:36.641]                             name <- restart$name
[17:46:36.641]                             if (is.null(name)) 
[17:46:36.641]                               next
[17:46:36.641]                             if (!grepl(pattern, name)) 
[17:46:36.641]                               next
[17:46:36.641]                             invokeRestart(restart)
[17:46:36.641]                             muffled <- TRUE
[17:46:36.641]                             break
[17:46:36.641]                           }
[17:46:36.641]                         }
[17:46:36.641]                       }
[17:46:36.641]                       invisible(muffled)
[17:46:36.641]                     }
[17:46:36.641]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.641]                   }
[17:46:36.641]                 }
[17:46:36.641]                 else {
[17:46:36.641]                   if (TRUE) {
[17:46:36.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.641]                     {
[17:46:36.641]                       inherits <- base::inherits
[17:46:36.641]                       invokeRestart <- base::invokeRestart
[17:46:36.641]                       is.null <- base::is.null
[17:46:36.641]                       muffled <- FALSE
[17:46:36.641]                       if (inherits(cond, "message")) {
[17:46:36.641]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.641]                         if (muffled) 
[17:46:36.641]                           invokeRestart("muffleMessage")
[17:46:36.641]                       }
[17:46:36.641]                       else if (inherits(cond, "warning")) {
[17:46:36.641]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.641]                         if (muffled) 
[17:46:36.641]                           invokeRestart("muffleWarning")
[17:46:36.641]                       }
[17:46:36.641]                       else if (inherits(cond, "condition")) {
[17:46:36.641]                         if (!is.null(pattern)) {
[17:46:36.641]                           computeRestarts <- base::computeRestarts
[17:46:36.641]                           grepl <- base::grepl
[17:46:36.641]                           restarts <- computeRestarts(cond)
[17:46:36.641]                           for (restart in restarts) {
[17:46:36.641]                             name <- restart$name
[17:46:36.641]                             if (is.null(name)) 
[17:46:36.641]                               next
[17:46:36.641]                             if (!grepl(pattern, name)) 
[17:46:36.641]                               next
[17:46:36.641]                             invokeRestart(restart)
[17:46:36.641]                             muffled <- TRUE
[17:46:36.641]                             break
[17:46:36.641]                           }
[17:46:36.641]                         }
[17:46:36.641]                       }
[17:46:36.641]                       invisible(muffled)
[17:46:36.641]                     }
[17:46:36.641]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.641]                   }
[17:46:36.641]                 }
[17:46:36.641]             }
[17:46:36.641]         }))
[17:46:36.641]     }, error = function(ex) {
[17:46:36.641]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.641]                 ...future.rng), started = ...future.startTime, 
[17:46:36.641]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.641]             version = "1.8"), class = "FutureResult")
[17:46:36.641]     }, finally = {
[17:46:36.641]         if (!identical(...future.workdir, getwd())) 
[17:46:36.641]             setwd(...future.workdir)
[17:46:36.641]         {
[17:46:36.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.641]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.641]             }
[17:46:36.641]             base::options(...future.oldOptions)
[17:46:36.641]             if (.Platform$OS.type == "windows") {
[17:46:36.641]                 old_names <- names(...future.oldEnvVars)
[17:46:36.641]                 envs <- base::Sys.getenv()
[17:46:36.641]                 names <- names(envs)
[17:46:36.641]                 common <- intersect(names, old_names)
[17:46:36.641]                 added <- setdiff(names, old_names)
[17:46:36.641]                 removed <- setdiff(old_names, names)
[17:46:36.641]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.641]                   envs[common]]
[17:46:36.641]                 NAMES <- toupper(changed)
[17:46:36.641]                 args <- list()
[17:46:36.641]                 for (kk in seq_along(NAMES)) {
[17:46:36.641]                   name <- changed[[kk]]
[17:46:36.641]                   NAME <- NAMES[[kk]]
[17:46:36.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.641]                     next
[17:46:36.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.641]                 }
[17:46:36.641]                 NAMES <- toupper(added)
[17:46:36.641]                 for (kk in seq_along(NAMES)) {
[17:46:36.641]                   name <- added[[kk]]
[17:46:36.641]                   NAME <- NAMES[[kk]]
[17:46:36.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.641]                     next
[17:46:36.641]                   args[[name]] <- ""
[17:46:36.641]                 }
[17:46:36.641]                 NAMES <- toupper(removed)
[17:46:36.641]                 for (kk in seq_along(NAMES)) {
[17:46:36.641]                   name <- removed[[kk]]
[17:46:36.641]                   NAME <- NAMES[[kk]]
[17:46:36.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.641]                     next
[17:46:36.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.641]                 }
[17:46:36.641]                 if (length(args) > 0) 
[17:46:36.641]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.641]             }
[17:46:36.641]             else {
[17:46:36.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.641]             }
[17:46:36.641]             {
[17:46:36.641]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.641]                   0L) {
[17:46:36.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.641]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.641]                   base::options(opts)
[17:46:36.641]                 }
[17:46:36.641]                 {
[17:46:36.641]                   {
[17:46:36.641]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:36.641]                     NULL
[17:46:36.641]                   }
[17:46:36.641]                   options(future.plan = NULL)
[17:46:36.641]                   if (is.na(NA_character_)) 
[17:46:36.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.641]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.641]                     .init = FALSE)
[17:46:36.641]                 }
[17:46:36.641]             }
[17:46:36.641]         }
[17:46:36.641]     })
[17:46:36.641]     if (TRUE) {
[17:46:36.641]         base::sink(type = "output", split = FALSE)
[17:46:36.641]         if (TRUE) {
[17:46:36.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.641]         }
[17:46:36.641]         else {
[17:46:36.641]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.641]         }
[17:46:36.641]         base::close(...future.stdout)
[17:46:36.641]         ...future.stdout <- NULL
[17:46:36.641]     }
[17:46:36.641]     ...future.result$conditions <- ...future.conditions
[17:46:36.641]     ...future.result$finished <- base::Sys.time()
[17:46:36.641]     ...future.result
[17:46:36.641] }
[17:46:36.643] assign_globals() ...
[17:46:36.643] List of 1
[17:46:36.643]  $ a: num 2
[17:46:36.643]  - attr(*, "where")=List of 1
[17:46:36.643]   ..$ a:<environment: R_EmptyEnv> 
[17:46:36.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:36.643]  - attr(*, "resolved")= logi FALSE
[17:46:36.643]  - attr(*, "total_size")= num 56
[17:46:36.643]  - attr(*, "already-done")= logi TRUE
[17:46:36.646] - copied ‘a’ to environment
[17:46:36.646] assign_globals() ... done
[17:46:36.646] requestCore(): workers = 2
[17:46:36.648] MulticoreFuture started
[17:46:36.648] - Launch lazy future ... done
[17:46:36.649] run() for ‘MulticoreFuture’ ... done
[17:46:36.649] result() for MulticoreFuture ...
[17:46:36.649] plan(): Setting new future strategy stack:
[17:46:36.649] List of future strategies:
[17:46:36.649] 1. sequential:
[17:46:36.649]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.649]    - tweaked: FALSE
[17:46:36.649]    - call: NULL
[17:46:36.650] plan(): nbrOfWorkers() = 1
[17:46:36.652] plan(): Setting new future strategy stack:
[17:46:36.652] List of future strategies:
[17:46:36.652] 1. multicore:
[17:46:36.652]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:36.652]    - tweaked: FALSE
[17:46:36.652]    - call: plan(strategy)
[17:46:36.657] plan(): nbrOfWorkers() = 2
[17:46:36.658] result() for MulticoreFuture ...
[17:46:36.658] result() for MulticoreFuture ... done
[17:46:36.658] result() for MulticoreFuture ... done
[17:46:36.658] result() for MulticoreFuture ...
[17:46:36.659] result() for MulticoreFuture ... done
** Future evaluation with errors
[17:46:36.659] getGlobalsAndPackages() ...
[17:46:36.659] Searching for globals...
[17:46:36.661] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[17:46:36.662] Searching for globals ... DONE
[17:46:36.662] Resolving globals: FALSE
[17:46:36.662] 
[17:46:36.662] 
[17:46:36.662] getGlobalsAndPackages() ... DONE
[17:46:36.663] run() for ‘Future’ ...
[17:46:36.663] - state: ‘created’
[17:46:36.663] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:36.667] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:36.667] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:36.667]   - Field: ‘label’
[17:46:36.667]   - Field: ‘local’
[17:46:36.667]   - Field: ‘owner’
[17:46:36.667]   - Field: ‘envir’
[17:46:36.668]   - Field: ‘workers’
[17:46:36.668]   - Field: ‘packages’
[17:46:36.668]   - Field: ‘gc’
[17:46:36.668]   - Field: ‘job’
[17:46:36.668]   - Field: ‘conditions’
[17:46:36.668]   - Field: ‘expr’
[17:46:36.668]   - Field: ‘uuid’
[17:46:36.668]   - Field: ‘seed’
[17:46:36.668]   - Field: ‘version’
[17:46:36.669]   - Field: ‘result’
[17:46:36.669]   - Field: ‘asynchronous’
[17:46:36.669]   - Field: ‘calls’
[17:46:36.669]   - Field: ‘globals’
[17:46:36.669]   - Field: ‘stdout’
[17:46:36.669]   - Field: ‘earlySignal’
[17:46:36.669]   - Field: ‘lazy’
[17:46:36.669]   - Field: ‘state’
[17:46:36.669] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:36.670] - Launch lazy future ...
[17:46:36.670] Packages needed by the future expression (n = 0): <none>
[17:46:36.670] Packages needed by future strategies (n = 0): <none>
[17:46:36.671] {
[17:46:36.671]     {
[17:46:36.671]         {
[17:46:36.671]             ...future.startTime <- base::Sys.time()
[17:46:36.671]             {
[17:46:36.671]                 {
[17:46:36.671]                   {
[17:46:36.671]                     {
[17:46:36.671]                       base::local({
[17:46:36.671]                         has_future <- base::requireNamespace("future", 
[17:46:36.671]                           quietly = TRUE)
[17:46:36.671]                         if (has_future) {
[17:46:36.671]                           ns <- base::getNamespace("future")
[17:46:36.671]                           version <- ns[[".package"]][["version"]]
[17:46:36.671]                           if (is.null(version)) 
[17:46:36.671]                             version <- utils::packageVersion("future")
[17:46:36.671]                         }
[17:46:36.671]                         else {
[17:46:36.671]                           version <- NULL
[17:46:36.671]                         }
[17:46:36.671]                         if (!has_future || version < "1.8.0") {
[17:46:36.671]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.671]                             "", base::R.version$version.string), 
[17:46:36.671]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:36.671]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.671]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.671]                               "release", "version")], collapse = " "), 
[17:46:36.671]                             hostname = base::Sys.info()[["nodename"]])
[17:46:36.671]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.671]                             info)
[17:46:36.671]                           info <- base::paste(info, collapse = "; ")
[17:46:36.671]                           if (!has_future) {
[17:46:36.671]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.671]                               info)
[17:46:36.671]                           }
[17:46:36.671]                           else {
[17:46:36.671]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.671]                               info, version)
[17:46:36.671]                           }
[17:46:36.671]                           base::stop(msg)
[17:46:36.671]                         }
[17:46:36.671]                       })
[17:46:36.671]                     }
[17:46:36.671]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:36.671]                     base::options(mc.cores = 1L)
[17:46:36.671]                   }
[17:46:36.671]                   ...future.strategy.old <- future::plan("list")
[17:46:36.671]                   options(future.plan = NULL)
[17:46:36.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.671]                 }
[17:46:36.671]                 ...future.workdir <- getwd()
[17:46:36.671]             }
[17:46:36.671]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.671]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.671]         }
[17:46:36.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.671]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.671]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.671]             base::names(...future.oldOptions))
[17:46:36.671]     }
[17:46:36.671]     if (FALSE) {
[17:46:36.671]     }
[17:46:36.671]     else {
[17:46:36.671]         if (TRUE) {
[17:46:36.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.671]                 open = "w")
[17:46:36.671]         }
[17:46:36.671]         else {
[17:46:36.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.671]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.671]         }
[17:46:36.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.671]             base::sink(type = "output", split = FALSE)
[17:46:36.671]             base::close(...future.stdout)
[17:46:36.671]         }, add = TRUE)
[17:46:36.671]     }
[17:46:36.671]     ...future.frame <- base::sys.nframe()
[17:46:36.671]     ...future.conditions <- base::list()
[17:46:36.671]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.671]     if (FALSE) {
[17:46:36.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.671]     }
[17:46:36.671]     ...future.result <- base::tryCatch({
[17:46:36.671]         base::withCallingHandlers({
[17:46:36.671]             ...future.value <- base::withVisible(base::local({
[17:46:36.671]                 withCallingHandlers({
[17:46:36.671]                   {
[17:46:36.671]                     x <- 3
[17:46:36.671]                     stop("Woops!")
[17:46:36.671]                     x
[17:46:36.671]                   }
[17:46:36.671]                 }, immediateCondition = function(cond) {
[17:46:36.671]                   save_rds <- function (object, pathname, ...) 
[17:46:36.671]                   {
[17:46:36.671]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:36.671]                     if (file_test("-f", pathname_tmp)) {
[17:46:36.671]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.671]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:36.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.671]                         fi_tmp[["mtime"]])
[17:46:36.671]                     }
[17:46:36.671]                     tryCatch({
[17:46:36.671]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:36.671]                     }, error = function(ex) {
[17:46:36.671]                       msg <- conditionMessage(ex)
[17:46:36.671]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.671]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:36.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.671]                         fi_tmp[["mtime"]], msg)
[17:46:36.671]                       ex$message <- msg
[17:46:36.671]                       stop(ex)
[17:46:36.671]                     })
[17:46:36.671]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:36.671]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:36.671]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:36.671]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.671]                       fi <- file.info(pathname)
[17:46:36.671]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:36.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.671]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:36.671]                         fi[["size"]], fi[["mtime"]])
[17:46:36.671]                       stop(msg)
[17:46:36.671]                     }
[17:46:36.671]                     invisible(pathname)
[17:46:36.671]                   }
[17:46:36.671]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:36.671]                     rootPath = tempdir()) 
[17:46:36.671]                   {
[17:46:36.671]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:36.671]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:36.671]                       tmpdir = path, fileext = ".rds")
[17:46:36.671]                     save_rds(obj, file)
[17:46:36.671]                   }
[17:46:36.671]                   saveImmediateCondition(cond, path = "/tmp/RtmpzxgiTZ/.future/immediateConditions")
[17:46:36.671]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.671]                   {
[17:46:36.671]                     inherits <- base::inherits
[17:46:36.671]                     invokeRestart <- base::invokeRestart
[17:46:36.671]                     is.null <- base::is.null
[17:46:36.671]                     muffled <- FALSE
[17:46:36.671]                     if (inherits(cond, "message")) {
[17:46:36.671]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:36.671]                       if (muffled) 
[17:46:36.671]                         invokeRestart("muffleMessage")
[17:46:36.671]                     }
[17:46:36.671]                     else if (inherits(cond, "warning")) {
[17:46:36.671]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:36.671]                       if (muffled) 
[17:46:36.671]                         invokeRestart("muffleWarning")
[17:46:36.671]                     }
[17:46:36.671]                     else if (inherits(cond, "condition")) {
[17:46:36.671]                       if (!is.null(pattern)) {
[17:46:36.671]                         computeRestarts <- base::computeRestarts
[17:46:36.671]                         grepl <- base::grepl
[17:46:36.671]                         restarts <- computeRestarts(cond)
[17:46:36.671]                         for (restart in restarts) {
[17:46:36.671]                           name <- restart$name
[17:46:36.671]                           if (is.null(name)) 
[17:46:36.671]                             next
[17:46:36.671]                           if (!grepl(pattern, name)) 
[17:46:36.671]                             next
[17:46:36.671]                           invokeRestart(restart)
[17:46:36.671]                           muffled <- TRUE
[17:46:36.671]                           break
[17:46:36.671]                         }
[17:46:36.671]                       }
[17:46:36.671]                     }
[17:46:36.671]                     invisible(muffled)
[17:46:36.671]                   }
[17:46:36.671]                   muffleCondition(cond)
[17:46:36.671]                 })
[17:46:36.671]             }))
[17:46:36.671]             future::FutureResult(value = ...future.value$value, 
[17:46:36.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.671]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.671]                     ...future.globalenv.names))
[17:46:36.671]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.671]         }, condition = base::local({
[17:46:36.671]             c <- base::c
[17:46:36.671]             inherits <- base::inherits
[17:46:36.671]             invokeRestart <- base::invokeRestart
[17:46:36.671]             length <- base::length
[17:46:36.671]             list <- base::list
[17:46:36.671]             seq.int <- base::seq.int
[17:46:36.671]             signalCondition <- base::signalCondition
[17:46:36.671]             sys.calls <- base::sys.calls
[17:46:36.671]             `[[` <- base::`[[`
[17:46:36.671]             `+` <- base::`+`
[17:46:36.671]             `<<-` <- base::`<<-`
[17:46:36.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.671]                   3L)]
[17:46:36.671]             }
[17:46:36.671]             function(cond) {
[17:46:36.671]                 is_error <- inherits(cond, "error")
[17:46:36.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.671]                   NULL)
[17:46:36.671]                 if (is_error) {
[17:46:36.671]                   sessionInformation <- function() {
[17:46:36.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.671]                       search = base::search(), system = base::Sys.info())
[17:46:36.671]                   }
[17:46:36.671]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.671]                     cond$call), session = sessionInformation(), 
[17:46:36.671]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.671]                   signalCondition(cond)
[17:46:36.671]                 }
[17:46:36.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.671]                 "immediateCondition"))) {
[17:46:36.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.671]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.671]                   if (TRUE && !signal) {
[17:46:36.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.671]                     {
[17:46:36.671]                       inherits <- base::inherits
[17:46:36.671]                       invokeRestart <- base::invokeRestart
[17:46:36.671]                       is.null <- base::is.null
[17:46:36.671]                       muffled <- FALSE
[17:46:36.671]                       if (inherits(cond, "message")) {
[17:46:36.671]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.671]                         if (muffled) 
[17:46:36.671]                           invokeRestart("muffleMessage")
[17:46:36.671]                       }
[17:46:36.671]                       else if (inherits(cond, "warning")) {
[17:46:36.671]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.671]                         if (muffled) 
[17:46:36.671]                           invokeRestart("muffleWarning")
[17:46:36.671]                       }
[17:46:36.671]                       else if (inherits(cond, "condition")) {
[17:46:36.671]                         if (!is.null(pattern)) {
[17:46:36.671]                           computeRestarts <- base::computeRestarts
[17:46:36.671]                           grepl <- base::grepl
[17:46:36.671]                           restarts <- computeRestarts(cond)
[17:46:36.671]                           for (restart in restarts) {
[17:46:36.671]                             name <- restart$name
[17:46:36.671]                             if (is.null(name)) 
[17:46:36.671]                               next
[17:46:36.671]                             if (!grepl(pattern, name)) 
[17:46:36.671]                               next
[17:46:36.671]                             invokeRestart(restart)
[17:46:36.671]                             muffled <- TRUE
[17:46:36.671]                             break
[17:46:36.671]                           }
[17:46:36.671]                         }
[17:46:36.671]                       }
[17:46:36.671]                       invisible(muffled)
[17:46:36.671]                     }
[17:46:36.671]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.671]                   }
[17:46:36.671]                 }
[17:46:36.671]                 else {
[17:46:36.671]                   if (TRUE) {
[17:46:36.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.671]                     {
[17:46:36.671]                       inherits <- base::inherits
[17:46:36.671]                       invokeRestart <- base::invokeRestart
[17:46:36.671]                       is.null <- base::is.null
[17:46:36.671]                       muffled <- FALSE
[17:46:36.671]                       if (inherits(cond, "message")) {
[17:46:36.671]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.671]                         if (muffled) 
[17:46:36.671]                           invokeRestart("muffleMessage")
[17:46:36.671]                       }
[17:46:36.671]                       else if (inherits(cond, "warning")) {
[17:46:36.671]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.671]                         if (muffled) 
[17:46:36.671]                           invokeRestart("muffleWarning")
[17:46:36.671]                       }
[17:46:36.671]                       else if (inherits(cond, "condition")) {
[17:46:36.671]                         if (!is.null(pattern)) {
[17:46:36.671]                           computeRestarts <- base::computeRestarts
[17:46:36.671]                           grepl <- base::grepl
[17:46:36.671]                           restarts <- computeRestarts(cond)
[17:46:36.671]                           for (restart in restarts) {
[17:46:36.671]                             name <- restart$name
[17:46:36.671]                             if (is.null(name)) 
[17:46:36.671]                               next
[17:46:36.671]                             if (!grepl(pattern, name)) 
[17:46:36.671]                               next
[17:46:36.671]                             invokeRestart(restart)
[17:46:36.671]                             muffled <- TRUE
[17:46:36.671]                             break
[17:46:36.671]                           }
[17:46:36.671]                         }
[17:46:36.671]                       }
[17:46:36.671]                       invisible(muffled)
[17:46:36.671]                     }
[17:46:36.671]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.671]                   }
[17:46:36.671]                 }
[17:46:36.671]             }
[17:46:36.671]         }))
[17:46:36.671]     }, error = function(ex) {
[17:46:36.671]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.671]                 ...future.rng), started = ...future.startTime, 
[17:46:36.671]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.671]             version = "1.8"), class = "FutureResult")
[17:46:36.671]     }, finally = {
[17:46:36.671]         if (!identical(...future.workdir, getwd())) 
[17:46:36.671]             setwd(...future.workdir)
[17:46:36.671]         {
[17:46:36.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.671]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.671]             }
[17:46:36.671]             base::options(...future.oldOptions)
[17:46:36.671]             if (.Platform$OS.type == "windows") {
[17:46:36.671]                 old_names <- names(...future.oldEnvVars)
[17:46:36.671]                 envs <- base::Sys.getenv()
[17:46:36.671]                 names <- names(envs)
[17:46:36.671]                 common <- intersect(names, old_names)
[17:46:36.671]                 added <- setdiff(names, old_names)
[17:46:36.671]                 removed <- setdiff(old_names, names)
[17:46:36.671]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.671]                   envs[common]]
[17:46:36.671]                 NAMES <- toupper(changed)
[17:46:36.671]                 args <- list()
[17:46:36.671]                 for (kk in seq_along(NAMES)) {
[17:46:36.671]                   name <- changed[[kk]]
[17:46:36.671]                   NAME <- NAMES[[kk]]
[17:46:36.671]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.671]                     next
[17:46:36.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.671]                 }
[17:46:36.671]                 NAMES <- toupper(added)
[17:46:36.671]                 for (kk in seq_along(NAMES)) {
[17:46:36.671]                   name <- added[[kk]]
[17:46:36.671]                   NAME <- NAMES[[kk]]
[17:46:36.671]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.671]                     next
[17:46:36.671]                   args[[name]] <- ""
[17:46:36.671]                 }
[17:46:36.671]                 NAMES <- toupper(removed)
[17:46:36.671]                 for (kk in seq_along(NAMES)) {
[17:46:36.671]                   name <- removed[[kk]]
[17:46:36.671]                   NAME <- NAMES[[kk]]
[17:46:36.671]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.671]                     next
[17:46:36.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.671]                 }
[17:46:36.671]                 if (length(args) > 0) 
[17:46:36.671]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.671]             }
[17:46:36.671]             else {
[17:46:36.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.671]             }
[17:46:36.671]             {
[17:46:36.671]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.671]                   0L) {
[17:46:36.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.671]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.671]                   base::options(opts)
[17:46:36.671]                 }
[17:46:36.671]                 {
[17:46:36.671]                   {
[17:46:36.671]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:36.671]                     NULL
[17:46:36.671]                   }
[17:46:36.671]                   options(future.plan = NULL)
[17:46:36.671]                   if (is.na(NA_character_)) 
[17:46:36.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.671]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.671]                     .init = FALSE)
[17:46:36.671]                 }
[17:46:36.671]             }
[17:46:36.671]         }
[17:46:36.671]     })
[17:46:36.671]     if (TRUE) {
[17:46:36.671]         base::sink(type = "output", split = FALSE)
[17:46:36.671]         if (TRUE) {
[17:46:36.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.671]         }
[17:46:36.671]         else {
[17:46:36.671]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.671]         }
[17:46:36.671]         base::close(...future.stdout)
[17:46:36.671]         ...future.stdout <- NULL
[17:46:36.671]     }
[17:46:36.671]     ...future.result$conditions <- ...future.conditions
[17:46:36.671]     ...future.result$finished <- base::Sys.time()
[17:46:36.671]     ...future.result
[17:46:36.671] }
[17:46:36.673] requestCore(): workers = 2
[17:46:36.675] MulticoreFuture started
[17:46:36.675] - Launch lazy future ... done
[17:46:36.675] run() for ‘MulticoreFuture’ ... done
[17:46:36.676] result() for MulticoreFuture ...
[17:46:36.676] plan(): Setting new future strategy stack:
[17:46:36.676] List of future strategies:
[17:46:36.676] 1. sequential:
[17:46:36.676]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.676]    - tweaked: FALSE
[17:46:36.676]    - call: NULL
[17:46:36.677] plan(): nbrOfWorkers() = 1
[17:46:36.679] plan(): Setting new future strategy stack:
[17:46:36.679] List of future strategies:
[17:46:36.679] 1. multicore:
[17:46:36.679]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:36.679]    - tweaked: FALSE
[17:46:36.679]    - call: plan(strategy)
[17:46:36.684] plan(): nbrOfWorkers() = 2
[17:46:36.689] result() for MulticoreFuture ...
[17:46:36.689] result() for MulticoreFuture ... done
[17:46:36.689] signalConditions() ...
[17:46:36.689]  - include = ‘immediateCondition’
[17:46:36.689]  - exclude = 
[17:46:36.689]  - resignal = FALSE
[17:46:36.689]  - Number of conditions: 1
[17:46:36.689] signalConditions() ... done
[17:46:36.689] result() for MulticoreFuture ... done
[17:46:36.690] result() for MulticoreFuture ...
[17:46:36.690] result() for MulticoreFuture ... done
[17:46:36.690] signalConditions() ...
[17:46:36.690]  - include = ‘immediateCondition’
[17:46:36.690]  - exclude = 
[17:46:36.690]  - resignal = FALSE
[17:46:36.690]  - Number of conditions: 1
[17:46:36.690] signalConditions() ... done
[17:46:36.690] Future state: ‘finished’
[17:46:36.691] result() for MulticoreFuture ...
[17:46:36.691] result() for MulticoreFuture ... done
[17:46:36.691] signalConditions() ...
[17:46:36.691]  - include = ‘condition’
[17:46:36.691]  - exclude = ‘immediateCondition’
[17:46:36.691]  - resignal = TRUE
[17:46:36.691]  - Number of conditions: 1
[17:46:36.691]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:36.692] signalConditions() ... done
[17:46:36.692] getGlobalsAndPackages() ...
[17:46:36.692] Searching for globals...
[17:46:36.694] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:46:36.697] Searching for globals ... DONE
[17:46:36.697] Resolving globals: FALSE
[17:46:36.698] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:36.698] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:46:36.698] - globals: [1] ‘ii’
[17:46:36.699] 
[17:46:36.699] getGlobalsAndPackages() ... DONE
[17:46:36.699] run() for ‘Future’ ...
[17:46:36.699] - state: ‘created’
[17:46:36.699] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:36.703] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:36.703] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:36.704]   - Field: ‘label’
[17:46:36.704]   - Field: ‘local’
[17:46:36.704]   - Field: ‘owner’
[17:46:36.704]   - Field: ‘envir’
[17:46:36.704]   - Field: ‘workers’
[17:46:36.704]   - Field: ‘packages’
[17:46:36.704]   - Field: ‘gc’
[17:46:36.704]   - Field: ‘job’
[17:46:36.705]   - Field: ‘conditions’
[17:46:36.705]   - Field: ‘expr’
[17:46:36.705]   - Field: ‘uuid’
[17:46:36.705]   - Field: ‘seed’
[17:46:36.705]   - Field: ‘version’
[17:46:36.705]   - Field: ‘result’
[17:46:36.705]   - Field: ‘asynchronous’
[17:46:36.705]   - Field: ‘calls’
[17:46:36.705]   - Field: ‘globals’
[17:46:36.706]   - Field: ‘stdout’
[17:46:36.706]   - Field: ‘earlySignal’
[17:46:36.706]   - Field: ‘lazy’
[17:46:36.706]   - Field: ‘state’
[17:46:36.706] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:36.706] - Launch lazy future ...
[17:46:36.706] Packages needed by the future expression (n = 0): <none>
[17:46:36.707] Packages needed by future strategies (n = 0): <none>
[17:46:36.707] {
[17:46:36.707]     {
[17:46:36.707]         {
[17:46:36.707]             ...future.startTime <- base::Sys.time()
[17:46:36.707]             {
[17:46:36.707]                 {
[17:46:36.707]                   {
[17:46:36.707]                     {
[17:46:36.707]                       base::local({
[17:46:36.707]                         has_future <- base::requireNamespace("future", 
[17:46:36.707]                           quietly = TRUE)
[17:46:36.707]                         if (has_future) {
[17:46:36.707]                           ns <- base::getNamespace("future")
[17:46:36.707]                           version <- ns[[".package"]][["version"]]
[17:46:36.707]                           if (is.null(version)) 
[17:46:36.707]                             version <- utils::packageVersion("future")
[17:46:36.707]                         }
[17:46:36.707]                         else {
[17:46:36.707]                           version <- NULL
[17:46:36.707]                         }
[17:46:36.707]                         if (!has_future || version < "1.8.0") {
[17:46:36.707]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.707]                             "", base::R.version$version.string), 
[17:46:36.707]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:36.707]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.707]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.707]                               "release", "version")], collapse = " "), 
[17:46:36.707]                             hostname = base::Sys.info()[["nodename"]])
[17:46:36.707]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.707]                             info)
[17:46:36.707]                           info <- base::paste(info, collapse = "; ")
[17:46:36.707]                           if (!has_future) {
[17:46:36.707]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.707]                               info)
[17:46:36.707]                           }
[17:46:36.707]                           else {
[17:46:36.707]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.707]                               info, version)
[17:46:36.707]                           }
[17:46:36.707]                           base::stop(msg)
[17:46:36.707]                         }
[17:46:36.707]                       })
[17:46:36.707]                     }
[17:46:36.707]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:36.707]                     base::options(mc.cores = 1L)
[17:46:36.707]                   }
[17:46:36.707]                   ...future.strategy.old <- future::plan("list")
[17:46:36.707]                   options(future.plan = NULL)
[17:46:36.707]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.707]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.707]                 }
[17:46:36.707]                 ...future.workdir <- getwd()
[17:46:36.707]             }
[17:46:36.707]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.707]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.707]         }
[17:46:36.707]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.707]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.707]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.707]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.707]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.707]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.707]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.707]             base::names(...future.oldOptions))
[17:46:36.707]     }
[17:46:36.707]     if (FALSE) {
[17:46:36.707]     }
[17:46:36.707]     else {
[17:46:36.707]         if (TRUE) {
[17:46:36.707]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.707]                 open = "w")
[17:46:36.707]         }
[17:46:36.707]         else {
[17:46:36.707]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.707]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.707]         }
[17:46:36.707]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.707]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.707]             base::sink(type = "output", split = FALSE)
[17:46:36.707]             base::close(...future.stdout)
[17:46:36.707]         }, add = TRUE)
[17:46:36.707]     }
[17:46:36.707]     ...future.frame <- base::sys.nframe()
[17:46:36.707]     ...future.conditions <- base::list()
[17:46:36.707]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.707]     if (FALSE) {
[17:46:36.707]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.707]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.707]     }
[17:46:36.707]     ...future.result <- base::tryCatch({
[17:46:36.707]         base::withCallingHandlers({
[17:46:36.707]             ...future.value <- base::withVisible(base::local({
[17:46:36.707]                 withCallingHandlers({
[17:46:36.707]                   {
[17:46:36.707]                     if (ii%%2 == 0) 
[17:46:36.707]                       stop("Woops!")
[17:46:36.707]                     ii
[17:46:36.707]                   }
[17:46:36.707]                 }, immediateCondition = function(cond) {
[17:46:36.707]                   save_rds <- function (object, pathname, ...) 
[17:46:36.707]                   {
[17:46:36.707]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:36.707]                     if (file_test("-f", pathname_tmp)) {
[17:46:36.707]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.707]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:36.707]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.707]                         fi_tmp[["mtime"]])
[17:46:36.707]                     }
[17:46:36.707]                     tryCatch({
[17:46:36.707]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:36.707]                     }, error = function(ex) {
[17:46:36.707]                       msg <- conditionMessage(ex)
[17:46:36.707]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.707]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:36.707]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.707]                         fi_tmp[["mtime"]], msg)
[17:46:36.707]                       ex$message <- msg
[17:46:36.707]                       stop(ex)
[17:46:36.707]                     })
[17:46:36.707]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:36.707]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:36.707]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:36.707]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.707]                       fi <- file.info(pathname)
[17:46:36.707]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:36.707]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.707]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:36.707]                         fi[["size"]], fi[["mtime"]])
[17:46:36.707]                       stop(msg)
[17:46:36.707]                     }
[17:46:36.707]                     invisible(pathname)
[17:46:36.707]                   }
[17:46:36.707]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:36.707]                     rootPath = tempdir()) 
[17:46:36.707]                   {
[17:46:36.707]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:36.707]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:36.707]                       tmpdir = path, fileext = ".rds")
[17:46:36.707]                     save_rds(obj, file)
[17:46:36.707]                   }
[17:46:36.707]                   saveImmediateCondition(cond, path = "/tmp/RtmpzxgiTZ/.future/immediateConditions")
[17:46:36.707]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.707]                   {
[17:46:36.707]                     inherits <- base::inherits
[17:46:36.707]                     invokeRestart <- base::invokeRestart
[17:46:36.707]                     is.null <- base::is.null
[17:46:36.707]                     muffled <- FALSE
[17:46:36.707]                     if (inherits(cond, "message")) {
[17:46:36.707]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:36.707]                       if (muffled) 
[17:46:36.707]                         invokeRestart("muffleMessage")
[17:46:36.707]                     }
[17:46:36.707]                     else if (inherits(cond, "warning")) {
[17:46:36.707]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:36.707]                       if (muffled) 
[17:46:36.707]                         invokeRestart("muffleWarning")
[17:46:36.707]                     }
[17:46:36.707]                     else if (inherits(cond, "condition")) {
[17:46:36.707]                       if (!is.null(pattern)) {
[17:46:36.707]                         computeRestarts <- base::computeRestarts
[17:46:36.707]                         grepl <- base::grepl
[17:46:36.707]                         restarts <- computeRestarts(cond)
[17:46:36.707]                         for (restart in restarts) {
[17:46:36.707]                           name <- restart$name
[17:46:36.707]                           if (is.null(name)) 
[17:46:36.707]                             next
[17:46:36.707]                           if (!grepl(pattern, name)) 
[17:46:36.707]                             next
[17:46:36.707]                           invokeRestart(restart)
[17:46:36.707]                           muffled <- TRUE
[17:46:36.707]                           break
[17:46:36.707]                         }
[17:46:36.707]                       }
[17:46:36.707]                     }
[17:46:36.707]                     invisible(muffled)
[17:46:36.707]                   }
[17:46:36.707]                   muffleCondition(cond)
[17:46:36.707]                 })
[17:46:36.707]             }))
[17:46:36.707]             future::FutureResult(value = ...future.value$value, 
[17:46:36.707]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.707]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.707]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.707]                     ...future.globalenv.names))
[17:46:36.707]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.707]         }, condition = base::local({
[17:46:36.707]             c <- base::c
[17:46:36.707]             inherits <- base::inherits
[17:46:36.707]             invokeRestart <- base::invokeRestart
[17:46:36.707]             length <- base::length
[17:46:36.707]             list <- base::list
[17:46:36.707]             seq.int <- base::seq.int
[17:46:36.707]             signalCondition <- base::signalCondition
[17:46:36.707]             sys.calls <- base::sys.calls
[17:46:36.707]             `[[` <- base::`[[`
[17:46:36.707]             `+` <- base::`+`
[17:46:36.707]             `<<-` <- base::`<<-`
[17:46:36.707]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.707]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.707]                   3L)]
[17:46:36.707]             }
[17:46:36.707]             function(cond) {
[17:46:36.707]                 is_error <- inherits(cond, "error")
[17:46:36.707]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.707]                   NULL)
[17:46:36.707]                 if (is_error) {
[17:46:36.707]                   sessionInformation <- function() {
[17:46:36.707]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.707]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.707]                       search = base::search(), system = base::Sys.info())
[17:46:36.707]                   }
[17:46:36.707]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.707]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.707]                     cond$call), session = sessionInformation(), 
[17:46:36.707]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.707]                   signalCondition(cond)
[17:46:36.707]                 }
[17:46:36.707]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.707]                 "immediateCondition"))) {
[17:46:36.707]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.707]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.707]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.707]                   if (TRUE && !signal) {
[17:46:36.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.707]                     {
[17:46:36.707]                       inherits <- base::inherits
[17:46:36.707]                       invokeRestart <- base::invokeRestart
[17:46:36.707]                       is.null <- base::is.null
[17:46:36.707]                       muffled <- FALSE
[17:46:36.707]                       if (inherits(cond, "message")) {
[17:46:36.707]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.707]                         if (muffled) 
[17:46:36.707]                           invokeRestart("muffleMessage")
[17:46:36.707]                       }
[17:46:36.707]                       else if (inherits(cond, "warning")) {
[17:46:36.707]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.707]                         if (muffled) 
[17:46:36.707]                           invokeRestart("muffleWarning")
[17:46:36.707]                       }
[17:46:36.707]                       else if (inherits(cond, "condition")) {
[17:46:36.707]                         if (!is.null(pattern)) {
[17:46:36.707]                           computeRestarts <- base::computeRestarts
[17:46:36.707]                           grepl <- base::grepl
[17:46:36.707]                           restarts <- computeRestarts(cond)
[17:46:36.707]                           for (restart in restarts) {
[17:46:36.707]                             name <- restart$name
[17:46:36.707]                             if (is.null(name)) 
[17:46:36.707]                               next
[17:46:36.707]                             if (!grepl(pattern, name)) 
[17:46:36.707]                               next
[17:46:36.707]                             invokeRestart(restart)
[17:46:36.707]                             muffled <- TRUE
[17:46:36.707]                             break
[17:46:36.707]                           }
[17:46:36.707]                         }
[17:46:36.707]                       }
[17:46:36.707]                       invisible(muffled)
[17:46:36.707]                     }
[17:46:36.707]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.707]                   }
[17:46:36.707]                 }
[17:46:36.707]                 else {
[17:46:36.707]                   if (TRUE) {
[17:46:36.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.707]                     {
[17:46:36.707]                       inherits <- base::inherits
[17:46:36.707]                       invokeRestart <- base::invokeRestart
[17:46:36.707]                       is.null <- base::is.null
[17:46:36.707]                       muffled <- FALSE
[17:46:36.707]                       if (inherits(cond, "message")) {
[17:46:36.707]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.707]                         if (muffled) 
[17:46:36.707]                           invokeRestart("muffleMessage")
[17:46:36.707]                       }
[17:46:36.707]                       else if (inherits(cond, "warning")) {
[17:46:36.707]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.707]                         if (muffled) 
[17:46:36.707]                           invokeRestart("muffleWarning")
[17:46:36.707]                       }
[17:46:36.707]                       else if (inherits(cond, "condition")) {
[17:46:36.707]                         if (!is.null(pattern)) {
[17:46:36.707]                           computeRestarts <- base::computeRestarts
[17:46:36.707]                           grepl <- base::grepl
[17:46:36.707]                           restarts <- computeRestarts(cond)
[17:46:36.707]                           for (restart in restarts) {
[17:46:36.707]                             name <- restart$name
[17:46:36.707]                             if (is.null(name)) 
[17:46:36.707]                               next
[17:46:36.707]                             if (!grepl(pattern, name)) 
[17:46:36.707]                               next
[17:46:36.707]                             invokeRestart(restart)
[17:46:36.707]                             muffled <- TRUE
[17:46:36.707]                             break
[17:46:36.707]                           }
[17:46:36.707]                         }
[17:46:36.707]                       }
[17:46:36.707]                       invisible(muffled)
[17:46:36.707]                     }
[17:46:36.707]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.707]                   }
[17:46:36.707]                 }
[17:46:36.707]             }
[17:46:36.707]         }))
[17:46:36.707]     }, error = function(ex) {
[17:46:36.707]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.707]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.707]                 ...future.rng), started = ...future.startTime, 
[17:46:36.707]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.707]             version = "1.8"), class = "FutureResult")
[17:46:36.707]     }, finally = {
[17:46:36.707]         if (!identical(...future.workdir, getwd())) 
[17:46:36.707]             setwd(...future.workdir)
[17:46:36.707]         {
[17:46:36.707]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.707]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.707]             }
[17:46:36.707]             base::options(...future.oldOptions)
[17:46:36.707]             if (.Platform$OS.type == "windows") {
[17:46:36.707]                 old_names <- names(...future.oldEnvVars)
[17:46:36.707]                 envs <- base::Sys.getenv()
[17:46:36.707]                 names <- names(envs)
[17:46:36.707]                 common <- intersect(names, old_names)
[17:46:36.707]                 added <- setdiff(names, old_names)
[17:46:36.707]                 removed <- setdiff(old_names, names)
[17:46:36.707]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.707]                   envs[common]]
[17:46:36.707]                 NAMES <- toupper(changed)
[17:46:36.707]                 args <- list()
[17:46:36.707]                 for (kk in seq_along(NAMES)) {
[17:46:36.707]                   name <- changed[[kk]]
[17:46:36.707]                   NAME <- NAMES[[kk]]
[17:46:36.707]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.707]                     next
[17:46:36.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.707]                 }
[17:46:36.707]                 NAMES <- toupper(added)
[17:46:36.707]                 for (kk in seq_along(NAMES)) {
[17:46:36.707]                   name <- added[[kk]]
[17:46:36.707]                   NAME <- NAMES[[kk]]
[17:46:36.707]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.707]                     next
[17:46:36.707]                   args[[name]] <- ""
[17:46:36.707]                 }
[17:46:36.707]                 NAMES <- toupper(removed)
[17:46:36.707]                 for (kk in seq_along(NAMES)) {
[17:46:36.707]                   name <- removed[[kk]]
[17:46:36.707]                   NAME <- NAMES[[kk]]
[17:46:36.707]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.707]                     next
[17:46:36.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.707]                 }
[17:46:36.707]                 if (length(args) > 0) 
[17:46:36.707]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.707]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.707]             }
[17:46:36.707]             else {
[17:46:36.707]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.707]             }
[17:46:36.707]             {
[17:46:36.707]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.707]                   0L) {
[17:46:36.707]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.707]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.707]                   base::options(opts)
[17:46:36.707]                 }
[17:46:36.707]                 {
[17:46:36.707]                   {
[17:46:36.707]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:36.707]                     NULL
[17:46:36.707]                   }
[17:46:36.707]                   options(future.plan = NULL)
[17:46:36.707]                   if (is.na(NA_character_)) 
[17:46:36.707]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.707]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.707]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.707]                     .init = FALSE)
[17:46:36.707]                 }
[17:46:36.707]             }
[17:46:36.707]         }
[17:46:36.707]     })
[17:46:36.707]     if (TRUE) {
[17:46:36.707]         base::sink(type = "output", split = FALSE)
[17:46:36.707]         if (TRUE) {
[17:46:36.707]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.707]         }
[17:46:36.707]         else {
[17:46:36.707]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.707]         }
[17:46:36.707]         base::close(...future.stdout)
[17:46:36.707]         ...future.stdout <- NULL
[17:46:36.707]     }
[17:46:36.707]     ...future.result$conditions <- ...future.conditions
[17:46:36.707]     ...future.result$finished <- base::Sys.time()
[17:46:36.707]     ...future.result
[17:46:36.707] }
[17:46:36.709] assign_globals() ...
[17:46:36.709] List of 1
[17:46:36.709]  $ ii: int 1
[17:46:36.709]  - attr(*, "where")=List of 1
[17:46:36.709]   ..$ ii:<environment: R_EmptyEnv> 
[17:46:36.709]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:36.709]  - attr(*, "resolved")= logi FALSE
[17:46:36.709]  - attr(*, "total_size")= num 56
[17:46:36.709]  - attr(*, "already-done")= logi TRUE
[17:46:36.712] - copied ‘ii’ to environment
[17:46:36.713] assign_globals() ... done
[17:46:36.713] requestCore(): workers = 2
[17:46:36.714] MulticoreFuture started
[17:46:36.715] - Launch lazy future ... done
[17:46:36.715] run() for ‘MulticoreFuture’ ... done
[17:46:36.716] plan(): Setting new future strategy stack:
[17:46:36.716] getGlobalsAndPackages() ...
[17:46:36.716] Searching for globals...
[17:46:36.716] List of future strategies:
[17:46:36.716] 1. sequential:
[17:46:36.716]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.716]    - tweaked: FALSE
[17:46:36.716]    - call: NULL
[17:46:36.717] plan(): nbrOfWorkers() = 1
[17:46:36.719] plan(): Setting new future strategy stack:
[17:46:36.719] List of future strategies:
[17:46:36.719] 1. multicore:
[17:46:36.719]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:36.719]    - tweaked: FALSE
[17:46:36.719]    - call: plan(strategy)
[17:46:36.719] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:46:36.719] Searching for globals ... DONE
[17:46:36.720] Resolving globals: FALSE
[17:46:36.720] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:36.721] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:46:36.721] - globals: [1] ‘ii’
[17:46:36.722] 
[17:46:36.722] getGlobalsAndPackages() ... DONE
[17:46:36.722] run() for ‘Future’ ...
[17:46:36.722] - state: ‘created’
[17:46:36.723] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:36.723] plan(): nbrOfWorkers() = 2
[17:46:36.727] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:36.727] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:36.727]   - Field: ‘label’
[17:46:36.728]   - Field: ‘local’
[17:46:36.728]   - Field: ‘owner’
[17:46:36.728]   - Field: ‘envir’
[17:46:36.728]   - Field: ‘workers’
[17:46:36.728]   - Field: ‘packages’
[17:46:36.728]   - Field: ‘gc’
[17:46:36.728]   - Field: ‘job’
[17:46:36.729]   - Field: ‘conditions’
[17:46:36.729]   - Field: ‘expr’
[17:46:36.729]   - Field: ‘uuid’
[17:46:36.729]   - Field: ‘seed’
[17:46:36.729]   - Field: ‘version’
[17:46:36.729]   - Field: ‘result’
[17:46:36.729]   - Field: ‘asynchronous’
[17:46:36.730]   - Field: ‘calls’
[17:46:36.730]   - Field: ‘globals’
[17:46:36.730]   - Field: ‘stdout’
[17:46:36.730]   - Field: ‘earlySignal’
[17:46:36.730]   - Field: ‘lazy’
[17:46:36.730]   - Field: ‘state’
[17:46:36.730] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:36.731] - Launch lazy future ...
[17:46:36.731] Packages needed by the future expression (n = 0): <none>
[17:46:36.731] Packages needed by future strategies (n = 0): <none>
[17:46:36.732] {
[17:46:36.732]     {
[17:46:36.732]         {
[17:46:36.732]             ...future.startTime <- base::Sys.time()
[17:46:36.732]             {
[17:46:36.732]                 {
[17:46:36.732]                   {
[17:46:36.732]                     {
[17:46:36.732]                       base::local({
[17:46:36.732]                         has_future <- base::requireNamespace("future", 
[17:46:36.732]                           quietly = TRUE)
[17:46:36.732]                         if (has_future) {
[17:46:36.732]                           ns <- base::getNamespace("future")
[17:46:36.732]                           version <- ns[[".package"]][["version"]]
[17:46:36.732]                           if (is.null(version)) 
[17:46:36.732]                             version <- utils::packageVersion("future")
[17:46:36.732]                         }
[17:46:36.732]                         else {
[17:46:36.732]                           version <- NULL
[17:46:36.732]                         }
[17:46:36.732]                         if (!has_future || version < "1.8.0") {
[17:46:36.732]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.732]                             "", base::R.version$version.string), 
[17:46:36.732]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:36.732]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.732]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.732]                               "release", "version")], collapse = " "), 
[17:46:36.732]                             hostname = base::Sys.info()[["nodename"]])
[17:46:36.732]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.732]                             info)
[17:46:36.732]                           info <- base::paste(info, collapse = "; ")
[17:46:36.732]                           if (!has_future) {
[17:46:36.732]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.732]                               info)
[17:46:36.732]                           }
[17:46:36.732]                           else {
[17:46:36.732]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.732]                               info, version)
[17:46:36.732]                           }
[17:46:36.732]                           base::stop(msg)
[17:46:36.732]                         }
[17:46:36.732]                       })
[17:46:36.732]                     }
[17:46:36.732]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:36.732]                     base::options(mc.cores = 1L)
[17:46:36.732]                   }
[17:46:36.732]                   ...future.strategy.old <- future::plan("list")
[17:46:36.732]                   options(future.plan = NULL)
[17:46:36.732]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.732]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.732]                 }
[17:46:36.732]                 ...future.workdir <- getwd()
[17:46:36.732]             }
[17:46:36.732]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.732]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.732]         }
[17:46:36.732]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.732]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.732]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.732]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.732]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.732]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.732]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.732]             base::names(...future.oldOptions))
[17:46:36.732]     }
[17:46:36.732]     if (FALSE) {
[17:46:36.732]     }
[17:46:36.732]     else {
[17:46:36.732]         if (TRUE) {
[17:46:36.732]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.732]                 open = "w")
[17:46:36.732]         }
[17:46:36.732]         else {
[17:46:36.732]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.732]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.732]         }
[17:46:36.732]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.732]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.732]             base::sink(type = "output", split = FALSE)
[17:46:36.732]             base::close(...future.stdout)
[17:46:36.732]         }, add = TRUE)
[17:46:36.732]     }
[17:46:36.732]     ...future.frame <- base::sys.nframe()
[17:46:36.732]     ...future.conditions <- base::list()
[17:46:36.732]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.732]     if (FALSE) {
[17:46:36.732]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.732]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.732]     }
[17:46:36.732]     ...future.result <- base::tryCatch({
[17:46:36.732]         base::withCallingHandlers({
[17:46:36.732]             ...future.value <- base::withVisible(base::local({
[17:46:36.732]                 withCallingHandlers({
[17:46:36.732]                   {
[17:46:36.732]                     if (ii%%2 == 0) 
[17:46:36.732]                       stop("Woops!")
[17:46:36.732]                     ii
[17:46:36.732]                   }
[17:46:36.732]                 }, immediateCondition = function(cond) {
[17:46:36.732]                   save_rds <- function (object, pathname, ...) 
[17:46:36.732]                   {
[17:46:36.732]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:36.732]                     if (file_test("-f", pathname_tmp)) {
[17:46:36.732]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.732]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:36.732]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.732]                         fi_tmp[["mtime"]])
[17:46:36.732]                     }
[17:46:36.732]                     tryCatch({
[17:46:36.732]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:36.732]                     }, error = function(ex) {
[17:46:36.732]                       msg <- conditionMessage(ex)
[17:46:36.732]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.732]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:36.732]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.732]                         fi_tmp[["mtime"]], msg)
[17:46:36.732]                       ex$message <- msg
[17:46:36.732]                       stop(ex)
[17:46:36.732]                     })
[17:46:36.732]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:36.732]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:36.732]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:36.732]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.732]                       fi <- file.info(pathname)
[17:46:36.732]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:36.732]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.732]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:36.732]                         fi[["size"]], fi[["mtime"]])
[17:46:36.732]                       stop(msg)
[17:46:36.732]                     }
[17:46:36.732]                     invisible(pathname)
[17:46:36.732]                   }
[17:46:36.732]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:36.732]                     rootPath = tempdir()) 
[17:46:36.732]                   {
[17:46:36.732]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:36.732]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:36.732]                       tmpdir = path, fileext = ".rds")
[17:46:36.732]                     save_rds(obj, file)
[17:46:36.732]                   }
[17:46:36.732]                   saveImmediateCondition(cond, path = "/tmp/RtmpzxgiTZ/.future/immediateConditions")
[17:46:36.732]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.732]                   {
[17:46:36.732]                     inherits <- base::inherits
[17:46:36.732]                     invokeRestart <- base::invokeRestart
[17:46:36.732]                     is.null <- base::is.null
[17:46:36.732]                     muffled <- FALSE
[17:46:36.732]                     if (inherits(cond, "message")) {
[17:46:36.732]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:36.732]                       if (muffled) 
[17:46:36.732]                         invokeRestart("muffleMessage")
[17:46:36.732]                     }
[17:46:36.732]                     else if (inherits(cond, "warning")) {
[17:46:36.732]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:36.732]                       if (muffled) 
[17:46:36.732]                         invokeRestart("muffleWarning")
[17:46:36.732]                     }
[17:46:36.732]                     else if (inherits(cond, "condition")) {
[17:46:36.732]                       if (!is.null(pattern)) {
[17:46:36.732]                         computeRestarts <- base::computeRestarts
[17:46:36.732]                         grepl <- base::grepl
[17:46:36.732]                         restarts <- computeRestarts(cond)
[17:46:36.732]                         for (restart in restarts) {
[17:46:36.732]                           name <- restart$name
[17:46:36.732]                           if (is.null(name)) 
[17:46:36.732]                             next
[17:46:36.732]                           if (!grepl(pattern, name)) 
[17:46:36.732]                             next
[17:46:36.732]                           invokeRestart(restart)
[17:46:36.732]                           muffled <- TRUE
[17:46:36.732]                           break
[17:46:36.732]                         }
[17:46:36.732]                       }
[17:46:36.732]                     }
[17:46:36.732]                     invisible(muffled)
[17:46:36.732]                   }
[17:46:36.732]                   muffleCondition(cond)
[17:46:36.732]                 })
[17:46:36.732]             }))
[17:46:36.732]             future::FutureResult(value = ...future.value$value, 
[17:46:36.732]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.732]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.732]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.732]                     ...future.globalenv.names))
[17:46:36.732]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.732]         }, condition = base::local({
[17:46:36.732]             c <- base::c
[17:46:36.732]             inherits <- base::inherits
[17:46:36.732]             invokeRestart <- base::invokeRestart
[17:46:36.732]             length <- base::length
[17:46:36.732]             list <- base::list
[17:46:36.732]             seq.int <- base::seq.int
[17:46:36.732]             signalCondition <- base::signalCondition
[17:46:36.732]             sys.calls <- base::sys.calls
[17:46:36.732]             `[[` <- base::`[[`
[17:46:36.732]             `+` <- base::`+`
[17:46:36.732]             `<<-` <- base::`<<-`
[17:46:36.732]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.732]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.732]                   3L)]
[17:46:36.732]             }
[17:46:36.732]             function(cond) {
[17:46:36.732]                 is_error <- inherits(cond, "error")
[17:46:36.732]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.732]                   NULL)
[17:46:36.732]                 if (is_error) {
[17:46:36.732]                   sessionInformation <- function() {
[17:46:36.732]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.732]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.732]                       search = base::search(), system = base::Sys.info())
[17:46:36.732]                   }
[17:46:36.732]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.732]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.732]                     cond$call), session = sessionInformation(), 
[17:46:36.732]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.732]                   signalCondition(cond)
[17:46:36.732]                 }
[17:46:36.732]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.732]                 "immediateCondition"))) {
[17:46:36.732]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.732]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.732]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.732]                   if (TRUE && !signal) {
[17:46:36.732]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.732]                     {
[17:46:36.732]                       inherits <- base::inherits
[17:46:36.732]                       invokeRestart <- base::invokeRestart
[17:46:36.732]                       is.null <- base::is.null
[17:46:36.732]                       muffled <- FALSE
[17:46:36.732]                       if (inherits(cond, "message")) {
[17:46:36.732]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.732]                         if (muffled) 
[17:46:36.732]                           invokeRestart("muffleMessage")
[17:46:36.732]                       }
[17:46:36.732]                       else if (inherits(cond, "warning")) {
[17:46:36.732]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.732]                         if (muffled) 
[17:46:36.732]                           invokeRestart("muffleWarning")
[17:46:36.732]                       }
[17:46:36.732]                       else if (inherits(cond, "condition")) {
[17:46:36.732]                         if (!is.null(pattern)) {
[17:46:36.732]                           computeRestarts <- base::computeRestarts
[17:46:36.732]                           grepl <- base::grepl
[17:46:36.732]                           restarts <- computeRestarts(cond)
[17:46:36.732]                           for (restart in restarts) {
[17:46:36.732]                             name <- restart$name
[17:46:36.732]                             if (is.null(name)) 
[17:46:36.732]                               next
[17:46:36.732]                             if (!grepl(pattern, name)) 
[17:46:36.732]                               next
[17:46:36.732]                             invokeRestart(restart)
[17:46:36.732]                             muffled <- TRUE
[17:46:36.732]                             break
[17:46:36.732]                           }
[17:46:36.732]                         }
[17:46:36.732]                       }
[17:46:36.732]                       invisible(muffled)
[17:46:36.732]                     }
[17:46:36.732]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.732]                   }
[17:46:36.732]                 }
[17:46:36.732]                 else {
[17:46:36.732]                   if (TRUE) {
[17:46:36.732]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.732]                     {
[17:46:36.732]                       inherits <- base::inherits
[17:46:36.732]                       invokeRestart <- base::invokeRestart
[17:46:36.732]                       is.null <- base::is.null
[17:46:36.732]                       muffled <- FALSE
[17:46:36.732]                       if (inherits(cond, "message")) {
[17:46:36.732]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.732]                         if (muffled) 
[17:46:36.732]                           invokeRestart("muffleMessage")
[17:46:36.732]                       }
[17:46:36.732]                       else if (inherits(cond, "warning")) {
[17:46:36.732]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.732]                         if (muffled) 
[17:46:36.732]                           invokeRestart("muffleWarning")
[17:46:36.732]                       }
[17:46:36.732]                       else if (inherits(cond, "condition")) {
[17:46:36.732]                         if (!is.null(pattern)) {
[17:46:36.732]                           computeRestarts <- base::computeRestarts
[17:46:36.732]                           grepl <- base::grepl
[17:46:36.732]                           restarts <- computeRestarts(cond)
[17:46:36.732]                           for (restart in restarts) {
[17:46:36.732]                             name <- restart$name
[17:46:36.732]                             if (is.null(name)) 
[17:46:36.732]                               next
[17:46:36.732]                             if (!grepl(pattern, name)) 
[17:46:36.732]                               next
[17:46:36.732]                             invokeRestart(restart)
[17:46:36.732]                             muffled <- TRUE
[17:46:36.732]                             break
[17:46:36.732]                           }
[17:46:36.732]                         }
[17:46:36.732]                       }
[17:46:36.732]                       invisible(muffled)
[17:46:36.732]                     }
[17:46:36.732]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.732]                   }
[17:46:36.732]                 }
[17:46:36.732]             }
[17:46:36.732]         }))
[17:46:36.732]     }, error = function(ex) {
[17:46:36.732]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.732]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.732]                 ...future.rng), started = ...future.startTime, 
[17:46:36.732]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.732]             version = "1.8"), class = "FutureResult")
[17:46:36.732]     }, finally = {
[17:46:36.732]         if (!identical(...future.workdir, getwd())) 
[17:46:36.732]             setwd(...future.workdir)
[17:46:36.732]         {
[17:46:36.732]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.732]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.732]             }
[17:46:36.732]             base::options(...future.oldOptions)
[17:46:36.732]             if (.Platform$OS.type == "windows") {
[17:46:36.732]                 old_names <- names(...future.oldEnvVars)
[17:46:36.732]                 envs <- base::Sys.getenv()
[17:46:36.732]                 names <- names(envs)
[17:46:36.732]                 common <- intersect(names, old_names)
[17:46:36.732]                 added <- setdiff(names, old_names)
[17:46:36.732]                 removed <- setdiff(old_names, names)
[17:46:36.732]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.732]                   envs[common]]
[17:46:36.732]                 NAMES <- toupper(changed)
[17:46:36.732]                 args <- list()
[17:46:36.732]                 for (kk in seq_along(NAMES)) {
[17:46:36.732]                   name <- changed[[kk]]
[17:46:36.732]                   NAME <- NAMES[[kk]]
[17:46:36.732]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.732]                     next
[17:46:36.732]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.732]                 }
[17:46:36.732]                 NAMES <- toupper(added)
[17:46:36.732]                 for (kk in seq_along(NAMES)) {
[17:46:36.732]                   name <- added[[kk]]
[17:46:36.732]                   NAME <- NAMES[[kk]]
[17:46:36.732]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.732]                     next
[17:46:36.732]                   args[[name]] <- ""
[17:46:36.732]                 }
[17:46:36.732]                 NAMES <- toupper(removed)
[17:46:36.732]                 for (kk in seq_along(NAMES)) {
[17:46:36.732]                   name <- removed[[kk]]
[17:46:36.732]                   NAME <- NAMES[[kk]]
[17:46:36.732]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.732]                     next
[17:46:36.732]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.732]                 }
[17:46:36.732]                 if (length(args) > 0) 
[17:46:36.732]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.732]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.732]             }
[17:46:36.732]             else {
[17:46:36.732]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.732]             }
[17:46:36.732]             {
[17:46:36.732]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.732]                   0L) {
[17:46:36.732]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.732]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.732]                   base::options(opts)
[17:46:36.732]                 }
[17:46:36.732]                 {
[17:46:36.732]                   {
[17:46:36.732]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:36.732]                     NULL
[17:46:36.732]                   }
[17:46:36.732]                   options(future.plan = NULL)
[17:46:36.732]                   if (is.na(NA_character_)) 
[17:46:36.732]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.732]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.732]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.732]                     .init = FALSE)
[17:46:36.732]                 }
[17:46:36.732]             }
[17:46:36.732]         }
[17:46:36.732]     })
[17:46:36.732]     if (TRUE) {
[17:46:36.732]         base::sink(type = "output", split = FALSE)
[17:46:36.732]         if (TRUE) {
[17:46:36.732]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.732]         }
[17:46:36.732]         else {
[17:46:36.732]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.732]         }
[17:46:36.732]         base::close(...future.stdout)
[17:46:36.732]         ...future.stdout <- NULL
[17:46:36.732]     }
[17:46:36.732]     ...future.result$conditions <- ...future.conditions
[17:46:36.732]     ...future.result$finished <- base::Sys.time()
[17:46:36.732]     ...future.result
[17:46:36.732] }
[17:46:36.735] assign_globals() ...
[17:46:36.735] List of 1
[17:46:36.735]  $ ii: int 2
[17:46:36.735]  - attr(*, "where")=List of 1
[17:46:36.735]   ..$ ii:<environment: R_EmptyEnv> 
[17:46:36.735]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:36.735]  - attr(*, "resolved")= logi FALSE
[17:46:36.735]  - attr(*, "total_size")= num 56
[17:46:36.735]  - attr(*, "already-done")= logi TRUE
[17:46:36.739] - copied ‘ii’ to environment
[17:46:36.739] assign_globals() ... done
[17:46:36.739] requestCore(): workers = 2
[17:46:36.741] MulticoreFuture started
[17:46:36.741] - Launch lazy future ... done
[17:46:36.742] run() for ‘MulticoreFuture’ ... done
[17:46:36.742] plan(): Setting new future strategy stack:
[17:46:36.743] getGlobalsAndPackages() ...
[17:46:36.742] List of future strategies:
[17:46:36.742] 1. sequential:
[17:46:36.742]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.742]    - tweaked: FALSE
[17:46:36.742]    - call: NULL
[17:46:36.743] Searching for globals...
[17:46:36.743] plan(): nbrOfWorkers() = 1
[17:46:36.748] plan(): Setting new future strategy stack:
[17:46:36.749] List of future strategies:
[17:46:36.749] 1. multicore:
[17:46:36.749]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:36.749]    - tweaked: FALSE
[17:46:36.749]    - call: plan(strategy)
[17:46:36.750] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:46:36.750] Searching for globals ... DONE
[17:46:36.751] Resolving globals: FALSE
[17:46:36.752] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:36.752] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:46:36.752] - globals: [1] ‘ii’
[17:46:36.753] 
[17:46:36.753] getGlobalsAndPackages() ... DONE
[17:46:36.753] run() for ‘Future’ ...
[17:46:36.753] - state: ‘created’
[17:46:36.753] plan(): nbrOfWorkers() = 2
[17:46:36.754] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:36.758] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:36.758] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:36.758]   - Field: ‘label’
[17:46:36.758]   - Field: ‘local’
[17:46:36.759]   - Field: ‘owner’
[17:46:36.759]   - Field: ‘envir’
[17:46:36.759]   - Field: ‘workers’
[17:46:36.759]   - Field: ‘packages’
[17:46:36.759]   - Field: ‘gc’
[17:46:36.759]   - Field: ‘job’
[17:46:36.760]   - Field: ‘conditions’
[17:46:36.760]   - Field: ‘expr’
[17:46:36.760]   - Field: ‘uuid’
[17:46:36.760]   - Field: ‘seed’
[17:46:36.760]   - Field: ‘version’
[17:46:36.760]   - Field: ‘result’
[17:46:36.760]   - Field: ‘asynchronous’
[17:46:36.760]   - Field: ‘calls’
[17:46:36.761]   - Field: ‘globals’
[17:46:36.761]   - Field: ‘stdout’
[17:46:36.761]   - Field: ‘earlySignal’
[17:46:36.761]   - Field: ‘lazy’
[17:46:36.761]   - Field: ‘state’
[17:46:36.761] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:36.761] - Launch lazy future ...
[17:46:36.762] Packages needed by the future expression (n = 0): <none>
[17:46:36.762] Packages needed by future strategies (n = 0): <none>
[17:46:36.763] {
[17:46:36.763]     {
[17:46:36.763]         {
[17:46:36.763]             ...future.startTime <- base::Sys.time()
[17:46:36.763]             {
[17:46:36.763]                 {
[17:46:36.763]                   {
[17:46:36.763]                     {
[17:46:36.763]                       base::local({
[17:46:36.763]                         has_future <- base::requireNamespace("future", 
[17:46:36.763]                           quietly = TRUE)
[17:46:36.763]                         if (has_future) {
[17:46:36.763]                           ns <- base::getNamespace("future")
[17:46:36.763]                           version <- ns[[".package"]][["version"]]
[17:46:36.763]                           if (is.null(version)) 
[17:46:36.763]                             version <- utils::packageVersion("future")
[17:46:36.763]                         }
[17:46:36.763]                         else {
[17:46:36.763]                           version <- NULL
[17:46:36.763]                         }
[17:46:36.763]                         if (!has_future || version < "1.8.0") {
[17:46:36.763]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.763]                             "", base::R.version$version.string), 
[17:46:36.763]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:36.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.763]                               "release", "version")], collapse = " "), 
[17:46:36.763]                             hostname = base::Sys.info()[["nodename"]])
[17:46:36.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.763]                             info)
[17:46:36.763]                           info <- base::paste(info, collapse = "; ")
[17:46:36.763]                           if (!has_future) {
[17:46:36.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.763]                               info)
[17:46:36.763]                           }
[17:46:36.763]                           else {
[17:46:36.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.763]                               info, version)
[17:46:36.763]                           }
[17:46:36.763]                           base::stop(msg)
[17:46:36.763]                         }
[17:46:36.763]                       })
[17:46:36.763]                     }
[17:46:36.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:36.763]                     base::options(mc.cores = 1L)
[17:46:36.763]                   }
[17:46:36.763]                   ...future.strategy.old <- future::plan("list")
[17:46:36.763]                   options(future.plan = NULL)
[17:46:36.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.763]                 }
[17:46:36.763]                 ...future.workdir <- getwd()
[17:46:36.763]             }
[17:46:36.763]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.763]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.763]         }
[17:46:36.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.763]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.763]             base::names(...future.oldOptions))
[17:46:36.763]     }
[17:46:36.763]     if (FALSE) {
[17:46:36.763]     }
[17:46:36.763]     else {
[17:46:36.763]         if (TRUE) {
[17:46:36.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.763]                 open = "w")
[17:46:36.763]         }
[17:46:36.763]         else {
[17:46:36.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.763]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.763]         }
[17:46:36.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.763]             base::sink(type = "output", split = FALSE)
[17:46:36.763]             base::close(...future.stdout)
[17:46:36.763]         }, add = TRUE)
[17:46:36.763]     }
[17:46:36.763]     ...future.frame <- base::sys.nframe()
[17:46:36.763]     ...future.conditions <- base::list()
[17:46:36.763]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.763]     if (FALSE) {
[17:46:36.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.763]     }
[17:46:36.763]     ...future.result <- base::tryCatch({
[17:46:36.763]         base::withCallingHandlers({
[17:46:36.763]             ...future.value <- base::withVisible(base::local({
[17:46:36.763]                 withCallingHandlers({
[17:46:36.763]                   {
[17:46:36.763]                     if (ii%%2 == 0) 
[17:46:36.763]                       stop("Woops!")
[17:46:36.763]                     ii
[17:46:36.763]                   }
[17:46:36.763]                 }, immediateCondition = function(cond) {
[17:46:36.763]                   save_rds <- function (object, pathname, ...) 
[17:46:36.763]                   {
[17:46:36.763]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:36.763]                     if (file_test("-f", pathname_tmp)) {
[17:46:36.763]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.763]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:36.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.763]                         fi_tmp[["mtime"]])
[17:46:36.763]                     }
[17:46:36.763]                     tryCatch({
[17:46:36.763]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:36.763]                     }, error = function(ex) {
[17:46:36.763]                       msg <- conditionMessage(ex)
[17:46:36.763]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.763]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:36.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.763]                         fi_tmp[["mtime"]], msg)
[17:46:36.763]                       ex$message <- msg
[17:46:36.763]                       stop(ex)
[17:46:36.763]                     })
[17:46:36.763]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:36.763]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:36.763]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:36.763]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.763]                       fi <- file.info(pathname)
[17:46:36.763]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:36.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.763]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:36.763]                         fi[["size"]], fi[["mtime"]])
[17:46:36.763]                       stop(msg)
[17:46:36.763]                     }
[17:46:36.763]                     invisible(pathname)
[17:46:36.763]                   }
[17:46:36.763]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:36.763]                     rootPath = tempdir()) 
[17:46:36.763]                   {
[17:46:36.763]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:36.763]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:36.763]                       tmpdir = path, fileext = ".rds")
[17:46:36.763]                     save_rds(obj, file)
[17:46:36.763]                   }
[17:46:36.763]                   saveImmediateCondition(cond, path = "/tmp/RtmpzxgiTZ/.future/immediateConditions")
[17:46:36.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.763]                   {
[17:46:36.763]                     inherits <- base::inherits
[17:46:36.763]                     invokeRestart <- base::invokeRestart
[17:46:36.763]                     is.null <- base::is.null
[17:46:36.763]                     muffled <- FALSE
[17:46:36.763]                     if (inherits(cond, "message")) {
[17:46:36.763]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:36.763]                       if (muffled) 
[17:46:36.763]                         invokeRestart("muffleMessage")
[17:46:36.763]                     }
[17:46:36.763]                     else if (inherits(cond, "warning")) {
[17:46:36.763]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:36.763]                       if (muffled) 
[17:46:36.763]                         invokeRestart("muffleWarning")
[17:46:36.763]                     }
[17:46:36.763]                     else if (inherits(cond, "condition")) {
[17:46:36.763]                       if (!is.null(pattern)) {
[17:46:36.763]                         computeRestarts <- base::computeRestarts
[17:46:36.763]                         grepl <- base::grepl
[17:46:36.763]                         restarts <- computeRestarts(cond)
[17:46:36.763]                         for (restart in restarts) {
[17:46:36.763]                           name <- restart$name
[17:46:36.763]                           if (is.null(name)) 
[17:46:36.763]                             next
[17:46:36.763]                           if (!grepl(pattern, name)) 
[17:46:36.763]                             next
[17:46:36.763]                           invokeRestart(restart)
[17:46:36.763]                           muffled <- TRUE
[17:46:36.763]                           break
[17:46:36.763]                         }
[17:46:36.763]                       }
[17:46:36.763]                     }
[17:46:36.763]                     invisible(muffled)
[17:46:36.763]                   }
[17:46:36.763]                   muffleCondition(cond)
[17:46:36.763]                 })
[17:46:36.763]             }))
[17:46:36.763]             future::FutureResult(value = ...future.value$value, 
[17:46:36.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.763]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.763]                     ...future.globalenv.names))
[17:46:36.763]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.763]         }, condition = base::local({
[17:46:36.763]             c <- base::c
[17:46:36.763]             inherits <- base::inherits
[17:46:36.763]             invokeRestart <- base::invokeRestart
[17:46:36.763]             length <- base::length
[17:46:36.763]             list <- base::list
[17:46:36.763]             seq.int <- base::seq.int
[17:46:36.763]             signalCondition <- base::signalCondition
[17:46:36.763]             sys.calls <- base::sys.calls
[17:46:36.763]             `[[` <- base::`[[`
[17:46:36.763]             `+` <- base::`+`
[17:46:36.763]             `<<-` <- base::`<<-`
[17:46:36.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.763]                   3L)]
[17:46:36.763]             }
[17:46:36.763]             function(cond) {
[17:46:36.763]                 is_error <- inherits(cond, "error")
[17:46:36.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.763]                   NULL)
[17:46:36.763]                 if (is_error) {
[17:46:36.763]                   sessionInformation <- function() {
[17:46:36.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.763]                       search = base::search(), system = base::Sys.info())
[17:46:36.763]                   }
[17:46:36.763]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.763]                     cond$call), session = sessionInformation(), 
[17:46:36.763]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.763]                   signalCondition(cond)
[17:46:36.763]                 }
[17:46:36.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.763]                 "immediateCondition"))) {
[17:46:36.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.763]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.763]                   if (TRUE && !signal) {
[17:46:36.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.763]                     {
[17:46:36.763]                       inherits <- base::inherits
[17:46:36.763]                       invokeRestart <- base::invokeRestart
[17:46:36.763]                       is.null <- base::is.null
[17:46:36.763]                       muffled <- FALSE
[17:46:36.763]                       if (inherits(cond, "message")) {
[17:46:36.763]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.763]                         if (muffled) 
[17:46:36.763]                           invokeRestart("muffleMessage")
[17:46:36.763]                       }
[17:46:36.763]                       else if (inherits(cond, "warning")) {
[17:46:36.763]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.763]                         if (muffled) 
[17:46:36.763]                           invokeRestart("muffleWarning")
[17:46:36.763]                       }
[17:46:36.763]                       else if (inherits(cond, "condition")) {
[17:46:36.763]                         if (!is.null(pattern)) {
[17:46:36.763]                           computeRestarts <- base::computeRestarts
[17:46:36.763]                           grepl <- base::grepl
[17:46:36.763]                           restarts <- computeRestarts(cond)
[17:46:36.763]                           for (restart in restarts) {
[17:46:36.763]                             name <- restart$name
[17:46:36.763]                             if (is.null(name)) 
[17:46:36.763]                               next
[17:46:36.763]                             if (!grepl(pattern, name)) 
[17:46:36.763]                               next
[17:46:36.763]                             invokeRestart(restart)
[17:46:36.763]                             muffled <- TRUE
[17:46:36.763]                             break
[17:46:36.763]                           }
[17:46:36.763]                         }
[17:46:36.763]                       }
[17:46:36.763]                       invisible(muffled)
[17:46:36.763]                     }
[17:46:36.763]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.763]                   }
[17:46:36.763]                 }
[17:46:36.763]                 else {
[17:46:36.763]                   if (TRUE) {
[17:46:36.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.763]                     {
[17:46:36.763]                       inherits <- base::inherits
[17:46:36.763]                       invokeRestart <- base::invokeRestart
[17:46:36.763]                       is.null <- base::is.null
[17:46:36.763]                       muffled <- FALSE
[17:46:36.763]                       if (inherits(cond, "message")) {
[17:46:36.763]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.763]                         if (muffled) 
[17:46:36.763]                           invokeRestart("muffleMessage")
[17:46:36.763]                       }
[17:46:36.763]                       else if (inherits(cond, "warning")) {
[17:46:36.763]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.763]                         if (muffled) 
[17:46:36.763]                           invokeRestart("muffleWarning")
[17:46:36.763]                       }
[17:46:36.763]                       else if (inherits(cond, "condition")) {
[17:46:36.763]                         if (!is.null(pattern)) {
[17:46:36.763]                           computeRestarts <- base::computeRestarts
[17:46:36.763]                           grepl <- base::grepl
[17:46:36.763]                           restarts <- computeRestarts(cond)
[17:46:36.763]                           for (restart in restarts) {
[17:46:36.763]                             name <- restart$name
[17:46:36.763]                             if (is.null(name)) 
[17:46:36.763]                               next
[17:46:36.763]                             if (!grepl(pattern, name)) 
[17:46:36.763]                               next
[17:46:36.763]                             invokeRestart(restart)
[17:46:36.763]                             muffled <- TRUE
[17:46:36.763]                             break
[17:46:36.763]                           }
[17:46:36.763]                         }
[17:46:36.763]                       }
[17:46:36.763]                       invisible(muffled)
[17:46:36.763]                     }
[17:46:36.763]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.763]                   }
[17:46:36.763]                 }
[17:46:36.763]             }
[17:46:36.763]         }))
[17:46:36.763]     }, error = function(ex) {
[17:46:36.763]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.763]                 ...future.rng), started = ...future.startTime, 
[17:46:36.763]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.763]             version = "1.8"), class = "FutureResult")
[17:46:36.763]     }, finally = {
[17:46:36.763]         if (!identical(...future.workdir, getwd())) 
[17:46:36.763]             setwd(...future.workdir)
[17:46:36.763]         {
[17:46:36.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.763]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.763]             }
[17:46:36.763]             base::options(...future.oldOptions)
[17:46:36.763]             if (.Platform$OS.type == "windows") {
[17:46:36.763]                 old_names <- names(...future.oldEnvVars)
[17:46:36.763]                 envs <- base::Sys.getenv()
[17:46:36.763]                 names <- names(envs)
[17:46:36.763]                 common <- intersect(names, old_names)
[17:46:36.763]                 added <- setdiff(names, old_names)
[17:46:36.763]                 removed <- setdiff(old_names, names)
[17:46:36.763]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.763]                   envs[common]]
[17:46:36.763]                 NAMES <- toupper(changed)
[17:46:36.763]                 args <- list()
[17:46:36.763]                 for (kk in seq_along(NAMES)) {
[17:46:36.763]                   name <- changed[[kk]]
[17:46:36.763]                   NAME <- NAMES[[kk]]
[17:46:36.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.763]                     next
[17:46:36.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.763]                 }
[17:46:36.763]                 NAMES <- toupper(added)
[17:46:36.763]                 for (kk in seq_along(NAMES)) {
[17:46:36.763]                   name <- added[[kk]]
[17:46:36.763]                   NAME <- NAMES[[kk]]
[17:46:36.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.763]                     next
[17:46:36.763]                   args[[name]] <- ""
[17:46:36.763]                 }
[17:46:36.763]                 NAMES <- toupper(removed)
[17:46:36.763]                 for (kk in seq_along(NAMES)) {
[17:46:36.763]                   name <- removed[[kk]]
[17:46:36.763]                   NAME <- NAMES[[kk]]
[17:46:36.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.763]                     next
[17:46:36.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.763]                 }
[17:46:36.763]                 if (length(args) > 0) 
[17:46:36.763]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.763]             }
[17:46:36.763]             else {
[17:46:36.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.763]             }
[17:46:36.763]             {
[17:46:36.763]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.763]                   0L) {
[17:46:36.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.763]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.763]                   base::options(opts)
[17:46:36.763]                 }
[17:46:36.763]                 {
[17:46:36.763]                   {
[17:46:36.763]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:36.763]                     NULL
[17:46:36.763]                   }
[17:46:36.763]                   options(future.plan = NULL)
[17:46:36.763]                   if (is.na(NA_character_)) 
[17:46:36.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.763]                     .init = FALSE)
[17:46:36.763]                 }
[17:46:36.763]             }
[17:46:36.763]         }
[17:46:36.763]     })
[17:46:36.763]     if (TRUE) {
[17:46:36.763]         base::sink(type = "output", split = FALSE)
[17:46:36.763]         if (TRUE) {
[17:46:36.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.763]         }
[17:46:36.763]         else {
[17:46:36.763]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.763]         }
[17:46:36.763]         base::close(...future.stdout)
[17:46:36.763]         ...future.stdout <- NULL
[17:46:36.763]     }
[17:46:36.763]     ...future.result$conditions <- ...future.conditions
[17:46:36.763]     ...future.result$finished <- base::Sys.time()
[17:46:36.763]     ...future.result
[17:46:36.763] }
[17:46:36.765] assign_globals() ...
[17:46:36.765] List of 1
[17:46:36.765]  $ ii: int 3
[17:46:36.765]  - attr(*, "where")=List of 1
[17:46:36.765]   ..$ ii:<environment: R_EmptyEnv> 
[17:46:36.765]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:36.765]  - attr(*, "resolved")= logi FALSE
[17:46:36.765]  - attr(*, "total_size")= num 56
[17:46:36.765]  - attr(*, "already-done")= logi TRUE
[17:46:36.769] - copied ‘ii’ to environment
[17:46:36.769] assign_globals() ... done
[17:46:36.769] requestCore(): workers = 2
[17:46:36.770] Poll #1 (0): usedCores() = 2, workers = 2
[17:46:36.781] result() for MulticoreFuture ...
[17:46:36.782] result() for MulticoreFuture ...
[17:46:36.782] result() for MulticoreFuture ... done
[17:46:36.782] result() for MulticoreFuture ... done
[17:46:36.782] result() for MulticoreFuture ...
[17:46:36.782] result() for MulticoreFuture ... done
[17:46:36.785] MulticoreFuture started
[17:46:36.786] - Launch lazy future ... done
[17:46:36.786] run() for ‘MulticoreFuture’ ... done
[17:46:36.786] result() for MulticoreFuture ...
[17:46:36.786] plan(): Setting new future strategy stack:
[17:46:36.787] result() for MulticoreFuture ... done
[17:46:36.787] result() for MulticoreFuture ...
[17:46:36.787] result() for MulticoreFuture ... done
[17:46:36.787] result() for MulticoreFuture ...
[17:46:36.787] List of future strategies:
[17:46:36.787] 1. sequential:
[17:46:36.787]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.787]    - tweaked: FALSE
[17:46:36.787]    - call: NULL
[17:46:36.788] plan(): nbrOfWorkers() = 1
[17:46:36.790] plan(): Setting new future strategy stack:
[17:46:36.790] List of future strategies:
[17:46:36.790] 1. multicore:
[17:46:36.790]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:36.790]    - tweaked: FALSE
[17:46:36.790]    - call: plan(strategy)
[17:46:36.791] result() for MulticoreFuture ...
[17:46:36.791] result() for MulticoreFuture ... done
[17:46:36.791] signalConditions() ...
[17:46:36.791]  - include = ‘immediateCondition’
[17:46:36.792]  - exclude = 
[17:46:36.792]  - resignal = FALSE
[17:46:36.792]  - Number of conditions: 1
[17:46:36.792] signalConditions() ... done
[17:46:36.792] result() for MulticoreFuture ... done
[17:46:36.792] result() for MulticoreFuture ...
[17:46:36.793] result() for MulticoreFuture ... done
[17:46:36.793] signalConditions() ...
[17:46:36.793]  - include = ‘immediateCondition’
[17:46:36.793]  - exclude = 
[17:46:36.793]  - resignal = FALSE
[17:46:36.793]  - Number of conditions: 1
[17:46:36.794] signalConditions() ... done
[17:46:36.794] Future state: ‘finished’
[17:46:36.794] result() for MulticoreFuture ...
[17:46:36.794] result() for MulticoreFuture ... done
[17:46:36.794] signalConditions() ...
[17:46:36.795]  - include = ‘condition’
[17:46:36.795]  - exclude = ‘immediateCondition’
[17:46:36.795]  - resignal = TRUE
[17:46:36.795]  - Number of conditions: 1
[17:46:36.795] plan(): nbrOfWorkers() = 2
[17:46:36.795]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:36.795] signalConditions() ... done
[17:46:36.796] result() for MulticoreFuture ...
[17:46:36.797] result() for MulticoreFuture ...
[17:46:36.797] result() for MulticoreFuture ... done
[17:46:36.797] result() for MulticoreFuture ... done
[17:46:36.797] result() for MulticoreFuture ...
[17:46:36.797] result() for MulticoreFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[17:46:36.798] result() for MulticoreFuture ...
[17:46:36.798] result() for MulticoreFuture ... done
[17:46:36.798] result() for MulticoreFuture ...
[17:46:36.798] result() for MulticoreFuture ... done
[17:46:36.798] signalConditions() ...
[17:46:36.798]  - include = ‘immediateCondition’
[17:46:36.798]  - exclude = 
[17:46:36.798]  - resignal = FALSE
[17:46:36.799]  - Number of conditions: 1
[17:46:36.799] signalConditions() ... done
[17:46:36.799] Future state: ‘finished’
[17:46:36.799] result() for MulticoreFuture ...
[17:46:36.799] result() for MulticoreFuture ... done
[17:46:36.799] signalConditions() ...
[17:46:36.799]  - include = ‘condition’
[17:46:36.799]  - exclude = ‘immediateCondition’
[17:46:36.799]  - resignal = TRUE
[17:46:36.800]  - Number of conditions: 1
[17:46:36.800]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:36.800] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[17:46:36.800] result() for MulticoreFuture ...
[17:46:36.800] result() for MulticoreFuture ... done
[17:46:36.800] result() for MulticoreFuture ...
[17:46:36.801] result() for MulticoreFuture ... done
[17:46:36.801] signalConditions() ...
[17:46:36.803]  - include = ‘immediateCondition’
[17:46:36.804]  - exclude = 
[17:46:36.804]  - resignal = FALSE
[17:46:36.804]  - Number of conditions: 1
[17:46:36.804] signalConditions() ... done
[17:46:36.804] Future state: ‘finished’
[17:46:36.804] result() for MulticoreFuture ...
[17:46:36.804] result() for MulticoreFuture ... done
[17:46:36.804] signalConditions() ...
[17:46:36.805]  - include = ‘condition’
[17:46:36.805]  - exclude = ‘immediateCondition’
[17:46:36.805]  - resignal = TRUE
[17:46:36.805]  - Number of conditions: 1
[17:46:36.805]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:36.805] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[17:46:36.806] getGlobalsAndPackages() ...
[17:46:36.806] Searching for globals...
[17:46:36.808] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[17:46:36.809] Searching for globals ... DONE
[17:46:36.809] Resolving globals: FALSE
[17:46:36.809] 
[17:46:36.809] 
[17:46:36.809] getGlobalsAndPackages() ... DONE
[17:46:36.810] run() for ‘Future’ ...
[17:46:36.810] - state: ‘created’
[17:46:36.810] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:36.814] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:36.815] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:36.815]   - Field: ‘label’
[17:46:36.815]   - Field: ‘local’
[17:46:36.815]   - Field: ‘owner’
[17:46:36.815]   - Field: ‘envir’
[17:46:36.815]   - Field: ‘workers’
[17:46:36.815]   - Field: ‘packages’
[17:46:36.816]   - Field: ‘gc’
[17:46:36.816]   - Field: ‘job’
[17:46:36.816]   - Field: ‘conditions’
[17:46:36.816]   - Field: ‘expr’
[17:46:36.816]   - Field: ‘uuid’
[17:46:36.816]   - Field: ‘seed’
[17:46:36.816]   - Field: ‘version’
[17:46:36.817]   - Field: ‘result’
[17:46:36.817]   - Field: ‘asynchronous’
[17:46:36.817]   - Field: ‘calls’
[17:46:36.817]   - Field: ‘globals’
[17:46:36.817]   - Field: ‘stdout’
[17:46:36.817]   - Field: ‘earlySignal’
[17:46:36.817]   - Field: ‘lazy’
[17:46:36.817]   - Field: ‘state’
[17:46:36.817] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:36.818] - Launch lazy future ...
[17:46:36.818] Packages needed by the future expression (n = 0): <none>
[17:46:36.818] Packages needed by future strategies (n = 0): <none>
[17:46:36.819] {
[17:46:36.819]     {
[17:46:36.819]         {
[17:46:36.819]             ...future.startTime <- base::Sys.time()
[17:46:36.819]             {
[17:46:36.819]                 {
[17:46:36.819]                   {
[17:46:36.819]                     {
[17:46:36.819]                       base::local({
[17:46:36.819]                         has_future <- base::requireNamespace("future", 
[17:46:36.819]                           quietly = TRUE)
[17:46:36.819]                         if (has_future) {
[17:46:36.819]                           ns <- base::getNamespace("future")
[17:46:36.819]                           version <- ns[[".package"]][["version"]]
[17:46:36.819]                           if (is.null(version)) 
[17:46:36.819]                             version <- utils::packageVersion("future")
[17:46:36.819]                         }
[17:46:36.819]                         else {
[17:46:36.819]                           version <- NULL
[17:46:36.819]                         }
[17:46:36.819]                         if (!has_future || version < "1.8.0") {
[17:46:36.819]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.819]                             "", base::R.version$version.string), 
[17:46:36.819]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:36.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.819]                               "release", "version")], collapse = " "), 
[17:46:36.819]                             hostname = base::Sys.info()[["nodename"]])
[17:46:36.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.819]                             info)
[17:46:36.819]                           info <- base::paste(info, collapse = "; ")
[17:46:36.819]                           if (!has_future) {
[17:46:36.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.819]                               info)
[17:46:36.819]                           }
[17:46:36.819]                           else {
[17:46:36.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.819]                               info, version)
[17:46:36.819]                           }
[17:46:36.819]                           base::stop(msg)
[17:46:36.819]                         }
[17:46:36.819]                       })
[17:46:36.819]                     }
[17:46:36.819]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:36.819]                     base::options(mc.cores = 1L)
[17:46:36.819]                   }
[17:46:36.819]                   ...future.strategy.old <- future::plan("list")
[17:46:36.819]                   options(future.plan = NULL)
[17:46:36.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.819]                 }
[17:46:36.819]                 ...future.workdir <- getwd()
[17:46:36.819]             }
[17:46:36.819]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.819]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.819]         }
[17:46:36.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.819]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.819]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.819]             base::names(...future.oldOptions))
[17:46:36.819]     }
[17:46:36.819]     if (FALSE) {
[17:46:36.819]     }
[17:46:36.819]     else {
[17:46:36.819]         if (TRUE) {
[17:46:36.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.819]                 open = "w")
[17:46:36.819]         }
[17:46:36.819]         else {
[17:46:36.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.819]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.819]         }
[17:46:36.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.819]             base::sink(type = "output", split = FALSE)
[17:46:36.819]             base::close(...future.stdout)
[17:46:36.819]         }, add = TRUE)
[17:46:36.819]     }
[17:46:36.819]     ...future.frame <- base::sys.nframe()
[17:46:36.819]     ...future.conditions <- base::list()
[17:46:36.819]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.819]     if (FALSE) {
[17:46:36.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.819]     }
[17:46:36.819]     ...future.result <- base::tryCatch({
[17:46:36.819]         base::withCallingHandlers({
[17:46:36.819]             ...future.value <- base::withVisible(base::local({
[17:46:36.819]                 withCallingHandlers({
[17:46:36.819]                   {
[17:46:36.819]                     cat("Processing: ")
[17:46:36.819]                     for (ii in 1:10) {
[17:46:36.819]                       cat(".")
[17:46:36.819]                     }
[17:46:36.819]                     cat(" [100%]\n")
[17:46:36.819]                     4
[17:46:36.819]                   }
[17:46:36.819]                 }, immediateCondition = function(cond) {
[17:46:36.819]                   save_rds <- function (object, pathname, ...) 
[17:46:36.819]                   {
[17:46:36.819]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:36.819]                     if (file_test("-f", pathname_tmp)) {
[17:46:36.819]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.819]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:36.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.819]                         fi_tmp[["mtime"]])
[17:46:36.819]                     }
[17:46:36.819]                     tryCatch({
[17:46:36.819]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:36.819]                     }, error = function(ex) {
[17:46:36.819]                       msg <- conditionMessage(ex)
[17:46:36.819]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.819]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:36.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.819]                         fi_tmp[["mtime"]], msg)
[17:46:36.819]                       ex$message <- msg
[17:46:36.819]                       stop(ex)
[17:46:36.819]                     })
[17:46:36.819]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:36.819]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:36.819]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:36.819]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.819]                       fi <- file.info(pathname)
[17:46:36.819]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:36.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.819]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:36.819]                         fi[["size"]], fi[["mtime"]])
[17:46:36.819]                       stop(msg)
[17:46:36.819]                     }
[17:46:36.819]                     invisible(pathname)
[17:46:36.819]                   }
[17:46:36.819]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:36.819]                     rootPath = tempdir()) 
[17:46:36.819]                   {
[17:46:36.819]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:36.819]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:36.819]                       tmpdir = path, fileext = ".rds")
[17:46:36.819]                     save_rds(obj, file)
[17:46:36.819]                   }
[17:46:36.819]                   saveImmediateCondition(cond, path = "/tmp/RtmpzxgiTZ/.future/immediateConditions")
[17:46:36.819]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.819]                   {
[17:46:36.819]                     inherits <- base::inherits
[17:46:36.819]                     invokeRestart <- base::invokeRestart
[17:46:36.819]                     is.null <- base::is.null
[17:46:36.819]                     muffled <- FALSE
[17:46:36.819]                     if (inherits(cond, "message")) {
[17:46:36.819]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:36.819]                       if (muffled) 
[17:46:36.819]                         invokeRestart("muffleMessage")
[17:46:36.819]                     }
[17:46:36.819]                     else if (inherits(cond, "warning")) {
[17:46:36.819]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:36.819]                       if (muffled) 
[17:46:36.819]                         invokeRestart("muffleWarning")
[17:46:36.819]                     }
[17:46:36.819]                     else if (inherits(cond, "condition")) {
[17:46:36.819]                       if (!is.null(pattern)) {
[17:46:36.819]                         computeRestarts <- base::computeRestarts
[17:46:36.819]                         grepl <- base::grepl
[17:46:36.819]                         restarts <- computeRestarts(cond)
[17:46:36.819]                         for (restart in restarts) {
[17:46:36.819]                           name <- restart$name
[17:46:36.819]                           if (is.null(name)) 
[17:46:36.819]                             next
[17:46:36.819]                           if (!grepl(pattern, name)) 
[17:46:36.819]                             next
[17:46:36.819]                           invokeRestart(restart)
[17:46:36.819]                           muffled <- TRUE
[17:46:36.819]                           break
[17:46:36.819]                         }
[17:46:36.819]                       }
[17:46:36.819]                     }
[17:46:36.819]                     invisible(muffled)
[17:46:36.819]                   }
[17:46:36.819]                   muffleCondition(cond)
[17:46:36.819]                 })
[17:46:36.819]             }))
[17:46:36.819]             future::FutureResult(value = ...future.value$value, 
[17:46:36.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.819]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.819]                     ...future.globalenv.names))
[17:46:36.819]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.819]         }, condition = base::local({
[17:46:36.819]             c <- base::c
[17:46:36.819]             inherits <- base::inherits
[17:46:36.819]             invokeRestart <- base::invokeRestart
[17:46:36.819]             length <- base::length
[17:46:36.819]             list <- base::list
[17:46:36.819]             seq.int <- base::seq.int
[17:46:36.819]             signalCondition <- base::signalCondition
[17:46:36.819]             sys.calls <- base::sys.calls
[17:46:36.819]             `[[` <- base::`[[`
[17:46:36.819]             `+` <- base::`+`
[17:46:36.819]             `<<-` <- base::`<<-`
[17:46:36.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.819]                   3L)]
[17:46:36.819]             }
[17:46:36.819]             function(cond) {
[17:46:36.819]                 is_error <- inherits(cond, "error")
[17:46:36.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.819]                   NULL)
[17:46:36.819]                 if (is_error) {
[17:46:36.819]                   sessionInformation <- function() {
[17:46:36.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.819]                       search = base::search(), system = base::Sys.info())
[17:46:36.819]                   }
[17:46:36.819]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.819]                     cond$call), session = sessionInformation(), 
[17:46:36.819]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.819]                   signalCondition(cond)
[17:46:36.819]                 }
[17:46:36.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.819]                 "immediateCondition"))) {
[17:46:36.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.819]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.819]                   if (TRUE && !signal) {
[17:46:36.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.819]                     {
[17:46:36.819]                       inherits <- base::inherits
[17:46:36.819]                       invokeRestart <- base::invokeRestart
[17:46:36.819]                       is.null <- base::is.null
[17:46:36.819]                       muffled <- FALSE
[17:46:36.819]                       if (inherits(cond, "message")) {
[17:46:36.819]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.819]                         if (muffled) 
[17:46:36.819]                           invokeRestart("muffleMessage")
[17:46:36.819]                       }
[17:46:36.819]                       else if (inherits(cond, "warning")) {
[17:46:36.819]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.819]                         if (muffled) 
[17:46:36.819]                           invokeRestart("muffleWarning")
[17:46:36.819]                       }
[17:46:36.819]                       else if (inherits(cond, "condition")) {
[17:46:36.819]                         if (!is.null(pattern)) {
[17:46:36.819]                           computeRestarts <- base::computeRestarts
[17:46:36.819]                           grepl <- base::grepl
[17:46:36.819]                           restarts <- computeRestarts(cond)
[17:46:36.819]                           for (restart in restarts) {
[17:46:36.819]                             name <- restart$name
[17:46:36.819]                             if (is.null(name)) 
[17:46:36.819]                               next
[17:46:36.819]                             if (!grepl(pattern, name)) 
[17:46:36.819]                               next
[17:46:36.819]                             invokeRestart(restart)
[17:46:36.819]                             muffled <- TRUE
[17:46:36.819]                             break
[17:46:36.819]                           }
[17:46:36.819]                         }
[17:46:36.819]                       }
[17:46:36.819]                       invisible(muffled)
[17:46:36.819]                     }
[17:46:36.819]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.819]                   }
[17:46:36.819]                 }
[17:46:36.819]                 else {
[17:46:36.819]                   if (TRUE) {
[17:46:36.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.819]                     {
[17:46:36.819]                       inherits <- base::inherits
[17:46:36.819]                       invokeRestart <- base::invokeRestart
[17:46:36.819]                       is.null <- base::is.null
[17:46:36.819]                       muffled <- FALSE
[17:46:36.819]                       if (inherits(cond, "message")) {
[17:46:36.819]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.819]                         if (muffled) 
[17:46:36.819]                           invokeRestart("muffleMessage")
[17:46:36.819]                       }
[17:46:36.819]                       else if (inherits(cond, "warning")) {
[17:46:36.819]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.819]                         if (muffled) 
[17:46:36.819]                           invokeRestart("muffleWarning")
[17:46:36.819]                       }
[17:46:36.819]                       else if (inherits(cond, "condition")) {
[17:46:36.819]                         if (!is.null(pattern)) {
[17:46:36.819]                           computeRestarts <- base::computeRestarts
[17:46:36.819]                           grepl <- base::grepl
[17:46:36.819]                           restarts <- computeRestarts(cond)
[17:46:36.819]                           for (restart in restarts) {
[17:46:36.819]                             name <- restart$name
[17:46:36.819]                             if (is.null(name)) 
[17:46:36.819]                               next
[17:46:36.819]                             if (!grepl(pattern, name)) 
[17:46:36.819]                               next
[17:46:36.819]                             invokeRestart(restart)
[17:46:36.819]                             muffled <- TRUE
[17:46:36.819]                             break
[17:46:36.819]                           }
[17:46:36.819]                         }
[17:46:36.819]                       }
[17:46:36.819]                       invisible(muffled)
[17:46:36.819]                     }
[17:46:36.819]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.819]                   }
[17:46:36.819]                 }
[17:46:36.819]             }
[17:46:36.819]         }))
[17:46:36.819]     }, error = function(ex) {
[17:46:36.819]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.819]                 ...future.rng), started = ...future.startTime, 
[17:46:36.819]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.819]             version = "1.8"), class = "FutureResult")
[17:46:36.819]     }, finally = {
[17:46:36.819]         if (!identical(...future.workdir, getwd())) 
[17:46:36.819]             setwd(...future.workdir)
[17:46:36.819]         {
[17:46:36.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.819]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.819]             }
[17:46:36.819]             base::options(...future.oldOptions)
[17:46:36.819]             if (.Platform$OS.type == "windows") {
[17:46:36.819]                 old_names <- names(...future.oldEnvVars)
[17:46:36.819]                 envs <- base::Sys.getenv()
[17:46:36.819]                 names <- names(envs)
[17:46:36.819]                 common <- intersect(names, old_names)
[17:46:36.819]                 added <- setdiff(names, old_names)
[17:46:36.819]                 removed <- setdiff(old_names, names)
[17:46:36.819]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.819]                   envs[common]]
[17:46:36.819]                 NAMES <- toupper(changed)
[17:46:36.819]                 args <- list()
[17:46:36.819]                 for (kk in seq_along(NAMES)) {
[17:46:36.819]                   name <- changed[[kk]]
[17:46:36.819]                   NAME <- NAMES[[kk]]
[17:46:36.819]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.819]                     next
[17:46:36.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.819]                 }
[17:46:36.819]                 NAMES <- toupper(added)
[17:46:36.819]                 for (kk in seq_along(NAMES)) {
[17:46:36.819]                   name <- added[[kk]]
[17:46:36.819]                   NAME <- NAMES[[kk]]
[17:46:36.819]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.819]                     next
[17:46:36.819]                   args[[name]] <- ""
[17:46:36.819]                 }
[17:46:36.819]                 NAMES <- toupper(removed)
[17:46:36.819]                 for (kk in seq_along(NAMES)) {
[17:46:36.819]                   name <- removed[[kk]]
[17:46:36.819]                   NAME <- NAMES[[kk]]
[17:46:36.819]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.819]                     next
[17:46:36.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.819]                 }
[17:46:36.819]                 if (length(args) > 0) 
[17:46:36.819]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.819]             }
[17:46:36.819]             else {
[17:46:36.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.819]             }
[17:46:36.819]             {
[17:46:36.819]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.819]                   0L) {
[17:46:36.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.819]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.819]                   base::options(opts)
[17:46:36.819]                 }
[17:46:36.819]                 {
[17:46:36.819]                   {
[17:46:36.819]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:36.819]                     NULL
[17:46:36.819]                   }
[17:46:36.819]                   options(future.plan = NULL)
[17:46:36.819]                   if (is.na(NA_character_)) 
[17:46:36.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.819]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.819]                     .init = FALSE)
[17:46:36.819]                 }
[17:46:36.819]             }
[17:46:36.819]         }
[17:46:36.819]     })
[17:46:36.819]     if (TRUE) {
[17:46:36.819]         base::sink(type = "output", split = FALSE)
[17:46:36.819]         if (TRUE) {
[17:46:36.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.819]         }
[17:46:36.819]         else {
[17:46:36.819]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.819]         }
[17:46:36.819]         base::close(...future.stdout)
[17:46:36.819]         ...future.stdout <- NULL
[17:46:36.819]     }
[17:46:36.819]     ...future.result$conditions <- ...future.conditions
[17:46:36.819]     ...future.result$finished <- base::Sys.time()
[17:46:36.819]     ...future.result
[17:46:36.819] }
[17:46:36.821] requestCore(): workers = 2
[17:46:36.823] MulticoreFuture started
[17:46:36.823] - Launch lazy future ... done
[17:46:36.823] run() for ‘MulticoreFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
[17:46:36.824] plan(): Setting new future strategy stack:
Warning in sprintf(...) : restarting interrupted promise evaluation
[17:46:36.824] result() for MulticoreFuture ...
[17:46:36.825] result() for MulticoreFuture ... done
[17:46:36.825] result() for MulticoreFuture ...
[17:46:36.825] result() for MulticoreFuture ... done
[17:46:36.824] List of future strategies:
[17:46:36.824] 1. sequential:
[17:46:36.824]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.824]    - tweaked: FALSE
[17:46:36.824]    - call: NULL
[17:46:36.825] signalConditions() ...
[17:46:36.825] plan(): nbrOfWorkers() = 1
[17:46:36.825]  - include = ‘immediateCondition’
[17:46:36.825]  - exclude = 
[17:46:36.825]  - resignal = FALSE
[17:46:36.826]  - Number of conditions: 1
[17:46:36.826] signalConditions() ... done
[17:46:36.826] Future state: ‘finished’
[17:46:36.826] result() for MulticoreFuture ...
[17:46:36.826] result() for MulticoreFuture ... done
[17:46:36.826] signalConditions() ...
[17:46:36.826]  - include = ‘condition’
[17:46:36.827]  - exclude = ‘immediateCondition’
[17:46:36.827]  - resignal = TRUE
[17:46:36.827]  - Number of conditions: 1
[17:46:36.827] plan(): Setting new future strategy stack:
[17:46:36.827]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:36.827] signalConditions() ... done
[17:46:36.827] List of future strategies:
[17:46:36.827] 1. multicore:
[17:46:36.827]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:36.827]    - tweaked: FALSE
[17:46:36.827]    - call: plan(strategy)
v3: <simpleError> (as expect)
[17:46:36.828] result() for MulticoreFuture ...
[17:46:36.832] plan(): nbrOfWorkers() = 2
[17:46:36.833] result() for MulticoreFuture ...
[17:46:36.833] result() for MulticoreFuture ... done
[17:46:36.833] result() for MulticoreFuture ... done
[17:46:36.833] result() for MulticoreFuture ...
[17:46:36.833] result() for MulticoreFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[17:46:36.834] getGlobalsAndPackages() ...
[17:46:36.834] Searching for globals...
[17:46:36.834] 
[17:46:36.835] Searching for globals ... DONE
[17:46:36.835] - globals: [0] <none>
[17:46:36.835] getGlobalsAndPackages() ... DONE
[17:46:36.835] run() for ‘Future’ ...
[17:46:36.835] - state: ‘created’
[17:46:36.835] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:36.839] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:36.839] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:36.840]   - Field: ‘label’
[17:46:36.840]   - Field: ‘local’
[17:46:36.840]   - Field: ‘owner’
[17:46:36.840]   - Field: ‘envir’
[17:46:36.840]   - Field: ‘workers’
[17:46:36.840]   - Field: ‘packages’
[17:46:36.840]   - Field: ‘gc’
[17:46:36.840]   - Field: ‘job’
[17:46:36.840]   - Field: ‘conditions’
[17:46:36.841]   - Field: ‘expr’
[17:46:36.841]   - Field: ‘uuid’
[17:46:36.841]   - Field: ‘seed’
[17:46:36.841]   - Field: ‘version’
[17:46:36.841]   - Field: ‘result’
[17:46:36.841]   - Field: ‘asynchronous’
[17:46:36.841]   - Field: ‘calls’
[17:46:36.841]   - Field: ‘globals’
[17:46:36.841]   - Field: ‘stdout’
[17:46:36.842]   - Field: ‘earlySignal’
[17:46:36.842]   - Field: ‘lazy’
[17:46:36.842]   - Field: ‘state’
[17:46:36.842] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:36.842] - Launch lazy future ...
[17:46:36.842] Packages needed by the future expression (n = 0): <none>
[17:46:36.842] Packages needed by future strategies (n = 0): <none>
[17:46:36.843] {
[17:46:36.843]     {
[17:46:36.843]         {
[17:46:36.843]             ...future.startTime <- base::Sys.time()
[17:46:36.843]             {
[17:46:36.843]                 {
[17:46:36.843]                   {
[17:46:36.843]                     {
[17:46:36.843]                       base::local({
[17:46:36.843]                         has_future <- base::requireNamespace("future", 
[17:46:36.843]                           quietly = TRUE)
[17:46:36.843]                         if (has_future) {
[17:46:36.843]                           ns <- base::getNamespace("future")
[17:46:36.843]                           version <- ns[[".package"]][["version"]]
[17:46:36.843]                           if (is.null(version)) 
[17:46:36.843]                             version <- utils::packageVersion("future")
[17:46:36.843]                         }
[17:46:36.843]                         else {
[17:46:36.843]                           version <- NULL
[17:46:36.843]                         }
[17:46:36.843]                         if (!has_future || version < "1.8.0") {
[17:46:36.843]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.843]                             "", base::R.version$version.string), 
[17:46:36.843]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:36.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.843]                               "release", "version")], collapse = " "), 
[17:46:36.843]                             hostname = base::Sys.info()[["nodename"]])
[17:46:36.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.843]                             info)
[17:46:36.843]                           info <- base::paste(info, collapse = "; ")
[17:46:36.843]                           if (!has_future) {
[17:46:36.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.843]                               info)
[17:46:36.843]                           }
[17:46:36.843]                           else {
[17:46:36.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.843]                               info, version)
[17:46:36.843]                           }
[17:46:36.843]                           base::stop(msg)
[17:46:36.843]                         }
[17:46:36.843]                       })
[17:46:36.843]                     }
[17:46:36.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:36.843]                     base::options(mc.cores = 1L)
[17:46:36.843]                   }
[17:46:36.843]                   ...future.strategy.old <- future::plan("list")
[17:46:36.843]                   options(future.plan = NULL)
[17:46:36.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.843]                 }
[17:46:36.843]                 ...future.workdir <- getwd()
[17:46:36.843]             }
[17:46:36.843]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.843]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.843]         }
[17:46:36.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.843]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.843]             base::names(...future.oldOptions))
[17:46:36.843]     }
[17:46:36.843]     if (FALSE) {
[17:46:36.843]     }
[17:46:36.843]     else {
[17:46:36.843]         if (TRUE) {
[17:46:36.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.843]                 open = "w")
[17:46:36.843]         }
[17:46:36.843]         else {
[17:46:36.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.843]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.843]         }
[17:46:36.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.843]             base::sink(type = "output", split = FALSE)
[17:46:36.843]             base::close(...future.stdout)
[17:46:36.843]         }, add = TRUE)
[17:46:36.843]     }
[17:46:36.843]     ...future.frame <- base::sys.nframe()
[17:46:36.843]     ...future.conditions <- base::list()
[17:46:36.843]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.843]     if (FALSE) {
[17:46:36.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.843]     }
[17:46:36.843]     ...future.result <- base::tryCatch({
[17:46:36.843]         base::withCallingHandlers({
[17:46:36.843]             ...future.value <- base::withVisible(base::local({
[17:46:36.843]                 withCallingHandlers({
[17:46:36.843]                   1
[17:46:36.843]                 }, immediateCondition = function(cond) {
[17:46:36.843]                   save_rds <- function (object, pathname, ...) 
[17:46:36.843]                   {
[17:46:36.843]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:36.843]                     if (file_test("-f", pathname_tmp)) {
[17:46:36.843]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.843]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:36.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.843]                         fi_tmp[["mtime"]])
[17:46:36.843]                     }
[17:46:36.843]                     tryCatch({
[17:46:36.843]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:36.843]                     }, error = function(ex) {
[17:46:36.843]                       msg <- conditionMessage(ex)
[17:46:36.843]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.843]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:36.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.843]                         fi_tmp[["mtime"]], msg)
[17:46:36.843]                       ex$message <- msg
[17:46:36.843]                       stop(ex)
[17:46:36.843]                     })
[17:46:36.843]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:36.843]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:36.843]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:36.843]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.843]                       fi <- file.info(pathname)
[17:46:36.843]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:36.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.843]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:36.843]                         fi[["size"]], fi[["mtime"]])
[17:46:36.843]                       stop(msg)
[17:46:36.843]                     }
[17:46:36.843]                     invisible(pathname)
[17:46:36.843]                   }
[17:46:36.843]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:36.843]                     rootPath = tempdir()) 
[17:46:36.843]                   {
[17:46:36.843]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:36.843]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:36.843]                       tmpdir = path, fileext = ".rds")
[17:46:36.843]                     save_rds(obj, file)
[17:46:36.843]                   }
[17:46:36.843]                   saveImmediateCondition(cond, path = "/tmp/RtmpzxgiTZ/.future/immediateConditions")
[17:46:36.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.843]                   {
[17:46:36.843]                     inherits <- base::inherits
[17:46:36.843]                     invokeRestart <- base::invokeRestart
[17:46:36.843]                     is.null <- base::is.null
[17:46:36.843]                     muffled <- FALSE
[17:46:36.843]                     if (inherits(cond, "message")) {
[17:46:36.843]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:36.843]                       if (muffled) 
[17:46:36.843]                         invokeRestart("muffleMessage")
[17:46:36.843]                     }
[17:46:36.843]                     else if (inherits(cond, "warning")) {
[17:46:36.843]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:36.843]                       if (muffled) 
[17:46:36.843]                         invokeRestart("muffleWarning")
[17:46:36.843]                     }
[17:46:36.843]                     else if (inherits(cond, "condition")) {
[17:46:36.843]                       if (!is.null(pattern)) {
[17:46:36.843]                         computeRestarts <- base::computeRestarts
[17:46:36.843]                         grepl <- base::grepl
[17:46:36.843]                         restarts <- computeRestarts(cond)
[17:46:36.843]                         for (restart in restarts) {
[17:46:36.843]                           name <- restart$name
[17:46:36.843]                           if (is.null(name)) 
[17:46:36.843]                             next
[17:46:36.843]                           if (!grepl(pattern, name)) 
[17:46:36.843]                             next
[17:46:36.843]                           invokeRestart(restart)
[17:46:36.843]                           muffled <- TRUE
[17:46:36.843]                           break
[17:46:36.843]                         }
[17:46:36.843]                       }
[17:46:36.843]                     }
[17:46:36.843]                     invisible(muffled)
[17:46:36.843]                   }
[17:46:36.843]                   muffleCondition(cond)
[17:46:36.843]                 })
[17:46:36.843]             }))
[17:46:36.843]             future::FutureResult(value = ...future.value$value, 
[17:46:36.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.843]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.843]                     ...future.globalenv.names))
[17:46:36.843]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.843]         }, condition = base::local({
[17:46:36.843]             c <- base::c
[17:46:36.843]             inherits <- base::inherits
[17:46:36.843]             invokeRestart <- base::invokeRestart
[17:46:36.843]             length <- base::length
[17:46:36.843]             list <- base::list
[17:46:36.843]             seq.int <- base::seq.int
[17:46:36.843]             signalCondition <- base::signalCondition
[17:46:36.843]             sys.calls <- base::sys.calls
[17:46:36.843]             `[[` <- base::`[[`
[17:46:36.843]             `+` <- base::`+`
[17:46:36.843]             `<<-` <- base::`<<-`
[17:46:36.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.843]                   3L)]
[17:46:36.843]             }
[17:46:36.843]             function(cond) {
[17:46:36.843]                 is_error <- inherits(cond, "error")
[17:46:36.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.843]                   NULL)
[17:46:36.843]                 if (is_error) {
[17:46:36.843]                   sessionInformation <- function() {
[17:46:36.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.843]                       search = base::search(), system = base::Sys.info())
[17:46:36.843]                   }
[17:46:36.843]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.843]                     cond$call), session = sessionInformation(), 
[17:46:36.843]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.843]                   signalCondition(cond)
[17:46:36.843]                 }
[17:46:36.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.843]                 "immediateCondition"))) {
[17:46:36.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.843]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.843]                   if (TRUE && !signal) {
[17:46:36.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.843]                     {
[17:46:36.843]                       inherits <- base::inherits
[17:46:36.843]                       invokeRestart <- base::invokeRestart
[17:46:36.843]                       is.null <- base::is.null
[17:46:36.843]                       muffled <- FALSE
[17:46:36.843]                       if (inherits(cond, "message")) {
[17:46:36.843]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.843]                         if (muffled) 
[17:46:36.843]                           invokeRestart("muffleMessage")
[17:46:36.843]                       }
[17:46:36.843]                       else if (inherits(cond, "warning")) {
[17:46:36.843]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.843]                         if (muffled) 
[17:46:36.843]                           invokeRestart("muffleWarning")
[17:46:36.843]                       }
[17:46:36.843]                       else if (inherits(cond, "condition")) {
[17:46:36.843]                         if (!is.null(pattern)) {
[17:46:36.843]                           computeRestarts <- base::computeRestarts
[17:46:36.843]                           grepl <- base::grepl
[17:46:36.843]                           restarts <- computeRestarts(cond)
[17:46:36.843]                           for (restart in restarts) {
[17:46:36.843]                             name <- restart$name
[17:46:36.843]                             if (is.null(name)) 
[17:46:36.843]                               next
[17:46:36.843]                             if (!grepl(pattern, name)) 
[17:46:36.843]                               next
[17:46:36.843]                             invokeRestart(restart)
[17:46:36.843]                             muffled <- TRUE
[17:46:36.843]                             break
[17:46:36.843]                           }
[17:46:36.843]                         }
[17:46:36.843]                       }
[17:46:36.843]                       invisible(muffled)
[17:46:36.843]                     }
[17:46:36.843]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.843]                   }
[17:46:36.843]                 }
[17:46:36.843]                 else {
[17:46:36.843]                   if (TRUE) {
[17:46:36.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.843]                     {
[17:46:36.843]                       inherits <- base::inherits
[17:46:36.843]                       invokeRestart <- base::invokeRestart
[17:46:36.843]                       is.null <- base::is.null
[17:46:36.843]                       muffled <- FALSE
[17:46:36.843]                       if (inherits(cond, "message")) {
[17:46:36.843]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.843]                         if (muffled) 
[17:46:36.843]                           invokeRestart("muffleMessage")
[17:46:36.843]                       }
[17:46:36.843]                       else if (inherits(cond, "warning")) {
[17:46:36.843]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.843]                         if (muffled) 
[17:46:36.843]                           invokeRestart("muffleWarning")
[17:46:36.843]                       }
[17:46:36.843]                       else if (inherits(cond, "condition")) {
[17:46:36.843]                         if (!is.null(pattern)) {
[17:46:36.843]                           computeRestarts <- base::computeRestarts
[17:46:36.843]                           grepl <- base::grepl
[17:46:36.843]                           restarts <- computeRestarts(cond)
[17:46:36.843]                           for (restart in restarts) {
[17:46:36.843]                             name <- restart$name
[17:46:36.843]                             if (is.null(name)) 
[17:46:36.843]                               next
[17:46:36.843]                             if (!grepl(pattern, name)) 
[17:46:36.843]                               next
[17:46:36.843]                             invokeRestart(restart)
[17:46:36.843]                             muffled <- TRUE
[17:46:36.843]                             break
[17:46:36.843]                           }
[17:46:36.843]                         }
[17:46:36.843]                       }
[17:46:36.843]                       invisible(muffled)
[17:46:36.843]                     }
[17:46:36.843]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.843]                   }
[17:46:36.843]                 }
[17:46:36.843]             }
[17:46:36.843]         }))
[17:46:36.843]     }, error = function(ex) {
[17:46:36.843]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.843]                 ...future.rng), started = ...future.startTime, 
[17:46:36.843]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.843]             version = "1.8"), class = "FutureResult")
[17:46:36.843]     }, finally = {
[17:46:36.843]         if (!identical(...future.workdir, getwd())) 
[17:46:36.843]             setwd(...future.workdir)
[17:46:36.843]         {
[17:46:36.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.843]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.843]             }
[17:46:36.843]             base::options(...future.oldOptions)
[17:46:36.843]             if (.Platform$OS.type == "windows") {
[17:46:36.843]                 old_names <- names(...future.oldEnvVars)
[17:46:36.843]                 envs <- base::Sys.getenv()
[17:46:36.843]                 names <- names(envs)
[17:46:36.843]                 common <- intersect(names, old_names)
[17:46:36.843]                 added <- setdiff(names, old_names)
[17:46:36.843]                 removed <- setdiff(old_names, names)
[17:46:36.843]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.843]                   envs[common]]
[17:46:36.843]                 NAMES <- toupper(changed)
[17:46:36.843]                 args <- list()
[17:46:36.843]                 for (kk in seq_along(NAMES)) {
[17:46:36.843]                   name <- changed[[kk]]
[17:46:36.843]                   NAME <- NAMES[[kk]]
[17:46:36.843]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.843]                     next
[17:46:36.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.843]                 }
[17:46:36.843]                 NAMES <- toupper(added)
[17:46:36.843]                 for (kk in seq_along(NAMES)) {
[17:46:36.843]                   name <- added[[kk]]
[17:46:36.843]                   NAME <- NAMES[[kk]]
[17:46:36.843]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.843]                     next
[17:46:36.843]                   args[[name]] <- ""
[17:46:36.843]                 }
[17:46:36.843]                 NAMES <- toupper(removed)
[17:46:36.843]                 for (kk in seq_along(NAMES)) {
[17:46:36.843]                   name <- removed[[kk]]
[17:46:36.843]                   NAME <- NAMES[[kk]]
[17:46:36.843]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.843]                     next
[17:46:36.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.843]                 }
[17:46:36.843]                 if (length(args) > 0) 
[17:46:36.843]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.843]             }
[17:46:36.843]             else {
[17:46:36.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.843]             }
[17:46:36.843]             {
[17:46:36.843]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.843]                   0L) {
[17:46:36.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.843]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.843]                   base::options(opts)
[17:46:36.843]                 }
[17:46:36.843]                 {
[17:46:36.843]                   {
[17:46:36.843]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:36.843]                     NULL
[17:46:36.843]                   }
[17:46:36.843]                   options(future.plan = NULL)
[17:46:36.843]                   if (is.na(NA_character_)) 
[17:46:36.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.843]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.843]                     .init = FALSE)
[17:46:36.843]                 }
[17:46:36.843]             }
[17:46:36.843]         }
[17:46:36.843]     })
[17:46:36.843]     if (TRUE) {
[17:46:36.843]         base::sink(type = "output", split = FALSE)
[17:46:36.843]         if (TRUE) {
[17:46:36.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.843]         }
[17:46:36.843]         else {
[17:46:36.843]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.843]         }
[17:46:36.843]         base::close(...future.stdout)
[17:46:36.843]         ...future.stdout <- NULL
[17:46:36.843]     }
[17:46:36.843]     ...future.result$conditions <- ...future.conditions
[17:46:36.843]     ...future.result$finished <- base::Sys.time()
[17:46:36.843]     ...future.result
[17:46:36.843] }
[17:46:36.845] requestCore(): workers = 2
[17:46:36.847] MulticoreFuture started
[17:46:36.848] - Launch lazy future ... done
[17:46:36.848] run() for ‘MulticoreFuture’ ... done
[17:46:36.848] plan(): Setting new future strategy stack:
[17:46:36.852] result() for MulticoreFuture ...
[17:46:36.848] List of future strategies:
[17:46:36.848] 1. sequential:
[17:46:36.848]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.848]    - tweaked: FALSE
[17:46:36.848]    - call: NULL
[17:46:36.853] plan(): nbrOfWorkers() = 1
[17:46:36.855] plan(): Setting new future strategy stack:
[17:46:36.855] List of future strategies:
[17:46:36.855] 1. multicore:
[17:46:36.855]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:36.855]    - tweaked: FALSE
[17:46:36.855]    - call: plan(strategy)
[17:46:36.860] plan(): nbrOfWorkers() = 2
[17:46:36.861] result() for MulticoreFuture ...
[17:46:36.861] result() for MulticoreFuture ... done
[17:46:36.861] result() for MulticoreFuture ... done
[17:46:36.862] result() for MulticoreFuture ...
[17:46:36.862] result() for MulticoreFuture ... done
c = 1
[17:46:36.862] getGlobalsAndPackages() ...
[17:46:36.862] Searching for globals...
[17:46:36.863] 
[17:46:36.863] Searching for globals ... DONE
[17:46:36.863] - globals: [0] <none>
[17:46:36.863] getGlobalsAndPackages() ... DONE
[17:46:36.864] run() for ‘Future’ ...
[17:46:36.864] - state: ‘created’
[17:46:36.864] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:36.868] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:36.868] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:36.868]   - Field: ‘label’
[17:46:36.868]   - Field: ‘local’
[17:46:36.868]   - Field: ‘owner’
[17:46:36.869]   - Field: ‘envir’
[17:46:36.869]   - Field: ‘workers’
[17:46:36.869]   - Field: ‘packages’
[17:46:36.869]   - Field: ‘gc’
[17:46:36.869]   - Field: ‘job’
[17:46:36.869]   - Field: ‘conditions’
[17:46:36.869]   - Field: ‘expr’
[17:46:36.869]   - Field: ‘uuid’
[17:46:36.870]   - Field: ‘seed’
[17:46:36.870]   - Field: ‘version’
[17:46:36.870]   - Field: ‘result’
[17:46:36.870]   - Field: ‘asynchronous’
[17:46:36.870]   - Field: ‘calls’
[17:46:36.870]   - Field: ‘globals’
[17:46:36.870]   - Field: ‘stdout’
[17:46:36.870]   - Field: ‘earlySignal’
[17:46:36.870]   - Field: ‘lazy’
[17:46:36.871]   - Field: ‘state’
[17:46:36.871] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:36.871] - Launch lazy future ...
[17:46:36.871] Packages needed by the future expression (n = 0): <none>
[17:46:36.871] Packages needed by future strategies (n = 0): <none>
[17:46:36.872] {
[17:46:36.872]     {
[17:46:36.872]         {
[17:46:36.872]             ...future.startTime <- base::Sys.time()
[17:46:36.872]             {
[17:46:36.872]                 {
[17:46:36.872]                   {
[17:46:36.872]                     {
[17:46:36.872]                       base::local({
[17:46:36.872]                         has_future <- base::requireNamespace("future", 
[17:46:36.872]                           quietly = TRUE)
[17:46:36.872]                         if (has_future) {
[17:46:36.872]                           ns <- base::getNamespace("future")
[17:46:36.872]                           version <- ns[[".package"]][["version"]]
[17:46:36.872]                           if (is.null(version)) 
[17:46:36.872]                             version <- utils::packageVersion("future")
[17:46:36.872]                         }
[17:46:36.872]                         else {
[17:46:36.872]                           version <- NULL
[17:46:36.872]                         }
[17:46:36.872]                         if (!has_future || version < "1.8.0") {
[17:46:36.872]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.872]                             "", base::R.version$version.string), 
[17:46:36.872]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:36.872]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.872]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.872]                               "release", "version")], collapse = " "), 
[17:46:36.872]                             hostname = base::Sys.info()[["nodename"]])
[17:46:36.872]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.872]                             info)
[17:46:36.872]                           info <- base::paste(info, collapse = "; ")
[17:46:36.872]                           if (!has_future) {
[17:46:36.872]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.872]                               info)
[17:46:36.872]                           }
[17:46:36.872]                           else {
[17:46:36.872]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.872]                               info, version)
[17:46:36.872]                           }
[17:46:36.872]                           base::stop(msg)
[17:46:36.872]                         }
[17:46:36.872]                       })
[17:46:36.872]                     }
[17:46:36.872]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:36.872]                     base::options(mc.cores = 1L)
[17:46:36.872]                   }
[17:46:36.872]                   ...future.strategy.old <- future::plan("list")
[17:46:36.872]                   options(future.plan = NULL)
[17:46:36.872]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.872]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.872]                 }
[17:46:36.872]                 ...future.workdir <- getwd()
[17:46:36.872]             }
[17:46:36.872]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.872]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.872]         }
[17:46:36.872]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.872]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.872]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.872]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.872]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.872]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.872]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.872]             base::names(...future.oldOptions))
[17:46:36.872]     }
[17:46:36.872]     if (FALSE) {
[17:46:36.872]     }
[17:46:36.872]     else {
[17:46:36.872]         if (TRUE) {
[17:46:36.872]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.872]                 open = "w")
[17:46:36.872]         }
[17:46:36.872]         else {
[17:46:36.872]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.872]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.872]         }
[17:46:36.872]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.872]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.872]             base::sink(type = "output", split = FALSE)
[17:46:36.872]             base::close(...future.stdout)
[17:46:36.872]         }, add = TRUE)
[17:46:36.872]     }
[17:46:36.872]     ...future.frame <- base::sys.nframe()
[17:46:36.872]     ...future.conditions <- base::list()
[17:46:36.872]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.872]     if (FALSE) {
[17:46:36.872]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.872]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.872]     }
[17:46:36.872]     ...future.result <- base::tryCatch({
[17:46:36.872]         base::withCallingHandlers({
[17:46:36.872]             ...future.value <- base::withVisible(base::local({
[17:46:36.872]                 withCallingHandlers({
[17:46:36.872]                   1
[17:46:36.872]                 }, immediateCondition = function(cond) {
[17:46:36.872]                   save_rds <- function (object, pathname, ...) 
[17:46:36.872]                   {
[17:46:36.872]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:36.872]                     if (file_test("-f", pathname_tmp)) {
[17:46:36.872]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.872]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:36.872]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.872]                         fi_tmp[["mtime"]])
[17:46:36.872]                     }
[17:46:36.872]                     tryCatch({
[17:46:36.872]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:36.872]                     }, error = function(ex) {
[17:46:36.872]                       msg <- conditionMessage(ex)
[17:46:36.872]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.872]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:36.872]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.872]                         fi_tmp[["mtime"]], msg)
[17:46:36.872]                       ex$message <- msg
[17:46:36.872]                       stop(ex)
[17:46:36.872]                     })
[17:46:36.872]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:36.872]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:36.872]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:36.872]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.872]                       fi <- file.info(pathname)
[17:46:36.872]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:36.872]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.872]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:36.872]                         fi[["size"]], fi[["mtime"]])
[17:46:36.872]                       stop(msg)
[17:46:36.872]                     }
[17:46:36.872]                     invisible(pathname)
[17:46:36.872]                   }
[17:46:36.872]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:36.872]                     rootPath = tempdir()) 
[17:46:36.872]                   {
[17:46:36.872]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:36.872]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:36.872]                       tmpdir = path, fileext = ".rds")
[17:46:36.872]                     save_rds(obj, file)
[17:46:36.872]                   }
[17:46:36.872]                   saveImmediateCondition(cond, path = "/tmp/RtmpzxgiTZ/.future/immediateConditions")
[17:46:36.872]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.872]                   {
[17:46:36.872]                     inherits <- base::inherits
[17:46:36.872]                     invokeRestart <- base::invokeRestart
[17:46:36.872]                     is.null <- base::is.null
[17:46:36.872]                     muffled <- FALSE
[17:46:36.872]                     if (inherits(cond, "message")) {
[17:46:36.872]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:36.872]                       if (muffled) 
[17:46:36.872]                         invokeRestart("muffleMessage")
[17:46:36.872]                     }
[17:46:36.872]                     else if (inherits(cond, "warning")) {
[17:46:36.872]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:36.872]                       if (muffled) 
[17:46:36.872]                         invokeRestart("muffleWarning")
[17:46:36.872]                     }
[17:46:36.872]                     else if (inherits(cond, "condition")) {
[17:46:36.872]                       if (!is.null(pattern)) {
[17:46:36.872]                         computeRestarts <- base::computeRestarts
[17:46:36.872]                         grepl <- base::grepl
[17:46:36.872]                         restarts <- computeRestarts(cond)
[17:46:36.872]                         for (restart in restarts) {
[17:46:36.872]                           name <- restart$name
[17:46:36.872]                           if (is.null(name)) 
[17:46:36.872]                             next
[17:46:36.872]                           if (!grepl(pattern, name)) 
[17:46:36.872]                             next
[17:46:36.872]                           invokeRestart(restart)
[17:46:36.872]                           muffled <- TRUE
[17:46:36.872]                           break
[17:46:36.872]                         }
[17:46:36.872]                       }
[17:46:36.872]                     }
[17:46:36.872]                     invisible(muffled)
[17:46:36.872]                   }
[17:46:36.872]                   muffleCondition(cond)
[17:46:36.872]                 })
[17:46:36.872]             }))
[17:46:36.872]             future::FutureResult(value = ...future.value$value, 
[17:46:36.872]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.872]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.872]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.872]                     ...future.globalenv.names))
[17:46:36.872]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.872]         }, condition = base::local({
[17:46:36.872]             c <- base::c
[17:46:36.872]             inherits <- base::inherits
[17:46:36.872]             invokeRestart <- base::invokeRestart
[17:46:36.872]             length <- base::length
[17:46:36.872]             list <- base::list
[17:46:36.872]             seq.int <- base::seq.int
[17:46:36.872]             signalCondition <- base::signalCondition
[17:46:36.872]             sys.calls <- base::sys.calls
[17:46:36.872]             `[[` <- base::`[[`
[17:46:36.872]             `+` <- base::`+`
[17:46:36.872]             `<<-` <- base::`<<-`
[17:46:36.872]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.872]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.872]                   3L)]
[17:46:36.872]             }
[17:46:36.872]             function(cond) {
[17:46:36.872]                 is_error <- inherits(cond, "error")
[17:46:36.872]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.872]                   NULL)
[17:46:36.872]                 if (is_error) {
[17:46:36.872]                   sessionInformation <- function() {
[17:46:36.872]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.872]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.872]                       search = base::search(), system = base::Sys.info())
[17:46:36.872]                   }
[17:46:36.872]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.872]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.872]                     cond$call), session = sessionInformation(), 
[17:46:36.872]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.872]                   signalCondition(cond)
[17:46:36.872]                 }
[17:46:36.872]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.872]                 "immediateCondition"))) {
[17:46:36.872]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.872]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.872]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.872]                   if (TRUE && !signal) {
[17:46:36.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.872]                     {
[17:46:36.872]                       inherits <- base::inherits
[17:46:36.872]                       invokeRestart <- base::invokeRestart
[17:46:36.872]                       is.null <- base::is.null
[17:46:36.872]                       muffled <- FALSE
[17:46:36.872]                       if (inherits(cond, "message")) {
[17:46:36.872]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.872]                         if (muffled) 
[17:46:36.872]                           invokeRestart("muffleMessage")
[17:46:36.872]                       }
[17:46:36.872]                       else if (inherits(cond, "warning")) {
[17:46:36.872]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.872]                         if (muffled) 
[17:46:36.872]                           invokeRestart("muffleWarning")
[17:46:36.872]                       }
[17:46:36.872]                       else if (inherits(cond, "condition")) {
[17:46:36.872]                         if (!is.null(pattern)) {
[17:46:36.872]                           computeRestarts <- base::computeRestarts
[17:46:36.872]                           grepl <- base::grepl
[17:46:36.872]                           restarts <- computeRestarts(cond)
[17:46:36.872]                           for (restart in restarts) {
[17:46:36.872]                             name <- restart$name
[17:46:36.872]                             if (is.null(name)) 
[17:46:36.872]                               next
[17:46:36.872]                             if (!grepl(pattern, name)) 
[17:46:36.872]                               next
[17:46:36.872]                             invokeRestart(restart)
[17:46:36.872]                             muffled <- TRUE
[17:46:36.872]                             break
[17:46:36.872]                           }
[17:46:36.872]                         }
[17:46:36.872]                       }
[17:46:36.872]                       invisible(muffled)
[17:46:36.872]                     }
[17:46:36.872]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.872]                   }
[17:46:36.872]                 }
[17:46:36.872]                 else {
[17:46:36.872]                   if (TRUE) {
[17:46:36.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.872]                     {
[17:46:36.872]                       inherits <- base::inherits
[17:46:36.872]                       invokeRestart <- base::invokeRestart
[17:46:36.872]                       is.null <- base::is.null
[17:46:36.872]                       muffled <- FALSE
[17:46:36.872]                       if (inherits(cond, "message")) {
[17:46:36.872]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.872]                         if (muffled) 
[17:46:36.872]                           invokeRestart("muffleMessage")
[17:46:36.872]                       }
[17:46:36.872]                       else if (inherits(cond, "warning")) {
[17:46:36.872]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.872]                         if (muffled) 
[17:46:36.872]                           invokeRestart("muffleWarning")
[17:46:36.872]                       }
[17:46:36.872]                       else if (inherits(cond, "condition")) {
[17:46:36.872]                         if (!is.null(pattern)) {
[17:46:36.872]                           computeRestarts <- base::computeRestarts
[17:46:36.872]                           grepl <- base::grepl
[17:46:36.872]                           restarts <- computeRestarts(cond)
[17:46:36.872]                           for (restart in restarts) {
[17:46:36.872]                             name <- restart$name
[17:46:36.872]                             if (is.null(name)) 
[17:46:36.872]                               next
[17:46:36.872]                             if (!grepl(pattern, name)) 
[17:46:36.872]                               next
[17:46:36.872]                             invokeRestart(restart)
[17:46:36.872]                             muffled <- TRUE
[17:46:36.872]                             break
[17:46:36.872]                           }
[17:46:36.872]                         }
[17:46:36.872]                       }
[17:46:36.872]                       invisible(muffled)
[17:46:36.872]                     }
[17:46:36.872]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.872]                   }
[17:46:36.872]                 }
[17:46:36.872]             }
[17:46:36.872]         }))
[17:46:36.872]     }, error = function(ex) {
[17:46:36.872]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.872]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.872]                 ...future.rng), started = ...future.startTime, 
[17:46:36.872]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.872]             version = "1.8"), class = "FutureResult")
[17:46:36.872]     }, finally = {
[17:46:36.872]         if (!identical(...future.workdir, getwd())) 
[17:46:36.872]             setwd(...future.workdir)
[17:46:36.872]         {
[17:46:36.872]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.872]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.872]             }
[17:46:36.872]             base::options(...future.oldOptions)
[17:46:36.872]             if (.Platform$OS.type == "windows") {
[17:46:36.872]                 old_names <- names(...future.oldEnvVars)
[17:46:36.872]                 envs <- base::Sys.getenv()
[17:46:36.872]                 names <- names(envs)
[17:46:36.872]                 common <- intersect(names, old_names)
[17:46:36.872]                 added <- setdiff(names, old_names)
[17:46:36.872]                 removed <- setdiff(old_names, names)
[17:46:36.872]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.872]                   envs[common]]
[17:46:36.872]                 NAMES <- toupper(changed)
[17:46:36.872]                 args <- list()
[17:46:36.872]                 for (kk in seq_along(NAMES)) {
[17:46:36.872]                   name <- changed[[kk]]
[17:46:36.872]                   NAME <- NAMES[[kk]]
[17:46:36.872]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.872]                     next
[17:46:36.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.872]                 }
[17:46:36.872]                 NAMES <- toupper(added)
[17:46:36.872]                 for (kk in seq_along(NAMES)) {
[17:46:36.872]                   name <- added[[kk]]
[17:46:36.872]                   NAME <- NAMES[[kk]]
[17:46:36.872]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.872]                     next
[17:46:36.872]                   args[[name]] <- ""
[17:46:36.872]                 }
[17:46:36.872]                 NAMES <- toupper(removed)
[17:46:36.872]                 for (kk in seq_along(NAMES)) {
[17:46:36.872]                   name <- removed[[kk]]
[17:46:36.872]                   NAME <- NAMES[[kk]]
[17:46:36.872]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.872]                     next
[17:46:36.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.872]                 }
[17:46:36.872]                 if (length(args) > 0) 
[17:46:36.872]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.872]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.872]             }
[17:46:36.872]             else {
[17:46:36.872]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.872]             }
[17:46:36.872]             {
[17:46:36.872]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.872]                   0L) {
[17:46:36.872]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.872]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.872]                   base::options(opts)
[17:46:36.872]                 }
[17:46:36.872]                 {
[17:46:36.872]                   {
[17:46:36.872]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:36.872]                     NULL
[17:46:36.872]                   }
[17:46:36.872]                   options(future.plan = NULL)
[17:46:36.872]                   if (is.na(NA_character_)) 
[17:46:36.872]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.872]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.872]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.872]                     .init = FALSE)
[17:46:36.872]                 }
[17:46:36.872]             }
[17:46:36.872]         }
[17:46:36.872]     })
[17:46:36.872]     if (TRUE) {
[17:46:36.872]         base::sink(type = "output", split = FALSE)
[17:46:36.872]         if (TRUE) {
[17:46:36.872]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.872]         }
[17:46:36.872]         else {
[17:46:36.872]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.872]         }
[17:46:36.872]         base::close(...future.stdout)
[17:46:36.872]         ...future.stdout <- NULL
[17:46:36.872]     }
[17:46:36.872]     ...future.result$conditions <- ...future.conditions
[17:46:36.872]     ...future.result$finished <- base::Sys.time()
[17:46:36.872]     ...future.result
[17:46:36.872] }
[17:46:36.874] requestCore(): workers = 2
[17:46:36.876] MulticoreFuture started
[17:46:36.876] - Launch lazy future ... done
[17:46:36.876] run() for ‘MulticoreFuture’ ... done
[17:46:36.877] result() for MulticoreFuture ...
[17:46:36.877] plan(): Setting new future strategy stack:
[17:46:36.877] List of future strategies:
[17:46:36.877] 1. sequential:
[17:46:36.877]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.877]    - tweaked: FALSE
[17:46:36.877]    - call: NULL
[17:46:36.878] plan(): nbrOfWorkers() = 1
[17:46:36.880] plan(): Setting new future strategy stack:
[17:46:36.880] List of future strategies:
[17:46:36.880] 1. multicore:
[17:46:36.880]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:36.880]    - tweaked: FALSE
[17:46:36.880]    - call: plan(strategy)
[17:46:36.885] plan(): nbrOfWorkers() = 2
[17:46:36.886] result() for MulticoreFuture ...
[17:46:36.886] result() for MulticoreFuture ... done
[17:46:36.886] result() for MulticoreFuture ... done
[17:46:36.886] result() for MulticoreFuture ...
[17:46:36.886] result() for MulticoreFuture ... done
d = 1
** Nested future assignments
[17:46:36.887] getGlobalsAndPackages() ...
[17:46:36.887] Searching for globals...
[17:46:36.892] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[17:46:36.892] Searching for globals ... DONE
[17:46:36.892] Resolving globals: FALSE
[17:46:36.893] 
[17:46:36.893] - packages: [1] ‘future’
[17:46:36.893] getGlobalsAndPackages() ... DONE
[17:46:36.893] run() for ‘Future’ ...
[17:46:36.894] - state: ‘created’
[17:46:36.894] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:36.898] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:36.898] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:36.898]   - Field: ‘label’
[17:46:36.898]   - Field: ‘local’
[17:46:36.898]   - Field: ‘owner’
[17:46:36.898]   - Field: ‘envir’
[17:46:36.899]   - Field: ‘workers’
[17:46:36.899]   - Field: ‘packages’
[17:46:36.899]   - Field: ‘gc’
[17:46:36.899]   - Field: ‘job’
[17:46:36.899]   - Field: ‘conditions’
[17:46:36.899]   - Field: ‘expr’
[17:46:36.899]   - Field: ‘uuid’
[17:46:36.899]   - Field: ‘seed’
[17:46:36.899]   - Field: ‘version’
[17:46:36.900]   - Field: ‘result’
[17:46:36.900]   - Field: ‘asynchronous’
[17:46:36.900]   - Field: ‘calls’
[17:46:36.900]   - Field: ‘globals’
[17:46:36.900]   - Field: ‘stdout’
[17:46:36.900]   - Field: ‘earlySignal’
[17:46:36.900]   - Field: ‘lazy’
[17:46:36.900]   - Field: ‘state’
[17:46:36.900] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:36.901] - Launch lazy future ...
[17:46:36.901] Packages needed by the future expression (n = 1): ‘future’
[17:46:36.901] Packages needed by future strategies (n = 0): <none>
[17:46:36.902] {
[17:46:36.902]     {
[17:46:36.902]         {
[17:46:36.902]             ...future.startTime <- base::Sys.time()
[17:46:36.902]             {
[17:46:36.902]                 {
[17:46:36.902]                   {
[17:46:36.902]                     {
[17:46:36.902]                       {
[17:46:36.902]                         base::local({
[17:46:36.902]                           has_future <- base::requireNamespace("future", 
[17:46:36.902]                             quietly = TRUE)
[17:46:36.902]                           if (has_future) {
[17:46:36.902]                             ns <- base::getNamespace("future")
[17:46:36.902]                             version <- ns[[".package"]][["version"]]
[17:46:36.902]                             if (is.null(version)) 
[17:46:36.902]                               version <- utils::packageVersion("future")
[17:46:36.902]                           }
[17:46:36.902]                           else {
[17:46:36.902]                             version <- NULL
[17:46:36.902]                           }
[17:46:36.902]                           if (!has_future || version < "1.8.0") {
[17:46:36.902]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.902]                               "", base::R.version$version.string), 
[17:46:36.902]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:36.902]                                 base::R.version$platform, 8 * 
[17:46:36.902]                                   base::.Machine$sizeof.pointer), 
[17:46:36.902]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.902]                                 "release", "version")], collapse = " "), 
[17:46:36.902]                               hostname = base::Sys.info()[["nodename"]])
[17:46:36.902]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.902]                               info)
[17:46:36.902]                             info <- base::paste(info, collapse = "; ")
[17:46:36.902]                             if (!has_future) {
[17:46:36.902]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.902]                                 info)
[17:46:36.902]                             }
[17:46:36.902]                             else {
[17:46:36.902]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.902]                                 info, version)
[17:46:36.902]                             }
[17:46:36.902]                             base::stop(msg)
[17:46:36.902]                           }
[17:46:36.902]                         })
[17:46:36.902]                       }
[17:46:36.902]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:36.902]                       base::options(mc.cores = 1L)
[17:46:36.902]                     }
[17:46:36.902]                     base::local({
[17:46:36.902]                       for (pkg in "future") {
[17:46:36.902]                         base::loadNamespace(pkg)
[17:46:36.902]                         base::library(pkg, character.only = TRUE)
[17:46:36.902]                       }
[17:46:36.902]                     })
[17:46:36.902]                   }
[17:46:36.902]                   ...future.strategy.old <- future::plan("list")
[17:46:36.902]                   options(future.plan = NULL)
[17:46:36.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.902]                 }
[17:46:36.902]                 ...future.workdir <- getwd()
[17:46:36.902]             }
[17:46:36.902]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.902]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.902]         }
[17:46:36.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.902]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.902]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.902]             base::names(...future.oldOptions))
[17:46:36.902]     }
[17:46:36.902]     if (FALSE) {
[17:46:36.902]     }
[17:46:36.902]     else {
[17:46:36.902]         if (TRUE) {
[17:46:36.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.902]                 open = "w")
[17:46:36.902]         }
[17:46:36.902]         else {
[17:46:36.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.902]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.902]         }
[17:46:36.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.902]             base::sink(type = "output", split = FALSE)
[17:46:36.902]             base::close(...future.stdout)
[17:46:36.902]         }, add = TRUE)
[17:46:36.902]     }
[17:46:36.902]     ...future.frame <- base::sys.nframe()
[17:46:36.902]     ...future.conditions <- base::list()
[17:46:36.902]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.902]     if (FALSE) {
[17:46:36.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.902]     }
[17:46:36.902]     ...future.result <- base::tryCatch({
[17:46:36.902]         base::withCallingHandlers({
[17:46:36.902]             ...future.value <- base::withVisible(base::local({
[17:46:36.902]                 withCallingHandlers({
[17:46:36.902]                   {
[17:46:36.902]                     b <- 1
[17:46:36.902]                     c %<-% 2
[17:46:36.902]                     d <- 3
[17:46:36.902]                     4 %->% e
[17:46:36.902]                     b + c + d + e
[17:46:36.902]                   }
[17:46:36.902]                 }, immediateCondition = function(cond) {
[17:46:36.902]                   save_rds <- function (object, pathname, ...) 
[17:46:36.902]                   {
[17:46:36.902]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:36.902]                     if (file_test("-f", pathname_tmp)) {
[17:46:36.902]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.902]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:36.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.902]                         fi_tmp[["mtime"]])
[17:46:36.902]                     }
[17:46:36.902]                     tryCatch({
[17:46:36.902]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:36.902]                     }, error = function(ex) {
[17:46:36.902]                       msg <- conditionMessage(ex)
[17:46:36.902]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.902]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:36.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.902]                         fi_tmp[["mtime"]], msg)
[17:46:36.902]                       ex$message <- msg
[17:46:36.902]                       stop(ex)
[17:46:36.902]                     })
[17:46:36.902]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:36.902]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:36.902]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:36.902]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.902]                       fi <- file.info(pathname)
[17:46:36.902]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:36.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.902]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:36.902]                         fi[["size"]], fi[["mtime"]])
[17:46:36.902]                       stop(msg)
[17:46:36.902]                     }
[17:46:36.902]                     invisible(pathname)
[17:46:36.902]                   }
[17:46:36.902]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:36.902]                     rootPath = tempdir()) 
[17:46:36.902]                   {
[17:46:36.902]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:36.902]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:36.902]                       tmpdir = path, fileext = ".rds")
[17:46:36.902]                     save_rds(obj, file)
[17:46:36.902]                   }
[17:46:36.902]                   saveImmediateCondition(cond, path = "/tmp/RtmpzxgiTZ/.future/immediateConditions")
[17:46:36.902]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.902]                   {
[17:46:36.902]                     inherits <- base::inherits
[17:46:36.902]                     invokeRestart <- base::invokeRestart
[17:46:36.902]                     is.null <- base::is.null
[17:46:36.902]                     muffled <- FALSE
[17:46:36.902]                     if (inherits(cond, "message")) {
[17:46:36.902]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:36.902]                       if (muffled) 
[17:46:36.902]                         invokeRestart("muffleMessage")
[17:46:36.902]                     }
[17:46:36.902]                     else if (inherits(cond, "warning")) {
[17:46:36.902]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:36.902]                       if (muffled) 
[17:46:36.902]                         invokeRestart("muffleWarning")
[17:46:36.902]                     }
[17:46:36.902]                     else if (inherits(cond, "condition")) {
[17:46:36.902]                       if (!is.null(pattern)) {
[17:46:36.902]                         computeRestarts <- base::computeRestarts
[17:46:36.902]                         grepl <- base::grepl
[17:46:36.902]                         restarts <- computeRestarts(cond)
[17:46:36.902]                         for (restart in restarts) {
[17:46:36.902]                           name <- restart$name
[17:46:36.902]                           if (is.null(name)) 
[17:46:36.902]                             next
[17:46:36.902]                           if (!grepl(pattern, name)) 
[17:46:36.902]                             next
[17:46:36.902]                           invokeRestart(restart)
[17:46:36.902]                           muffled <- TRUE
[17:46:36.902]                           break
[17:46:36.902]                         }
[17:46:36.902]                       }
[17:46:36.902]                     }
[17:46:36.902]                     invisible(muffled)
[17:46:36.902]                   }
[17:46:36.902]                   muffleCondition(cond)
[17:46:36.902]                 })
[17:46:36.902]             }))
[17:46:36.902]             future::FutureResult(value = ...future.value$value, 
[17:46:36.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.902]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.902]                     ...future.globalenv.names))
[17:46:36.902]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.902]         }, condition = base::local({
[17:46:36.902]             c <- base::c
[17:46:36.902]             inherits <- base::inherits
[17:46:36.902]             invokeRestart <- base::invokeRestart
[17:46:36.902]             length <- base::length
[17:46:36.902]             list <- base::list
[17:46:36.902]             seq.int <- base::seq.int
[17:46:36.902]             signalCondition <- base::signalCondition
[17:46:36.902]             sys.calls <- base::sys.calls
[17:46:36.902]             `[[` <- base::`[[`
[17:46:36.902]             `+` <- base::`+`
[17:46:36.902]             `<<-` <- base::`<<-`
[17:46:36.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.902]                   3L)]
[17:46:36.902]             }
[17:46:36.902]             function(cond) {
[17:46:36.902]                 is_error <- inherits(cond, "error")
[17:46:36.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.902]                   NULL)
[17:46:36.902]                 if (is_error) {
[17:46:36.902]                   sessionInformation <- function() {
[17:46:36.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.902]                       search = base::search(), system = base::Sys.info())
[17:46:36.902]                   }
[17:46:36.902]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.902]                     cond$call), session = sessionInformation(), 
[17:46:36.902]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.902]                   signalCondition(cond)
[17:46:36.902]                 }
[17:46:36.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.902]                 "immediateCondition"))) {
[17:46:36.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.902]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.902]                   if (TRUE && !signal) {
[17:46:36.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.902]                     {
[17:46:36.902]                       inherits <- base::inherits
[17:46:36.902]                       invokeRestart <- base::invokeRestart
[17:46:36.902]                       is.null <- base::is.null
[17:46:36.902]                       muffled <- FALSE
[17:46:36.902]                       if (inherits(cond, "message")) {
[17:46:36.902]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.902]                         if (muffled) 
[17:46:36.902]                           invokeRestart("muffleMessage")
[17:46:36.902]                       }
[17:46:36.902]                       else if (inherits(cond, "warning")) {
[17:46:36.902]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.902]                         if (muffled) 
[17:46:36.902]                           invokeRestart("muffleWarning")
[17:46:36.902]                       }
[17:46:36.902]                       else if (inherits(cond, "condition")) {
[17:46:36.902]                         if (!is.null(pattern)) {
[17:46:36.902]                           computeRestarts <- base::computeRestarts
[17:46:36.902]                           grepl <- base::grepl
[17:46:36.902]                           restarts <- computeRestarts(cond)
[17:46:36.902]                           for (restart in restarts) {
[17:46:36.902]                             name <- restart$name
[17:46:36.902]                             if (is.null(name)) 
[17:46:36.902]                               next
[17:46:36.902]                             if (!grepl(pattern, name)) 
[17:46:36.902]                               next
[17:46:36.902]                             invokeRestart(restart)
[17:46:36.902]                             muffled <- TRUE
[17:46:36.902]                             break
[17:46:36.902]                           }
[17:46:36.902]                         }
[17:46:36.902]                       }
[17:46:36.902]                       invisible(muffled)
[17:46:36.902]                     }
[17:46:36.902]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.902]                   }
[17:46:36.902]                 }
[17:46:36.902]                 else {
[17:46:36.902]                   if (TRUE) {
[17:46:36.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.902]                     {
[17:46:36.902]                       inherits <- base::inherits
[17:46:36.902]                       invokeRestart <- base::invokeRestart
[17:46:36.902]                       is.null <- base::is.null
[17:46:36.902]                       muffled <- FALSE
[17:46:36.902]                       if (inherits(cond, "message")) {
[17:46:36.902]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.902]                         if (muffled) 
[17:46:36.902]                           invokeRestart("muffleMessage")
[17:46:36.902]                       }
[17:46:36.902]                       else if (inherits(cond, "warning")) {
[17:46:36.902]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.902]                         if (muffled) 
[17:46:36.902]                           invokeRestart("muffleWarning")
[17:46:36.902]                       }
[17:46:36.902]                       else if (inherits(cond, "condition")) {
[17:46:36.902]                         if (!is.null(pattern)) {
[17:46:36.902]                           computeRestarts <- base::computeRestarts
[17:46:36.902]                           grepl <- base::grepl
[17:46:36.902]                           restarts <- computeRestarts(cond)
[17:46:36.902]                           for (restart in restarts) {
[17:46:36.902]                             name <- restart$name
[17:46:36.902]                             if (is.null(name)) 
[17:46:36.902]                               next
[17:46:36.902]                             if (!grepl(pattern, name)) 
[17:46:36.902]                               next
[17:46:36.902]                             invokeRestart(restart)
[17:46:36.902]                             muffled <- TRUE
[17:46:36.902]                             break
[17:46:36.902]                           }
[17:46:36.902]                         }
[17:46:36.902]                       }
[17:46:36.902]                       invisible(muffled)
[17:46:36.902]                     }
[17:46:36.902]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.902]                   }
[17:46:36.902]                 }
[17:46:36.902]             }
[17:46:36.902]         }))
[17:46:36.902]     }, error = function(ex) {
[17:46:36.902]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.902]                 ...future.rng), started = ...future.startTime, 
[17:46:36.902]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.902]             version = "1.8"), class = "FutureResult")
[17:46:36.902]     }, finally = {
[17:46:36.902]         if (!identical(...future.workdir, getwd())) 
[17:46:36.902]             setwd(...future.workdir)
[17:46:36.902]         {
[17:46:36.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.902]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.902]             }
[17:46:36.902]             base::options(...future.oldOptions)
[17:46:36.902]             if (.Platform$OS.type == "windows") {
[17:46:36.902]                 old_names <- names(...future.oldEnvVars)
[17:46:36.902]                 envs <- base::Sys.getenv()
[17:46:36.902]                 names <- names(envs)
[17:46:36.902]                 common <- intersect(names, old_names)
[17:46:36.902]                 added <- setdiff(names, old_names)
[17:46:36.902]                 removed <- setdiff(old_names, names)
[17:46:36.902]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.902]                   envs[common]]
[17:46:36.902]                 NAMES <- toupper(changed)
[17:46:36.902]                 args <- list()
[17:46:36.902]                 for (kk in seq_along(NAMES)) {
[17:46:36.902]                   name <- changed[[kk]]
[17:46:36.902]                   NAME <- NAMES[[kk]]
[17:46:36.902]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.902]                     next
[17:46:36.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.902]                 }
[17:46:36.902]                 NAMES <- toupper(added)
[17:46:36.902]                 for (kk in seq_along(NAMES)) {
[17:46:36.902]                   name <- added[[kk]]
[17:46:36.902]                   NAME <- NAMES[[kk]]
[17:46:36.902]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.902]                     next
[17:46:36.902]                   args[[name]] <- ""
[17:46:36.902]                 }
[17:46:36.902]                 NAMES <- toupper(removed)
[17:46:36.902]                 for (kk in seq_along(NAMES)) {
[17:46:36.902]                   name <- removed[[kk]]
[17:46:36.902]                   NAME <- NAMES[[kk]]
[17:46:36.902]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.902]                     next
[17:46:36.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.902]                 }
[17:46:36.902]                 if (length(args) > 0) 
[17:46:36.902]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.902]             }
[17:46:36.902]             else {
[17:46:36.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.902]             }
[17:46:36.902]             {
[17:46:36.902]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.902]                   0L) {
[17:46:36.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.902]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.902]                   base::options(opts)
[17:46:36.902]                 }
[17:46:36.902]                 {
[17:46:36.902]                   {
[17:46:36.902]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:36.902]                     NULL
[17:46:36.902]                   }
[17:46:36.902]                   options(future.plan = NULL)
[17:46:36.902]                   if (is.na(NA_character_)) 
[17:46:36.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.902]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.902]                     .init = FALSE)
[17:46:36.902]                 }
[17:46:36.902]             }
[17:46:36.902]         }
[17:46:36.902]     })
[17:46:36.902]     if (TRUE) {
[17:46:36.902]         base::sink(type = "output", split = FALSE)
[17:46:36.902]         if (TRUE) {
[17:46:36.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.902]         }
[17:46:36.902]         else {
[17:46:36.902]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.902]         }
[17:46:36.902]         base::close(...future.stdout)
[17:46:36.902]         ...future.stdout <- NULL
[17:46:36.902]     }
[17:46:36.902]     ...future.result$conditions <- ...future.conditions
[17:46:36.902]     ...future.result$finished <- base::Sys.time()
[17:46:36.902]     ...future.result
[17:46:36.902] }
[17:46:36.904] requestCore(): workers = 2
[17:46:36.906] MulticoreFuture started
[17:46:36.906] - Launch lazy future ... done
[17:46:36.906] run() for ‘MulticoreFuture’ ... done
[17:46:36.911] result() for MulticoreFuture ...
[17:46:36.911] plan(): Setting new future strategy stack:
[17:46:36.911] List of future strategies:
[17:46:36.911] 1. sequential:
[17:46:36.911]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.911]    - tweaked: FALSE
[17:46:36.911]    - call: NULL
[17:46:36.912] plan(): nbrOfWorkers() = 1
[17:46:36.941] plan(): Setting new future strategy stack:
[17:46:36.941] List of future strategies:
[17:46:36.941] 1. multicore:
[17:46:36.941]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:36.941]    - tweaked: FALSE
[17:46:36.941]    - call: plan(strategy)
[17:46:36.945] plan(): nbrOfWorkers() = 2
[17:46:36.947] result() for MulticoreFuture ...
[17:46:36.947] result() for MulticoreFuture ... done
[17:46:36.947] signalConditions() ...
[17:46:36.947]  - include = ‘immediateCondition’
[17:46:36.947]  - exclude = 
[17:46:36.948]  - resignal = FALSE
[17:46:36.948]  - Number of conditions: 88
[17:46:36.948] signalConditions() ... done
[17:46:36.948] result() for MulticoreFuture ... done
[17:46:36.948] result() for MulticoreFuture ...
[17:46:36.948] result() for MulticoreFuture ... done
[17:46:36.948] signalConditions() ...
[17:46:36.949]  - include = ‘immediateCondition’
[17:46:36.949]  - exclude = 
[17:46:36.949]  - resignal = FALSE
[17:46:36.949]  - Number of conditions: 88
[17:46:36.949] signalConditions() ... done
[17:46:36.949] Future state: ‘finished’
[17:46:36.949] result() for MulticoreFuture ...
[17:46:36.950] result() for MulticoreFuture ... done
[17:46:36.950] signalConditions() ...
[17:46:36.950]  - include = ‘condition’
[17:46:36.950]  - exclude = ‘immediateCondition’
[17:46:36.950]  - resignal = TRUE
[17:46:36.950]  - Number of conditions: 88
[17:46:36.950]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.914] getGlobalsAndPackages() ...
[17:46:36.950]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.914] Searching for globals...
[17:46:36.951]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.915] 
[17:46:36.951]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.915] Searching for globals ... DONE
[17:46:36.951]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.915] - globals: [0] <none>
[17:46:36.951]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.915] getGlobalsAndPackages() ... DONE
[17:46:36.951]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.916] run() for ‘Future’ ...
[17:46:36.952]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.917] - state: ‘created’
[17:46:36.952]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.917] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.952]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.917] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.952]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.917] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.952]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.918]   - Field: ‘label’
[17:46:36.952]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.918]   - Field: ‘local’
[17:46:36.953]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.918]   - Field: ‘owner’
[17:46:36.953]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.918]   - Field: ‘envir’
[17:46:36.953]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.918]   - Field: ‘packages’
[17:46:36.953]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.919]   - Field: ‘gc’
[17:46:36.953]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.919]   - Field: ‘conditions’
[17:46:36.953]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.919]   - Field: ‘expr’
[17:46:36.954]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.919]   - Field: ‘uuid’
[17:46:36.954]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.919]   - Field: ‘seed’
[17:46:36.954]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.920]   - Field: ‘version’
[17:46:36.954]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.920]   - Field: ‘result’
[17:46:36.954]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.920]   - Field: ‘asynchronous’
[17:46:36.954]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.920]   - Field: ‘calls’
[17:46:36.954]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.920]   - Field: ‘globals’
[17:46:36.955]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.921]   - Field: ‘stdout’
[17:46:36.955]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.921]   - Field: ‘earlySignal’
[17:46:36.955]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.921]   - Field: ‘lazy’
[17:46:36.955]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.921]   - Field: ‘state’
[17:46:36.955]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.921] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.955]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.921] - Launch lazy future ...
[17:46:36.956]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.922] Packages needed by the future expression (n = 0): <none>
[17:46:36.956]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.922] Packages needed by future strategies (n = 0): <none>
[17:46:36.956]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.923] {
[17:46:36.923]     {
[17:46:36.923]         {
[17:46:36.923]             ...future.startTime <- base::Sys.time()
[17:46:36.923]             {
[17:46:36.923]                 {
[17:46:36.923]                   {
[17:46:36.923]                     base::local({
[17:46:36.923]                       has_future <- base::requireNamespace("future", 
[17:46:36.923]                         quietly = TRUE)
[17:46:36.923]                       if (has_future) {
[17:46:36.923]                         ns <- base::getNamespace("future")
[17:46:36.923]                         version <- ns[[".package"]][["version"]]
[17:46:36.923]                         if (is.null(version)) 
[17:46:36.923]                           version <- utils::packageVersion("future")
[17:46:36.923]                       }
[17:46:36.923]                       else {
[17:46:36.923]                         version <- NULL
[17:46:36.923]                       }
[17:46:36.923]                       if (!has_future || version < "1.8.0") {
[17:46:36.923]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.923]                           "", base::R.version$version.string), 
[17:46:36.923]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:36.923]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.923]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.923]                             "release", "version")], collapse = " "), 
[17:46:36.923]                           hostname = base::Sys.info()[["nodename"]])
[17:46:36.923]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.923]                           info)
[17:46:36.923]                         info <- base::paste(info, collapse = "; ")
[17:46:36.923]                         if (!has_future) {
[17:46:36.923]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.923]                             info)
[17:46:36.923]                         }
[17:46:36.923]                         else {
[17:46:36.923]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.923]                             info, version)
[17:46:36.923]                         }
[17:46:36.923]                         base::stop(msg)
[17:46:36.923]                       }
[17:46:36.923]                     })
[17:46:36.923]                   }
[17:46:36.923]                   ...future.strategy.old <- future::plan("list")
[17:46:36.923]                   options(future.plan = NULL)
[17:46:36.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.923]                 }
[17:46:36.923]                 ...future.workdir <- getwd()
[17:46:36.923]             }
[17:46:36.923]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.923]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.923]         }
[17:46:36.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.923]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.923]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.923]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.923]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.923]             base::names(...future.oldOptions))
[17:46:36.923]     }
[17:46:36.923]     if (FALSE) {
[17:46:36.923]     }
[17:46:36.923]     else {
[17:46:36.923]         if (TRUE) {
[17:46:36.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.923]                 open = "w")
[17:46:36.923]         }
[17:46:36.923]         else {
[17:46:36.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.923]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.923]         }
[17:46:36.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.923]             base::sink(type = "output", split = FALSE)
[17:46:36.923]             base::close(...future.stdout)
[17:46:36.923]         }, add = TRUE)
[17:46:36.923]     }
[17:46:36.923]     ...future.frame <- base::sys.nframe()
[17:46:36.923]     ...future.conditions <- base::list()
[17:46:36.923]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.923]     if (FALSE) {
[17:46:36.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.923]     }
[17:46:36.923]     ...future.result <- base::tryCatch({
[17:46:36.923]         base::withCallingHandlers({
[17:46:36.923]             ...future.value <- base::withVisible(base::local(2))
[17:46:36.923]             future::FutureResult(value = ...future.value$value, 
[17:46:36.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.923]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.923]                     ...future.globalenv.names))
[17:46:36.923]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.923]         }, condition = base::local({
[17:46:36.923]             c <- base::c
[17:46:36.923]             inherits <- base::inherits
[17:46:36.923]             invokeRestart <- base::invokeRestart
[17:46:36.923]             length <- base::length
[17:46:36.923]             list <- base::list
[17:46:36.923]             seq.int <- base::seq.int
[17:46:36.923]             signalCondition <- base::signalCondition
[17:46:36.923]             sys.calls <- base::sys.calls
[17:46:36.923]             `[[` <- base::`[[`
[17:46:36.923]             `+` <- base::`+`
[17:46:36.923]             `<<-` <- base::`<<-`
[17:46:36.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.923]                   3L)]
[17:46:36.923]             }
[17:46:36.923]             function(cond) {
[17:46:36.923]                 is_error <- inherits(cond, "error")
[17:46:36.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.923]                   NULL)
[17:46:36.923]                 if (is_error) {
[17:46:36.923]                   sessionInformation <- function() {
[17:46:36.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.923]                       search = base::search(), system = base::Sys.info())
[17:46:36.923]                   }
[17:46:36.923]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.923]                     cond$call), session = sessionInformation(), 
[17:46:36.923]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.923]                   signalCondition(cond)
[17:46:36.923]                 }
[17:46:36.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.923]                 "immediateCondition"))) {
[17:46:36.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.923]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.923]                   if (TRUE && !signal) {
[17:46:36.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.923]                     {
[17:46:36.923]                       inherits <- base::inherits
[17:46:36.923]                       invokeRestart <- base::invokeRestart
[17:46:36.923]                       is.null <- base::is.null
[17:46:36.923]                       muffled <- FALSE
[17:46:36.923]                       if (inherits(cond, "message")) {
[17:46:36.923]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.923]                         if (muffled) 
[17:46:36.923]                           invokeRestart("muffleMessage")
[17:46:36.923]                       }
[17:46:36.923]                       else if (inherits(cond, "warning")) {
[17:46:36.923]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.923]                         if (muffled) 
[17:46:36.923]                           invokeRestart("muffleWarning")
[17:46:36.923]                       }
[17:46:36.923]                       else if (inherits(cond, "condition")) {
[17:46:36.923]                         if (!is.null(pattern)) {
[17:46:36.923]                           computeRestarts <- base::computeRestarts
[17:46:36.923]                           grepl <- base::grepl
[17:46:36.923]                           restarts <- computeRestarts(cond)
[17:46:36.923]                           for (restart in restarts) {
[17:46:36.923]                             name <- restart$name
[17:46:36.923]                             if (is.null(name)) 
[17:46:36.923]                               next
[17:46:36.923]                             if (!grepl(pattern, name)) 
[17:46:36.923]                               next
[17:46:36.923]                             invokeRestart(restart)
[17:46:36.923]                             muffled <- TRUE
[17:46:36.923]                             break
[17:46:36.923]                           }
[17:46:36.923]                         }
[17:46:36.923]                       }
[17:46:36.923]                       invisible(muffled)
[17:46:36.923]                     }
[17:46:36.923]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.923]                   }
[17:46:36.923]                 }
[17:46:36.923]                 else {
[17:46:36.923]                   if (TRUE) {
[17:46:36.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.923]                     {
[17:46:36.923]                       inherits <- base::inherits
[17:46:36.923]                       invokeRestart <- base::invokeRestart
[17:46:36.923]                       is.null <- base::is.null
[17:46:36.923]                       muffled <- FALSE
[17:46:36.923]                       if (inherits(cond, "message")) {
[17:46:36.923]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.923]                         if (muffled) 
[17:46:36.923]                           invokeRestart("muffleMessage")
[17:46:36.923]                       }
[17:46:36.923]                       else if (inherits(cond, "warning")) {
[17:46:36.923]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.923]                         if (muffled) 
[17:46:36.923]                           invokeRestart("muffleWarning")
[17:46:36.923]                       }
[17:46:36.923]                       else if (inherits(cond, "condition")) {
[17:46:36.923]                         if (!is.null(pattern)) {
[17:46:36.923]                           computeRestarts <- base::computeRestarts
[17:46:36.923]                           grepl <- base::grepl
[17:46:36.923]                           restarts <- computeRestarts(cond)
[17:46:36.923]                           for (restart in restarts) {
[17:46:36.923]                             name <- restart$name
[17:46:36.923]                             if (is.null(name)) 
[17:46:36.923]                               next
[17:46:36.923]                             if (!grepl(pattern, name)) 
[17:46:36.923]                               next
[17:46:36.923]                             invokeRestart(restart)
[17:46:36.923]                             muffled <- TRUE
[17:46:36.923]                             break
[17:46:36.923]                           }
[17:46:36.923]                         }
[17:46:36.923]                       }
[17:46:36.923]                       invisible(muffled)
[17:46:36.923]                     }
[17:46:36.923]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.923]                   }
[17:46:36.923]                 }
[17:46:36.923]             }
[17:46:36.923]         }))
[17:46:36.923]     }, error = function(ex) {
[17:46:36.923]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.923]                 ...future.rng), started = ...future.startTime, 
[17:46:36.923]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.923]             version = "1.8"), class = "FutureResult")
[17:46:36.923]     }, finally = {
[17:46:36.923]         if (!identical(...future.workdir, getwd())) 
[17:46:36.923]             setwd(...future.workdir)
[17:46:36.923]         {
[17:46:36.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.923]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.923]             }
[17:46:36.923]             base::options(...future.oldOptions)
[17:46:36.923]             if (.Platform$OS.type == "windows") {
[17:46:36.923]                 old_names <- names(...future.oldEnvVars)
[17:46:36.923]                 envs <- base::Sys.getenv()
[17:46:36.923]                 names <- names(envs)
[17:46:36.923]                 common <- intersect(names, old_names)
[17:46:36.923]                 added <- setdiff(names, old_names)
[17:46:36.923]                 removed <- setdiff(old_names, names)
[17:46:36.923]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.923]                   envs[common]]
[17:46:36.923]                 NAMES <- toupper(changed)
[17:46:36.923]                 args <- list()
[17:46:36.923]                 for (kk in seq_along(NAMES)) {
[17:46:36.923]                   name <- changed[[kk]]
[17:46:36.923]                   NAME <- NAMES[[kk]]
[17:46:36.923]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.923]                     next
[17:46:36.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.923]                 }
[17:46:36.923]                 NAMES <- toupper(added)
[17:46:36.923]                 for (kk in seq_along(NAMES)) {
[17:46:36.923]                   name <- added[[kk]]
[17:46:36.923]                   NAME <- NAMES[[kk]]
[17:46:36.923]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.923]                     next
[17:46:36.923]                   args[[name]] <- ""
[17:46:36.923]                 }
[17:46:36.923]                 NAMES <- toupper(removed)
[17:46:36.923]                 for (kk in seq_along(NAMES)) {
[17:46:36.923]                   name <- removed[[kk]]
[17:46:36.923]                   NAME <- NAMES[[kk]]
[17:46:36.923]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.923]                     next
[17:46:36.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.923]                 }
[17:46:36.923]                 if (length(args) > 0) 
[17:46:36.923]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.923]             }
[17:46:36.923]             else {
[17:46:36.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.923]             }
[17:46:36.923]             {
[17:46:36.923]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.923]                   0L) {
[17:46:36.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.923]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.923]                   base::options(opts)
[17:46:36.923]                 }
[17:46:36.923]                 {
[17:46:36.923]                   {
[17:46:36.923]                     NULL
[17:46:36.923]                     RNGkind("Mersenne-Twister")
[17:46:36.923]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.923]                       inherits = FALSE)
[17:46:36.923]                   }
[17:46:36.923]                   options(future.plan = NULL)
[17:46:36.923]                   if (is.na(NA_character_)) 
[17:46:36.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.923]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.923]                     .init = FALSE)
[17:46:36.923]                 }
[17:46:36.923]             }
[17:46:36.923]         }
[17:46:36.923]     })
[17:46:36.923]     if (TRUE) {
[17:46:36.923]         base::sink(type = "output", split = FALSE)
[17:46:36.923]         if (TRUE) {
[17:46:36.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.923]         }
[17:46:36.923]         else {
[17:46:36.923]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.923]         }
[17:46:36.923]         base::close(...future.stdout)
[17:46:36.923]         ...future.stdout <- NULL
[17:46:36.923]     }
[17:46:36.923]     ...future.result$conditions <- ...future.conditions
[17:46:36.923]     ...future.result$finished <- base::Sys.time()
[17:46:36.923]     ...future.result
[17:46:36.923] }
[17:46:36.956]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.925] plan(): Setting new future strategy stack:
[17:46:36.956]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.925] List of future strategies:
[17:46:36.925] 1. sequential:
[17:46:36.925]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.925]    - tweaked: FALSE
[17:46:36.925]    - call: NULL
[17:46:36.956]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.926] plan(): nbrOfWorkers() = 1
[17:46:36.957]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.927] plan(): Setting new future strategy stack:
[17:46:36.957]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.927] List of future strategies:
[17:46:36.927] 1. sequential:
[17:46:36.927]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.927]    - tweaked: FALSE
[17:46:36.927]    - call: NULL
[17:46:36.957]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.928] plan(): nbrOfWorkers() = 1
[17:46:36.957]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.928] SequentialFuture started (and completed)
[17:46:36.957]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.928] - Launch lazy future ... done
[17:46:36.957]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.928] run() for ‘SequentialFuture’ ... done
[17:46:36.958]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.928] getGlobalsAndPackages() ...
[17:46:36.958]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.929] Searching for globals...
[17:46:36.958]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.929] 
[17:46:36.958]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.929] Searching for globals ... DONE
[17:46:36.958]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.929] - globals: [0] <none>
[17:46:36.958]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.930] getGlobalsAndPackages() ... DONE
[17:46:36.958]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.930] run() for ‘Future’ ...
[17:46:36.959]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.930] - state: ‘created’
[17:46:36.959]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.930] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:36.959]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.931] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:36.959]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.931] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:36.959]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.931]   - Field: ‘label’
[17:46:36.959]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.931]   - Field: ‘local’
[17:46:36.960]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.931]   - Field: ‘owner’
[17:46:36.960]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.932]   - Field: ‘envir’
[17:46:36.960]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.932]   - Field: ‘packages’
[17:46:36.960]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.932]   - Field: ‘gc’
[17:46:36.960]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.932]   - Field: ‘conditions’
[17:46:36.960]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.932]   - Field: ‘expr’
[17:46:36.961]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.932]   - Field: ‘uuid’
[17:46:36.961]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.932]   - Field: ‘seed’
[17:46:36.961]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.933]   - Field: ‘version’
[17:46:36.961]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.933]   - Field: ‘result’
[17:46:36.961]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.933]   - Field: ‘asynchronous’
[17:46:36.961]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.933]   - Field: ‘calls’
[17:46:36.961]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.933]   - Field: ‘globals’
[17:46:36.962]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.933]   - Field: ‘stdout’
[17:46:36.962]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.934]   - Field: ‘earlySignal’
[17:46:36.962]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.934]   - Field: ‘lazy’
[17:46:36.962]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.934]   - Field: ‘state’
[17:46:36.962]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.934] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:36.962]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.934] - Launch lazy future ...
[17:46:36.963]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.934] Packages needed by the future expression (n = 0): <none>
[17:46:36.963]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.935] Packages needed by future strategies (n = 0): <none>
[17:46:36.963]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.935] {
[17:46:36.935]     {
[17:46:36.935]         {
[17:46:36.935]             ...future.startTime <- base::Sys.time()
[17:46:36.935]             {
[17:46:36.935]                 {
[17:46:36.935]                   {
[17:46:36.935]                     base::local({
[17:46:36.935]                       has_future <- base::requireNamespace("future", 
[17:46:36.935]                         quietly = TRUE)
[17:46:36.935]                       if (has_future) {
[17:46:36.935]                         ns <- base::getNamespace("future")
[17:46:36.935]                         version <- ns[[".package"]][["version"]]
[17:46:36.935]                         if (is.null(version)) 
[17:46:36.935]                           version <- utils::packageVersion("future")
[17:46:36.935]                       }
[17:46:36.935]                       else {
[17:46:36.935]                         version <- NULL
[17:46:36.935]                       }
[17:46:36.935]                       if (!has_future || version < "1.8.0") {
[17:46:36.935]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.935]                           "", base::R.version$version.string), 
[17:46:36.935]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:36.935]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.935]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.935]                             "release", "version")], collapse = " "), 
[17:46:36.935]                           hostname = base::Sys.info()[["nodename"]])
[17:46:36.935]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.935]                           info)
[17:46:36.935]                         info <- base::paste(info, collapse = "; ")
[17:46:36.935]                         if (!has_future) {
[17:46:36.935]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.935]                             info)
[17:46:36.935]                         }
[17:46:36.935]                         else {
[17:46:36.935]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.935]                             info, version)
[17:46:36.935]                         }
[17:46:36.935]                         base::stop(msg)
[17:46:36.935]                       }
[17:46:36.935]                     })
[17:46:36.935]                   }
[17:46:36.935]                   ...future.strategy.old <- future::plan("list")
[17:46:36.935]                   options(future.plan = NULL)
[17:46:36.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.935]                 }
[17:46:36.935]                 ...future.workdir <- getwd()
[17:46:36.935]             }
[17:46:36.935]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.935]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.935]         }
[17:46:36.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.935]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.935]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.935]             base::names(...future.oldOptions))
[17:46:36.935]     }
[17:46:36.935]     if (FALSE) {
[17:46:36.935]     }
[17:46:36.935]     else {
[17:46:36.935]         if (TRUE) {
[17:46:36.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.935]                 open = "w")
[17:46:36.935]         }
[17:46:36.935]         else {
[17:46:36.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.935]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.935]         }
[17:46:36.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.935]             base::sink(type = "output", split = FALSE)
[17:46:36.935]             base::close(...future.stdout)
[17:46:36.935]         }, add = TRUE)
[17:46:36.935]     }
[17:46:36.935]     ...future.frame <- base::sys.nframe()
[17:46:36.935]     ...future.conditions <- base::list()
[17:46:36.935]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.935]     if (FALSE) {
[17:46:36.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.935]     }
[17:46:36.935]     ...future.result <- base::tryCatch({
[17:46:36.935]         base::withCallingHandlers({
[17:46:36.935]             ...future.value <- base::withVisible(base::local(4))
[17:46:36.935]             future::FutureResult(value = ...future.value$value, 
[17:46:36.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.935]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.935]                     ...future.globalenv.names))
[17:46:36.935]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.935]         }, condition = base::local({
[17:46:36.935]             c <- base::c
[17:46:36.935]             inherits <- base::inherits
[17:46:36.935]             invokeRestart <- base::invokeRestart
[17:46:36.935]             length <- base::length
[17:46:36.935]             list <- base::list
[17:46:36.935]             seq.int <- base::seq.int
[17:46:36.935]             signalCondition <- base::signalCondition
[17:46:36.935]             sys.calls <- base::sys.calls
[17:46:36.935]             `[[` <- base::`[[`
[17:46:36.935]             `+` <- base::`+`
[17:46:36.935]             `<<-` <- base::`<<-`
[17:46:36.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.935]                   3L)]
[17:46:36.935]             }
[17:46:36.935]             function(cond) {
[17:46:36.935]                 is_error <- inherits(cond, "error")
[17:46:36.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.935]                   NULL)
[17:46:36.935]                 if (is_error) {
[17:46:36.935]                   sessionInformation <- function() {
[17:46:36.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.935]                       search = base::search(), system = base::Sys.info())
[17:46:36.935]                   }
[17:46:36.935]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.935]                     cond$call), session = sessionInformation(), 
[17:46:36.935]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.935]                   signalCondition(cond)
[17:46:36.935]                 }
[17:46:36.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.935]                 "immediateCondition"))) {
[17:46:36.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.935]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.935]                   if (TRUE && !signal) {
[17:46:36.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.935]                     {
[17:46:36.935]                       inherits <- base::inherits
[17:46:36.935]                       invokeRestart <- base::invokeRestart
[17:46:36.935]                       is.null <- base::is.null
[17:46:36.935]                       muffled <- FALSE
[17:46:36.935]                       if (inherits(cond, "message")) {
[17:46:36.935]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.935]                         if (muffled) 
[17:46:36.935]                           invokeRestart("muffleMessage")
[17:46:36.935]                       }
[17:46:36.935]                       else if (inherits(cond, "warning")) {
[17:46:36.935]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.935]                         if (muffled) 
[17:46:36.935]                           invokeRestart("muffleWarning")
[17:46:36.935]                       }
[17:46:36.935]                       else if (inherits(cond, "condition")) {
[17:46:36.935]                         if (!is.null(pattern)) {
[17:46:36.935]                           computeRestarts <- base::computeRestarts
[17:46:36.935]                           grepl <- base::grepl
[17:46:36.935]                           restarts <- computeRestarts(cond)
[17:46:36.935]                           for (restart in restarts) {
[17:46:36.935]                             name <- restart$name
[17:46:36.935]                             if (is.null(name)) 
[17:46:36.935]                               next
[17:46:36.935]                             if (!grepl(pattern, name)) 
[17:46:36.935]                               next
[17:46:36.935]                             invokeRestart(restart)
[17:46:36.935]                             muffled <- TRUE
[17:46:36.935]                             break
[17:46:36.935]                           }
[17:46:36.935]                         }
[17:46:36.935]                       }
[17:46:36.935]                       invisible(muffled)
[17:46:36.935]                     }
[17:46:36.935]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.935]                   }
[17:46:36.935]                 }
[17:46:36.935]                 else {
[17:46:36.935]                   if (TRUE) {
[17:46:36.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.935]                     {
[17:46:36.935]                       inherits <- base::inherits
[17:46:36.935]                       invokeRestart <- base::invokeRestart
[17:46:36.935]                       is.null <- base::is.null
[17:46:36.935]                       muffled <- FALSE
[17:46:36.935]                       if (inherits(cond, "message")) {
[17:46:36.935]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.935]                         if (muffled) 
[17:46:36.935]                           invokeRestart("muffleMessage")
[17:46:36.935]                       }
[17:46:36.935]                       else if (inherits(cond, "warning")) {
[17:46:36.935]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.935]                         if (muffled) 
[17:46:36.935]                           invokeRestart("muffleWarning")
[17:46:36.935]                       }
[17:46:36.935]                       else if (inherits(cond, "condition")) {
[17:46:36.935]                         if (!is.null(pattern)) {
[17:46:36.935]                           computeRestarts <- base::computeRestarts
[17:46:36.935]                           grepl <- base::grepl
[17:46:36.935]                           restarts <- computeRestarts(cond)
[17:46:36.935]                           for (restart in restarts) {
[17:46:36.935]                             name <- restart$name
[17:46:36.935]                             if (is.null(name)) 
[17:46:36.935]                               next
[17:46:36.935]                             if (!grepl(pattern, name)) 
[17:46:36.935]                               next
[17:46:36.935]                             invokeRestart(restart)
[17:46:36.935]                             muffled <- TRUE
[17:46:36.935]                             break
[17:46:36.935]                           }
[17:46:36.935]                         }
[17:46:36.935]                       }
[17:46:36.935]                       invisible(muffled)
[17:46:36.935]                     }
[17:46:36.935]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.935]                   }
[17:46:36.935]                 }
[17:46:36.935]             }
[17:46:36.935]         }))
[17:46:36.935]     }, error = function(ex) {
[17:46:36.935]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.935]                 ...future.rng), started = ...future.startTime, 
[17:46:36.935]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.935]             version = "1.8"), class = "FutureResult")
[17:46:36.935]     }, finally = {
[17:46:36.935]         if (!identical(...future.workdir, getwd())) 
[17:46:36.935]             setwd(...future.workdir)
[17:46:36.935]         {
[17:46:36.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.935]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.935]             }
[17:46:36.935]             base::options(...future.oldOptions)
[17:46:36.935]             if (.Platform$OS.type == "windows") {
[17:46:36.935]                 old_names <- names(...future.oldEnvVars)
[17:46:36.935]                 envs <- base::Sys.getenv()
[17:46:36.935]                 names <- names(envs)
[17:46:36.935]                 common <- intersect(names, old_names)
[17:46:36.935]                 added <- setdiff(names, old_names)
[17:46:36.935]                 removed <- setdiff(old_names, names)
[17:46:36.935]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.935]                   envs[common]]
[17:46:36.935]                 NAMES <- toupper(changed)
[17:46:36.935]                 args <- list()
[17:46:36.935]                 for (kk in seq_along(NAMES)) {
[17:46:36.935]                   name <- changed[[kk]]
[17:46:36.935]                   NAME <- NAMES[[kk]]
[17:46:36.935]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.935]                     next
[17:46:36.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.935]                 }
[17:46:36.935]                 NAMES <- toupper(added)
[17:46:36.935]                 for (kk in seq_along(NAMES)) {
[17:46:36.935]                   name <- added[[kk]]
[17:46:36.935]                   NAME <- NAMES[[kk]]
[17:46:36.935]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.935]                     next
[17:46:36.935]                   args[[name]] <- ""
[17:46:36.935]                 }
[17:46:36.935]                 NAMES <- toupper(removed)
[17:46:36.935]                 for (kk in seq_along(NAMES)) {
[17:46:36.935]                   name <- removed[[kk]]
[17:46:36.935]                   NAME <- NAMES[[kk]]
[17:46:36.935]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.935]                     next
[17:46:36.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.935]                 }
[17:46:36.935]                 if (length(args) > 0) 
[17:46:36.935]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.935]             }
[17:46:36.935]             else {
[17:46:36.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.935]             }
[17:46:36.935]             {
[17:46:36.935]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.935]                   0L) {
[17:46:36.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.935]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.935]                   base::options(opts)
[17:46:36.935]                 }
[17:46:36.935]                 {
[17:46:36.935]                   {
[17:46:36.935]                     NULL
[17:46:36.935]                     RNGkind("Mersenne-Twister")
[17:46:36.935]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:36.935]                       inherits = FALSE)
[17:46:36.935]                   }
[17:46:36.935]                   options(future.plan = NULL)
[17:46:36.935]                   if (is.na(NA_character_)) 
[17:46:36.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.935]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.935]                     .init = FALSE)
[17:46:36.935]                 }
[17:46:36.935]             }
[17:46:36.935]         }
[17:46:36.935]     })
[17:46:36.935]     if (TRUE) {
[17:46:36.935]         base::sink(type = "output", split = FALSE)
[17:46:36.935]         if (TRUE) {
[17:46:36.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.935]         }
[17:46:36.935]         else {
[17:46:36.935]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.935]         }
[17:46:36.935]         base::close(...future.stdout)
[17:46:36.935]         ...future.stdout <- NULL
[17:46:36.935]     }
[17:46:36.935]     ...future.result$conditions <- ...future.conditions
[17:46:36.935]     ...future.result$finished <- base::Sys.time()
[17:46:36.935]     ...future.result
[17:46:36.935] }
[17:46:36.963]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.937] plan(): Setting new future strategy stack:
[17:46:36.963]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.937] List of future strategies:
[17:46:36.937] 1. sequential:
[17:46:36.937]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.937]    - tweaked: FALSE
[17:46:36.937]    - call: NULL
[17:46:36.963]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.938] plan(): nbrOfWorkers() = 1
[17:46:36.964]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.939] plan(): Setting new future strategy stack:
[17:46:36.964]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.939] List of future strategies:
[17:46:36.939] 1. sequential:
[17:46:36.939]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.939]    - tweaked: FALSE
[17:46:36.939]    - call: NULL
[17:46:36.964]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.940] plan(): nbrOfWorkers() = 1
[17:46:36.964]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.940] SequentialFuture started (and completed)
[17:46:36.964]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.940] - Launch lazy future ... done
[17:46:36.964]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[17:46:36.940] run() for ‘SequentialFuture’ ... done
[17:46:36.964] signalConditions() ... done
a = 10
[17:46:36.965] getGlobalsAndPackages() ...
[17:46:36.965] Searching for globals...
[17:46:36.966] - globals found: [3] ‘{’, ‘+’, ‘a’
[17:46:36.966] Searching for globals ... DONE
[17:46:36.966] Resolving globals: FALSE
[17:46:36.967] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:36.967] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:46:36.967] - globals: [1] ‘a’
[17:46:36.967] 
[17:46:36.968] getGlobalsAndPackages() ... DONE
[17:46:36.968] run() for ‘Future’ ...
[17:46:36.968] - state: ‘created’
[17:46:36.968] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:36.974] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:36.974] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:36.974]   - Field: ‘label’
[17:46:36.974]   - Field: ‘local’
[17:46:36.975]   - Field: ‘owner’
[17:46:36.975]   - Field: ‘envir’
[17:46:36.975]   - Field: ‘workers’
[17:46:36.975]   - Field: ‘packages’
[17:46:36.975]   - Field: ‘gc’
[17:46:36.975]   - Field: ‘job’
[17:46:36.975]   - Field: ‘conditions’
[17:46:36.975]   - Field: ‘expr’
[17:46:36.975]   - Field: ‘uuid’
[17:46:36.975]   - Field: ‘seed’
[17:46:36.976]   - Field: ‘version’
[17:46:36.976]   - Field: ‘result’
[17:46:36.976]   - Field: ‘asynchronous’
[17:46:36.976]   - Field: ‘calls’
[17:46:36.976]   - Field: ‘globals’
[17:46:36.976]   - Field: ‘stdout’
[17:46:36.976]   - Field: ‘earlySignal’
[17:46:36.976]   - Field: ‘lazy’
[17:46:36.976]   - Field: ‘state’
[17:46:36.976] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:36.976] - Launch lazy future ...
[17:46:36.977] Packages needed by the future expression (n = 0): <none>
[17:46:36.977] Packages needed by future strategies (n = 0): <none>
[17:46:36.977] {
[17:46:36.977]     {
[17:46:36.977]         {
[17:46:36.977]             ...future.startTime <- base::Sys.time()
[17:46:36.977]             {
[17:46:36.977]                 {
[17:46:36.977]                   {
[17:46:36.977]                     {
[17:46:36.977]                       base::local({
[17:46:36.977]                         has_future <- base::requireNamespace("future", 
[17:46:36.977]                           quietly = TRUE)
[17:46:36.977]                         if (has_future) {
[17:46:36.977]                           ns <- base::getNamespace("future")
[17:46:36.977]                           version <- ns[[".package"]][["version"]]
[17:46:36.977]                           if (is.null(version)) 
[17:46:36.977]                             version <- utils::packageVersion("future")
[17:46:36.977]                         }
[17:46:36.977]                         else {
[17:46:36.977]                           version <- NULL
[17:46:36.977]                         }
[17:46:36.977]                         if (!has_future || version < "1.8.0") {
[17:46:36.977]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:36.977]                             "", base::R.version$version.string), 
[17:46:36.977]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:36.977]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:36.977]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:36.977]                               "release", "version")], collapse = " "), 
[17:46:36.977]                             hostname = base::Sys.info()[["nodename"]])
[17:46:36.977]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:36.977]                             info)
[17:46:36.977]                           info <- base::paste(info, collapse = "; ")
[17:46:36.977]                           if (!has_future) {
[17:46:36.977]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:36.977]                               info)
[17:46:36.977]                           }
[17:46:36.977]                           else {
[17:46:36.977]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:36.977]                               info, version)
[17:46:36.977]                           }
[17:46:36.977]                           base::stop(msg)
[17:46:36.977]                         }
[17:46:36.977]                       })
[17:46:36.977]                     }
[17:46:36.977]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:36.977]                     base::options(mc.cores = 1L)
[17:46:36.977]                   }
[17:46:36.977]                   ...future.strategy.old <- future::plan("list")
[17:46:36.977]                   options(future.plan = NULL)
[17:46:36.977]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.977]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:36.977]                 }
[17:46:36.977]                 ...future.workdir <- getwd()
[17:46:36.977]             }
[17:46:36.977]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:36.977]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:36.977]         }
[17:46:36.977]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:36.977]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:36.977]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:36.977]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:36.977]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:36.977]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:36.977]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:36.977]             base::names(...future.oldOptions))
[17:46:36.977]     }
[17:46:36.977]     if (FALSE) {
[17:46:36.977]     }
[17:46:36.977]     else {
[17:46:36.977]         if (TRUE) {
[17:46:36.977]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:36.977]                 open = "w")
[17:46:36.977]         }
[17:46:36.977]         else {
[17:46:36.977]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:36.977]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:36.977]         }
[17:46:36.977]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:36.977]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:36.977]             base::sink(type = "output", split = FALSE)
[17:46:36.977]             base::close(...future.stdout)
[17:46:36.977]         }, add = TRUE)
[17:46:36.977]     }
[17:46:36.977]     ...future.frame <- base::sys.nframe()
[17:46:36.977]     ...future.conditions <- base::list()
[17:46:36.977]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:36.977]     if (FALSE) {
[17:46:36.977]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:36.977]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:36.977]     }
[17:46:36.977]     ...future.result <- base::tryCatch({
[17:46:36.977]         base::withCallingHandlers({
[17:46:36.977]             ...future.value <- base::withVisible(base::local({
[17:46:36.977]                 withCallingHandlers({
[17:46:36.977]                   {
[17:46:36.977]                     a + 1
[17:46:36.977]                   }
[17:46:36.977]                 }, immediateCondition = function(cond) {
[17:46:36.977]                   save_rds <- function (object, pathname, ...) 
[17:46:36.977]                   {
[17:46:36.977]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:36.977]                     if (file_test("-f", pathname_tmp)) {
[17:46:36.977]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.977]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:36.977]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.977]                         fi_tmp[["mtime"]])
[17:46:36.977]                     }
[17:46:36.977]                     tryCatch({
[17:46:36.977]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:36.977]                     }, error = function(ex) {
[17:46:36.977]                       msg <- conditionMessage(ex)
[17:46:36.977]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.977]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:36.977]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.977]                         fi_tmp[["mtime"]], msg)
[17:46:36.977]                       ex$message <- msg
[17:46:36.977]                       stop(ex)
[17:46:36.977]                     })
[17:46:36.977]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:36.977]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:36.977]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:36.977]                       fi_tmp <- file.info(pathname_tmp)
[17:46:36.977]                       fi <- file.info(pathname)
[17:46:36.977]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:36.977]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:36.977]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:36.977]                         fi[["size"]], fi[["mtime"]])
[17:46:36.977]                       stop(msg)
[17:46:36.977]                     }
[17:46:36.977]                     invisible(pathname)
[17:46:36.977]                   }
[17:46:36.977]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:36.977]                     rootPath = tempdir()) 
[17:46:36.977]                   {
[17:46:36.977]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:36.977]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:36.977]                       tmpdir = path, fileext = ".rds")
[17:46:36.977]                     save_rds(obj, file)
[17:46:36.977]                   }
[17:46:36.977]                   saveImmediateCondition(cond, path = "/tmp/RtmpzxgiTZ/.future/immediateConditions")
[17:46:36.977]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.977]                   {
[17:46:36.977]                     inherits <- base::inherits
[17:46:36.977]                     invokeRestart <- base::invokeRestart
[17:46:36.977]                     is.null <- base::is.null
[17:46:36.977]                     muffled <- FALSE
[17:46:36.977]                     if (inherits(cond, "message")) {
[17:46:36.977]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:36.977]                       if (muffled) 
[17:46:36.977]                         invokeRestart("muffleMessage")
[17:46:36.977]                     }
[17:46:36.977]                     else if (inherits(cond, "warning")) {
[17:46:36.977]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:36.977]                       if (muffled) 
[17:46:36.977]                         invokeRestart("muffleWarning")
[17:46:36.977]                     }
[17:46:36.977]                     else if (inherits(cond, "condition")) {
[17:46:36.977]                       if (!is.null(pattern)) {
[17:46:36.977]                         computeRestarts <- base::computeRestarts
[17:46:36.977]                         grepl <- base::grepl
[17:46:36.977]                         restarts <- computeRestarts(cond)
[17:46:36.977]                         for (restart in restarts) {
[17:46:36.977]                           name <- restart$name
[17:46:36.977]                           if (is.null(name)) 
[17:46:36.977]                             next
[17:46:36.977]                           if (!grepl(pattern, name)) 
[17:46:36.977]                             next
[17:46:36.977]                           invokeRestart(restart)
[17:46:36.977]                           muffled <- TRUE
[17:46:36.977]                           break
[17:46:36.977]                         }
[17:46:36.977]                       }
[17:46:36.977]                     }
[17:46:36.977]                     invisible(muffled)
[17:46:36.977]                   }
[17:46:36.977]                   muffleCondition(cond)
[17:46:36.977]                 })
[17:46:36.977]             }))
[17:46:36.977]             future::FutureResult(value = ...future.value$value, 
[17:46:36.977]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.977]                   ...future.rng), globalenv = if (FALSE) 
[17:46:36.977]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:36.977]                     ...future.globalenv.names))
[17:46:36.977]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:36.977]         }, condition = base::local({
[17:46:36.977]             c <- base::c
[17:46:36.977]             inherits <- base::inherits
[17:46:36.977]             invokeRestart <- base::invokeRestart
[17:46:36.977]             length <- base::length
[17:46:36.977]             list <- base::list
[17:46:36.977]             seq.int <- base::seq.int
[17:46:36.977]             signalCondition <- base::signalCondition
[17:46:36.977]             sys.calls <- base::sys.calls
[17:46:36.977]             `[[` <- base::`[[`
[17:46:36.977]             `+` <- base::`+`
[17:46:36.977]             `<<-` <- base::`<<-`
[17:46:36.977]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:36.977]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:36.977]                   3L)]
[17:46:36.977]             }
[17:46:36.977]             function(cond) {
[17:46:36.977]                 is_error <- inherits(cond, "error")
[17:46:36.977]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:36.977]                   NULL)
[17:46:36.977]                 if (is_error) {
[17:46:36.977]                   sessionInformation <- function() {
[17:46:36.977]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:36.977]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:36.977]                       search = base::search(), system = base::Sys.info())
[17:46:36.977]                   }
[17:46:36.977]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.977]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:36.977]                     cond$call), session = sessionInformation(), 
[17:46:36.977]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:36.977]                   signalCondition(cond)
[17:46:36.977]                 }
[17:46:36.977]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:36.977]                 "immediateCondition"))) {
[17:46:36.977]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:36.977]                   ...future.conditions[[length(...future.conditions) + 
[17:46:36.977]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:36.977]                   if (TRUE && !signal) {
[17:46:36.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.977]                     {
[17:46:36.977]                       inherits <- base::inherits
[17:46:36.977]                       invokeRestart <- base::invokeRestart
[17:46:36.977]                       is.null <- base::is.null
[17:46:36.977]                       muffled <- FALSE
[17:46:36.977]                       if (inherits(cond, "message")) {
[17:46:36.977]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.977]                         if (muffled) 
[17:46:36.977]                           invokeRestart("muffleMessage")
[17:46:36.977]                       }
[17:46:36.977]                       else if (inherits(cond, "warning")) {
[17:46:36.977]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.977]                         if (muffled) 
[17:46:36.977]                           invokeRestart("muffleWarning")
[17:46:36.977]                       }
[17:46:36.977]                       else if (inherits(cond, "condition")) {
[17:46:36.977]                         if (!is.null(pattern)) {
[17:46:36.977]                           computeRestarts <- base::computeRestarts
[17:46:36.977]                           grepl <- base::grepl
[17:46:36.977]                           restarts <- computeRestarts(cond)
[17:46:36.977]                           for (restart in restarts) {
[17:46:36.977]                             name <- restart$name
[17:46:36.977]                             if (is.null(name)) 
[17:46:36.977]                               next
[17:46:36.977]                             if (!grepl(pattern, name)) 
[17:46:36.977]                               next
[17:46:36.977]                             invokeRestart(restart)
[17:46:36.977]                             muffled <- TRUE
[17:46:36.977]                             break
[17:46:36.977]                           }
[17:46:36.977]                         }
[17:46:36.977]                       }
[17:46:36.977]                       invisible(muffled)
[17:46:36.977]                     }
[17:46:36.977]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.977]                   }
[17:46:36.977]                 }
[17:46:36.977]                 else {
[17:46:36.977]                   if (TRUE) {
[17:46:36.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:36.977]                     {
[17:46:36.977]                       inherits <- base::inherits
[17:46:36.977]                       invokeRestart <- base::invokeRestart
[17:46:36.977]                       is.null <- base::is.null
[17:46:36.977]                       muffled <- FALSE
[17:46:36.977]                       if (inherits(cond, "message")) {
[17:46:36.977]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:36.977]                         if (muffled) 
[17:46:36.977]                           invokeRestart("muffleMessage")
[17:46:36.977]                       }
[17:46:36.977]                       else if (inherits(cond, "warning")) {
[17:46:36.977]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:36.977]                         if (muffled) 
[17:46:36.977]                           invokeRestart("muffleWarning")
[17:46:36.977]                       }
[17:46:36.977]                       else if (inherits(cond, "condition")) {
[17:46:36.977]                         if (!is.null(pattern)) {
[17:46:36.977]                           computeRestarts <- base::computeRestarts
[17:46:36.977]                           grepl <- base::grepl
[17:46:36.977]                           restarts <- computeRestarts(cond)
[17:46:36.977]                           for (restart in restarts) {
[17:46:36.977]                             name <- restart$name
[17:46:36.977]                             if (is.null(name)) 
[17:46:36.977]                               next
[17:46:36.977]                             if (!grepl(pattern, name)) 
[17:46:36.977]                               next
[17:46:36.977]                             invokeRestart(restart)
[17:46:36.977]                             muffled <- TRUE
[17:46:36.977]                             break
[17:46:36.977]                           }
[17:46:36.977]                         }
[17:46:36.977]                       }
[17:46:36.977]                       invisible(muffled)
[17:46:36.977]                     }
[17:46:36.977]                     muffleCondition(cond, pattern = "^muffle")
[17:46:36.977]                   }
[17:46:36.977]                 }
[17:46:36.977]             }
[17:46:36.977]         }))
[17:46:36.977]     }, error = function(ex) {
[17:46:36.977]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:36.977]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:36.977]                 ...future.rng), started = ...future.startTime, 
[17:46:36.977]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:36.977]             version = "1.8"), class = "FutureResult")
[17:46:36.977]     }, finally = {
[17:46:36.977]         if (!identical(...future.workdir, getwd())) 
[17:46:36.977]             setwd(...future.workdir)
[17:46:36.977]         {
[17:46:36.977]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:36.977]                 ...future.oldOptions$nwarnings <- NULL
[17:46:36.977]             }
[17:46:36.977]             base::options(...future.oldOptions)
[17:46:36.977]             if (.Platform$OS.type == "windows") {
[17:46:36.977]                 old_names <- names(...future.oldEnvVars)
[17:46:36.977]                 envs <- base::Sys.getenv()
[17:46:36.977]                 names <- names(envs)
[17:46:36.977]                 common <- intersect(names, old_names)
[17:46:36.977]                 added <- setdiff(names, old_names)
[17:46:36.977]                 removed <- setdiff(old_names, names)
[17:46:36.977]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:36.977]                   envs[common]]
[17:46:36.977]                 NAMES <- toupper(changed)
[17:46:36.977]                 args <- list()
[17:46:36.977]                 for (kk in seq_along(NAMES)) {
[17:46:36.977]                   name <- changed[[kk]]
[17:46:36.977]                   NAME <- NAMES[[kk]]
[17:46:36.977]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.977]                     next
[17:46:36.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.977]                 }
[17:46:36.977]                 NAMES <- toupper(added)
[17:46:36.977]                 for (kk in seq_along(NAMES)) {
[17:46:36.977]                   name <- added[[kk]]
[17:46:36.977]                   NAME <- NAMES[[kk]]
[17:46:36.977]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.977]                     next
[17:46:36.977]                   args[[name]] <- ""
[17:46:36.977]                 }
[17:46:36.977]                 NAMES <- toupper(removed)
[17:46:36.977]                 for (kk in seq_along(NAMES)) {
[17:46:36.977]                   name <- removed[[kk]]
[17:46:36.977]                   NAME <- NAMES[[kk]]
[17:46:36.977]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:36.977]                     next
[17:46:36.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:36.977]                 }
[17:46:36.977]                 if (length(args) > 0) 
[17:46:36.977]                   base::do.call(base::Sys.setenv, args = args)
[17:46:36.977]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:36.977]             }
[17:46:36.977]             else {
[17:46:36.977]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:36.977]             }
[17:46:36.977]             {
[17:46:36.977]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:36.977]                   0L) {
[17:46:36.977]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:36.977]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:36.977]                   base::options(opts)
[17:46:36.977]                 }
[17:46:36.977]                 {
[17:46:36.977]                   {
[17:46:36.977]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:36.977]                     NULL
[17:46:36.977]                   }
[17:46:36.977]                   options(future.plan = NULL)
[17:46:36.977]                   if (is.na(NA_character_)) 
[17:46:36.977]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:36.977]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:36.977]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:36.977]                     .init = FALSE)
[17:46:36.977]                 }
[17:46:36.977]             }
[17:46:36.977]         }
[17:46:36.977]     })
[17:46:36.977]     if (TRUE) {
[17:46:36.977]         base::sink(type = "output", split = FALSE)
[17:46:36.977]         if (TRUE) {
[17:46:36.977]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:36.977]         }
[17:46:36.977]         else {
[17:46:36.977]             ...future.result["stdout"] <- base::list(NULL)
[17:46:36.977]         }
[17:46:36.977]         base::close(...future.stdout)
[17:46:36.977]         ...future.stdout <- NULL
[17:46:36.977]     }
[17:46:36.977]     ...future.result$conditions <- ...future.conditions
[17:46:36.977]     ...future.result$finished <- base::Sys.time()
[17:46:36.977]     ...future.result
[17:46:36.977] }
[17:46:36.979] assign_globals() ...
[17:46:36.980] List of 1
[17:46:36.980]  $ a: num 10
[17:46:36.980]  - attr(*, "where")=List of 1
[17:46:36.980]   ..$ a:<environment: R_EmptyEnv> 
[17:46:36.980]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:36.980]  - attr(*, "resolved")= logi FALSE
[17:46:36.980]  - attr(*, "total_size")= num 56
[17:46:36.980]  - attr(*, "already-done")= logi TRUE
[17:46:36.982] - copied ‘a’ to environment
[17:46:36.982] assign_globals() ... done
[17:46:36.982] requestCore(): workers = 2
[17:46:36.984] MulticoreFuture started
[17:46:36.985] - Launch lazy future ... done
[17:46:36.985] run() for ‘MulticoreFuture’ ... done
[17:46:36.985] result() for MulticoreFuture ...
[17:46:36.985] plan(): Setting new future strategy stack:
[17:46:36.986] List of future strategies:
[17:46:36.986] 1. sequential:
[17:46:36.986]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:36.986]    - tweaked: FALSE
[17:46:36.986]    - call: NULL
[17:46:36.987] plan(): nbrOfWorkers() = 1
[17:46:36.988] plan(): Setting new future strategy stack:
[17:46:36.989] List of future strategies:
[17:46:36.989] 1. multicore:
[17:46:36.989]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:36.989]    - tweaked: FALSE
[17:46:36.989]    - call: plan(strategy)
[17:46:36.994] plan(): nbrOfWorkers() = 2
[17:46:36.995] result() for MulticoreFuture ...
[17:46:36.995] result() for MulticoreFuture ... done
[17:46:36.995] result() for MulticoreFuture ... done
[17:46:36.995] result() for MulticoreFuture ...
[17:46:36.995] result() for MulticoreFuture ... done
b = 11
*** %<-% with ‘multicore’ futures ... DONE
*** %<-% with ‘multisession’ futures ...
[17:46:36.996] plan(): Setting new future strategy stack:
[17:46:36.996] List of future strategies:
[17:46:36.996] 1. multisession:
[17:46:36.996]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:46:36.996]    - tweaked: FALSE
[17:46:36.996]    - call: plan(strategy)
[17:46:36.997] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:46:36.997] multisession:
[17:46:36.997] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:46:36.997] - tweaked: FALSE
[17:46:36.997] - call: plan(strategy)
[17:46:37.004] getGlobalsAndPackages() ...
[17:46:37.004] Not searching for globals
[17:46:37.004] - globals: [0] <none>
[17:46:37.004] getGlobalsAndPackages() ... DONE
[17:46:37.005] [local output] makeClusterPSOCK() ...
[17:46:37.051] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:46:37.052] [local output] Base port: 11488
[17:46:37.053] [local output] Getting setup options for 2 cluster nodes ...
[17:46:37.053] [local output]  - Node 1 of 2 ...
[17:46:37.053] [local output] localMachine=TRUE => revtunnel=FALSE

[17:46:37.054] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpzxgiTZ/worker.rank=1.parallelly.parent=41206.a0f664526891.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpzxgiTZ/worker.rank=1.parallelly.parent=41206.a0f664526891.pid")'’
[17:46:37.242] - Possible to infer worker's PID: TRUE
[17:46:37.242] [local output] Rscript port: 11488

[17:46:37.243] [local output]  - Node 2 of 2 ...
[17:46:37.243] [local output] localMachine=TRUE => revtunnel=FALSE

[17:46:37.244] [local output] Rscript port: 11488

[17:46:37.244] [local output] Getting setup options for 2 cluster nodes ... done
[17:46:37.244] [local output]  - Parallel setup requested for some PSOCK nodes
[17:46:37.245] [local output] Setting up PSOCK nodes in parallel
[17:46:37.245] List of 36
[17:46:37.245]  $ worker          : chr "localhost"
[17:46:37.245]   ..- attr(*, "localhost")= logi TRUE
[17:46:37.245]  $ master          : chr "localhost"
[17:46:37.245]  $ port            : int 11488
[17:46:37.245]  $ connectTimeout  : num 120
[17:46:37.245]  $ timeout         : num 2592000
[17:46:37.245]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:46:37.245]  $ homogeneous     : logi TRUE
[17:46:37.245]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:46:37.245]  $ rscript_envs    : NULL
[17:46:37.245]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:46:37.245]  $ rscript_startup : NULL
[17:46:37.245]  $ rscript_sh      : chr "sh"
[17:46:37.245]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:46:37.245]  $ methods         : logi TRUE
[17:46:37.245]  $ socketOptions   : chr "no-delay"
[17:46:37.245]  $ useXDR          : logi FALSE
[17:46:37.245]  $ outfile         : chr "/dev/null"
[17:46:37.245]  $ renice          : int NA
[17:46:37.245]  $ rshcmd          : NULL
[17:46:37.245]  $ user            : chr(0) 
[17:46:37.245]  $ revtunnel       : logi FALSE
[17:46:37.245]  $ rshlogfile      : NULL
[17:46:37.245]  $ rshopts         : chr(0) 
[17:46:37.245]  $ rank            : int 1
[17:46:37.245]  $ manual          : logi FALSE
[17:46:37.245]  $ dryrun          : logi FALSE
[17:46:37.245]  $ quiet           : logi FALSE
[17:46:37.245]  $ setup_strategy  : chr "parallel"
[17:46:37.245]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:46:37.245]  $ pidfile         : chr "/tmp/RtmpzxgiTZ/worker.rank=1.parallelly.parent=41206.a0f664526891.pid"
[17:46:37.245]  $ rshcmd_label    : NULL
[17:46:37.245]  $ rsh_call        : NULL
[17:46:37.245]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:46:37.245]  $ localMachine    : logi TRUE
[17:46:37.245]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:46:37.245]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:46:37.245]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:46:37.245]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:46:37.245]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:46:37.245]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:46:37.245]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:46:37.245]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:46:37.245]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:46:37.245]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:46:37.245]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:46:37.245]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:46:37.245]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:46:37.245]  $ arguments       :List of 28
[17:46:37.245]   ..$ worker          : chr "localhost"
[17:46:37.245]   ..$ master          : NULL
[17:46:37.245]   ..$ port            : int 11488
[17:46:37.245]   ..$ connectTimeout  : num 120
[17:46:37.245]   ..$ timeout         : num 2592000
[17:46:37.245]   ..$ rscript         : NULL
[17:46:37.245]   ..$ homogeneous     : NULL
[17:46:37.245]   ..$ rscript_args    : NULL
[17:46:37.245]   ..$ rscript_envs    : NULL
[17:46:37.245]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:46:37.245]   ..$ rscript_startup : NULL
[17:46:37.245]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:46:37.245]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:46:37.245]   ..$ methods         : logi TRUE
[17:46:37.245]   ..$ socketOptions   : chr "no-delay"
[17:46:37.245]   ..$ useXDR          : logi FALSE
[17:46:37.245]   ..$ outfile         : chr "/dev/null"
[17:46:37.245]   ..$ renice          : int NA
[17:46:37.245]   ..$ rshcmd          : NULL
[17:46:37.245]   ..$ user            : NULL
[17:46:37.245]   ..$ revtunnel       : logi NA
[17:46:37.245]   ..$ rshlogfile      : NULL
[17:46:37.245]   ..$ rshopts         : NULL
[17:46:37.245]   ..$ rank            : int 1
[17:46:37.245]   ..$ manual          : logi FALSE
[17:46:37.245]   ..$ dryrun          : logi FALSE
[17:46:37.245]   ..$ quiet           : logi FALSE
[17:46:37.245]   ..$ setup_strategy  : chr "parallel"
[17:46:37.245]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:46:37.261] [local output] System call to launch all workers:
[17:46:37.261] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpzxgiTZ/worker.rank=1.parallelly.parent=41206.a0f664526891.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11488 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:46:37.262] [local output] Starting PSOCK main server
[17:46:37.267] [local output] Workers launched
[17:46:37.267] [local output] Waiting for workers to connect back
[17:46:37.268]  - [local output] 0 workers out of 2 ready
[17:46:37.503]  - [local output] 0 workers out of 2 ready
[17:46:37.503]  - [local output] 1 workers out of 2 ready
[17:46:37.513]  - [local output] 1 workers out of 2 ready
[17:46:37.513]  - [local output] 2 workers out of 2 ready
[17:46:37.513] [local output] Launching of workers completed
[17:46:37.513] [local output] Collecting session information from workers
[17:46:37.514] [local output]  - Worker #1 of 2
[17:46:37.515] [local output]  - Worker #2 of 2
[17:46:37.515] [local output] makeClusterPSOCK() ... done
[17:46:37.526] Packages needed by the future expression (n = 0): <none>
[17:46:37.526] Packages needed by future strategies (n = 0): <none>
[17:46:37.527] {
[17:46:37.527]     {
[17:46:37.527]         {
[17:46:37.527]             ...future.startTime <- base::Sys.time()
[17:46:37.527]             {
[17:46:37.527]                 {
[17:46:37.527]                   {
[17:46:37.527]                     {
[17:46:37.527]                       base::local({
[17:46:37.527]                         has_future <- base::requireNamespace("future", 
[17:46:37.527]                           quietly = TRUE)
[17:46:37.527]                         if (has_future) {
[17:46:37.527]                           ns <- base::getNamespace("future")
[17:46:37.527]                           version <- ns[[".package"]][["version"]]
[17:46:37.527]                           if (is.null(version)) 
[17:46:37.527]                             version <- utils::packageVersion("future")
[17:46:37.527]                         }
[17:46:37.527]                         else {
[17:46:37.527]                           version <- NULL
[17:46:37.527]                         }
[17:46:37.527]                         if (!has_future || version < "1.8.0") {
[17:46:37.527]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:37.527]                             "", base::R.version$version.string), 
[17:46:37.527]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:37.527]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:37.527]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:37.527]                               "release", "version")], collapse = " "), 
[17:46:37.527]                             hostname = base::Sys.info()[["nodename"]])
[17:46:37.527]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:37.527]                             info)
[17:46:37.527]                           info <- base::paste(info, collapse = "; ")
[17:46:37.527]                           if (!has_future) {
[17:46:37.527]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:37.527]                               info)
[17:46:37.527]                           }
[17:46:37.527]                           else {
[17:46:37.527]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:37.527]                               info, version)
[17:46:37.527]                           }
[17:46:37.527]                           base::stop(msg)
[17:46:37.527]                         }
[17:46:37.527]                       })
[17:46:37.527]                     }
[17:46:37.527]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:37.527]                     base::options(mc.cores = 1L)
[17:46:37.527]                   }
[17:46:37.527]                   ...future.strategy.old <- future::plan("list")
[17:46:37.527]                   options(future.plan = NULL)
[17:46:37.527]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.527]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:37.527]                 }
[17:46:37.527]                 ...future.workdir <- getwd()
[17:46:37.527]             }
[17:46:37.527]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:37.527]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:37.527]         }
[17:46:37.527]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:37.527]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:37.527]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:37.527]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:37.527]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:37.527]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:37.527]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:37.527]             base::names(...future.oldOptions))
[17:46:37.527]     }
[17:46:37.527]     if (FALSE) {
[17:46:37.527]     }
[17:46:37.527]     else {
[17:46:37.527]         if (TRUE) {
[17:46:37.527]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:37.527]                 open = "w")
[17:46:37.527]         }
[17:46:37.527]         else {
[17:46:37.527]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:37.527]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:37.527]         }
[17:46:37.527]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:37.527]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:37.527]             base::sink(type = "output", split = FALSE)
[17:46:37.527]             base::close(...future.stdout)
[17:46:37.527]         }, add = TRUE)
[17:46:37.527]     }
[17:46:37.527]     ...future.frame <- base::sys.nframe()
[17:46:37.527]     ...future.conditions <- base::list()
[17:46:37.527]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:37.527]     if (FALSE) {
[17:46:37.527]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:37.527]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:37.527]     }
[17:46:37.527]     ...future.result <- base::tryCatch({
[17:46:37.527]         base::withCallingHandlers({
[17:46:37.527]             ...future.value <- base::withVisible(base::local({
[17:46:37.527]                 ...future.makeSendCondition <- base::local({
[17:46:37.527]                   sendCondition <- NULL
[17:46:37.527]                   function(frame = 1L) {
[17:46:37.527]                     if (is.function(sendCondition)) 
[17:46:37.527]                       return(sendCondition)
[17:46:37.527]                     ns <- getNamespace("parallel")
[17:46:37.527]                     if (exists("sendData", mode = "function", 
[17:46:37.527]                       envir = ns)) {
[17:46:37.527]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:37.527]                         envir = ns)
[17:46:37.527]                       envir <- sys.frame(frame)
[17:46:37.527]                       master <- NULL
[17:46:37.527]                       while (!identical(envir, .GlobalEnv) && 
[17:46:37.527]                         !identical(envir, emptyenv())) {
[17:46:37.527]                         if (exists("master", mode = "list", envir = envir, 
[17:46:37.527]                           inherits = FALSE)) {
[17:46:37.527]                           master <- get("master", mode = "list", 
[17:46:37.527]                             envir = envir, inherits = FALSE)
[17:46:37.527]                           if (inherits(master, c("SOCKnode", 
[17:46:37.527]                             "SOCK0node"))) {
[17:46:37.527]                             sendCondition <<- function(cond) {
[17:46:37.527]                               data <- list(type = "VALUE", value = cond, 
[17:46:37.527]                                 success = TRUE)
[17:46:37.527]                               parallel_sendData(master, data)
[17:46:37.527]                             }
[17:46:37.527]                             return(sendCondition)
[17:46:37.527]                           }
[17:46:37.527]                         }
[17:46:37.527]                         frame <- frame + 1L
[17:46:37.527]                         envir <- sys.frame(frame)
[17:46:37.527]                       }
[17:46:37.527]                     }
[17:46:37.527]                     sendCondition <<- function(cond) NULL
[17:46:37.527]                   }
[17:46:37.527]                 })
[17:46:37.527]                 withCallingHandlers({
[17:46:37.527]                   NA
[17:46:37.527]                 }, immediateCondition = function(cond) {
[17:46:37.527]                   sendCondition <- ...future.makeSendCondition()
[17:46:37.527]                   sendCondition(cond)
[17:46:37.527]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.527]                   {
[17:46:37.527]                     inherits <- base::inherits
[17:46:37.527]                     invokeRestart <- base::invokeRestart
[17:46:37.527]                     is.null <- base::is.null
[17:46:37.527]                     muffled <- FALSE
[17:46:37.527]                     if (inherits(cond, "message")) {
[17:46:37.527]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:37.527]                       if (muffled) 
[17:46:37.527]                         invokeRestart("muffleMessage")
[17:46:37.527]                     }
[17:46:37.527]                     else if (inherits(cond, "warning")) {
[17:46:37.527]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:37.527]                       if (muffled) 
[17:46:37.527]                         invokeRestart("muffleWarning")
[17:46:37.527]                     }
[17:46:37.527]                     else if (inherits(cond, "condition")) {
[17:46:37.527]                       if (!is.null(pattern)) {
[17:46:37.527]                         computeRestarts <- base::computeRestarts
[17:46:37.527]                         grepl <- base::grepl
[17:46:37.527]                         restarts <- computeRestarts(cond)
[17:46:37.527]                         for (restart in restarts) {
[17:46:37.527]                           name <- restart$name
[17:46:37.527]                           if (is.null(name)) 
[17:46:37.527]                             next
[17:46:37.527]                           if (!grepl(pattern, name)) 
[17:46:37.527]                             next
[17:46:37.527]                           invokeRestart(restart)
[17:46:37.527]                           muffled <- TRUE
[17:46:37.527]                           break
[17:46:37.527]                         }
[17:46:37.527]                       }
[17:46:37.527]                     }
[17:46:37.527]                     invisible(muffled)
[17:46:37.527]                   }
[17:46:37.527]                   muffleCondition(cond)
[17:46:37.527]                 })
[17:46:37.527]             }))
[17:46:37.527]             future::FutureResult(value = ...future.value$value, 
[17:46:37.527]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.527]                   ...future.rng), globalenv = if (FALSE) 
[17:46:37.527]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:37.527]                     ...future.globalenv.names))
[17:46:37.527]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:37.527]         }, condition = base::local({
[17:46:37.527]             c <- base::c
[17:46:37.527]             inherits <- base::inherits
[17:46:37.527]             invokeRestart <- base::invokeRestart
[17:46:37.527]             length <- base::length
[17:46:37.527]             list <- base::list
[17:46:37.527]             seq.int <- base::seq.int
[17:46:37.527]             signalCondition <- base::signalCondition
[17:46:37.527]             sys.calls <- base::sys.calls
[17:46:37.527]             `[[` <- base::`[[`
[17:46:37.527]             `+` <- base::`+`
[17:46:37.527]             `<<-` <- base::`<<-`
[17:46:37.527]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:37.527]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:37.527]                   3L)]
[17:46:37.527]             }
[17:46:37.527]             function(cond) {
[17:46:37.527]                 is_error <- inherits(cond, "error")
[17:46:37.527]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:37.527]                   NULL)
[17:46:37.527]                 if (is_error) {
[17:46:37.527]                   sessionInformation <- function() {
[17:46:37.527]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:37.527]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:37.527]                       search = base::search(), system = base::Sys.info())
[17:46:37.527]                   }
[17:46:37.527]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.527]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:37.527]                     cond$call), session = sessionInformation(), 
[17:46:37.527]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:37.527]                   signalCondition(cond)
[17:46:37.527]                 }
[17:46:37.527]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:37.527]                 "immediateCondition"))) {
[17:46:37.527]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:37.527]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.527]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:37.527]                   if (TRUE && !signal) {
[17:46:37.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.527]                     {
[17:46:37.527]                       inherits <- base::inherits
[17:46:37.527]                       invokeRestart <- base::invokeRestart
[17:46:37.527]                       is.null <- base::is.null
[17:46:37.527]                       muffled <- FALSE
[17:46:37.527]                       if (inherits(cond, "message")) {
[17:46:37.527]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.527]                         if (muffled) 
[17:46:37.527]                           invokeRestart("muffleMessage")
[17:46:37.527]                       }
[17:46:37.527]                       else if (inherits(cond, "warning")) {
[17:46:37.527]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.527]                         if (muffled) 
[17:46:37.527]                           invokeRestart("muffleWarning")
[17:46:37.527]                       }
[17:46:37.527]                       else if (inherits(cond, "condition")) {
[17:46:37.527]                         if (!is.null(pattern)) {
[17:46:37.527]                           computeRestarts <- base::computeRestarts
[17:46:37.527]                           grepl <- base::grepl
[17:46:37.527]                           restarts <- computeRestarts(cond)
[17:46:37.527]                           for (restart in restarts) {
[17:46:37.527]                             name <- restart$name
[17:46:37.527]                             if (is.null(name)) 
[17:46:37.527]                               next
[17:46:37.527]                             if (!grepl(pattern, name)) 
[17:46:37.527]                               next
[17:46:37.527]                             invokeRestart(restart)
[17:46:37.527]                             muffled <- TRUE
[17:46:37.527]                             break
[17:46:37.527]                           }
[17:46:37.527]                         }
[17:46:37.527]                       }
[17:46:37.527]                       invisible(muffled)
[17:46:37.527]                     }
[17:46:37.527]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.527]                   }
[17:46:37.527]                 }
[17:46:37.527]                 else {
[17:46:37.527]                   if (TRUE) {
[17:46:37.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.527]                     {
[17:46:37.527]                       inherits <- base::inherits
[17:46:37.527]                       invokeRestart <- base::invokeRestart
[17:46:37.527]                       is.null <- base::is.null
[17:46:37.527]                       muffled <- FALSE
[17:46:37.527]                       if (inherits(cond, "message")) {
[17:46:37.527]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.527]                         if (muffled) 
[17:46:37.527]                           invokeRestart("muffleMessage")
[17:46:37.527]                       }
[17:46:37.527]                       else if (inherits(cond, "warning")) {
[17:46:37.527]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.527]                         if (muffled) 
[17:46:37.527]                           invokeRestart("muffleWarning")
[17:46:37.527]                       }
[17:46:37.527]                       else if (inherits(cond, "condition")) {
[17:46:37.527]                         if (!is.null(pattern)) {
[17:46:37.527]                           computeRestarts <- base::computeRestarts
[17:46:37.527]                           grepl <- base::grepl
[17:46:37.527]                           restarts <- computeRestarts(cond)
[17:46:37.527]                           for (restart in restarts) {
[17:46:37.527]                             name <- restart$name
[17:46:37.527]                             if (is.null(name)) 
[17:46:37.527]                               next
[17:46:37.527]                             if (!grepl(pattern, name)) 
[17:46:37.527]                               next
[17:46:37.527]                             invokeRestart(restart)
[17:46:37.527]                             muffled <- TRUE
[17:46:37.527]                             break
[17:46:37.527]                           }
[17:46:37.527]                         }
[17:46:37.527]                       }
[17:46:37.527]                       invisible(muffled)
[17:46:37.527]                     }
[17:46:37.527]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.527]                   }
[17:46:37.527]                 }
[17:46:37.527]             }
[17:46:37.527]         }))
[17:46:37.527]     }, error = function(ex) {
[17:46:37.527]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:37.527]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.527]                 ...future.rng), started = ...future.startTime, 
[17:46:37.527]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:37.527]             version = "1.8"), class = "FutureResult")
[17:46:37.527]     }, finally = {
[17:46:37.527]         if (!identical(...future.workdir, getwd())) 
[17:46:37.527]             setwd(...future.workdir)
[17:46:37.527]         {
[17:46:37.527]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:37.527]                 ...future.oldOptions$nwarnings <- NULL
[17:46:37.527]             }
[17:46:37.527]             base::options(...future.oldOptions)
[17:46:37.527]             if (.Platform$OS.type == "windows") {
[17:46:37.527]                 old_names <- names(...future.oldEnvVars)
[17:46:37.527]                 envs <- base::Sys.getenv()
[17:46:37.527]                 names <- names(envs)
[17:46:37.527]                 common <- intersect(names, old_names)
[17:46:37.527]                 added <- setdiff(names, old_names)
[17:46:37.527]                 removed <- setdiff(old_names, names)
[17:46:37.527]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:37.527]                   envs[common]]
[17:46:37.527]                 NAMES <- toupper(changed)
[17:46:37.527]                 args <- list()
[17:46:37.527]                 for (kk in seq_along(NAMES)) {
[17:46:37.527]                   name <- changed[[kk]]
[17:46:37.527]                   NAME <- NAMES[[kk]]
[17:46:37.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.527]                     next
[17:46:37.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.527]                 }
[17:46:37.527]                 NAMES <- toupper(added)
[17:46:37.527]                 for (kk in seq_along(NAMES)) {
[17:46:37.527]                   name <- added[[kk]]
[17:46:37.527]                   NAME <- NAMES[[kk]]
[17:46:37.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.527]                     next
[17:46:37.527]                   args[[name]] <- ""
[17:46:37.527]                 }
[17:46:37.527]                 NAMES <- toupper(removed)
[17:46:37.527]                 for (kk in seq_along(NAMES)) {
[17:46:37.527]                   name <- removed[[kk]]
[17:46:37.527]                   NAME <- NAMES[[kk]]
[17:46:37.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.527]                     next
[17:46:37.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.527]                 }
[17:46:37.527]                 if (length(args) > 0) 
[17:46:37.527]                   base::do.call(base::Sys.setenv, args = args)
[17:46:37.527]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:37.527]             }
[17:46:37.527]             else {
[17:46:37.527]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:37.527]             }
[17:46:37.527]             {
[17:46:37.527]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:37.527]                   0L) {
[17:46:37.527]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:37.527]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:37.527]                   base::options(opts)
[17:46:37.527]                 }
[17:46:37.527]                 {
[17:46:37.527]                   {
[17:46:37.527]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:37.527]                     NULL
[17:46:37.527]                   }
[17:46:37.527]                   options(future.plan = NULL)
[17:46:37.527]                   if (is.na(NA_character_)) 
[17:46:37.527]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.527]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:37.527]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:37.527]                     .init = FALSE)
[17:46:37.527]                 }
[17:46:37.527]             }
[17:46:37.527]         }
[17:46:37.527]     })
[17:46:37.527]     if (TRUE) {
[17:46:37.527]         base::sink(type = "output", split = FALSE)
[17:46:37.527]         if (TRUE) {
[17:46:37.527]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:37.527]         }
[17:46:37.527]         else {
[17:46:37.527]             ...future.result["stdout"] <- base::list(NULL)
[17:46:37.527]         }
[17:46:37.527]         base::close(...future.stdout)
[17:46:37.527]         ...future.stdout <- NULL
[17:46:37.527]     }
[17:46:37.527]     ...future.result$conditions <- ...future.conditions
[17:46:37.527]     ...future.result$finished <- base::Sys.time()
[17:46:37.527]     ...future.result
[17:46:37.527] }
[17:46:37.580] MultisessionFuture started
[17:46:37.581] result() for ClusterFuture ...
[17:46:37.581] receiveMessageFromWorker() for ClusterFuture ...
[17:46:37.582] - Validating connection of MultisessionFuture
[17:46:37.613] - received message: FutureResult
[17:46:37.614] - Received FutureResult
[17:46:37.614] - Erased future from FutureRegistry
[17:46:37.614] result() for ClusterFuture ...
[17:46:37.614] - result already collected: FutureResult
[17:46:37.614] result() for ClusterFuture ... done
[17:46:37.614] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:37.614] result() for ClusterFuture ... done
[17:46:37.614] result() for ClusterFuture ...
[17:46:37.615] - result already collected: FutureResult
[17:46:37.615] result() for ClusterFuture ... done
[17:46:37.615] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:46:37.619] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[17:46:37.619] getGlobalsAndPackages() ...
[17:46:37.619] Searching for globals...
[17:46:37.621] - globals found: [2] ‘{’, ‘<-’
[17:46:37.621] Searching for globals ... DONE
[17:46:37.621] Resolving globals: FALSE
[17:46:37.621] 
[17:46:37.621] 
[17:46:37.622] getGlobalsAndPackages() ... DONE
[17:46:37.622] run() for ‘Future’ ...
[17:46:37.622] - state: ‘created’
[17:46:37.622] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:37.636] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:37.636] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:37.636]   - Field: ‘node’
[17:46:37.637]   - Field: ‘label’
[17:46:37.637]   - Field: ‘local’
[17:46:37.637]   - Field: ‘owner’
[17:46:37.637]   - Field: ‘envir’
[17:46:37.637]   - Field: ‘workers’
[17:46:37.637]   - Field: ‘packages’
[17:46:37.637]   - Field: ‘gc’
[17:46:37.637]   - Field: ‘conditions’
[17:46:37.637]   - Field: ‘persistent’
[17:46:37.637]   - Field: ‘expr’
[17:46:37.638]   - Field: ‘uuid’
[17:46:37.638]   - Field: ‘seed’
[17:46:37.638]   - Field: ‘version’
[17:46:37.638]   - Field: ‘result’
[17:46:37.638]   - Field: ‘asynchronous’
[17:46:37.638]   - Field: ‘calls’
[17:46:37.638]   - Field: ‘globals’
[17:46:37.638]   - Field: ‘stdout’
[17:46:37.638]   - Field: ‘earlySignal’
[17:46:37.639]   - Field: ‘lazy’
[17:46:37.639]   - Field: ‘state’
[17:46:37.639] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:37.639] - Launch lazy future ...
[17:46:37.639] Packages needed by the future expression (n = 0): <none>
[17:46:37.639] Packages needed by future strategies (n = 0): <none>
[17:46:37.640] {
[17:46:37.640]     {
[17:46:37.640]         {
[17:46:37.640]             ...future.startTime <- base::Sys.time()
[17:46:37.640]             {
[17:46:37.640]                 {
[17:46:37.640]                   {
[17:46:37.640]                     {
[17:46:37.640]                       base::local({
[17:46:37.640]                         has_future <- base::requireNamespace("future", 
[17:46:37.640]                           quietly = TRUE)
[17:46:37.640]                         if (has_future) {
[17:46:37.640]                           ns <- base::getNamespace("future")
[17:46:37.640]                           version <- ns[[".package"]][["version"]]
[17:46:37.640]                           if (is.null(version)) 
[17:46:37.640]                             version <- utils::packageVersion("future")
[17:46:37.640]                         }
[17:46:37.640]                         else {
[17:46:37.640]                           version <- NULL
[17:46:37.640]                         }
[17:46:37.640]                         if (!has_future || version < "1.8.0") {
[17:46:37.640]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:37.640]                             "", base::R.version$version.string), 
[17:46:37.640]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:37.640]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:37.640]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:37.640]                               "release", "version")], collapse = " "), 
[17:46:37.640]                             hostname = base::Sys.info()[["nodename"]])
[17:46:37.640]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:37.640]                             info)
[17:46:37.640]                           info <- base::paste(info, collapse = "; ")
[17:46:37.640]                           if (!has_future) {
[17:46:37.640]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:37.640]                               info)
[17:46:37.640]                           }
[17:46:37.640]                           else {
[17:46:37.640]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:37.640]                               info, version)
[17:46:37.640]                           }
[17:46:37.640]                           base::stop(msg)
[17:46:37.640]                         }
[17:46:37.640]                       })
[17:46:37.640]                     }
[17:46:37.640]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:37.640]                     base::options(mc.cores = 1L)
[17:46:37.640]                   }
[17:46:37.640]                   ...future.strategy.old <- future::plan("list")
[17:46:37.640]                   options(future.plan = NULL)
[17:46:37.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:37.640]                 }
[17:46:37.640]                 ...future.workdir <- getwd()
[17:46:37.640]             }
[17:46:37.640]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:37.640]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:37.640]         }
[17:46:37.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:37.640]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:37.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:37.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:37.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:37.640]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:37.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:37.640]             base::names(...future.oldOptions))
[17:46:37.640]     }
[17:46:37.640]     if (FALSE) {
[17:46:37.640]     }
[17:46:37.640]     else {
[17:46:37.640]         if (TRUE) {
[17:46:37.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:37.640]                 open = "w")
[17:46:37.640]         }
[17:46:37.640]         else {
[17:46:37.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:37.640]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:37.640]         }
[17:46:37.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:37.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:37.640]             base::sink(type = "output", split = FALSE)
[17:46:37.640]             base::close(...future.stdout)
[17:46:37.640]         }, add = TRUE)
[17:46:37.640]     }
[17:46:37.640]     ...future.frame <- base::sys.nframe()
[17:46:37.640]     ...future.conditions <- base::list()
[17:46:37.640]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:37.640]     if (FALSE) {
[17:46:37.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:37.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:37.640]     }
[17:46:37.640]     ...future.result <- base::tryCatch({
[17:46:37.640]         base::withCallingHandlers({
[17:46:37.640]             ...future.value <- base::withVisible(base::local({
[17:46:37.640]                 ...future.makeSendCondition <- base::local({
[17:46:37.640]                   sendCondition <- NULL
[17:46:37.640]                   function(frame = 1L) {
[17:46:37.640]                     if (is.function(sendCondition)) 
[17:46:37.640]                       return(sendCondition)
[17:46:37.640]                     ns <- getNamespace("parallel")
[17:46:37.640]                     if (exists("sendData", mode = "function", 
[17:46:37.640]                       envir = ns)) {
[17:46:37.640]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:37.640]                         envir = ns)
[17:46:37.640]                       envir <- sys.frame(frame)
[17:46:37.640]                       master <- NULL
[17:46:37.640]                       while (!identical(envir, .GlobalEnv) && 
[17:46:37.640]                         !identical(envir, emptyenv())) {
[17:46:37.640]                         if (exists("master", mode = "list", envir = envir, 
[17:46:37.640]                           inherits = FALSE)) {
[17:46:37.640]                           master <- get("master", mode = "list", 
[17:46:37.640]                             envir = envir, inherits = FALSE)
[17:46:37.640]                           if (inherits(master, c("SOCKnode", 
[17:46:37.640]                             "SOCK0node"))) {
[17:46:37.640]                             sendCondition <<- function(cond) {
[17:46:37.640]                               data <- list(type = "VALUE", value = cond, 
[17:46:37.640]                                 success = TRUE)
[17:46:37.640]                               parallel_sendData(master, data)
[17:46:37.640]                             }
[17:46:37.640]                             return(sendCondition)
[17:46:37.640]                           }
[17:46:37.640]                         }
[17:46:37.640]                         frame <- frame + 1L
[17:46:37.640]                         envir <- sys.frame(frame)
[17:46:37.640]                       }
[17:46:37.640]                     }
[17:46:37.640]                     sendCondition <<- function(cond) NULL
[17:46:37.640]                   }
[17:46:37.640]                 })
[17:46:37.640]                 withCallingHandlers({
[17:46:37.640]                   {
[17:46:37.640]                     x <- 1
[17:46:37.640]                   }
[17:46:37.640]                 }, immediateCondition = function(cond) {
[17:46:37.640]                   sendCondition <- ...future.makeSendCondition()
[17:46:37.640]                   sendCondition(cond)
[17:46:37.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.640]                   {
[17:46:37.640]                     inherits <- base::inherits
[17:46:37.640]                     invokeRestart <- base::invokeRestart
[17:46:37.640]                     is.null <- base::is.null
[17:46:37.640]                     muffled <- FALSE
[17:46:37.640]                     if (inherits(cond, "message")) {
[17:46:37.640]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:37.640]                       if (muffled) 
[17:46:37.640]                         invokeRestart("muffleMessage")
[17:46:37.640]                     }
[17:46:37.640]                     else if (inherits(cond, "warning")) {
[17:46:37.640]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:37.640]                       if (muffled) 
[17:46:37.640]                         invokeRestart("muffleWarning")
[17:46:37.640]                     }
[17:46:37.640]                     else if (inherits(cond, "condition")) {
[17:46:37.640]                       if (!is.null(pattern)) {
[17:46:37.640]                         computeRestarts <- base::computeRestarts
[17:46:37.640]                         grepl <- base::grepl
[17:46:37.640]                         restarts <- computeRestarts(cond)
[17:46:37.640]                         for (restart in restarts) {
[17:46:37.640]                           name <- restart$name
[17:46:37.640]                           if (is.null(name)) 
[17:46:37.640]                             next
[17:46:37.640]                           if (!grepl(pattern, name)) 
[17:46:37.640]                             next
[17:46:37.640]                           invokeRestart(restart)
[17:46:37.640]                           muffled <- TRUE
[17:46:37.640]                           break
[17:46:37.640]                         }
[17:46:37.640]                       }
[17:46:37.640]                     }
[17:46:37.640]                     invisible(muffled)
[17:46:37.640]                   }
[17:46:37.640]                   muffleCondition(cond)
[17:46:37.640]                 })
[17:46:37.640]             }))
[17:46:37.640]             future::FutureResult(value = ...future.value$value, 
[17:46:37.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.640]                   ...future.rng), globalenv = if (FALSE) 
[17:46:37.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:37.640]                     ...future.globalenv.names))
[17:46:37.640]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:37.640]         }, condition = base::local({
[17:46:37.640]             c <- base::c
[17:46:37.640]             inherits <- base::inherits
[17:46:37.640]             invokeRestart <- base::invokeRestart
[17:46:37.640]             length <- base::length
[17:46:37.640]             list <- base::list
[17:46:37.640]             seq.int <- base::seq.int
[17:46:37.640]             signalCondition <- base::signalCondition
[17:46:37.640]             sys.calls <- base::sys.calls
[17:46:37.640]             `[[` <- base::`[[`
[17:46:37.640]             `+` <- base::`+`
[17:46:37.640]             `<<-` <- base::`<<-`
[17:46:37.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:37.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:37.640]                   3L)]
[17:46:37.640]             }
[17:46:37.640]             function(cond) {
[17:46:37.640]                 is_error <- inherits(cond, "error")
[17:46:37.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:37.640]                   NULL)
[17:46:37.640]                 if (is_error) {
[17:46:37.640]                   sessionInformation <- function() {
[17:46:37.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:37.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:37.640]                       search = base::search(), system = base::Sys.info())
[17:46:37.640]                   }
[17:46:37.640]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:37.640]                     cond$call), session = sessionInformation(), 
[17:46:37.640]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:37.640]                   signalCondition(cond)
[17:46:37.640]                 }
[17:46:37.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:37.640]                 "immediateCondition"))) {
[17:46:37.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:37.640]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:37.640]                   if (TRUE && !signal) {
[17:46:37.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.640]                     {
[17:46:37.640]                       inherits <- base::inherits
[17:46:37.640]                       invokeRestart <- base::invokeRestart
[17:46:37.640]                       is.null <- base::is.null
[17:46:37.640]                       muffled <- FALSE
[17:46:37.640]                       if (inherits(cond, "message")) {
[17:46:37.640]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.640]                         if (muffled) 
[17:46:37.640]                           invokeRestart("muffleMessage")
[17:46:37.640]                       }
[17:46:37.640]                       else if (inherits(cond, "warning")) {
[17:46:37.640]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.640]                         if (muffled) 
[17:46:37.640]                           invokeRestart("muffleWarning")
[17:46:37.640]                       }
[17:46:37.640]                       else if (inherits(cond, "condition")) {
[17:46:37.640]                         if (!is.null(pattern)) {
[17:46:37.640]                           computeRestarts <- base::computeRestarts
[17:46:37.640]                           grepl <- base::grepl
[17:46:37.640]                           restarts <- computeRestarts(cond)
[17:46:37.640]                           for (restart in restarts) {
[17:46:37.640]                             name <- restart$name
[17:46:37.640]                             if (is.null(name)) 
[17:46:37.640]                               next
[17:46:37.640]                             if (!grepl(pattern, name)) 
[17:46:37.640]                               next
[17:46:37.640]                             invokeRestart(restart)
[17:46:37.640]                             muffled <- TRUE
[17:46:37.640]                             break
[17:46:37.640]                           }
[17:46:37.640]                         }
[17:46:37.640]                       }
[17:46:37.640]                       invisible(muffled)
[17:46:37.640]                     }
[17:46:37.640]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.640]                   }
[17:46:37.640]                 }
[17:46:37.640]                 else {
[17:46:37.640]                   if (TRUE) {
[17:46:37.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.640]                     {
[17:46:37.640]                       inherits <- base::inherits
[17:46:37.640]                       invokeRestart <- base::invokeRestart
[17:46:37.640]                       is.null <- base::is.null
[17:46:37.640]                       muffled <- FALSE
[17:46:37.640]                       if (inherits(cond, "message")) {
[17:46:37.640]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.640]                         if (muffled) 
[17:46:37.640]                           invokeRestart("muffleMessage")
[17:46:37.640]                       }
[17:46:37.640]                       else if (inherits(cond, "warning")) {
[17:46:37.640]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.640]                         if (muffled) 
[17:46:37.640]                           invokeRestart("muffleWarning")
[17:46:37.640]                       }
[17:46:37.640]                       else if (inherits(cond, "condition")) {
[17:46:37.640]                         if (!is.null(pattern)) {
[17:46:37.640]                           computeRestarts <- base::computeRestarts
[17:46:37.640]                           grepl <- base::grepl
[17:46:37.640]                           restarts <- computeRestarts(cond)
[17:46:37.640]                           for (restart in restarts) {
[17:46:37.640]                             name <- restart$name
[17:46:37.640]                             if (is.null(name)) 
[17:46:37.640]                               next
[17:46:37.640]                             if (!grepl(pattern, name)) 
[17:46:37.640]                               next
[17:46:37.640]                             invokeRestart(restart)
[17:46:37.640]                             muffled <- TRUE
[17:46:37.640]                             break
[17:46:37.640]                           }
[17:46:37.640]                         }
[17:46:37.640]                       }
[17:46:37.640]                       invisible(muffled)
[17:46:37.640]                     }
[17:46:37.640]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.640]                   }
[17:46:37.640]                 }
[17:46:37.640]             }
[17:46:37.640]         }))
[17:46:37.640]     }, error = function(ex) {
[17:46:37.640]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:37.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.640]                 ...future.rng), started = ...future.startTime, 
[17:46:37.640]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:37.640]             version = "1.8"), class = "FutureResult")
[17:46:37.640]     }, finally = {
[17:46:37.640]         if (!identical(...future.workdir, getwd())) 
[17:46:37.640]             setwd(...future.workdir)
[17:46:37.640]         {
[17:46:37.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:37.640]                 ...future.oldOptions$nwarnings <- NULL
[17:46:37.640]             }
[17:46:37.640]             base::options(...future.oldOptions)
[17:46:37.640]             if (.Platform$OS.type == "windows") {
[17:46:37.640]                 old_names <- names(...future.oldEnvVars)
[17:46:37.640]                 envs <- base::Sys.getenv()
[17:46:37.640]                 names <- names(envs)
[17:46:37.640]                 common <- intersect(names, old_names)
[17:46:37.640]                 added <- setdiff(names, old_names)
[17:46:37.640]                 removed <- setdiff(old_names, names)
[17:46:37.640]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:37.640]                   envs[common]]
[17:46:37.640]                 NAMES <- toupper(changed)
[17:46:37.640]                 args <- list()
[17:46:37.640]                 for (kk in seq_along(NAMES)) {
[17:46:37.640]                   name <- changed[[kk]]
[17:46:37.640]                   NAME <- NAMES[[kk]]
[17:46:37.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.640]                     next
[17:46:37.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.640]                 }
[17:46:37.640]                 NAMES <- toupper(added)
[17:46:37.640]                 for (kk in seq_along(NAMES)) {
[17:46:37.640]                   name <- added[[kk]]
[17:46:37.640]                   NAME <- NAMES[[kk]]
[17:46:37.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.640]                     next
[17:46:37.640]                   args[[name]] <- ""
[17:46:37.640]                 }
[17:46:37.640]                 NAMES <- toupper(removed)
[17:46:37.640]                 for (kk in seq_along(NAMES)) {
[17:46:37.640]                   name <- removed[[kk]]
[17:46:37.640]                   NAME <- NAMES[[kk]]
[17:46:37.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.640]                     next
[17:46:37.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.640]                 }
[17:46:37.640]                 if (length(args) > 0) 
[17:46:37.640]                   base::do.call(base::Sys.setenv, args = args)
[17:46:37.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:37.640]             }
[17:46:37.640]             else {
[17:46:37.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:37.640]             }
[17:46:37.640]             {
[17:46:37.640]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:37.640]                   0L) {
[17:46:37.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:37.640]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:37.640]                   base::options(opts)
[17:46:37.640]                 }
[17:46:37.640]                 {
[17:46:37.640]                   {
[17:46:37.640]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:37.640]                     NULL
[17:46:37.640]                   }
[17:46:37.640]                   options(future.plan = NULL)
[17:46:37.640]                   if (is.na(NA_character_)) 
[17:46:37.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:37.640]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:37.640]                     .init = FALSE)
[17:46:37.640]                 }
[17:46:37.640]             }
[17:46:37.640]         }
[17:46:37.640]     })
[17:46:37.640]     if (TRUE) {
[17:46:37.640]         base::sink(type = "output", split = FALSE)
[17:46:37.640]         if (TRUE) {
[17:46:37.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:37.640]         }
[17:46:37.640]         else {
[17:46:37.640]             ...future.result["stdout"] <- base::list(NULL)
[17:46:37.640]         }
[17:46:37.640]         base::close(...future.stdout)
[17:46:37.640]         ...future.stdout <- NULL
[17:46:37.640]     }
[17:46:37.640]     ...future.result$conditions <- ...future.conditions
[17:46:37.640]     ...future.result$finished <- base::Sys.time()
[17:46:37.640]     ...future.result
[17:46:37.640] }
[17:46:37.643] MultisessionFuture started
[17:46:37.643] - Launch lazy future ... done
[17:46:37.643] run() for ‘MultisessionFuture’ ... done
[17:46:37.644] result() for ClusterFuture ...
[17:46:37.644] receiveMessageFromWorker() for ClusterFuture ...
[17:46:37.644] - Validating connection of MultisessionFuture
[17:46:37.645] - received message: FutureResult
[17:46:37.645] - Received FutureResult
[17:46:37.645] - Erased future from FutureRegistry
[17:46:37.645] result() for ClusterFuture ...
[17:46:37.645] - result already collected: FutureResult
[17:46:37.645] result() for ClusterFuture ... done
[17:46:37.645] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:37.646] result() for ClusterFuture ... done
[17:46:37.646] result() for ClusterFuture ...
[17:46:37.646] - result already collected: FutureResult
[17:46:37.646] result() for ClusterFuture ... done
** Future evaluation with globals
[17:46:37.646] getGlobalsAndPackages() ...
[17:46:37.646] Searching for globals...
[17:46:37.648] - globals found: [3] ‘{’, ‘<-’, ‘a’
[17:46:37.648] Searching for globals ... DONE
[17:46:37.648] Resolving globals: FALSE
[17:46:37.648] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:37.649] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:46:37.649] - globals: [1] ‘a’
[17:46:37.649] 
[17:46:37.649] getGlobalsAndPackages() ... DONE
[17:46:37.649] run() for ‘Future’ ...
[17:46:37.649] - state: ‘created’
[17:46:37.650] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:37.664] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:37.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:37.664]   - Field: ‘node’
[17:46:37.664]   - Field: ‘label’
[17:46:37.664]   - Field: ‘local’
[17:46:37.664]   - Field: ‘owner’
[17:46:37.664]   - Field: ‘envir’
[17:46:37.664]   - Field: ‘workers’
[17:46:37.664]   - Field: ‘packages’
[17:46:37.665]   - Field: ‘gc’
[17:46:37.665]   - Field: ‘conditions’
[17:46:37.665]   - Field: ‘persistent’
[17:46:37.665]   - Field: ‘expr’
[17:46:37.665]   - Field: ‘uuid’
[17:46:37.665]   - Field: ‘seed’
[17:46:37.665]   - Field: ‘version’
[17:46:37.665]   - Field: ‘result’
[17:46:37.665]   - Field: ‘asynchronous’
[17:46:37.666]   - Field: ‘calls’
[17:46:37.666]   - Field: ‘globals’
[17:46:37.666]   - Field: ‘stdout’
[17:46:37.666]   - Field: ‘earlySignal’
[17:46:37.666]   - Field: ‘lazy’
[17:46:37.666]   - Field: ‘state’
[17:46:37.666] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:37.666] - Launch lazy future ...
[17:46:37.667] Packages needed by the future expression (n = 0): <none>
[17:46:37.667] Packages needed by future strategies (n = 0): <none>
[17:46:37.667] {
[17:46:37.667]     {
[17:46:37.667]         {
[17:46:37.667]             ...future.startTime <- base::Sys.time()
[17:46:37.667]             {
[17:46:37.667]                 {
[17:46:37.667]                   {
[17:46:37.667]                     {
[17:46:37.667]                       base::local({
[17:46:37.667]                         has_future <- base::requireNamespace("future", 
[17:46:37.667]                           quietly = TRUE)
[17:46:37.667]                         if (has_future) {
[17:46:37.667]                           ns <- base::getNamespace("future")
[17:46:37.667]                           version <- ns[[".package"]][["version"]]
[17:46:37.667]                           if (is.null(version)) 
[17:46:37.667]                             version <- utils::packageVersion("future")
[17:46:37.667]                         }
[17:46:37.667]                         else {
[17:46:37.667]                           version <- NULL
[17:46:37.667]                         }
[17:46:37.667]                         if (!has_future || version < "1.8.0") {
[17:46:37.667]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:37.667]                             "", base::R.version$version.string), 
[17:46:37.667]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:37.667]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:37.667]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:37.667]                               "release", "version")], collapse = " "), 
[17:46:37.667]                             hostname = base::Sys.info()[["nodename"]])
[17:46:37.667]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:37.667]                             info)
[17:46:37.667]                           info <- base::paste(info, collapse = "; ")
[17:46:37.667]                           if (!has_future) {
[17:46:37.667]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:37.667]                               info)
[17:46:37.667]                           }
[17:46:37.667]                           else {
[17:46:37.667]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:37.667]                               info, version)
[17:46:37.667]                           }
[17:46:37.667]                           base::stop(msg)
[17:46:37.667]                         }
[17:46:37.667]                       })
[17:46:37.667]                     }
[17:46:37.667]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:37.667]                     base::options(mc.cores = 1L)
[17:46:37.667]                   }
[17:46:37.667]                   ...future.strategy.old <- future::plan("list")
[17:46:37.667]                   options(future.plan = NULL)
[17:46:37.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:37.667]                 }
[17:46:37.667]                 ...future.workdir <- getwd()
[17:46:37.667]             }
[17:46:37.667]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:37.667]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:37.667]         }
[17:46:37.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:37.667]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:37.667]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:37.667]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:37.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:37.667]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:37.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:37.667]             base::names(...future.oldOptions))
[17:46:37.667]     }
[17:46:37.667]     if (FALSE) {
[17:46:37.667]     }
[17:46:37.667]     else {
[17:46:37.667]         if (TRUE) {
[17:46:37.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:37.667]                 open = "w")
[17:46:37.667]         }
[17:46:37.667]         else {
[17:46:37.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:37.667]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:37.667]         }
[17:46:37.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:37.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:37.667]             base::sink(type = "output", split = FALSE)
[17:46:37.667]             base::close(...future.stdout)
[17:46:37.667]         }, add = TRUE)
[17:46:37.667]     }
[17:46:37.667]     ...future.frame <- base::sys.nframe()
[17:46:37.667]     ...future.conditions <- base::list()
[17:46:37.667]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:37.667]     if (FALSE) {
[17:46:37.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:37.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:37.667]     }
[17:46:37.667]     ...future.result <- base::tryCatch({
[17:46:37.667]         base::withCallingHandlers({
[17:46:37.667]             ...future.value <- base::withVisible(base::local({
[17:46:37.667]                 ...future.makeSendCondition <- base::local({
[17:46:37.667]                   sendCondition <- NULL
[17:46:37.667]                   function(frame = 1L) {
[17:46:37.667]                     if (is.function(sendCondition)) 
[17:46:37.667]                       return(sendCondition)
[17:46:37.667]                     ns <- getNamespace("parallel")
[17:46:37.667]                     if (exists("sendData", mode = "function", 
[17:46:37.667]                       envir = ns)) {
[17:46:37.667]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:37.667]                         envir = ns)
[17:46:37.667]                       envir <- sys.frame(frame)
[17:46:37.667]                       master <- NULL
[17:46:37.667]                       while (!identical(envir, .GlobalEnv) && 
[17:46:37.667]                         !identical(envir, emptyenv())) {
[17:46:37.667]                         if (exists("master", mode = "list", envir = envir, 
[17:46:37.667]                           inherits = FALSE)) {
[17:46:37.667]                           master <- get("master", mode = "list", 
[17:46:37.667]                             envir = envir, inherits = FALSE)
[17:46:37.667]                           if (inherits(master, c("SOCKnode", 
[17:46:37.667]                             "SOCK0node"))) {
[17:46:37.667]                             sendCondition <<- function(cond) {
[17:46:37.667]                               data <- list(type = "VALUE", value = cond, 
[17:46:37.667]                                 success = TRUE)
[17:46:37.667]                               parallel_sendData(master, data)
[17:46:37.667]                             }
[17:46:37.667]                             return(sendCondition)
[17:46:37.667]                           }
[17:46:37.667]                         }
[17:46:37.667]                         frame <- frame + 1L
[17:46:37.667]                         envir <- sys.frame(frame)
[17:46:37.667]                       }
[17:46:37.667]                     }
[17:46:37.667]                     sendCondition <<- function(cond) NULL
[17:46:37.667]                   }
[17:46:37.667]                 })
[17:46:37.667]                 withCallingHandlers({
[17:46:37.667]                   {
[17:46:37.667]                     x <- a
[17:46:37.667]                   }
[17:46:37.667]                 }, immediateCondition = function(cond) {
[17:46:37.667]                   sendCondition <- ...future.makeSendCondition()
[17:46:37.667]                   sendCondition(cond)
[17:46:37.667]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.667]                   {
[17:46:37.667]                     inherits <- base::inherits
[17:46:37.667]                     invokeRestart <- base::invokeRestart
[17:46:37.667]                     is.null <- base::is.null
[17:46:37.667]                     muffled <- FALSE
[17:46:37.667]                     if (inherits(cond, "message")) {
[17:46:37.667]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:37.667]                       if (muffled) 
[17:46:37.667]                         invokeRestart("muffleMessage")
[17:46:37.667]                     }
[17:46:37.667]                     else if (inherits(cond, "warning")) {
[17:46:37.667]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:37.667]                       if (muffled) 
[17:46:37.667]                         invokeRestart("muffleWarning")
[17:46:37.667]                     }
[17:46:37.667]                     else if (inherits(cond, "condition")) {
[17:46:37.667]                       if (!is.null(pattern)) {
[17:46:37.667]                         computeRestarts <- base::computeRestarts
[17:46:37.667]                         grepl <- base::grepl
[17:46:37.667]                         restarts <- computeRestarts(cond)
[17:46:37.667]                         for (restart in restarts) {
[17:46:37.667]                           name <- restart$name
[17:46:37.667]                           if (is.null(name)) 
[17:46:37.667]                             next
[17:46:37.667]                           if (!grepl(pattern, name)) 
[17:46:37.667]                             next
[17:46:37.667]                           invokeRestart(restart)
[17:46:37.667]                           muffled <- TRUE
[17:46:37.667]                           break
[17:46:37.667]                         }
[17:46:37.667]                       }
[17:46:37.667]                     }
[17:46:37.667]                     invisible(muffled)
[17:46:37.667]                   }
[17:46:37.667]                   muffleCondition(cond)
[17:46:37.667]                 })
[17:46:37.667]             }))
[17:46:37.667]             future::FutureResult(value = ...future.value$value, 
[17:46:37.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.667]                   ...future.rng), globalenv = if (FALSE) 
[17:46:37.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:37.667]                     ...future.globalenv.names))
[17:46:37.667]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:37.667]         }, condition = base::local({
[17:46:37.667]             c <- base::c
[17:46:37.667]             inherits <- base::inherits
[17:46:37.667]             invokeRestart <- base::invokeRestart
[17:46:37.667]             length <- base::length
[17:46:37.667]             list <- base::list
[17:46:37.667]             seq.int <- base::seq.int
[17:46:37.667]             signalCondition <- base::signalCondition
[17:46:37.667]             sys.calls <- base::sys.calls
[17:46:37.667]             `[[` <- base::`[[`
[17:46:37.667]             `+` <- base::`+`
[17:46:37.667]             `<<-` <- base::`<<-`
[17:46:37.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:37.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:37.667]                   3L)]
[17:46:37.667]             }
[17:46:37.667]             function(cond) {
[17:46:37.667]                 is_error <- inherits(cond, "error")
[17:46:37.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:37.667]                   NULL)
[17:46:37.667]                 if (is_error) {
[17:46:37.667]                   sessionInformation <- function() {
[17:46:37.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:37.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:37.667]                       search = base::search(), system = base::Sys.info())
[17:46:37.667]                   }
[17:46:37.667]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:37.667]                     cond$call), session = sessionInformation(), 
[17:46:37.667]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:37.667]                   signalCondition(cond)
[17:46:37.667]                 }
[17:46:37.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:37.667]                 "immediateCondition"))) {
[17:46:37.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:37.667]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:37.667]                   if (TRUE && !signal) {
[17:46:37.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.667]                     {
[17:46:37.667]                       inherits <- base::inherits
[17:46:37.667]                       invokeRestart <- base::invokeRestart
[17:46:37.667]                       is.null <- base::is.null
[17:46:37.667]                       muffled <- FALSE
[17:46:37.667]                       if (inherits(cond, "message")) {
[17:46:37.667]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.667]                         if (muffled) 
[17:46:37.667]                           invokeRestart("muffleMessage")
[17:46:37.667]                       }
[17:46:37.667]                       else if (inherits(cond, "warning")) {
[17:46:37.667]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.667]                         if (muffled) 
[17:46:37.667]                           invokeRestart("muffleWarning")
[17:46:37.667]                       }
[17:46:37.667]                       else if (inherits(cond, "condition")) {
[17:46:37.667]                         if (!is.null(pattern)) {
[17:46:37.667]                           computeRestarts <- base::computeRestarts
[17:46:37.667]                           grepl <- base::grepl
[17:46:37.667]                           restarts <- computeRestarts(cond)
[17:46:37.667]                           for (restart in restarts) {
[17:46:37.667]                             name <- restart$name
[17:46:37.667]                             if (is.null(name)) 
[17:46:37.667]                               next
[17:46:37.667]                             if (!grepl(pattern, name)) 
[17:46:37.667]                               next
[17:46:37.667]                             invokeRestart(restart)
[17:46:37.667]                             muffled <- TRUE
[17:46:37.667]                             break
[17:46:37.667]                           }
[17:46:37.667]                         }
[17:46:37.667]                       }
[17:46:37.667]                       invisible(muffled)
[17:46:37.667]                     }
[17:46:37.667]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.667]                   }
[17:46:37.667]                 }
[17:46:37.667]                 else {
[17:46:37.667]                   if (TRUE) {
[17:46:37.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.667]                     {
[17:46:37.667]                       inherits <- base::inherits
[17:46:37.667]                       invokeRestart <- base::invokeRestart
[17:46:37.667]                       is.null <- base::is.null
[17:46:37.667]                       muffled <- FALSE
[17:46:37.667]                       if (inherits(cond, "message")) {
[17:46:37.667]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.667]                         if (muffled) 
[17:46:37.667]                           invokeRestart("muffleMessage")
[17:46:37.667]                       }
[17:46:37.667]                       else if (inherits(cond, "warning")) {
[17:46:37.667]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.667]                         if (muffled) 
[17:46:37.667]                           invokeRestart("muffleWarning")
[17:46:37.667]                       }
[17:46:37.667]                       else if (inherits(cond, "condition")) {
[17:46:37.667]                         if (!is.null(pattern)) {
[17:46:37.667]                           computeRestarts <- base::computeRestarts
[17:46:37.667]                           grepl <- base::grepl
[17:46:37.667]                           restarts <- computeRestarts(cond)
[17:46:37.667]                           for (restart in restarts) {
[17:46:37.667]                             name <- restart$name
[17:46:37.667]                             if (is.null(name)) 
[17:46:37.667]                               next
[17:46:37.667]                             if (!grepl(pattern, name)) 
[17:46:37.667]                               next
[17:46:37.667]                             invokeRestart(restart)
[17:46:37.667]                             muffled <- TRUE
[17:46:37.667]                             break
[17:46:37.667]                           }
[17:46:37.667]                         }
[17:46:37.667]                       }
[17:46:37.667]                       invisible(muffled)
[17:46:37.667]                     }
[17:46:37.667]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.667]                   }
[17:46:37.667]                 }
[17:46:37.667]             }
[17:46:37.667]         }))
[17:46:37.667]     }, error = function(ex) {
[17:46:37.667]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:37.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.667]                 ...future.rng), started = ...future.startTime, 
[17:46:37.667]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:37.667]             version = "1.8"), class = "FutureResult")
[17:46:37.667]     }, finally = {
[17:46:37.667]         if (!identical(...future.workdir, getwd())) 
[17:46:37.667]             setwd(...future.workdir)
[17:46:37.667]         {
[17:46:37.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:37.667]                 ...future.oldOptions$nwarnings <- NULL
[17:46:37.667]             }
[17:46:37.667]             base::options(...future.oldOptions)
[17:46:37.667]             if (.Platform$OS.type == "windows") {
[17:46:37.667]                 old_names <- names(...future.oldEnvVars)
[17:46:37.667]                 envs <- base::Sys.getenv()
[17:46:37.667]                 names <- names(envs)
[17:46:37.667]                 common <- intersect(names, old_names)
[17:46:37.667]                 added <- setdiff(names, old_names)
[17:46:37.667]                 removed <- setdiff(old_names, names)
[17:46:37.667]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:37.667]                   envs[common]]
[17:46:37.667]                 NAMES <- toupper(changed)
[17:46:37.667]                 args <- list()
[17:46:37.667]                 for (kk in seq_along(NAMES)) {
[17:46:37.667]                   name <- changed[[kk]]
[17:46:37.667]                   NAME <- NAMES[[kk]]
[17:46:37.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.667]                     next
[17:46:37.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.667]                 }
[17:46:37.667]                 NAMES <- toupper(added)
[17:46:37.667]                 for (kk in seq_along(NAMES)) {
[17:46:37.667]                   name <- added[[kk]]
[17:46:37.667]                   NAME <- NAMES[[kk]]
[17:46:37.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.667]                     next
[17:46:37.667]                   args[[name]] <- ""
[17:46:37.667]                 }
[17:46:37.667]                 NAMES <- toupper(removed)
[17:46:37.667]                 for (kk in seq_along(NAMES)) {
[17:46:37.667]                   name <- removed[[kk]]
[17:46:37.667]                   NAME <- NAMES[[kk]]
[17:46:37.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.667]                     next
[17:46:37.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.667]                 }
[17:46:37.667]                 if (length(args) > 0) 
[17:46:37.667]                   base::do.call(base::Sys.setenv, args = args)
[17:46:37.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:37.667]             }
[17:46:37.667]             else {
[17:46:37.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:37.667]             }
[17:46:37.667]             {
[17:46:37.667]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:37.667]                   0L) {
[17:46:37.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:37.667]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:37.667]                   base::options(opts)
[17:46:37.667]                 }
[17:46:37.667]                 {
[17:46:37.667]                   {
[17:46:37.667]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:37.667]                     NULL
[17:46:37.667]                   }
[17:46:37.667]                   options(future.plan = NULL)
[17:46:37.667]                   if (is.na(NA_character_)) 
[17:46:37.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:37.667]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:37.667]                     .init = FALSE)
[17:46:37.667]                 }
[17:46:37.667]             }
[17:46:37.667]         }
[17:46:37.667]     })
[17:46:37.667]     if (TRUE) {
[17:46:37.667]         base::sink(type = "output", split = FALSE)
[17:46:37.667]         if (TRUE) {
[17:46:37.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:37.667]         }
[17:46:37.667]         else {
[17:46:37.667]             ...future.result["stdout"] <- base::list(NULL)
[17:46:37.667]         }
[17:46:37.667]         base::close(...future.stdout)
[17:46:37.667]         ...future.stdout <- NULL
[17:46:37.667]     }
[17:46:37.667]     ...future.result$conditions <- ...future.conditions
[17:46:37.667]     ...future.result$finished <- base::Sys.time()
[17:46:37.667]     ...future.result
[17:46:37.667] }
[17:46:37.670] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:46:37.670] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:46:37.671] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:46:37.671] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:46:37.671] MultisessionFuture started
[17:46:37.672] - Launch lazy future ... done
[17:46:37.672] run() for ‘MultisessionFuture’ ... done
[17:46:37.672] result() for ClusterFuture ...
[17:46:37.672] receiveMessageFromWorker() for ClusterFuture ...
[17:46:37.673] - Validating connection of MultisessionFuture
[17:46:37.677] - received message: FutureResult
[17:46:37.677] - Received FutureResult
[17:46:37.677] - Erased future from FutureRegistry
[17:46:37.677] result() for ClusterFuture ...
[17:46:37.677] - result already collected: FutureResult
[17:46:37.677] result() for ClusterFuture ... done
[17:46:37.678] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:37.678] result() for ClusterFuture ... done
[17:46:37.678] result() for ClusterFuture ...
[17:46:37.678] - result already collected: FutureResult
[17:46:37.678] result() for ClusterFuture ... done
** Future evaluation with errors
[17:46:37.678] getGlobalsAndPackages() ...
[17:46:37.679] Searching for globals...
[17:46:37.680] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[17:46:37.681] Searching for globals ... DONE
[17:46:37.681] Resolving globals: FALSE
[17:46:37.681] 
[17:46:37.681] 
[17:46:37.681] getGlobalsAndPackages() ... DONE
[17:46:37.682] run() for ‘Future’ ...
[17:46:37.682] - state: ‘created’
[17:46:37.682] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:37.696] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:37.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:37.697]   - Field: ‘node’
[17:46:37.697]   - Field: ‘label’
[17:46:37.697]   - Field: ‘local’
[17:46:37.697]   - Field: ‘owner’
[17:46:37.697]   - Field: ‘envir’
[17:46:37.697]   - Field: ‘workers’
[17:46:37.697]   - Field: ‘packages’
[17:46:37.697]   - Field: ‘gc’
[17:46:37.697]   - Field: ‘conditions’
[17:46:37.698]   - Field: ‘persistent’
[17:46:37.698]   - Field: ‘expr’
[17:46:37.698]   - Field: ‘uuid’
[17:46:37.698]   - Field: ‘seed’
[17:46:37.698]   - Field: ‘version’
[17:46:37.698]   - Field: ‘result’
[17:46:37.698]   - Field: ‘asynchronous’
[17:46:37.698]   - Field: ‘calls’
[17:46:37.698]   - Field: ‘globals’
[17:46:37.699]   - Field: ‘stdout’
[17:46:37.699]   - Field: ‘earlySignal’
[17:46:37.699]   - Field: ‘lazy’
[17:46:37.699]   - Field: ‘state’
[17:46:37.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:37.699] - Launch lazy future ...
[17:46:37.699] Packages needed by the future expression (n = 0): <none>
[17:46:37.700] Packages needed by future strategies (n = 0): <none>
[17:46:37.700] {
[17:46:37.700]     {
[17:46:37.700]         {
[17:46:37.700]             ...future.startTime <- base::Sys.time()
[17:46:37.700]             {
[17:46:37.700]                 {
[17:46:37.700]                   {
[17:46:37.700]                     {
[17:46:37.700]                       base::local({
[17:46:37.700]                         has_future <- base::requireNamespace("future", 
[17:46:37.700]                           quietly = TRUE)
[17:46:37.700]                         if (has_future) {
[17:46:37.700]                           ns <- base::getNamespace("future")
[17:46:37.700]                           version <- ns[[".package"]][["version"]]
[17:46:37.700]                           if (is.null(version)) 
[17:46:37.700]                             version <- utils::packageVersion("future")
[17:46:37.700]                         }
[17:46:37.700]                         else {
[17:46:37.700]                           version <- NULL
[17:46:37.700]                         }
[17:46:37.700]                         if (!has_future || version < "1.8.0") {
[17:46:37.700]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:37.700]                             "", base::R.version$version.string), 
[17:46:37.700]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:37.700]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:37.700]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:37.700]                               "release", "version")], collapse = " "), 
[17:46:37.700]                             hostname = base::Sys.info()[["nodename"]])
[17:46:37.700]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:37.700]                             info)
[17:46:37.700]                           info <- base::paste(info, collapse = "; ")
[17:46:37.700]                           if (!has_future) {
[17:46:37.700]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:37.700]                               info)
[17:46:37.700]                           }
[17:46:37.700]                           else {
[17:46:37.700]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:37.700]                               info, version)
[17:46:37.700]                           }
[17:46:37.700]                           base::stop(msg)
[17:46:37.700]                         }
[17:46:37.700]                       })
[17:46:37.700]                     }
[17:46:37.700]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:37.700]                     base::options(mc.cores = 1L)
[17:46:37.700]                   }
[17:46:37.700]                   ...future.strategy.old <- future::plan("list")
[17:46:37.700]                   options(future.plan = NULL)
[17:46:37.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:37.700]                 }
[17:46:37.700]                 ...future.workdir <- getwd()
[17:46:37.700]             }
[17:46:37.700]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:37.700]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:37.700]         }
[17:46:37.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:37.700]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:37.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:37.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:37.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:37.700]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:37.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:37.700]             base::names(...future.oldOptions))
[17:46:37.700]     }
[17:46:37.700]     if (FALSE) {
[17:46:37.700]     }
[17:46:37.700]     else {
[17:46:37.700]         if (TRUE) {
[17:46:37.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:37.700]                 open = "w")
[17:46:37.700]         }
[17:46:37.700]         else {
[17:46:37.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:37.700]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:37.700]         }
[17:46:37.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:37.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:37.700]             base::sink(type = "output", split = FALSE)
[17:46:37.700]             base::close(...future.stdout)
[17:46:37.700]         }, add = TRUE)
[17:46:37.700]     }
[17:46:37.700]     ...future.frame <- base::sys.nframe()
[17:46:37.700]     ...future.conditions <- base::list()
[17:46:37.700]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:37.700]     if (FALSE) {
[17:46:37.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:37.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:37.700]     }
[17:46:37.700]     ...future.result <- base::tryCatch({
[17:46:37.700]         base::withCallingHandlers({
[17:46:37.700]             ...future.value <- base::withVisible(base::local({
[17:46:37.700]                 ...future.makeSendCondition <- base::local({
[17:46:37.700]                   sendCondition <- NULL
[17:46:37.700]                   function(frame = 1L) {
[17:46:37.700]                     if (is.function(sendCondition)) 
[17:46:37.700]                       return(sendCondition)
[17:46:37.700]                     ns <- getNamespace("parallel")
[17:46:37.700]                     if (exists("sendData", mode = "function", 
[17:46:37.700]                       envir = ns)) {
[17:46:37.700]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:37.700]                         envir = ns)
[17:46:37.700]                       envir <- sys.frame(frame)
[17:46:37.700]                       master <- NULL
[17:46:37.700]                       while (!identical(envir, .GlobalEnv) && 
[17:46:37.700]                         !identical(envir, emptyenv())) {
[17:46:37.700]                         if (exists("master", mode = "list", envir = envir, 
[17:46:37.700]                           inherits = FALSE)) {
[17:46:37.700]                           master <- get("master", mode = "list", 
[17:46:37.700]                             envir = envir, inherits = FALSE)
[17:46:37.700]                           if (inherits(master, c("SOCKnode", 
[17:46:37.700]                             "SOCK0node"))) {
[17:46:37.700]                             sendCondition <<- function(cond) {
[17:46:37.700]                               data <- list(type = "VALUE", value = cond, 
[17:46:37.700]                                 success = TRUE)
[17:46:37.700]                               parallel_sendData(master, data)
[17:46:37.700]                             }
[17:46:37.700]                             return(sendCondition)
[17:46:37.700]                           }
[17:46:37.700]                         }
[17:46:37.700]                         frame <- frame + 1L
[17:46:37.700]                         envir <- sys.frame(frame)
[17:46:37.700]                       }
[17:46:37.700]                     }
[17:46:37.700]                     sendCondition <<- function(cond) NULL
[17:46:37.700]                   }
[17:46:37.700]                 })
[17:46:37.700]                 withCallingHandlers({
[17:46:37.700]                   {
[17:46:37.700]                     x <- 3
[17:46:37.700]                     stop("Woops!")
[17:46:37.700]                     x
[17:46:37.700]                   }
[17:46:37.700]                 }, immediateCondition = function(cond) {
[17:46:37.700]                   sendCondition <- ...future.makeSendCondition()
[17:46:37.700]                   sendCondition(cond)
[17:46:37.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.700]                   {
[17:46:37.700]                     inherits <- base::inherits
[17:46:37.700]                     invokeRestart <- base::invokeRestart
[17:46:37.700]                     is.null <- base::is.null
[17:46:37.700]                     muffled <- FALSE
[17:46:37.700]                     if (inherits(cond, "message")) {
[17:46:37.700]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:37.700]                       if (muffled) 
[17:46:37.700]                         invokeRestart("muffleMessage")
[17:46:37.700]                     }
[17:46:37.700]                     else if (inherits(cond, "warning")) {
[17:46:37.700]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:37.700]                       if (muffled) 
[17:46:37.700]                         invokeRestart("muffleWarning")
[17:46:37.700]                     }
[17:46:37.700]                     else if (inherits(cond, "condition")) {
[17:46:37.700]                       if (!is.null(pattern)) {
[17:46:37.700]                         computeRestarts <- base::computeRestarts
[17:46:37.700]                         grepl <- base::grepl
[17:46:37.700]                         restarts <- computeRestarts(cond)
[17:46:37.700]                         for (restart in restarts) {
[17:46:37.700]                           name <- restart$name
[17:46:37.700]                           if (is.null(name)) 
[17:46:37.700]                             next
[17:46:37.700]                           if (!grepl(pattern, name)) 
[17:46:37.700]                             next
[17:46:37.700]                           invokeRestart(restart)
[17:46:37.700]                           muffled <- TRUE
[17:46:37.700]                           break
[17:46:37.700]                         }
[17:46:37.700]                       }
[17:46:37.700]                     }
[17:46:37.700]                     invisible(muffled)
[17:46:37.700]                   }
[17:46:37.700]                   muffleCondition(cond)
[17:46:37.700]                 })
[17:46:37.700]             }))
[17:46:37.700]             future::FutureResult(value = ...future.value$value, 
[17:46:37.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.700]                   ...future.rng), globalenv = if (FALSE) 
[17:46:37.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:37.700]                     ...future.globalenv.names))
[17:46:37.700]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:37.700]         }, condition = base::local({
[17:46:37.700]             c <- base::c
[17:46:37.700]             inherits <- base::inherits
[17:46:37.700]             invokeRestart <- base::invokeRestart
[17:46:37.700]             length <- base::length
[17:46:37.700]             list <- base::list
[17:46:37.700]             seq.int <- base::seq.int
[17:46:37.700]             signalCondition <- base::signalCondition
[17:46:37.700]             sys.calls <- base::sys.calls
[17:46:37.700]             `[[` <- base::`[[`
[17:46:37.700]             `+` <- base::`+`
[17:46:37.700]             `<<-` <- base::`<<-`
[17:46:37.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:37.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:37.700]                   3L)]
[17:46:37.700]             }
[17:46:37.700]             function(cond) {
[17:46:37.700]                 is_error <- inherits(cond, "error")
[17:46:37.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:37.700]                   NULL)
[17:46:37.700]                 if (is_error) {
[17:46:37.700]                   sessionInformation <- function() {
[17:46:37.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:37.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:37.700]                       search = base::search(), system = base::Sys.info())
[17:46:37.700]                   }
[17:46:37.700]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:37.700]                     cond$call), session = sessionInformation(), 
[17:46:37.700]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:37.700]                   signalCondition(cond)
[17:46:37.700]                 }
[17:46:37.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:37.700]                 "immediateCondition"))) {
[17:46:37.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:37.700]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:37.700]                   if (TRUE && !signal) {
[17:46:37.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.700]                     {
[17:46:37.700]                       inherits <- base::inherits
[17:46:37.700]                       invokeRestart <- base::invokeRestart
[17:46:37.700]                       is.null <- base::is.null
[17:46:37.700]                       muffled <- FALSE
[17:46:37.700]                       if (inherits(cond, "message")) {
[17:46:37.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.700]                         if (muffled) 
[17:46:37.700]                           invokeRestart("muffleMessage")
[17:46:37.700]                       }
[17:46:37.700]                       else if (inherits(cond, "warning")) {
[17:46:37.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.700]                         if (muffled) 
[17:46:37.700]                           invokeRestart("muffleWarning")
[17:46:37.700]                       }
[17:46:37.700]                       else if (inherits(cond, "condition")) {
[17:46:37.700]                         if (!is.null(pattern)) {
[17:46:37.700]                           computeRestarts <- base::computeRestarts
[17:46:37.700]                           grepl <- base::grepl
[17:46:37.700]                           restarts <- computeRestarts(cond)
[17:46:37.700]                           for (restart in restarts) {
[17:46:37.700]                             name <- restart$name
[17:46:37.700]                             if (is.null(name)) 
[17:46:37.700]                               next
[17:46:37.700]                             if (!grepl(pattern, name)) 
[17:46:37.700]                               next
[17:46:37.700]                             invokeRestart(restart)
[17:46:37.700]                             muffled <- TRUE
[17:46:37.700]                             break
[17:46:37.700]                           }
[17:46:37.700]                         }
[17:46:37.700]                       }
[17:46:37.700]                       invisible(muffled)
[17:46:37.700]                     }
[17:46:37.700]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.700]                   }
[17:46:37.700]                 }
[17:46:37.700]                 else {
[17:46:37.700]                   if (TRUE) {
[17:46:37.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.700]                     {
[17:46:37.700]                       inherits <- base::inherits
[17:46:37.700]                       invokeRestart <- base::invokeRestart
[17:46:37.700]                       is.null <- base::is.null
[17:46:37.700]                       muffled <- FALSE
[17:46:37.700]                       if (inherits(cond, "message")) {
[17:46:37.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.700]                         if (muffled) 
[17:46:37.700]                           invokeRestart("muffleMessage")
[17:46:37.700]                       }
[17:46:37.700]                       else if (inherits(cond, "warning")) {
[17:46:37.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.700]                         if (muffled) 
[17:46:37.700]                           invokeRestart("muffleWarning")
[17:46:37.700]                       }
[17:46:37.700]                       else if (inherits(cond, "condition")) {
[17:46:37.700]                         if (!is.null(pattern)) {
[17:46:37.700]                           computeRestarts <- base::computeRestarts
[17:46:37.700]                           grepl <- base::grepl
[17:46:37.700]                           restarts <- computeRestarts(cond)
[17:46:37.700]                           for (restart in restarts) {
[17:46:37.700]                             name <- restart$name
[17:46:37.700]                             if (is.null(name)) 
[17:46:37.700]                               next
[17:46:37.700]                             if (!grepl(pattern, name)) 
[17:46:37.700]                               next
[17:46:37.700]                             invokeRestart(restart)
[17:46:37.700]                             muffled <- TRUE
[17:46:37.700]                             break
[17:46:37.700]                           }
[17:46:37.700]                         }
[17:46:37.700]                       }
[17:46:37.700]                       invisible(muffled)
[17:46:37.700]                     }
[17:46:37.700]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.700]                   }
[17:46:37.700]                 }
[17:46:37.700]             }
[17:46:37.700]         }))
[17:46:37.700]     }, error = function(ex) {
[17:46:37.700]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:37.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.700]                 ...future.rng), started = ...future.startTime, 
[17:46:37.700]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:37.700]             version = "1.8"), class = "FutureResult")
[17:46:37.700]     }, finally = {
[17:46:37.700]         if (!identical(...future.workdir, getwd())) 
[17:46:37.700]             setwd(...future.workdir)
[17:46:37.700]         {
[17:46:37.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:37.700]                 ...future.oldOptions$nwarnings <- NULL
[17:46:37.700]             }
[17:46:37.700]             base::options(...future.oldOptions)
[17:46:37.700]             if (.Platform$OS.type == "windows") {
[17:46:37.700]                 old_names <- names(...future.oldEnvVars)
[17:46:37.700]                 envs <- base::Sys.getenv()
[17:46:37.700]                 names <- names(envs)
[17:46:37.700]                 common <- intersect(names, old_names)
[17:46:37.700]                 added <- setdiff(names, old_names)
[17:46:37.700]                 removed <- setdiff(old_names, names)
[17:46:37.700]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:37.700]                   envs[common]]
[17:46:37.700]                 NAMES <- toupper(changed)
[17:46:37.700]                 args <- list()
[17:46:37.700]                 for (kk in seq_along(NAMES)) {
[17:46:37.700]                   name <- changed[[kk]]
[17:46:37.700]                   NAME <- NAMES[[kk]]
[17:46:37.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.700]                     next
[17:46:37.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.700]                 }
[17:46:37.700]                 NAMES <- toupper(added)
[17:46:37.700]                 for (kk in seq_along(NAMES)) {
[17:46:37.700]                   name <- added[[kk]]
[17:46:37.700]                   NAME <- NAMES[[kk]]
[17:46:37.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.700]                     next
[17:46:37.700]                   args[[name]] <- ""
[17:46:37.700]                 }
[17:46:37.700]                 NAMES <- toupper(removed)
[17:46:37.700]                 for (kk in seq_along(NAMES)) {
[17:46:37.700]                   name <- removed[[kk]]
[17:46:37.700]                   NAME <- NAMES[[kk]]
[17:46:37.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.700]                     next
[17:46:37.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.700]                 }
[17:46:37.700]                 if (length(args) > 0) 
[17:46:37.700]                   base::do.call(base::Sys.setenv, args = args)
[17:46:37.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:37.700]             }
[17:46:37.700]             else {
[17:46:37.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:37.700]             }
[17:46:37.700]             {
[17:46:37.700]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:37.700]                   0L) {
[17:46:37.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:37.700]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:37.700]                   base::options(opts)
[17:46:37.700]                 }
[17:46:37.700]                 {
[17:46:37.700]                   {
[17:46:37.700]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:37.700]                     NULL
[17:46:37.700]                   }
[17:46:37.700]                   options(future.plan = NULL)
[17:46:37.700]                   if (is.na(NA_character_)) 
[17:46:37.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:37.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:37.700]                     .init = FALSE)
[17:46:37.700]                 }
[17:46:37.700]             }
[17:46:37.700]         }
[17:46:37.700]     })
[17:46:37.700]     if (TRUE) {
[17:46:37.700]         base::sink(type = "output", split = FALSE)
[17:46:37.700]         if (TRUE) {
[17:46:37.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:37.700]         }
[17:46:37.700]         else {
[17:46:37.700]             ...future.result["stdout"] <- base::list(NULL)
[17:46:37.700]         }
[17:46:37.700]         base::close(...future.stdout)
[17:46:37.700]         ...future.stdout <- NULL
[17:46:37.700]     }
[17:46:37.700]     ...future.result$conditions <- ...future.conditions
[17:46:37.700]     ...future.result$finished <- base::Sys.time()
[17:46:37.700]     ...future.result
[17:46:37.700] }
[17:46:37.703] MultisessionFuture started
[17:46:37.703] - Launch lazy future ... done
[17:46:37.704] run() for ‘MultisessionFuture’ ... done
[17:46:37.704] result() for ClusterFuture ...
[17:46:37.704] receiveMessageFromWorker() for ClusterFuture ...
[17:46:37.704] - Validating connection of MultisessionFuture
[17:46:37.705] - received message: FutureResult
[17:46:37.706] - Received FutureResult
[17:46:37.706] - Erased future from FutureRegistry
[17:46:37.706] result() for ClusterFuture ...
[17:46:37.706] - result already collected: FutureResult
[17:46:37.706] result() for ClusterFuture ... done
[17:46:37.706] signalConditions() ...
[17:46:37.706]  - include = ‘immediateCondition’
[17:46:37.706]  - exclude = 
[17:46:37.706]  - resignal = FALSE
[17:46:37.707]  - Number of conditions: 1
[17:46:37.707] signalConditions() ... done
[17:46:37.707] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:37.707] result() for ClusterFuture ... done
[17:46:37.707] result() for ClusterFuture ...
[17:46:37.707] - result already collected: FutureResult
[17:46:37.707] result() for ClusterFuture ... done
[17:46:37.707] signalConditions() ...
[17:46:37.707]  - include = ‘immediateCondition’
[17:46:37.708]  - exclude = 
[17:46:37.708]  - resignal = FALSE
[17:46:37.708]  - Number of conditions: 1
[17:46:37.708] signalConditions() ... done
[17:46:37.708] Future state: ‘finished’
[17:46:37.708] result() for ClusterFuture ...
[17:46:37.708] - result already collected: FutureResult
[17:46:37.708] result() for ClusterFuture ... done
[17:46:37.709] signalConditions() ...
[17:46:37.709]  - include = ‘condition’
[17:46:37.709]  - exclude = ‘immediateCondition’
[17:46:37.709]  - resignal = TRUE
[17:46:37.709]  - Number of conditions: 1
[17:46:37.709]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:37.709] signalConditions() ... done
[17:46:37.710] getGlobalsAndPackages() ...
[17:46:37.710] Searching for globals...
[17:46:37.712] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:46:37.712] Searching for globals ... DONE
[17:46:37.712] Resolving globals: FALSE
[17:46:37.712] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:37.713] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:46:37.713] - globals: [1] ‘ii’
[17:46:37.713] 
[17:46:37.713] getGlobalsAndPackages() ... DONE
[17:46:37.714] run() for ‘Future’ ...
[17:46:37.714] - state: ‘created’
[17:46:37.714] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:37.730] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:37.730] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:37.730]   - Field: ‘node’
[17:46:37.730]   - Field: ‘label’
[17:46:37.730]   - Field: ‘local’
[17:46:37.730]   - Field: ‘owner’
[17:46:37.730]   - Field: ‘envir’
[17:46:37.731]   - Field: ‘workers’
[17:46:37.731]   - Field: ‘packages’
[17:46:37.731]   - Field: ‘gc’
[17:46:37.731]   - Field: ‘conditions’
[17:46:37.731]   - Field: ‘persistent’
[17:46:37.731]   - Field: ‘expr’
[17:46:37.731]   - Field: ‘uuid’
[17:46:37.731]   - Field: ‘seed’
[17:46:37.731]   - Field: ‘version’
[17:46:37.731]   - Field: ‘result’
[17:46:37.731]   - Field: ‘asynchronous’
[17:46:37.732]   - Field: ‘calls’
[17:46:37.732]   - Field: ‘globals’
[17:46:37.732]   - Field: ‘stdout’
[17:46:37.732]   - Field: ‘earlySignal’
[17:46:37.732]   - Field: ‘lazy’
[17:46:37.732]   - Field: ‘state’
[17:46:37.732] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:37.732] - Launch lazy future ...
[17:46:37.732] Packages needed by the future expression (n = 0): <none>
[17:46:37.732] Packages needed by future strategies (n = 0): <none>
[17:46:37.733] {
[17:46:37.733]     {
[17:46:37.733]         {
[17:46:37.733]             ...future.startTime <- base::Sys.time()
[17:46:37.733]             {
[17:46:37.733]                 {
[17:46:37.733]                   {
[17:46:37.733]                     {
[17:46:37.733]                       base::local({
[17:46:37.733]                         has_future <- base::requireNamespace("future", 
[17:46:37.733]                           quietly = TRUE)
[17:46:37.733]                         if (has_future) {
[17:46:37.733]                           ns <- base::getNamespace("future")
[17:46:37.733]                           version <- ns[[".package"]][["version"]]
[17:46:37.733]                           if (is.null(version)) 
[17:46:37.733]                             version <- utils::packageVersion("future")
[17:46:37.733]                         }
[17:46:37.733]                         else {
[17:46:37.733]                           version <- NULL
[17:46:37.733]                         }
[17:46:37.733]                         if (!has_future || version < "1.8.0") {
[17:46:37.733]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:37.733]                             "", base::R.version$version.string), 
[17:46:37.733]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:37.733]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:37.733]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:37.733]                               "release", "version")], collapse = " "), 
[17:46:37.733]                             hostname = base::Sys.info()[["nodename"]])
[17:46:37.733]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:37.733]                             info)
[17:46:37.733]                           info <- base::paste(info, collapse = "; ")
[17:46:37.733]                           if (!has_future) {
[17:46:37.733]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:37.733]                               info)
[17:46:37.733]                           }
[17:46:37.733]                           else {
[17:46:37.733]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:37.733]                               info, version)
[17:46:37.733]                           }
[17:46:37.733]                           base::stop(msg)
[17:46:37.733]                         }
[17:46:37.733]                       })
[17:46:37.733]                     }
[17:46:37.733]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:37.733]                     base::options(mc.cores = 1L)
[17:46:37.733]                   }
[17:46:37.733]                   ...future.strategy.old <- future::plan("list")
[17:46:37.733]                   options(future.plan = NULL)
[17:46:37.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:37.733]                 }
[17:46:37.733]                 ...future.workdir <- getwd()
[17:46:37.733]             }
[17:46:37.733]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:37.733]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:37.733]         }
[17:46:37.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:37.733]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:37.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:37.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:37.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:37.733]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:37.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:37.733]             base::names(...future.oldOptions))
[17:46:37.733]     }
[17:46:37.733]     if (FALSE) {
[17:46:37.733]     }
[17:46:37.733]     else {
[17:46:37.733]         if (TRUE) {
[17:46:37.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:37.733]                 open = "w")
[17:46:37.733]         }
[17:46:37.733]         else {
[17:46:37.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:37.733]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:37.733]         }
[17:46:37.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:37.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:37.733]             base::sink(type = "output", split = FALSE)
[17:46:37.733]             base::close(...future.stdout)
[17:46:37.733]         }, add = TRUE)
[17:46:37.733]     }
[17:46:37.733]     ...future.frame <- base::sys.nframe()
[17:46:37.733]     ...future.conditions <- base::list()
[17:46:37.733]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:37.733]     if (FALSE) {
[17:46:37.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:37.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:37.733]     }
[17:46:37.733]     ...future.result <- base::tryCatch({
[17:46:37.733]         base::withCallingHandlers({
[17:46:37.733]             ...future.value <- base::withVisible(base::local({
[17:46:37.733]                 ...future.makeSendCondition <- base::local({
[17:46:37.733]                   sendCondition <- NULL
[17:46:37.733]                   function(frame = 1L) {
[17:46:37.733]                     if (is.function(sendCondition)) 
[17:46:37.733]                       return(sendCondition)
[17:46:37.733]                     ns <- getNamespace("parallel")
[17:46:37.733]                     if (exists("sendData", mode = "function", 
[17:46:37.733]                       envir = ns)) {
[17:46:37.733]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:37.733]                         envir = ns)
[17:46:37.733]                       envir <- sys.frame(frame)
[17:46:37.733]                       master <- NULL
[17:46:37.733]                       while (!identical(envir, .GlobalEnv) && 
[17:46:37.733]                         !identical(envir, emptyenv())) {
[17:46:37.733]                         if (exists("master", mode = "list", envir = envir, 
[17:46:37.733]                           inherits = FALSE)) {
[17:46:37.733]                           master <- get("master", mode = "list", 
[17:46:37.733]                             envir = envir, inherits = FALSE)
[17:46:37.733]                           if (inherits(master, c("SOCKnode", 
[17:46:37.733]                             "SOCK0node"))) {
[17:46:37.733]                             sendCondition <<- function(cond) {
[17:46:37.733]                               data <- list(type = "VALUE", value = cond, 
[17:46:37.733]                                 success = TRUE)
[17:46:37.733]                               parallel_sendData(master, data)
[17:46:37.733]                             }
[17:46:37.733]                             return(sendCondition)
[17:46:37.733]                           }
[17:46:37.733]                         }
[17:46:37.733]                         frame <- frame + 1L
[17:46:37.733]                         envir <- sys.frame(frame)
[17:46:37.733]                       }
[17:46:37.733]                     }
[17:46:37.733]                     sendCondition <<- function(cond) NULL
[17:46:37.733]                   }
[17:46:37.733]                 })
[17:46:37.733]                 withCallingHandlers({
[17:46:37.733]                   {
[17:46:37.733]                     if (ii%%2 == 0) 
[17:46:37.733]                       stop("Woops!")
[17:46:37.733]                     ii
[17:46:37.733]                   }
[17:46:37.733]                 }, immediateCondition = function(cond) {
[17:46:37.733]                   sendCondition <- ...future.makeSendCondition()
[17:46:37.733]                   sendCondition(cond)
[17:46:37.733]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.733]                   {
[17:46:37.733]                     inherits <- base::inherits
[17:46:37.733]                     invokeRestart <- base::invokeRestart
[17:46:37.733]                     is.null <- base::is.null
[17:46:37.733]                     muffled <- FALSE
[17:46:37.733]                     if (inherits(cond, "message")) {
[17:46:37.733]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:37.733]                       if (muffled) 
[17:46:37.733]                         invokeRestart("muffleMessage")
[17:46:37.733]                     }
[17:46:37.733]                     else if (inherits(cond, "warning")) {
[17:46:37.733]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:37.733]                       if (muffled) 
[17:46:37.733]                         invokeRestart("muffleWarning")
[17:46:37.733]                     }
[17:46:37.733]                     else if (inherits(cond, "condition")) {
[17:46:37.733]                       if (!is.null(pattern)) {
[17:46:37.733]                         computeRestarts <- base::computeRestarts
[17:46:37.733]                         grepl <- base::grepl
[17:46:37.733]                         restarts <- computeRestarts(cond)
[17:46:37.733]                         for (restart in restarts) {
[17:46:37.733]                           name <- restart$name
[17:46:37.733]                           if (is.null(name)) 
[17:46:37.733]                             next
[17:46:37.733]                           if (!grepl(pattern, name)) 
[17:46:37.733]                             next
[17:46:37.733]                           invokeRestart(restart)
[17:46:37.733]                           muffled <- TRUE
[17:46:37.733]                           break
[17:46:37.733]                         }
[17:46:37.733]                       }
[17:46:37.733]                     }
[17:46:37.733]                     invisible(muffled)
[17:46:37.733]                   }
[17:46:37.733]                   muffleCondition(cond)
[17:46:37.733]                 })
[17:46:37.733]             }))
[17:46:37.733]             future::FutureResult(value = ...future.value$value, 
[17:46:37.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.733]                   ...future.rng), globalenv = if (FALSE) 
[17:46:37.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:37.733]                     ...future.globalenv.names))
[17:46:37.733]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:37.733]         }, condition = base::local({
[17:46:37.733]             c <- base::c
[17:46:37.733]             inherits <- base::inherits
[17:46:37.733]             invokeRestart <- base::invokeRestart
[17:46:37.733]             length <- base::length
[17:46:37.733]             list <- base::list
[17:46:37.733]             seq.int <- base::seq.int
[17:46:37.733]             signalCondition <- base::signalCondition
[17:46:37.733]             sys.calls <- base::sys.calls
[17:46:37.733]             `[[` <- base::`[[`
[17:46:37.733]             `+` <- base::`+`
[17:46:37.733]             `<<-` <- base::`<<-`
[17:46:37.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:37.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:37.733]                   3L)]
[17:46:37.733]             }
[17:46:37.733]             function(cond) {
[17:46:37.733]                 is_error <- inherits(cond, "error")
[17:46:37.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:37.733]                   NULL)
[17:46:37.733]                 if (is_error) {
[17:46:37.733]                   sessionInformation <- function() {
[17:46:37.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:37.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:37.733]                       search = base::search(), system = base::Sys.info())
[17:46:37.733]                   }
[17:46:37.733]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:37.733]                     cond$call), session = sessionInformation(), 
[17:46:37.733]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:37.733]                   signalCondition(cond)
[17:46:37.733]                 }
[17:46:37.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:37.733]                 "immediateCondition"))) {
[17:46:37.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:37.733]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:37.733]                   if (TRUE && !signal) {
[17:46:37.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.733]                     {
[17:46:37.733]                       inherits <- base::inherits
[17:46:37.733]                       invokeRestart <- base::invokeRestart
[17:46:37.733]                       is.null <- base::is.null
[17:46:37.733]                       muffled <- FALSE
[17:46:37.733]                       if (inherits(cond, "message")) {
[17:46:37.733]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.733]                         if (muffled) 
[17:46:37.733]                           invokeRestart("muffleMessage")
[17:46:37.733]                       }
[17:46:37.733]                       else if (inherits(cond, "warning")) {
[17:46:37.733]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.733]                         if (muffled) 
[17:46:37.733]                           invokeRestart("muffleWarning")
[17:46:37.733]                       }
[17:46:37.733]                       else if (inherits(cond, "condition")) {
[17:46:37.733]                         if (!is.null(pattern)) {
[17:46:37.733]                           computeRestarts <- base::computeRestarts
[17:46:37.733]                           grepl <- base::grepl
[17:46:37.733]                           restarts <- computeRestarts(cond)
[17:46:37.733]                           for (restart in restarts) {
[17:46:37.733]                             name <- restart$name
[17:46:37.733]                             if (is.null(name)) 
[17:46:37.733]                               next
[17:46:37.733]                             if (!grepl(pattern, name)) 
[17:46:37.733]                               next
[17:46:37.733]                             invokeRestart(restart)
[17:46:37.733]                             muffled <- TRUE
[17:46:37.733]                             break
[17:46:37.733]                           }
[17:46:37.733]                         }
[17:46:37.733]                       }
[17:46:37.733]                       invisible(muffled)
[17:46:37.733]                     }
[17:46:37.733]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.733]                   }
[17:46:37.733]                 }
[17:46:37.733]                 else {
[17:46:37.733]                   if (TRUE) {
[17:46:37.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.733]                     {
[17:46:37.733]                       inherits <- base::inherits
[17:46:37.733]                       invokeRestart <- base::invokeRestart
[17:46:37.733]                       is.null <- base::is.null
[17:46:37.733]                       muffled <- FALSE
[17:46:37.733]                       if (inherits(cond, "message")) {
[17:46:37.733]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.733]                         if (muffled) 
[17:46:37.733]                           invokeRestart("muffleMessage")
[17:46:37.733]                       }
[17:46:37.733]                       else if (inherits(cond, "warning")) {
[17:46:37.733]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.733]                         if (muffled) 
[17:46:37.733]                           invokeRestart("muffleWarning")
[17:46:37.733]                       }
[17:46:37.733]                       else if (inherits(cond, "condition")) {
[17:46:37.733]                         if (!is.null(pattern)) {
[17:46:37.733]                           computeRestarts <- base::computeRestarts
[17:46:37.733]                           grepl <- base::grepl
[17:46:37.733]                           restarts <- computeRestarts(cond)
[17:46:37.733]                           for (restart in restarts) {
[17:46:37.733]                             name <- restart$name
[17:46:37.733]                             if (is.null(name)) 
[17:46:37.733]                               next
[17:46:37.733]                             if (!grepl(pattern, name)) 
[17:46:37.733]                               next
[17:46:37.733]                             invokeRestart(restart)
[17:46:37.733]                             muffled <- TRUE
[17:46:37.733]                             break
[17:46:37.733]                           }
[17:46:37.733]                         }
[17:46:37.733]                       }
[17:46:37.733]                       invisible(muffled)
[17:46:37.733]                     }
[17:46:37.733]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.733]                   }
[17:46:37.733]                 }
[17:46:37.733]             }
[17:46:37.733]         }))
[17:46:37.733]     }, error = function(ex) {
[17:46:37.733]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:37.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.733]                 ...future.rng), started = ...future.startTime, 
[17:46:37.733]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:37.733]             version = "1.8"), class = "FutureResult")
[17:46:37.733]     }, finally = {
[17:46:37.733]         if (!identical(...future.workdir, getwd())) 
[17:46:37.733]             setwd(...future.workdir)
[17:46:37.733]         {
[17:46:37.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:37.733]                 ...future.oldOptions$nwarnings <- NULL
[17:46:37.733]             }
[17:46:37.733]             base::options(...future.oldOptions)
[17:46:37.733]             if (.Platform$OS.type == "windows") {
[17:46:37.733]                 old_names <- names(...future.oldEnvVars)
[17:46:37.733]                 envs <- base::Sys.getenv()
[17:46:37.733]                 names <- names(envs)
[17:46:37.733]                 common <- intersect(names, old_names)
[17:46:37.733]                 added <- setdiff(names, old_names)
[17:46:37.733]                 removed <- setdiff(old_names, names)
[17:46:37.733]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:37.733]                   envs[common]]
[17:46:37.733]                 NAMES <- toupper(changed)
[17:46:37.733]                 args <- list()
[17:46:37.733]                 for (kk in seq_along(NAMES)) {
[17:46:37.733]                   name <- changed[[kk]]
[17:46:37.733]                   NAME <- NAMES[[kk]]
[17:46:37.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.733]                     next
[17:46:37.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.733]                 }
[17:46:37.733]                 NAMES <- toupper(added)
[17:46:37.733]                 for (kk in seq_along(NAMES)) {
[17:46:37.733]                   name <- added[[kk]]
[17:46:37.733]                   NAME <- NAMES[[kk]]
[17:46:37.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.733]                     next
[17:46:37.733]                   args[[name]] <- ""
[17:46:37.733]                 }
[17:46:37.733]                 NAMES <- toupper(removed)
[17:46:37.733]                 for (kk in seq_along(NAMES)) {
[17:46:37.733]                   name <- removed[[kk]]
[17:46:37.733]                   NAME <- NAMES[[kk]]
[17:46:37.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.733]                     next
[17:46:37.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.733]                 }
[17:46:37.733]                 if (length(args) > 0) 
[17:46:37.733]                   base::do.call(base::Sys.setenv, args = args)
[17:46:37.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:37.733]             }
[17:46:37.733]             else {
[17:46:37.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:37.733]             }
[17:46:37.733]             {
[17:46:37.733]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:37.733]                   0L) {
[17:46:37.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:37.733]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:37.733]                   base::options(opts)
[17:46:37.733]                 }
[17:46:37.733]                 {
[17:46:37.733]                   {
[17:46:37.733]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:37.733]                     NULL
[17:46:37.733]                   }
[17:46:37.733]                   options(future.plan = NULL)
[17:46:37.733]                   if (is.na(NA_character_)) 
[17:46:37.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:37.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:37.733]                     .init = FALSE)
[17:46:37.733]                 }
[17:46:37.733]             }
[17:46:37.733]         }
[17:46:37.733]     })
[17:46:37.733]     if (TRUE) {
[17:46:37.733]         base::sink(type = "output", split = FALSE)
[17:46:37.733]         if (TRUE) {
[17:46:37.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:37.733]         }
[17:46:37.733]         else {
[17:46:37.733]             ...future.result["stdout"] <- base::list(NULL)
[17:46:37.733]         }
[17:46:37.733]         base::close(...future.stdout)
[17:46:37.733]         ...future.stdout <- NULL
[17:46:37.733]     }
[17:46:37.733]     ...future.result$conditions <- ...future.conditions
[17:46:37.733]     ...future.result$finished <- base::Sys.time()
[17:46:37.733]     ...future.result
[17:46:37.733] }
[17:46:37.735] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:46:37.735] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:46:37.736] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:46:37.736] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:46:37.736] MultisessionFuture started
[17:46:37.736] - Launch lazy future ... done
[17:46:37.737] run() for ‘MultisessionFuture’ ... done
[17:46:37.737] getGlobalsAndPackages() ...
[17:46:37.737] Searching for globals...
[17:46:37.738] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:46:37.738] Searching for globals ... DONE
[17:46:37.739] Resolving globals: FALSE
[17:46:37.739] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:37.739] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:46:37.740] - globals: [1] ‘ii’
[17:46:37.740] 
[17:46:37.740] getGlobalsAndPackages() ... DONE
[17:46:37.740] run() for ‘Future’ ...
[17:46:37.740] - state: ‘created’
[17:46:37.740] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:37.754] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:37.754] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:37.754]   - Field: ‘node’
[17:46:37.754]   - Field: ‘label’
[17:46:37.754]   - Field: ‘local’
[17:46:37.755]   - Field: ‘owner’
[17:46:37.755]   - Field: ‘envir’
[17:46:37.755]   - Field: ‘workers’
[17:46:37.755]   - Field: ‘packages’
[17:46:37.755]   - Field: ‘gc’
[17:46:37.755]   - Field: ‘conditions’
[17:46:37.755]   - Field: ‘persistent’
[17:46:37.755]   - Field: ‘expr’
[17:46:37.755]   - Field: ‘uuid’
[17:46:37.755]   - Field: ‘seed’
[17:46:37.755]   - Field: ‘version’
[17:46:37.756]   - Field: ‘result’
[17:46:37.756]   - Field: ‘asynchronous’
[17:46:37.756]   - Field: ‘calls’
[17:46:37.756]   - Field: ‘globals’
[17:46:37.756]   - Field: ‘stdout’
[17:46:37.756]   - Field: ‘earlySignal’
[17:46:37.756]   - Field: ‘lazy’
[17:46:37.756]   - Field: ‘state’
[17:46:37.756] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:37.756] - Launch lazy future ...
[17:46:37.757] Packages needed by the future expression (n = 0): <none>
[17:46:37.757] Packages needed by future strategies (n = 0): <none>
[17:46:37.757] {
[17:46:37.757]     {
[17:46:37.757]         {
[17:46:37.757]             ...future.startTime <- base::Sys.time()
[17:46:37.757]             {
[17:46:37.757]                 {
[17:46:37.757]                   {
[17:46:37.757]                     {
[17:46:37.757]                       base::local({
[17:46:37.757]                         has_future <- base::requireNamespace("future", 
[17:46:37.757]                           quietly = TRUE)
[17:46:37.757]                         if (has_future) {
[17:46:37.757]                           ns <- base::getNamespace("future")
[17:46:37.757]                           version <- ns[[".package"]][["version"]]
[17:46:37.757]                           if (is.null(version)) 
[17:46:37.757]                             version <- utils::packageVersion("future")
[17:46:37.757]                         }
[17:46:37.757]                         else {
[17:46:37.757]                           version <- NULL
[17:46:37.757]                         }
[17:46:37.757]                         if (!has_future || version < "1.8.0") {
[17:46:37.757]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:37.757]                             "", base::R.version$version.string), 
[17:46:37.757]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:37.757]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:37.757]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:37.757]                               "release", "version")], collapse = " "), 
[17:46:37.757]                             hostname = base::Sys.info()[["nodename"]])
[17:46:37.757]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:37.757]                             info)
[17:46:37.757]                           info <- base::paste(info, collapse = "; ")
[17:46:37.757]                           if (!has_future) {
[17:46:37.757]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:37.757]                               info)
[17:46:37.757]                           }
[17:46:37.757]                           else {
[17:46:37.757]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:37.757]                               info, version)
[17:46:37.757]                           }
[17:46:37.757]                           base::stop(msg)
[17:46:37.757]                         }
[17:46:37.757]                       })
[17:46:37.757]                     }
[17:46:37.757]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:37.757]                     base::options(mc.cores = 1L)
[17:46:37.757]                   }
[17:46:37.757]                   ...future.strategy.old <- future::plan("list")
[17:46:37.757]                   options(future.plan = NULL)
[17:46:37.757]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.757]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:37.757]                 }
[17:46:37.757]                 ...future.workdir <- getwd()
[17:46:37.757]             }
[17:46:37.757]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:37.757]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:37.757]         }
[17:46:37.757]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:37.757]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:37.757]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:37.757]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:37.757]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:37.757]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:37.757]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:37.757]             base::names(...future.oldOptions))
[17:46:37.757]     }
[17:46:37.757]     if (FALSE) {
[17:46:37.757]     }
[17:46:37.757]     else {
[17:46:37.757]         if (TRUE) {
[17:46:37.757]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:37.757]                 open = "w")
[17:46:37.757]         }
[17:46:37.757]         else {
[17:46:37.757]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:37.757]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:37.757]         }
[17:46:37.757]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:37.757]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:37.757]             base::sink(type = "output", split = FALSE)
[17:46:37.757]             base::close(...future.stdout)
[17:46:37.757]         }, add = TRUE)
[17:46:37.757]     }
[17:46:37.757]     ...future.frame <- base::sys.nframe()
[17:46:37.757]     ...future.conditions <- base::list()
[17:46:37.757]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:37.757]     if (FALSE) {
[17:46:37.757]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:37.757]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:37.757]     }
[17:46:37.757]     ...future.result <- base::tryCatch({
[17:46:37.757]         base::withCallingHandlers({
[17:46:37.757]             ...future.value <- base::withVisible(base::local({
[17:46:37.757]                 ...future.makeSendCondition <- base::local({
[17:46:37.757]                   sendCondition <- NULL
[17:46:37.757]                   function(frame = 1L) {
[17:46:37.757]                     if (is.function(sendCondition)) 
[17:46:37.757]                       return(sendCondition)
[17:46:37.757]                     ns <- getNamespace("parallel")
[17:46:37.757]                     if (exists("sendData", mode = "function", 
[17:46:37.757]                       envir = ns)) {
[17:46:37.757]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:37.757]                         envir = ns)
[17:46:37.757]                       envir <- sys.frame(frame)
[17:46:37.757]                       master <- NULL
[17:46:37.757]                       while (!identical(envir, .GlobalEnv) && 
[17:46:37.757]                         !identical(envir, emptyenv())) {
[17:46:37.757]                         if (exists("master", mode = "list", envir = envir, 
[17:46:37.757]                           inherits = FALSE)) {
[17:46:37.757]                           master <- get("master", mode = "list", 
[17:46:37.757]                             envir = envir, inherits = FALSE)
[17:46:37.757]                           if (inherits(master, c("SOCKnode", 
[17:46:37.757]                             "SOCK0node"))) {
[17:46:37.757]                             sendCondition <<- function(cond) {
[17:46:37.757]                               data <- list(type = "VALUE", value = cond, 
[17:46:37.757]                                 success = TRUE)
[17:46:37.757]                               parallel_sendData(master, data)
[17:46:37.757]                             }
[17:46:37.757]                             return(sendCondition)
[17:46:37.757]                           }
[17:46:37.757]                         }
[17:46:37.757]                         frame <- frame + 1L
[17:46:37.757]                         envir <- sys.frame(frame)
[17:46:37.757]                       }
[17:46:37.757]                     }
[17:46:37.757]                     sendCondition <<- function(cond) NULL
[17:46:37.757]                   }
[17:46:37.757]                 })
[17:46:37.757]                 withCallingHandlers({
[17:46:37.757]                   {
[17:46:37.757]                     if (ii%%2 == 0) 
[17:46:37.757]                       stop("Woops!")
[17:46:37.757]                     ii
[17:46:37.757]                   }
[17:46:37.757]                 }, immediateCondition = function(cond) {
[17:46:37.757]                   sendCondition <- ...future.makeSendCondition()
[17:46:37.757]                   sendCondition(cond)
[17:46:37.757]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.757]                   {
[17:46:37.757]                     inherits <- base::inherits
[17:46:37.757]                     invokeRestart <- base::invokeRestart
[17:46:37.757]                     is.null <- base::is.null
[17:46:37.757]                     muffled <- FALSE
[17:46:37.757]                     if (inherits(cond, "message")) {
[17:46:37.757]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:37.757]                       if (muffled) 
[17:46:37.757]                         invokeRestart("muffleMessage")
[17:46:37.757]                     }
[17:46:37.757]                     else if (inherits(cond, "warning")) {
[17:46:37.757]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:37.757]                       if (muffled) 
[17:46:37.757]                         invokeRestart("muffleWarning")
[17:46:37.757]                     }
[17:46:37.757]                     else if (inherits(cond, "condition")) {
[17:46:37.757]                       if (!is.null(pattern)) {
[17:46:37.757]                         computeRestarts <- base::computeRestarts
[17:46:37.757]                         grepl <- base::grepl
[17:46:37.757]                         restarts <- computeRestarts(cond)
[17:46:37.757]                         for (restart in restarts) {
[17:46:37.757]                           name <- restart$name
[17:46:37.757]                           if (is.null(name)) 
[17:46:37.757]                             next
[17:46:37.757]                           if (!grepl(pattern, name)) 
[17:46:37.757]                             next
[17:46:37.757]                           invokeRestart(restart)
[17:46:37.757]                           muffled <- TRUE
[17:46:37.757]                           break
[17:46:37.757]                         }
[17:46:37.757]                       }
[17:46:37.757]                     }
[17:46:37.757]                     invisible(muffled)
[17:46:37.757]                   }
[17:46:37.757]                   muffleCondition(cond)
[17:46:37.757]                 })
[17:46:37.757]             }))
[17:46:37.757]             future::FutureResult(value = ...future.value$value, 
[17:46:37.757]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.757]                   ...future.rng), globalenv = if (FALSE) 
[17:46:37.757]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:37.757]                     ...future.globalenv.names))
[17:46:37.757]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:37.757]         }, condition = base::local({
[17:46:37.757]             c <- base::c
[17:46:37.757]             inherits <- base::inherits
[17:46:37.757]             invokeRestart <- base::invokeRestart
[17:46:37.757]             length <- base::length
[17:46:37.757]             list <- base::list
[17:46:37.757]             seq.int <- base::seq.int
[17:46:37.757]             signalCondition <- base::signalCondition
[17:46:37.757]             sys.calls <- base::sys.calls
[17:46:37.757]             `[[` <- base::`[[`
[17:46:37.757]             `+` <- base::`+`
[17:46:37.757]             `<<-` <- base::`<<-`
[17:46:37.757]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:37.757]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:37.757]                   3L)]
[17:46:37.757]             }
[17:46:37.757]             function(cond) {
[17:46:37.757]                 is_error <- inherits(cond, "error")
[17:46:37.757]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:37.757]                   NULL)
[17:46:37.757]                 if (is_error) {
[17:46:37.757]                   sessionInformation <- function() {
[17:46:37.757]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:37.757]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:37.757]                       search = base::search(), system = base::Sys.info())
[17:46:37.757]                   }
[17:46:37.757]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.757]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:37.757]                     cond$call), session = sessionInformation(), 
[17:46:37.757]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:37.757]                   signalCondition(cond)
[17:46:37.757]                 }
[17:46:37.757]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:37.757]                 "immediateCondition"))) {
[17:46:37.757]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:37.757]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.757]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:37.757]                   if (TRUE && !signal) {
[17:46:37.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.757]                     {
[17:46:37.757]                       inherits <- base::inherits
[17:46:37.757]                       invokeRestart <- base::invokeRestart
[17:46:37.757]                       is.null <- base::is.null
[17:46:37.757]                       muffled <- FALSE
[17:46:37.757]                       if (inherits(cond, "message")) {
[17:46:37.757]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.757]                         if (muffled) 
[17:46:37.757]                           invokeRestart("muffleMessage")
[17:46:37.757]                       }
[17:46:37.757]                       else if (inherits(cond, "warning")) {
[17:46:37.757]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.757]                         if (muffled) 
[17:46:37.757]                           invokeRestart("muffleWarning")
[17:46:37.757]                       }
[17:46:37.757]                       else if (inherits(cond, "condition")) {
[17:46:37.757]                         if (!is.null(pattern)) {
[17:46:37.757]                           computeRestarts <- base::computeRestarts
[17:46:37.757]                           grepl <- base::grepl
[17:46:37.757]                           restarts <- computeRestarts(cond)
[17:46:37.757]                           for (restart in restarts) {
[17:46:37.757]                             name <- restart$name
[17:46:37.757]                             if (is.null(name)) 
[17:46:37.757]                               next
[17:46:37.757]                             if (!grepl(pattern, name)) 
[17:46:37.757]                               next
[17:46:37.757]                             invokeRestart(restart)
[17:46:37.757]                             muffled <- TRUE
[17:46:37.757]                             break
[17:46:37.757]                           }
[17:46:37.757]                         }
[17:46:37.757]                       }
[17:46:37.757]                       invisible(muffled)
[17:46:37.757]                     }
[17:46:37.757]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.757]                   }
[17:46:37.757]                 }
[17:46:37.757]                 else {
[17:46:37.757]                   if (TRUE) {
[17:46:37.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.757]                     {
[17:46:37.757]                       inherits <- base::inherits
[17:46:37.757]                       invokeRestart <- base::invokeRestart
[17:46:37.757]                       is.null <- base::is.null
[17:46:37.757]                       muffled <- FALSE
[17:46:37.757]                       if (inherits(cond, "message")) {
[17:46:37.757]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.757]                         if (muffled) 
[17:46:37.757]                           invokeRestart("muffleMessage")
[17:46:37.757]                       }
[17:46:37.757]                       else if (inherits(cond, "warning")) {
[17:46:37.757]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.757]                         if (muffled) 
[17:46:37.757]                           invokeRestart("muffleWarning")
[17:46:37.757]                       }
[17:46:37.757]                       else if (inherits(cond, "condition")) {
[17:46:37.757]                         if (!is.null(pattern)) {
[17:46:37.757]                           computeRestarts <- base::computeRestarts
[17:46:37.757]                           grepl <- base::grepl
[17:46:37.757]                           restarts <- computeRestarts(cond)
[17:46:37.757]                           for (restart in restarts) {
[17:46:37.757]                             name <- restart$name
[17:46:37.757]                             if (is.null(name)) 
[17:46:37.757]                               next
[17:46:37.757]                             if (!grepl(pattern, name)) 
[17:46:37.757]                               next
[17:46:37.757]                             invokeRestart(restart)
[17:46:37.757]                             muffled <- TRUE
[17:46:37.757]                             break
[17:46:37.757]                           }
[17:46:37.757]                         }
[17:46:37.757]                       }
[17:46:37.757]                       invisible(muffled)
[17:46:37.757]                     }
[17:46:37.757]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.757]                   }
[17:46:37.757]                 }
[17:46:37.757]             }
[17:46:37.757]         }))
[17:46:37.757]     }, error = function(ex) {
[17:46:37.757]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:37.757]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.757]                 ...future.rng), started = ...future.startTime, 
[17:46:37.757]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:37.757]             version = "1.8"), class = "FutureResult")
[17:46:37.757]     }, finally = {
[17:46:37.757]         if (!identical(...future.workdir, getwd())) 
[17:46:37.757]             setwd(...future.workdir)
[17:46:37.757]         {
[17:46:37.757]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:37.757]                 ...future.oldOptions$nwarnings <- NULL
[17:46:37.757]             }
[17:46:37.757]             base::options(...future.oldOptions)
[17:46:37.757]             if (.Platform$OS.type == "windows") {
[17:46:37.757]                 old_names <- names(...future.oldEnvVars)
[17:46:37.757]                 envs <- base::Sys.getenv()
[17:46:37.757]                 names <- names(envs)
[17:46:37.757]                 common <- intersect(names, old_names)
[17:46:37.757]                 added <- setdiff(names, old_names)
[17:46:37.757]                 removed <- setdiff(old_names, names)
[17:46:37.757]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:37.757]                   envs[common]]
[17:46:37.757]                 NAMES <- toupper(changed)
[17:46:37.757]                 args <- list()
[17:46:37.757]                 for (kk in seq_along(NAMES)) {
[17:46:37.757]                   name <- changed[[kk]]
[17:46:37.757]                   NAME <- NAMES[[kk]]
[17:46:37.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.757]                     next
[17:46:37.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.757]                 }
[17:46:37.757]                 NAMES <- toupper(added)
[17:46:37.757]                 for (kk in seq_along(NAMES)) {
[17:46:37.757]                   name <- added[[kk]]
[17:46:37.757]                   NAME <- NAMES[[kk]]
[17:46:37.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.757]                     next
[17:46:37.757]                   args[[name]] <- ""
[17:46:37.757]                 }
[17:46:37.757]                 NAMES <- toupper(removed)
[17:46:37.757]                 for (kk in seq_along(NAMES)) {
[17:46:37.757]                   name <- removed[[kk]]
[17:46:37.757]                   NAME <- NAMES[[kk]]
[17:46:37.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.757]                     next
[17:46:37.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.757]                 }
[17:46:37.757]                 if (length(args) > 0) 
[17:46:37.757]                   base::do.call(base::Sys.setenv, args = args)
[17:46:37.757]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:37.757]             }
[17:46:37.757]             else {
[17:46:37.757]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:37.757]             }
[17:46:37.757]             {
[17:46:37.757]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:37.757]                   0L) {
[17:46:37.757]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:37.757]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:37.757]                   base::options(opts)
[17:46:37.757]                 }
[17:46:37.757]                 {
[17:46:37.757]                   {
[17:46:37.757]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:37.757]                     NULL
[17:46:37.757]                   }
[17:46:37.757]                   options(future.plan = NULL)
[17:46:37.757]                   if (is.na(NA_character_)) 
[17:46:37.757]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.757]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:37.757]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:37.757]                     .init = FALSE)
[17:46:37.757]                 }
[17:46:37.757]             }
[17:46:37.757]         }
[17:46:37.757]     })
[17:46:37.757]     if (TRUE) {
[17:46:37.757]         base::sink(type = "output", split = FALSE)
[17:46:37.757]         if (TRUE) {
[17:46:37.757]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:37.757]         }
[17:46:37.757]         else {
[17:46:37.757]             ...future.result["stdout"] <- base::list(NULL)
[17:46:37.757]         }
[17:46:37.757]         base::close(...future.stdout)
[17:46:37.757]         ...future.stdout <- NULL
[17:46:37.757]     }
[17:46:37.757]     ...future.result$conditions <- ...future.conditions
[17:46:37.757]     ...future.result$finished <- base::Sys.time()
[17:46:37.757]     ...future.result
[17:46:37.757] }
[17:46:37.809] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:46:37.810] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:46:37.810] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:46:37.810] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:46:37.811] MultisessionFuture started
[17:46:37.811] - Launch lazy future ... done
[17:46:37.811] run() for ‘MultisessionFuture’ ... done
[17:46:37.811] getGlobalsAndPackages() ...
[17:46:37.811] Searching for globals...
[17:46:37.813] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[17:46:37.813] Searching for globals ... DONE
[17:46:37.813] Resolving globals: FALSE
[17:46:37.814] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:37.814] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:46:37.814] - globals: [1] ‘ii’
[17:46:37.814] 
[17:46:37.814] getGlobalsAndPackages() ... DONE
[17:46:37.815] run() for ‘Future’ ...
[17:46:37.815] - state: ‘created’
[17:46:37.815] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:37.829] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:37.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:37.829]   - Field: ‘node’
[17:46:37.829]   - Field: ‘label’
[17:46:37.829]   - Field: ‘local’
[17:46:37.829]   - Field: ‘owner’
[17:46:37.830]   - Field: ‘envir’
[17:46:37.830]   - Field: ‘workers’
[17:46:37.830]   - Field: ‘packages’
[17:46:37.830]   - Field: ‘gc’
[17:46:37.830]   - Field: ‘conditions’
[17:46:37.830]   - Field: ‘persistent’
[17:46:37.830]   - Field: ‘expr’
[17:46:37.830]   - Field: ‘uuid’
[17:46:37.830]   - Field: ‘seed’
[17:46:37.830]   - Field: ‘version’
[17:46:37.830]   - Field: ‘result’
[17:46:37.831]   - Field: ‘asynchronous’
[17:46:37.831]   - Field: ‘calls’
[17:46:37.831]   - Field: ‘globals’
[17:46:37.831]   - Field: ‘stdout’
[17:46:37.831]   - Field: ‘earlySignal’
[17:46:37.831]   - Field: ‘lazy’
[17:46:37.831]   - Field: ‘state’
[17:46:37.831] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:37.831] - Launch lazy future ...
[17:46:37.832] Packages needed by the future expression (n = 0): <none>
[17:46:37.832] Packages needed by future strategies (n = 0): <none>
[17:46:37.832] {
[17:46:37.832]     {
[17:46:37.832]         {
[17:46:37.832]             ...future.startTime <- base::Sys.time()
[17:46:37.832]             {
[17:46:37.832]                 {
[17:46:37.832]                   {
[17:46:37.832]                     {
[17:46:37.832]                       base::local({
[17:46:37.832]                         has_future <- base::requireNamespace("future", 
[17:46:37.832]                           quietly = TRUE)
[17:46:37.832]                         if (has_future) {
[17:46:37.832]                           ns <- base::getNamespace("future")
[17:46:37.832]                           version <- ns[[".package"]][["version"]]
[17:46:37.832]                           if (is.null(version)) 
[17:46:37.832]                             version <- utils::packageVersion("future")
[17:46:37.832]                         }
[17:46:37.832]                         else {
[17:46:37.832]                           version <- NULL
[17:46:37.832]                         }
[17:46:37.832]                         if (!has_future || version < "1.8.0") {
[17:46:37.832]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:37.832]                             "", base::R.version$version.string), 
[17:46:37.832]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:37.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:37.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:37.832]                               "release", "version")], collapse = " "), 
[17:46:37.832]                             hostname = base::Sys.info()[["nodename"]])
[17:46:37.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:37.832]                             info)
[17:46:37.832]                           info <- base::paste(info, collapse = "; ")
[17:46:37.832]                           if (!has_future) {
[17:46:37.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:37.832]                               info)
[17:46:37.832]                           }
[17:46:37.832]                           else {
[17:46:37.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:37.832]                               info, version)
[17:46:37.832]                           }
[17:46:37.832]                           base::stop(msg)
[17:46:37.832]                         }
[17:46:37.832]                       })
[17:46:37.832]                     }
[17:46:37.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:37.832]                     base::options(mc.cores = 1L)
[17:46:37.832]                   }
[17:46:37.832]                   ...future.strategy.old <- future::plan("list")
[17:46:37.832]                   options(future.plan = NULL)
[17:46:37.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:37.832]                 }
[17:46:37.832]                 ...future.workdir <- getwd()
[17:46:37.832]             }
[17:46:37.832]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:37.832]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:37.832]         }
[17:46:37.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:37.832]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:37.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:37.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:37.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:37.832]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:37.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:37.832]             base::names(...future.oldOptions))
[17:46:37.832]     }
[17:46:37.832]     if (FALSE) {
[17:46:37.832]     }
[17:46:37.832]     else {
[17:46:37.832]         if (TRUE) {
[17:46:37.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:37.832]                 open = "w")
[17:46:37.832]         }
[17:46:37.832]         else {
[17:46:37.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:37.832]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:37.832]         }
[17:46:37.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:37.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:37.832]             base::sink(type = "output", split = FALSE)
[17:46:37.832]             base::close(...future.stdout)
[17:46:37.832]         }, add = TRUE)
[17:46:37.832]     }
[17:46:37.832]     ...future.frame <- base::sys.nframe()
[17:46:37.832]     ...future.conditions <- base::list()
[17:46:37.832]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:37.832]     if (FALSE) {
[17:46:37.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:37.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:37.832]     }
[17:46:37.832]     ...future.result <- base::tryCatch({
[17:46:37.832]         base::withCallingHandlers({
[17:46:37.832]             ...future.value <- base::withVisible(base::local({
[17:46:37.832]                 ...future.makeSendCondition <- base::local({
[17:46:37.832]                   sendCondition <- NULL
[17:46:37.832]                   function(frame = 1L) {
[17:46:37.832]                     if (is.function(sendCondition)) 
[17:46:37.832]                       return(sendCondition)
[17:46:37.832]                     ns <- getNamespace("parallel")
[17:46:37.832]                     if (exists("sendData", mode = "function", 
[17:46:37.832]                       envir = ns)) {
[17:46:37.832]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:37.832]                         envir = ns)
[17:46:37.832]                       envir <- sys.frame(frame)
[17:46:37.832]                       master <- NULL
[17:46:37.832]                       while (!identical(envir, .GlobalEnv) && 
[17:46:37.832]                         !identical(envir, emptyenv())) {
[17:46:37.832]                         if (exists("master", mode = "list", envir = envir, 
[17:46:37.832]                           inherits = FALSE)) {
[17:46:37.832]                           master <- get("master", mode = "list", 
[17:46:37.832]                             envir = envir, inherits = FALSE)
[17:46:37.832]                           if (inherits(master, c("SOCKnode", 
[17:46:37.832]                             "SOCK0node"))) {
[17:46:37.832]                             sendCondition <<- function(cond) {
[17:46:37.832]                               data <- list(type = "VALUE", value = cond, 
[17:46:37.832]                                 success = TRUE)
[17:46:37.832]                               parallel_sendData(master, data)
[17:46:37.832]                             }
[17:46:37.832]                             return(sendCondition)
[17:46:37.832]                           }
[17:46:37.832]                         }
[17:46:37.832]                         frame <- frame + 1L
[17:46:37.832]                         envir <- sys.frame(frame)
[17:46:37.832]                       }
[17:46:37.832]                     }
[17:46:37.832]                     sendCondition <<- function(cond) NULL
[17:46:37.832]                   }
[17:46:37.832]                 })
[17:46:37.832]                 withCallingHandlers({
[17:46:37.832]                   {
[17:46:37.832]                     if (ii%%2 == 0) 
[17:46:37.832]                       stop("Woops!")
[17:46:37.832]                     ii
[17:46:37.832]                   }
[17:46:37.832]                 }, immediateCondition = function(cond) {
[17:46:37.832]                   sendCondition <- ...future.makeSendCondition()
[17:46:37.832]                   sendCondition(cond)
[17:46:37.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.832]                   {
[17:46:37.832]                     inherits <- base::inherits
[17:46:37.832]                     invokeRestart <- base::invokeRestart
[17:46:37.832]                     is.null <- base::is.null
[17:46:37.832]                     muffled <- FALSE
[17:46:37.832]                     if (inherits(cond, "message")) {
[17:46:37.832]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:37.832]                       if (muffled) 
[17:46:37.832]                         invokeRestart("muffleMessage")
[17:46:37.832]                     }
[17:46:37.832]                     else if (inherits(cond, "warning")) {
[17:46:37.832]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:37.832]                       if (muffled) 
[17:46:37.832]                         invokeRestart("muffleWarning")
[17:46:37.832]                     }
[17:46:37.832]                     else if (inherits(cond, "condition")) {
[17:46:37.832]                       if (!is.null(pattern)) {
[17:46:37.832]                         computeRestarts <- base::computeRestarts
[17:46:37.832]                         grepl <- base::grepl
[17:46:37.832]                         restarts <- computeRestarts(cond)
[17:46:37.832]                         for (restart in restarts) {
[17:46:37.832]                           name <- restart$name
[17:46:37.832]                           if (is.null(name)) 
[17:46:37.832]                             next
[17:46:37.832]                           if (!grepl(pattern, name)) 
[17:46:37.832]                             next
[17:46:37.832]                           invokeRestart(restart)
[17:46:37.832]                           muffled <- TRUE
[17:46:37.832]                           break
[17:46:37.832]                         }
[17:46:37.832]                       }
[17:46:37.832]                     }
[17:46:37.832]                     invisible(muffled)
[17:46:37.832]                   }
[17:46:37.832]                   muffleCondition(cond)
[17:46:37.832]                 })
[17:46:37.832]             }))
[17:46:37.832]             future::FutureResult(value = ...future.value$value, 
[17:46:37.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.832]                   ...future.rng), globalenv = if (FALSE) 
[17:46:37.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:37.832]                     ...future.globalenv.names))
[17:46:37.832]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:37.832]         }, condition = base::local({
[17:46:37.832]             c <- base::c
[17:46:37.832]             inherits <- base::inherits
[17:46:37.832]             invokeRestart <- base::invokeRestart
[17:46:37.832]             length <- base::length
[17:46:37.832]             list <- base::list
[17:46:37.832]             seq.int <- base::seq.int
[17:46:37.832]             signalCondition <- base::signalCondition
[17:46:37.832]             sys.calls <- base::sys.calls
[17:46:37.832]             `[[` <- base::`[[`
[17:46:37.832]             `+` <- base::`+`
[17:46:37.832]             `<<-` <- base::`<<-`
[17:46:37.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:37.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:37.832]                   3L)]
[17:46:37.832]             }
[17:46:37.832]             function(cond) {
[17:46:37.832]                 is_error <- inherits(cond, "error")
[17:46:37.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:37.832]                   NULL)
[17:46:37.832]                 if (is_error) {
[17:46:37.832]                   sessionInformation <- function() {
[17:46:37.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:37.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:37.832]                       search = base::search(), system = base::Sys.info())
[17:46:37.832]                   }
[17:46:37.832]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:37.832]                     cond$call), session = sessionInformation(), 
[17:46:37.832]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:37.832]                   signalCondition(cond)
[17:46:37.832]                 }
[17:46:37.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:37.832]                 "immediateCondition"))) {
[17:46:37.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:37.832]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:37.832]                   if (TRUE && !signal) {
[17:46:37.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.832]                     {
[17:46:37.832]                       inherits <- base::inherits
[17:46:37.832]                       invokeRestart <- base::invokeRestart
[17:46:37.832]                       is.null <- base::is.null
[17:46:37.832]                       muffled <- FALSE
[17:46:37.832]                       if (inherits(cond, "message")) {
[17:46:37.832]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.832]                         if (muffled) 
[17:46:37.832]                           invokeRestart("muffleMessage")
[17:46:37.832]                       }
[17:46:37.832]                       else if (inherits(cond, "warning")) {
[17:46:37.832]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.832]                         if (muffled) 
[17:46:37.832]                           invokeRestart("muffleWarning")
[17:46:37.832]                       }
[17:46:37.832]                       else if (inherits(cond, "condition")) {
[17:46:37.832]                         if (!is.null(pattern)) {
[17:46:37.832]                           computeRestarts <- base::computeRestarts
[17:46:37.832]                           grepl <- base::grepl
[17:46:37.832]                           restarts <- computeRestarts(cond)
[17:46:37.832]                           for (restart in restarts) {
[17:46:37.832]                             name <- restart$name
[17:46:37.832]                             if (is.null(name)) 
[17:46:37.832]                               next
[17:46:37.832]                             if (!grepl(pattern, name)) 
[17:46:37.832]                               next
[17:46:37.832]                             invokeRestart(restart)
[17:46:37.832]                             muffled <- TRUE
[17:46:37.832]                             break
[17:46:37.832]                           }
[17:46:37.832]                         }
[17:46:37.832]                       }
[17:46:37.832]                       invisible(muffled)
[17:46:37.832]                     }
[17:46:37.832]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.832]                   }
[17:46:37.832]                 }
[17:46:37.832]                 else {
[17:46:37.832]                   if (TRUE) {
[17:46:37.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.832]                     {
[17:46:37.832]                       inherits <- base::inherits
[17:46:37.832]                       invokeRestart <- base::invokeRestart
[17:46:37.832]                       is.null <- base::is.null
[17:46:37.832]                       muffled <- FALSE
[17:46:37.832]                       if (inherits(cond, "message")) {
[17:46:37.832]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.832]                         if (muffled) 
[17:46:37.832]                           invokeRestart("muffleMessage")
[17:46:37.832]                       }
[17:46:37.832]                       else if (inherits(cond, "warning")) {
[17:46:37.832]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.832]                         if (muffled) 
[17:46:37.832]                           invokeRestart("muffleWarning")
[17:46:37.832]                       }
[17:46:37.832]                       else if (inherits(cond, "condition")) {
[17:46:37.832]                         if (!is.null(pattern)) {
[17:46:37.832]                           computeRestarts <- base::computeRestarts
[17:46:37.832]                           grepl <- base::grepl
[17:46:37.832]                           restarts <- computeRestarts(cond)
[17:46:37.832]                           for (restart in restarts) {
[17:46:37.832]                             name <- restart$name
[17:46:37.832]                             if (is.null(name)) 
[17:46:37.832]                               next
[17:46:37.832]                             if (!grepl(pattern, name)) 
[17:46:37.832]                               next
[17:46:37.832]                             invokeRestart(restart)
[17:46:37.832]                             muffled <- TRUE
[17:46:37.832]                             break
[17:46:37.832]                           }
[17:46:37.832]                         }
[17:46:37.832]                       }
[17:46:37.832]                       invisible(muffled)
[17:46:37.832]                     }
[17:46:37.832]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.832]                   }
[17:46:37.832]                 }
[17:46:37.832]             }
[17:46:37.832]         }))
[17:46:37.832]     }, error = function(ex) {
[17:46:37.832]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:37.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.832]                 ...future.rng), started = ...future.startTime, 
[17:46:37.832]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:37.832]             version = "1.8"), class = "FutureResult")
[17:46:37.832]     }, finally = {
[17:46:37.832]         if (!identical(...future.workdir, getwd())) 
[17:46:37.832]             setwd(...future.workdir)
[17:46:37.832]         {
[17:46:37.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:37.832]                 ...future.oldOptions$nwarnings <- NULL
[17:46:37.832]             }
[17:46:37.832]             base::options(...future.oldOptions)
[17:46:37.832]             if (.Platform$OS.type == "windows") {
[17:46:37.832]                 old_names <- names(...future.oldEnvVars)
[17:46:37.832]                 envs <- base::Sys.getenv()
[17:46:37.832]                 names <- names(envs)
[17:46:37.832]                 common <- intersect(names, old_names)
[17:46:37.832]                 added <- setdiff(names, old_names)
[17:46:37.832]                 removed <- setdiff(old_names, names)
[17:46:37.832]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:37.832]                   envs[common]]
[17:46:37.832]                 NAMES <- toupper(changed)
[17:46:37.832]                 args <- list()
[17:46:37.832]                 for (kk in seq_along(NAMES)) {
[17:46:37.832]                   name <- changed[[kk]]
[17:46:37.832]                   NAME <- NAMES[[kk]]
[17:46:37.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.832]                     next
[17:46:37.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.832]                 }
[17:46:37.832]                 NAMES <- toupper(added)
[17:46:37.832]                 for (kk in seq_along(NAMES)) {
[17:46:37.832]                   name <- added[[kk]]
[17:46:37.832]                   NAME <- NAMES[[kk]]
[17:46:37.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.832]                     next
[17:46:37.832]                   args[[name]] <- ""
[17:46:37.832]                 }
[17:46:37.832]                 NAMES <- toupper(removed)
[17:46:37.832]                 for (kk in seq_along(NAMES)) {
[17:46:37.832]                   name <- removed[[kk]]
[17:46:37.832]                   NAME <- NAMES[[kk]]
[17:46:37.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.832]                     next
[17:46:37.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.832]                 }
[17:46:37.832]                 if (length(args) > 0) 
[17:46:37.832]                   base::do.call(base::Sys.setenv, args = args)
[17:46:37.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:37.832]             }
[17:46:37.832]             else {
[17:46:37.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:37.832]             }
[17:46:37.832]             {
[17:46:37.832]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:37.832]                   0L) {
[17:46:37.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:37.832]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:37.832]                   base::options(opts)
[17:46:37.832]                 }
[17:46:37.832]                 {
[17:46:37.832]                   {
[17:46:37.832]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:37.832]                     NULL
[17:46:37.832]                   }
[17:46:37.832]                   options(future.plan = NULL)
[17:46:37.832]                   if (is.na(NA_character_)) 
[17:46:37.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:37.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:37.832]                     .init = FALSE)
[17:46:37.832]                 }
[17:46:37.832]             }
[17:46:37.832]         }
[17:46:37.832]     })
[17:46:37.832]     if (TRUE) {
[17:46:37.832]         base::sink(type = "output", split = FALSE)
[17:46:37.832]         if (TRUE) {
[17:46:37.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:37.832]         }
[17:46:37.832]         else {
[17:46:37.832]             ...future.result["stdout"] <- base::list(NULL)
[17:46:37.832]         }
[17:46:37.832]         base::close(...future.stdout)
[17:46:37.832]         ...future.stdout <- NULL
[17:46:37.832]     }
[17:46:37.832]     ...future.result$conditions <- ...future.conditions
[17:46:37.832]     ...future.result$finished <- base::Sys.time()
[17:46:37.832]     ...future.result
[17:46:37.832] }
[17:46:37.834] Poll #1 (0): usedNodes() = 2, workers = 2
[17:46:37.853] receiveMessageFromWorker() for ClusterFuture ...
[17:46:37.853] - Validating connection of MultisessionFuture
[17:46:37.853] - received message: FutureResult
[17:46:37.853] - Received FutureResult
[17:46:37.854] - Erased future from FutureRegistry
[17:46:37.854] result() for ClusterFuture ...
[17:46:37.854] - result already collected: FutureResult
[17:46:37.854] result() for ClusterFuture ... done
[17:46:37.854] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:37.854] result() for ClusterFuture ...
[17:46:37.854] - result already collected: FutureResult
[17:46:37.854] result() for ClusterFuture ... done
[17:46:37.854] result() for ClusterFuture ...
[17:46:37.854] - result already collected: FutureResult
[17:46:37.854] result() for ClusterFuture ... done
[17:46:37.855] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:46:37.855] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:46:37.856] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:46:37.856] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:46:37.856] MultisessionFuture started
[17:46:37.856] - Launch lazy future ... done
[17:46:37.857] run() for ‘MultisessionFuture’ ... done
[17:46:37.857] result() for ClusterFuture ...
[17:46:37.857] - result already collected: FutureResult
[17:46:37.857] result() for ClusterFuture ... done
[17:46:37.857] result() for ClusterFuture ...
[17:46:37.858] - result already collected: FutureResult
[17:46:37.858] result() for ClusterFuture ... done
[17:46:37.858] result() for ClusterFuture ...
[17:46:37.858] receiveMessageFromWorker() for ClusterFuture ...
[17:46:37.858] - Validating connection of MultisessionFuture
[17:46:37.859] - received message: FutureResult
[17:46:37.859] - Received FutureResult
[17:46:37.859] - Erased future from FutureRegistry
[17:46:37.859] result() for ClusterFuture ...
[17:46:37.859] - result already collected: FutureResult
[17:46:37.859] result() for ClusterFuture ... done
[17:46:37.859] signalConditions() ...
[17:46:37.860]  - include = ‘immediateCondition’
[17:46:37.860]  - exclude = 
[17:46:37.860]  - resignal = FALSE
[17:46:37.860]  - Number of conditions: 1
[17:46:37.860] signalConditions() ... done
[17:46:37.860] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:37.860] result() for ClusterFuture ... done
[17:46:37.860] result() for ClusterFuture ...
[17:46:37.860] - result already collected: FutureResult
[17:46:37.860] result() for ClusterFuture ... done
[17:46:37.860] signalConditions() ...
[17:46:37.860]  - include = ‘immediateCondition’
[17:46:37.861]  - exclude = 
[17:46:37.861]  - resignal = FALSE
[17:46:37.861]  - Number of conditions: 1
[17:46:37.861] signalConditions() ... done
[17:46:37.861] Future state: ‘finished’
[17:46:37.861] result() for ClusterFuture ...
[17:46:37.861] - result already collected: FutureResult
[17:46:37.861] result() for ClusterFuture ... done
[17:46:37.861] signalConditions() ...
[17:46:37.861]  - include = ‘condition’
[17:46:37.861]  - exclude = ‘immediateCondition’
[17:46:37.862]  - resignal = TRUE
[17:46:37.862]  - Number of conditions: 1
[17:46:37.862]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:37.862] signalConditions() ... done
[17:46:37.862] result() for ClusterFuture ...
[17:46:37.862] receiveMessageFromWorker() for ClusterFuture ...
[17:46:37.862] - Validating connection of MultisessionFuture
[17:46:37.862] - received message: FutureResult
[17:46:37.863] - Received FutureResult
[17:46:37.863] - Erased future from FutureRegistry
[17:46:37.863] result() for ClusterFuture ...
[17:46:37.863] - result already collected: FutureResult
[17:46:37.863] result() for ClusterFuture ... done
[17:46:37.863] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:37.863] result() for ClusterFuture ... done
[17:46:37.863] result() for ClusterFuture ...
[17:46:37.863] - result already collected: FutureResult
[17:46:37.863] result() for ClusterFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[17:46:37.864] result() for ClusterFuture ...
[17:46:37.864] - result already collected: FutureResult
[17:46:37.864] result() for ClusterFuture ... done
[17:46:37.864] result() for ClusterFuture ...
[17:46:37.864] - result already collected: FutureResult
[17:46:37.864] result() for ClusterFuture ... done
[17:46:37.864] signalConditions() ...
[17:46:37.864]  - include = ‘immediateCondition’
[17:46:37.864]  - exclude = 
[17:46:37.865]  - resignal = FALSE
[17:46:37.865]  - Number of conditions: 1
[17:46:37.865] signalConditions() ... done
[17:46:37.865] Future state: ‘finished’
[17:46:37.865] result() for ClusterFuture ...
[17:46:37.865] - result already collected: FutureResult
[17:46:37.865] result() for ClusterFuture ... done
[17:46:37.865] signalConditions() ...
[17:46:37.865]  - include = ‘condition’
[17:46:37.865]  - exclude = ‘immediateCondition’
[17:46:37.865]  - resignal = TRUE
[17:46:37.865]  - Number of conditions: 1
[17:46:37.866]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:37.866] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[17:46:37.866] result() for ClusterFuture ...
[17:46:37.866] - result already collected: FutureResult
[17:46:37.866] result() for ClusterFuture ... done
[17:46:37.866] result() for ClusterFuture ...
[17:46:37.866] - result already collected: FutureResult
[17:46:37.866] result() for ClusterFuture ... done
[17:46:37.866] signalConditions() ...
[17:46:37.867]  - include = ‘immediateCondition’
[17:46:37.867]  - exclude = 
[17:46:37.867]  - resignal = FALSE
[17:46:37.867]  - Number of conditions: 1
[17:46:37.867] signalConditions() ... done
[17:46:37.867] Future state: ‘finished’
[17:46:37.867] result() for ClusterFuture ...
[17:46:37.867] - result already collected: FutureResult
[17:46:37.867] result() for ClusterFuture ... done
[17:46:37.867] signalConditions() ...
[17:46:37.867]  - include = ‘condition’
[17:46:37.867]  - exclude = ‘immediateCondition’
[17:46:37.868]  - resignal = TRUE
[17:46:37.868]  - Number of conditions: 1
[17:46:37.868]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:37.868] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[17:46:37.868] getGlobalsAndPackages() ...
[17:46:37.868] Searching for globals...
[17:46:37.870] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[17:46:37.870] Searching for globals ... DONE
[17:46:37.870] Resolving globals: FALSE
[17:46:37.871] 
[17:46:37.871] 
[17:46:37.871] getGlobalsAndPackages() ... DONE
[17:46:37.871] run() for ‘Future’ ...
[17:46:37.871] - state: ‘created’
[17:46:37.871] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:37.885] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:37.885] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:37.885]   - Field: ‘node’
[17:46:37.886]   - Field: ‘label’
[17:46:37.886]   - Field: ‘local’
[17:46:37.886]   - Field: ‘owner’
[17:46:37.886]   - Field: ‘envir’
[17:46:37.886]   - Field: ‘workers’
[17:46:37.886]   - Field: ‘packages’
[17:46:37.886]   - Field: ‘gc’
[17:46:37.886]   - Field: ‘conditions’
[17:46:37.886]   - Field: ‘persistent’
[17:46:37.886]   - Field: ‘expr’
[17:46:37.886]   - Field: ‘uuid’
[17:46:37.887]   - Field: ‘seed’
[17:46:37.887]   - Field: ‘version’
[17:46:37.887]   - Field: ‘result’
[17:46:37.887]   - Field: ‘asynchronous’
[17:46:37.887]   - Field: ‘calls’
[17:46:37.887]   - Field: ‘globals’
[17:46:37.887]   - Field: ‘stdout’
[17:46:37.887]   - Field: ‘earlySignal’
[17:46:37.887]   - Field: ‘lazy’
[17:46:37.887]   - Field: ‘state’
[17:46:37.888] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:37.888] - Launch lazy future ...
[17:46:37.888] Packages needed by the future expression (n = 0): <none>
[17:46:37.888] Packages needed by future strategies (n = 0): <none>
[17:46:37.888] {
[17:46:37.888]     {
[17:46:37.888]         {
[17:46:37.888]             ...future.startTime <- base::Sys.time()
[17:46:37.888]             {
[17:46:37.888]                 {
[17:46:37.888]                   {
[17:46:37.888]                     {
[17:46:37.888]                       base::local({
[17:46:37.888]                         has_future <- base::requireNamespace("future", 
[17:46:37.888]                           quietly = TRUE)
[17:46:37.888]                         if (has_future) {
[17:46:37.888]                           ns <- base::getNamespace("future")
[17:46:37.888]                           version <- ns[[".package"]][["version"]]
[17:46:37.888]                           if (is.null(version)) 
[17:46:37.888]                             version <- utils::packageVersion("future")
[17:46:37.888]                         }
[17:46:37.888]                         else {
[17:46:37.888]                           version <- NULL
[17:46:37.888]                         }
[17:46:37.888]                         if (!has_future || version < "1.8.0") {
[17:46:37.888]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:37.888]                             "", base::R.version$version.string), 
[17:46:37.888]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:37.888]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:37.888]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:37.888]                               "release", "version")], collapse = " "), 
[17:46:37.888]                             hostname = base::Sys.info()[["nodename"]])
[17:46:37.888]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:37.888]                             info)
[17:46:37.888]                           info <- base::paste(info, collapse = "; ")
[17:46:37.888]                           if (!has_future) {
[17:46:37.888]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:37.888]                               info)
[17:46:37.888]                           }
[17:46:37.888]                           else {
[17:46:37.888]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:37.888]                               info, version)
[17:46:37.888]                           }
[17:46:37.888]                           base::stop(msg)
[17:46:37.888]                         }
[17:46:37.888]                       })
[17:46:37.888]                     }
[17:46:37.888]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:37.888]                     base::options(mc.cores = 1L)
[17:46:37.888]                   }
[17:46:37.888]                   ...future.strategy.old <- future::plan("list")
[17:46:37.888]                   options(future.plan = NULL)
[17:46:37.888]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.888]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:37.888]                 }
[17:46:37.888]                 ...future.workdir <- getwd()
[17:46:37.888]             }
[17:46:37.888]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:37.888]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:37.888]         }
[17:46:37.888]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:37.888]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:37.888]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:37.888]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:37.888]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:37.888]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:37.888]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:37.888]             base::names(...future.oldOptions))
[17:46:37.888]     }
[17:46:37.888]     if (FALSE) {
[17:46:37.888]     }
[17:46:37.888]     else {
[17:46:37.888]         if (TRUE) {
[17:46:37.888]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:37.888]                 open = "w")
[17:46:37.888]         }
[17:46:37.888]         else {
[17:46:37.888]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:37.888]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:37.888]         }
[17:46:37.888]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:37.888]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:37.888]             base::sink(type = "output", split = FALSE)
[17:46:37.888]             base::close(...future.stdout)
[17:46:37.888]         }, add = TRUE)
[17:46:37.888]     }
[17:46:37.888]     ...future.frame <- base::sys.nframe()
[17:46:37.888]     ...future.conditions <- base::list()
[17:46:37.888]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:37.888]     if (FALSE) {
[17:46:37.888]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:37.888]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:37.888]     }
[17:46:37.888]     ...future.result <- base::tryCatch({
[17:46:37.888]         base::withCallingHandlers({
[17:46:37.888]             ...future.value <- base::withVisible(base::local({
[17:46:37.888]                 ...future.makeSendCondition <- base::local({
[17:46:37.888]                   sendCondition <- NULL
[17:46:37.888]                   function(frame = 1L) {
[17:46:37.888]                     if (is.function(sendCondition)) 
[17:46:37.888]                       return(sendCondition)
[17:46:37.888]                     ns <- getNamespace("parallel")
[17:46:37.888]                     if (exists("sendData", mode = "function", 
[17:46:37.888]                       envir = ns)) {
[17:46:37.888]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:37.888]                         envir = ns)
[17:46:37.888]                       envir <- sys.frame(frame)
[17:46:37.888]                       master <- NULL
[17:46:37.888]                       while (!identical(envir, .GlobalEnv) && 
[17:46:37.888]                         !identical(envir, emptyenv())) {
[17:46:37.888]                         if (exists("master", mode = "list", envir = envir, 
[17:46:37.888]                           inherits = FALSE)) {
[17:46:37.888]                           master <- get("master", mode = "list", 
[17:46:37.888]                             envir = envir, inherits = FALSE)
[17:46:37.888]                           if (inherits(master, c("SOCKnode", 
[17:46:37.888]                             "SOCK0node"))) {
[17:46:37.888]                             sendCondition <<- function(cond) {
[17:46:37.888]                               data <- list(type = "VALUE", value = cond, 
[17:46:37.888]                                 success = TRUE)
[17:46:37.888]                               parallel_sendData(master, data)
[17:46:37.888]                             }
[17:46:37.888]                             return(sendCondition)
[17:46:37.888]                           }
[17:46:37.888]                         }
[17:46:37.888]                         frame <- frame + 1L
[17:46:37.888]                         envir <- sys.frame(frame)
[17:46:37.888]                       }
[17:46:37.888]                     }
[17:46:37.888]                     sendCondition <<- function(cond) NULL
[17:46:37.888]                   }
[17:46:37.888]                 })
[17:46:37.888]                 withCallingHandlers({
[17:46:37.888]                   {
[17:46:37.888]                     cat("Processing: ")
[17:46:37.888]                     for (ii in 1:10) {
[17:46:37.888]                       cat(".")
[17:46:37.888]                     }
[17:46:37.888]                     cat(" [100%]\n")
[17:46:37.888]                     4
[17:46:37.888]                   }
[17:46:37.888]                 }, immediateCondition = function(cond) {
[17:46:37.888]                   sendCondition <- ...future.makeSendCondition()
[17:46:37.888]                   sendCondition(cond)
[17:46:37.888]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.888]                   {
[17:46:37.888]                     inherits <- base::inherits
[17:46:37.888]                     invokeRestart <- base::invokeRestart
[17:46:37.888]                     is.null <- base::is.null
[17:46:37.888]                     muffled <- FALSE
[17:46:37.888]                     if (inherits(cond, "message")) {
[17:46:37.888]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:37.888]                       if (muffled) 
[17:46:37.888]                         invokeRestart("muffleMessage")
[17:46:37.888]                     }
[17:46:37.888]                     else if (inherits(cond, "warning")) {
[17:46:37.888]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:37.888]                       if (muffled) 
[17:46:37.888]                         invokeRestart("muffleWarning")
[17:46:37.888]                     }
[17:46:37.888]                     else if (inherits(cond, "condition")) {
[17:46:37.888]                       if (!is.null(pattern)) {
[17:46:37.888]                         computeRestarts <- base::computeRestarts
[17:46:37.888]                         grepl <- base::grepl
[17:46:37.888]                         restarts <- computeRestarts(cond)
[17:46:37.888]                         for (restart in restarts) {
[17:46:37.888]                           name <- restart$name
[17:46:37.888]                           if (is.null(name)) 
[17:46:37.888]                             next
[17:46:37.888]                           if (!grepl(pattern, name)) 
[17:46:37.888]                             next
[17:46:37.888]                           invokeRestart(restart)
[17:46:37.888]                           muffled <- TRUE
[17:46:37.888]                           break
[17:46:37.888]                         }
[17:46:37.888]                       }
[17:46:37.888]                     }
[17:46:37.888]                     invisible(muffled)
[17:46:37.888]                   }
[17:46:37.888]                   muffleCondition(cond)
[17:46:37.888]                 })
[17:46:37.888]             }))
[17:46:37.888]             future::FutureResult(value = ...future.value$value, 
[17:46:37.888]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.888]                   ...future.rng), globalenv = if (FALSE) 
[17:46:37.888]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:37.888]                     ...future.globalenv.names))
[17:46:37.888]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:37.888]         }, condition = base::local({
[17:46:37.888]             c <- base::c
[17:46:37.888]             inherits <- base::inherits
[17:46:37.888]             invokeRestart <- base::invokeRestart
[17:46:37.888]             length <- base::length
[17:46:37.888]             list <- base::list
[17:46:37.888]             seq.int <- base::seq.int
[17:46:37.888]             signalCondition <- base::signalCondition
[17:46:37.888]             sys.calls <- base::sys.calls
[17:46:37.888]             `[[` <- base::`[[`
[17:46:37.888]             `+` <- base::`+`
[17:46:37.888]             `<<-` <- base::`<<-`
[17:46:37.888]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:37.888]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:37.888]                   3L)]
[17:46:37.888]             }
[17:46:37.888]             function(cond) {
[17:46:37.888]                 is_error <- inherits(cond, "error")
[17:46:37.888]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:37.888]                   NULL)
[17:46:37.888]                 if (is_error) {
[17:46:37.888]                   sessionInformation <- function() {
[17:46:37.888]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:37.888]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:37.888]                       search = base::search(), system = base::Sys.info())
[17:46:37.888]                   }
[17:46:37.888]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.888]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:37.888]                     cond$call), session = sessionInformation(), 
[17:46:37.888]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:37.888]                   signalCondition(cond)
[17:46:37.888]                 }
[17:46:37.888]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:37.888]                 "immediateCondition"))) {
[17:46:37.888]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:37.888]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.888]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:37.888]                   if (TRUE && !signal) {
[17:46:37.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.888]                     {
[17:46:37.888]                       inherits <- base::inherits
[17:46:37.888]                       invokeRestart <- base::invokeRestart
[17:46:37.888]                       is.null <- base::is.null
[17:46:37.888]                       muffled <- FALSE
[17:46:37.888]                       if (inherits(cond, "message")) {
[17:46:37.888]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.888]                         if (muffled) 
[17:46:37.888]                           invokeRestart("muffleMessage")
[17:46:37.888]                       }
[17:46:37.888]                       else if (inherits(cond, "warning")) {
[17:46:37.888]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.888]                         if (muffled) 
[17:46:37.888]                           invokeRestart("muffleWarning")
[17:46:37.888]                       }
[17:46:37.888]                       else if (inherits(cond, "condition")) {
[17:46:37.888]                         if (!is.null(pattern)) {
[17:46:37.888]                           computeRestarts <- base::computeRestarts
[17:46:37.888]                           grepl <- base::grepl
[17:46:37.888]                           restarts <- computeRestarts(cond)
[17:46:37.888]                           for (restart in restarts) {
[17:46:37.888]                             name <- restart$name
[17:46:37.888]                             if (is.null(name)) 
[17:46:37.888]                               next
[17:46:37.888]                             if (!grepl(pattern, name)) 
[17:46:37.888]                               next
[17:46:37.888]                             invokeRestart(restart)
[17:46:37.888]                             muffled <- TRUE
[17:46:37.888]                             break
[17:46:37.888]                           }
[17:46:37.888]                         }
[17:46:37.888]                       }
[17:46:37.888]                       invisible(muffled)
[17:46:37.888]                     }
[17:46:37.888]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.888]                   }
[17:46:37.888]                 }
[17:46:37.888]                 else {
[17:46:37.888]                   if (TRUE) {
[17:46:37.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.888]                     {
[17:46:37.888]                       inherits <- base::inherits
[17:46:37.888]                       invokeRestart <- base::invokeRestart
[17:46:37.888]                       is.null <- base::is.null
[17:46:37.888]                       muffled <- FALSE
[17:46:37.888]                       if (inherits(cond, "message")) {
[17:46:37.888]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.888]                         if (muffled) 
[17:46:37.888]                           invokeRestart("muffleMessage")
[17:46:37.888]                       }
[17:46:37.888]                       else if (inherits(cond, "warning")) {
[17:46:37.888]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.888]                         if (muffled) 
[17:46:37.888]                           invokeRestart("muffleWarning")
[17:46:37.888]                       }
[17:46:37.888]                       else if (inherits(cond, "condition")) {
[17:46:37.888]                         if (!is.null(pattern)) {
[17:46:37.888]                           computeRestarts <- base::computeRestarts
[17:46:37.888]                           grepl <- base::grepl
[17:46:37.888]                           restarts <- computeRestarts(cond)
[17:46:37.888]                           for (restart in restarts) {
[17:46:37.888]                             name <- restart$name
[17:46:37.888]                             if (is.null(name)) 
[17:46:37.888]                               next
[17:46:37.888]                             if (!grepl(pattern, name)) 
[17:46:37.888]                               next
[17:46:37.888]                             invokeRestart(restart)
[17:46:37.888]                             muffled <- TRUE
[17:46:37.888]                             break
[17:46:37.888]                           }
[17:46:37.888]                         }
[17:46:37.888]                       }
[17:46:37.888]                       invisible(muffled)
[17:46:37.888]                     }
[17:46:37.888]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.888]                   }
[17:46:37.888]                 }
[17:46:37.888]             }
[17:46:37.888]         }))
[17:46:37.888]     }, error = function(ex) {
[17:46:37.888]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:37.888]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.888]                 ...future.rng), started = ...future.startTime, 
[17:46:37.888]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:37.888]             version = "1.8"), class = "FutureResult")
[17:46:37.888]     }, finally = {
[17:46:37.888]         if (!identical(...future.workdir, getwd())) 
[17:46:37.888]             setwd(...future.workdir)
[17:46:37.888]         {
[17:46:37.888]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:37.888]                 ...future.oldOptions$nwarnings <- NULL
[17:46:37.888]             }
[17:46:37.888]             base::options(...future.oldOptions)
[17:46:37.888]             if (.Platform$OS.type == "windows") {
[17:46:37.888]                 old_names <- names(...future.oldEnvVars)
[17:46:37.888]                 envs <- base::Sys.getenv()
[17:46:37.888]                 names <- names(envs)
[17:46:37.888]                 common <- intersect(names, old_names)
[17:46:37.888]                 added <- setdiff(names, old_names)
[17:46:37.888]                 removed <- setdiff(old_names, names)
[17:46:37.888]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:37.888]                   envs[common]]
[17:46:37.888]                 NAMES <- toupper(changed)
[17:46:37.888]                 args <- list()
[17:46:37.888]                 for (kk in seq_along(NAMES)) {
[17:46:37.888]                   name <- changed[[kk]]
[17:46:37.888]                   NAME <- NAMES[[kk]]
[17:46:37.888]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.888]                     next
[17:46:37.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.888]                 }
[17:46:37.888]                 NAMES <- toupper(added)
[17:46:37.888]                 for (kk in seq_along(NAMES)) {
[17:46:37.888]                   name <- added[[kk]]
[17:46:37.888]                   NAME <- NAMES[[kk]]
[17:46:37.888]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.888]                     next
[17:46:37.888]                   args[[name]] <- ""
[17:46:37.888]                 }
[17:46:37.888]                 NAMES <- toupper(removed)
[17:46:37.888]                 for (kk in seq_along(NAMES)) {
[17:46:37.888]                   name <- removed[[kk]]
[17:46:37.888]                   NAME <- NAMES[[kk]]
[17:46:37.888]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.888]                     next
[17:46:37.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.888]                 }
[17:46:37.888]                 if (length(args) > 0) 
[17:46:37.888]                   base::do.call(base::Sys.setenv, args = args)
[17:46:37.888]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:37.888]             }
[17:46:37.888]             else {
[17:46:37.888]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:37.888]             }
[17:46:37.888]             {
[17:46:37.888]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:37.888]                   0L) {
[17:46:37.888]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:37.888]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:37.888]                   base::options(opts)
[17:46:37.888]                 }
[17:46:37.888]                 {
[17:46:37.888]                   {
[17:46:37.888]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:37.888]                     NULL
[17:46:37.888]                   }
[17:46:37.888]                   options(future.plan = NULL)
[17:46:37.888]                   if (is.na(NA_character_)) 
[17:46:37.888]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.888]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:37.888]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:37.888]                     .init = FALSE)
[17:46:37.888]                 }
[17:46:37.888]             }
[17:46:37.888]         }
[17:46:37.888]     })
[17:46:37.888]     if (TRUE) {
[17:46:37.888]         base::sink(type = "output", split = FALSE)
[17:46:37.888]         if (TRUE) {
[17:46:37.888]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:37.888]         }
[17:46:37.888]         else {
[17:46:37.888]             ...future.result["stdout"] <- base::list(NULL)
[17:46:37.888]         }
[17:46:37.888]         base::close(...future.stdout)
[17:46:37.888]         ...future.stdout <- NULL
[17:46:37.888]     }
[17:46:37.888]     ...future.result$conditions <- ...future.conditions
[17:46:37.888]     ...future.result$finished <- base::Sys.time()
[17:46:37.888]     ...future.result
[17:46:37.888] }
[17:46:37.891] MultisessionFuture started
[17:46:37.891] - Launch lazy future ... done
[17:46:37.892] run() for ‘MultisessionFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[17:46:37.892] result() for ClusterFuture ...
[17:46:37.892] - result already collected: FutureResult
[17:46:37.892] result() for ClusterFuture ... done
[17:46:37.893] result() for ClusterFuture ...
[17:46:37.893] - result already collected: FutureResult
[17:46:37.893] result() for ClusterFuture ... done
[17:46:37.893] signalConditions() ...
[17:46:37.893]  - include = ‘immediateCondition’
[17:46:37.893]  - exclude = 
[17:46:37.893]  - resignal = FALSE
[17:46:37.894]  - Number of conditions: 1
[17:46:37.894] signalConditions() ... done
[17:46:37.894] Future state: ‘finished’
[17:46:37.894] result() for ClusterFuture ...
[17:46:37.894] - result already collected: FutureResult
[17:46:37.894] result() for ClusterFuture ... done
[17:46:37.894] signalConditions() ...
[17:46:37.894]  - include = ‘condition’
[17:46:37.894]  - exclude = ‘immediateCondition’
[17:46:37.894]  - resignal = TRUE
[17:46:37.895]  - Number of conditions: 1
[17:46:37.895]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:37.895] signalConditions() ... done
v3: <simpleError> (as expect)
[17:46:37.895] result() for ClusterFuture ...
[17:46:37.895] receiveMessageFromWorker() for ClusterFuture ...
[17:46:37.895] - Validating connection of MultisessionFuture
[17:46:37.895] - received message: FutureResult
[17:46:37.895] - Received FutureResult
[17:46:37.895] - Erased future from FutureRegistry
[17:46:37.896] result() for ClusterFuture ...
[17:46:37.896] - result already collected: FutureResult
[17:46:37.896] result() for ClusterFuture ... done
[17:46:37.896] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:37.896] result() for ClusterFuture ... done
[17:46:37.896] result() for ClusterFuture ...
[17:46:37.896] - result already collected: FutureResult
[17:46:37.896] result() for ClusterFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[17:46:37.897] getGlobalsAndPackages() ...
[17:46:37.897] Searching for globals...
[17:46:37.897] 
[17:46:37.897] Searching for globals ... DONE
[17:46:37.897] - globals: [0] <none>
[17:46:37.897] getGlobalsAndPackages() ... DONE
[17:46:37.897] run() for ‘Future’ ...
[17:46:37.897] - state: ‘created’
[17:46:37.898] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:37.911] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:37.911] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:37.911]   - Field: ‘node’
[17:46:37.911]   - Field: ‘label’
[17:46:37.911]   - Field: ‘local’
[17:46:37.911]   - Field: ‘owner’
[17:46:37.912]   - Field: ‘envir’
[17:46:37.912]   - Field: ‘workers’
[17:46:37.912]   - Field: ‘packages’
[17:46:37.912]   - Field: ‘gc’
[17:46:37.912]   - Field: ‘conditions’
[17:46:37.912]   - Field: ‘persistent’
[17:46:37.912]   - Field: ‘expr’
[17:46:37.912]   - Field: ‘uuid’
[17:46:37.912]   - Field: ‘seed’
[17:46:37.912]   - Field: ‘version’
[17:46:37.912]   - Field: ‘result’
[17:46:37.913]   - Field: ‘asynchronous’
[17:46:37.913]   - Field: ‘calls’
[17:46:37.913]   - Field: ‘globals’
[17:46:37.913]   - Field: ‘stdout’
[17:46:37.913]   - Field: ‘earlySignal’
[17:46:37.913]   - Field: ‘lazy’
[17:46:37.913]   - Field: ‘state’
[17:46:37.913] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:37.913] - Launch lazy future ...
[17:46:37.913] Packages needed by the future expression (n = 0): <none>
[17:46:37.914] Packages needed by future strategies (n = 0): <none>
[17:46:37.914] {
[17:46:37.914]     {
[17:46:37.914]         {
[17:46:37.914]             ...future.startTime <- base::Sys.time()
[17:46:37.914]             {
[17:46:37.914]                 {
[17:46:37.914]                   {
[17:46:37.914]                     {
[17:46:37.914]                       base::local({
[17:46:37.914]                         has_future <- base::requireNamespace("future", 
[17:46:37.914]                           quietly = TRUE)
[17:46:37.914]                         if (has_future) {
[17:46:37.914]                           ns <- base::getNamespace("future")
[17:46:37.914]                           version <- ns[[".package"]][["version"]]
[17:46:37.914]                           if (is.null(version)) 
[17:46:37.914]                             version <- utils::packageVersion("future")
[17:46:37.914]                         }
[17:46:37.914]                         else {
[17:46:37.914]                           version <- NULL
[17:46:37.914]                         }
[17:46:37.914]                         if (!has_future || version < "1.8.0") {
[17:46:37.914]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:37.914]                             "", base::R.version$version.string), 
[17:46:37.914]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:37.914]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:37.914]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:37.914]                               "release", "version")], collapse = " "), 
[17:46:37.914]                             hostname = base::Sys.info()[["nodename"]])
[17:46:37.914]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:37.914]                             info)
[17:46:37.914]                           info <- base::paste(info, collapse = "; ")
[17:46:37.914]                           if (!has_future) {
[17:46:37.914]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:37.914]                               info)
[17:46:37.914]                           }
[17:46:37.914]                           else {
[17:46:37.914]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:37.914]                               info, version)
[17:46:37.914]                           }
[17:46:37.914]                           base::stop(msg)
[17:46:37.914]                         }
[17:46:37.914]                       })
[17:46:37.914]                     }
[17:46:37.914]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:37.914]                     base::options(mc.cores = 1L)
[17:46:37.914]                   }
[17:46:37.914]                   ...future.strategy.old <- future::plan("list")
[17:46:37.914]                   options(future.plan = NULL)
[17:46:37.914]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.914]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:37.914]                 }
[17:46:37.914]                 ...future.workdir <- getwd()
[17:46:37.914]             }
[17:46:37.914]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:37.914]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:37.914]         }
[17:46:37.914]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:37.914]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:37.914]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:37.914]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:37.914]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:37.914]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:37.914]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:37.914]             base::names(...future.oldOptions))
[17:46:37.914]     }
[17:46:37.914]     if (FALSE) {
[17:46:37.914]     }
[17:46:37.914]     else {
[17:46:37.914]         if (TRUE) {
[17:46:37.914]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:37.914]                 open = "w")
[17:46:37.914]         }
[17:46:37.914]         else {
[17:46:37.914]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:37.914]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:37.914]         }
[17:46:37.914]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:37.914]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:37.914]             base::sink(type = "output", split = FALSE)
[17:46:37.914]             base::close(...future.stdout)
[17:46:37.914]         }, add = TRUE)
[17:46:37.914]     }
[17:46:37.914]     ...future.frame <- base::sys.nframe()
[17:46:37.914]     ...future.conditions <- base::list()
[17:46:37.914]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:37.914]     if (FALSE) {
[17:46:37.914]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:37.914]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:37.914]     }
[17:46:37.914]     ...future.result <- base::tryCatch({
[17:46:37.914]         base::withCallingHandlers({
[17:46:37.914]             ...future.value <- base::withVisible(base::local({
[17:46:37.914]                 ...future.makeSendCondition <- base::local({
[17:46:37.914]                   sendCondition <- NULL
[17:46:37.914]                   function(frame = 1L) {
[17:46:37.914]                     if (is.function(sendCondition)) 
[17:46:37.914]                       return(sendCondition)
[17:46:37.914]                     ns <- getNamespace("parallel")
[17:46:37.914]                     if (exists("sendData", mode = "function", 
[17:46:37.914]                       envir = ns)) {
[17:46:37.914]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:37.914]                         envir = ns)
[17:46:37.914]                       envir <- sys.frame(frame)
[17:46:37.914]                       master <- NULL
[17:46:37.914]                       while (!identical(envir, .GlobalEnv) && 
[17:46:37.914]                         !identical(envir, emptyenv())) {
[17:46:37.914]                         if (exists("master", mode = "list", envir = envir, 
[17:46:37.914]                           inherits = FALSE)) {
[17:46:37.914]                           master <- get("master", mode = "list", 
[17:46:37.914]                             envir = envir, inherits = FALSE)
[17:46:37.914]                           if (inherits(master, c("SOCKnode", 
[17:46:37.914]                             "SOCK0node"))) {
[17:46:37.914]                             sendCondition <<- function(cond) {
[17:46:37.914]                               data <- list(type = "VALUE", value = cond, 
[17:46:37.914]                                 success = TRUE)
[17:46:37.914]                               parallel_sendData(master, data)
[17:46:37.914]                             }
[17:46:37.914]                             return(sendCondition)
[17:46:37.914]                           }
[17:46:37.914]                         }
[17:46:37.914]                         frame <- frame + 1L
[17:46:37.914]                         envir <- sys.frame(frame)
[17:46:37.914]                       }
[17:46:37.914]                     }
[17:46:37.914]                     sendCondition <<- function(cond) NULL
[17:46:37.914]                   }
[17:46:37.914]                 })
[17:46:37.914]                 withCallingHandlers({
[17:46:37.914]                   1
[17:46:37.914]                 }, immediateCondition = function(cond) {
[17:46:37.914]                   sendCondition <- ...future.makeSendCondition()
[17:46:37.914]                   sendCondition(cond)
[17:46:37.914]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.914]                   {
[17:46:37.914]                     inherits <- base::inherits
[17:46:37.914]                     invokeRestart <- base::invokeRestart
[17:46:37.914]                     is.null <- base::is.null
[17:46:37.914]                     muffled <- FALSE
[17:46:37.914]                     if (inherits(cond, "message")) {
[17:46:37.914]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:37.914]                       if (muffled) 
[17:46:37.914]                         invokeRestart("muffleMessage")
[17:46:37.914]                     }
[17:46:37.914]                     else if (inherits(cond, "warning")) {
[17:46:37.914]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:37.914]                       if (muffled) 
[17:46:37.914]                         invokeRestart("muffleWarning")
[17:46:37.914]                     }
[17:46:37.914]                     else if (inherits(cond, "condition")) {
[17:46:37.914]                       if (!is.null(pattern)) {
[17:46:37.914]                         computeRestarts <- base::computeRestarts
[17:46:37.914]                         grepl <- base::grepl
[17:46:37.914]                         restarts <- computeRestarts(cond)
[17:46:37.914]                         for (restart in restarts) {
[17:46:37.914]                           name <- restart$name
[17:46:37.914]                           if (is.null(name)) 
[17:46:37.914]                             next
[17:46:37.914]                           if (!grepl(pattern, name)) 
[17:46:37.914]                             next
[17:46:37.914]                           invokeRestart(restart)
[17:46:37.914]                           muffled <- TRUE
[17:46:37.914]                           break
[17:46:37.914]                         }
[17:46:37.914]                       }
[17:46:37.914]                     }
[17:46:37.914]                     invisible(muffled)
[17:46:37.914]                   }
[17:46:37.914]                   muffleCondition(cond)
[17:46:37.914]                 })
[17:46:37.914]             }))
[17:46:37.914]             future::FutureResult(value = ...future.value$value, 
[17:46:37.914]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.914]                   ...future.rng), globalenv = if (FALSE) 
[17:46:37.914]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:37.914]                     ...future.globalenv.names))
[17:46:37.914]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:37.914]         }, condition = base::local({
[17:46:37.914]             c <- base::c
[17:46:37.914]             inherits <- base::inherits
[17:46:37.914]             invokeRestart <- base::invokeRestart
[17:46:37.914]             length <- base::length
[17:46:37.914]             list <- base::list
[17:46:37.914]             seq.int <- base::seq.int
[17:46:37.914]             signalCondition <- base::signalCondition
[17:46:37.914]             sys.calls <- base::sys.calls
[17:46:37.914]             `[[` <- base::`[[`
[17:46:37.914]             `+` <- base::`+`
[17:46:37.914]             `<<-` <- base::`<<-`
[17:46:37.914]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:37.914]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:37.914]                   3L)]
[17:46:37.914]             }
[17:46:37.914]             function(cond) {
[17:46:37.914]                 is_error <- inherits(cond, "error")
[17:46:37.914]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:37.914]                   NULL)
[17:46:37.914]                 if (is_error) {
[17:46:37.914]                   sessionInformation <- function() {
[17:46:37.914]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:37.914]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:37.914]                       search = base::search(), system = base::Sys.info())
[17:46:37.914]                   }
[17:46:37.914]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.914]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:37.914]                     cond$call), session = sessionInformation(), 
[17:46:37.914]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:37.914]                   signalCondition(cond)
[17:46:37.914]                 }
[17:46:37.914]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:37.914]                 "immediateCondition"))) {
[17:46:37.914]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:37.914]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.914]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:37.914]                   if (TRUE && !signal) {
[17:46:37.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.914]                     {
[17:46:37.914]                       inherits <- base::inherits
[17:46:37.914]                       invokeRestart <- base::invokeRestart
[17:46:37.914]                       is.null <- base::is.null
[17:46:37.914]                       muffled <- FALSE
[17:46:37.914]                       if (inherits(cond, "message")) {
[17:46:37.914]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.914]                         if (muffled) 
[17:46:37.914]                           invokeRestart("muffleMessage")
[17:46:37.914]                       }
[17:46:37.914]                       else if (inherits(cond, "warning")) {
[17:46:37.914]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.914]                         if (muffled) 
[17:46:37.914]                           invokeRestart("muffleWarning")
[17:46:37.914]                       }
[17:46:37.914]                       else if (inherits(cond, "condition")) {
[17:46:37.914]                         if (!is.null(pattern)) {
[17:46:37.914]                           computeRestarts <- base::computeRestarts
[17:46:37.914]                           grepl <- base::grepl
[17:46:37.914]                           restarts <- computeRestarts(cond)
[17:46:37.914]                           for (restart in restarts) {
[17:46:37.914]                             name <- restart$name
[17:46:37.914]                             if (is.null(name)) 
[17:46:37.914]                               next
[17:46:37.914]                             if (!grepl(pattern, name)) 
[17:46:37.914]                               next
[17:46:37.914]                             invokeRestart(restart)
[17:46:37.914]                             muffled <- TRUE
[17:46:37.914]                             break
[17:46:37.914]                           }
[17:46:37.914]                         }
[17:46:37.914]                       }
[17:46:37.914]                       invisible(muffled)
[17:46:37.914]                     }
[17:46:37.914]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.914]                   }
[17:46:37.914]                 }
[17:46:37.914]                 else {
[17:46:37.914]                   if (TRUE) {
[17:46:37.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.914]                     {
[17:46:37.914]                       inherits <- base::inherits
[17:46:37.914]                       invokeRestart <- base::invokeRestart
[17:46:37.914]                       is.null <- base::is.null
[17:46:37.914]                       muffled <- FALSE
[17:46:37.914]                       if (inherits(cond, "message")) {
[17:46:37.914]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.914]                         if (muffled) 
[17:46:37.914]                           invokeRestart("muffleMessage")
[17:46:37.914]                       }
[17:46:37.914]                       else if (inherits(cond, "warning")) {
[17:46:37.914]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.914]                         if (muffled) 
[17:46:37.914]                           invokeRestart("muffleWarning")
[17:46:37.914]                       }
[17:46:37.914]                       else if (inherits(cond, "condition")) {
[17:46:37.914]                         if (!is.null(pattern)) {
[17:46:37.914]                           computeRestarts <- base::computeRestarts
[17:46:37.914]                           grepl <- base::grepl
[17:46:37.914]                           restarts <- computeRestarts(cond)
[17:46:37.914]                           for (restart in restarts) {
[17:46:37.914]                             name <- restart$name
[17:46:37.914]                             if (is.null(name)) 
[17:46:37.914]                               next
[17:46:37.914]                             if (!grepl(pattern, name)) 
[17:46:37.914]                               next
[17:46:37.914]                             invokeRestart(restart)
[17:46:37.914]                             muffled <- TRUE
[17:46:37.914]                             break
[17:46:37.914]                           }
[17:46:37.914]                         }
[17:46:37.914]                       }
[17:46:37.914]                       invisible(muffled)
[17:46:37.914]                     }
[17:46:37.914]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.914]                   }
[17:46:37.914]                 }
[17:46:37.914]             }
[17:46:37.914]         }))
[17:46:37.914]     }, error = function(ex) {
[17:46:37.914]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:37.914]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.914]                 ...future.rng), started = ...future.startTime, 
[17:46:37.914]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:37.914]             version = "1.8"), class = "FutureResult")
[17:46:37.914]     }, finally = {
[17:46:37.914]         if (!identical(...future.workdir, getwd())) 
[17:46:37.914]             setwd(...future.workdir)
[17:46:37.914]         {
[17:46:37.914]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:37.914]                 ...future.oldOptions$nwarnings <- NULL
[17:46:37.914]             }
[17:46:37.914]             base::options(...future.oldOptions)
[17:46:37.914]             if (.Platform$OS.type == "windows") {
[17:46:37.914]                 old_names <- names(...future.oldEnvVars)
[17:46:37.914]                 envs <- base::Sys.getenv()
[17:46:37.914]                 names <- names(envs)
[17:46:37.914]                 common <- intersect(names, old_names)
[17:46:37.914]                 added <- setdiff(names, old_names)
[17:46:37.914]                 removed <- setdiff(old_names, names)
[17:46:37.914]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:37.914]                   envs[common]]
[17:46:37.914]                 NAMES <- toupper(changed)
[17:46:37.914]                 args <- list()
[17:46:37.914]                 for (kk in seq_along(NAMES)) {
[17:46:37.914]                   name <- changed[[kk]]
[17:46:37.914]                   NAME <- NAMES[[kk]]
[17:46:37.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.914]                     next
[17:46:37.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.914]                 }
[17:46:37.914]                 NAMES <- toupper(added)
[17:46:37.914]                 for (kk in seq_along(NAMES)) {
[17:46:37.914]                   name <- added[[kk]]
[17:46:37.914]                   NAME <- NAMES[[kk]]
[17:46:37.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.914]                     next
[17:46:37.914]                   args[[name]] <- ""
[17:46:37.914]                 }
[17:46:37.914]                 NAMES <- toupper(removed)
[17:46:37.914]                 for (kk in seq_along(NAMES)) {
[17:46:37.914]                   name <- removed[[kk]]
[17:46:37.914]                   NAME <- NAMES[[kk]]
[17:46:37.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.914]                     next
[17:46:37.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.914]                 }
[17:46:37.914]                 if (length(args) > 0) 
[17:46:37.914]                   base::do.call(base::Sys.setenv, args = args)
[17:46:37.914]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:37.914]             }
[17:46:37.914]             else {
[17:46:37.914]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:37.914]             }
[17:46:37.914]             {
[17:46:37.914]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:37.914]                   0L) {
[17:46:37.914]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:37.914]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:37.914]                   base::options(opts)
[17:46:37.914]                 }
[17:46:37.914]                 {
[17:46:37.914]                   {
[17:46:37.914]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:37.914]                     NULL
[17:46:37.914]                   }
[17:46:37.914]                   options(future.plan = NULL)
[17:46:37.914]                   if (is.na(NA_character_)) 
[17:46:37.914]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.914]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:37.914]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:37.914]                     .init = FALSE)
[17:46:37.914]                 }
[17:46:37.914]             }
[17:46:37.914]         }
[17:46:37.914]     })
[17:46:37.914]     if (TRUE) {
[17:46:37.914]         base::sink(type = "output", split = FALSE)
[17:46:37.914]         if (TRUE) {
[17:46:37.914]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:37.914]         }
[17:46:37.914]         else {
[17:46:37.914]             ...future.result["stdout"] <- base::list(NULL)
[17:46:37.914]         }
[17:46:37.914]         base::close(...future.stdout)
[17:46:37.914]         ...future.stdout <- NULL
[17:46:37.914]     }
[17:46:37.914]     ...future.result$conditions <- ...future.conditions
[17:46:37.914]     ...future.result$finished <- base::Sys.time()
[17:46:37.914]     ...future.result
[17:46:37.914] }
[17:46:37.917] MultisessionFuture started
[17:46:37.917] - Launch lazy future ... done
[17:46:37.917] run() for ‘MultisessionFuture’ ... done
[17:46:37.918] result() for ClusterFuture ...
[17:46:37.920] receiveMessageFromWorker() for ClusterFuture ...
[17:46:37.920] - Validating connection of MultisessionFuture
[17:46:37.920] - received message: FutureResult
[17:46:37.920] - Received FutureResult
[17:46:37.920] - Erased future from FutureRegistry
[17:46:37.921] result() for ClusterFuture ...
[17:46:37.921] - result already collected: FutureResult
[17:46:37.921] result() for ClusterFuture ... done
[17:46:37.921] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:37.921] result() for ClusterFuture ... done
[17:46:37.921] result() for ClusterFuture ...
[17:46:37.921] - result already collected: FutureResult
[17:46:37.921] result() for ClusterFuture ... done
c = 1
[17:46:37.921] getGlobalsAndPackages() ...
[17:46:37.922] Searching for globals...
[17:46:37.922] 
[17:46:37.922] Searching for globals ... DONE
[17:46:37.922] - globals: [0] <none>
[17:46:37.922] getGlobalsAndPackages() ... DONE
[17:46:37.922] run() for ‘Future’ ...
[17:46:37.922] - state: ‘created’
[17:46:37.922] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:37.936] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:37.936] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:37.936]   - Field: ‘node’
[17:46:37.936]   - Field: ‘label’
[17:46:37.936]   - Field: ‘local’
[17:46:37.937]   - Field: ‘owner’
[17:46:37.937]   - Field: ‘envir’
[17:46:37.937]   - Field: ‘workers’
[17:46:37.937]   - Field: ‘packages’
[17:46:37.937]   - Field: ‘gc’
[17:46:37.937]   - Field: ‘conditions’
[17:46:37.937]   - Field: ‘persistent’
[17:46:37.937]   - Field: ‘expr’
[17:46:37.937]   - Field: ‘uuid’
[17:46:37.937]   - Field: ‘seed’
[17:46:37.937]   - Field: ‘version’
[17:46:37.938]   - Field: ‘result’
[17:46:37.938]   - Field: ‘asynchronous’
[17:46:37.938]   - Field: ‘calls’
[17:46:37.938]   - Field: ‘globals’
[17:46:37.938]   - Field: ‘stdout’
[17:46:37.938]   - Field: ‘earlySignal’
[17:46:37.938]   - Field: ‘lazy’
[17:46:37.938]   - Field: ‘state’
[17:46:37.938] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:37.938] - Launch lazy future ...
[17:46:37.939] Packages needed by the future expression (n = 0): <none>
[17:46:37.939] Packages needed by future strategies (n = 0): <none>
[17:46:37.939] {
[17:46:37.939]     {
[17:46:37.939]         {
[17:46:37.939]             ...future.startTime <- base::Sys.time()
[17:46:37.939]             {
[17:46:37.939]                 {
[17:46:37.939]                   {
[17:46:37.939]                     {
[17:46:37.939]                       base::local({
[17:46:37.939]                         has_future <- base::requireNamespace("future", 
[17:46:37.939]                           quietly = TRUE)
[17:46:37.939]                         if (has_future) {
[17:46:37.939]                           ns <- base::getNamespace("future")
[17:46:37.939]                           version <- ns[[".package"]][["version"]]
[17:46:37.939]                           if (is.null(version)) 
[17:46:37.939]                             version <- utils::packageVersion("future")
[17:46:37.939]                         }
[17:46:37.939]                         else {
[17:46:37.939]                           version <- NULL
[17:46:37.939]                         }
[17:46:37.939]                         if (!has_future || version < "1.8.0") {
[17:46:37.939]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:37.939]                             "", base::R.version$version.string), 
[17:46:37.939]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:37.939]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:37.939]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:37.939]                               "release", "version")], collapse = " "), 
[17:46:37.939]                             hostname = base::Sys.info()[["nodename"]])
[17:46:37.939]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:37.939]                             info)
[17:46:37.939]                           info <- base::paste(info, collapse = "; ")
[17:46:37.939]                           if (!has_future) {
[17:46:37.939]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:37.939]                               info)
[17:46:37.939]                           }
[17:46:37.939]                           else {
[17:46:37.939]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:37.939]                               info, version)
[17:46:37.939]                           }
[17:46:37.939]                           base::stop(msg)
[17:46:37.939]                         }
[17:46:37.939]                       })
[17:46:37.939]                     }
[17:46:37.939]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:37.939]                     base::options(mc.cores = 1L)
[17:46:37.939]                   }
[17:46:37.939]                   ...future.strategy.old <- future::plan("list")
[17:46:37.939]                   options(future.plan = NULL)
[17:46:37.939]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.939]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:37.939]                 }
[17:46:37.939]                 ...future.workdir <- getwd()
[17:46:37.939]             }
[17:46:37.939]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:37.939]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:37.939]         }
[17:46:37.939]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:37.939]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:37.939]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:37.939]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:37.939]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:37.939]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:37.939]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:37.939]             base::names(...future.oldOptions))
[17:46:37.939]     }
[17:46:37.939]     if (FALSE) {
[17:46:37.939]     }
[17:46:37.939]     else {
[17:46:37.939]         if (TRUE) {
[17:46:37.939]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:37.939]                 open = "w")
[17:46:37.939]         }
[17:46:37.939]         else {
[17:46:37.939]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:37.939]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:37.939]         }
[17:46:37.939]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:37.939]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:37.939]             base::sink(type = "output", split = FALSE)
[17:46:37.939]             base::close(...future.stdout)
[17:46:37.939]         }, add = TRUE)
[17:46:37.939]     }
[17:46:37.939]     ...future.frame <- base::sys.nframe()
[17:46:37.939]     ...future.conditions <- base::list()
[17:46:37.939]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:37.939]     if (FALSE) {
[17:46:37.939]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:37.939]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:37.939]     }
[17:46:37.939]     ...future.result <- base::tryCatch({
[17:46:37.939]         base::withCallingHandlers({
[17:46:37.939]             ...future.value <- base::withVisible(base::local({
[17:46:37.939]                 ...future.makeSendCondition <- base::local({
[17:46:37.939]                   sendCondition <- NULL
[17:46:37.939]                   function(frame = 1L) {
[17:46:37.939]                     if (is.function(sendCondition)) 
[17:46:37.939]                       return(sendCondition)
[17:46:37.939]                     ns <- getNamespace("parallel")
[17:46:37.939]                     if (exists("sendData", mode = "function", 
[17:46:37.939]                       envir = ns)) {
[17:46:37.939]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:37.939]                         envir = ns)
[17:46:37.939]                       envir <- sys.frame(frame)
[17:46:37.939]                       master <- NULL
[17:46:37.939]                       while (!identical(envir, .GlobalEnv) && 
[17:46:37.939]                         !identical(envir, emptyenv())) {
[17:46:37.939]                         if (exists("master", mode = "list", envir = envir, 
[17:46:37.939]                           inherits = FALSE)) {
[17:46:37.939]                           master <- get("master", mode = "list", 
[17:46:37.939]                             envir = envir, inherits = FALSE)
[17:46:37.939]                           if (inherits(master, c("SOCKnode", 
[17:46:37.939]                             "SOCK0node"))) {
[17:46:37.939]                             sendCondition <<- function(cond) {
[17:46:37.939]                               data <- list(type = "VALUE", value = cond, 
[17:46:37.939]                                 success = TRUE)
[17:46:37.939]                               parallel_sendData(master, data)
[17:46:37.939]                             }
[17:46:37.939]                             return(sendCondition)
[17:46:37.939]                           }
[17:46:37.939]                         }
[17:46:37.939]                         frame <- frame + 1L
[17:46:37.939]                         envir <- sys.frame(frame)
[17:46:37.939]                       }
[17:46:37.939]                     }
[17:46:37.939]                     sendCondition <<- function(cond) NULL
[17:46:37.939]                   }
[17:46:37.939]                 })
[17:46:37.939]                 withCallingHandlers({
[17:46:37.939]                   1
[17:46:37.939]                 }, immediateCondition = function(cond) {
[17:46:37.939]                   sendCondition <- ...future.makeSendCondition()
[17:46:37.939]                   sendCondition(cond)
[17:46:37.939]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.939]                   {
[17:46:37.939]                     inherits <- base::inherits
[17:46:37.939]                     invokeRestart <- base::invokeRestart
[17:46:37.939]                     is.null <- base::is.null
[17:46:37.939]                     muffled <- FALSE
[17:46:37.939]                     if (inherits(cond, "message")) {
[17:46:37.939]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:37.939]                       if (muffled) 
[17:46:37.939]                         invokeRestart("muffleMessage")
[17:46:37.939]                     }
[17:46:37.939]                     else if (inherits(cond, "warning")) {
[17:46:37.939]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:37.939]                       if (muffled) 
[17:46:37.939]                         invokeRestart("muffleWarning")
[17:46:37.939]                     }
[17:46:37.939]                     else if (inherits(cond, "condition")) {
[17:46:37.939]                       if (!is.null(pattern)) {
[17:46:37.939]                         computeRestarts <- base::computeRestarts
[17:46:37.939]                         grepl <- base::grepl
[17:46:37.939]                         restarts <- computeRestarts(cond)
[17:46:37.939]                         for (restart in restarts) {
[17:46:37.939]                           name <- restart$name
[17:46:37.939]                           if (is.null(name)) 
[17:46:37.939]                             next
[17:46:37.939]                           if (!grepl(pattern, name)) 
[17:46:37.939]                             next
[17:46:37.939]                           invokeRestart(restart)
[17:46:37.939]                           muffled <- TRUE
[17:46:37.939]                           break
[17:46:37.939]                         }
[17:46:37.939]                       }
[17:46:37.939]                     }
[17:46:37.939]                     invisible(muffled)
[17:46:37.939]                   }
[17:46:37.939]                   muffleCondition(cond)
[17:46:37.939]                 })
[17:46:37.939]             }))
[17:46:37.939]             future::FutureResult(value = ...future.value$value, 
[17:46:37.939]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.939]                   ...future.rng), globalenv = if (FALSE) 
[17:46:37.939]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:37.939]                     ...future.globalenv.names))
[17:46:37.939]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:37.939]         }, condition = base::local({
[17:46:37.939]             c <- base::c
[17:46:37.939]             inherits <- base::inherits
[17:46:37.939]             invokeRestart <- base::invokeRestart
[17:46:37.939]             length <- base::length
[17:46:37.939]             list <- base::list
[17:46:37.939]             seq.int <- base::seq.int
[17:46:37.939]             signalCondition <- base::signalCondition
[17:46:37.939]             sys.calls <- base::sys.calls
[17:46:37.939]             `[[` <- base::`[[`
[17:46:37.939]             `+` <- base::`+`
[17:46:37.939]             `<<-` <- base::`<<-`
[17:46:37.939]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:37.939]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:37.939]                   3L)]
[17:46:37.939]             }
[17:46:37.939]             function(cond) {
[17:46:37.939]                 is_error <- inherits(cond, "error")
[17:46:37.939]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:37.939]                   NULL)
[17:46:37.939]                 if (is_error) {
[17:46:37.939]                   sessionInformation <- function() {
[17:46:37.939]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:37.939]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:37.939]                       search = base::search(), system = base::Sys.info())
[17:46:37.939]                   }
[17:46:37.939]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.939]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:37.939]                     cond$call), session = sessionInformation(), 
[17:46:37.939]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:37.939]                   signalCondition(cond)
[17:46:37.939]                 }
[17:46:37.939]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:37.939]                 "immediateCondition"))) {
[17:46:37.939]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:37.939]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.939]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:37.939]                   if (TRUE && !signal) {
[17:46:37.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.939]                     {
[17:46:37.939]                       inherits <- base::inherits
[17:46:37.939]                       invokeRestart <- base::invokeRestart
[17:46:37.939]                       is.null <- base::is.null
[17:46:37.939]                       muffled <- FALSE
[17:46:37.939]                       if (inherits(cond, "message")) {
[17:46:37.939]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.939]                         if (muffled) 
[17:46:37.939]                           invokeRestart("muffleMessage")
[17:46:37.939]                       }
[17:46:37.939]                       else if (inherits(cond, "warning")) {
[17:46:37.939]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.939]                         if (muffled) 
[17:46:37.939]                           invokeRestart("muffleWarning")
[17:46:37.939]                       }
[17:46:37.939]                       else if (inherits(cond, "condition")) {
[17:46:37.939]                         if (!is.null(pattern)) {
[17:46:37.939]                           computeRestarts <- base::computeRestarts
[17:46:37.939]                           grepl <- base::grepl
[17:46:37.939]                           restarts <- computeRestarts(cond)
[17:46:37.939]                           for (restart in restarts) {
[17:46:37.939]                             name <- restart$name
[17:46:37.939]                             if (is.null(name)) 
[17:46:37.939]                               next
[17:46:37.939]                             if (!grepl(pattern, name)) 
[17:46:37.939]                               next
[17:46:37.939]                             invokeRestart(restart)
[17:46:37.939]                             muffled <- TRUE
[17:46:37.939]                             break
[17:46:37.939]                           }
[17:46:37.939]                         }
[17:46:37.939]                       }
[17:46:37.939]                       invisible(muffled)
[17:46:37.939]                     }
[17:46:37.939]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.939]                   }
[17:46:37.939]                 }
[17:46:37.939]                 else {
[17:46:37.939]                   if (TRUE) {
[17:46:37.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.939]                     {
[17:46:37.939]                       inherits <- base::inherits
[17:46:37.939]                       invokeRestart <- base::invokeRestart
[17:46:37.939]                       is.null <- base::is.null
[17:46:37.939]                       muffled <- FALSE
[17:46:37.939]                       if (inherits(cond, "message")) {
[17:46:37.939]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.939]                         if (muffled) 
[17:46:37.939]                           invokeRestart("muffleMessage")
[17:46:37.939]                       }
[17:46:37.939]                       else if (inherits(cond, "warning")) {
[17:46:37.939]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.939]                         if (muffled) 
[17:46:37.939]                           invokeRestart("muffleWarning")
[17:46:37.939]                       }
[17:46:37.939]                       else if (inherits(cond, "condition")) {
[17:46:37.939]                         if (!is.null(pattern)) {
[17:46:37.939]                           computeRestarts <- base::computeRestarts
[17:46:37.939]                           grepl <- base::grepl
[17:46:37.939]                           restarts <- computeRestarts(cond)
[17:46:37.939]                           for (restart in restarts) {
[17:46:37.939]                             name <- restart$name
[17:46:37.939]                             if (is.null(name)) 
[17:46:37.939]                               next
[17:46:37.939]                             if (!grepl(pattern, name)) 
[17:46:37.939]                               next
[17:46:37.939]                             invokeRestart(restart)
[17:46:37.939]                             muffled <- TRUE
[17:46:37.939]                             break
[17:46:37.939]                           }
[17:46:37.939]                         }
[17:46:37.939]                       }
[17:46:37.939]                       invisible(muffled)
[17:46:37.939]                     }
[17:46:37.939]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.939]                   }
[17:46:37.939]                 }
[17:46:37.939]             }
[17:46:37.939]         }))
[17:46:37.939]     }, error = function(ex) {
[17:46:37.939]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:37.939]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.939]                 ...future.rng), started = ...future.startTime, 
[17:46:37.939]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:37.939]             version = "1.8"), class = "FutureResult")
[17:46:37.939]     }, finally = {
[17:46:37.939]         if (!identical(...future.workdir, getwd())) 
[17:46:37.939]             setwd(...future.workdir)
[17:46:37.939]         {
[17:46:37.939]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:37.939]                 ...future.oldOptions$nwarnings <- NULL
[17:46:37.939]             }
[17:46:37.939]             base::options(...future.oldOptions)
[17:46:37.939]             if (.Platform$OS.type == "windows") {
[17:46:37.939]                 old_names <- names(...future.oldEnvVars)
[17:46:37.939]                 envs <- base::Sys.getenv()
[17:46:37.939]                 names <- names(envs)
[17:46:37.939]                 common <- intersect(names, old_names)
[17:46:37.939]                 added <- setdiff(names, old_names)
[17:46:37.939]                 removed <- setdiff(old_names, names)
[17:46:37.939]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:37.939]                   envs[common]]
[17:46:37.939]                 NAMES <- toupper(changed)
[17:46:37.939]                 args <- list()
[17:46:37.939]                 for (kk in seq_along(NAMES)) {
[17:46:37.939]                   name <- changed[[kk]]
[17:46:37.939]                   NAME <- NAMES[[kk]]
[17:46:37.939]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.939]                     next
[17:46:37.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.939]                 }
[17:46:37.939]                 NAMES <- toupper(added)
[17:46:37.939]                 for (kk in seq_along(NAMES)) {
[17:46:37.939]                   name <- added[[kk]]
[17:46:37.939]                   NAME <- NAMES[[kk]]
[17:46:37.939]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.939]                     next
[17:46:37.939]                   args[[name]] <- ""
[17:46:37.939]                 }
[17:46:37.939]                 NAMES <- toupper(removed)
[17:46:37.939]                 for (kk in seq_along(NAMES)) {
[17:46:37.939]                   name <- removed[[kk]]
[17:46:37.939]                   NAME <- NAMES[[kk]]
[17:46:37.939]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.939]                     next
[17:46:37.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.939]                 }
[17:46:37.939]                 if (length(args) > 0) 
[17:46:37.939]                   base::do.call(base::Sys.setenv, args = args)
[17:46:37.939]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:37.939]             }
[17:46:37.939]             else {
[17:46:37.939]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:37.939]             }
[17:46:37.939]             {
[17:46:37.939]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:37.939]                   0L) {
[17:46:37.939]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:37.939]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:37.939]                   base::options(opts)
[17:46:37.939]                 }
[17:46:37.939]                 {
[17:46:37.939]                   {
[17:46:37.939]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:37.939]                     NULL
[17:46:37.939]                   }
[17:46:37.939]                   options(future.plan = NULL)
[17:46:37.939]                   if (is.na(NA_character_)) 
[17:46:37.939]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.939]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:37.939]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:37.939]                     .init = FALSE)
[17:46:37.939]                 }
[17:46:37.939]             }
[17:46:37.939]         }
[17:46:37.939]     })
[17:46:37.939]     if (TRUE) {
[17:46:37.939]         base::sink(type = "output", split = FALSE)
[17:46:37.939]         if (TRUE) {
[17:46:37.939]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:37.939]         }
[17:46:37.939]         else {
[17:46:37.939]             ...future.result["stdout"] <- base::list(NULL)
[17:46:37.939]         }
[17:46:37.939]         base::close(...future.stdout)
[17:46:37.939]         ...future.stdout <- NULL
[17:46:37.939]     }
[17:46:37.939]     ...future.result$conditions <- ...future.conditions
[17:46:37.939]     ...future.result$finished <- base::Sys.time()
[17:46:37.939]     ...future.result
[17:46:37.939] }
[17:46:37.942] MultisessionFuture started
[17:46:37.942] - Launch lazy future ... done
[17:46:37.942] run() for ‘MultisessionFuture’ ... done
[17:46:37.942] result() for ClusterFuture ...
[17:46:37.943] receiveMessageFromWorker() for ClusterFuture ...
[17:46:37.943] - Validating connection of MultisessionFuture
[17:46:37.944] - received message: FutureResult
[17:46:37.944] - Received FutureResult
[17:46:37.944] - Erased future from FutureRegistry
[17:46:37.944] result() for ClusterFuture ...
[17:46:37.944] - result already collected: FutureResult
[17:46:37.944] result() for ClusterFuture ... done
[17:46:37.944] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:37.944] result() for ClusterFuture ... done
[17:46:37.944] result() for ClusterFuture ...
[17:46:37.945] - result already collected: FutureResult
[17:46:37.945] result() for ClusterFuture ... done
d = 1
** Nested future assignments
[17:46:37.945] getGlobalsAndPackages() ...
[17:46:37.945] Searching for globals...
[17:46:37.948] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[17:46:37.949] Searching for globals ... DONE
[17:46:37.949] Resolving globals: FALSE
[17:46:37.949] 
[17:46:37.949] - packages: [1] ‘future’
[17:46:37.949] getGlobalsAndPackages() ... DONE
[17:46:37.949] run() for ‘Future’ ...
[17:46:37.950] - state: ‘created’
[17:46:37.950] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:37.963] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:37.964] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:37.964]   - Field: ‘node’
[17:46:37.964]   - Field: ‘label’
[17:46:37.964]   - Field: ‘local’
[17:46:37.964]   - Field: ‘owner’
[17:46:37.964]   - Field: ‘envir’
[17:46:37.964]   - Field: ‘workers’
[17:46:37.964]   - Field: ‘packages’
[17:46:37.964]   - Field: ‘gc’
[17:46:37.964]   - Field: ‘conditions’
[17:46:37.964]   - Field: ‘persistent’
[17:46:37.965]   - Field: ‘expr’
[17:46:37.965]   - Field: ‘uuid’
[17:46:37.965]   - Field: ‘seed’
[17:46:37.965]   - Field: ‘version’
[17:46:37.965]   - Field: ‘result’
[17:46:37.965]   - Field: ‘asynchronous’
[17:46:37.965]   - Field: ‘calls’
[17:46:37.965]   - Field: ‘globals’
[17:46:37.965]   - Field: ‘stdout’
[17:46:37.965]   - Field: ‘earlySignal’
[17:46:37.965]   - Field: ‘lazy’
[17:46:37.965]   - Field: ‘state’
[17:46:37.966] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:37.966] - Launch lazy future ...
[17:46:37.966] Packages needed by the future expression (n = 1): ‘future’
[17:46:37.966] Packages needed by future strategies (n = 0): <none>
[17:46:37.967] {
[17:46:37.967]     {
[17:46:37.967]         {
[17:46:37.967]             ...future.startTime <- base::Sys.time()
[17:46:37.967]             {
[17:46:37.967]                 {
[17:46:37.967]                   {
[17:46:37.967]                     {
[17:46:37.967]                       {
[17:46:37.967]                         base::local({
[17:46:37.967]                           has_future <- base::requireNamespace("future", 
[17:46:37.967]                             quietly = TRUE)
[17:46:37.967]                           if (has_future) {
[17:46:37.967]                             ns <- base::getNamespace("future")
[17:46:37.967]                             version <- ns[[".package"]][["version"]]
[17:46:37.967]                             if (is.null(version)) 
[17:46:37.967]                               version <- utils::packageVersion("future")
[17:46:37.967]                           }
[17:46:37.967]                           else {
[17:46:37.967]                             version <- NULL
[17:46:37.967]                           }
[17:46:37.967]                           if (!has_future || version < "1.8.0") {
[17:46:37.967]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:37.967]                               "", base::R.version$version.string), 
[17:46:37.967]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:37.967]                                 base::R.version$platform, 8 * 
[17:46:37.967]                                   base::.Machine$sizeof.pointer), 
[17:46:37.967]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:37.967]                                 "release", "version")], collapse = " "), 
[17:46:37.967]                               hostname = base::Sys.info()[["nodename"]])
[17:46:37.967]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:37.967]                               info)
[17:46:37.967]                             info <- base::paste(info, collapse = "; ")
[17:46:37.967]                             if (!has_future) {
[17:46:37.967]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:37.967]                                 info)
[17:46:37.967]                             }
[17:46:37.967]                             else {
[17:46:37.967]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:37.967]                                 info, version)
[17:46:37.967]                             }
[17:46:37.967]                             base::stop(msg)
[17:46:37.967]                           }
[17:46:37.967]                         })
[17:46:37.967]                       }
[17:46:37.967]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:37.967]                       base::options(mc.cores = 1L)
[17:46:37.967]                     }
[17:46:37.967]                     base::local({
[17:46:37.967]                       for (pkg in "future") {
[17:46:37.967]                         base::loadNamespace(pkg)
[17:46:37.967]                         base::library(pkg, character.only = TRUE)
[17:46:37.967]                       }
[17:46:37.967]                     })
[17:46:37.967]                   }
[17:46:37.967]                   ...future.strategy.old <- future::plan("list")
[17:46:37.967]                   options(future.plan = NULL)
[17:46:37.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:37.967]                 }
[17:46:37.967]                 ...future.workdir <- getwd()
[17:46:37.967]             }
[17:46:37.967]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:37.967]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:37.967]         }
[17:46:37.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:37.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:37.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:37.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:37.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:37.967]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:37.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:37.967]             base::names(...future.oldOptions))
[17:46:37.967]     }
[17:46:37.967]     if (FALSE) {
[17:46:37.967]     }
[17:46:37.967]     else {
[17:46:37.967]         if (TRUE) {
[17:46:37.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:37.967]                 open = "w")
[17:46:37.967]         }
[17:46:37.967]         else {
[17:46:37.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:37.967]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:37.967]         }
[17:46:37.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:37.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:37.967]             base::sink(type = "output", split = FALSE)
[17:46:37.967]             base::close(...future.stdout)
[17:46:37.967]         }, add = TRUE)
[17:46:37.967]     }
[17:46:37.967]     ...future.frame <- base::sys.nframe()
[17:46:37.967]     ...future.conditions <- base::list()
[17:46:37.967]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:37.967]     if (FALSE) {
[17:46:37.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:37.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:37.967]     }
[17:46:37.967]     ...future.result <- base::tryCatch({
[17:46:37.967]         base::withCallingHandlers({
[17:46:37.967]             ...future.value <- base::withVisible(base::local({
[17:46:37.967]                 ...future.makeSendCondition <- base::local({
[17:46:37.967]                   sendCondition <- NULL
[17:46:37.967]                   function(frame = 1L) {
[17:46:37.967]                     if (is.function(sendCondition)) 
[17:46:37.967]                       return(sendCondition)
[17:46:37.967]                     ns <- getNamespace("parallel")
[17:46:37.967]                     if (exists("sendData", mode = "function", 
[17:46:37.967]                       envir = ns)) {
[17:46:37.967]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:37.967]                         envir = ns)
[17:46:37.967]                       envir <- sys.frame(frame)
[17:46:37.967]                       master <- NULL
[17:46:37.967]                       while (!identical(envir, .GlobalEnv) && 
[17:46:37.967]                         !identical(envir, emptyenv())) {
[17:46:37.967]                         if (exists("master", mode = "list", envir = envir, 
[17:46:37.967]                           inherits = FALSE)) {
[17:46:37.967]                           master <- get("master", mode = "list", 
[17:46:37.967]                             envir = envir, inherits = FALSE)
[17:46:37.967]                           if (inherits(master, c("SOCKnode", 
[17:46:37.967]                             "SOCK0node"))) {
[17:46:37.967]                             sendCondition <<- function(cond) {
[17:46:37.967]                               data <- list(type = "VALUE", value = cond, 
[17:46:37.967]                                 success = TRUE)
[17:46:37.967]                               parallel_sendData(master, data)
[17:46:37.967]                             }
[17:46:37.967]                             return(sendCondition)
[17:46:37.967]                           }
[17:46:37.967]                         }
[17:46:37.967]                         frame <- frame + 1L
[17:46:37.967]                         envir <- sys.frame(frame)
[17:46:37.967]                       }
[17:46:37.967]                     }
[17:46:37.967]                     sendCondition <<- function(cond) NULL
[17:46:37.967]                   }
[17:46:37.967]                 })
[17:46:37.967]                 withCallingHandlers({
[17:46:37.967]                   {
[17:46:37.967]                     b <- 1
[17:46:37.967]                     c %<-% 2
[17:46:37.967]                     d <- 3
[17:46:37.967]                     4 %->% e
[17:46:37.967]                     b + c + d + e
[17:46:37.967]                   }
[17:46:37.967]                 }, immediateCondition = function(cond) {
[17:46:37.967]                   sendCondition <- ...future.makeSendCondition()
[17:46:37.967]                   sendCondition(cond)
[17:46:37.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.967]                   {
[17:46:37.967]                     inherits <- base::inherits
[17:46:37.967]                     invokeRestart <- base::invokeRestart
[17:46:37.967]                     is.null <- base::is.null
[17:46:37.967]                     muffled <- FALSE
[17:46:37.967]                     if (inherits(cond, "message")) {
[17:46:37.967]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:37.967]                       if (muffled) 
[17:46:37.967]                         invokeRestart("muffleMessage")
[17:46:37.967]                     }
[17:46:37.967]                     else if (inherits(cond, "warning")) {
[17:46:37.967]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:37.967]                       if (muffled) 
[17:46:37.967]                         invokeRestart("muffleWarning")
[17:46:37.967]                     }
[17:46:37.967]                     else if (inherits(cond, "condition")) {
[17:46:37.967]                       if (!is.null(pattern)) {
[17:46:37.967]                         computeRestarts <- base::computeRestarts
[17:46:37.967]                         grepl <- base::grepl
[17:46:37.967]                         restarts <- computeRestarts(cond)
[17:46:37.967]                         for (restart in restarts) {
[17:46:37.967]                           name <- restart$name
[17:46:37.967]                           if (is.null(name)) 
[17:46:37.967]                             next
[17:46:37.967]                           if (!grepl(pattern, name)) 
[17:46:37.967]                             next
[17:46:37.967]                           invokeRestart(restart)
[17:46:37.967]                           muffled <- TRUE
[17:46:37.967]                           break
[17:46:37.967]                         }
[17:46:37.967]                       }
[17:46:37.967]                     }
[17:46:37.967]                     invisible(muffled)
[17:46:37.967]                   }
[17:46:37.967]                   muffleCondition(cond)
[17:46:37.967]                 })
[17:46:37.967]             }))
[17:46:37.967]             future::FutureResult(value = ...future.value$value, 
[17:46:37.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.967]                   ...future.rng), globalenv = if (FALSE) 
[17:46:37.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:37.967]                     ...future.globalenv.names))
[17:46:37.967]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:37.967]         }, condition = base::local({
[17:46:37.967]             c <- base::c
[17:46:37.967]             inherits <- base::inherits
[17:46:37.967]             invokeRestart <- base::invokeRestart
[17:46:37.967]             length <- base::length
[17:46:37.967]             list <- base::list
[17:46:37.967]             seq.int <- base::seq.int
[17:46:37.967]             signalCondition <- base::signalCondition
[17:46:37.967]             sys.calls <- base::sys.calls
[17:46:37.967]             `[[` <- base::`[[`
[17:46:37.967]             `+` <- base::`+`
[17:46:37.967]             `<<-` <- base::`<<-`
[17:46:37.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:37.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:37.967]                   3L)]
[17:46:37.967]             }
[17:46:37.967]             function(cond) {
[17:46:37.967]                 is_error <- inherits(cond, "error")
[17:46:37.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:37.967]                   NULL)
[17:46:37.967]                 if (is_error) {
[17:46:37.967]                   sessionInformation <- function() {
[17:46:37.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:37.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:37.967]                       search = base::search(), system = base::Sys.info())
[17:46:37.967]                   }
[17:46:37.967]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:37.967]                     cond$call), session = sessionInformation(), 
[17:46:37.967]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:37.967]                   signalCondition(cond)
[17:46:37.967]                 }
[17:46:37.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:37.967]                 "immediateCondition"))) {
[17:46:37.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:37.967]                   ...future.conditions[[length(...future.conditions) + 
[17:46:37.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:37.967]                   if (TRUE && !signal) {
[17:46:37.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.967]                     {
[17:46:37.967]                       inherits <- base::inherits
[17:46:37.967]                       invokeRestart <- base::invokeRestart
[17:46:37.967]                       is.null <- base::is.null
[17:46:37.967]                       muffled <- FALSE
[17:46:37.967]                       if (inherits(cond, "message")) {
[17:46:37.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.967]                         if (muffled) 
[17:46:37.967]                           invokeRestart("muffleMessage")
[17:46:37.967]                       }
[17:46:37.967]                       else if (inherits(cond, "warning")) {
[17:46:37.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.967]                         if (muffled) 
[17:46:37.967]                           invokeRestart("muffleWarning")
[17:46:37.967]                       }
[17:46:37.967]                       else if (inherits(cond, "condition")) {
[17:46:37.967]                         if (!is.null(pattern)) {
[17:46:37.967]                           computeRestarts <- base::computeRestarts
[17:46:37.967]                           grepl <- base::grepl
[17:46:37.967]                           restarts <- computeRestarts(cond)
[17:46:37.967]                           for (restart in restarts) {
[17:46:37.967]                             name <- restart$name
[17:46:37.967]                             if (is.null(name)) 
[17:46:37.967]                               next
[17:46:37.967]                             if (!grepl(pattern, name)) 
[17:46:37.967]                               next
[17:46:37.967]                             invokeRestart(restart)
[17:46:37.967]                             muffled <- TRUE
[17:46:37.967]                             break
[17:46:37.967]                           }
[17:46:37.967]                         }
[17:46:37.967]                       }
[17:46:37.967]                       invisible(muffled)
[17:46:37.967]                     }
[17:46:37.967]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.967]                   }
[17:46:37.967]                 }
[17:46:37.967]                 else {
[17:46:37.967]                   if (TRUE) {
[17:46:37.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:37.967]                     {
[17:46:37.967]                       inherits <- base::inherits
[17:46:37.967]                       invokeRestart <- base::invokeRestart
[17:46:37.967]                       is.null <- base::is.null
[17:46:37.967]                       muffled <- FALSE
[17:46:37.967]                       if (inherits(cond, "message")) {
[17:46:37.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:37.967]                         if (muffled) 
[17:46:37.967]                           invokeRestart("muffleMessage")
[17:46:37.967]                       }
[17:46:37.967]                       else if (inherits(cond, "warning")) {
[17:46:37.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:37.967]                         if (muffled) 
[17:46:37.967]                           invokeRestart("muffleWarning")
[17:46:37.967]                       }
[17:46:37.967]                       else if (inherits(cond, "condition")) {
[17:46:37.967]                         if (!is.null(pattern)) {
[17:46:37.967]                           computeRestarts <- base::computeRestarts
[17:46:37.967]                           grepl <- base::grepl
[17:46:37.967]                           restarts <- computeRestarts(cond)
[17:46:37.967]                           for (restart in restarts) {
[17:46:37.967]                             name <- restart$name
[17:46:37.967]                             if (is.null(name)) 
[17:46:37.967]                               next
[17:46:37.967]                             if (!grepl(pattern, name)) 
[17:46:37.967]                               next
[17:46:37.967]                             invokeRestart(restart)
[17:46:37.967]                             muffled <- TRUE
[17:46:37.967]                             break
[17:46:37.967]                           }
[17:46:37.967]                         }
[17:46:37.967]                       }
[17:46:37.967]                       invisible(muffled)
[17:46:37.967]                     }
[17:46:37.967]                     muffleCondition(cond, pattern = "^muffle")
[17:46:37.967]                   }
[17:46:37.967]                 }
[17:46:37.967]             }
[17:46:37.967]         }))
[17:46:37.967]     }, error = function(ex) {
[17:46:37.967]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:37.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:37.967]                 ...future.rng), started = ...future.startTime, 
[17:46:37.967]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:37.967]             version = "1.8"), class = "FutureResult")
[17:46:37.967]     }, finally = {
[17:46:37.967]         if (!identical(...future.workdir, getwd())) 
[17:46:37.967]             setwd(...future.workdir)
[17:46:37.967]         {
[17:46:37.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:37.967]                 ...future.oldOptions$nwarnings <- NULL
[17:46:37.967]             }
[17:46:37.967]             base::options(...future.oldOptions)
[17:46:37.967]             if (.Platform$OS.type == "windows") {
[17:46:37.967]                 old_names <- names(...future.oldEnvVars)
[17:46:37.967]                 envs <- base::Sys.getenv()
[17:46:37.967]                 names <- names(envs)
[17:46:37.967]                 common <- intersect(names, old_names)
[17:46:37.967]                 added <- setdiff(names, old_names)
[17:46:37.967]                 removed <- setdiff(old_names, names)
[17:46:37.967]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:37.967]                   envs[common]]
[17:46:37.967]                 NAMES <- toupper(changed)
[17:46:37.967]                 args <- list()
[17:46:37.967]                 for (kk in seq_along(NAMES)) {
[17:46:37.967]                   name <- changed[[kk]]
[17:46:37.967]                   NAME <- NAMES[[kk]]
[17:46:37.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.967]                     next
[17:46:37.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.967]                 }
[17:46:37.967]                 NAMES <- toupper(added)
[17:46:37.967]                 for (kk in seq_along(NAMES)) {
[17:46:37.967]                   name <- added[[kk]]
[17:46:37.967]                   NAME <- NAMES[[kk]]
[17:46:37.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.967]                     next
[17:46:37.967]                   args[[name]] <- ""
[17:46:37.967]                 }
[17:46:37.967]                 NAMES <- toupper(removed)
[17:46:37.967]                 for (kk in seq_along(NAMES)) {
[17:46:37.967]                   name <- removed[[kk]]
[17:46:37.967]                   NAME <- NAMES[[kk]]
[17:46:37.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:37.967]                     next
[17:46:37.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:37.967]                 }
[17:46:37.967]                 if (length(args) > 0) 
[17:46:37.967]                   base::do.call(base::Sys.setenv, args = args)
[17:46:37.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:37.967]             }
[17:46:37.967]             else {
[17:46:37.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:37.967]             }
[17:46:37.967]             {
[17:46:37.967]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:37.967]                   0L) {
[17:46:37.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:37.967]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:37.967]                   base::options(opts)
[17:46:37.967]                 }
[17:46:37.967]                 {
[17:46:37.967]                   {
[17:46:37.967]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:37.967]                     NULL
[17:46:37.967]                   }
[17:46:37.967]                   options(future.plan = NULL)
[17:46:37.967]                   if (is.na(NA_character_)) 
[17:46:37.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:37.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:37.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:37.967]                     .init = FALSE)
[17:46:37.967]                 }
[17:46:37.967]             }
[17:46:37.967]         }
[17:46:37.967]     })
[17:46:37.967]     if (TRUE) {
[17:46:37.967]         base::sink(type = "output", split = FALSE)
[17:46:37.967]         if (TRUE) {
[17:46:37.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:37.967]         }
[17:46:37.967]         else {
[17:46:37.967]             ...future.result["stdout"] <- base::list(NULL)
[17:46:37.967]         }
[17:46:37.967]         base::close(...future.stdout)
[17:46:37.967]         ...future.stdout <- NULL
[17:46:37.967]     }
[17:46:37.967]     ...future.result$conditions <- ...future.conditions
[17:46:37.967]     ...future.result$finished <- base::Sys.time()
[17:46:37.967]     ...future.result
[17:46:37.967] }
[17:46:37.969] MultisessionFuture started
[17:46:37.970] - Launch lazy future ... done
[17:46:37.970] run() for ‘MultisessionFuture’ ... done
[17:46:37.970] result() for ClusterFuture ...
[17:46:37.970] receiveMessageFromWorker() for ClusterFuture ...
[17:46:37.970] - Validating connection of MultisessionFuture
[17:46:38.026] - received message: FutureResult
[17:46:38.026] - Received FutureResult
[17:46:38.026] - Erased future from FutureRegistry
[17:46:38.026] result() for ClusterFuture ...
[17:46:38.026] - result already collected: FutureResult
[17:46:38.027] result() for ClusterFuture ... done
[17:46:38.027] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:38.027] result() for ClusterFuture ... done
[17:46:38.027] result() for ClusterFuture ...
[17:46:38.027] - result already collected: FutureResult
[17:46:38.027] result() for ClusterFuture ... done
a = 10
[17:46:38.027] getGlobalsAndPackages() ...
[17:46:38.028] Searching for globals...
[17:46:38.028] - globals found: [3] ‘{’, ‘+’, ‘a’
[17:46:38.029] Searching for globals ... DONE
[17:46:38.029] Resolving globals: FALSE
[17:46:38.029] The total size of the 1 globals is 56 bytes (56 bytes)
[17:46:38.029] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:46:38.030] - globals: [1] ‘a’
[17:46:38.030] 
[17:46:38.030] getGlobalsAndPackages() ... DONE
[17:46:38.030] run() for ‘Future’ ...
[17:46:38.030] - state: ‘created’
[17:46:38.030] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:38.044] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:38.045] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:38.045]   - Field: ‘node’
[17:46:38.045]   - Field: ‘label’
[17:46:38.045]   - Field: ‘local’
[17:46:38.045]   - Field: ‘owner’
[17:46:38.045]   - Field: ‘envir’
[17:46:38.045]   - Field: ‘workers’
[17:46:38.045]   - Field: ‘packages’
[17:46:38.045]   - Field: ‘gc’
[17:46:38.045]   - Field: ‘conditions’
[17:46:38.046]   - Field: ‘persistent’
[17:46:38.046]   - Field: ‘expr’
[17:46:38.046]   - Field: ‘uuid’
[17:46:38.046]   - Field: ‘seed’
[17:46:38.046]   - Field: ‘version’
[17:46:38.046]   - Field: ‘result’
[17:46:38.046]   - Field: ‘asynchronous’
[17:46:38.046]   - Field: ‘calls’
[17:46:38.046]   - Field: ‘globals’
[17:46:38.046]   - Field: ‘stdout’
[17:46:38.046]   - Field: ‘earlySignal’
[17:46:38.047]   - Field: ‘lazy’
[17:46:38.047]   - Field: ‘state’
[17:46:38.047] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:38.047] - Launch lazy future ...
[17:46:38.047] Packages needed by the future expression (n = 0): <none>
[17:46:38.047] Packages needed by future strategies (n = 0): <none>
[17:46:38.048] {
[17:46:38.048]     {
[17:46:38.048]         {
[17:46:38.048]             ...future.startTime <- base::Sys.time()
[17:46:38.048]             {
[17:46:38.048]                 {
[17:46:38.048]                   {
[17:46:38.048]                     {
[17:46:38.048]                       base::local({
[17:46:38.048]                         has_future <- base::requireNamespace("future", 
[17:46:38.048]                           quietly = TRUE)
[17:46:38.048]                         if (has_future) {
[17:46:38.048]                           ns <- base::getNamespace("future")
[17:46:38.048]                           version <- ns[[".package"]][["version"]]
[17:46:38.048]                           if (is.null(version)) 
[17:46:38.048]                             version <- utils::packageVersion("future")
[17:46:38.048]                         }
[17:46:38.048]                         else {
[17:46:38.048]                           version <- NULL
[17:46:38.048]                         }
[17:46:38.048]                         if (!has_future || version < "1.8.0") {
[17:46:38.048]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:38.048]                             "", base::R.version$version.string), 
[17:46:38.048]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:38.048]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:38.048]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:38.048]                               "release", "version")], collapse = " "), 
[17:46:38.048]                             hostname = base::Sys.info()[["nodename"]])
[17:46:38.048]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:38.048]                             info)
[17:46:38.048]                           info <- base::paste(info, collapse = "; ")
[17:46:38.048]                           if (!has_future) {
[17:46:38.048]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:38.048]                               info)
[17:46:38.048]                           }
[17:46:38.048]                           else {
[17:46:38.048]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:38.048]                               info, version)
[17:46:38.048]                           }
[17:46:38.048]                           base::stop(msg)
[17:46:38.048]                         }
[17:46:38.048]                       })
[17:46:38.048]                     }
[17:46:38.048]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:38.048]                     base::options(mc.cores = 1L)
[17:46:38.048]                   }
[17:46:38.048]                   ...future.strategy.old <- future::plan("list")
[17:46:38.048]                   options(future.plan = NULL)
[17:46:38.048]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:38.048]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:38.048]                 }
[17:46:38.048]                 ...future.workdir <- getwd()
[17:46:38.048]             }
[17:46:38.048]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:38.048]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:38.048]         }
[17:46:38.048]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:38.048]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:38.048]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:38.048]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:38.048]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:38.048]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:38.048]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:38.048]             base::names(...future.oldOptions))
[17:46:38.048]     }
[17:46:38.048]     if (FALSE) {
[17:46:38.048]     }
[17:46:38.048]     else {
[17:46:38.048]         if (TRUE) {
[17:46:38.048]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:38.048]                 open = "w")
[17:46:38.048]         }
[17:46:38.048]         else {
[17:46:38.048]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:38.048]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:38.048]         }
[17:46:38.048]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:38.048]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:38.048]             base::sink(type = "output", split = FALSE)
[17:46:38.048]             base::close(...future.stdout)
[17:46:38.048]         }, add = TRUE)
[17:46:38.048]     }
[17:46:38.048]     ...future.frame <- base::sys.nframe()
[17:46:38.048]     ...future.conditions <- base::list()
[17:46:38.048]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:38.048]     if (FALSE) {
[17:46:38.048]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:38.048]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:38.048]     }
[17:46:38.048]     ...future.result <- base::tryCatch({
[17:46:38.048]         base::withCallingHandlers({
[17:46:38.048]             ...future.value <- base::withVisible(base::local({
[17:46:38.048]                 ...future.makeSendCondition <- base::local({
[17:46:38.048]                   sendCondition <- NULL
[17:46:38.048]                   function(frame = 1L) {
[17:46:38.048]                     if (is.function(sendCondition)) 
[17:46:38.048]                       return(sendCondition)
[17:46:38.048]                     ns <- getNamespace("parallel")
[17:46:38.048]                     if (exists("sendData", mode = "function", 
[17:46:38.048]                       envir = ns)) {
[17:46:38.048]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:38.048]                         envir = ns)
[17:46:38.048]                       envir <- sys.frame(frame)
[17:46:38.048]                       master <- NULL
[17:46:38.048]                       while (!identical(envir, .GlobalEnv) && 
[17:46:38.048]                         !identical(envir, emptyenv())) {
[17:46:38.048]                         if (exists("master", mode = "list", envir = envir, 
[17:46:38.048]                           inherits = FALSE)) {
[17:46:38.048]                           master <- get("master", mode = "list", 
[17:46:38.048]                             envir = envir, inherits = FALSE)
[17:46:38.048]                           if (inherits(master, c("SOCKnode", 
[17:46:38.048]                             "SOCK0node"))) {
[17:46:38.048]                             sendCondition <<- function(cond) {
[17:46:38.048]                               data <- list(type = "VALUE", value = cond, 
[17:46:38.048]                                 success = TRUE)
[17:46:38.048]                               parallel_sendData(master, data)
[17:46:38.048]                             }
[17:46:38.048]                             return(sendCondition)
[17:46:38.048]                           }
[17:46:38.048]                         }
[17:46:38.048]                         frame <- frame + 1L
[17:46:38.048]                         envir <- sys.frame(frame)
[17:46:38.048]                       }
[17:46:38.048]                     }
[17:46:38.048]                     sendCondition <<- function(cond) NULL
[17:46:38.048]                   }
[17:46:38.048]                 })
[17:46:38.048]                 withCallingHandlers({
[17:46:38.048]                   {
[17:46:38.048]                     a + 1
[17:46:38.048]                   }
[17:46:38.048]                 }, immediateCondition = function(cond) {
[17:46:38.048]                   sendCondition <- ...future.makeSendCondition()
[17:46:38.048]                   sendCondition(cond)
[17:46:38.048]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:38.048]                   {
[17:46:38.048]                     inherits <- base::inherits
[17:46:38.048]                     invokeRestart <- base::invokeRestart
[17:46:38.048]                     is.null <- base::is.null
[17:46:38.048]                     muffled <- FALSE
[17:46:38.048]                     if (inherits(cond, "message")) {
[17:46:38.048]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:38.048]                       if (muffled) 
[17:46:38.048]                         invokeRestart("muffleMessage")
[17:46:38.048]                     }
[17:46:38.048]                     else if (inherits(cond, "warning")) {
[17:46:38.048]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:38.048]                       if (muffled) 
[17:46:38.048]                         invokeRestart("muffleWarning")
[17:46:38.048]                     }
[17:46:38.048]                     else if (inherits(cond, "condition")) {
[17:46:38.048]                       if (!is.null(pattern)) {
[17:46:38.048]                         computeRestarts <- base::computeRestarts
[17:46:38.048]                         grepl <- base::grepl
[17:46:38.048]                         restarts <- computeRestarts(cond)
[17:46:38.048]                         for (restart in restarts) {
[17:46:38.048]                           name <- restart$name
[17:46:38.048]                           if (is.null(name)) 
[17:46:38.048]                             next
[17:46:38.048]                           if (!grepl(pattern, name)) 
[17:46:38.048]                             next
[17:46:38.048]                           invokeRestart(restart)
[17:46:38.048]                           muffled <- TRUE
[17:46:38.048]                           break
[17:46:38.048]                         }
[17:46:38.048]                       }
[17:46:38.048]                     }
[17:46:38.048]                     invisible(muffled)
[17:46:38.048]                   }
[17:46:38.048]                   muffleCondition(cond)
[17:46:38.048]                 })
[17:46:38.048]             }))
[17:46:38.048]             future::FutureResult(value = ...future.value$value, 
[17:46:38.048]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:38.048]                   ...future.rng), globalenv = if (FALSE) 
[17:46:38.048]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:38.048]                     ...future.globalenv.names))
[17:46:38.048]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:38.048]         }, condition = base::local({
[17:46:38.048]             c <- base::c
[17:46:38.048]             inherits <- base::inherits
[17:46:38.048]             invokeRestart <- base::invokeRestart
[17:46:38.048]             length <- base::length
[17:46:38.048]             list <- base::list
[17:46:38.048]             seq.int <- base::seq.int
[17:46:38.048]             signalCondition <- base::signalCondition
[17:46:38.048]             sys.calls <- base::sys.calls
[17:46:38.048]             `[[` <- base::`[[`
[17:46:38.048]             `+` <- base::`+`
[17:46:38.048]             `<<-` <- base::`<<-`
[17:46:38.048]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:38.048]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:38.048]                   3L)]
[17:46:38.048]             }
[17:46:38.048]             function(cond) {
[17:46:38.048]                 is_error <- inherits(cond, "error")
[17:46:38.048]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:38.048]                   NULL)
[17:46:38.048]                 if (is_error) {
[17:46:38.048]                   sessionInformation <- function() {
[17:46:38.048]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:38.048]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:38.048]                       search = base::search(), system = base::Sys.info())
[17:46:38.048]                   }
[17:46:38.048]                   ...future.conditions[[length(...future.conditions) + 
[17:46:38.048]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:38.048]                     cond$call), session = sessionInformation(), 
[17:46:38.048]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:38.048]                   signalCondition(cond)
[17:46:38.048]                 }
[17:46:38.048]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:38.048]                 "immediateCondition"))) {
[17:46:38.048]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:38.048]                   ...future.conditions[[length(...future.conditions) + 
[17:46:38.048]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:38.048]                   if (TRUE && !signal) {
[17:46:38.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:38.048]                     {
[17:46:38.048]                       inherits <- base::inherits
[17:46:38.048]                       invokeRestart <- base::invokeRestart
[17:46:38.048]                       is.null <- base::is.null
[17:46:38.048]                       muffled <- FALSE
[17:46:38.048]                       if (inherits(cond, "message")) {
[17:46:38.048]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:38.048]                         if (muffled) 
[17:46:38.048]                           invokeRestart("muffleMessage")
[17:46:38.048]                       }
[17:46:38.048]                       else if (inherits(cond, "warning")) {
[17:46:38.048]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:38.048]                         if (muffled) 
[17:46:38.048]                           invokeRestart("muffleWarning")
[17:46:38.048]                       }
[17:46:38.048]                       else if (inherits(cond, "condition")) {
[17:46:38.048]                         if (!is.null(pattern)) {
[17:46:38.048]                           computeRestarts <- base::computeRestarts
[17:46:38.048]                           grepl <- base::grepl
[17:46:38.048]                           restarts <- computeRestarts(cond)
[17:46:38.048]                           for (restart in restarts) {
[17:46:38.048]                             name <- restart$name
[17:46:38.048]                             if (is.null(name)) 
[17:46:38.048]                               next
[17:46:38.048]                             if (!grepl(pattern, name)) 
[17:46:38.048]                               next
[17:46:38.048]                             invokeRestart(restart)
[17:46:38.048]                             muffled <- TRUE
[17:46:38.048]                             break
[17:46:38.048]                           }
[17:46:38.048]                         }
[17:46:38.048]                       }
[17:46:38.048]                       invisible(muffled)
[17:46:38.048]                     }
[17:46:38.048]                     muffleCondition(cond, pattern = "^muffle")
[17:46:38.048]                   }
[17:46:38.048]                 }
[17:46:38.048]                 else {
[17:46:38.048]                   if (TRUE) {
[17:46:38.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:38.048]                     {
[17:46:38.048]                       inherits <- base::inherits
[17:46:38.048]                       invokeRestart <- base::invokeRestart
[17:46:38.048]                       is.null <- base::is.null
[17:46:38.048]                       muffled <- FALSE
[17:46:38.048]                       if (inherits(cond, "message")) {
[17:46:38.048]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:38.048]                         if (muffled) 
[17:46:38.048]                           invokeRestart("muffleMessage")
[17:46:38.048]                       }
[17:46:38.048]                       else if (inherits(cond, "warning")) {
[17:46:38.048]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:38.048]                         if (muffled) 
[17:46:38.048]                           invokeRestart("muffleWarning")
[17:46:38.048]                       }
[17:46:38.048]                       else if (inherits(cond, "condition")) {
[17:46:38.048]                         if (!is.null(pattern)) {
[17:46:38.048]                           computeRestarts <- base::computeRestarts
[17:46:38.048]                           grepl <- base::grepl
[17:46:38.048]                           restarts <- computeRestarts(cond)
[17:46:38.048]                           for (restart in restarts) {
[17:46:38.048]                             name <- restart$name
[17:46:38.048]                             if (is.null(name)) 
[17:46:38.048]                               next
[17:46:38.048]                             if (!grepl(pattern, name)) 
[17:46:38.048]                               next
[17:46:38.048]                             invokeRestart(restart)
[17:46:38.048]                             muffled <- TRUE
[17:46:38.048]                             break
[17:46:38.048]                           }
[17:46:38.048]                         }
[17:46:38.048]                       }
[17:46:38.048]                       invisible(muffled)
[17:46:38.048]                     }
[17:46:38.048]                     muffleCondition(cond, pattern = "^muffle")
[17:46:38.048]                   }
[17:46:38.048]                 }
[17:46:38.048]             }
[17:46:38.048]         }))
[17:46:38.048]     }, error = function(ex) {
[17:46:38.048]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:38.048]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:38.048]                 ...future.rng), started = ...future.startTime, 
[17:46:38.048]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:38.048]             version = "1.8"), class = "FutureResult")
[17:46:38.048]     }, finally = {
[17:46:38.048]         if (!identical(...future.workdir, getwd())) 
[17:46:38.048]             setwd(...future.workdir)
[17:46:38.048]         {
[17:46:38.048]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:38.048]                 ...future.oldOptions$nwarnings <- NULL
[17:46:38.048]             }
[17:46:38.048]             base::options(...future.oldOptions)
[17:46:38.048]             if (.Platform$OS.type == "windows") {
[17:46:38.048]                 old_names <- names(...future.oldEnvVars)
[17:46:38.048]                 envs <- base::Sys.getenv()
[17:46:38.048]                 names <- names(envs)
[17:46:38.048]                 common <- intersect(names, old_names)
[17:46:38.048]                 added <- setdiff(names, old_names)
[17:46:38.048]                 removed <- setdiff(old_names, names)
[17:46:38.048]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:38.048]                   envs[common]]
[17:46:38.048]                 NAMES <- toupper(changed)
[17:46:38.048]                 args <- list()
[17:46:38.048]                 for (kk in seq_along(NAMES)) {
[17:46:38.048]                   name <- changed[[kk]]
[17:46:38.048]                   NAME <- NAMES[[kk]]
[17:46:38.048]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:38.048]                     next
[17:46:38.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:38.048]                 }
[17:46:38.048]                 NAMES <- toupper(added)
[17:46:38.048]                 for (kk in seq_along(NAMES)) {
[17:46:38.048]                   name <- added[[kk]]
[17:46:38.048]                   NAME <- NAMES[[kk]]
[17:46:38.048]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:38.048]                     next
[17:46:38.048]                   args[[name]] <- ""
[17:46:38.048]                 }
[17:46:38.048]                 NAMES <- toupper(removed)
[17:46:38.048]                 for (kk in seq_along(NAMES)) {
[17:46:38.048]                   name <- removed[[kk]]
[17:46:38.048]                   NAME <- NAMES[[kk]]
[17:46:38.048]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:38.048]                     next
[17:46:38.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:38.048]                 }
[17:46:38.048]                 if (length(args) > 0) 
[17:46:38.048]                   base::do.call(base::Sys.setenv, args = args)
[17:46:38.048]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:38.048]             }
[17:46:38.048]             else {
[17:46:38.048]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:38.048]             }
[17:46:38.048]             {
[17:46:38.048]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:38.048]                   0L) {
[17:46:38.048]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:38.048]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:38.048]                   base::options(opts)
[17:46:38.048]                 }
[17:46:38.048]                 {
[17:46:38.048]                   {
[17:46:38.048]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:38.048]                     NULL
[17:46:38.048]                   }
[17:46:38.048]                   options(future.plan = NULL)
[17:46:38.048]                   if (is.na(NA_character_)) 
[17:46:38.048]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:38.048]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:38.048]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:38.048]                     .init = FALSE)
[17:46:38.048]                 }
[17:46:38.048]             }
[17:46:38.048]         }
[17:46:38.048]     })
[17:46:38.048]     if (TRUE) {
[17:46:38.048]         base::sink(type = "output", split = FALSE)
[17:46:38.048]         if (TRUE) {
[17:46:38.048]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:38.048]         }
[17:46:38.048]         else {
[17:46:38.048]             ...future.result["stdout"] <- base::list(NULL)
[17:46:38.048]         }
[17:46:38.048]         base::close(...future.stdout)
[17:46:38.048]         ...future.stdout <- NULL
[17:46:38.048]     }
[17:46:38.048]     ...future.result$conditions <- ...future.conditions
[17:46:38.048]     ...future.result$finished <- base::Sys.time()
[17:46:38.048]     ...future.result
[17:46:38.048] }
[17:46:38.050] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:46:38.050] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:46:38.051] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:46:38.051] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:46:38.051] MultisessionFuture started
[17:46:38.052] - Launch lazy future ... done
[17:46:38.052] run() for ‘MultisessionFuture’ ... done
[17:46:38.052] result() for ClusterFuture ...
[17:46:38.052] receiveMessageFromWorker() for ClusterFuture ...
[17:46:38.052] - Validating connection of MultisessionFuture
[17:46:38.053] - received message: FutureResult
[17:46:38.053] - Received FutureResult
[17:46:38.053] - Erased future from FutureRegistry
[17:46:38.054] result() for ClusterFuture ...
[17:46:38.054] - result already collected: FutureResult
[17:46:38.054] result() for ClusterFuture ... done
[17:46:38.054] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:38.054] result() for ClusterFuture ... done
[17:46:38.054] result() for ClusterFuture ...
[17:46:38.054] - result already collected: FutureResult
[17:46:38.054] result() for ClusterFuture ... done
b = 11
*** %<-% with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** %<-% ... DONE")
*** %<-% ... DONE
> 
> source("incl/end.R")
[17:46:38.055] plan(): Setting new future strategy stack:
[17:46:38.055] List of future strategies:
[17:46:38.055] 1. FutureStrategy:
[17:46:38.055]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:38.055]    - tweaked: FALSE
[17:46:38.055]    - call: future::plan(oplan)
[17:46:38.056] plan(): nbrOfWorkers() = 1
> 
