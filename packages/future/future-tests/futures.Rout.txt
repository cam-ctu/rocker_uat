
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:02:28.380] plan(): Setting new future strategy stack:
[17:02:28.381] List of future strategies:
[17:02:28.381] 1. sequential:
[17:02:28.381]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.381]    - tweaked: FALSE
[17:02:28.381]    - call: future::plan("sequential")
[17:02:28.392] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[17:02:28.447] plan(): Setting new future strategy stack:
[17:02:28.447] List of future strategies:
[17:02:28.447] 1. sequential:
[17:02:28.447]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.447]    - tweaked: FALSE
[17:02:28.447]    - call: plan(strategy)
[17:02:28.458] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[17:02:28.459] getGlobalsAndPackages() ...
[17:02:28.459] Searching for globals...
[17:02:28.462] 
[17:02:28.463] Searching for globals ... DONE
[17:02:28.463] - globals: [0] <none>
[17:02:28.463] getGlobalsAndPackages() ... DONE
[17:02:28.463] run() for ‘Future’ ...
[17:02:28.464] - state: ‘created’
[17:02:28.464] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.464] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.464] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.464]   - Field: ‘label’
[17:02:28.464]   - Field: ‘local’
[17:02:28.465]   - Field: ‘owner’
[17:02:28.465]   - Field: ‘envir’
[17:02:28.465]   - Field: ‘packages’
[17:02:28.465]   - Field: ‘gc’
[17:02:28.465]   - Field: ‘conditions’
[17:02:28.465]   - Field: ‘expr’
[17:02:28.465]   - Field: ‘uuid’
[17:02:28.465]   - Field: ‘seed’
[17:02:28.465]   - Field: ‘version’
[17:02:28.465]   - Field: ‘result’
[17:02:28.465]   - Field: ‘asynchronous’
[17:02:28.465]   - Field: ‘calls’
[17:02:28.466]   - Field: ‘globals’
[17:02:28.466]   - Field: ‘stdout’
[17:02:28.466]   - Field: ‘earlySignal’
[17:02:28.466]   - Field: ‘lazy’
[17:02:28.466]   - Field: ‘state’
[17:02:28.466] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.466] - Launch lazy future ...
[17:02:28.467] Packages needed by the future expression (n = 0): <none>
[17:02:28.467] Packages needed by future strategies (n = 0): <none>
[17:02:28.468] {
[17:02:28.468]     {
[17:02:28.468]         {
[17:02:28.468]             ...future.startTime <- base::Sys.time()
[17:02:28.468]             {
[17:02:28.468]                 {
[17:02:28.468]                   {
[17:02:28.468]                     base::local({
[17:02:28.468]                       has_future <- base::requireNamespace("future", 
[17:02:28.468]                         quietly = TRUE)
[17:02:28.468]                       if (has_future) {
[17:02:28.468]                         ns <- base::getNamespace("future")
[17:02:28.468]                         version <- ns[[".package"]][["version"]]
[17:02:28.468]                         if (is.null(version)) 
[17:02:28.468]                           version <- utils::packageVersion("future")
[17:02:28.468]                       }
[17:02:28.468]                       else {
[17:02:28.468]                         version <- NULL
[17:02:28.468]                       }
[17:02:28.468]                       if (!has_future || version < "1.8.0") {
[17:02:28.468]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.468]                           "", base::R.version$version.string), 
[17:02:28.468]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.468]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.468]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.468]                             "release", "version")], collapse = " "), 
[17:02:28.468]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.468]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.468]                           info)
[17:02:28.468]                         info <- base::paste(info, collapse = "; ")
[17:02:28.468]                         if (!has_future) {
[17:02:28.468]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.468]                             info)
[17:02:28.468]                         }
[17:02:28.468]                         else {
[17:02:28.468]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.468]                             info, version)
[17:02:28.468]                         }
[17:02:28.468]                         base::stop(msg)
[17:02:28.468]                       }
[17:02:28.468]                     })
[17:02:28.468]                   }
[17:02:28.468]                   ...future.strategy.old <- future::plan("list")
[17:02:28.468]                   options(future.plan = NULL)
[17:02:28.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.468]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.468]                 }
[17:02:28.468]                 ...future.workdir <- getwd()
[17:02:28.468]             }
[17:02:28.468]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.468]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.468]         }
[17:02:28.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.468]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.468]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.468]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.468]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.468]             base::names(...future.oldOptions))
[17:02:28.468]     }
[17:02:28.468]     if (FALSE) {
[17:02:28.468]     }
[17:02:28.468]     else {
[17:02:28.468]         if (TRUE) {
[17:02:28.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.468]                 open = "w")
[17:02:28.468]         }
[17:02:28.468]         else {
[17:02:28.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.468]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.468]         }
[17:02:28.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.468]             base::sink(type = "output", split = FALSE)
[17:02:28.468]             base::close(...future.stdout)
[17:02:28.468]         }, add = TRUE)
[17:02:28.468]     }
[17:02:28.468]     ...future.frame <- base::sys.nframe()
[17:02:28.468]     ...future.conditions <- base::list()
[17:02:28.468]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.468]     if (FALSE) {
[17:02:28.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.468]     }
[17:02:28.468]     ...future.result <- base::tryCatch({
[17:02:28.468]         base::withCallingHandlers({
[17:02:28.468]             ...future.value <- base::withVisible(base::local(2))
[17:02:28.468]             future::FutureResult(value = ...future.value$value, 
[17:02:28.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.468]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.468]                     ...future.globalenv.names))
[17:02:28.468]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.468]         }, condition = base::local({
[17:02:28.468]             c <- base::c
[17:02:28.468]             inherits <- base::inherits
[17:02:28.468]             invokeRestart <- base::invokeRestart
[17:02:28.468]             length <- base::length
[17:02:28.468]             list <- base::list
[17:02:28.468]             seq.int <- base::seq.int
[17:02:28.468]             signalCondition <- base::signalCondition
[17:02:28.468]             sys.calls <- base::sys.calls
[17:02:28.468]             `[[` <- base::`[[`
[17:02:28.468]             `+` <- base::`+`
[17:02:28.468]             `<<-` <- base::`<<-`
[17:02:28.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.468]                   3L)]
[17:02:28.468]             }
[17:02:28.468]             function(cond) {
[17:02:28.468]                 is_error <- inherits(cond, "error")
[17:02:28.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.468]                   NULL)
[17:02:28.468]                 if (is_error) {
[17:02:28.468]                   sessionInformation <- function() {
[17:02:28.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.468]                       search = base::search(), system = base::Sys.info())
[17:02:28.468]                   }
[17:02:28.468]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.468]                     cond$call), session = sessionInformation(), 
[17:02:28.468]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.468]                   signalCondition(cond)
[17:02:28.468]                 }
[17:02:28.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.468]                 "immediateCondition"))) {
[17:02:28.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.468]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.468]                   if (TRUE && !signal) {
[17:02:28.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.468]                     {
[17:02:28.468]                       inherits <- base::inherits
[17:02:28.468]                       invokeRestart <- base::invokeRestart
[17:02:28.468]                       is.null <- base::is.null
[17:02:28.468]                       muffled <- FALSE
[17:02:28.468]                       if (inherits(cond, "message")) {
[17:02:28.468]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.468]                         if (muffled) 
[17:02:28.468]                           invokeRestart("muffleMessage")
[17:02:28.468]                       }
[17:02:28.468]                       else if (inherits(cond, "warning")) {
[17:02:28.468]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.468]                         if (muffled) 
[17:02:28.468]                           invokeRestart("muffleWarning")
[17:02:28.468]                       }
[17:02:28.468]                       else if (inherits(cond, "condition")) {
[17:02:28.468]                         if (!is.null(pattern)) {
[17:02:28.468]                           computeRestarts <- base::computeRestarts
[17:02:28.468]                           grepl <- base::grepl
[17:02:28.468]                           restarts <- computeRestarts(cond)
[17:02:28.468]                           for (restart in restarts) {
[17:02:28.468]                             name <- restart$name
[17:02:28.468]                             if (is.null(name)) 
[17:02:28.468]                               next
[17:02:28.468]                             if (!grepl(pattern, name)) 
[17:02:28.468]                               next
[17:02:28.468]                             invokeRestart(restart)
[17:02:28.468]                             muffled <- TRUE
[17:02:28.468]                             break
[17:02:28.468]                           }
[17:02:28.468]                         }
[17:02:28.468]                       }
[17:02:28.468]                       invisible(muffled)
[17:02:28.468]                     }
[17:02:28.468]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.468]                   }
[17:02:28.468]                 }
[17:02:28.468]                 else {
[17:02:28.468]                   if (TRUE) {
[17:02:28.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.468]                     {
[17:02:28.468]                       inherits <- base::inherits
[17:02:28.468]                       invokeRestart <- base::invokeRestart
[17:02:28.468]                       is.null <- base::is.null
[17:02:28.468]                       muffled <- FALSE
[17:02:28.468]                       if (inherits(cond, "message")) {
[17:02:28.468]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.468]                         if (muffled) 
[17:02:28.468]                           invokeRestart("muffleMessage")
[17:02:28.468]                       }
[17:02:28.468]                       else if (inherits(cond, "warning")) {
[17:02:28.468]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.468]                         if (muffled) 
[17:02:28.468]                           invokeRestart("muffleWarning")
[17:02:28.468]                       }
[17:02:28.468]                       else if (inherits(cond, "condition")) {
[17:02:28.468]                         if (!is.null(pattern)) {
[17:02:28.468]                           computeRestarts <- base::computeRestarts
[17:02:28.468]                           grepl <- base::grepl
[17:02:28.468]                           restarts <- computeRestarts(cond)
[17:02:28.468]                           for (restart in restarts) {
[17:02:28.468]                             name <- restart$name
[17:02:28.468]                             if (is.null(name)) 
[17:02:28.468]                               next
[17:02:28.468]                             if (!grepl(pattern, name)) 
[17:02:28.468]                               next
[17:02:28.468]                             invokeRestart(restart)
[17:02:28.468]                             muffled <- TRUE
[17:02:28.468]                             break
[17:02:28.468]                           }
[17:02:28.468]                         }
[17:02:28.468]                       }
[17:02:28.468]                       invisible(muffled)
[17:02:28.468]                     }
[17:02:28.468]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.468]                   }
[17:02:28.468]                 }
[17:02:28.468]             }
[17:02:28.468]         }))
[17:02:28.468]     }, error = function(ex) {
[17:02:28.468]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.468]                 ...future.rng), started = ...future.startTime, 
[17:02:28.468]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.468]             version = "1.8"), class = "FutureResult")
[17:02:28.468]     }, finally = {
[17:02:28.468]         if (!identical(...future.workdir, getwd())) 
[17:02:28.468]             setwd(...future.workdir)
[17:02:28.468]         {
[17:02:28.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.468]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.468]             }
[17:02:28.468]             base::options(...future.oldOptions)
[17:02:28.468]             if (.Platform$OS.type == "windows") {
[17:02:28.468]                 old_names <- names(...future.oldEnvVars)
[17:02:28.468]                 envs <- base::Sys.getenv()
[17:02:28.468]                 names <- names(envs)
[17:02:28.468]                 common <- intersect(names, old_names)
[17:02:28.468]                 added <- setdiff(names, old_names)
[17:02:28.468]                 removed <- setdiff(old_names, names)
[17:02:28.468]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.468]                   envs[common]]
[17:02:28.468]                 NAMES <- toupper(changed)
[17:02:28.468]                 args <- list()
[17:02:28.468]                 for (kk in seq_along(NAMES)) {
[17:02:28.468]                   name <- changed[[kk]]
[17:02:28.468]                   NAME <- NAMES[[kk]]
[17:02:28.468]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.468]                     next
[17:02:28.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.468]                 }
[17:02:28.468]                 NAMES <- toupper(added)
[17:02:28.468]                 for (kk in seq_along(NAMES)) {
[17:02:28.468]                   name <- added[[kk]]
[17:02:28.468]                   NAME <- NAMES[[kk]]
[17:02:28.468]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.468]                     next
[17:02:28.468]                   args[[name]] <- ""
[17:02:28.468]                 }
[17:02:28.468]                 NAMES <- toupper(removed)
[17:02:28.468]                 for (kk in seq_along(NAMES)) {
[17:02:28.468]                   name <- removed[[kk]]
[17:02:28.468]                   NAME <- NAMES[[kk]]
[17:02:28.468]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.468]                     next
[17:02:28.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.468]                 }
[17:02:28.468]                 if (length(args) > 0) 
[17:02:28.468]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.468]             }
[17:02:28.468]             else {
[17:02:28.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.468]             }
[17:02:28.468]             {
[17:02:28.468]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.468]                   0L) {
[17:02:28.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.468]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.468]                   base::options(opts)
[17:02:28.468]                 }
[17:02:28.468]                 {
[17:02:28.468]                   {
[17:02:28.468]                     NULL
[17:02:28.468]                     RNGkind("Mersenne-Twister")
[17:02:28.468]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.468]                       inherits = FALSE)
[17:02:28.468]                   }
[17:02:28.468]                   options(future.plan = NULL)
[17:02:28.468]                   if (is.na(NA_character_)) 
[17:02:28.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.468]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.468]                     .init = FALSE)
[17:02:28.468]                 }
[17:02:28.468]             }
[17:02:28.468]         }
[17:02:28.468]     })
[17:02:28.468]     if (TRUE) {
[17:02:28.468]         base::sink(type = "output", split = FALSE)
[17:02:28.468]         if (TRUE) {
[17:02:28.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.468]         }
[17:02:28.468]         else {
[17:02:28.468]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.468]         }
[17:02:28.468]         base::close(...future.stdout)
[17:02:28.468]         ...future.stdout <- NULL
[17:02:28.468]     }
[17:02:28.468]     ...future.result$conditions <- ...future.conditions
[17:02:28.468]     ...future.result$finished <- base::Sys.time()
[17:02:28.468]     ...future.result
[17:02:28.468] }
[17:02:28.470] plan(): Setting new future strategy stack:
[17:02:28.470] List of future strategies:
[17:02:28.470] 1. sequential:
[17:02:28.470]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.470]    - tweaked: FALSE
[17:02:28.470]    - call: NULL
[17:02:28.470] plan(): nbrOfWorkers() = 1
[17:02:28.471] plan(): Setting new future strategy stack:
[17:02:28.471] List of future strategies:
[17:02:28.471] 1. sequential:
[17:02:28.471]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.471]    - tweaked: FALSE
[17:02:28.471]    - call: plan(strategy)
[17:02:28.472] plan(): nbrOfWorkers() = 1
[17:02:28.472] SequentialFuture started (and completed)
[17:02:28.472] - Launch lazy future ... done
[17:02:28.472] run() for ‘SequentialFuture’ ... done
[17:02:28.473] getGlobalsAndPackages() ...
[17:02:28.473] Searching for globals...
[17:02:28.473] 
[17:02:28.473] Searching for globals ... DONE
[17:02:28.473] - globals: [0] <none>
[17:02:28.473] getGlobalsAndPackages() ... DONE
[17:02:28.473] run() for ‘Future’ ...
[17:02:28.474] - state: ‘created’
[17:02:28.474] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.474] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.474] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.474]   - Field: ‘label’
[17:02:28.474]   - Field: ‘local’
[17:02:28.474]   - Field: ‘owner’
[17:02:28.474]   - Field: ‘envir’
[17:02:28.474]   - Field: ‘packages’
[17:02:28.475]   - Field: ‘gc’
[17:02:28.475]   - Field: ‘conditions’
[17:02:28.475]   - Field: ‘expr’
[17:02:28.475]   - Field: ‘uuid’
[17:02:28.475]   - Field: ‘seed’
[17:02:28.475]   - Field: ‘version’
[17:02:28.475]   - Field: ‘result’
[17:02:28.475]   - Field: ‘asynchronous’
[17:02:28.475]   - Field: ‘calls’
[17:02:28.475]   - Field: ‘globals’
[17:02:28.475]   - Field: ‘stdout’
[17:02:28.476]   - Field: ‘earlySignal’
[17:02:28.476]   - Field: ‘lazy’
[17:02:28.476]   - Field: ‘state’
[17:02:28.476] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.476] - Launch lazy future ...
[17:02:28.476] Packages needed by the future expression (n = 0): <none>
[17:02:28.476] Packages needed by future strategies (n = 0): <none>
[17:02:28.477] {
[17:02:28.477]     {
[17:02:28.477]         {
[17:02:28.477]             ...future.startTime <- base::Sys.time()
[17:02:28.477]             {
[17:02:28.477]                 {
[17:02:28.477]                   {
[17:02:28.477]                     base::local({
[17:02:28.477]                       has_future <- base::requireNamespace("future", 
[17:02:28.477]                         quietly = TRUE)
[17:02:28.477]                       if (has_future) {
[17:02:28.477]                         ns <- base::getNamespace("future")
[17:02:28.477]                         version <- ns[[".package"]][["version"]]
[17:02:28.477]                         if (is.null(version)) 
[17:02:28.477]                           version <- utils::packageVersion("future")
[17:02:28.477]                       }
[17:02:28.477]                       else {
[17:02:28.477]                         version <- NULL
[17:02:28.477]                       }
[17:02:28.477]                       if (!has_future || version < "1.8.0") {
[17:02:28.477]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.477]                           "", base::R.version$version.string), 
[17:02:28.477]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.477]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.477]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.477]                             "release", "version")], collapse = " "), 
[17:02:28.477]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.477]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.477]                           info)
[17:02:28.477]                         info <- base::paste(info, collapse = "; ")
[17:02:28.477]                         if (!has_future) {
[17:02:28.477]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.477]                             info)
[17:02:28.477]                         }
[17:02:28.477]                         else {
[17:02:28.477]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.477]                             info, version)
[17:02:28.477]                         }
[17:02:28.477]                         base::stop(msg)
[17:02:28.477]                       }
[17:02:28.477]                     })
[17:02:28.477]                   }
[17:02:28.477]                   ...future.strategy.old <- future::plan("list")
[17:02:28.477]                   options(future.plan = NULL)
[17:02:28.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.477]                 }
[17:02:28.477]                 ...future.workdir <- getwd()
[17:02:28.477]             }
[17:02:28.477]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.477]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.477]         }
[17:02:28.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.477]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.477]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.477]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.477]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.477]             base::names(...future.oldOptions))
[17:02:28.477]     }
[17:02:28.477]     if (FALSE) {
[17:02:28.477]     }
[17:02:28.477]     else {
[17:02:28.477]         if (TRUE) {
[17:02:28.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.477]                 open = "w")
[17:02:28.477]         }
[17:02:28.477]         else {
[17:02:28.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.477]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.477]         }
[17:02:28.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.477]             base::sink(type = "output", split = FALSE)
[17:02:28.477]             base::close(...future.stdout)
[17:02:28.477]         }, add = TRUE)
[17:02:28.477]     }
[17:02:28.477]     ...future.frame <- base::sys.nframe()
[17:02:28.477]     ...future.conditions <- base::list()
[17:02:28.477]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.477]     if (FALSE) {
[17:02:28.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.477]     }
[17:02:28.477]     ...future.result <- base::tryCatch({
[17:02:28.477]         base::withCallingHandlers({
[17:02:28.477]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:28.477]             future::FutureResult(value = ...future.value$value, 
[17:02:28.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.477]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.477]                     ...future.globalenv.names))
[17:02:28.477]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.477]         }, condition = base::local({
[17:02:28.477]             c <- base::c
[17:02:28.477]             inherits <- base::inherits
[17:02:28.477]             invokeRestart <- base::invokeRestart
[17:02:28.477]             length <- base::length
[17:02:28.477]             list <- base::list
[17:02:28.477]             seq.int <- base::seq.int
[17:02:28.477]             signalCondition <- base::signalCondition
[17:02:28.477]             sys.calls <- base::sys.calls
[17:02:28.477]             `[[` <- base::`[[`
[17:02:28.477]             `+` <- base::`+`
[17:02:28.477]             `<<-` <- base::`<<-`
[17:02:28.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.477]                   3L)]
[17:02:28.477]             }
[17:02:28.477]             function(cond) {
[17:02:28.477]                 is_error <- inherits(cond, "error")
[17:02:28.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.477]                   NULL)
[17:02:28.477]                 if (is_error) {
[17:02:28.477]                   sessionInformation <- function() {
[17:02:28.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.477]                       search = base::search(), system = base::Sys.info())
[17:02:28.477]                   }
[17:02:28.477]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.477]                     cond$call), session = sessionInformation(), 
[17:02:28.477]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.477]                   signalCondition(cond)
[17:02:28.477]                 }
[17:02:28.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.477]                 "immediateCondition"))) {
[17:02:28.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.477]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.477]                   if (TRUE && !signal) {
[17:02:28.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.477]                     {
[17:02:28.477]                       inherits <- base::inherits
[17:02:28.477]                       invokeRestart <- base::invokeRestart
[17:02:28.477]                       is.null <- base::is.null
[17:02:28.477]                       muffled <- FALSE
[17:02:28.477]                       if (inherits(cond, "message")) {
[17:02:28.477]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.477]                         if (muffled) 
[17:02:28.477]                           invokeRestart("muffleMessage")
[17:02:28.477]                       }
[17:02:28.477]                       else if (inherits(cond, "warning")) {
[17:02:28.477]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.477]                         if (muffled) 
[17:02:28.477]                           invokeRestart("muffleWarning")
[17:02:28.477]                       }
[17:02:28.477]                       else if (inherits(cond, "condition")) {
[17:02:28.477]                         if (!is.null(pattern)) {
[17:02:28.477]                           computeRestarts <- base::computeRestarts
[17:02:28.477]                           grepl <- base::grepl
[17:02:28.477]                           restarts <- computeRestarts(cond)
[17:02:28.477]                           for (restart in restarts) {
[17:02:28.477]                             name <- restart$name
[17:02:28.477]                             if (is.null(name)) 
[17:02:28.477]                               next
[17:02:28.477]                             if (!grepl(pattern, name)) 
[17:02:28.477]                               next
[17:02:28.477]                             invokeRestart(restart)
[17:02:28.477]                             muffled <- TRUE
[17:02:28.477]                             break
[17:02:28.477]                           }
[17:02:28.477]                         }
[17:02:28.477]                       }
[17:02:28.477]                       invisible(muffled)
[17:02:28.477]                     }
[17:02:28.477]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.477]                   }
[17:02:28.477]                 }
[17:02:28.477]                 else {
[17:02:28.477]                   if (TRUE) {
[17:02:28.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.477]                     {
[17:02:28.477]                       inherits <- base::inherits
[17:02:28.477]                       invokeRestart <- base::invokeRestart
[17:02:28.477]                       is.null <- base::is.null
[17:02:28.477]                       muffled <- FALSE
[17:02:28.477]                       if (inherits(cond, "message")) {
[17:02:28.477]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.477]                         if (muffled) 
[17:02:28.477]                           invokeRestart("muffleMessage")
[17:02:28.477]                       }
[17:02:28.477]                       else if (inherits(cond, "warning")) {
[17:02:28.477]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.477]                         if (muffled) 
[17:02:28.477]                           invokeRestart("muffleWarning")
[17:02:28.477]                       }
[17:02:28.477]                       else if (inherits(cond, "condition")) {
[17:02:28.477]                         if (!is.null(pattern)) {
[17:02:28.477]                           computeRestarts <- base::computeRestarts
[17:02:28.477]                           grepl <- base::grepl
[17:02:28.477]                           restarts <- computeRestarts(cond)
[17:02:28.477]                           for (restart in restarts) {
[17:02:28.477]                             name <- restart$name
[17:02:28.477]                             if (is.null(name)) 
[17:02:28.477]                               next
[17:02:28.477]                             if (!grepl(pattern, name)) 
[17:02:28.477]                               next
[17:02:28.477]                             invokeRestart(restart)
[17:02:28.477]                             muffled <- TRUE
[17:02:28.477]                             break
[17:02:28.477]                           }
[17:02:28.477]                         }
[17:02:28.477]                       }
[17:02:28.477]                       invisible(muffled)
[17:02:28.477]                     }
[17:02:28.477]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.477]                   }
[17:02:28.477]                 }
[17:02:28.477]             }
[17:02:28.477]         }))
[17:02:28.477]     }, error = function(ex) {
[17:02:28.477]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.477]                 ...future.rng), started = ...future.startTime, 
[17:02:28.477]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.477]             version = "1.8"), class = "FutureResult")
[17:02:28.477]     }, finally = {
[17:02:28.477]         if (!identical(...future.workdir, getwd())) 
[17:02:28.477]             setwd(...future.workdir)
[17:02:28.477]         {
[17:02:28.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.477]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.477]             }
[17:02:28.477]             base::options(...future.oldOptions)
[17:02:28.477]             if (.Platform$OS.type == "windows") {
[17:02:28.477]                 old_names <- names(...future.oldEnvVars)
[17:02:28.477]                 envs <- base::Sys.getenv()
[17:02:28.477]                 names <- names(envs)
[17:02:28.477]                 common <- intersect(names, old_names)
[17:02:28.477]                 added <- setdiff(names, old_names)
[17:02:28.477]                 removed <- setdiff(old_names, names)
[17:02:28.477]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.477]                   envs[common]]
[17:02:28.477]                 NAMES <- toupper(changed)
[17:02:28.477]                 args <- list()
[17:02:28.477]                 for (kk in seq_along(NAMES)) {
[17:02:28.477]                   name <- changed[[kk]]
[17:02:28.477]                   NAME <- NAMES[[kk]]
[17:02:28.477]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.477]                     next
[17:02:28.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.477]                 }
[17:02:28.477]                 NAMES <- toupper(added)
[17:02:28.477]                 for (kk in seq_along(NAMES)) {
[17:02:28.477]                   name <- added[[kk]]
[17:02:28.477]                   NAME <- NAMES[[kk]]
[17:02:28.477]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.477]                     next
[17:02:28.477]                   args[[name]] <- ""
[17:02:28.477]                 }
[17:02:28.477]                 NAMES <- toupper(removed)
[17:02:28.477]                 for (kk in seq_along(NAMES)) {
[17:02:28.477]                   name <- removed[[kk]]
[17:02:28.477]                   NAME <- NAMES[[kk]]
[17:02:28.477]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.477]                     next
[17:02:28.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.477]                 }
[17:02:28.477]                 if (length(args) > 0) 
[17:02:28.477]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.477]             }
[17:02:28.477]             else {
[17:02:28.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.477]             }
[17:02:28.477]             {
[17:02:28.477]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.477]                   0L) {
[17:02:28.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.477]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.477]                   base::options(opts)
[17:02:28.477]                 }
[17:02:28.477]                 {
[17:02:28.477]                   {
[17:02:28.477]                     NULL
[17:02:28.477]                     RNGkind("Mersenne-Twister")
[17:02:28.477]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.477]                       inherits = FALSE)
[17:02:28.477]                   }
[17:02:28.477]                   options(future.plan = NULL)
[17:02:28.477]                   if (is.na(NA_character_)) 
[17:02:28.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.477]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.477]                     .init = FALSE)
[17:02:28.477]                 }
[17:02:28.477]             }
[17:02:28.477]         }
[17:02:28.477]     })
[17:02:28.477]     if (TRUE) {
[17:02:28.477]         base::sink(type = "output", split = FALSE)
[17:02:28.477]         if (TRUE) {
[17:02:28.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.477]         }
[17:02:28.477]         else {
[17:02:28.477]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.477]         }
[17:02:28.477]         base::close(...future.stdout)
[17:02:28.477]         ...future.stdout <- NULL
[17:02:28.477]     }
[17:02:28.477]     ...future.result$conditions <- ...future.conditions
[17:02:28.477]     ...future.result$finished <- base::Sys.time()
[17:02:28.477]     ...future.result
[17:02:28.477] }
[17:02:28.478] plan(): Setting new future strategy stack:
[17:02:28.478] List of future strategies:
[17:02:28.478] 1. sequential:
[17:02:28.478]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.478]    - tweaked: FALSE
[17:02:28.478]    - call: NULL
[17:02:28.479] plan(): nbrOfWorkers() = 1
[17:02:28.479] plan(): Setting new future strategy stack:
[17:02:28.480] List of future strategies:
[17:02:28.480] 1. sequential:
[17:02:28.480]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.480]    - tweaked: FALSE
[17:02:28.480]    - call: plan(strategy)
[17:02:28.480] plan(): nbrOfWorkers() = 1
[17:02:28.480] SequentialFuture started (and completed)
[17:02:28.480] - Launch lazy future ... done
[17:02:28.480] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c74805e818> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c747e183b0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c74805e818> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c747e183b0> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:02:28.486] resolved() for ‘SequentialFuture’ ...
[17:02:28.486] - state: ‘finished’
[17:02:28.486] - run: TRUE
[17:02:28.486] - result: ‘FutureResult’
[17:02:28.487] resolved() for ‘SequentialFuture’ ... done
[17:02:28.487] resolved() for ‘SequentialFuture’ ...
[17:02:28.487] - state: ‘finished’
[17:02:28.487] - run: TRUE
[17:02:28.487] - result: ‘FutureResult’
[17:02:28.487] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:28.488] resolve() on list ...
[17:02:28.488]  recursive: 0
[17:02:28.488]  length: 6
[17:02:28.488]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:28.489] signalConditionsASAP(numeric, pos=1) ...
[17:02:28.489] - nx: 6
[17:02:28.489] - relay: TRUE
[17:02:28.489] - stdout: TRUE
[17:02:28.489] - signal: TRUE
[17:02:28.489] - resignal: FALSE
[17:02:28.489] - force: TRUE
[17:02:28.489] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.489] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.489]  - until=2
[17:02:28.489]  - relaying element #2
[17:02:28.489] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.490] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.490] signalConditionsASAP(NULL, pos=1) ... done
[17:02:28.490]  length: 5 (resolved future 1)
[17:02:28.490] resolved() for ‘SequentialFuture’ ...
[17:02:28.490] - state: ‘finished’
[17:02:28.490] - run: TRUE
[17:02:28.490] - result: ‘FutureResult’
[17:02:28.490] resolved() for ‘SequentialFuture’ ... done
[17:02:28.490] Future #2
[17:02:28.491] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:28.491] - nx: 6
[17:02:28.491] - relay: TRUE
[17:02:28.491] - stdout: TRUE
[17:02:28.491] - signal: TRUE
[17:02:28.491] - resignal: FALSE
[17:02:28.491] - force: TRUE
[17:02:28.491] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.491] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.491]  - until=2
[17:02:28.492]  - relaying element #2
[17:02:28.492] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.492] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.492] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:28.492]  length: 4 (resolved future 2)
[17:02:28.492] resolved() for ‘SequentialFuture’ ...
[17:02:28.492] - state: ‘finished’
[17:02:28.492] - run: TRUE
[17:02:28.492] - result: ‘FutureResult’
[17:02:28.493] resolved() for ‘SequentialFuture’ ... done
[17:02:28.493] Future #3
[17:02:28.493] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:28.493] - nx: 6
[17:02:28.493] - relay: TRUE
[17:02:28.493] - stdout: TRUE
[17:02:28.493] - signal: TRUE
[17:02:28.493] - resignal: FALSE
[17:02:28.493] - force: TRUE
[17:02:28.493] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.493] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.494]  - until=3
[17:02:28.494]  - relaying element #3
[17:02:28.494] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.494] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.494] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:28.494]  length: 3 (resolved future 3)
[17:02:28.494] signalConditionsASAP(NULL, pos=4) ...
[17:02:28.494] - nx: 6
[17:02:28.494] - relay: TRUE
[17:02:28.494] - stdout: TRUE
[17:02:28.494] - signal: TRUE
[17:02:28.495] - resignal: FALSE
[17:02:28.495] - force: TRUE
[17:02:28.495] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.495] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.495]  - until=5
[17:02:28.495]  - relaying element #5
[17:02:28.495] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.495] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.495] signalConditionsASAP(NULL, pos=4) ... done
[17:02:28.495]  length: 2 (resolved future 4)
[17:02:28.495] signalConditionsASAP(NULL, pos=5) ...
[17:02:28.495] - nx: 6
[17:02:28.496] - relay: TRUE
[17:02:28.496] - stdout: TRUE
[17:02:28.496] - signal: TRUE
[17:02:28.496] - resignal: FALSE
[17:02:28.496] - force: TRUE
[17:02:28.496] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.496] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.496]  - until=6
[17:02:28.496]  - relaying element #6
[17:02:28.496] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:28.496] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.496] signalConditionsASAP(NULL, pos=5) ... done
[17:02:28.497]  length: 1 (resolved future 5)
[17:02:28.497] signalConditionsASAP(numeric, pos=6) ...
[17:02:28.497] - nx: 6
[17:02:28.497] - relay: TRUE
[17:02:28.499] - stdout: TRUE
[17:02:28.499] - signal: TRUE
[17:02:28.499] - resignal: FALSE
[17:02:28.499] - force: TRUE
[17:02:28.500] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:28.500] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.500]  - until=6
[17:02:28.500] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.500] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.500] signalConditionsASAP(numeric, pos=6) ... done
[17:02:28.500]  length: 0 (resolved future 6)
[17:02:28.500] Relaying remaining futures
[17:02:28.500] signalConditionsASAP(NULL, pos=0) ...
[17:02:28.500] - nx: 6
[17:02:28.500] - relay: TRUE
[17:02:28.501] - stdout: TRUE
[17:02:28.501] - signal: TRUE
[17:02:28.501] - resignal: FALSE
[17:02:28.501] - force: TRUE
[17:02:28.501] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.501] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:28.501] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.501] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.501] signalConditionsASAP(NULL, pos=0) ... done
[17:02:28.501] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[17:02:28.504] getGlobalsAndPackages() ...
[17:02:28.504] Searching for globals...
[17:02:28.504] 
[17:02:28.504] Searching for globals ... DONE
[17:02:28.504] - globals: [0] <none>
[17:02:28.504] getGlobalsAndPackages() ... DONE
[17:02:28.504] run() for ‘Future’ ...
[17:02:28.505] - state: ‘created’
[17:02:28.505] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.505] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.505] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.505]   - Field: ‘label’
[17:02:28.505]   - Field: ‘local’
[17:02:28.505]   - Field: ‘owner’
[17:02:28.505]   - Field: ‘envir’
[17:02:28.506]   - Field: ‘packages’
[17:02:28.506]   - Field: ‘gc’
[17:02:28.506]   - Field: ‘conditions’
[17:02:28.506]   - Field: ‘expr’
[17:02:28.506]   - Field: ‘uuid’
[17:02:28.506]   - Field: ‘seed’
[17:02:28.506]   - Field: ‘version’
[17:02:28.506]   - Field: ‘result’
[17:02:28.506]   - Field: ‘asynchronous’
[17:02:28.506]   - Field: ‘calls’
[17:02:28.506]   - Field: ‘globals’
[17:02:28.507]   - Field: ‘stdout’
[17:02:28.507]   - Field: ‘earlySignal’
[17:02:28.507]   - Field: ‘lazy’
[17:02:28.507]   - Field: ‘state’
[17:02:28.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.507] - Launch lazy future ...
[17:02:28.507] Packages needed by the future expression (n = 0): <none>
[17:02:28.507] Packages needed by future strategies (n = 0): <none>
[17:02:28.508] {
[17:02:28.508]     {
[17:02:28.508]         {
[17:02:28.508]             ...future.startTime <- base::Sys.time()
[17:02:28.508]             {
[17:02:28.508]                 {
[17:02:28.508]                   {
[17:02:28.508]                     base::local({
[17:02:28.508]                       has_future <- base::requireNamespace("future", 
[17:02:28.508]                         quietly = TRUE)
[17:02:28.508]                       if (has_future) {
[17:02:28.508]                         ns <- base::getNamespace("future")
[17:02:28.508]                         version <- ns[[".package"]][["version"]]
[17:02:28.508]                         if (is.null(version)) 
[17:02:28.508]                           version <- utils::packageVersion("future")
[17:02:28.508]                       }
[17:02:28.508]                       else {
[17:02:28.508]                         version <- NULL
[17:02:28.508]                       }
[17:02:28.508]                       if (!has_future || version < "1.8.0") {
[17:02:28.508]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.508]                           "", base::R.version$version.string), 
[17:02:28.508]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.508]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.508]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.508]                             "release", "version")], collapse = " "), 
[17:02:28.508]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.508]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.508]                           info)
[17:02:28.508]                         info <- base::paste(info, collapse = "; ")
[17:02:28.508]                         if (!has_future) {
[17:02:28.508]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.508]                             info)
[17:02:28.508]                         }
[17:02:28.508]                         else {
[17:02:28.508]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.508]                             info, version)
[17:02:28.508]                         }
[17:02:28.508]                         base::stop(msg)
[17:02:28.508]                       }
[17:02:28.508]                     })
[17:02:28.508]                   }
[17:02:28.508]                   ...future.strategy.old <- future::plan("list")
[17:02:28.508]                   options(future.plan = NULL)
[17:02:28.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.508]                 }
[17:02:28.508]                 ...future.workdir <- getwd()
[17:02:28.508]             }
[17:02:28.508]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.508]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.508]         }
[17:02:28.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.508]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.508]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.508]             base::names(...future.oldOptions))
[17:02:28.508]     }
[17:02:28.508]     if (FALSE) {
[17:02:28.508]     }
[17:02:28.508]     else {
[17:02:28.508]         if (TRUE) {
[17:02:28.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.508]                 open = "w")
[17:02:28.508]         }
[17:02:28.508]         else {
[17:02:28.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.508]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.508]         }
[17:02:28.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.508]             base::sink(type = "output", split = FALSE)
[17:02:28.508]             base::close(...future.stdout)
[17:02:28.508]         }, add = TRUE)
[17:02:28.508]     }
[17:02:28.508]     ...future.frame <- base::sys.nframe()
[17:02:28.508]     ...future.conditions <- base::list()
[17:02:28.508]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.508]     if (FALSE) {
[17:02:28.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.508]     }
[17:02:28.508]     ...future.result <- base::tryCatch({
[17:02:28.508]         base::withCallingHandlers({
[17:02:28.508]             ...future.value <- base::withVisible(base::local(2))
[17:02:28.508]             future::FutureResult(value = ...future.value$value, 
[17:02:28.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.508]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.508]                     ...future.globalenv.names))
[17:02:28.508]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.508]         }, condition = base::local({
[17:02:28.508]             c <- base::c
[17:02:28.508]             inherits <- base::inherits
[17:02:28.508]             invokeRestart <- base::invokeRestart
[17:02:28.508]             length <- base::length
[17:02:28.508]             list <- base::list
[17:02:28.508]             seq.int <- base::seq.int
[17:02:28.508]             signalCondition <- base::signalCondition
[17:02:28.508]             sys.calls <- base::sys.calls
[17:02:28.508]             `[[` <- base::`[[`
[17:02:28.508]             `+` <- base::`+`
[17:02:28.508]             `<<-` <- base::`<<-`
[17:02:28.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.508]                   3L)]
[17:02:28.508]             }
[17:02:28.508]             function(cond) {
[17:02:28.508]                 is_error <- inherits(cond, "error")
[17:02:28.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.508]                   NULL)
[17:02:28.508]                 if (is_error) {
[17:02:28.508]                   sessionInformation <- function() {
[17:02:28.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.508]                       search = base::search(), system = base::Sys.info())
[17:02:28.508]                   }
[17:02:28.508]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.508]                     cond$call), session = sessionInformation(), 
[17:02:28.508]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.508]                   signalCondition(cond)
[17:02:28.508]                 }
[17:02:28.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.508]                 "immediateCondition"))) {
[17:02:28.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.508]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.508]                   if (TRUE && !signal) {
[17:02:28.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.508]                     {
[17:02:28.508]                       inherits <- base::inherits
[17:02:28.508]                       invokeRestart <- base::invokeRestart
[17:02:28.508]                       is.null <- base::is.null
[17:02:28.508]                       muffled <- FALSE
[17:02:28.508]                       if (inherits(cond, "message")) {
[17:02:28.508]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.508]                         if (muffled) 
[17:02:28.508]                           invokeRestart("muffleMessage")
[17:02:28.508]                       }
[17:02:28.508]                       else if (inherits(cond, "warning")) {
[17:02:28.508]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.508]                         if (muffled) 
[17:02:28.508]                           invokeRestart("muffleWarning")
[17:02:28.508]                       }
[17:02:28.508]                       else if (inherits(cond, "condition")) {
[17:02:28.508]                         if (!is.null(pattern)) {
[17:02:28.508]                           computeRestarts <- base::computeRestarts
[17:02:28.508]                           grepl <- base::grepl
[17:02:28.508]                           restarts <- computeRestarts(cond)
[17:02:28.508]                           for (restart in restarts) {
[17:02:28.508]                             name <- restart$name
[17:02:28.508]                             if (is.null(name)) 
[17:02:28.508]                               next
[17:02:28.508]                             if (!grepl(pattern, name)) 
[17:02:28.508]                               next
[17:02:28.508]                             invokeRestart(restart)
[17:02:28.508]                             muffled <- TRUE
[17:02:28.508]                             break
[17:02:28.508]                           }
[17:02:28.508]                         }
[17:02:28.508]                       }
[17:02:28.508]                       invisible(muffled)
[17:02:28.508]                     }
[17:02:28.508]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.508]                   }
[17:02:28.508]                 }
[17:02:28.508]                 else {
[17:02:28.508]                   if (TRUE) {
[17:02:28.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.508]                     {
[17:02:28.508]                       inherits <- base::inherits
[17:02:28.508]                       invokeRestart <- base::invokeRestart
[17:02:28.508]                       is.null <- base::is.null
[17:02:28.508]                       muffled <- FALSE
[17:02:28.508]                       if (inherits(cond, "message")) {
[17:02:28.508]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.508]                         if (muffled) 
[17:02:28.508]                           invokeRestart("muffleMessage")
[17:02:28.508]                       }
[17:02:28.508]                       else if (inherits(cond, "warning")) {
[17:02:28.508]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.508]                         if (muffled) 
[17:02:28.508]                           invokeRestart("muffleWarning")
[17:02:28.508]                       }
[17:02:28.508]                       else if (inherits(cond, "condition")) {
[17:02:28.508]                         if (!is.null(pattern)) {
[17:02:28.508]                           computeRestarts <- base::computeRestarts
[17:02:28.508]                           grepl <- base::grepl
[17:02:28.508]                           restarts <- computeRestarts(cond)
[17:02:28.508]                           for (restart in restarts) {
[17:02:28.508]                             name <- restart$name
[17:02:28.508]                             if (is.null(name)) 
[17:02:28.508]                               next
[17:02:28.508]                             if (!grepl(pattern, name)) 
[17:02:28.508]                               next
[17:02:28.508]                             invokeRestart(restart)
[17:02:28.508]                             muffled <- TRUE
[17:02:28.508]                             break
[17:02:28.508]                           }
[17:02:28.508]                         }
[17:02:28.508]                       }
[17:02:28.508]                       invisible(muffled)
[17:02:28.508]                     }
[17:02:28.508]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.508]                   }
[17:02:28.508]                 }
[17:02:28.508]             }
[17:02:28.508]         }))
[17:02:28.508]     }, error = function(ex) {
[17:02:28.508]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.508]                 ...future.rng), started = ...future.startTime, 
[17:02:28.508]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.508]             version = "1.8"), class = "FutureResult")
[17:02:28.508]     }, finally = {
[17:02:28.508]         if (!identical(...future.workdir, getwd())) 
[17:02:28.508]             setwd(...future.workdir)
[17:02:28.508]         {
[17:02:28.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.508]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.508]             }
[17:02:28.508]             base::options(...future.oldOptions)
[17:02:28.508]             if (.Platform$OS.type == "windows") {
[17:02:28.508]                 old_names <- names(...future.oldEnvVars)
[17:02:28.508]                 envs <- base::Sys.getenv()
[17:02:28.508]                 names <- names(envs)
[17:02:28.508]                 common <- intersect(names, old_names)
[17:02:28.508]                 added <- setdiff(names, old_names)
[17:02:28.508]                 removed <- setdiff(old_names, names)
[17:02:28.508]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.508]                   envs[common]]
[17:02:28.508]                 NAMES <- toupper(changed)
[17:02:28.508]                 args <- list()
[17:02:28.508]                 for (kk in seq_along(NAMES)) {
[17:02:28.508]                   name <- changed[[kk]]
[17:02:28.508]                   NAME <- NAMES[[kk]]
[17:02:28.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.508]                     next
[17:02:28.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.508]                 }
[17:02:28.508]                 NAMES <- toupper(added)
[17:02:28.508]                 for (kk in seq_along(NAMES)) {
[17:02:28.508]                   name <- added[[kk]]
[17:02:28.508]                   NAME <- NAMES[[kk]]
[17:02:28.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.508]                     next
[17:02:28.508]                   args[[name]] <- ""
[17:02:28.508]                 }
[17:02:28.508]                 NAMES <- toupper(removed)
[17:02:28.508]                 for (kk in seq_along(NAMES)) {
[17:02:28.508]                   name <- removed[[kk]]
[17:02:28.508]                   NAME <- NAMES[[kk]]
[17:02:28.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.508]                     next
[17:02:28.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.508]                 }
[17:02:28.508]                 if (length(args) > 0) 
[17:02:28.508]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.508]             }
[17:02:28.508]             else {
[17:02:28.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.508]             }
[17:02:28.508]             {
[17:02:28.508]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.508]                   0L) {
[17:02:28.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.508]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.508]                   base::options(opts)
[17:02:28.508]                 }
[17:02:28.508]                 {
[17:02:28.508]                   {
[17:02:28.508]                     NULL
[17:02:28.508]                     RNGkind("Mersenne-Twister")
[17:02:28.508]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.508]                       inherits = FALSE)
[17:02:28.508]                   }
[17:02:28.508]                   options(future.plan = NULL)
[17:02:28.508]                   if (is.na(NA_character_)) 
[17:02:28.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.508]                     .init = FALSE)
[17:02:28.508]                 }
[17:02:28.508]             }
[17:02:28.508]         }
[17:02:28.508]     })
[17:02:28.508]     if (TRUE) {
[17:02:28.508]         base::sink(type = "output", split = FALSE)
[17:02:28.508]         if (TRUE) {
[17:02:28.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.508]         }
[17:02:28.508]         else {
[17:02:28.508]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.508]         }
[17:02:28.508]         base::close(...future.stdout)
[17:02:28.508]         ...future.stdout <- NULL
[17:02:28.508]     }
[17:02:28.508]     ...future.result$conditions <- ...future.conditions
[17:02:28.508]     ...future.result$finished <- base::Sys.time()
[17:02:28.508]     ...future.result
[17:02:28.508] }
[17:02:28.510] plan(): Setting new future strategy stack:
[17:02:28.510] List of future strategies:
[17:02:28.510] 1. sequential:
[17:02:28.510]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.510]    - tweaked: FALSE
[17:02:28.510]    - call: NULL
[17:02:28.510] plan(): nbrOfWorkers() = 1
[17:02:28.511] plan(): Setting new future strategy stack:
[17:02:28.511] List of future strategies:
[17:02:28.511] 1. sequential:
[17:02:28.511]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.511]    - tweaked: FALSE
[17:02:28.511]    - call: plan(strategy)
[17:02:28.511] plan(): nbrOfWorkers() = 1
[17:02:28.512] SequentialFuture started (and completed)
[17:02:28.512] - Launch lazy future ... done
[17:02:28.512] run() for ‘SequentialFuture’ ... done
[17:02:28.512] getGlobalsAndPackages() ...
[17:02:28.512] Searching for globals...
[17:02:28.512] 
[17:02:28.512] Searching for globals ... DONE
[17:02:28.513] - globals: [0] <none>
[17:02:28.513] getGlobalsAndPackages() ... DONE
[17:02:28.513] run() for ‘Future’ ...
[17:02:28.513] - state: ‘created’
[17:02:28.513] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.513] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.513] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.514]   - Field: ‘label’
[17:02:28.514]   - Field: ‘local’
[17:02:28.514]   - Field: ‘owner’
[17:02:28.514]   - Field: ‘envir’
[17:02:28.514]   - Field: ‘packages’
[17:02:28.514]   - Field: ‘gc’
[17:02:28.514]   - Field: ‘conditions’
[17:02:28.514]   - Field: ‘expr’
[17:02:28.514]   - Field: ‘uuid’
[17:02:28.514]   - Field: ‘seed’
[17:02:28.514]   - Field: ‘version’
[17:02:28.514]   - Field: ‘result’
[17:02:28.515]   - Field: ‘asynchronous’
[17:02:28.515]   - Field: ‘calls’
[17:02:28.515]   - Field: ‘globals’
[17:02:28.515]   - Field: ‘stdout’
[17:02:28.515]   - Field: ‘earlySignal’
[17:02:28.515]   - Field: ‘lazy’
[17:02:28.515]   - Field: ‘state’
[17:02:28.515] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.515] - Launch lazy future ...
[17:02:28.515] Packages needed by the future expression (n = 0): <none>
[17:02:28.516] Packages needed by future strategies (n = 0): <none>
[17:02:28.516] {
[17:02:28.516]     {
[17:02:28.516]         {
[17:02:28.516]             ...future.startTime <- base::Sys.time()
[17:02:28.516]             {
[17:02:28.516]                 {
[17:02:28.516]                   {
[17:02:28.516]                     base::local({
[17:02:28.516]                       has_future <- base::requireNamespace("future", 
[17:02:28.516]                         quietly = TRUE)
[17:02:28.516]                       if (has_future) {
[17:02:28.516]                         ns <- base::getNamespace("future")
[17:02:28.516]                         version <- ns[[".package"]][["version"]]
[17:02:28.516]                         if (is.null(version)) 
[17:02:28.516]                           version <- utils::packageVersion("future")
[17:02:28.516]                       }
[17:02:28.516]                       else {
[17:02:28.516]                         version <- NULL
[17:02:28.516]                       }
[17:02:28.516]                       if (!has_future || version < "1.8.0") {
[17:02:28.516]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.516]                           "", base::R.version$version.string), 
[17:02:28.516]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.516]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.516]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.516]                             "release", "version")], collapse = " "), 
[17:02:28.516]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.516]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.516]                           info)
[17:02:28.516]                         info <- base::paste(info, collapse = "; ")
[17:02:28.516]                         if (!has_future) {
[17:02:28.516]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.516]                             info)
[17:02:28.516]                         }
[17:02:28.516]                         else {
[17:02:28.516]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.516]                             info, version)
[17:02:28.516]                         }
[17:02:28.516]                         base::stop(msg)
[17:02:28.516]                       }
[17:02:28.516]                     })
[17:02:28.516]                   }
[17:02:28.516]                   ...future.strategy.old <- future::plan("list")
[17:02:28.516]                   options(future.plan = NULL)
[17:02:28.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.516]                 }
[17:02:28.516]                 ...future.workdir <- getwd()
[17:02:28.516]             }
[17:02:28.516]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.516]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.516]         }
[17:02:28.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.516]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.516]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.516]             base::names(...future.oldOptions))
[17:02:28.516]     }
[17:02:28.516]     if (FALSE) {
[17:02:28.516]     }
[17:02:28.516]     else {
[17:02:28.516]         if (TRUE) {
[17:02:28.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.516]                 open = "w")
[17:02:28.516]         }
[17:02:28.516]         else {
[17:02:28.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.516]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.516]         }
[17:02:28.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.516]             base::sink(type = "output", split = FALSE)
[17:02:28.516]             base::close(...future.stdout)
[17:02:28.516]         }, add = TRUE)
[17:02:28.516]     }
[17:02:28.516]     ...future.frame <- base::sys.nframe()
[17:02:28.516]     ...future.conditions <- base::list()
[17:02:28.516]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.516]     if (FALSE) {
[17:02:28.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.516]     }
[17:02:28.516]     ...future.result <- base::tryCatch({
[17:02:28.516]         base::withCallingHandlers({
[17:02:28.516]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:28.516]             future::FutureResult(value = ...future.value$value, 
[17:02:28.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.516]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.516]                     ...future.globalenv.names))
[17:02:28.516]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.516]         }, condition = base::local({
[17:02:28.516]             c <- base::c
[17:02:28.516]             inherits <- base::inherits
[17:02:28.516]             invokeRestart <- base::invokeRestart
[17:02:28.516]             length <- base::length
[17:02:28.516]             list <- base::list
[17:02:28.516]             seq.int <- base::seq.int
[17:02:28.516]             signalCondition <- base::signalCondition
[17:02:28.516]             sys.calls <- base::sys.calls
[17:02:28.516]             `[[` <- base::`[[`
[17:02:28.516]             `+` <- base::`+`
[17:02:28.516]             `<<-` <- base::`<<-`
[17:02:28.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.516]                   3L)]
[17:02:28.516]             }
[17:02:28.516]             function(cond) {
[17:02:28.516]                 is_error <- inherits(cond, "error")
[17:02:28.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.516]                   NULL)
[17:02:28.516]                 if (is_error) {
[17:02:28.516]                   sessionInformation <- function() {
[17:02:28.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.516]                       search = base::search(), system = base::Sys.info())
[17:02:28.516]                   }
[17:02:28.516]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.516]                     cond$call), session = sessionInformation(), 
[17:02:28.516]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.516]                   signalCondition(cond)
[17:02:28.516]                 }
[17:02:28.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.516]                 "immediateCondition"))) {
[17:02:28.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.516]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.516]                   if (TRUE && !signal) {
[17:02:28.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.516]                     {
[17:02:28.516]                       inherits <- base::inherits
[17:02:28.516]                       invokeRestart <- base::invokeRestart
[17:02:28.516]                       is.null <- base::is.null
[17:02:28.516]                       muffled <- FALSE
[17:02:28.516]                       if (inherits(cond, "message")) {
[17:02:28.516]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.516]                         if (muffled) 
[17:02:28.516]                           invokeRestart("muffleMessage")
[17:02:28.516]                       }
[17:02:28.516]                       else if (inherits(cond, "warning")) {
[17:02:28.516]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.516]                         if (muffled) 
[17:02:28.516]                           invokeRestart("muffleWarning")
[17:02:28.516]                       }
[17:02:28.516]                       else if (inherits(cond, "condition")) {
[17:02:28.516]                         if (!is.null(pattern)) {
[17:02:28.516]                           computeRestarts <- base::computeRestarts
[17:02:28.516]                           grepl <- base::grepl
[17:02:28.516]                           restarts <- computeRestarts(cond)
[17:02:28.516]                           for (restart in restarts) {
[17:02:28.516]                             name <- restart$name
[17:02:28.516]                             if (is.null(name)) 
[17:02:28.516]                               next
[17:02:28.516]                             if (!grepl(pattern, name)) 
[17:02:28.516]                               next
[17:02:28.516]                             invokeRestart(restart)
[17:02:28.516]                             muffled <- TRUE
[17:02:28.516]                             break
[17:02:28.516]                           }
[17:02:28.516]                         }
[17:02:28.516]                       }
[17:02:28.516]                       invisible(muffled)
[17:02:28.516]                     }
[17:02:28.516]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.516]                   }
[17:02:28.516]                 }
[17:02:28.516]                 else {
[17:02:28.516]                   if (TRUE) {
[17:02:28.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.516]                     {
[17:02:28.516]                       inherits <- base::inherits
[17:02:28.516]                       invokeRestart <- base::invokeRestart
[17:02:28.516]                       is.null <- base::is.null
[17:02:28.516]                       muffled <- FALSE
[17:02:28.516]                       if (inherits(cond, "message")) {
[17:02:28.516]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.516]                         if (muffled) 
[17:02:28.516]                           invokeRestart("muffleMessage")
[17:02:28.516]                       }
[17:02:28.516]                       else if (inherits(cond, "warning")) {
[17:02:28.516]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.516]                         if (muffled) 
[17:02:28.516]                           invokeRestart("muffleWarning")
[17:02:28.516]                       }
[17:02:28.516]                       else if (inherits(cond, "condition")) {
[17:02:28.516]                         if (!is.null(pattern)) {
[17:02:28.516]                           computeRestarts <- base::computeRestarts
[17:02:28.516]                           grepl <- base::grepl
[17:02:28.516]                           restarts <- computeRestarts(cond)
[17:02:28.516]                           for (restart in restarts) {
[17:02:28.516]                             name <- restart$name
[17:02:28.516]                             if (is.null(name)) 
[17:02:28.516]                               next
[17:02:28.516]                             if (!grepl(pattern, name)) 
[17:02:28.516]                               next
[17:02:28.516]                             invokeRestart(restart)
[17:02:28.516]                             muffled <- TRUE
[17:02:28.516]                             break
[17:02:28.516]                           }
[17:02:28.516]                         }
[17:02:28.516]                       }
[17:02:28.516]                       invisible(muffled)
[17:02:28.516]                     }
[17:02:28.516]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.516]                   }
[17:02:28.516]                 }
[17:02:28.516]             }
[17:02:28.516]         }))
[17:02:28.516]     }, error = function(ex) {
[17:02:28.516]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.516]                 ...future.rng), started = ...future.startTime, 
[17:02:28.516]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.516]             version = "1.8"), class = "FutureResult")
[17:02:28.516]     }, finally = {
[17:02:28.516]         if (!identical(...future.workdir, getwd())) 
[17:02:28.516]             setwd(...future.workdir)
[17:02:28.516]         {
[17:02:28.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.516]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.516]             }
[17:02:28.516]             base::options(...future.oldOptions)
[17:02:28.516]             if (.Platform$OS.type == "windows") {
[17:02:28.516]                 old_names <- names(...future.oldEnvVars)
[17:02:28.516]                 envs <- base::Sys.getenv()
[17:02:28.516]                 names <- names(envs)
[17:02:28.516]                 common <- intersect(names, old_names)
[17:02:28.516]                 added <- setdiff(names, old_names)
[17:02:28.516]                 removed <- setdiff(old_names, names)
[17:02:28.516]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.516]                   envs[common]]
[17:02:28.516]                 NAMES <- toupper(changed)
[17:02:28.516]                 args <- list()
[17:02:28.516]                 for (kk in seq_along(NAMES)) {
[17:02:28.516]                   name <- changed[[kk]]
[17:02:28.516]                   NAME <- NAMES[[kk]]
[17:02:28.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.516]                     next
[17:02:28.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.516]                 }
[17:02:28.516]                 NAMES <- toupper(added)
[17:02:28.516]                 for (kk in seq_along(NAMES)) {
[17:02:28.516]                   name <- added[[kk]]
[17:02:28.516]                   NAME <- NAMES[[kk]]
[17:02:28.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.516]                     next
[17:02:28.516]                   args[[name]] <- ""
[17:02:28.516]                 }
[17:02:28.516]                 NAMES <- toupper(removed)
[17:02:28.516]                 for (kk in seq_along(NAMES)) {
[17:02:28.516]                   name <- removed[[kk]]
[17:02:28.516]                   NAME <- NAMES[[kk]]
[17:02:28.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.516]                     next
[17:02:28.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.516]                 }
[17:02:28.516]                 if (length(args) > 0) 
[17:02:28.516]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.516]             }
[17:02:28.516]             else {
[17:02:28.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.516]             }
[17:02:28.516]             {
[17:02:28.516]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.516]                   0L) {
[17:02:28.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.516]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.516]                   base::options(opts)
[17:02:28.516]                 }
[17:02:28.516]                 {
[17:02:28.516]                   {
[17:02:28.516]                     NULL
[17:02:28.516]                     RNGkind("Mersenne-Twister")
[17:02:28.516]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.516]                       inherits = FALSE)
[17:02:28.516]                   }
[17:02:28.516]                   options(future.plan = NULL)
[17:02:28.516]                   if (is.na(NA_character_)) 
[17:02:28.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.516]                     .init = FALSE)
[17:02:28.516]                 }
[17:02:28.516]             }
[17:02:28.516]         }
[17:02:28.516]     })
[17:02:28.516]     if (TRUE) {
[17:02:28.516]         base::sink(type = "output", split = FALSE)
[17:02:28.516]         if (TRUE) {
[17:02:28.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.516]         }
[17:02:28.516]         else {
[17:02:28.516]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.516]         }
[17:02:28.516]         base::close(...future.stdout)
[17:02:28.516]         ...future.stdout <- NULL
[17:02:28.516]     }
[17:02:28.516]     ...future.result$conditions <- ...future.conditions
[17:02:28.516]     ...future.result$finished <- base::Sys.time()
[17:02:28.516]     ...future.result
[17:02:28.516] }
[17:02:28.518] plan(): Setting new future strategy stack:
[17:02:28.518] List of future strategies:
[17:02:28.518] 1. sequential:
[17:02:28.518]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.518]    - tweaked: FALSE
[17:02:28.518]    - call: NULL
[17:02:28.518] plan(): nbrOfWorkers() = 1
[17:02:28.519] plan(): Setting new future strategy stack:
[17:02:28.519] List of future strategies:
[17:02:28.519] 1. sequential:
[17:02:28.519]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.519]    - tweaked: FALSE
[17:02:28.519]    - call: plan(strategy)
[17:02:28.520] plan(): nbrOfWorkers() = 1
[17:02:28.520] SequentialFuture started (and completed)
[17:02:28.520] - Launch lazy future ... done
[17:02:28.520] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c7471663f8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c749101658> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c7471663f8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c749101658> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:02:28.525] resolved() for ‘SequentialFuture’ ...
[17:02:28.525] - state: ‘finished’
[17:02:28.525] - run: TRUE
[17:02:28.525] - result: ‘FutureResult’
[17:02:28.525] resolved() for ‘SequentialFuture’ ... done
[17:02:28.525] resolved() for ‘SequentialFuture’ ...
[17:02:28.525] - state: ‘finished’
[17:02:28.525] - run: TRUE
[17:02:28.525] - result: ‘FutureResult’
[17:02:28.526] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:28.527] resolve() on list ...
[17:02:28.528]  recursive: 0
[17:02:28.528]  length: 6
[17:02:28.528]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:28.528] signalConditionsASAP(numeric, pos=1) ...
[17:02:28.528] - nx: 6
[17:02:28.528] - relay: TRUE
[17:02:28.528] - stdout: TRUE
[17:02:28.528] - signal: TRUE
[17:02:28.528] - resignal: FALSE
[17:02:28.528] - force: TRUE
[17:02:28.528] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.528] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.529]  - until=2
[17:02:28.529]  - relaying element #2
[17:02:28.529] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.529] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.529] signalConditionsASAP(NULL, pos=1) ... done
[17:02:28.529]  length: 5 (resolved future 1)
[17:02:28.529] resolved() for ‘SequentialFuture’ ...
[17:02:28.529] - state: ‘finished’
[17:02:28.529] - run: TRUE
[17:02:28.529] - result: ‘FutureResult’
[17:02:28.529] resolved() for ‘SequentialFuture’ ... done
[17:02:28.530] Future #2
[17:02:28.530] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:28.530] - nx: 6
[17:02:28.532] - relay: TRUE
[17:02:28.532] - stdout: TRUE
[17:02:28.532] - signal: TRUE
[17:02:28.532] - resignal: FALSE
[17:02:28.532] - force: TRUE
[17:02:28.532] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.532] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.532]  - until=2
[17:02:28.532]  - relaying element #2
[17:02:28.532] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.533] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.533] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:28.533]  length: 4 (resolved future 2)
[17:02:28.533] resolved() for ‘SequentialFuture’ ...
[17:02:28.533] - state: ‘finished’
[17:02:28.533] - run: TRUE
[17:02:28.533] - result: ‘FutureResult’
[17:02:28.533] resolved() for ‘SequentialFuture’ ... done
[17:02:28.533] Future #3
[17:02:28.533] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:28.534] - nx: 6
[17:02:28.534] - relay: TRUE
[17:02:28.534] - stdout: TRUE
[17:02:28.534] - signal: TRUE
[17:02:28.534] - resignal: FALSE
[17:02:28.534] - force: TRUE
[17:02:28.534] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.534] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.534]  - until=3
[17:02:28.534]  - relaying element #3
[17:02:28.534] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.535] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.535] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:28.535]  length: 3 (resolved future 3)
[17:02:28.535] signalConditionsASAP(NULL, pos=4) ...
[17:02:28.535] - nx: 6
[17:02:28.535] - relay: TRUE
[17:02:28.535] - stdout: TRUE
[17:02:28.535] - signal: TRUE
[17:02:28.535] - resignal: FALSE
[17:02:28.535] - force: TRUE
[17:02:28.535] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.536] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.536]  - until=5
[17:02:28.536]  - relaying element #5
[17:02:28.536] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.536] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.536] signalConditionsASAP(NULL, pos=4) ... done
[17:02:28.536]  length: 2 (resolved future 4)
[17:02:28.536] signalConditionsASAP(NULL, pos=5) ...
[17:02:28.536] - nx: 6
[17:02:28.536] - relay: TRUE
[17:02:28.536] - stdout: TRUE
[17:02:28.536] - signal: TRUE
[17:02:28.537] - resignal: FALSE
[17:02:28.537] - force: TRUE
[17:02:28.537] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.537] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.537]  - until=6
[17:02:28.537]  - relaying element #6
[17:02:28.537] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:28.537] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.537] signalConditionsASAP(NULL, pos=5) ... done
[17:02:28.537]  length: 1 (resolved future 5)
[17:02:28.537] signalConditionsASAP(numeric, pos=6) ...
[17:02:28.537] - nx: 6
[17:02:28.538] - relay: TRUE
[17:02:28.538] - stdout: TRUE
[17:02:28.538] - signal: TRUE
[17:02:28.538] - resignal: FALSE
[17:02:28.538] - force: TRUE
[17:02:28.538] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:28.538] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.538]  - until=6
[17:02:28.538] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.538] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.538] signalConditionsASAP(numeric, pos=6) ... done
[17:02:28.538]  length: 0 (resolved future 6)
[17:02:28.538] Relaying remaining futures
[17:02:28.539] signalConditionsASAP(NULL, pos=0) ...
[17:02:28.539] - nx: 6
[17:02:28.539] - relay: TRUE
[17:02:28.539] - stdout: TRUE
[17:02:28.539] - signal: TRUE
[17:02:28.539] - resignal: FALSE
[17:02:28.539] - force: TRUE
[17:02:28.539] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.539] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:28.539] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.539] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.540] signalConditionsASAP(NULL, pos=0) ... done
[17:02:28.540] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:02:28.543] getGlobalsAndPackages() ...
[17:02:28.543] Searching for globals...
[17:02:28.543] 
[17:02:28.543] Searching for globals ... DONE
[17:02:28.543] - globals: [0] <none>
[17:02:28.543] getGlobalsAndPackages() ... DONE
[17:02:28.544] run() for ‘Future’ ...
[17:02:28.544] - state: ‘created’
[17:02:28.544] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.544] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.544] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.544]   - Field: ‘label’
[17:02:28.544]   - Field: ‘local’
[17:02:28.544]   - Field: ‘owner’
[17:02:28.545]   - Field: ‘envir’
[17:02:28.545]   - Field: ‘packages’
[17:02:28.545]   - Field: ‘gc’
[17:02:28.545]   - Field: ‘conditions’
[17:02:28.545]   - Field: ‘expr’
[17:02:28.545]   - Field: ‘uuid’
[17:02:28.545]   - Field: ‘seed’
[17:02:28.545]   - Field: ‘version’
[17:02:28.545]   - Field: ‘result’
[17:02:28.545]   - Field: ‘asynchronous’
[17:02:28.545]   - Field: ‘calls’
[17:02:28.545]   - Field: ‘globals’
[17:02:28.546]   - Field: ‘stdout’
[17:02:28.546]   - Field: ‘earlySignal’
[17:02:28.546]   - Field: ‘lazy’
[17:02:28.546]   - Field: ‘state’
[17:02:28.546] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.546] - Launch lazy future ...
[17:02:28.546] Packages needed by the future expression (n = 0): <none>
[17:02:28.546] Packages needed by future strategies (n = 0): <none>
[17:02:28.547] {
[17:02:28.547]     {
[17:02:28.547]         {
[17:02:28.547]             ...future.startTime <- base::Sys.time()
[17:02:28.547]             {
[17:02:28.547]                 {
[17:02:28.547]                   {
[17:02:28.547]                     base::local({
[17:02:28.547]                       has_future <- base::requireNamespace("future", 
[17:02:28.547]                         quietly = TRUE)
[17:02:28.547]                       if (has_future) {
[17:02:28.547]                         ns <- base::getNamespace("future")
[17:02:28.547]                         version <- ns[[".package"]][["version"]]
[17:02:28.547]                         if (is.null(version)) 
[17:02:28.547]                           version <- utils::packageVersion("future")
[17:02:28.547]                       }
[17:02:28.547]                       else {
[17:02:28.547]                         version <- NULL
[17:02:28.547]                       }
[17:02:28.547]                       if (!has_future || version < "1.8.0") {
[17:02:28.547]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.547]                           "", base::R.version$version.string), 
[17:02:28.547]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.547]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.547]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.547]                             "release", "version")], collapse = " "), 
[17:02:28.547]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.547]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.547]                           info)
[17:02:28.547]                         info <- base::paste(info, collapse = "; ")
[17:02:28.547]                         if (!has_future) {
[17:02:28.547]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.547]                             info)
[17:02:28.547]                         }
[17:02:28.547]                         else {
[17:02:28.547]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.547]                             info, version)
[17:02:28.547]                         }
[17:02:28.547]                         base::stop(msg)
[17:02:28.547]                       }
[17:02:28.547]                     })
[17:02:28.547]                   }
[17:02:28.547]                   ...future.strategy.old <- future::plan("list")
[17:02:28.547]                   options(future.plan = NULL)
[17:02:28.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.547]                 }
[17:02:28.547]                 ...future.workdir <- getwd()
[17:02:28.547]             }
[17:02:28.547]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.547]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.547]         }
[17:02:28.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.547]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.547]             base::names(...future.oldOptions))
[17:02:28.547]     }
[17:02:28.547]     if (FALSE) {
[17:02:28.547]     }
[17:02:28.547]     else {
[17:02:28.547]         if (TRUE) {
[17:02:28.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.547]                 open = "w")
[17:02:28.547]         }
[17:02:28.547]         else {
[17:02:28.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.547]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.547]         }
[17:02:28.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.547]             base::sink(type = "output", split = FALSE)
[17:02:28.547]             base::close(...future.stdout)
[17:02:28.547]         }, add = TRUE)
[17:02:28.547]     }
[17:02:28.547]     ...future.frame <- base::sys.nframe()
[17:02:28.547]     ...future.conditions <- base::list()
[17:02:28.547]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.547]     if (FALSE) {
[17:02:28.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.547]     }
[17:02:28.547]     ...future.result <- base::tryCatch({
[17:02:28.547]         base::withCallingHandlers({
[17:02:28.547]             ...future.value <- base::withVisible(base::local(2))
[17:02:28.547]             future::FutureResult(value = ...future.value$value, 
[17:02:28.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.547]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.547]                     ...future.globalenv.names))
[17:02:28.547]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.547]         }, condition = base::local({
[17:02:28.547]             c <- base::c
[17:02:28.547]             inherits <- base::inherits
[17:02:28.547]             invokeRestart <- base::invokeRestart
[17:02:28.547]             length <- base::length
[17:02:28.547]             list <- base::list
[17:02:28.547]             seq.int <- base::seq.int
[17:02:28.547]             signalCondition <- base::signalCondition
[17:02:28.547]             sys.calls <- base::sys.calls
[17:02:28.547]             `[[` <- base::`[[`
[17:02:28.547]             `+` <- base::`+`
[17:02:28.547]             `<<-` <- base::`<<-`
[17:02:28.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.547]                   3L)]
[17:02:28.547]             }
[17:02:28.547]             function(cond) {
[17:02:28.547]                 is_error <- inherits(cond, "error")
[17:02:28.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.547]                   NULL)
[17:02:28.547]                 if (is_error) {
[17:02:28.547]                   sessionInformation <- function() {
[17:02:28.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.547]                       search = base::search(), system = base::Sys.info())
[17:02:28.547]                   }
[17:02:28.547]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.547]                     cond$call), session = sessionInformation(), 
[17:02:28.547]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.547]                   signalCondition(cond)
[17:02:28.547]                 }
[17:02:28.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.547]                 "immediateCondition"))) {
[17:02:28.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.547]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.547]                   if (TRUE && !signal) {
[17:02:28.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.547]                     {
[17:02:28.547]                       inherits <- base::inherits
[17:02:28.547]                       invokeRestart <- base::invokeRestart
[17:02:28.547]                       is.null <- base::is.null
[17:02:28.547]                       muffled <- FALSE
[17:02:28.547]                       if (inherits(cond, "message")) {
[17:02:28.547]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.547]                         if (muffled) 
[17:02:28.547]                           invokeRestart("muffleMessage")
[17:02:28.547]                       }
[17:02:28.547]                       else if (inherits(cond, "warning")) {
[17:02:28.547]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.547]                         if (muffled) 
[17:02:28.547]                           invokeRestart("muffleWarning")
[17:02:28.547]                       }
[17:02:28.547]                       else if (inherits(cond, "condition")) {
[17:02:28.547]                         if (!is.null(pattern)) {
[17:02:28.547]                           computeRestarts <- base::computeRestarts
[17:02:28.547]                           grepl <- base::grepl
[17:02:28.547]                           restarts <- computeRestarts(cond)
[17:02:28.547]                           for (restart in restarts) {
[17:02:28.547]                             name <- restart$name
[17:02:28.547]                             if (is.null(name)) 
[17:02:28.547]                               next
[17:02:28.547]                             if (!grepl(pattern, name)) 
[17:02:28.547]                               next
[17:02:28.547]                             invokeRestart(restart)
[17:02:28.547]                             muffled <- TRUE
[17:02:28.547]                             break
[17:02:28.547]                           }
[17:02:28.547]                         }
[17:02:28.547]                       }
[17:02:28.547]                       invisible(muffled)
[17:02:28.547]                     }
[17:02:28.547]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.547]                   }
[17:02:28.547]                 }
[17:02:28.547]                 else {
[17:02:28.547]                   if (TRUE) {
[17:02:28.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.547]                     {
[17:02:28.547]                       inherits <- base::inherits
[17:02:28.547]                       invokeRestart <- base::invokeRestart
[17:02:28.547]                       is.null <- base::is.null
[17:02:28.547]                       muffled <- FALSE
[17:02:28.547]                       if (inherits(cond, "message")) {
[17:02:28.547]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.547]                         if (muffled) 
[17:02:28.547]                           invokeRestart("muffleMessage")
[17:02:28.547]                       }
[17:02:28.547]                       else if (inherits(cond, "warning")) {
[17:02:28.547]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.547]                         if (muffled) 
[17:02:28.547]                           invokeRestart("muffleWarning")
[17:02:28.547]                       }
[17:02:28.547]                       else if (inherits(cond, "condition")) {
[17:02:28.547]                         if (!is.null(pattern)) {
[17:02:28.547]                           computeRestarts <- base::computeRestarts
[17:02:28.547]                           grepl <- base::grepl
[17:02:28.547]                           restarts <- computeRestarts(cond)
[17:02:28.547]                           for (restart in restarts) {
[17:02:28.547]                             name <- restart$name
[17:02:28.547]                             if (is.null(name)) 
[17:02:28.547]                               next
[17:02:28.547]                             if (!grepl(pattern, name)) 
[17:02:28.547]                               next
[17:02:28.547]                             invokeRestart(restart)
[17:02:28.547]                             muffled <- TRUE
[17:02:28.547]                             break
[17:02:28.547]                           }
[17:02:28.547]                         }
[17:02:28.547]                       }
[17:02:28.547]                       invisible(muffled)
[17:02:28.547]                     }
[17:02:28.547]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.547]                   }
[17:02:28.547]                 }
[17:02:28.547]             }
[17:02:28.547]         }))
[17:02:28.547]     }, error = function(ex) {
[17:02:28.547]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.547]                 ...future.rng), started = ...future.startTime, 
[17:02:28.547]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.547]             version = "1.8"), class = "FutureResult")
[17:02:28.547]     }, finally = {
[17:02:28.547]         if (!identical(...future.workdir, getwd())) 
[17:02:28.547]             setwd(...future.workdir)
[17:02:28.547]         {
[17:02:28.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.547]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.547]             }
[17:02:28.547]             base::options(...future.oldOptions)
[17:02:28.547]             if (.Platform$OS.type == "windows") {
[17:02:28.547]                 old_names <- names(...future.oldEnvVars)
[17:02:28.547]                 envs <- base::Sys.getenv()
[17:02:28.547]                 names <- names(envs)
[17:02:28.547]                 common <- intersect(names, old_names)
[17:02:28.547]                 added <- setdiff(names, old_names)
[17:02:28.547]                 removed <- setdiff(old_names, names)
[17:02:28.547]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.547]                   envs[common]]
[17:02:28.547]                 NAMES <- toupper(changed)
[17:02:28.547]                 args <- list()
[17:02:28.547]                 for (kk in seq_along(NAMES)) {
[17:02:28.547]                   name <- changed[[kk]]
[17:02:28.547]                   NAME <- NAMES[[kk]]
[17:02:28.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.547]                     next
[17:02:28.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.547]                 }
[17:02:28.547]                 NAMES <- toupper(added)
[17:02:28.547]                 for (kk in seq_along(NAMES)) {
[17:02:28.547]                   name <- added[[kk]]
[17:02:28.547]                   NAME <- NAMES[[kk]]
[17:02:28.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.547]                     next
[17:02:28.547]                   args[[name]] <- ""
[17:02:28.547]                 }
[17:02:28.547]                 NAMES <- toupper(removed)
[17:02:28.547]                 for (kk in seq_along(NAMES)) {
[17:02:28.547]                   name <- removed[[kk]]
[17:02:28.547]                   NAME <- NAMES[[kk]]
[17:02:28.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.547]                     next
[17:02:28.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.547]                 }
[17:02:28.547]                 if (length(args) > 0) 
[17:02:28.547]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.547]             }
[17:02:28.547]             else {
[17:02:28.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.547]             }
[17:02:28.547]             {
[17:02:28.547]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.547]                   0L) {
[17:02:28.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.547]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.547]                   base::options(opts)
[17:02:28.547]                 }
[17:02:28.547]                 {
[17:02:28.547]                   {
[17:02:28.547]                     NULL
[17:02:28.547]                     RNGkind("Mersenne-Twister")
[17:02:28.547]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.547]                       inherits = FALSE)
[17:02:28.547]                   }
[17:02:28.547]                   options(future.plan = NULL)
[17:02:28.547]                   if (is.na(NA_character_)) 
[17:02:28.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.547]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.547]                     .init = FALSE)
[17:02:28.547]                 }
[17:02:28.547]             }
[17:02:28.547]         }
[17:02:28.547]     })
[17:02:28.547]     if (TRUE) {
[17:02:28.547]         base::sink(type = "output", split = FALSE)
[17:02:28.547]         if (TRUE) {
[17:02:28.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.547]         }
[17:02:28.547]         else {
[17:02:28.547]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.547]         }
[17:02:28.547]         base::close(...future.stdout)
[17:02:28.547]         ...future.stdout <- NULL
[17:02:28.547]     }
[17:02:28.547]     ...future.result$conditions <- ...future.conditions
[17:02:28.547]     ...future.result$finished <- base::Sys.time()
[17:02:28.547]     ...future.result
[17:02:28.547] }
[17:02:28.548] plan(): Setting new future strategy stack:
[17:02:28.548] List of future strategies:
[17:02:28.548] 1. sequential:
[17:02:28.548]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.548]    - tweaked: FALSE
[17:02:28.548]    - call: NULL
[17:02:28.549] plan(): nbrOfWorkers() = 1
[17:02:28.550] plan(): Setting new future strategy stack:
[17:02:28.550] List of future strategies:
[17:02:28.550] 1. sequential:
[17:02:28.550]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.550]    - tweaked: FALSE
[17:02:28.550]    - call: plan(strategy)
[17:02:28.550] plan(): nbrOfWorkers() = 1
[17:02:28.550] SequentialFuture started (and completed)
[17:02:28.550] - Launch lazy future ... done
[17:02:28.551] run() for ‘SequentialFuture’ ... done
[17:02:28.551] getGlobalsAndPackages() ...
[17:02:28.551] Searching for globals...
[17:02:28.551] 
[17:02:28.551] Searching for globals ... DONE
[17:02:28.551] - globals: [0] <none>
[17:02:28.551] getGlobalsAndPackages() ... DONE
[17:02:28.552] run() for ‘Future’ ...
[17:02:28.552] - state: ‘created’
[17:02:28.552] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.552] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.552] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.552]   - Field: ‘label’
[17:02:28.552]   - Field: ‘local’
[17:02:28.552]   - Field: ‘owner’
[17:02:28.552]   - Field: ‘envir’
[17:02:28.553]   - Field: ‘packages’
[17:02:28.553]   - Field: ‘gc’
[17:02:28.553]   - Field: ‘conditions’
[17:02:28.553]   - Field: ‘expr’
[17:02:28.553]   - Field: ‘uuid’
[17:02:28.553]   - Field: ‘seed’
[17:02:28.553]   - Field: ‘version’
[17:02:28.553]   - Field: ‘result’
[17:02:28.553]   - Field: ‘asynchronous’
[17:02:28.553]   - Field: ‘calls’
[17:02:28.553]   - Field: ‘globals’
[17:02:28.554]   - Field: ‘stdout’
[17:02:28.554]   - Field: ‘earlySignal’
[17:02:28.554]   - Field: ‘lazy’
[17:02:28.554]   - Field: ‘state’
[17:02:28.554] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.554] - Launch lazy future ...
[17:02:28.554] Packages needed by the future expression (n = 0): <none>
[17:02:28.554] Packages needed by future strategies (n = 0): <none>
[17:02:28.555] {
[17:02:28.555]     {
[17:02:28.555]         {
[17:02:28.555]             ...future.startTime <- base::Sys.time()
[17:02:28.555]             {
[17:02:28.555]                 {
[17:02:28.555]                   {
[17:02:28.555]                     base::local({
[17:02:28.555]                       has_future <- base::requireNamespace("future", 
[17:02:28.555]                         quietly = TRUE)
[17:02:28.555]                       if (has_future) {
[17:02:28.555]                         ns <- base::getNamespace("future")
[17:02:28.555]                         version <- ns[[".package"]][["version"]]
[17:02:28.555]                         if (is.null(version)) 
[17:02:28.555]                           version <- utils::packageVersion("future")
[17:02:28.555]                       }
[17:02:28.555]                       else {
[17:02:28.555]                         version <- NULL
[17:02:28.555]                       }
[17:02:28.555]                       if (!has_future || version < "1.8.0") {
[17:02:28.555]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.555]                           "", base::R.version$version.string), 
[17:02:28.555]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.555]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.555]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.555]                             "release", "version")], collapse = " "), 
[17:02:28.555]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.555]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.555]                           info)
[17:02:28.555]                         info <- base::paste(info, collapse = "; ")
[17:02:28.555]                         if (!has_future) {
[17:02:28.555]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.555]                             info)
[17:02:28.555]                         }
[17:02:28.555]                         else {
[17:02:28.555]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.555]                             info, version)
[17:02:28.555]                         }
[17:02:28.555]                         base::stop(msg)
[17:02:28.555]                       }
[17:02:28.555]                     })
[17:02:28.555]                   }
[17:02:28.555]                   ...future.strategy.old <- future::plan("list")
[17:02:28.555]                   options(future.plan = NULL)
[17:02:28.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.555]                 }
[17:02:28.555]                 ...future.workdir <- getwd()
[17:02:28.555]             }
[17:02:28.555]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.555]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.555]         }
[17:02:28.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.555]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.555]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.555]             base::names(...future.oldOptions))
[17:02:28.555]     }
[17:02:28.555]     if (FALSE) {
[17:02:28.555]     }
[17:02:28.555]     else {
[17:02:28.555]         if (TRUE) {
[17:02:28.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.555]                 open = "w")
[17:02:28.555]         }
[17:02:28.555]         else {
[17:02:28.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.555]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.555]         }
[17:02:28.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.555]             base::sink(type = "output", split = FALSE)
[17:02:28.555]             base::close(...future.stdout)
[17:02:28.555]         }, add = TRUE)
[17:02:28.555]     }
[17:02:28.555]     ...future.frame <- base::sys.nframe()
[17:02:28.555]     ...future.conditions <- base::list()
[17:02:28.555]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.555]     if (FALSE) {
[17:02:28.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.555]     }
[17:02:28.555]     ...future.result <- base::tryCatch({
[17:02:28.555]         base::withCallingHandlers({
[17:02:28.555]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:28.555]             future::FutureResult(value = ...future.value$value, 
[17:02:28.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.555]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.555]                     ...future.globalenv.names))
[17:02:28.555]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.555]         }, condition = base::local({
[17:02:28.555]             c <- base::c
[17:02:28.555]             inherits <- base::inherits
[17:02:28.555]             invokeRestart <- base::invokeRestart
[17:02:28.555]             length <- base::length
[17:02:28.555]             list <- base::list
[17:02:28.555]             seq.int <- base::seq.int
[17:02:28.555]             signalCondition <- base::signalCondition
[17:02:28.555]             sys.calls <- base::sys.calls
[17:02:28.555]             `[[` <- base::`[[`
[17:02:28.555]             `+` <- base::`+`
[17:02:28.555]             `<<-` <- base::`<<-`
[17:02:28.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.555]                   3L)]
[17:02:28.555]             }
[17:02:28.555]             function(cond) {
[17:02:28.555]                 is_error <- inherits(cond, "error")
[17:02:28.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.555]                   NULL)
[17:02:28.555]                 if (is_error) {
[17:02:28.555]                   sessionInformation <- function() {
[17:02:28.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.555]                       search = base::search(), system = base::Sys.info())
[17:02:28.555]                   }
[17:02:28.555]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.555]                     cond$call), session = sessionInformation(), 
[17:02:28.555]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.555]                   signalCondition(cond)
[17:02:28.555]                 }
[17:02:28.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.555]                 "immediateCondition"))) {
[17:02:28.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.555]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.555]                   if (TRUE && !signal) {
[17:02:28.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.555]                     {
[17:02:28.555]                       inherits <- base::inherits
[17:02:28.555]                       invokeRestart <- base::invokeRestart
[17:02:28.555]                       is.null <- base::is.null
[17:02:28.555]                       muffled <- FALSE
[17:02:28.555]                       if (inherits(cond, "message")) {
[17:02:28.555]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.555]                         if (muffled) 
[17:02:28.555]                           invokeRestart("muffleMessage")
[17:02:28.555]                       }
[17:02:28.555]                       else if (inherits(cond, "warning")) {
[17:02:28.555]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.555]                         if (muffled) 
[17:02:28.555]                           invokeRestart("muffleWarning")
[17:02:28.555]                       }
[17:02:28.555]                       else if (inherits(cond, "condition")) {
[17:02:28.555]                         if (!is.null(pattern)) {
[17:02:28.555]                           computeRestarts <- base::computeRestarts
[17:02:28.555]                           grepl <- base::grepl
[17:02:28.555]                           restarts <- computeRestarts(cond)
[17:02:28.555]                           for (restart in restarts) {
[17:02:28.555]                             name <- restart$name
[17:02:28.555]                             if (is.null(name)) 
[17:02:28.555]                               next
[17:02:28.555]                             if (!grepl(pattern, name)) 
[17:02:28.555]                               next
[17:02:28.555]                             invokeRestart(restart)
[17:02:28.555]                             muffled <- TRUE
[17:02:28.555]                             break
[17:02:28.555]                           }
[17:02:28.555]                         }
[17:02:28.555]                       }
[17:02:28.555]                       invisible(muffled)
[17:02:28.555]                     }
[17:02:28.555]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.555]                   }
[17:02:28.555]                 }
[17:02:28.555]                 else {
[17:02:28.555]                   if (TRUE) {
[17:02:28.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.555]                     {
[17:02:28.555]                       inherits <- base::inherits
[17:02:28.555]                       invokeRestart <- base::invokeRestart
[17:02:28.555]                       is.null <- base::is.null
[17:02:28.555]                       muffled <- FALSE
[17:02:28.555]                       if (inherits(cond, "message")) {
[17:02:28.555]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.555]                         if (muffled) 
[17:02:28.555]                           invokeRestart("muffleMessage")
[17:02:28.555]                       }
[17:02:28.555]                       else if (inherits(cond, "warning")) {
[17:02:28.555]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.555]                         if (muffled) 
[17:02:28.555]                           invokeRestart("muffleWarning")
[17:02:28.555]                       }
[17:02:28.555]                       else if (inherits(cond, "condition")) {
[17:02:28.555]                         if (!is.null(pattern)) {
[17:02:28.555]                           computeRestarts <- base::computeRestarts
[17:02:28.555]                           grepl <- base::grepl
[17:02:28.555]                           restarts <- computeRestarts(cond)
[17:02:28.555]                           for (restart in restarts) {
[17:02:28.555]                             name <- restart$name
[17:02:28.555]                             if (is.null(name)) 
[17:02:28.555]                               next
[17:02:28.555]                             if (!grepl(pattern, name)) 
[17:02:28.555]                               next
[17:02:28.555]                             invokeRestart(restart)
[17:02:28.555]                             muffled <- TRUE
[17:02:28.555]                             break
[17:02:28.555]                           }
[17:02:28.555]                         }
[17:02:28.555]                       }
[17:02:28.555]                       invisible(muffled)
[17:02:28.555]                     }
[17:02:28.555]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.555]                   }
[17:02:28.555]                 }
[17:02:28.555]             }
[17:02:28.555]         }))
[17:02:28.555]     }, error = function(ex) {
[17:02:28.555]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.555]                 ...future.rng), started = ...future.startTime, 
[17:02:28.555]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.555]             version = "1.8"), class = "FutureResult")
[17:02:28.555]     }, finally = {
[17:02:28.555]         if (!identical(...future.workdir, getwd())) 
[17:02:28.555]             setwd(...future.workdir)
[17:02:28.555]         {
[17:02:28.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.555]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.555]             }
[17:02:28.555]             base::options(...future.oldOptions)
[17:02:28.555]             if (.Platform$OS.type == "windows") {
[17:02:28.555]                 old_names <- names(...future.oldEnvVars)
[17:02:28.555]                 envs <- base::Sys.getenv()
[17:02:28.555]                 names <- names(envs)
[17:02:28.555]                 common <- intersect(names, old_names)
[17:02:28.555]                 added <- setdiff(names, old_names)
[17:02:28.555]                 removed <- setdiff(old_names, names)
[17:02:28.555]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.555]                   envs[common]]
[17:02:28.555]                 NAMES <- toupper(changed)
[17:02:28.555]                 args <- list()
[17:02:28.555]                 for (kk in seq_along(NAMES)) {
[17:02:28.555]                   name <- changed[[kk]]
[17:02:28.555]                   NAME <- NAMES[[kk]]
[17:02:28.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.555]                     next
[17:02:28.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.555]                 }
[17:02:28.555]                 NAMES <- toupper(added)
[17:02:28.555]                 for (kk in seq_along(NAMES)) {
[17:02:28.555]                   name <- added[[kk]]
[17:02:28.555]                   NAME <- NAMES[[kk]]
[17:02:28.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.555]                     next
[17:02:28.555]                   args[[name]] <- ""
[17:02:28.555]                 }
[17:02:28.555]                 NAMES <- toupper(removed)
[17:02:28.555]                 for (kk in seq_along(NAMES)) {
[17:02:28.555]                   name <- removed[[kk]]
[17:02:28.555]                   NAME <- NAMES[[kk]]
[17:02:28.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.555]                     next
[17:02:28.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.555]                 }
[17:02:28.555]                 if (length(args) > 0) 
[17:02:28.555]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.555]             }
[17:02:28.555]             else {
[17:02:28.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.555]             }
[17:02:28.555]             {
[17:02:28.555]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.555]                   0L) {
[17:02:28.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.555]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.555]                   base::options(opts)
[17:02:28.555]                 }
[17:02:28.555]                 {
[17:02:28.555]                   {
[17:02:28.555]                     NULL
[17:02:28.555]                     RNGkind("Mersenne-Twister")
[17:02:28.555]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.555]                       inherits = FALSE)
[17:02:28.555]                   }
[17:02:28.555]                   options(future.plan = NULL)
[17:02:28.555]                   if (is.na(NA_character_)) 
[17:02:28.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.555]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.555]                     .init = FALSE)
[17:02:28.555]                 }
[17:02:28.555]             }
[17:02:28.555]         }
[17:02:28.555]     })
[17:02:28.555]     if (TRUE) {
[17:02:28.555]         base::sink(type = "output", split = FALSE)
[17:02:28.555]         if (TRUE) {
[17:02:28.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.555]         }
[17:02:28.555]         else {
[17:02:28.555]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.555]         }
[17:02:28.555]         base::close(...future.stdout)
[17:02:28.555]         ...future.stdout <- NULL
[17:02:28.555]     }
[17:02:28.555]     ...future.result$conditions <- ...future.conditions
[17:02:28.555]     ...future.result$finished <- base::Sys.time()
[17:02:28.555]     ...future.result
[17:02:28.555] }
[17:02:28.556] plan(): Setting new future strategy stack:
[17:02:28.556] List of future strategies:
[17:02:28.556] 1. sequential:
[17:02:28.556]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.556]    - tweaked: FALSE
[17:02:28.556]    - call: NULL
[17:02:28.557] plan(): nbrOfWorkers() = 1
[17:02:28.558] plan(): Setting new future strategy stack:
[17:02:28.558] List of future strategies:
[17:02:28.558] 1. sequential:
[17:02:28.558]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.558]    - tweaked: FALSE
[17:02:28.558]    - call: plan(strategy)
[17:02:28.558] plan(): nbrOfWorkers() = 1
[17:02:28.558] SequentialFuture started (and completed)
[17:02:28.558] - Launch lazy future ... done
[17:02:28.558] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c7492f0390> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c74975d828> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c7492f0390> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c74975d828> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:02:28.565] resolved() for ‘SequentialFuture’ ...
[17:02:28.565] - state: ‘finished’
[17:02:28.565] - run: TRUE
[17:02:28.565] - result: ‘FutureResult’
[17:02:28.565] resolved() for ‘SequentialFuture’ ... done
[17:02:28.565] resolved() for ‘SequentialFuture’ ...
[17:02:28.566] - state: ‘finished’
[17:02:28.566] - run: TRUE
[17:02:28.566] - result: ‘FutureResult’
[17:02:28.566] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:28.567] resolve() on list ...
[17:02:28.567]  recursive: 0
[17:02:28.567]  length: 6
[17:02:28.568]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:28.568] signalConditionsASAP(numeric, pos=1) ...
[17:02:28.568] - nx: 6
[17:02:28.568] - relay: TRUE
[17:02:28.568] - stdout: TRUE
[17:02:28.568] - signal: TRUE
[17:02:28.568] - resignal: FALSE
[17:02:28.568] - force: TRUE
[17:02:28.568] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.568] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.568]  - until=2
[17:02:28.569]  - relaying element #2
[17:02:28.569] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.569] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.569] signalConditionsASAP(NULL, pos=1) ... done
[17:02:28.569]  length: 5 (resolved future 1)
[17:02:28.569] resolved() for ‘SequentialFuture’ ...
[17:02:28.569] - state: ‘finished’
[17:02:28.569] - run: TRUE
[17:02:28.569] - result: ‘FutureResult’
[17:02:28.569] resolved() for ‘SequentialFuture’ ... done
[17:02:28.569] Future #2
[17:02:28.570] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:28.570] - nx: 6
[17:02:28.570] - relay: TRUE
[17:02:28.570] - stdout: TRUE
[17:02:28.570] - signal: TRUE
[17:02:28.570] - resignal: FALSE
[17:02:28.570] - force: TRUE
[17:02:28.570] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.570] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.570]  - until=2
[17:02:28.570]  - relaying element #2
[17:02:28.571] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.571] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.571] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:28.571]  length: 4 (resolved future 2)
[17:02:28.571] resolved() for ‘SequentialFuture’ ...
[17:02:28.571] - state: ‘finished’
[17:02:28.571] - run: TRUE
[17:02:28.571] - result: ‘FutureResult’
[17:02:28.571] resolved() for ‘SequentialFuture’ ... done
[17:02:28.571] Future #3
[17:02:28.572] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:28.572] - nx: 6
[17:02:28.572] - relay: TRUE
[17:02:28.572] - stdout: TRUE
[17:02:28.572] - signal: TRUE
[17:02:28.572] - resignal: FALSE
[17:02:28.572] - force: TRUE
[17:02:28.572] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.572] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.572]  - until=3
[17:02:28.572]  - relaying element #3
[17:02:28.573] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.573] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.573] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:28.573]  length: 3 (resolved future 3)
[17:02:28.573] signalConditionsASAP(NULL, pos=4) ...
[17:02:28.573] - nx: 6
[17:02:28.573] - relay: TRUE
[17:02:28.573] - stdout: TRUE
[17:02:28.573] - signal: TRUE
[17:02:28.573] - resignal: FALSE
[17:02:28.573] - force: TRUE
[17:02:28.573] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.574] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.574]  - until=5
[17:02:28.574]  - relaying element #5
[17:02:28.574] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.574] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.574] signalConditionsASAP(NULL, pos=4) ... done
[17:02:28.574]  length: 2 (resolved future 4)
[17:02:28.574] signalConditionsASAP(NULL, pos=5) ...
[17:02:28.574] - nx: 6
[17:02:28.574] - relay: TRUE
[17:02:28.574] - stdout: TRUE
[17:02:28.575] - signal: TRUE
[17:02:28.575] - resignal: FALSE
[17:02:28.575] - force: TRUE
[17:02:28.575] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.575] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.575]  - until=6
[17:02:28.575]  - relaying element #6
[17:02:28.575] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:28.575] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.575] signalConditionsASAP(NULL, pos=5) ... done
[17:02:28.575]  length: 1 (resolved future 5)
[17:02:28.575] signalConditionsASAP(numeric, pos=6) ...
[17:02:28.576] - nx: 6
[17:02:28.576] - relay: TRUE
[17:02:28.576] - stdout: TRUE
[17:02:28.576] - signal: TRUE
[17:02:28.576] - resignal: FALSE
[17:02:28.576] - force: TRUE
[17:02:28.576] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:28.576] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.576]  - until=6
[17:02:28.576] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.576] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.576] signalConditionsASAP(numeric, pos=6) ... done
[17:02:28.577]  length: 0 (resolved future 6)
[17:02:28.577] Relaying remaining futures
[17:02:28.577] signalConditionsASAP(NULL, pos=0) ...
[17:02:28.577] - nx: 6
[17:02:28.577] - relay: TRUE
[17:02:28.577] - stdout: TRUE
[17:02:28.577] - signal: TRUE
[17:02:28.577] - resignal: FALSE
[17:02:28.577] - force: TRUE
[17:02:28.577] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.577] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:28.577] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.578] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.578] signalConditionsASAP(NULL, pos=0) ... done
[17:02:28.578] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:02:28.581] getGlobalsAndPackages() ...
[17:02:28.581] Searching for globals...
[17:02:28.581] 
[17:02:28.582] Searching for globals ... DONE
[17:02:28.582] - globals: [0] <none>
[17:02:28.582] getGlobalsAndPackages() ... DONE
[17:02:28.582] run() for ‘Future’ ...
[17:02:28.582] - state: ‘created’
[17:02:28.582] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.583] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.583] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.583]   - Field: ‘label’
[17:02:28.583]   - Field: ‘local’
[17:02:28.583]   - Field: ‘owner’
[17:02:28.583]   - Field: ‘envir’
[17:02:28.583]   - Field: ‘packages’
[17:02:28.583]   - Field: ‘gc’
[17:02:28.583]   - Field: ‘conditions’
[17:02:28.583]   - Field: ‘expr’
[17:02:28.584]   - Field: ‘uuid’
[17:02:28.584]   - Field: ‘seed’
[17:02:28.584]   - Field: ‘version’
[17:02:28.584]   - Field: ‘result’
[17:02:28.584]   - Field: ‘asynchronous’
[17:02:28.584]   - Field: ‘calls’
[17:02:28.584]   - Field: ‘globals’
[17:02:28.584]   - Field: ‘stdout’
[17:02:28.584]   - Field: ‘earlySignal’
[17:02:28.584]   - Field: ‘lazy’
[17:02:28.585]   - Field: ‘state’
[17:02:28.585] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.585] - Launch lazy future ...
[17:02:28.585] Packages needed by the future expression (n = 0): <none>
[17:02:28.585] Packages needed by future strategies (n = 0): <none>
[17:02:28.585] {
[17:02:28.585]     {
[17:02:28.585]         {
[17:02:28.585]             ...future.startTime <- base::Sys.time()
[17:02:28.585]             {
[17:02:28.585]                 {
[17:02:28.585]                   {
[17:02:28.585]                     base::local({
[17:02:28.585]                       has_future <- base::requireNamespace("future", 
[17:02:28.585]                         quietly = TRUE)
[17:02:28.585]                       if (has_future) {
[17:02:28.585]                         ns <- base::getNamespace("future")
[17:02:28.585]                         version <- ns[[".package"]][["version"]]
[17:02:28.585]                         if (is.null(version)) 
[17:02:28.585]                           version <- utils::packageVersion("future")
[17:02:28.585]                       }
[17:02:28.585]                       else {
[17:02:28.585]                         version <- NULL
[17:02:28.585]                       }
[17:02:28.585]                       if (!has_future || version < "1.8.0") {
[17:02:28.585]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.585]                           "", base::R.version$version.string), 
[17:02:28.585]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.585]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.585]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.585]                             "release", "version")], collapse = " "), 
[17:02:28.585]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.585]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.585]                           info)
[17:02:28.585]                         info <- base::paste(info, collapse = "; ")
[17:02:28.585]                         if (!has_future) {
[17:02:28.585]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.585]                             info)
[17:02:28.585]                         }
[17:02:28.585]                         else {
[17:02:28.585]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.585]                             info, version)
[17:02:28.585]                         }
[17:02:28.585]                         base::stop(msg)
[17:02:28.585]                       }
[17:02:28.585]                     })
[17:02:28.585]                   }
[17:02:28.585]                   ...future.strategy.old <- future::plan("list")
[17:02:28.585]                   options(future.plan = NULL)
[17:02:28.585]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.585]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.585]                 }
[17:02:28.585]                 ...future.workdir <- getwd()
[17:02:28.585]             }
[17:02:28.585]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.585]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.585]         }
[17:02:28.585]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.585]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.585]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.585]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.585]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.585]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.585]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.585]             base::names(...future.oldOptions))
[17:02:28.585]     }
[17:02:28.585]     if (FALSE) {
[17:02:28.585]     }
[17:02:28.585]     else {
[17:02:28.585]         if (TRUE) {
[17:02:28.585]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.585]                 open = "w")
[17:02:28.585]         }
[17:02:28.585]         else {
[17:02:28.585]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.585]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.585]         }
[17:02:28.585]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.585]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.585]             base::sink(type = "output", split = FALSE)
[17:02:28.585]             base::close(...future.stdout)
[17:02:28.585]         }, add = TRUE)
[17:02:28.585]     }
[17:02:28.585]     ...future.frame <- base::sys.nframe()
[17:02:28.585]     ...future.conditions <- base::list()
[17:02:28.585]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.585]     if (FALSE) {
[17:02:28.585]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.585]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.585]     }
[17:02:28.585]     ...future.result <- base::tryCatch({
[17:02:28.585]         base::withCallingHandlers({
[17:02:28.585]             ...future.value <- base::withVisible(base::local(2))
[17:02:28.585]             future::FutureResult(value = ...future.value$value, 
[17:02:28.585]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.585]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.585]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.585]                     ...future.globalenv.names))
[17:02:28.585]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.585]         }, condition = base::local({
[17:02:28.585]             c <- base::c
[17:02:28.585]             inherits <- base::inherits
[17:02:28.585]             invokeRestart <- base::invokeRestart
[17:02:28.585]             length <- base::length
[17:02:28.585]             list <- base::list
[17:02:28.585]             seq.int <- base::seq.int
[17:02:28.585]             signalCondition <- base::signalCondition
[17:02:28.585]             sys.calls <- base::sys.calls
[17:02:28.585]             `[[` <- base::`[[`
[17:02:28.585]             `+` <- base::`+`
[17:02:28.585]             `<<-` <- base::`<<-`
[17:02:28.585]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.585]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.585]                   3L)]
[17:02:28.585]             }
[17:02:28.585]             function(cond) {
[17:02:28.585]                 is_error <- inherits(cond, "error")
[17:02:28.585]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.585]                   NULL)
[17:02:28.585]                 if (is_error) {
[17:02:28.585]                   sessionInformation <- function() {
[17:02:28.585]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.585]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.585]                       search = base::search(), system = base::Sys.info())
[17:02:28.585]                   }
[17:02:28.585]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.585]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.585]                     cond$call), session = sessionInformation(), 
[17:02:28.585]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.585]                   signalCondition(cond)
[17:02:28.585]                 }
[17:02:28.585]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.585]                 "immediateCondition"))) {
[17:02:28.585]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.585]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.585]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.585]                   if (TRUE && !signal) {
[17:02:28.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.585]                     {
[17:02:28.585]                       inherits <- base::inherits
[17:02:28.585]                       invokeRestart <- base::invokeRestart
[17:02:28.585]                       is.null <- base::is.null
[17:02:28.585]                       muffled <- FALSE
[17:02:28.585]                       if (inherits(cond, "message")) {
[17:02:28.585]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.585]                         if (muffled) 
[17:02:28.585]                           invokeRestart("muffleMessage")
[17:02:28.585]                       }
[17:02:28.585]                       else if (inherits(cond, "warning")) {
[17:02:28.585]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.585]                         if (muffled) 
[17:02:28.585]                           invokeRestart("muffleWarning")
[17:02:28.585]                       }
[17:02:28.585]                       else if (inherits(cond, "condition")) {
[17:02:28.585]                         if (!is.null(pattern)) {
[17:02:28.585]                           computeRestarts <- base::computeRestarts
[17:02:28.585]                           grepl <- base::grepl
[17:02:28.585]                           restarts <- computeRestarts(cond)
[17:02:28.585]                           for (restart in restarts) {
[17:02:28.585]                             name <- restart$name
[17:02:28.585]                             if (is.null(name)) 
[17:02:28.585]                               next
[17:02:28.585]                             if (!grepl(pattern, name)) 
[17:02:28.585]                               next
[17:02:28.585]                             invokeRestart(restart)
[17:02:28.585]                             muffled <- TRUE
[17:02:28.585]                             break
[17:02:28.585]                           }
[17:02:28.585]                         }
[17:02:28.585]                       }
[17:02:28.585]                       invisible(muffled)
[17:02:28.585]                     }
[17:02:28.585]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.585]                   }
[17:02:28.585]                 }
[17:02:28.585]                 else {
[17:02:28.585]                   if (TRUE) {
[17:02:28.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.585]                     {
[17:02:28.585]                       inherits <- base::inherits
[17:02:28.585]                       invokeRestart <- base::invokeRestart
[17:02:28.585]                       is.null <- base::is.null
[17:02:28.585]                       muffled <- FALSE
[17:02:28.585]                       if (inherits(cond, "message")) {
[17:02:28.585]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.585]                         if (muffled) 
[17:02:28.585]                           invokeRestart("muffleMessage")
[17:02:28.585]                       }
[17:02:28.585]                       else if (inherits(cond, "warning")) {
[17:02:28.585]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.585]                         if (muffled) 
[17:02:28.585]                           invokeRestart("muffleWarning")
[17:02:28.585]                       }
[17:02:28.585]                       else if (inherits(cond, "condition")) {
[17:02:28.585]                         if (!is.null(pattern)) {
[17:02:28.585]                           computeRestarts <- base::computeRestarts
[17:02:28.585]                           grepl <- base::grepl
[17:02:28.585]                           restarts <- computeRestarts(cond)
[17:02:28.585]                           for (restart in restarts) {
[17:02:28.585]                             name <- restart$name
[17:02:28.585]                             if (is.null(name)) 
[17:02:28.585]                               next
[17:02:28.585]                             if (!grepl(pattern, name)) 
[17:02:28.585]                               next
[17:02:28.585]                             invokeRestart(restart)
[17:02:28.585]                             muffled <- TRUE
[17:02:28.585]                             break
[17:02:28.585]                           }
[17:02:28.585]                         }
[17:02:28.585]                       }
[17:02:28.585]                       invisible(muffled)
[17:02:28.585]                     }
[17:02:28.585]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.585]                   }
[17:02:28.585]                 }
[17:02:28.585]             }
[17:02:28.585]         }))
[17:02:28.585]     }, error = function(ex) {
[17:02:28.585]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.585]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.585]                 ...future.rng), started = ...future.startTime, 
[17:02:28.585]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.585]             version = "1.8"), class = "FutureResult")
[17:02:28.585]     }, finally = {
[17:02:28.585]         if (!identical(...future.workdir, getwd())) 
[17:02:28.585]             setwd(...future.workdir)
[17:02:28.585]         {
[17:02:28.585]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.585]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.585]             }
[17:02:28.585]             base::options(...future.oldOptions)
[17:02:28.585]             if (.Platform$OS.type == "windows") {
[17:02:28.585]                 old_names <- names(...future.oldEnvVars)
[17:02:28.585]                 envs <- base::Sys.getenv()
[17:02:28.585]                 names <- names(envs)
[17:02:28.585]                 common <- intersect(names, old_names)
[17:02:28.585]                 added <- setdiff(names, old_names)
[17:02:28.585]                 removed <- setdiff(old_names, names)
[17:02:28.585]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.585]                   envs[common]]
[17:02:28.585]                 NAMES <- toupper(changed)
[17:02:28.585]                 args <- list()
[17:02:28.585]                 for (kk in seq_along(NAMES)) {
[17:02:28.585]                   name <- changed[[kk]]
[17:02:28.585]                   NAME <- NAMES[[kk]]
[17:02:28.585]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.585]                     next
[17:02:28.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.585]                 }
[17:02:28.585]                 NAMES <- toupper(added)
[17:02:28.585]                 for (kk in seq_along(NAMES)) {
[17:02:28.585]                   name <- added[[kk]]
[17:02:28.585]                   NAME <- NAMES[[kk]]
[17:02:28.585]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.585]                     next
[17:02:28.585]                   args[[name]] <- ""
[17:02:28.585]                 }
[17:02:28.585]                 NAMES <- toupper(removed)
[17:02:28.585]                 for (kk in seq_along(NAMES)) {
[17:02:28.585]                   name <- removed[[kk]]
[17:02:28.585]                   NAME <- NAMES[[kk]]
[17:02:28.585]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.585]                     next
[17:02:28.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.585]                 }
[17:02:28.585]                 if (length(args) > 0) 
[17:02:28.585]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.585]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.585]             }
[17:02:28.585]             else {
[17:02:28.585]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.585]             }
[17:02:28.585]             {
[17:02:28.585]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.585]                   0L) {
[17:02:28.585]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.585]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.585]                   base::options(opts)
[17:02:28.585]                 }
[17:02:28.585]                 {
[17:02:28.585]                   {
[17:02:28.585]                     NULL
[17:02:28.585]                     RNGkind("Mersenne-Twister")
[17:02:28.585]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.585]                       inherits = FALSE)
[17:02:28.585]                   }
[17:02:28.585]                   options(future.plan = NULL)
[17:02:28.585]                   if (is.na(NA_character_)) 
[17:02:28.585]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.585]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.585]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.585]                     .init = FALSE)
[17:02:28.585]                 }
[17:02:28.585]             }
[17:02:28.585]         }
[17:02:28.585]     })
[17:02:28.585]     if (TRUE) {
[17:02:28.585]         base::sink(type = "output", split = FALSE)
[17:02:28.585]         if (TRUE) {
[17:02:28.585]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.585]         }
[17:02:28.585]         else {
[17:02:28.585]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.585]         }
[17:02:28.585]         base::close(...future.stdout)
[17:02:28.585]         ...future.stdout <- NULL
[17:02:28.585]     }
[17:02:28.585]     ...future.result$conditions <- ...future.conditions
[17:02:28.585]     ...future.result$finished <- base::Sys.time()
[17:02:28.585]     ...future.result
[17:02:28.585] }
[17:02:28.587] plan(): Setting new future strategy stack:
[17:02:28.587] List of future strategies:
[17:02:28.587] 1. sequential:
[17:02:28.587]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.587]    - tweaked: FALSE
[17:02:28.587]    - call: NULL
[17:02:28.588] plan(): nbrOfWorkers() = 1
[17:02:28.589] plan(): Setting new future strategy stack:
[17:02:28.589] List of future strategies:
[17:02:28.589] 1. sequential:
[17:02:28.589]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.589]    - tweaked: FALSE
[17:02:28.589]    - call: plan(strategy)
[17:02:28.589] plan(): nbrOfWorkers() = 1
[17:02:28.589] SequentialFuture started (and completed)
[17:02:28.589] - Launch lazy future ... done
[17:02:28.589] run() for ‘SequentialFuture’ ... done
[17:02:28.590] getGlobalsAndPackages() ...
[17:02:28.590] Searching for globals...
[17:02:28.590] 
[17:02:28.590] Searching for globals ... DONE
[17:02:28.590] - globals: [0] <none>
[17:02:28.592] getGlobalsAndPackages() ... DONE
[17:02:28.592] run() for ‘Future’ ...
[17:02:28.593] - state: ‘created’
[17:02:28.593] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.593] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.593] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.593]   - Field: ‘label’
[17:02:28.593]   - Field: ‘local’
[17:02:28.593]   - Field: ‘owner’
[17:02:28.593]   - Field: ‘envir’
[17:02:28.594]   - Field: ‘packages’
[17:02:28.594]   - Field: ‘gc’
[17:02:28.594]   - Field: ‘conditions’
[17:02:28.594]   - Field: ‘expr’
[17:02:28.594]   - Field: ‘uuid’
[17:02:28.594]   - Field: ‘seed’
[17:02:28.594]   - Field: ‘version’
[17:02:28.594]   - Field: ‘result’
[17:02:28.594]   - Field: ‘asynchronous’
[17:02:28.594]   - Field: ‘calls’
[17:02:28.595]   - Field: ‘globals’
[17:02:28.595]   - Field: ‘stdout’
[17:02:28.595]   - Field: ‘earlySignal’
[17:02:28.595]   - Field: ‘lazy’
[17:02:28.595]   - Field: ‘state’
[17:02:28.595] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.595] - Launch lazy future ...
[17:02:28.595] Packages needed by the future expression (n = 0): <none>
[17:02:28.595] Packages needed by future strategies (n = 0): <none>
[17:02:28.596] {
[17:02:28.596]     {
[17:02:28.596]         {
[17:02:28.596]             ...future.startTime <- base::Sys.time()
[17:02:28.596]             {
[17:02:28.596]                 {
[17:02:28.596]                   {
[17:02:28.596]                     base::local({
[17:02:28.596]                       has_future <- base::requireNamespace("future", 
[17:02:28.596]                         quietly = TRUE)
[17:02:28.596]                       if (has_future) {
[17:02:28.596]                         ns <- base::getNamespace("future")
[17:02:28.596]                         version <- ns[[".package"]][["version"]]
[17:02:28.596]                         if (is.null(version)) 
[17:02:28.596]                           version <- utils::packageVersion("future")
[17:02:28.596]                       }
[17:02:28.596]                       else {
[17:02:28.596]                         version <- NULL
[17:02:28.596]                       }
[17:02:28.596]                       if (!has_future || version < "1.8.0") {
[17:02:28.596]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.596]                           "", base::R.version$version.string), 
[17:02:28.596]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.596]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.596]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.596]                             "release", "version")], collapse = " "), 
[17:02:28.596]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.596]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.596]                           info)
[17:02:28.596]                         info <- base::paste(info, collapse = "; ")
[17:02:28.596]                         if (!has_future) {
[17:02:28.596]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.596]                             info)
[17:02:28.596]                         }
[17:02:28.596]                         else {
[17:02:28.596]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.596]                             info, version)
[17:02:28.596]                         }
[17:02:28.596]                         base::stop(msg)
[17:02:28.596]                       }
[17:02:28.596]                     })
[17:02:28.596]                   }
[17:02:28.596]                   ...future.strategy.old <- future::plan("list")
[17:02:28.596]                   options(future.plan = NULL)
[17:02:28.596]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.596]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.596]                 }
[17:02:28.596]                 ...future.workdir <- getwd()
[17:02:28.596]             }
[17:02:28.596]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.596]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.596]         }
[17:02:28.596]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.596]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.596]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.596]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.596]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.596]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.596]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.596]             base::names(...future.oldOptions))
[17:02:28.596]     }
[17:02:28.596]     if (FALSE) {
[17:02:28.596]     }
[17:02:28.596]     else {
[17:02:28.596]         if (TRUE) {
[17:02:28.596]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.596]                 open = "w")
[17:02:28.596]         }
[17:02:28.596]         else {
[17:02:28.596]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.596]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.596]         }
[17:02:28.596]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.596]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.596]             base::sink(type = "output", split = FALSE)
[17:02:28.596]             base::close(...future.stdout)
[17:02:28.596]         }, add = TRUE)
[17:02:28.596]     }
[17:02:28.596]     ...future.frame <- base::sys.nframe()
[17:02:28.596]     ...future.conditions <- base::list()
[17:02:28.596]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.596]     if (FALSE) {
[17:02:28.596]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.596]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.596]     }
[17:02:28.596]     ...future.result <- base::tryCatch({
[17:02:28.596]         base::withCallingHandlers({
[17:02:28.596]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:28.596]             future::FutureResult(value = ...future.value$value, 
[17:02:28.596]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.596]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.596]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.596]                     ...future.globalenv.names))
[17:02:28.596]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.596]         }, condition = base::local({
[17:02:28.596]             c <- base::c
[17:02:28.596]             inherits <- base::inherits
[17:02:28.596]             invokeRestart <- base::invokeRestart
[17:02:28.596]             length <- base::length
[17:02:28.596]             list <- base::list
[17:02:28.596]             seq.int <- base::seq.int
[17:02:28.596]             signalCondition <- base::signalCondition
[17:02:28.596]             sys.calls <- base::sys.calls
[17:02:28.596]             `[[` <- base::`[[`
[17:02:28.596]             `+` <- base::`+`
[17:02:28.596]             `<<-` <- base::`<<-`
[17:02:28.596]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.596]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.596]                   3L)]
[17:02:28.596]             }
[17:02:28.596]             function(cond) {
[17:02:28.596]                 is_error <- inherits(cond, "error")
[17:02:28.596]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.596]                   NULL)
[17:02:28.596]                 if (is_error) {
[17:02:28.596]                   sessionInformation <- function() {
[17:02:28.596]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.596]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.596]                       search = base::search(), system = base::Sys.info())
[17:02:28.596]                   }
[17:02:28.596]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.596]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.596]                     cond$call), session = sessionInformation(), 
[17:02:28.596]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.596]                   signalCondition(cond)
[17:02:28.596]                 }
[17:02:28.596]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.596]                 "immediateCondition"))) {
[17:02:28.596]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.596]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.596]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.596]                   if (TRUE && !signal) {
[17:02:28.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.596]                     {
[17:02:28.596]                       inherits <- base::inherits
[17:02:28.596]                       invokeRestart <- base::invokeRestart
[17:02:28.596]                       is.null <- base::is.null
[17:02:28.596]                       muffled <- FALSE
[17:02:28.596]                       if (inherits(cond, "message")) {
[17:02:28.596]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.596]                         if (muffled) 
[17:02:28.596]                           invokeRestart("muffleMessage")
[17:02:28.596]                       }
[17:02:28.596]                       else if (inherits(cond, "warning")) {
[17:02:28.596]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.596]                         if (muffled) 
[17:02:28.596]                           invokeRestart("muffleWarning")
[17:02:28.596]                       }
[17:02:28.596]                       else if (inherits(cond, "condition")) {
[17:02:28.596]                         if (!is.null(pattern)) {
[17:02:28.596]                           computeRestarts <- base::computeRestarts
[17:02:28.596]                           grepl <- base::grepl
[17:02:28.596]                           restarts <- computeRestarts(cond)
[17:02:28.596]                           for (restart in restarts) {
[17:02:28.596]                             name <- restart$name
[17:02:28.596]                             if (is.null(name)) 
[17:02:28.596]                               next
[17:02:28.596]                             if (!grepl(pattern, name)) 
[17:02:28.596]                               next
[17:02:28.596]                             invokeRestart(restart)
[17:02:28.596]                             muffled <- TRUE
[17:02:28.596]                             break
[17:02:28.596]                           }
[17:02:28.596]                         }
[17:02:28.596]                       }
[17:02:28.596]                       invisible(muffled)
[17:02:28.596]                     }
[17:02:28.596]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.596]                   }
[17:02:28.596]                 }
[17:02:28.596]                 else {
[17:02:28.596]                   if (TRUE) {
[17:02:28.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.596]                     {
[17:02:28.596]                       inherits <- base::inherits
[17:02:28.596]                       invokeRestart <- base::invokeRestart
[17:02:28.596]                       is.null <- base::is.null
[17:02:28.596]                       muffled <- FALSE
[17:02:28.596]                       if (inherits(cond, "message")) {
[17:02:28.596]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.596]                         if (muffled) 
[17:02:28.596]                           invokeRestart("muffleMessage")
[17:02:28.596]                       }
[17:02:28.596]                       else if (inherits(cond, "warning")) {
[17:02:28.596]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.596]                         if (muffled) 
[17:02:28.596]                           invokeRestart("muffleWarning")
[17:02:28.596]                       }
[17:02:28.596]                       else if (inherits(cond, "condition")) {
[17:02:28.596]                         if (!is.null(pattern)) {
[17:02:28.596]                           computeRestarts <- base::computeRestarts
[17:02:28.596]                           grepl <- base::grepl
[17:02:28.596]                           restarts <- computeRestarts(cond)
[17:02:28.596]                           for (restart in restarts) {
[17:02:28.596]                             name <- restart$name
[17:02:28.596]                             if (is.null(name)) 
[17:02:28.596]                               next
[17:02:28.596]                             if (!grepl(pattern, name)) 
[17:02:28.596]                               next
[17:02:28.596]                             invokeRestart(restart)
[17:02:28.596]                             muffled <- TRUE
[17:02:28.596]                             break
[17:02:28.596]                           }
[17:02:28.596]                         }
[17:02:28.596]                       }
[17:02:28.596]                       invisible(muffled)
[17:02:28.596]                     }
[17:02:28.596]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.596]                   }
[17:02:28.596]                 }
[17:02:28.596]             }
[17:02:28.596]         }))
[17:02:28.596]     }, error = function(ex) {
[17:02:28.596]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.596]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.596]                 ...future.rng), started = ...future.startTime, 
[17:02:28.596]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.596]             version = "1.8"), class = "FutureResult")
[17:02:28.596]     }, finally = {
[17:02:28.596]         if (!identical(...future.workdir, getwd())) 
[17:02:28.596]             setwd(...future.workdir)
[17:02:28.596]         {
[17:02:28.596]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.596]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.596]             }
[17:02:28.596]             base::options(...future.oldOptions)
[17:02:28.596]             if (.Platform$OS.type == "windows") {
[17:02:28.596]                 old_names <- names(...future.oldEnvVars)
[17:02:28.596]                 envs <- base::Sys.getenv()
[17:02:28.596]                 names <- names(envs)
[17:02:28.596]                 common <- intersect(names, old_names)
[17:02:28.596]                 added <- setdiff(names, old_names)
[17:02:28.596]                 removed <- setdiff(old_names, names)
[17:02:28.596]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.596]                   envs[common]]
[17:02:28.596]                 NAMES <- toupper(changed)
[17:02:28.596]                 args <- list()
[17:02:28.596]                 for (kk in seq_along(NAMES)) {
[17:02:28.596]                   name <- changed[[kk]]
[17:02:28.596]                   NAME <- NAMES[[kk]]
[17:02:28.596]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.596]                     next
[17:02:28.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.596]                 }
[17:02:28.596]                 NAMES <- toupper(added)
[17:02:28.596]                 for (kk in seq_along(NAMES)) {
[17:02:28.596]                   name <- added[[kk]]
[17:02:28.596]                   NAME <- NAMES[[kk]]
[17:02:28.596]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.596]                     next
[17:02:28.596]                   args[[name]] <- ""
[17:02:28.596]                 }
[17:02:28.596]                 NAMES <- toupper(removed)
[17:02:28.596]                 for (kk in seq_along(NAMES)) {
[17:02:28.596]                   name <- removed[[kk]]
[17:02:28.596]                   NAME <- NAMES[[kk]]
[17:02:28.596]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.596]                     next
[17:02:28.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.596]                 }
[17:02:28.596]                 if (length(args) > 0) 
[17:02:28.596]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.596]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.596]             }
[17:02:28.596]             else {
[17:02:28.596]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.596]             }
[17:02:28.596]             {
[17:02:28.596]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.596]                   0L) {
[17:02:28.596]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.596]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.596]                   base::options(opts)
[17:02:28.596]                 }
[17:02:28.596]                 {
[17:02:28.596]                   {
[17:02:28.596]                     NULL
[17:02:28.596]                     RNGkind("Mersenne-Twister")
[17:02:28.596]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.596]                       inherits = FALSE)
[17:02:28.596]                   }
[17:02:28.596]                   options(future.plan = NULL)
[17:02:28.596]                   if (is.na(NA_character_)) 
[17:02:28.596]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.596]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.596]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.596]                     .init = FALSE)
[17:02:28.596]                 }
[17:02:28.596]             }
[17:02:28.596]         }
[17:02:28.596]     })
[17:02:28.596]     if (TRUE) {
[17:02:28.596]         base::sink(type = "output", split = FALSE)
[17:02:28.596]         if (TRUE) {
[17:02:28.596]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.596]         }
[17:02:28.596]         else {
[17:02:28.596]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.596]         }
[17:02:28.596]         base::close(...future.stdout)
[17:02:28.596]         ...future.stdout <- NULL
[17:02:28.596]     }
[17:02:28.596]     ...future.result$conditions <- ...future.conditions
[17:02:28.596]     ...future.result$finished <- base::Sys.time()
[17:02:28.596]     ...future.result
[17:02:28.596] }
[17:02:28.598] plan(): Setting new future strategy stack:
[17:02:28.598] List of future strategies:
[17:02:28.598] 1. sequential:
[17:02:28.598]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.598]    - tweaked: FALSE
[17:02:28.598]    - call: NULL
[17:02:28.598] plan(): nbrOfWorkers() = 1
[17:02:28.599] plan(): Setting new future strategy stack:
[17:02:28.599] List of future strategies:
[17:02:28.599] 1. sequential:
[17:02:28.599]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.599]    - tweaked: FALSE
[17:02:28.599]    - call: plan(strategy)
[17:02:28.600] plan(): nbrOfWorkers() = 1
[17:02:28.600] SequentialFuture started (and completed)
[17:02:28.600] - Launch lazy future ... done
[17:02:28.600] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c74983fd68> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c7489be950> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c74983fd68> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c7489be950> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:02:28.605] resolved() for ‘SequentialFuture’ ...
[17:02:28.605] - state: ‘finished’
[17:02:28.605] - run: TRUE
[17:02:28.606] - result: ‘FutureResult’
[17:02:28.606] resolved() for ‘SequentialFuture’ ... done
[17:02:28.606] resolved() for ‘SequentialFuture’ ...
[17:02:28.606] - state: ‘finished’
[17:02:28.606] - run: TRUE
[17:02:28.606] - result: ‘FutureResult’
[17:02:28.606] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:28.608] resolve() on list ...
[17:02:28.608]  recursive: 0
[17:02:28.608]  length: 6
[17:02:28.608]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:28.608] signalConditionsASAP(numeric, pos=1) ...
[17:02:28.608] - nx: 6
[17:02:28.608] - relay: TRUE
[17:02:28.609] - stdout: TRUE
[17:02:28.609] - signal: TRUE
[17:02:28.609] - resignal: FALSE
[17:02:28.609] - force: TRUE
[17:02:28.609] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.609] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.609]  - until=2
[17:02:28.609]  - relaying element #2
[17:02:28.609] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.609] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.609] signalConditionsASAP(NULL, pos=1) ... done
[17:02:28.609]  length: 5 (resolved future 1)
[17:02:28.610] resolved() for ‘SequentialFuture’ ...
[17:02:28.610] - state: ‘finished’
[17:02:28.610] - run: TRUE
[17:02:28.610] - result: ‘FutureResult’
[17:02:28.610] resolved() for ‘SequentialFuture’ ... done
[17:02:28.610] Future #2
[17:02:28.610] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:28.610] - nx: 6
[17:02:28.610] - relay: TRUE
[17:02:28.610] - stdout: TRUE
[17:02:28.611] - signal: TRUE
[17:02:28.611] - resignal: FALSE
[17:02:28.611] - force: TRUE
[17:02:28.611] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.611] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.611]  - until=2
[17:02:28.611]  - relaying element #2
[17:02:28.611] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.611] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.611] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:28.612]  length: 4 (resolved future 2)
[17:02:28.612] resolved() for ‘SequentialFuture’ ...
[17:02:28.612] - state: ‘finished’
[17:02:28.612] - run: TRUE
[17:02:28.612] - result: ‘FutureResult’
[17:02:28.612] resolved() for ‘SequentialFuture’ ... done
[17:02:28.612] Future #3
[17:02:28.612] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:28.612] - nx: 6
[17:02:28.612] - relay: TRUE
[17:02:28.613] - stdout: TRUE
[17:02:28.613] - signal: TRUE
[17:02:28.613] - resignal: FALSE
[17:02:28.613] - force: TRUE
[17:02:28.613] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.613] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.613]  - until=3
[17:02:28.613]  - relaying element #3
[17:02:28.613] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.613] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.613] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:28.614]  length: 3 (resolved future 3)
[17:02:28.614] signalConditionsASAP(NULL, pos=4) ...
[17:02:28.614] - nx: 6
[17:02:28.614] - relay: TRUE
[17:02:28.614] - stdout: TRUE
[17:02:28.614] - signal: TRUE
[17:02:28.614] - resignal: FALSE
[17:02:28.614] - force: TRUE
[17:02:28.614] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.614] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.614]  - until=5
[17:02:28.614]  - relaying element #5
[17:02:28.615] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.615] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.615] signalConditionsASAP(NULL, pos=4) ... done
[17:02:28.615]  length: 2 (resolved future 4)
[17:02:28.615] signalConditionsASAP(NULL, pos=5) ...
[17:02:28.615] - nx: 6
[17:02:28.615] - relay: TRUE
[17:02:28.615] - stdout: TRUE
[17:02:28.615] - signal: TRUE
[17:02:28.615] - resignal: FALSE
[17:02:28.615] - force: TRUE
[17:02:28.615] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.616] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.616]  - until=6
[17:02:28.616]  - relaying element #6
[17:02:28.616] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:28.616] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.616] signalConditionsASAP(NULL, pos=5) ... done
[17:02:28.616]  length: 1 (resolved future 5)
[17:02:28.616] signalConditionsASAP(numeric, pos=6) ...
[17:02:28.616] - nx: 6
[17:02:28.616] - relay: TRUE
[17:02:28.616] - stdout: TRUE
[17:02:28.617] - signal: TRUE
[17:02:28.617] - resignal: FALSE
[17:02:28.617] - force: TRUE
[17:02:28.617] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:28.617] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.617]  - until=6
[17:02:28.617] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.617] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.617] signalConditionsASAP(numeric, pos=6) ... done
[17:02:28.617]  length: 0 (resolved future 6)
[17:02:28.617] Relaying remaining futures
[17:02:28.617] signalConditionsASAP(NULL, pos=0) ...
[17:02:28.617] - nx: 6
[17:02:28.618] - relay: TRUE
[17:02:28.618] - stdout: TRUE
[17:02:28.618] - signal: TRUE
[17:02:28.618] - resignal: FALSE
[17:02:28.618] - force: TRUE
[17:02:28.618] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.618] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:28.618] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.618] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.618] signalConditionsASAP(NULL, pos=0) ... done
[17:02:28.618] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:02:28.624] getGlobalsAndPackages() ...
[17:02:28.624] Searching for globals...
[17:02:28.624] 
[17:02:28.624] Searching for globals ... DONE
[17:02:28.625] - globals: [0] <none>
[17:02:28.625] getGlobalsAndPackages() ... DONE
[17:02:28.625] run() for ‘Future’ ...
[17:02:28.625] - state: ‘created’
[17:02:28.625] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.625] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.626] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.626]   - Field: ‘label’
[17:02:28.626]   - Field: ‘local’
[17:02:28.626]   - Field: ‘owner’
[17:02:28.626]   - Field: ‘envir’
[17:02:28.626]   - Field: ‘packages’
[17:02:28.626]   - Field: ‘gc’
[17:02:28.626]   - Field: ‘conditions’
[17:02:28.626]   - Field: ‘expr’
[17:02:28.627]   - Field: ‘uuid’
[17:02:28.627]   - Field: ‘seed’
[17:02:28.627]   - Field: ‘version’
[17:02:28.627]   - Field: ‘result’
[17:02:28.627]   - Field: ‘asynchronous’
[17:02:28.627]   - Field: ‘calls’
[17:02:28.627]   - Field: ‘globals’
[17:02:28.627]   - Field: ‘stdout’
[17:02:28.627]   - Field: ‘earlySignal’
[17:02:28.627]   - Field: ‘lazy’
[17:02:28.627]   - Field: ‘state’
[17:02:28.628] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.628] - Launch lazy future ...
[17:02:28.628] Packages needed by the future expression (n = 0): <none>
[17:02:28.628] Packages needed by future strategies (n = 0): <none>
[17:02:28.628] {
[17:02:28.628]     {
[17:02:28.628]         {
[17:02:28.628]             ...future.startTime <- base::Sys.time()
[17:02:28.628]             {
[17:02:28.628]                 {
[17:02:28.628]                   {
[17:02:28.628]                     base::local({
[17:02:28.628]                       has_future <- base::requireNamespace("future", 
[17:02:28.628]                         quietly = TRUE)
[17:02:28.628]                       if (has_future) {
[17:02:28.628]                         ns <- base::getNamespace("future")
[17:02:28.628]                         version <- ns[[".package"]][["version"]]
[17:02:28.628]                         if (is.null(version)) 
[17:02:28.628]                           version <- utils::packageVersion("future")
[17:02:28.628]                       }
[17:02:28.628]                       else {
[17:02:28.628]                         version <- NULL
[17:02:28.628]                       }
[17:02:28.628]                       if (!has_future || version < "1.8.0") {
[17:02:28.628]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.628]                           "", base::R.version$version.string), 
[17:02:28.628]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.628]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.628]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.628]                             "release", "version")], collapse = " "), 
[17:02:28.628]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.628]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.628]                           info)
[17:02:28.628]                         info <- base::paste(info, collapse = "; ")
[17:02:28.628]                         if (!has_future) {
[17:02:28.628]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.628]                             info)
[17:02:28.628]                         }
[17:02:28.628]                         else {
[17:02:28.628]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.628]                             info, version)
[17:02:28.628]                         }
[17:02:28.628]                         base::stop(msg)
[17:02:28.628]                       }
[17:02:28.628]                     })
[17:02:28.628]                   }
[17:02:28.628]                   ...future.strategy.old <- future::plan("list")
[17:02:28.628]                   options(future.plan = NULL)
[17:02:28.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.628]                 }
[17:02:28.628]                 ...future.workdir <- getwd()
[17:02:28.628]             }
[17:02:28.628]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.628]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.628]         }
[17:02:28.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.628]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.628]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.628]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.628]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.628]             base::names(...future.oldOptions))
[17:02:28.628]     }
[17:02:28.628]     if (FALSE) {
[17:02:28.628]     }
[17:02:28.628]     else {
[17:02:28.628]         if (TRUE) {
[17:02:28.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.628]                 open = "w")
[17:02:28.628]         }
[17:02:28.628]         else {
[17:02:28.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.628]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.628]         }
[17:02:28.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.628]             base::sink(type = "output", split = FALSE)
[17:02:28.628]             base::close(...future.stdout)
[17:02:28.628]         }, add = TRUE)
[17:02:28.628]     }
[17:02:28.628]     ...future.frame <- base::sys.nframe()
[17:02:28.628]     ...future.conditions <- base::list()
[17:02:28.628]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.628]     if (FALSE) {
[17:02:28.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.628]     }
[17:02:28.628]     ...future.result <- base::tryCatch({
[17:02:28.628]         base::withCallingHandlers({
[17:02:28.628]             ...future.value <- base::withVisible(base::local(2))
[17:02:28.628]             future::FutureResult(value = ...future.value$value, 
[17:02:28.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.628]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.628]                     ...future.globalenv.names))
[17:02:28.628]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.628]         }, condition = base::local({
[17:02:28.628]             c <- base::c
[17:02:28.628]             inherits <- base::inherits
[17:02:28.628]             invokeRestart <- base::invokeRestart
[17:02:28.628]             length <- base::length
[17:02:28.628]             list <- base::list
[17:02:28.628]             seq.int <- base::seq.int
[17:02:28.628]             signalCondition <- base::signalCondition
[17:02:28.628]             sys.calls <- base::sys.calls
[17:02:28.628]             `[[` <- base::`[[`
[17:02:28.628]             `+` <- base::`+`
[17:02:28.628]             `<<-` <- base::`<<-`
[17:02:28.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.628]                   3L)]
[17:02:28.628]             }
[17:02:28.628]             function(cond) {
[17:02:28.628]                 is_error <- inherits(cond, "error")
[17:02:28.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.628]                   NULL)
[17:02:28.628]                 if (is_error) {
[17:02:28.628]                   sessionInformation <- function() {
[17:02:28.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.628]                       search = base::search(), system = base::Sys.info())
[17:02:28.628]                   }
[17:02:28.628]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.628]                     cond$call), session = sessionInformation(), 
[17:02:28.628]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.628]                   signalCondition(cond)
[17:02:28.628]                 }
[17:02:28.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.628]                 "immediateCondition"))) {
[17:02:28.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.628]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.628]                   if (TRUE && !signal) {
[17:02:28.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.628]                     {
[17:02:28.628]                       inherits <- base::inherits
[17:02:28.628]                       invokeRestart <- base::invokeRestart
[17:02:28.628]                       is.null <- base::is.null
[17:02:28.628]                       muffled <- FALSE
[17:02:28.628]                       if (inherits(cond, "message")) {
[17:02:28.628]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.628]                         if (muffled) 
[17:02:28.628]                           invokeRestart("muffleMessage")
[17:02:28.628]                       }
[17:02:28.628]                       else if (inherits(cond, "warning")) {
[17:02:28.628]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.628]                         if (muffled) 
[17:02:28.628]                           invokeRestart("muffleWarning")
[17:02:28.628]                       }
[17:02:28.628]                       else if (inherits(cond, "condition")) {
[17:02:28.628]                         if (!is.null(pattern)) {
[17:02:28.628]                           computeRestarts <- base::computeRestarts
[17:02:28.628]                           grepl <- base::grepl
[17:02:28.628]                           restarts <- computeRestarts(cond)
[17:02:28.628]                           for (restart in restarts) {
[17:02:28.628]                             name <- restart$name
[17:02:28.628]                             if (is.null(name)) 
[17:02:28.628]                               next
[17:02:28.628]                             if (!grepl(pattern, name)) 
[17:02:28.628]                               next
[17:02:28.628]                             invokeRestart(restart)
[17:02:28.628]                             muffled <- TRUE
[17:02:28.628]                             break
[17:02:28.628]                           }
[17:02:28.628]                         }
[17:02:28.628]                       }
[17:02:28.628]                       invisible(muffled)
[17:02:28.628]                     }
[17:02:28.628]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.628]                   }
[17:02:28.628]                 }
[17:02:28.628]                 else {
[17:02:28.628]                   if (TRUE) {
[17:02:28.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.628]                     {
[17:02:28.628]                       inherits <- base::inherits
[17:02:28.628]                       invokeRestart <- base::invokeRestart
[17:02:28.628]                       is.null <- base::is.null
[17:02:28.628]                       muffled <- FALSE
[17:02:28.628]                       if (inherits(cond, "message")) {
[17:02:28.628]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.628]                         if (muffled) 
[17:02:28.628]                           invokeRestart("muffleMessage")
[17:02:28.628]                       }
[17:02:28.628]                       else if (inherits(cond, "warning")) {
[17:02:28.628]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.628]                         if (muffled) 
[17:02:28.628]                           invokeRestart("muffleWarning")
[17:02:28.628]                       }
[17:02:28.628]                       else if (inherits(cond, "condition")) {
[17:02:28.628]                         if (!is.null(pattern)) {
[17:02:28.628]                           computeRestarts <- base::computeRestarts
[17:02:28.628]                           grepl <- base::grepl
[17:02:28.628]                           restarts <- computeRestarts(cond)
[17:02:28.628]                           for (restart in restarts) {
[17:02:28.628]                             name <- restart$name
[17:02:28.628]                             if (is.null(name)) 
[17:02:28.628]                               next
[17:02:28.628]                             if (!grepl(pattern, name)) 
[17:02:28.628]                               next
[17:02:28.628]                             invokeRestart(restart)
[17:02:28.628]                             muffled <- TRUE
[17:02:28.628]                             break
[17:02:28.628]                           }
[17:02:28.628]                         }
[17:02:28.628]                       }
[17:02:28.628]                       invisible(muffled)
[17:02:28.628]                     }
[17:02:28.628]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.628]                   }
[17:02:28.628]                 }
[17:02:28.628]             }
[17:02:28.628]         }))
[17:02:28.628]     }, error = function(ex) {
[17:02:28.628]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.628]                 ...future.rng), started = ...future.startTime, 
[17:02:28.628]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.628]             version = "1.8"), class = "FutureResult")
[17:02:28.628]     }, finally = {
[17:02:28.628]         if (!identical(...future.workdir, getwd())) 
[17:02:28.628]             setwd(...future.workdir)
[17:02:28.628]         {
[17:02:28.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.628]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.628]             }
[17:02:28.628]             base::options(...future.oldOptions)
[17:02:28.628]             if (.Platform$OS.type == "windows") {
[17:02:28.628]                 old_names <- names(...future.oldEnvVars)
[17:02:28.628]                 envs <- base::Sys.getenv()
[17:02:28.628]                 names <- names(envs)
[17:02:28.628]                 common <- intersect(names, old_names)
[17:02:28.628]                 added <- setdiff(names, old_names)
[17:02:28.628]                 removed <- setdiff(old_names, names)
[17:02:28.628]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.628]                   envs[common]]
[17:02:28.628]                 NAMES <- toupper(changed)
[17:02:28.628]                 args <- list()
[17:02:28.628]                 for (kk in seq_along(NAMES)) {
[17:02:28.628]                   name <- changed[[kk]]
[17:02:28.628]                   NAME <- NAMES[[kk]]
[17:02:28.628]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.628]                     next
[17:02:28.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.628]                 }
[17:02:28.628]                 NAMES <- toupper(added)
[17:02:28.628]                 for (kk in seq_along(NAMES)) {
[17:02:28.628]                   name <- added[[kk]]
[17:02:28.628]                   NAME <- NAMES[[kk]]
[17:02:28.628]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.628]                     next
[17:02:28.628]                   args[[name]] <- ""
[17:02:28.628]                 }
[17:02:28.628]                 NAMES <- toupper(removed)
[17:02:28.628]                 for (kk in seq_along(NAMES)) {
[17:02:28.628]                   name <- removed[[kk]]
[17:02:28.628]                   NAME <- NAMES[[kk]]
[17:02:28.628]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.628]                     next
[17:02:28.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.628]                 }
[17:02:28.628]                 if (length(args) > 0) 
[17:02:28.628]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.628]             }
[17:02:28.628]             else {
[17:02:28.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.628]             }
[17:02:28.628]             {
[17:02:28.628]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.628]                   0L) {
[17:02:28.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.628]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.628]                   base::options(opts)
[17:02:28.628]                 }
[17:02:28.628]                 {
[17:02:28.628]                   {
[17:02:28.628]                     NULL
[17:02:28.628]                     RNGkind("Mersenne-Twister")
[17:02:28.628]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.628]                       inherits = FALSE)
[17:02:28.628]                   }
[17:02:28.628]                   options(future.plan = NULL)
[17:02:28.628]                   if (is.na(NA_character_)) 
[17:02:28.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.628]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.628]                     .init = FALSE)
[17:02:28.628]                 }
[17:02:28.628]             }
[17:02:28.628]         }
[17:02:28.628]     })
[17:02:28.628]     if (TRUE) {
[17:02:28.628]         base::sink(type = "output", split = FALSE)
[17:02:28.628]         if (TRUE) {
[17:02:28.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.628]         }
[17:02:28.628]         else {
[17:02:28.628]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.628]         }
[17:02:28.628]         base::close(...future.stdout)
[17:02:28.628]         ...future.stdout <- NULL
[17:02:28.628]     }
[17:02:28.628]     ...future.result$conditions <- ...future.conditions
[17:02:28.628]     ...future.result$finished <- base::Sys.time()
[17:02:28.628]     ...future.result
[17:02:28.628] }
[17:02:28.630] plan(): Setting new future strategy stack:
[17:02:28.630] List of future strategies:
[17:02:28.630] 1. sequential:
[17:02:28.630]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.630]    - tweaked: FALSE
[17:02:28.630]    - call: NULL
[17:02:28.631] plan(): nbrOfWorkers() = 1
[17:02:28.632] plan(): Setting new future strategy stack:
[17:02:28.632] List of future strategies:
[17:02:28.632] 1. sequential:
[17:02:28.632]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.632]    - tweaked: FALSE
[17:02:28.632]    - call: plan(strategy)
[17:02:28.632] plan(): nbrOfWorkers() = 1
[17:02:28.632] SequentialFuture started (and completed)
[17:02:28.633] - Launch lazy future ... done
[17:02:28.633] run() for ‘SequentialFuture’ ... done
[17:02:28.633] getGlobalsAndPackages() ...
[17:02:28.633] Searching for globals...
[17:02:28.633] 
[17:02:28.633] Searching for globals ... DONE
[17:02:28.633] - globals: [0] <none>
[17:02:28.633] getGlobalsAndPackages() ... DONE
[17:02:28.634] run() for ‘Future’ ...
[17:02:28.634] - state: ‘created’
[17:02:28.634] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.634] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.634] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.634]   - Field: ‘label’
[17:02:28.635]   - Field: ‘local’
[17:02:28.635]   - Field: ‘owner’
[17:02:28.635]   - Field: ‘envir’
[17:02:28.635]   - Field: ‘packages’
[17:02:28.635]   - Field: ‘gc’
[17:02:28.635]   - Field: ‘conditions’
[17:02:28.635]   - Field: ‘expr’
[17:02:28.635]   - Field: ‘uuid’
[17:02:28.635]   - Field: ‘seed’
[17:02:28.635]   - Field: ‘version’
[17:02:28.635]   - Field: ‘result’
[17:02:28.636]   - Field: ‘asynchronous’
[17:02:28.636]   - Field: ‘calls’
[17:02:28.636]   - Field: ‘globals’
[17:02:28.636]   - Field: ‘stdout’
[17:02:28.636]   - Field: ‘earlySignal’
[17:02:28.636]   - Field: ‘lazy’
[17:02:28.636]   - Field: ‘state’
[17:02:28.636] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.636] - Launch lazy future ...
[17:02:28.636] Packages needed by the future expression (n = 0): <none>
[17:02:28.637] Packages needed by future strategies (n = 0): <none>
[17:02:28.637] {
[17:02:28.637]     {
[17:02:28.637]         {
[17:02:28.637]             ...future.startTime <- base::Sys.time()
[17:02:28.637]             {
[17:02:28.637]                 {
[17:02:28.637]                   {
[17:02:28.637]                     base::local({
[17:02:28.637]                       has_future <- base::requireNamespace("future", 
[17:02:28.637]                         quietly = TRUE)
[17:02:28.637]                       if (has_future) {
[17:02:28.637]                         ns <- base::getNamespace("future")
[17:02:28.637]                         version <- ns[[".package"]][["version"]]
[17:02:28.637]                         if (is.null(version)) 
[17:02:28.637]                           version <- utils::packageVersion("future")
[17:02:28.637]                       }
[17:02:28.637]                       else {
[17:02:28.637]                         version <- NULL
[17:02:28.637]                       }
[17:02:28.637]                       if (!has_future || version < "1.8.0") {
[17:02:28.637]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.637]                           "", base::R.version$version.string), 
[17:02:28.637]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.637]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.637]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.637]                             "release", "version")], collapse = " "), 
[17:02:28.637]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.637]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.637]                           info)
[17:02:28.637]                         info <- base::paste(info, collapse = "; ")
[17:02:28.637]                         if (!has_future) {
[17:02:28.637]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.637]                             info)
[17:02:28.637]                         }
[17:02:28.637]                         else {
[17:02:28.637]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.637]                             info, version)
[17:02:28.637]                         }
[17:02:28.637]                         base::stop(msg)
[17:02:28.637]                       }
[17:02:28.637]                     })
[17:02:28.637]                   }
[17:02:28.637]                   ...future.strategy.old <- future::plan("list")
[17:02:28.637]                   options(future.plan = NULL)
[17:02:28.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.637]                 }
[17:02:28.637]                 ...future.workdir <- getwd()
[17:02:28.637]             }
[17:02:28.637]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.637]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.637]         }
[17:02:28.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.637]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.637]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.637]             base::names(...future.oldOptions))
[17:02:28.637]     }
[17:02:28.637]     if (FALSE) {
[17:02:28.637]     }
[17:02:28.637]     else {
[17:02:28.637]         if (TRUE) {
[17:02:28.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.637]                 open = "w")
[17:02:28.637]         }
[17:02:28.637]         else {
[17:02:28.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.637]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.637]         }
[17:02:28.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.637]             base::sink(type = "output", split = FALSE)
[17:02:28.637]             base::close(...future.stdout)
[17:02:28.637]         }, add = TRUE)
[17:02:28.637]     }
[17:02:28.637]     ...future.frame <- base::sys.nframe()
[17:02:28.637]     ...future.conditions <- base::list()
[17:02:28.637]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.637]     if (FALSE) {
[17:02:28.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.637]     }
[17:02:28.637]     ...future.result <- base::tryCatch({
[17:02:28.637]         base::withCallingHandlers({
[17:02:28.637]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:28.637]             future::FutureResult(value = ...future.value$value, 
[17:02:28.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.637]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.637]                     ...future.globalenv.names))
[17:02:28.637]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.637]         }, condition = base::local({
[17:02:28.637]             c <- base::c
[17:02:28.637]             inherits <- base::inherits
[17:02:28.637]             invokeRestart <- base::invokeRestart
[17:02:28.637]             length <- base::length
[17:02:28.637]             list <- base::list
[17:02:28.637]             seq.int <- base::seq.int
[17:02:28.637]             signalCondition <- base::signalCondition
[17:02:28.637]             sys.calls <- base::sys.calls
[17:02:28.637]             `[[` <- base::`[[`
[17:02:28.637]             `+` <- base::`+`
[17:02:28.637]             `<<-` <- base::`<<-`
[17:02:28.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.637]                   3L)]
[17:02:28.637]             }
[17:02:28.637]             function(cond) {
[17:02:28.637]                 is_error <- inherits(cond, "error")
[17:02:28.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.637]                   NULL)
[17:02:28.637]                 if (is_error) {
[17:02:28.637]                   sessionInformation <- function() {
[17:02:28.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.637]                       search = base::search(), system = base::Sys.info())
[17:02:28.637]                   }
[17:02:28.637]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.637]                     cond$call), session = sessionInformation(), 
[17:02:28.637]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.637]                   signalCondition(cond)
[17:02:28.637]                 }
[17:02:28.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.637]                 "immediateCondition"))) {
[17:02:28.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.637]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.637]                   if (TRUE && !signal) {
[17:02:28.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.637]                     {
[17:02:28.637]                       inherits <- base::inherits
[17:02:28.637]                       invokeRestart <- base::invokeRestart
[17:02:28.637]                       is.null <- base::is.null
[17:02:28.637]                       muffled <- FALSE
[17:02:28.637]                       if (inherits(cond, "message")) {
[17:02:28.637]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.637]                         if (muffled) 
[17:02:28.637]                           invokeRestart("muffleMessage")
[17:02:28.637]                       }
[17:02:28.637]                       else if (inherits(cond, "warning")) {
[17:02:28.637]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.637]                         if (muffled) 
[17:02:28.637]                           invokeRestart("muffleWarning")
[17:02:28.637]                       }
[17:02:28.637]                       else if (inherits(cond, "condition")) {
[17:02:28.637]                         if (!is.null(pattern)) {
[17:02:28.637]                           computeRestarts <- base::computeRestarts
[17:02:28.637]                           grepl <- base::grepl
[17:02:28.637]                           restarts <- computeRestarts(cond)
[17:02:28.637]                           for (restart in restarts) {
[17:02:28.637]                             name <- restart$name
[17:02:28.637]                             if (is.null(name)) 
[17:02:28.637]                               next
[17:02:28.637]                             if (!grepl(pattern, name)) 
[17:02:28.637]                               next
[17:02:28.637]                             invokeRestart(restart)
[17:02:28.637]                             muffled <- TRUE
[17:02:28.637]                             break
[17:02:28.637]                           }
[17:02:28.637]                         }
[17:02:28.637]                       }
[17:02:28.637]                       invisible(muffled)
[17:02:28.637]                     }
[17:02:28.637]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.637]                   }
[17:02:28.637]                 }
[17:02:28.637]                 else {
[17:02:28.637]                   if (TRUE) {
[17:02:28.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.637]                     {
[17:02:28.637]                       inherits <- base::inherits
[17:02:28.637]                       invokeRestart <- base::invokeRestart
[17:02:28.637]                       is.null <- base::is.null
[17:02:28.637]                       muffled <- FALSE
[17:02:28.637]                       if (inherits(cond, "message")) {
[17:02:28.637]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.637]                         if (muffled) 
[17:02:28.637]                           invokeRestart("muffleMessage")
[17:02:28.637]                       }
[17:02:28.637]                       else if (inherits(cond, "warning")) {
[17:02:28.637]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.637]                         if (muffled) 
[17:02:28.637]                           invokeRestart("muffleWarning")
[17:02:28.637]                       }
[17:02:28.637]                       else if (inherits(cond, "condition")) {
[17:02:28.637]                         if (!is.null(pattern)) {
[17:02:28.637]                           computeRestarts <- base::computeRestarts
[17:02:28.637]                           grepl <- base::grepl
[17:02:28.637]                           restarts <- computeRestarts(cond)
[17:02:28.637]                           for (restart in restarts) {
[17:02:28.637]                             name <- restart$name
[17:02:28.637]                             if (is.null(name)) 
[17:02:28.637]                               next
[17:02:28.637]                             if (!grepl(pattern, name)) 
[17:02:28.637]                               next
[17:02:28.637]                             invokeRestart(restart)
[17:02:28.637]                             muffled <- TRUE
[17:02:28.637]                             break
[17:02:28.637]                           }
[17:02:28.637]                         }
[17:02:28.637]                       }
[17:02:28.637]                       invisible(muffled)
[17:02:28.637]                     }
[17:02:28.637]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.637]                   }
[17:02:28.637]                 }
[17:02:28.637]             }
[17:02:28.637]         }))
[17:02:28.637]     }, error = function(ex) {
[17:02:28.637]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.637]                 ...future.rng), started = ...future.startTime, 
[17:02:28.637]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.637]             version = "1.8"), class = "FutureResult")
[17:02:28.637]     }, finally = {
[17:02:28.637]         if (!identical(...future.workdir, getwd())) 
[17:02:28.637]             setwd(...future.workdir)
[17:02:28.637]         {
[17:02:28.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.637]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.637]             }
[17:02:28.637]             base::options(...future.oldOptions)
[17:02:28.637]             if (.Platform$OS.type == "windows") {
[17:02:28.637]                 old_names <- names(...future.oldEnvVars)
[17:02:28.637]                 envs <- base::Sys.getenv()
[17:02:28.637]                 names <- names(envs)
[17:02:28.637]                 common <- intersect(names, old_names)
[17:02:28.637]                 added <- setdiff(names, old_names)
[17:02:28.637]                 removed <- setdiff(old_names, names)
[17:02:28.637]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.637]                   envs[common]]
[17:02:28.637]                 NAMES <- toupper(changed)
[17:02:28.637]                 args <- list()
[17:02:28.637]                 for (kk in seq_along(NAMES)) {
[17:02:28.637]                   name <- changed[[kk]]
[17:02:28.637]                   NAME <- NAMES[[kk]]
[17:02:28.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.637]                     next
[17:02:28.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.637]                 }
[17:02:28.637]                 NAMES <- toupper(added)
[17:02:28.637]                 for (kk in seq_along(NAMES)) {
[17:02:28.637]                   name <- added[[kk]]
[17:02:28.637]                   NAME <- NAMES[[kk]]
[17:02:28.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.637]                     next
[17:02:28.637]                   args[[name]] <- ""
[17:02:28.637]                 }
[17:02:28.637]                 NAMES <- toupper(removed)
[17:02:28.637]                 for (kk in seq_along(NAMES)) {
[17:02:28.637]                   name <- removed[[kk]]
[17:02:28.637]                   NAME <- NAMES[[kk]]
[17:02:28.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.637]                     next
[17:02:28.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.637]                 }
[17:02:28.637]                 if (length(args) > 0) 
[17:02:28.637]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.637]             }
[17:02:28.637]             else {
[17:02:28.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.637]             }
[17:02:28.637]             {
[17:02:28.637]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.637]                   0L) {
[17:02:28.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.637]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.637]                   base::options(opts)
[17:02:28.637]                 }
[17:02:28.637]                 {
[17:02:28.637]                   {
[17:02:28.637]                     NULL
[17:02:28.637]                     RNGkind("Mersenne-Twister")
[17:02:28.637]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.637]                       inherits = FALSE)
[17:02:28.637]                   }
[17:02:28.637]                   options(future.plan = NULL)
[17:02:28.637]                   if (is.na(NA_character_)) 
[17:02:28.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.637]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.637]                     .init = FALSE)
[17:02:28.637]                 }
[17:02:28.637]             }
[17:02:28.637]         }
[17:02:28.637]     })
[17:02:28.637]     if (TRUE) {
[17:02:28.637]         base::sink(type = "output", split = FALSE)
[17:02:28.637]         if (TRUE) {
[17:02:28.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.637]         }
[17:02:28.637]         else {
[17:02:28.637]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.637]         }
[17:02:28.637]         base::close(...future.stdout)
[17:02:28.637]         ...future.stdout <- NULL
[17:02:28.637]     }
[17:02:28.637]     ...future.result$conditions <- ...future.conditions
[17:02:28.637]     ...future.result$finished <- base::Sys.time()
[17:02:28.637]     ...future.result
[17:02:28.637] }
[17:02:28.639] plan(): Setting new future strategy stack:
[17:02:28.639] List of future strategies:
[17:02:28.639] 1. sequential:
[17:02:28.639]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.639]    - tweaked: FALSE
[17:02:28.639]    - call: NULL
[17:02:28.639] plan(): nbrOfWorkers() = 1
[17:02:28.640] plan(): Setting new future strategy stack:
[17:02:28.640] List of future strategies:
[17:02:28.640] 1. sequential:
[17:02:28.640]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.640]    - tweaked: FALSE
[17:02:28.640]    - call: plan(strategy)
[17:02:28.641] plan(): nbrOfWorkers() = 1
[17:02:28.641] SequentialFuture started (and completed)
[17:02:28.641] - Launch lazy future ... done
[17:02:28.641] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c747b52b90> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c748f32ba0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c747b52b90> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c748f32ba0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:02:28.647] resolved() for ‘SequentialFuture’ ...
[17:02:28.647] - state: ‘finished’
[17:02:28.647] - run: TRUE
[17:02:28.647] - result: ‘FutureResult’
[17:02:28.647] resolved() for ‘SequentialFuture’ ... done
[17:02:28.647] resolved() for ‘SequentialFuture’ ...
[17:02:28.647] - state: ‘finished’
[17:02:28.647] - run: TRUE
[17:02:28.647] - result: ‘FutureResult’
[17:02:28.647] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:28.649] resolve() on list ...
[17:02:28.650]  recursive: 0
[17:02:28.650]  length: 6
[17:02:28.650]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:28.650] signalConditionsASAP(numeric, pos=1) ...
[17:02:28.650] - nx: 6
[17:02:28.650] - relay: TRUE
[17:02:28.650] - stdout: TRUE
[17:02:28.650] - signal: TRUE
[17:02:28.650] - resignal: FALSE
[17:02:28.650] - force: TRUE
[17:02:28.650] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.650] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.651]  - until=2
[17:02:28.651]  - relaying element #2
[17:02:28.651] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.651] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.651] signalConditionsASAP(NULL, pos=1) ... done
[17:02:28.651]  length: 5 (resolved future 1)
[17:02:28.651] resolved() for ‘SequentialFuture’ ...
[17:02:28.651] - state: ‘finished’
[17:02:28.651] - run: TRUE
[17:02:28.651] - result: ‘FutureResult’
[17:02:28.652] resolved() for ‘SequentialFuture’ ... done
[17:02:28.652] Future #2
[17:02:28.652] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:28.652] - nx: 6
[17:02:28.652] - relay: TRUE
[17:02:28.652] - stdout: TRUE
[17:02:28.652] - signal: TRUE
[17:02:28.652] - resignal: FALSE
[17:02:28.652] - force: TRUE
[17:02:28.652] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.652] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.653]  - until=2
[17:02:28.653]  - relaying element #2
[17:02:28.653] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.653] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.653] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:28.653]  length: 4 (resolved future 2)
[17:02:28.655] resolved() for ‘SequentialFuture’ ...
[17:02:28.655] - state: ‘finished’
[17:02:28.655] - run: TRUE
[17:02:28.656] - result: ‘FutureResult’
[17:02:28.656] resolved() for ‘SequentialFuture’ ... done
[17:02:28.656] Future #3
[17:02:28.656] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:28.656] - nx: 6
[17:02:28.656] - relay: TRUE
[17:02:28.656] - stdout: TRUE
[17:02:28.656] - signal: TRUE
[17:02:28.656] - resignal: FALSE
[17:02:28.656] - force: TRUE
[17:02:28.656] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.657] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.657]  - until=3
[17:02:28.657]  - relaying element #3
[17:02:28.657] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.657] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.657] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:28.657]  length: 3 (resolved future 3)
[17:02:28.657] signalConditionsASAP(NULL, pos=4) ...
[17:02:28.657] - nx: 6
[17:02:28.657] - relay: TRUE
[17:02:28.658] - stdout: TRUE
[17:02:28.658] - signal: TRUE
[17:02:28.658] - resignal: FALSE
[17:02:28.658] - force: TRUE
[17:02:28.658] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.658] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.658]  - until=5
[17:02:28.658]  - relaying element #5
[17:02:28.658] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.658] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.658] signalConditionsASAP(NULL, pos=4) ... done
[17:02:28.658]  length: 2 (resolved future 4)
[17:02:28.659] signalConditionsASAP(NULL, pos=5) ...
[17:02:28.659] - nx: 6
[17:02:28.659] - relay: TRUE
[17:02:28.659] - stdout: TRUE
[17:02:28.659] - signal: TRUE
[17:02:28.659] - resignal: FALSE
[17:02:28.659] - force: TRUE
[17:02:28.659] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.659] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.659]  - until=6
[17:02:28.659]  - relaying element #6
[17:02:28.659] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:28.660] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.660] signalConditionsASAP(NULL, pos=5) ... done
[17:02:28.660]  length: 1 (resolved future 5)
[17:02:28.660] signalConditionsASAP(numeric, pos=6) ...
[17:02:28.660] - nx: 6
[17:02:28.660] - relay: TRUE
[17:02:28.660] - stdout: TRUE
[17:02:28.660] - signal: TRUE
[17:02:28.660] - resignal: FALSE
[17:02:28.660] - force: TRUE
[17:02:28.660] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:28.660] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.661]  - until=6
[17:02:28.661] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.661] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.661] signalConditionsASAP(numeric, pos=6) ... done
[17:02:28.661]  length: 0 (resolved future 6)
[17:02:28.661] Relaying remaining futures
[17:02:28.661] signalConditionsASAP(NULL, pos=0) ...
[17:02:28.661] - nx: 6
[17:02:28.661] - relay: TRUE
[17:02:28.661] - stdout: TRUE
[17:02:28.661] - signal: TRUE
[17:02:28.661] - resignal: FALSE
[17:02:28.662] - force: TRUE
[17:02:28.662] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.662] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:28.662] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.662] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.662] signalConditionsASAP(NULL, pos=0) ... done
[17:02:28.662] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[17:02:28.671] plan(): Setting new future strategy stack:
[17:02:28.671] List of future strategies:
[17:02:28.671] 1. sequential:
[17:02:28.671]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.671]    - tweaked: FALSE
[17:02:28.671]    - call: plan(strategy)
[17:02:28.671] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[17:02:28.672] getGlobalsAndPackages() ...
[17:02:28.672] Searching for globals...
[17:02:28.672] 
[17:02:28.672] Searching for globals ... DONE
[17:02:28.672] - globals: [0] <none>
[17:02:28.672] getGlobalsAndPackages() ... DONE
[17:02:28.673] run() for ‘Future’ ...
[17:02:28.673] - state: ‘created’
[17:02:28.673] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.673] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.673] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.673]   - Field: ‘label’
[17:02:28.673]   - Field: ‘local’
[17:02:28.673]   - Field: ‘owner’
[17:02:28.674]   - Field: ‘envir’
[17:02:28.674]   - Field: ‘packages’
[17:02:28.674]   - Field: ‘gc’
[17:02:28.674]   - Field: ‘conditions’
[17:02:28.674]   - Field: ‘expr’
[17:02:28.674]   - Field: ‘uuid’
[17:02:28.674]   - Field: ‘seed’
[17:02:28.674]   - Field: ‘version’
[17:02:28.674]   - Field: ‘result’
[17:02:28.674]   - Field: ‘asynchronous’
[17:02:28.674]   - Field: ‘calls’
[17:02:28.675]   - Field: ‘globals’
[17:02:28.675]   - Field: ‘stdout’
[17:02:28.675]   - Field: ‘earlySignal’
[17:02:28.675]   - Field: ‘lazy’
[17:02:28.675]   - Field: ‘state’
[17:02:28.675] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.675] - Launch lazy future ...
[17:02:28.675] Packages needed by the future expression (n = 0): <none>
[17:02:28.675] Packages needed by future strategies (n = 0): <none>
[17:02:28.676] {
[17:02:28.676]     {
[17:02:28.676]         {
[17:02:28.676]             ...future.startTime <- base::Sys.time()
[17:02:28.676]             {
[17:02:28.676]                 {
[17:02:28.676]                   {
[17:02:28.676]                     base::local({
[17:02:28.676]                       has_future <- base::requireNamespace("future", 
[17:02:28.676]                         quietly = TRUE)
[17:02:28.676]                       if (has_future) {
[17:02:28.676]                         ns <- base::getNamespace("future")
[17:02:28.676]                         version <- ns[[".package"]][["version"]]
[17:02:28.676]                         if (is.null(version)) 
[17:02:28.676]                           version <- utils::packageVersion("future")
[17:02:28.676]                       }
[17:02:28.676]                       else {
[17:02:28.676]                         version <- NULL
[17:02:28.676]                       }
[17:02:28.676]                       if (!has_future || version < "1.8.0") {
[17:02:28.676]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.676]                           "", base::R.version$version.string), 
[17:02:28.676]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.676]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.676]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.676]                             "release", "version")], collapse = " "), 
[17:02:28.676]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.676]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.676]                           info)
[17:02:28.676]                         info <- base::paste(info, collapse = "; ")
[17:02:28.676]                         if (!has_future) {
[17:02:28.676]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.676]                             info)
[17:02:28.676]                         }
[17:02:28.676]                         else {
[17:02:28.676]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.676]                             info, version)
[17:02:28.676]                         }
[17:02:28.676]                         base::stop(msg)
[17:02:28.676]                       }
[17:02:28.676]                     })
[17:02:28.676]                   }
[17:02:28.676]                   ...future.strategy.old <- future::plan("list")
[17:02:28.676]                   options(future.plan = NULL)
[17:02:28.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.676]                 }
[17:02:28.676]                 ...future.workdir <- getwd()
[17:02:28.676]             }
[17:02:28.676]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.676]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.676]         }
[17:02:28.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.676]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.676]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.676]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.676]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.676]             base::names(...future.oldOptions))
[17:02:28.676]     }
[17:02:28.676]     if (FALSE) {
[17:02:28.676]     }
[17:02:28.676]     else {
[17:02:28.676]         if (TRUE) {
[17:02:28.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.676]                 open = "w")
[17:02:28.676]         }
[17:02:28.676]         else {
[17:02:28.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.676]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.676]         }
[17:02:28.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.676]             base::sink(type = "output", split = FALSE)
[17:02:28.676]             base::close(...future.stdout)
[17:02:28.676]         }, add = TRUE)
[17:02:28.676]     }
[17:02:28.676]     ...future.frame <- base::sys.nframe()
[17:02:28.676]     ...future.conditions <- base::list()
[17:02:28.676]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.676]     if (FALSE) {
[17:02:28.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.676]     }
[17:02:28.676]     ...future.result <- base::tryCatch({
[17:02:28.676]         base::withCallingHandlers({
[17:02:28.676]             ...future.value <- base::withVisible(base::local(2))
[17:02:28.676]             future::FutureResult(value = ...future.value$value, 
[17:02:28.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.676]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.676]                     ...future.globalenv.names))
[17:02:28.676]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.676]         }, condition = base::local({
[17:02:28.676]             c <- base::c
[17:02:28.676]             inherits <- base::inherits
[17:02:28.676]             invokeRestart <- base::invokeRestart
[17:02:28.676]             length <- base::length
[17:02:28.676]             list <- base::list
[17:02:28.676]             seq.int <- base::seq.int
[17:02:28.676]             signalCondition <- base::signalCondition
[17:02:28.676]             sys.calls <- base::sys.calls
[17:02:28.676]             `[[` <- base::`[[`
[17:02:28.676]             `+` <- base::`+`
[17:02:28.676]             `<<-` <- base::`<<-`
[17:02:28.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.676]                   3L)]
[17:02:28.676]             }
[17:02:28.676]             function(cond) {
[17:02:28.676]                 is_error <- inherits(cond, "error")
[17:02:28.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.676]                   NULL)
[17:02:28.676]                 if (is_error) {
[17:02:28.676]                   sessionInformation <- function() {
[17:02:28.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.676]                       search = base::search(), system = base::Sys.info())
[17:02:28.676]                   }
[17:02:28.676]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.676]                     cond$call), session = sessionInformation(), 
[17:02:28.676]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.676]                   signalCondition(cond)
[17:02:28.676]                 }
[17:02:28.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.676]                 "immediateCondition"))) {
[17:02:28.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.676]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.676]                   if (TRUE && !signal) {
[17:02:28.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.676]                     {
[17:02:28.676]                       inherits <- base::inherits
[17:02:28.676]                       invokeRestart <- base::invokeRestart
[17:02:28.676]                       is.null <- base::is.null
[17:02:28.676]                       muffled <- FALSE
[17:02:28.676]                       if (inherits(cond, "message")) {
[17:02:28.676]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.676]                         if (muffled) 
[17:02:28.676]                           invokeRestart("muffleMessage")
[17:02:28.676]                       }
[17:02:28.676]                       else if (inherits(cond, "warning")) {
[17:02:28.676]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.676]                         if (muffled) 
[17:02:28.676]                           invokeRestart("muffleWarning")
[17:02:28.676]                       }
[17:02:28.676]                       else if (inherits(cond, "condition")) {
[17:02:28.676]                         if (!is.null(pattern)) {
[17:02:28.676]                           computeRestarts <- base::computeRestarts
[17:02:28.676]                           grepl <- base::grepl
[17:02:28.676]                           restarts <- computeRestarts(cond)
[17:02:28.676]                           for (restart in restarts) {
[17:02:28.676]                             name <- restart$name
[17:02:28.676]                             if (is.null(name)) 
[17:02:28.676]                               next
[17:02:28.676]                             if (!grepl(pattern, name)) 
[17:02:28.676]                               next
[17:02:28.676]                             invokeRestart(restart)
[17:02:28.676]                             muffled <- TRUE
[17:02:28.676]                             break
[17:02:28.676]                           }
[17:02:28.676]                         }
[17:02:28.676]                       }
[17:02:28.676]                       invisible(muffled)
[17:02:28.676]                     }
[17:02:28.676]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.676]                   }
[17:02:28.676]                 }
[17:02:28.676]                 else {
[17:02:28.676]                   if (TRUE) {
[17:02:28.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.676]                     {
[17:02:28.676]                       inherits <- base::inherits
[17:02:28.676]                       invokeRestart <- base::invokeRestart
[17:02:28.676]                       is.null <- base::is.null
[17:02:28.676]                       muffled <- FALSE
[17:02:28.676]                       if (inherits(cond, "message")) {
[17:02:28.676]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.676]                         if (muffled) 
[17:02:28.676]                           invokeRestart("muffleMessage")
[17:02:28.676]                       }
[17:02:28.676]                       else if (inherits(cond, "warning")) {
[17:02:28.676]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.676]                         if (muffled) 
[17:02:28.676]                           invokeRestart("muffleWarning")
[17:02:28.676]                       }
[17:02:28.676]                       else if (inherits(cond, "condition")) {
[17:02:28.676]                         if (!is.null(pattern)) {
[17:02:28.676]                           computeRestarts <- base::computeRestarts
[17:02:28.676]                           grepl <- base::grepl
[17:02:28.676]                           restarts <- computeRestarts(cond)
[17:02:28.676]                           for (restart in restarts) {
[17:02:28.676]                             name <- restart$name
[17:02:28.676]                             if (is.null(name)) 
[17:02:28.676]                               next
[17:02:28.676]                             if (!grepl(pattern, name)) 
[17:02:28.676]                               next
[17:02:28.676]                             invokeRestart(restart)
[17:02:28.676]                             muffled <- TRUE
[17:02:28.676]                             break
[17:02:28.676]                           }
[17:02:28.676]                         }
[17:02:28.676]                       }
[17:02:28.676]                       invisible(muffled)
[17:02:28.676]                     }
[17:02:28.676]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.676]                   }
[17:02:28.676]                 }
[17:02:28.676]             }
[17:02:28.676]         }))
[17:02:28.676]     }, error = function(ex) {
[17:02:28.676]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.676]                 ...future.rng), started = ...future.startTime, 
[17:02:28.676]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.676]             version = "1.8"), class = "FutureResult")
[17:02:28.676]     }, finally = {
[17:02:28.676]         if (!identical(...future.workdir, getwd())) 
[17:02:28.676]             setwd(...future.workdir)
[17:02:28.676]         {
[17:02:28.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.676]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.676]             }
[17:02:28.676]             base::options(...future.oldOptions)
[17:02:28.676]             if (.Platform$OS.type == "windows") {
[17:02:28.676]                 old_names <- names(...future.oldEnvVars)
[17:02:28.676]                 envs <- base::Sys.getenv()
[17:02:28.676]                 names <- names(envs)
[17:02:28.676]                 common <- intersect(names, old_names)
[17:02:28.676]                 added <- setdiff(names, old_names)
[17:02:28.676]                 removed <- setdiff(old_names, names)
[17:02:28.676]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.676]                   envs[common]]
[17:02:28.676]                 NAMES <- toupper(changed)
[17:02:28.676]                 args <- list()
[17:02:28.676]                 for (kk in seq_along(NAMES)) {
[17:02:28.676]                   name <- changed[[kk]]
[17:02:28.676]                   NAME <- NAMES[[kk]]
[17:02:28.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.676]                     next
[17:02:28.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.676]                 }
[17:02:28.676]                 NAMES <- toupper(added)
[17:02:28.676]                 for (kk in seq_along(NAMES)) {
[17:02:28.676]                   name <- added[[kk]]
[17:02:28.676]                   NAME <- NAMES[[kk]]
[17:02:28.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.676]                     next
[17:02:28.676]                   args[[name]] <- ""
[17:02:28.676]                 }
[17:02:28.676]                 NAMES <- toupper(removed)
[17:02:28.676]                 for (kk in seq_along(NAMES)) {
[17:02:28.676]                   name <- removed[[kk]]
[17:02:28.676]                   NAME <- NAMES[[kk]]
[17:02:28.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.676]                     next
[17:02:28.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.676]                 }
[17:02:28.676]                 if (length(args) > 0) 
[17:02:28.676]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.676]             }
[17:02:28.676]             else {
[17:02:28.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.676]             }
[17:02:28.676]             {
[17:02:28.676]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.676]                   0L) {
[17:02:28.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.676]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.676]                   base::options(opts)
[17:02:28.676]                 }
[17:02:28.676]                 {
[17:02:28.676]                   {
[17:02:28.676]                     NULL
[17:02:28.676]                     RNGkind("Mersenne-Twister")
[17:02:28.676]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.676]                       inherits = FALSE)
[17:02:28.676]                   }
[17:02:28.676]                   options(future.plan = NULL)
[17:02:28.676]                   if (is.na(NA_character_)) 
[17:02:28.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.676]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.676]                     .init = FALSE)
[17:02:28.676]                 }
[17:02:28.676]             }
[17:02:28.676]         }
[17:02:28.676]     })
[17:02:28.676]     if (TRUE) {
[17:02:28.676]         base::sink(type = "output", split = FALSE)
[17:02:28.676]         if (TRUE) {
[17:02:28.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.676]         }
[17:02:28.676]         else {
[17:02:28.676]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.676]         }
[17:02:28.676]         base::close(...future.stdout)
[17:02:28.676]         ...future.stdout <- NULL
[17:02:28.676]     }
[17:02:28.676]     ...future.result$conditions <- ...future.conditions
[17:02:28.676]     ...future.result$finished <- base::Sys.time()
[17:02:28.676]     ...future.result
[17:02:28.676] }
[17:02:28.678] plan(): Setting new future strategy stack:
[17:02:28.678] List of future strategies:
[17:02:28.678] 1. sequential:
[17:02:28.678]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.678]    - tweaked: FALSE
[17:02:28.678]    - call: NULL
[17:02:28.678] plan(): nbrOfWorkers() = 1
[17:02:28.679] plan(): Setting new future strategy stack:
[17:02:28.679] List of future strategies:
[17:02:28.679] 1. sequential:
[17:02:28.679]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.679]    - tweaked: FALSE
[17:02:28.679]    - call: plan(strategy)
[17:02:28.679] plan(): nbrOfWorkers() = 1
[17:02:28.680] SequentialFuture started (and completed)
[17:02:28.680] - Launch lazy future ... done
[17:02:28.680] run() for ‘SequentialFuture’ ... done
[17:02:28.680] getGlobalsAndPackages() ...
[17:02:28.680] Searching for globals...
[17:02:28.680] 
[17:02:28.680] Searching for globals ... DONE
[17:02:28.680] - globals: [0] <none>
[17:02:28.681] getGlobalsAndPackages() ... DONE
[17:02:28.681] run() for ‘Future’ ...
[17:02:28.681] - state: ‘created’
[17:02:28.681] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.681] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.681] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.681]   - Field: ‘label’
[17:02:28.682]   - Field: ‘local’
[17:02:28.683]   - Field: ‘owner’
[17:02:28.683]   - Field: ‘envir’
[17:02:28.683]   - Field: ‘packages’
[17:02:28.684]   - Field: ‘gc’
[17:02:28.684]   - Field: ‘conditions’
[17:02:28.684]   - Field: ‘expr’
[17:02:28.684]   - Field: ‘uuid’
[17:02:28.684]   - Field: ‘seed’
[17:02:28.684]   - Field: ‘version’
[17:02:28.684]   - Field: ‘result’
[17:02:28.684]   - Field: ‘asynchronous’
[17:02:28.684]   - Field: ‘calls’
[17:02:28.684]   - Field: ‘globals’
[17:02:28.684]   - Field: ‘stdout’
[17:02:28.685]   - Field: ‘earlySignal’
[17:02:28.685]   - Field: ‘lazy’
[17:02:28.685]   - Field: ‘state’
[17:02:28.685] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.685] - Launch lazy future ...
[17:02:28.685] Packages needed by the future expression (n = 0): <none>
[17:02:28.685] Packages needed by future strategies (n = 0): <none>
[17:02:28.686] {
[17:02:28.686]     {
[17:02:28.686]         {
[17:02:28.686]             ...future.startTime <- base::Sys.time()
[17:02:28.686]             {
[17:02:28.686]                 {
[17:02:28.686]                   {
[17:02:28.686]                     base::local({
[17:02:28.686]                       has_future <- base::requireNamespace("future", 
[17:02:28.686]                         quietly = TRUE)
[17:02:28.686]                       if (has_future) {
[17:02:28.686]                         ns <- base::getNamespace("future")
[17:02:28.686]                         version <- ns[[".package"]][["version"]]
[17:02:28.686]                         if (is.null(version)) 
[17:02:28.686]                           version <- utils::packageVersion("future")
[17:02:28.686]                       }
[17:02:28.686]                       else {
[17:02:28.686]                         version <- NULL
[17:02:28.686]                       }
[17:02:28.686]                       if (!has_future || version < "1.8.0") {
[17:02:28.686]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.686]                           "", base::R.version$version.string), 
[17:02:28.686]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.686]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.686]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.686]                             "release", "version")], collapse = " "), 
[17:02:28.686]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.686]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.686]                           info)
[17:02:28.686]                         info <- base::paste(info, collapse = "; ")
[17:02:28.686]                         if (!has_future) {
[17:02:28.686]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.686]                             info)
[17:02:28.686]                         }
[17:02:28.686]                         else {
[17:02:28.686]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.686]                             info, version)
[17:02:28.686]                         }
[17:02:28.686]                         base::stop(msg)
[17:02:28.686]                       }
[17:02:28.686]                     })
[17:02:28.686]                   }
[17:02:28.686]                   ...future.strategy.old <- future::plan("list")
[17:02:28.686]                   options(future.plan = NULL)
[17:02:28.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.686]                 }
[17:02:28.686]                 ...future.workdir <- getwd()
[17:02:28.686]             }
[17:02:28.686]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.686]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.686]         }
[17:02:28.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.686]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.686]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.686]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.686]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.686]             base::names(...future.oldOptions))
[17:02:28.686]     }
[17:02:28.686]     if (FALSE) {
[17:02:28.686]     }
[17:02:28.686]     else {
[17:02:28.686]         if (TRUE) {
[17:02:28.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.686]                 open = "w")
[17:02:28.686]         }
[17:02:28.686]         else {
[17:02:28.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.686]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.686]         }
[17:02:28.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.686]             base::sink(type = "output", split = FALSE)
[17:02:28.686]             base::close(...future.stdout)
[17:02:28.686]         }, add = TRUE)
[17:02:28.686]     }
[17:02:28.686]     ...future.frame <- base::sys.nframe()
[17:02:28.686]     ...future.conditions <- base::list()
[17:02:28.686]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.686]     if (FALSE) {
[17:02:28.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.686]     }
[17:02:28.686]     ...future.result <- base::tryCatch({
[17:02:28.686]         base::withCallingHandlers({
[17:02:28.686]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:28.686]             future::FutureResult(value = ...future.value$value, 
[17:02:28.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.686]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.686]                     ...future.globalenv.names))
[17:02:28.686]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.686]         }, condition = base::local({
[17:02:28.686]             c <- base::c
[17:02:28.686]             inherits <- base::inherits
[17:02:28.686]             invokeRestart <- base::invokeRestart
[17:02:28.686]             length <- base::length
[17:02:28.686]             list <- base::list
[17:02:28.686]             seq.int <- base::seq.int
[17:02:28.686]             signalCondition <- base::signalCondition
[17:02:28.686]             sys.calls <- base::sys.calls
[17:02:28.686]             `[[` <- base::`[[`
[17:02:28.686]             `+` <- base::`+`
[17:02:28.686]             `<<-` <- base::`<<-`
[17:02:28.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.686]                   3L)]
[17:02:28.686]             }
[17:02:28.686]             function(cond) {
[17:02:28.686]                 is_error <- inherits(cond, "error")
[17:02:28.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.686]                   NULL)
[17:02:28.686]                 if (is_error) {
[17:02:28.686]                   sessionInformation <- function() {
[17:02:28.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.686]                       search = base::search(), system = base::Sys.info())
[17:02:28.686]                   }
[17:02:28.686]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.686]                     cond$call), session = sessionInformation(), 
[17:02:28.686]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.686]                   signalCondition(cond)
[17:02:28.686]                 }
[17:02:28.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.686]                 "immediateCondition"))) {
[17:02:28.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.686]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.686]                   if (TRUE && !signal) {
[17:02:28.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.686]                     {
[17:02:28.686]                       inherits <- base::inherits
[17:02:28.686]                       invokeRestart <- base::invokeRestart
[17:02:28.686]                       is.null <- base::is.null
[17:02:28.686]                       muffled <- FALSE
[17:02:28.686]                       if (inherits(cond, "message")) {
[17:02:28.686]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.686]                         if (muffled) 
[17:02:28.686]                           invokeRestart("muffleMessage")
[17:02:28.686]                       }
[17:02:28.686]                       else if (inherits(cond, "warning")) {
[17:02:28.686]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.686]                         if (muffled) 
[17:02:28.686]                           invokeRestart("muffleWarning")
[17:02:28.686]                       }
[17:02:28.686]                       else if (inherits(cond, "condition")) {
[17:02:28.686]                         if (!is.null(pattern)) {
[17:02:28.686]                           computeRestarts <- base::computeRestarts
[17:02:28.686]                           grepl <- base::grepl
[17:02:28.686]                           restarts <- computeRestarts(cond)
[17:02:28.686]                           for (restart in restarts) {
[17:02:28.686]                             name <- restart$name
[17:02:28.686]                             if (is.null(name)) 
[17:02:28.686]                               next
[17:02:28.686]                             if (!grepl(pattern, name)) 
[17:02:28.686]                               next
[17:02:28.686]                             invokeRestart(restart)
[17:02:28.686]                             muffled <- TRUE
[17:02:28.686]                             break
[17:02:28.686]                           }
[17:02:28.686]                         }
[17:02:28.686]                       }
[17:02:28.686]                       invisible(muffled)
[17:02:28.686]                     }
[17:02:28.686]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.686]                   }
[17:02:28.686]                 }
[17:02:28.686]                 else {
[17:02:28.686]                   if (TRUE) {
[17:02:28.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.686]                     {
[17:02:28.686]                       inherits <- base::inherits
[17:02:28.686]                       invokeRestart <- base::invokeRestart
[17:02:28.686]                       is.null <- base::is.null
[17:02:28.686]                       muffled <- FALSE
[17:02:28.686]                       if (inherits(cond, "message")) {
[17:02:28.686]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.686]                         if (muffled) 
[17:02:28.686]                           invokeRestart("muffleMessage")
[17:02:28.686]                       }
[17:02:28.686]                       else if (inherits(cond, "warning")) {
[17:02:28.686]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.686]                         if (muffled) 
[17:02:28.686]                           invokeRestart("muffleWarning")
[17:02:28.686]                       }
[17:02:28.686]                       else if (inherits(cond, "condition")) {
[17:02:28.686]                         if (!is.null(pattern)) {
[17:02:28.686]                           computeRestarts <- base::computeRestarts
[17:02:28.686]                           grepl <- base::grepl
[17:02:28.686]                           restarts <- computeRestarts(cond)
[17:02:28.686]                           for (restart in restarts) {
[17:02:28.686]                             name <- restart$name
[17:02:28.686]                             if (is.null(name)) 
[17:02:28.686]                               next
[17:02:28.686]                             if (!grepl(pattern, name)) 
[17:02:28.686]                               next
[17:02:28.686]                             invokeRestart(restart)
[17:02:28.686]                             muffled <- TRUE
[17:02:28.686]                             break
[17:02:28.686]                           }
[17:02:28.686]                         }
[17:02:28.686]                       }
[17:02:28.686]                       invisible(muffled)
[17:02:28.686]                     }
[17:02:28.686]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.686]                   }
[17:02:28.686]                 }
[17:02:28.686]             }
[17:02:28.686]         }))
[17:02:28.686]     }, error = function(ex) {
[17:02:28.686]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.686]                 ...future.rng), started = ...future.startTime, 
[17:02:28.686]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.686]             version = "1.8"), class = "FutureResult")
[17:02:28.686]     }, finally = {
[17:02:28.686]         if (!identical(...future.workdir, getwd())) 
[17:02:28.686]             setwd(...future.workdir)
[17:02:28.686]         {
[17:02:28.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.686]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.686]             }
[17:02:28.686]             base::options(...future.oldOptions)
[17:02:28.686]             if (.Platform$OS.type == "windows") {
[17:02:28.686]                 old_names <- names(...future.oldEnvVars)
[17:02:28.686]                 envs <- base::Sys.getenv()
[17:02:28.686]                 names <- names(envs)
[17:02:28.686]                 common <- intersect(names, old_names)
[17:02:28.686]                 added <- setdiff(names, old_names)
[17:02:28.686]                 removed <- setdiff(old_names, names)
[17:02:28.686]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.686]                   envs[common]]
[17:02:28.686]                 NAMES <- toupper(changed)
[17:02:28.686]                 args <- list()
[17:02:28.686]                 for (kk in seq_along(NAMES)) {
[17:02:28.686]                   name <- changed[[kk]]
[17:02:28.686]                   NAME <- NAMES[[kk]]
[17:02:28.686]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.686]                     next
[17:02:28.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.686]                 }
[17:02:28.686]                 NAMES <- toupper(added)
[17:02:28.686]                 for (kk in seq_along(NAMES)) {
[17:02:28.686]                   name <- added[[kk]]
[17:02:28.686]                   NAME <- NAMES[[kk]]
[17:02:28.686]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.686]                     next
[17:02:28.686]                   args[[name]] <- ""
[17:02:28.686]                 }
[17:02:28.686]                 NAMES <- toupper(removed)
[17:02:28.686]                 for (kk in seq_along(NAMES)) {
[17:02:28.686]                   name <- removed[[kk]]
[17:02:28.686]                   NAME <- NAMES[[kk]]
[17:02:28.686]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.686]                     next
[17:02:28.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.686]                 }
[17:02:28.686]                 if (length(args) > 0) 
[17:02:28.686]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.686]             }
[17:02:28.686]             else {
[17:02:28.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.686]             }
[17:02:28.686]             {
[17:02:28.686]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.686]                   0L) {
[17:02:28.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.686]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.686]                   base::options(opts)
[17:02:28.686]                 }
[17:02:28.686]                 {
[17:02:28.686]                   {
[17:02:28.686]                     NULL
[17:02:28.686]                     RNGkind("Mersenne-Twister")
[17:02:28.686]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.686]                       inherits = FALSE)
[17:02:28.686]                   }
[17:02:28.686]                   options(future.plan = NULL)
[17:02:28.686]                   if (is.na(NA_character_)) 
[17:02:28.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.686]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.686]                     .init = FALSE)
[17:02:28.686]                 }
[17:02:28.686]             }
[17:02:28.686]         }
[17:02:28.686]     })
[17:02:28.686]     if (TRUE) {
[17:02:28.686]         base::sink(type = "output", split = FALSE)
[17:02:28.686]         if (TRUE) {
[17:02:28.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.686]         }
[17:02:28.686]         else {
[17:02:28.686]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.686]         }
[17:02:28.686]         base::close(...future.stdout)
[17:02:28.686]         ...future.stdout <- NULL
[17:02:28.686]     }
[17:02:28.686]     ...future.result$conditions <- ...future.conditions
[17:02:28.686]     ...future.result$finished <- base::Sys.time()
[17:02:28.686]     ...future.result
[17:02:28.686] }
[17:02:28.687] plan(): Setting new future strategy stack:
[17:02:28.687] List of future strategies:
[17:02:28.687] 1. sequential:
[17:02:28.687]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.687]    - tweaked: FALSE
[17:02:28.687]    - call: NULL
[17:02:28.688] plan(): nbrOfWorkers() = 1
[17:02:28.689] plan(): Setting new future strategy stack:
[17:02:28.689] List of future strategies:
[17:02:28.689] 1. sequential:
[17:02:28.689]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.689]    - tweaked: FALSE
[17:02:28.689]    - call: plan(strategy)
[17:02:28.689] plan(): nbrOfWorkers() = 1
[17:02:28.689] SequentialFuture started (and completed)
[17:02:28.689] - Launch lazy future ... done
[17:02:28.689] run() for ‘SequentialFuture’ ... done
[17:02:28.691] getGlobalsAndPackages() ...
[17:02:28.691] Searching for globals...
[17:02:28.692] - globals found: [1] ‘{’
[17:02:28.692] Searching for globals ... DONE
[17:02:28.692] Resolving globals: FALSE
[17:02:28.693] 
[17:02:28.693] 
[17:02:28.693] getGlobalsAndPackages() ... DONE
[17:02:28.693] run() for ‘Future’ ...
[17:02:28.693] - state: ‘created’
[17:02:28.693] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.694] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.694] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.694]   - Field: ‘label’
[17:02:28.694]   - Field: ‘local’
[17:02:28.694]   - Field: ‘owner’
[17:02:28.694]   - Field: ‘envir’
[17:02:28.694]   - Field: ‘packages’
[17:02:28.694]   - Field: ‘gc’
[17:02:28.694]   - Field: ‘conditions’
[17:02:28.695]   - Field: ‘expr’
[17:02:28.695]   - Field: ‘uuid’
[17:02:28.695]   - Field: ‘seed’
[17:02:28.695]   - Field: ‘version’
[17:02:28.695]   - Field: ‘result’
[17:02:28.695]   - Field: ‘asynchronous’
[17:02:28.695]   - Field: ‘calls’
[17:02:28.695]   - Field: ‘globals’
[17:02:28.695]   - Field: ‘stdout’
[17:02:28.695]   - Field: ‘earlySignal’
[17:02:28.695]   - Field: ‘lazy’
[17:02:28.696]   - Field: ‘state’
[17:02:28.696] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.696] - Launch lazy future ...
[17:02:28.696] Packages needed by the future expression (n = 0): <none>
[17:02:28.696] Packages needed by future strategies (n = 0): <none>
[17:02:28.696] {
[17:02:28.696]     {
[17:02:28.696]         {
[17:02:28.696]             ...future.startTime <- base::Sys.time()
[17:02:28.696]             {
[17:02:28.696]                 {
[17:02:28.696]                   {
[17:02:28.696]                     base::local({
[17:02:28.696]                       has_future <- base::requireNamespace("future", 
[17:02:28.696]                         quietly = TRUE)
[17:02:28.696]                       if (has_future) {
[17:02:28.696]                         ns <- base::getNamespace("future")
[17:02:28.696]                         version <- ns[[".package"]][["version"]]
[17:02:28.696]                         if (is.null(version)) 
[17:02:28.696]                           version <- utils::packageVersion("future")
[17:02:28.696]                       }
[17:02:28.696]                       else {
[17:02:28.696]                         version <- NULL
[17:02:28.696]                       }
[17:02:28.696]                       if (!has_future || version < "1.8.0") {
[17:02:28.696]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.696]                           "", base::R.version$version.string), 
[17:02:28.696]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.696]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.696]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.696]                             "release", "version")], collapse = " "), 
[17:02:28.696]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.696]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.696]                           info)
[17:02:28.696]                         info <- base::paste(info, collapse = "; ")
[17:02:28.696]                         if (!has_future) {
[17:02:28.696]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.696]                             info)
[17:02:28.696]                         }
[17:02:28.696]                         else {
[17:02:28.696]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.696]                             info, version)
[17:02:28.696]                         }
[17:02:28.696]                         base::stop(msg)
[17:02:28.696]                       }
[17:02:28.696]                     })
[17:02:28.696]                   }
[17:02:28.696]                   ...future.strategy.old <- future::plan("list")
[17:02:28.696]                   options(future.plan = NULL)
[17:02:28.696]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.696]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.696]                 }
[17:02:28.696]                 ...future.workdir <- getwd()
[17:02:28.696]             }
[17:02:28.696]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.696]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.696]         }
[17:02:28.696]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.696]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.696]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.696]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.696]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.696]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.696]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.696]             base::names(...future.oldOptions))
[17:02:28.696]     }
[17:02:28.696]     if (FALSE) {
[17:02:28.696]     }
[17:02:28.696]     else {
[17:02:28.696]         if (TRUE) {
[17:02:28.696]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.696]                 open = "w")
[17:02:28.696]         }
[17:02:28.696]         else {
[17:02:28.696]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.696]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.696]         }
[17:02:28.696]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.696]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.696]             base::sink(type = "output", split = FALSE)
[17:02:28.696]             base::close(...future.stdout)
[17:02:28.696]         }, add = TRUE)
[17:02:28.696]     }
[17:02:28.696]     ...future.frame <- base::sys.nframe()
[17:02:28.696]     ...future.conditions <- base::list()
[17:02:28.696]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.696]     if (FALSE) {
[17:02:28.696]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.696]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.696]     }
[17:02:28.696]     ...future.result <- base::tryCatch({
[17:02:28.696]         base::withCallingHandlers({
[17:02:28.696]             ...future.value <- base::withVisible(base::local({
[17:02:28.696]                 4
[17:02:28.696]             }))
[17:02:28.696]             future::FutureResult(value = ...future.value$value, 
[17:02:28.696]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.696]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.696]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.696]                     ...future.globalenv.names))
[17:02:28.696]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.696]         }, condition = base::local({
[17:02:28.696]             c <- base::c
[17:02:28.696]             inherits <- base::inherits
[17:02:28.696]             invokeRestart <- base::invokeRestart
[17:02:28.696]             length <- base::length
[17:02:28.696]             list <- base::list
[17:02:28.696]             seq.int <- base::seq.int
[17:02:28.696]             signalCondition <- base::signalCondition
[17:02:28.696]             sys.calls <- base::sys.calls
[17:02:28.696]             `[[` <- base::`[[`
[17:02:28.696]             `+` <- base::`+`
[17:02:28.696]             `<<-` <- base::`<<-`
[17:02:28.696]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.696]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.696]                   3L)]
[17:02:28.696]             }
[17:02:28.696]             function(cond) {
[17:02:28.696]                 is_error <- inherits(cond, "error")
[17:02:28.696]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.696]                   NULL)
[17:02:28.696]                 if (is_error) {
[17:02:28.696]                   sessionInformation <- function() {
[17:02:28.696]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.696]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.696]                       search = base::search(), system = base::Sys.info())
[17:02:28.696]                   }
[17:02:28.696]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.696]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.696]                     cond$call), session = sessionInformation(), 
[17:02:28.696]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.696]                   signalCondition(cond)
[17:02:28.696]                 }
[17:02:28.696]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.696]                 "immediateCondition"))) {
[17:02:28.696]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.696]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.696]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.696]                   if (TRUE && !signal) {
[17:02:28.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.696]                     {
[17:02:28.696]                       inherits <- base::inherits
[17:02:28.696]                       invokeRestart <- base::invokeRestart
[17:02:28.696]                       is.null <- base::is.null
[17:02:28.696]                       muffled <- FALSE
[17:02:28.696]                       if (inherits(cond, "message")) {
[17:02:28.696]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.696]                         if (muffled) 
[17:02:28.696]                           invokeRestart("muffleMessage")
[17:02:28.696]                       }
[17:02:28.696]                       else if (inherits(cond, "warning")) {
[17:02:28.696]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.696]                         if (muffled) 
[17:02:28.696]                           invokeRestart("muffleWarning")
[17:02:28.696]                       }
[17:02:28.696]                       else if (inherits(cond, "condition")) {
[17:02:28.696]                         if (!is.null(pattern)) {
[17:02:28.696]                           computeRestarts <- base::computeRestarts
[17:02:28.696]                           grepl <- base::grepl
[17:02:28.696]                           restarts <- computeRestarts(cond)
[17:02:28.696]                           for (restart in restarts) {
[17:02:28.696]                             name <- restart$name
[17:02:28.696]                             if (is.null(name)) 
[17:02:28.696]                               next
[17:02:28.696]                             if (!grepl(pattern, name)) 
[17:02:28.696]                               next
[17:02:28.696]                             invokeRestart(restart)
[17:02:28.696]                             muffled <- TRUE
[17:02:28.696]                             break
[17:02:28.696]                           }
[17:02:28.696]                         }
[17:02:28.696]                       }
[17:02:28.696]                       invisible(muffled)
[17:02:28.696]                     }
[17:02:28.696]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.696]                   }
[17:02:28.696]                 }
[17:02:28.696]                 else {
[17:02:28.696]                   if (TRUE) {
[17:02:28.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.696]                     {
[17:02:28.696]                       inherits <- base::inherits
[17:02:28.696]                       invokeRestart <- base::invokeRestart
[17:02:28.696]                       is.null <- base::is.null
[17:02:28.696]                       muffled <- FALSE
[17:02:28.696]                       if (inherits(cond, "message")) {
[17:02:28.696]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.696]                         if (muffled) 
[17:02:28.696]                           invokeRestart("muffleMessage")
[17:02:28.696]                       }
[17:02:28.696]                       else if (inherits(cond, "warning")) {
[17:02:28.696]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.696]                         if (muffled) 
[17:02:28.696]                           invokeRestart("muffleWarning")
[17:02:28.696]                       }
[17:02:28.696]                       else if (inherits(cond, "condition")) {
[17:02:28.696]                         if (!is.null(pattern)) {
[17:02:28.696]                           computeRestarts <- base::computeRestarts
[17:02:28.696]                           grepl <- base::grepl
[17:02:28.696]                           restarts <- computeRestarts(cond)
[17:02:28.696]                           for (restart in restarts) {
[17:02:28.696]                             name <- restart$name
[17:02:28.696]                             if (is.null(name)) 
[17:02:28.696]                               next
[17:02:28.696]                             if (!grepl(pattern, name)) 
[17:02:28.696]                               next
[17:02:28.696]                             invokeRestart(restart)
[17:02:28.696]                             muffled <- TRUE
[17:02:28.696]                             break
[17:02:28.696]                           }
[17:02:28.696]                         }
[17:02:28.696]                       }
[17:02:28.696]                       invisible(muffled)
[17:02:28.696]                     }
[17:02:28.696]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.696]                   }
[17:02:28.696]                 }
[17:02:28.696]             }
[17:02:28.696]         }))
[17:02:28.696]     }, error = function(ex) {
[17:02:28.696]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.696]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.696]                 ...future.rng), started = ...future.startTime, 
[17:02:28.696]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.696]             version = "1.8"), class = "FutureResult")
[17:02:28.696]     }, finally = {
[17:02:28.696]         if (!identical(...future.workdir, getwd())) 
[17:02:28.696]             setwd(...future.workdir)
[17:02:28.696]         {
[17:02:28.696]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.696]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.696]             }
[17:02:28.696]             base::options(...future.oldOptions)
[17:02:28.696]             if (.Platform$OS.type == "windows") {
[17:02:28.696]                 old_names <- names(...future.oldEnvVars)
[17:02:28.696]                 envs <- base::Sys.getenv()
[17:02:28.696]                 names <- names(envs)
[17:02:28.696]                 common <- intersect(names, old_names)
[17:02:28.696]                 added <- setdiff(names, old_names)
[17:02:28.696]                 removed <- setdiff(old_names, names)
[17:02:28.696]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.696]                   envs[common]]
[17:02:28.696]                 NAMES <- toupper(changed)
[17:02:28.696]                 args <- list()
[17:02:28.696]                 for (kk in seq_along(NAMES)) {
[17:02:28.696]                   name <- changed[[kk]]
[17:02:28.696]                   NAME <- NAMES[[kk]]
[17:02:28.696]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.696]                     next
[17:02:28.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.696]                 }
[17:02:28.696]                 NAMES <- toupper(added)
[17:02:28.696]                 for (kk in seq_along(NAMES)) {
[17:02:28.696]                   name <- added[[kk]]
[17:02:28.696]                   NAME <- NAMES[[kk]]
[17:02:28.696]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.696]                     next
[17:02:28.696]                   args[[name]] <- ""
[17:02:28.696]                 }
[17:02:28.696]                 NAMES <- toupper(removed)
[17:02:28.696]                 for (kk in seq_along(NAMES)) {
[17:02:28.696]                   name <- removed[[kk]]
[17:02:28.696]                   NAME <- NAMES[[kk]]
[17:02:28.696]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.696]                     next
[17:02:28.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.696]                 }
[17:02:28.696]                 if (length(args) > 0) 
[17:02:28.696]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.696]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.696]             }
[17:02:28.696]             else {
[17:02:28.696]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.696]             }
[17:02:28.696]             {
[17:02:28.696]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.696]                   0L) {
[17:02:28.696]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.696]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.696]                   base::options(opts)
[17:02:28.696]                 }
[17:02:28.696]                 {
[17:02:28.696]                   {
[17:02:28.696]                     NULL
[17:02:28.696]                     RNGkind("Mersenne-Twister")
[17:02:28.696]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.696]                       inherits = FALSE)
[17:02:28.696]                   }
[17:02:28.696]                   options(future.plan = NULL)
[17:02:28.696]                   if (is.na(NA_character_)) 
[17:02:28.696]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.696]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.696]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.696]                     .init = FALSE)
[17:02:28.696]                 }
[17:02:28.696]             }
[17:02:28.696]         }
[17:02:28.696]     })
[17:02:28.696]     if (TRUE) {
[17:02:28.696]         base::sink(type = "output", split = FALSE)
[17:02:28.696]         if (TRUE) {
[17:02:28.696]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.696]         }
[17:02:28.696]         else {
[17:02:28.696]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.696]         }
[17:02:28.696]         base::close(...future.stdout)
[17:02:28.696]         ...future.stdout <- NULL
[17:02:28.696]     }
[17:02:28.696]     ...future.result$conditions <- ...future.conditions
[17:02:28.696]     ...future.result$finished <- base::Sys.time()
[17:02:28.696]     ...future.result
[17:02:28.696] }
[17:02:28.698] plan(): Setting new future strategy stack:
[17:02:28.698] List of future strategies:
[17:02:28.698] 1. sequential:
[17:02:28.698]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.698]    - tweaked: FALSE
[17:02:28.698]    - call: NULL
[17:02:28.699] plan(): nbrOfWorkers() = 1
[17:02:28.699] plan(): Setting new future strategy stack:
[17:02:28.700] List of future strategies:
[17:02:28.700] 1. sequential:
[17:02:28.700]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.700]    - tweaked: FALSE
[17:02:28.700]    - call: plan(strategy)
[17:02:28.700] plan(): nbrOfWorkers() = 1
[17:02:28.700] SequentialFuture started (and completed)
[17:02:28.700] - Launch lazy future ... done
[17:02:28.700] run() for ‘SequentialFuture’ ... done
<environment: 0x55c749712270> 
<environment: 0x55c7493ec9b8> 
[17:02:28.702] resolved() for ‘SequentialFuture’ ...
[17:02:28.702] - state: ‘finished’
[17:02:28.702] - run: TRUE
[17:02:28.702] - result: ‘FutureResult’
[17:02:28.702] resolved() for ‘SequentialFuture’ ... done
[17:02:28.702] resolved() for ‘SequentialFuture’ ...
[17:02:28.702] - state: ‘finished’
[17:02:28.702] - run: TRUE
[17:02:28.703] - result: ‘FutureResult’
[17:02:28.703] resolved() for ‘SequentialFuture’ ... done
[17:02:28.703] resolved() for ‘SequentialFuture’ ...
[17:02:28.703] - state: ‘finished’
[17:02:28.703] - run: TRUE
[17:02:28.703] - result: ‘FutureResult’
[17:02:28.703] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:28.704] resolve() on environment ...
[17:02:28.705]  recursive: 0
[17:02:28.705]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:28.705] signalConditionsASAP(numeric, pos=1) ...
[17:02:28.705] - nx: 4
[17:02:28.705] - relay: TRUE
[17:02:28.705] - stdout: TRUE
[17:02:28.705] - signal: TRUE
[17:02:28.706] - resignal: FALSE
[17:02:28.706] - force: TRUE
[17:02:28.706] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.706] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.706]  - until=2
[17:02:28.706]  - relaying element #2
[17:02:28.706] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:28.706] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.706] signalConditionsASAP(NULL, pos=1) ... done
[17:02:28.706]  length: 3 (resolved future 1)
[17:02:28.706] resolved() for ‘SequentialFuture’ ...
[17:02:28.707] - state: ‘finished’
[17:02:28.707] - run: TRUE
[17:02:28.707] - result: ‘FutureResult’
[17:02:28.707] resolved() for ‘SequentialFuture’ ... done
[17:02:28.707] Future #2
[17:02:28.707] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:28.707] - nx: 4
[17:02:28.707] - relay: TRUE
[17:02:28.707] - stdout: TRUE
[17:02:28.707] - signal: TRUE
[17:02:28.707] - resignal: FALSE
[17:02:28.708] - force: TRUE
[17:02:28.708] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:28.708] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.708]  - until=2
[17:02:28.708]  - relaying element #2
[17:02:28.708] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:28.708] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:28.708] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:28.708]  length: 2 (resolved future 2)
[17:02:28.708] resolved() for ‘SequentialFuture’ ...
[17:02:28.709] - state: ‘finished’
[17:02:28.709] - run: TRUE
[17:02:28.709] - result: ‘FutureResult’
[17:02:28.709] resolved() for ‘SequentialFuture’ ... done
[17:02:28.709] Future #3
[17:02:28.709] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:28.709] - nx: 4
[17:02:28.709] - relay: TRUE
[17:02:28.709] - stdout: TRUE
[17:02:28.709] - signal: TRUE
[17:02:28.709] - resignal: FALSE
[17:02:28.710] - force: TRUE
[17:02:28.710] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:28.710] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:28.710]  - until=3
[17:02:28.710]  - relaying element #3
[17:02:28.710] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:28.710] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:28.710] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:28.710]  length: 1 (resolved future 3)
[17:02:28.710] resolved() for ‘SequentialFuture’ ...
[17:02:28.711] - state: ‘finished’
[17:02:28.711] - run: TRUE
[17:02:28.711] - result: ‘FutureResult’
[17:02:28.711] resolved() for ‘SequentialFuture’ ... done
[17:02:28.711] Future #4
[17:02:28.711] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:02:28.711] - nx: 4
[17:02:28.711] - relay: TRUE
[17:02:28.711] - stdout: TRUE
[17:02:28.711] - signal: TRUE
[17:02:28.711] - resignal: FALSE
[17:02:28.712] - force: TRUE
[17:02:28.712] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:28.712] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:28.712]  - until=4
[17:02:28.712]  - relaying element #4
[17:02:28.712] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.712] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:28.712] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:02:28.712]  length: 0 (resolved future 4)
[17:02:28.712] Relaying remaining futures
[17:02:28.712] signalConditionsASAP(NULL, pos=0) ...
[17:02:28.713] - nx: 4
[17:02:28.713] - relay: TRUE
[17:02:28.713] - stdout: TRUE
[17:02:28.713] - signal: TRUE
[17:02:28.713] - resignal: FALSE
[17:02:28.713] - force: TRUE
[17:02:28.713] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.713] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:28.715] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.715] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:28.715] signalConditionsASAP(NULL, pos=0) ... done
[17:02:28.716] resolve() on environment ... DONE
<environment: 0x55c7495a2de0> 
Dimensions: c(1, 6)
[17:02:28.716] getGlobalsAndPackages() ...
[17:02:28.716] Searching for globals...
[17:02:28.716] 
[17:02:28.717] Searching for globals ... DONE
[17:02:28.717] - globals: [0] <none>
[17:02:28.717] getGlobalsAndPackages() ... DONE
[17:02:28.717] run() for ‘Future’ ...
[17:02:28.717] - state: ‘created’
[17:02:28.717] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.717] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.718] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.718]   - Field: ‘label’
[17:02:28.718]   - Field: ‘local’
[17:02:28.718]   - Field: ‘owner’
[17:02:28.718]   - Field: ‘envir’
[17:02:28.718]   - Field: ‘packages’
[17:02:28.718]   - Field: ‘gc’
[17:02:28.718]   - Field: ‘conditions’
[17:02:28.718]   - Field: ‘expr’
[17:02:28.718]   - Field: ‘uuid’
[17:02:28.719]   - Field: ‘seed’
[17:02:28.719]   - Field: ‘version’
[17:02:28.719]   - Field: ‘result’
[17:02:28.719]   - Field: ‘asynchronous’
[17:02:28.719]   - Field: ‘calls’
[17:02:28.719]   - Field: ‘globals’
[17:02:28.719]   - Field: ‘stdout’
[17:02:28.719]   - Field: ‘earlySignal’
[17:02:28.719]   - Field: ‘lazy’
[17:02:28.719]   - Field: ‘state’
[17:02:28.719] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.720] - Launch lazy future ...
[17:02:28.720] Packages needed by the future expression (n = 0): <none>
[17:02:28.720] Packages needed by future strategies (n = 0): <none>
[17:02:28.720] {
[17:02:28.720]     {
[17:02:28.720]         {
[17:02:28.720]             ...future.startTime <- base::Sys.time()
[17:02:28.720]             {
[17:02:28.720]                 {
[17:02:28.720]                   {
[17:02:28.720]                     base::local({
[17:02:28.720]                       has_future <- base::requireNamespace("future", 
[17:02:28.720]                         quietly = TRUE)
[17:02:28.720]                       if (has_future) {
[17:02:28.720]                         ns <- base::getNamespace("future")
[17:02:28.720]                         version <- ns[[".package"]][["version"]]
[17:02:28.720]                         if (is.null(version)) 
[17:02:28.720]                           version <- utils::packageVersion("future")
[17:02:28.720]                       }
[17:02:28.720]                       else {
[17:02:28.720]                         version <- NULL
[17:02:28.720]                       }
[17:02:28.720]                       if (!has_future || version < "1.8.0") {
[17:02:28.720]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.720]                           "", base::R.version$version.string), 
[17:02:28.720]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.720]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.720]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.720]                             "release", "version")], collapse = " "), 
[17:02:28.720]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.720]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.720]                           info)
[17:02:28.720]                         info <- base::paste(info, collapse = "; ")
[17:02:28.720]                         if (!has_future) {
[17:02:28.720]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.720]                             info)
[17:02:28.720]                         }
[17:02:28.720]                         else {
[17:02:28.720]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.720]                             info, version)
[17:02:28.720]                         }
[17:02:28.720]                         base::stop(msg)
[17:02:28.720]                       }
[17:02:28.720]                     })
[17:02:28.720]                   }
[17:02:28.720]                   ...future.strategy.old <- future::plan("list")
[17:02:28.720]                   options(future.plan = NULL)
[17:02:28.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.720]                 }
[17:02:28.720]                 ...future.workdir <- getwd()
[17:02:28.720]             }
[17:02:28.720]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.720]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.720]         }
[17:02:28.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.720]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.720]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.720]             base::names(...future.oldOptions))
[17:02:28.720]     }
[17:02:28.720]     if (FALSE) {
[17:02:28.720]     }
[17:02:28.720]     else {
[17:02:28.720]         if (TRUE) {
[17:02:28.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.720]                 open = "w")
[17:02:28.720]         }
[17:02:28.720]         else {
[17:02:28.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.720]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.720]         }
[17:02:28.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.720]             base::sink(type = "output", split = FALSE)
[17:02:28.720]             base::close(...future.stdout)
[17:02:28.720]         }, add = TRUE)
[17:02:28.720]     }
[17:02:28.720]     ...future.frame <- base::sys.nframe()
[17:02:28.720]     ...future.conditions <- base::list()
[17:02:28.720]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.720]     if (FALSE) {
[17:02:28.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.720]     }
[17:02:28.720]     ...future.result <- base::tryCatch({
[17:02:28.720]         base::withCallingHandlers({
[17:02:28.720]             ...future.value <- base::withVisible(base::local(2))
[17:02:28.720]             future::FutureResult(value = ...future.value$value, 
[17:02:28.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.720]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.720]                     ...future.globalenv.names))
[17:02:28.720]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.720]         }, condition = base::local({
[17:02:28.720]             c <- base::c
[17:02:28.720]             inherits <- base::inherits
[17:02:28.720]             invokeRestart <- base::invokeRestart
[17:02:28.720]             length <- base::length
[17:02:28.720]             list <- base::list
[17:02:28.720]             seq.int <- base::seq.int
[17:02:28.720]             signalCondition <- base::signalCondition
[17:02:28.720]             sys.calls <- base::sys.calls
[17:02:28.720]             `[[` <- base::`[[`
[17:02:28.720]             `+` <- base::`+`
[17:02:28.720]             `<<-` <- base::`<<-`
[17:02:28.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.720]                   3L)]
[17:02:28.720]             }
[17:02:28.720]             function(cond) {
[17:02:28.720]                 is_error <- inherits(cond, "error")
[17:02:28.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.720]                   NULL)
[17:02:28.720]                 if (is_error) {
[17:02:28.720]                   sessionInformation <- function() {
[17:02:28.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.720]                       search = base::search(), system = base::Sys.info())
[17:02:28.720]                   }
[17:02:28.720]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.720]                     cond$call), session = sessionInformation(), 
[17:02:28.720]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.720]                   signalCondition(cond)
[17:02:28.720]                 }
[17:02:28.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.720]                 "immediateCondition"))) {
[17:02:28.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.720]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.720]                   if (TRUE && !signal) {
[17:02:28.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.720]                     {
[17:02:28.720]                       inherits <- base::inherits
[17:02:28.720]                       invokeRestart <- base::invokeRestart
[17:02:28.720]                       is.null <- base::is.null
[17:02:28.720]                       muffled <- FALSE
[17:02:28.720]                       if (inherits(cond, "message")) {
[17:02:28.720]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.720]                         if (muffled) 
[17:02:28.720]                           invokeRestart("muffleMessage")
[17:02:28.720]                       }
[17:02:28.720]                       else if (inherits(cond, "warning")) {
[17:02:28.720]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.720]                         if (muffled) 
[17:02:28.720]                           invokeRestart("muffleWarning")
[17:02:28.720]                       }
[17:02:28.720]                       else if (inherits(cond, "condition")) {
[17:02:28.720]                         if (!is.null(pattern)) {
[17:02:28.720]                           computeRestarts <- base::computeRestarts
[17:02:28.720]                           grepl <- base::grepl
[17:02:28.720]                           restarts <- computeRestarts(cond)
[17:02:28.720]                           for (restart in restarts) {
[17:02:28.720]                             name <- restart$name
[17:02:28.720]                             if (is.null(name)) 
[17:02:28.720]                               next
[17:02:28.720]                             if (!grepl(pattern, name)) 
[17:02:28.720]                               next
[17:02:28.720]                             invokeRestart(restart)
[17:02:28.720]                             muffled <- TRUE
[17:02:28.720]                             break
[17:02:28.720]                           }
[17:02:28.720]                         }
[17:02:28.720]                       }
[17:02:28.720]                       invisible(muffled)
[17:02:28.720]                     }
[17:02:28.720]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.720]                   }
[17:02:28.720]                 }
[17:02:28.720]                 else {
[17:02:28.720]                   if (TRUE) {
[17:02:28.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.720]                     {
[17:02:28.720]                       inherits <- base::inherits
[17:02:28.720]                       invokeRestart <- base::invokeRestart
[17:02:28.720]                       is.null <- base::is.null
[17:02:28.720]                       muffled <- FALSE
[17:02:28.720]                       if (inherits(cond, "message")) {
[17:02:28.720]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.720]                         if (muffled) 
[17:02:28.720]                           invokeRestart("muffleMessage")
[17:02:28.720]                       }
[17:02:28.720]                       else if (inherits(cond, "warning")) {
[17:02:28.720]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.720]                         if (muffled) 
[17:02:28.720]                           invokeRestart("muffleWarning")
[17:02:28.720]                       }
[17:02:28.720]                       else if (inherits(cond, "condition")) {
[17:02:28.720]                         if (!is.null(pattern)) {
[17:02:28.720]                           computeRestarts <- base::computeRestarts
[17:02:28.720]                           grepl <- base::grepl
[17:02:28.720]                           restarts <- computeRestarts(cond)
[17:02:28.720]                           for (restart in restarts) {
[17:02:28.720]                             name <- restart$name
[17:02:28.720]                             if (is.null(name)) 
[17:02:28.720]                               next
[17:02:28.720]                             if (!grepl(pattern, name)) 
[17:02:28.720]                               next
[17:02:28.720]                             invokeRestart(restart)
[17:02:28.720]                             muffled <- TRUE
[17:02:28.720]                             break
[17:02:28.720]                           }
[17:02:28.720]                         }
[17:02:28.720]                       }
[17:02:28.720]                       invisible(muffled)
[17:02:28.720]                     }
[17:02:28.720]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.720]                   }
[17:02:28.720]                 }
[17:02:28.720]             }
[17:02:28.720]         }))
[17:02:28.720]     }, error = function(ex) {
[17:02:28.720]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.720]                 ...future.rng), started = ...future.startTime, 
[17:02:28.720]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.720]             version = "1.8"), class = "FutureResult")
[17:02:28.720]     }, finally = {
[17:02:28.720]         if (!identical(...future.workdir, getwd())) 
[17:02:28.720]             setwd(...future.workdir)
[17:02:28.720]         {
[17:02:28.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.720]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.720]             }
[17:02:28.720]             base::options(...future.oldOptions)
[17:02:28.720]             if (.Platform$OS.type == "windows") {
[17:02:28.720]                 old_names <- names(...future.oldEnvVars)
[17:02:28.720]                 envs <- base::Sys.getenv()
[17:02:28.720]                 names <- names(envs)
[17:02:28.720]                 common <- intersect(names, old_names)
[17:02:28.720]                 added <- setdiff(names, old_names)
[17:02:28.720]                 removed <- setdiff(old_names, names)
[17:02:28.720]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.720]                   envs[common]]
[17:02:28.720]                 NAMES <- toupper(changed)
[17:02:28.720]                 args <- list()
[17:02:28.720]                 for (kk in seq_along(NAMES)) {
[17:02:28.720]                   name <- changed[[kk]]
[17:02:28.720]                   NAME <- NAMES[[kk]]
[17:02:28.720]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.720]                     next
[17:02:28.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.720]                 }
[17:02:28.720]                 NAMES <- toupper(added)
[17:02:28.720]                 for (kk in seq_along(NAMES)) {
[17:02:28.720]                   name <- added[[kk]]
[17:02:28.720]                   NAME <- NAMES[[kk]]
[17:02:28.720]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.720]                     next
[17:02:28.720]                   args[[name]] <- ""
[17:02:28.720]                 }
[17:02:28.720]                 NAMES <- toupper(removed)
[17:02:28.720]                 for (kk in seq_along(NAMES)) {
[17:02:28.720]                   name <- removed[[kk]]
[17:02:28.720]                   NAME <- NAMES[[kk]]
[17:02:28.720]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.720]                     next
[17:02:28.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.720]                 }
[17:02:28.720]                 if (length(args) > 0) 
[17:02:28.720]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.720]             }
[17:02:28.720]             else {
[17:02:28.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.720]             }
[17:02:28.720]             {
[17:02:28.720]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.720]                   0L) {
[17:02:28.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.720]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.720]                   base::options(opts)
[17:02:28.720]                 }
[17:02:28.720]                 {
[17:02:28.720]                   {
[17:02:28.720]                     NULL
[17:02:28.720]                     RNGkind("Mersenne-Twister")
[17:02:28.720]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.720]                       inherits = FALSE)
[17:02:28.720]                   }
[17:02:28.720]                   options(future.plan = NULL)
[17:02:28.720]                   if (is.na(NA_character_)) 
[17:02:28.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.720]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.720]                     .init = FALSE)
[17:02:28.720]                 }
[17:02:28.720]             }
[17:02:28.720]         }
[17:02:28.720]     })
[17:02:28.720]     if (TRUE) {
[17:02:28.720]         base::sink(type = "output", split = FALSE)
[17:02:28.720]         if (TRUE) {
[17:02:28.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.720]         }
[17:02:28.720]         else {
[17:02:28.720]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.720]         }
[17:02:28.720]         base::close(...future.stdout)
[17:02:28.720]         ...future.stdout <- NULL
[17:02:28.720]     }
[17:02:28.720]     ...future.result$conditions <- ...future.conditions
[17:02:28.720]     ...future.result$finished <- base::Sys.time()
[17:02:28.720]     ...future.result
[17:02:28.720] }
[17:02:28.722] plan(): Setting new future strategy stack:
[17:02:28.722] List of future strategies:
[17:02:28.722] 1. sequential:
[17:02:28.722]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.722]    - tweaked: FALSE
[17:02:28.722]    - call: NULL
[17:02:28.722] plan(): nbrOfWorkers() = 1
[17:02:28.723] plan(): Setting new future strategy stack:
[17:02:28.723] List of future strategies:
[17:02:28.723] 1. sequential:
[17:02:28.723]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.723]    - tweaked: FALSE
[17:02:28.723]    - call: plan(strategy)
[17:02:28.724] plan(): nbrOfWorkers() = 1
[17:02:28.724] SequentialFuture started (and completed)
[17:02:28.724] - Launch lazy future ... done
[17:02:28.724] run() for ‘SequentialFuture’ ... done
[17:02:28.724] getGlobalsAndPackages() ...
[17:02:28.724] Searching for globals...
[17:02:28.725] 
[17:02:28.725] Searching for globals ... DONE
[17:02:28.725] - globals: [0] <none>
[17:02:28.725] getGlobalsAndPackages() ... DONE
[17:02:28.725] run() for ‘Future’ ...
[17:02:28.725] - state: ‘created’
[17:02:28.725] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.725] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.726] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.726]   - Field: ‘label’
[17:02:28.726]   - Field: ‘local’
[17:02:28.726]   - Field: ‘owner’
[17:02:28.726]   - Field: ‘envir’
[17:02:28.726]   - Field: ‘packages’
[17:02:28.726]   - Field: ‘gc’
[17:02:28.726]   - Field: ‘conditions’
[17:02:28.726]   - Field: ‘expr’
[17:02:28.726]   - Field: ‘uuid’
[17:02:28.726]   - Field: ‘seed’
[17:02:28.727]   - Field: ‘version’
[17:02:28.727]   - Field: ‘result’
[17:02:28.727]   - Field: ‘asynchronous’
[17:02:28.727]   - Field: ‘calls’
[17:02:28.727]   - Field: ‘globals’
[17:02:28.727]   - Field: ‘stdout’
[17:02:28.727]   - Field: ‘earlySignal’
[17:02:28.727]   - Field: ‘lazy’
[17:02:28.727]   - Field: ‘state’
[17:02:28.727] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.727] - Launch lazy future ...
[17:02:28.728] Packages needed by the future expression (n = 0): <none>
[17:02:28.728] Packages needed by future strategies (n = 0): <none>
[17:02:28.728] {
[17:02:28.728]     {
[17:02:28.728]         {
[17:02:28.728]             ...future.startTime <- base::Sys.time()
[17:02:28.728]             {
[17:02:28.728]                 {
[17:02:28.728]                   {
[17:02:28.728]                     base::local({
[17:02:28.728]                       has_future <- base::requireNamespace("future", 
[17:02:28.728]                         quietly = TRUE)
[17:02:28.728]                       if (has_future) {
[17:02:28.728]                         ns <- base::getNamespace("future")
[17:02:28.728]                         version <- ns[[".package"]][["version"]]
[17:02:28.728]                         if (is.null(version)) 
[17:02:28.728]                           version <- utils::packageVersion("future")
[17:02:28.728]                       }
[17:02:28.728]                       else {
[17:02:28.728]                         version <- NULL
[17:02:28.728]                       }
[17:02:28.728]                       if (!has_future || version < "1.8.0") {
[17:02:28.728]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.728]                           "", base::R.version$version.string), 
[17:02:28.728]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.728]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.728]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.728]                             "release", "version")], collapse = " "), 
[17:02:28.728]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.728]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.728]                           info)
[17:02:28.728]                         info <- base::paste(info, collapse = "; ")
[17:02:28.728]                         if (!has_future) {
[17:02:28.728]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.728]                             info)
[17:02:28.728]                         }
[17:02:28.728]                         else {
[17:02:28.728]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.728]                             info, version)
[17:02:28.728]                         }
[17:02:28.728]                         base::stop(msg)
[17:02:28.728]                       }
[17:02:28.728]                     })
[17:02:28.728]                   }
[17:02:28.728]                   ...future.strategy.old <- future::plan("list")
[17:02:28.728]                   options(future.plan = NULL)
[17:02:28.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.728]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.728]                 }
[17:02:28.728]                 ...future.workdir <- getwd()
[17:02:28.728]             }
[17:02:28.728]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.728]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.728]         }
[17:02:28.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.728]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.728]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.728]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.728]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.728]             base::names(...future.oldOptions))
[17:02:28.728]     }
[17:02:28.728]     if (FALSE) {
[17:02:28.728]     }
[17:02:28.728]     else {
[17:02:28.728]         if (TRUE) {
[17:02:28.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.728]                 open = "w")
[17:02:28.728]         }
[17:02:28.728]         else {
[17:02:28.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.728]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.728]         }
[17:02:28.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.728]             base::sink(type = "output", split = FALSE)
[17:02:28.728]             base::close(...future.stdout)
[17:02:28.728]         }, add = TRUE)
[17:02:28.728]     }
[17:02:28.728]     ...future.frame <- base::sys.nframe()
[17:02:28.728]     ...future.conditions <- base::list()
[17:02:28.728]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.728]     if (FALSE) {
[17:02:28.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.728]     }
[17:02:28.728]     ...future.result <- base::tryCatch({
[17:02:28.728]         base::withCallingHandlers({
[17:02:28.728]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:28.728]             future::FutureResult(value = ...future.value$value, 
[17:02:28.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.728]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.728]                     ...future.globalenv.names))
[17:02:28.728]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.728]         }, condition = base::local({
[17:02:28.728]             c <- base::c
[17:02:28.728]             inherits <- base::inherits
[17:02:28.728]             invokeRestart <- base::invokeRestart
[17:02:28.728]             length <- base::length
[17:02:28.728]             list <- base::list
[17:02:28.728]             seq.int <- base::seq.int
[17:02:28.728]             signalCondition <- base::signalCondition
[17:02:28.728]             sys.calls <- base::sys.calls
[17:02:28.728]             `[[` <- base::`[[`
[17:02:28.728]             `+` <- base::`+`
[17:02:28.728]             `<<-` <- base::`<<-`
[17:02:28.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.728]                   3L)]
[17:02:28.728]             }
[17:02:28.728]             function(cond) {
[17:02:28.728]                 is_error <- inherits(cond, "error")
[17:02:28.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.728]                   NULL)
[17:02:28.728]                 if (is_error) {
[17:02:28.728]                   sessionInformation <- function() {
[17:02:28.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.728]                       search = base::search(), system = base::Sys.info())
[17:02:28.728]                   }
[17:02:28.728]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.728]                     cond$call), session = sessionInformation(), 
[17:02:28.728]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.728]                   signalCondition(cond)
[17:02:28.728]                 }
[17:02:28.728]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.728]                 "immediateCondition"))) {
[17:02:28.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.728]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.728]                   if (TRUE && !signal) {
[17:02:28.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.728]                     {
[17:02:28.728]                       inherits <- base::inherits
[17:02:28.728]                       invokeRestart <- base::invokeRestart
[17:02:28.728]                       is.null <- base::is.null
[17:02:28.728]                       muffled <- FALSE
[17:02:28.728]                       if (inherits(cond, "message")) {
[17:02:28.728]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.728]                         if (muffled) 
[17:02:28.728]                           invokeRestart("muffleMessage")
[17:02:28.728]                       }
[17:02:28.728]                       else if (inherits(cond, "warning")) {
[17:02:28.728]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.728]                         if (muffled) 
[17:02:28.728]                           invokeRestart("muffleWarning")
[17:02:28.728]                       }
[17:02:28.728]                       else if (inherits(cond, "condition")) {
[17:02:28.728]                         if (!is.null(pattern)) {
[17:02:28.728]                           computeRestarts <- base::computeRestarts
[17:02:28.728]                           grepl <- base::grepl
[17:02:28.728]                           restarts <- computeRestarts(cond)
[17:02:28.728]                           for (restart in restarts) {
[17:02:28.728]                             name <- restart$name
[17:02:28.728]                             if (is.null(name)) 
[17:02:28.728]                               next
[17:02:28.728]                             if (!grepl(pattern, name)) 
[17:02:28.728]                               next
[17:02:28.728]                             invokeRestart(restart)
[17:02:28.728]                             muffled <- TRUE
[17:02:28.728]                             break
[17:02:28.728]                           }
[17:02:28.728]                         }
[17:02:28.728]                       }
[17:02:28.728]                       invisible(muffled)
[17:02:28.728]                     }
[17:02:28.728]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.728]                   }
[17:02:28.728]                 }
[17:02:28.728]                 else {
[17:02:28.728]                   if (TRUE) {
[17:02:28.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.728]                     {
[17:02:28.728]                       inherits <- base::inherits
[17:02:28.728]                       invokeRestart <- base::invokeRestart
[17:02:28.728]                       is.null <- base::is.null
[17:02:28.728]                       muffled <- FALSE
[17:02:28.728]                       if (inherits(cond, "message")) {
[17:02:28.728]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.728]                         if (muffled) 
[17:02:28.728]                           invokeRestart("muffleMessage")
[17:02:28.728]                       }
[17:02:28.728]                       else if (inherits(cond, "warning")) {
[17:02:28.728]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.728]                         if (muffled) 
[17:02:28.728]                           invokeRestart("muffleWarning")
[17:02:28.728]                       }
[17:02:28.728]                       else if (inherits(cond, "condition")) {
[17:02:28.728]                         if (!is.null(pattern)) {
[17:02:28.728]                           computeRestarts <- base::computeRestarts
[17:02:28.728]                           grepl <- base::grepl
[17:02:28.728]                           restarts <- computeRestarts(cond)
[17:02:28.728]                           for (restart in restarts) {
[17:02:28.728]                             name <- restart$name
[17:02:28.728]                             if (is.null(name)) 
[17:02:28.728]                               next
[17:02:28.728]                             if (!grepl(pattern, name)) 
[17:02:28.728]                               next
[17:02:28.728]                             invokeRestart(restart)
[17:02:28.728]                             muffled <- TRUE
[17:02:28.728]                             break
[17:02:28.728]                           }
[17:02:28.728]                         }
[17:02:28.728]                       }
[17:02:28.728]                       invisible(muffled)
[17:02:28.728]                     }
[17:02:28.728]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.728]                   }
[17:02:28.728]                 }
[17:02:28.728]             }
[17:02:28.728]         }))
[17:02:28.728]     }, error = function(ex) {
[17:02:28.728]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.728]                 ...future.rng), started = ...future.startTime, 
[17:02:28.728]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.728]             version = "1.8"), class = "FutureResult")
[17:02:28.728]     }, finally = {
[17:02:28.728]         if (!identical(...future.workdir, getwd())) 
[17:02:28.728]             setwd(...future.workdir)
[17:02:28.728]         {
[17:02:28.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.728]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.728]             }
[17:02:28.728]             base::options(...future.oldOptions)
[17:02:28.728]             if (.Platform$OS.type == "windows") {
[17:02:28.728]                 old_names <- names(...future.oldEnvVars)
[17:02:28.728]                 envs <- base::Sys.getenv()
[17:02:28.728]                 names <- names(envs)
[17:02:28.728]                 common <- intersect(names, old_names)
[17:02:28.728]                 added <- setdiff(names, old_names)
[17:02:28.728]                 removed <- setdiff(old_names, names)
[17:02:28.728]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.728]                   envs[common]]
[17:02:28.728]                 NAMES <- toupper(changed)
[17:02:28.728]                 args <- list()
[17:02:28.728]                 for (kk in seq_along(NAMES)) {
[17:02:28.728]                   name <- changed[[kk]]
[17:02:28.728]                   NAME <- NAMES[[kk]]
[17:02:28.728]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.728]                     next
[17:02:28.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.728]                 }
[17:02:28.728]                 NAMES <- toupper(added)
[17:02:28.728]                 for (kk in seq_along(NAMES)) {
[17:02:28.728]                   name <- added[[kk]]
[17:02:28.728]                   NAME <- NAMES[[kk]]
[17:02:28.728]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.728]                     next
[17:02:28.728]                   args[[name]] <- ""
[17:02:28.728]                 }
[17:02:28.728]                 NAMES <- toupper(removed)
[17:02:28.728]                 for (kk in seq_along(NAMES)) {
[17:02:28.728]                   name <- removed[[kk]]
[17:02:28.728]                   NAME <- NAMES[[kk]]
[17:02:28.728]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.728]                     next
[17:02:28.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.728]                 }
[17:02:28.728]                 if (length(args) > 0) 
[17:02:28.728]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.728]             }
[17:02:28.728]             else {
[17:02:28.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.728]             }
[17:02:28.728]             {
[17:02:28.728]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.728]                   0L) {
[17:02:28.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.728]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.728]                   base::options(opts)
[17:02:28.728]                 }
[17:02:28.728]                 {
[17:02:28.728]                   {
[17:02:28.728]                     NULL
[17:02:28.728]                     RNGkind("Mersenne-Twister")
[17:02:28.728]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.728]                       inherits = FALSE)
[17:02:28.728]                   }
[17:02:28.728]                   options(future.plan = NULL)
[17:02:28.728]                   if (is.na(NA_character_)) 
[17:02:28.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.728]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.728]                     .init = FALSE)
[17:02:28.728]                 }
[17:02:28.728]             }
[17:02:28.728]         }
[17:02:28.728]     })
[17:02:28.728]     if (TRUE) {
[17:02:28.728]         base::sink(type = "output", split = FALSE)
[17:02:28.728]         if (TRUE) {
[17:02:28.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.728]         }
[17:02:28.728]         else {
[17:02:28.728]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.728]         }
[17:02:28.728]         base::close(...future.stdout)
[17:02:28.728]         ...future.stdout <- NULL
[17:02:28.728]     }
[17:02:28.728]     ...future.result$conditions <- ...future.conditions
[17:02:28.728]     ...future.result$finished <- base::Sys.time()
[17:02:28.728]     ...future.result
[17:02:28.728] }
[17:02:28.730] plan(): Setting new future strategy stack:
[17:02:28.730] List of future strategies:
[17:02:28.730] 1. sequential:
[17:02:28.730]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.730]    - tweaked: FALSE
[17:02:28.730]    - call: NULL
[17:02:28.730] plan(): nbrOfWorkers() = 1
[17:02:28.731] plan(): Setting new future strategy stack:
[17:02:28.731] List of future strategies:
[17:02:28.731] 1. sequential:
[17:02:28.731]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.731]    - tweaked: FALSE
[17:02:28.731]    - call: plan(strategy)
[17:02:28.732] plan(): nbrOfWorkers() = 1
[17:02:28.732] SequentialFuture started (and completed)
[17:02:28.732] - Launch lazy future ... done
[17:02:28.732] run() for ‘SequentialFuture’ ... done
[17:02:28.732] getGlobalsAndPackages() ...
[17:02:28.732] Searching for globals...
[17:02:28.733] - globals found: [1] ‘{’
[17:02:28.733] Searching for globals ... DONE
[17:02:28.733] Resolving globals: FALSE
[17:02:28.733] 
[17:02:28.733] 
[17:02:28.733] getGlobalsAndPackages() ... DONE
[17:02:28.734] run() for ‘Future’ ...
[17:02:28.734] - state: ‘created’
[17:02:28.734] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.734] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.734] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.734]   - Field: ‘label’
[17:02:28.734]   - Field: ‘local’
[17:02:28.735]   - Field: ‘owner’
[17:02:28.735]   - Field: ‘envir’
[17:02:28.735]   - Field: ‘packages’
[17:02:28.735]   - Field: ‘gc’
[17:02:28.735]   - Field: ‘conditions’
[17:02:28.735]   - Field: ‘expr’
[17:02:28.735]   - Field: ‘uuid’
[17:02:28.735]   - Field: ‘seed’
[17:02:28.735]   - Field: ‘version’
[17:02:28.735]   - Field: ‘result’
[17:02:28.735]   - Field: ‘asynchronous’
[17:02:28.736]   - Field: ‘calls’
[17:02:28.736]   - Field: ‘globals’
[17:02:28.736]   - Field: ‘stdout’
[17:02:28.736]   - Field: ‘earlySignal’
[17:02:28.736]   - Field: ‘lazy’
[17:02:28.736]   - Field: ‘state’
[17:02:28.736] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.736] - Launch lazy future ...
[17:02:28.736] Packages needed by the future expression (n = 0): <none>
[17:02:28.736] Packages needed by future strategies (n = 0): <none>
[17:02:28.737] {
[17:02:28.737]     {
[17:02:28.737]         {
[17:02:28.737]             ...future.startTime <- base::Sys.time()
[17:02:28.737]             {
[17:02:28.737]                 {
[17:02:28.737]                   {
[17:02:28.737]                     base::local({
[17:02:28.737]                       has_future <- base::requireNamespace("future", 
[17:02:28.737]                         quietly = TRUE)
[17:02:28.737]                       if (has_future) {
[17:02:28.737]                         ns <- base::getNamespace("future")
[17:02:28.737]                         version <- ns[[".package"]][["version"]]
[17:02:28.737]                         if (is.null(version)) 
[17:02:28.737]                           version <- utils::packageVersion("future")
[17:02:28.737]                       }
[17:02:28.737]                       else {
[17:02:28.737]                         version <- NULL
[17:02:28.737]                       }
[17:02:28.737]                       if (!has_future || version < "1.8.0") {
[17:02:28.737]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.737]                           "", base::R.version$version.string), 
[17:02:28.737]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.737]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.737]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.737]                             "release", "version")], collapse = " "), 
[17:02:28.737]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.737]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.737]                           info)
[17:02:28.737]                         info <- base::paste(info, collapse = "; ")
[17:02:28.737]                         if (!has_future) {
[17:02:28.737]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.737]                             info)
[17:02:28.737]                         }
[17:02:28.737]                         else {
[17:02:28.737]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.737]                             info, version)
[17:02:28.737]                         }
[17:02:28.737]                         base::stop(msg)
[17:02:28.737]                       }
[17:02:28.737]                     })
[17:02:28.737]                   }
[17:02:28.737]                   ...future.strategy.old <- future::plan("list")
[17:02:28.737]                   options(future.plan = NULL)
[17:02:28.737]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.737]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.737]                 }
[17:02:28.737]                 ...future.workdir <- getwd()
[17:02:28.737]             }
[17:02:28.737]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.737]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.737]         }
[17:02:28.737]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.737]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.737]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.737]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.737]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.737]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.737]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.737]             base::names(...future.oldOptions))
[17:02:28.737]     }
[17:02:28.737]     if (FALSE) {
[17:02:28.737]     }
[17:02:28.737]     else {
[17:02:28.737]         if (TRUE) {
[17:02:28.737]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.737]                 open = "w")
[17:02:28.737]         }
[17:02:28.737]         else {
[17:02:28.737]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.737]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.737]         }
[17:02:28.737]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.737]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.737]             base::sink(type = "output", split = FALSE)
[17:02:28.737]             base::close(...future.stdout)
[17:02:28.737]         }, add = TRUE)
[17:02:28.737]     }
[17:02:28.737]     ...future.frame <- base::sys.nframe()
[17:02:28.737]     ...future.conditions <- base::list()
[17:02:28.737]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.737]     if (FALSE) {
[17:02:28.737]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.737]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.737]     }
[17:02:28.737]     ...future.result <- base::tryCatch({
[17:02:28.737]         base::withCallingHandlers({
[17:02:28.737]             ...future.value <- base::withVisible(base::local({
[17:02:28.737]                 4
[17:02:28.737]             }))
[17:02:28.737]             future::FutureResult(value = ...future.value$value, 
[17:02:28.737]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.737]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.737]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.737]                     ...future.globalenv.names))
[17:02:28.737]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.737]         }, condition = base::local({
[17:02:28.737]             c <- base::c
[17:02:28.737]             inherits <- base::inherits
[17:02:28.737]             invokeRestart <- base::invokeRestart
[17:02:28.737]             length <- base::length
[17:02:28.737]             list <- base::list
[17:02:28.737]             seq.int <- base::seq.int
[17:02:28.737]             signalCondition <- base::signalCondition
[17:02:28.737]             sys.calls <- base::sys.calls
[17:02:28.737]             `[[` <- base::`[[`
[17:02:28.737]             `+` <- base::`+`
[17:02:28.737]             `<<-` <- base::`<<-`
[17:02:28.737]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.737]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.737]                   3L)]
[17:02:28.737]             }
[17:02:28.737]             function(cond) {
[17:02:28.737]                 is_error <- inherits(cond, "error")
[17:02:28.737]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.737]                   NULL)
[17:02:28.737]                 if (is_error) {
[17:02:28.737]                   sessionInformation <- function() {
[17:02:28.737]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.737]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.737]                       search = base::search(), system = base::Sys.info())
[17:02:28.737]                   }
[17:02:28.737]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.737]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.737]                     cond$call), session = sessionInformation(), 
[17:02:28.737]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.737]                   signalCondition(cond)
[17:02:28.737]                 }
[17:02:28.737]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.737]                 "immediateCondition"))) {
[17:02:28.737]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.737]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.737]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.737]                   if (TRUE && !signal) {
[17:02:28.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.737]                     {
[17:02:28.737]                       inherits <- base::inherits
[17:02:28.737]                       invokeRestart <- base::invokeRestart
[17:02:28.737]                       is.null <- base::is.null
[17:02:28.737]                       muffled <- FALSE
[17:02:28.737]                       if (inherits(cond, "message")) {
[17:02:28.737]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.737]                         if (muffled) 
[17:02:28.737]                           invokeRestart("muffleMessage")
[17:02:28.737]                       }
[17:02:28.737]                       else if (inherits(cond, "warning")) {
[17:02:28.737]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.737]                         if (muffled) 
[17:02:28.737]                           invokeRestart("muffleWarning")
[17:02:28.737]                       }
[17:02:28.737]                       else if (inherits(cond, "condition")) {
[17:02:28.737]                         if (!is.null(pattern)) {
[17:02:28.737]                           computeRestarts <- base::computeRestarts
[17:02:28.737]                           grepl <- base::grepl
[17:02:28.737]                           restarts <- computeRestarts(cond)
[17:02:28.737]                           for (restart in restarts) {
[17:02:28.737]                             name <- restart$name
[17:02:28.737]                             if (is.null(name)) 
[17:02:28.737]                               next
[17:02:28.737]                             if (!grepl(pattern, name)) 
[17:02:28.737]                               next
[17:02:28.737]                             invokeRestart(restart)
[17:02:28.737]                             muffled <- TRUE
[17:02:28.737]                             break
[17:02:28.737]                           }
[17:02:28.737]                         }
[17:02:28.737]                       }
[17:02:28.737]                       invisible(muffled)
[17:02:28.737]                     }
[17:02:28.737]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.737]                   }
[17:02:28.737]                 }
[17:02:28.737]                 else {
[17:02:28.737]                   if (TRUE) {
[17:02:28.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.737]                     {
[17:02:28.737]                       inherits <- base::inherits
[17:02:28.737]                       invokeRestart <- base::invokeRestart
[17:02:28.737]                       is.null <- base::is.null
[17:02:28.737]                       muffled <- FALSE
[17:02:28.737]                       if (inherits(cond, "message")) {
[17:02:28.737]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.737]                         if (muffled) 
[17:02:28.737]                           invokeRestart("muffleMessage")
[17:02:28.737]                       }
[17:02:28.737]                       else if (inherits(cond, "warning")) {
[17:02:28.737]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.737]                         if (muffled) 
[17:02:28.737]                           invokeRestart("muffleWarning")
[17:02:28.737]                       }
[17:02:28.737]                       else if (inherits(cond, "condition")) {
[17:02:28.737]                         if (!is.null(pattern)) {
[17:02:28.737]                           computeRestarts <- base::computeRestarts
[17:02:28.737]                           grepl <- base::grepl
[17:02:28.737]                           restarts <- computeRestarts(cond)
[17:02:28.737]                           for (restart in restarts) {
[17:02:28.737]                             name <- restart$name
[17:02:28.737]                             if (is.null(name)) 
[17:02:28.737]                               next
[17:02:28.737]                             if (!grepl(pattern, name)) 
[17:02:28.737]                               next
[17:02:28.737]                             invokeRestart(restart)
[17:02:28.737]                             muffled <- TRUE
[17:02:28.737]                             break
[17:02:28.737]                           }
[17:02:28.737]                         }
[17:02:28.737]                       }
[17:02:28.737]                       invisible(muffled)
[17:02:28.737]                     }
[17:02:28.737]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.737]                   }
[17:02:28.737]                 }
[17:02:28.737]             }
[17:02:28.737]         }))
[17:02:28.737]     }, error = function(ex) {
[17:02:28.737]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.737]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.737]                 ...future.rng), started = ...future.startTime, 
[17:02:28.737]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.737]             version = "1.8"), class = "FutureResult")
[17:02:28.737]     }, finally = {
[17:02:28.737]         if (!identical(...future.workdir, getwd())) 
[17:02:28.737]             setwd(...future.workdir)
[17:02:28.737]         {
[17:02:28.737]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.737]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.737]             }
[17:02:28.737]             base::options(...future.oldOptions)
[17:02:28.737]             if (.Platform$OS.type == "windows") {
[17:02:28.737]                 old_names <- names(...future.oldEnvVars)
[17:02:28.737]                 envs <- base::Sys.getenv()
[17:02:28.737]                 names <- names(envs)
[17:02:28.737]                 common <- intersect(names, old_names)
[17:02:28.737]                 added <- setdiff(names, old_names)
[17:02:28.737]                 removed <- setdiff(old_names, names)
[17:02:28.737]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.737]                   envs[common]]
[17:02:28.737]                 NAMES <- toupper(changed)
[17:02:28.737]                 args <- list()
[17:02:28.737]                 for (kk in seq_along(NAMES)) {
[17:02:28.737]                   name <- changed[[kk]]
[17:02:28.737]                   NAME <- NAMES[[kk]]
[17:02:28.737]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.737]                     next
[17:02:28.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.737]                 }
[17:02:28.737]                 NAMES <- toupper(added)
[17:02:28.737]                 for (kk in seq_along(NAMES)) {
[17:02:28.737]                   name <- added[[kk]]
[17:02:28.737]                   NAME <- NAMES[[kk]]
[17:02:28.737]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.737]                     next
[17:02:28.737]                   args[[name]] <- ""
[17:02:28.737]                 }
[17:02:28.737]                 NAMES <- toupper(removed)
[17:02:28.737]                 for (kk in seq_along(NAMES)) {
[17:02:28.737]                   name <- removed[[kk]]
[17:02:28.737]                   NAME <- NAMES[[kk]]
[17:02:28.737]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.737]                     next
[17:02:28.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.737]                 }
[17:02:28.737]                 if (length(args) > 0) 
[17:02:28.737]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.737]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.737]             }
[17:02:28.737]             else {
[17:02:28.737]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.737]             }
[17:02:28.737]             {
[17:02:28.737]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.737]                   0L) {
[17:02:28.737]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.737]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.737]                   base::options(opts)
[17:02:28.737]                 }
[17:02:28.737]                 {
[17:02:28.737]                   {
[17:02:28.737]                     NULL
[17:02:28.737]                     RNGkind("Mersenne-Twister")
[17:02:28.737]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.737]                       inherits = FALSE)
[17:02:28.737]                   }
[17:02:28.737]                   options(future.plan = NULL)
[17:02:28.737]                   if (is.na(NA_character_)) 
[17:02:28.737]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.737]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.737]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.737]                     .init = FALSE)
[17:02:28.737]                 }
[17:02:28.737]             }
[17:02:28.737]         }
[17:02:28.737]     })
[17:02:28.737]     if (TRUE) {
[17:02:28.737]         base::sink(type = "output", split = FALSE)
[17:02:28.737]         if (TRUE) {
[17:02:28.737]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.737]         }
[17:02:28.737]         else {
[17:02:28.737]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.737]         }
[17:02:28.737]         base::close(...future.stdout)
[17:02:28.737]         ...future.stdout <- NULL
[17:02:28.737]     }
[17:02:28.737]     ...future.result$conditions <- ...future.conditions
[17:02:28.737]     ...future.result$finished <- base::Sys.time()
[17:02:28.737]     ...future.result
[17:02:28.737] }
[17:02:28.739] plan(): Setting new future strategy stack:
[17:02:28.739] List of future strategies:
[17:02:28.739] 1. sequential:
[17:02:28.739]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.739]    - tweaked: FALSE
[17:02:28.739]    - call: NULL
[17:02:28.739] plan(): nbrOfWorkers() = 1
[17:02:28.740] plan(): Setting new future strategy stack:
[17:02:28.740] List of future strategies:
[17:02:28.740] 1. sequential:
[17:02:28.740]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.740]    - tweaked: FALSE
[17:02:28.740]    - call: plan(strategy)
[17:02:28.740] plan(): nbrOfWorkers() = 1
[17:02:28.740] SequentialFuture started (and completed)
[17:02:28.741] - Launch lazy future ... done
[17:02:28.741] run() for ‘SequentialFuture’ ... done
<environment: 0x55c747f50dd0> 
<environment: 0x55c749998a00> 
[17:02:28.742] resolved() for ‘SequentialFuture’ ...
[17:02:28.742] - state: ‘finished’
[17:02:28.742] - run: TRUE
[17:02:28.742] - result: ‘FutureResult’
[17:02:28.742] resolved() for ‘SequentialFuture’ ... done
[17:02:28.742] resolved() for ‘SequentialFuture’ ...
[17:02:28.742] - state: ‘finished’
[17:02:28.742] - run: TRUE
[17:02:28.743] - result: ‘FutureResult’
[17:02:28.743] resolved() for ‘SequentialFuture’ ... done
[17:02:28.743] resolved() for ‘SequentialFuture’ ...
[17:02:28.743] - state: ‘finished’
[17:02:28.743] - run: TRUE
[17:02:28.743] - result: ‘FutureResult’
[17:02:28.743] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:28.744] resolve() on environment ...
[17:02:28.744]  recursive: 0
[17:02:28.747]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:28.747] signalConditionsASAP(numeric, pos=1) ...
[17:02:28.747] - nx: 4
[17:02:28.747] - relay: TRUE
[17:02:28.747] - stdout: TRUE
[17:02:28.747] - signal: TRUE
[17:02:28.747] - resignal: FALSE
[17:02:28.747] - force: TRUE
[17:02:28.747] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.747] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.747]  - until=2
[17:02:28.748]  - relaying element #2
[17:02:28.748] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:28.748] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.748] signalConditionsASAP(NULL, pos=1) ... done
[17:02:28.748]  length: 3 (resolved future 1)
[17:02:28.748] resolved() for ‘SequentialFuture’ ...
[17:02:28.748] - state: ‘finished’
[17:02:28.748] - run: TRUE
[17:02:28.748] - result: ‘FutureResult’
[17:02:28.748] resolved() for ‘SequentialFuture’ ... done
[17:02:28.748] Future #2
[17:02:28.749] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:28.749] - nx: 4
[17:02:28.749] - relay: TRUE
[17:02:28.749] - stdout: TRUE
[17:02:28.749] - signal: TRUE
[17:02:28.749] - resignal: FALSE
[17:02:28.749] - force: TRUE
[17:02:28.749] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:28.749] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.749]  - until=2
[17:02:28.749]  - relaying element #2
[17:02:28.750] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:28.750] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:28.750] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:28.750]  length: 2 (resolved future 2)
[17:02:28.750] resolved() for ‘SequentialFuture’ ...
[17:02:28.750] - state: ‘finished’
[17:02:28.750] - run: TRUE
[17:02:28.750] - result: ‘FutureResult’
[17:02:28.750] resolved() for ‘SequentialFuture’ ... done
[17:02:28.750] Future #3
[17:02:28.751] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:28.751] - nx: 4
[17:02:28.751] - relay: TRUE
[17:02:28.751] - stdout: TRUE
[17:02:28.751] - signal: TRUE
[17:02:28.751] - resignal: FALSE
[17:02:28.751] - force: TRUE
[17:02:28.751] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:28.751] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:28.751]  - until=3
[17:02:28.751]  - relaying element #3
[17:02:28.752] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:28.752] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:28.752] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:28.752]  length: 1 (resolved future 3)
[17:02:28.752] resolved() for ‘SequentialFuture’ ...
[17:02:28.752] - state: ‘finished’
[17:02:28.752] - run: TRUE
[17:02:28.752] - result: ‘FutureResult’
[17:02:28.752] resolved() for ‘SequentialFuture’ ... done
[17:02:28.752] Future #4
[17:02:28.753] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:02:28.753] - nx: 4
[17:02:28.753] - relay: TRUE
[17:02:28.753] - stdout: TRUE
[17:02:28.753] - signal: TRUE
[17:02:28.753] - resignal: FALSE
[17:02:28.753] - force: TRUE
[17:02:28.753] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:28.753] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:28.753]  - until=4
[17:02:28.753]  - relaying element #4
[17:02:28.754] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.754] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:28.754] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:02:28.754]  length: 0 (resolved future 4)
[17:02:28.754] Relaying remaining futures
[17:02:28.754] signalConditionsASAP(NULL, pos=0) ...
[17:02:28.754] - nx: 4
[17:02:28.754] - relay: TRUE
[17:02:28.754] - stdout: TRUE
[17:02:28.754] - signal: TRUE
[17:02:28.754] - resignal: FALSE
[17:02:28.754] - force: TRUE
[17:02:28.755] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.755] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:28.755] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.755] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:28.755] signalConditionsASAP(NULL, pos=0) ... done
[17:02:28.755] resolve() on environment ... DONE
<environment: 0x55c749db1a18> 
Dimensions: c(2, 3)
[17:02:28.756] getGlobalsAndPackages() ...
[17:02:28.756] Searching for globals...
[17:02:28.756] 
[17:02:28.756] Searching for globals ... DONE
[17:02:28.756] - globals: [0] <none>
[17:02:28.756] getGlobalsAndPackages() ... DONE
[17:02:28.756] run() for ‘Future’ ...
[17:02:28.757] - state: ‘created’
[17:02:28.757] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.757] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.757] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.757]   - Field: ‘label’
[17:02:28.757]   - Field: ‘local’
[17:02:28.757]   - Field: ‘owner’
[17:02:28.757]   - Field: ‘envir’
[17:02:28.758]   - Field: ‘packages’
[17:02:28.758]   - Field: ‘gc’
[17:02:28.758]   - Field: ‘conditions’
[17:02:28.758]   - Field: ‘expr’
[17:02:28.758]   - Field: ‘uuid’
[17:02:28.758]   - Field: ‘seed’
[17:02:28.758]   - Field: ‘version’
[17:02:28.758]   - Field: ‘result’
[17:02:28.758]   - Field: ‘asynchronous’
[17:02:28.758]   - Field: ‘calls’
[17:02:28.758]   - Field: ‘globals’
[17:02:28.759]   - Field: ‘stdout’
[17:02:28.759]   - Field: ‘earlySignal’
[17:02:28.759]   - Field: ‘lazy’
[17:02:28.759]   - Field: ‘state’
[17:02:28.759] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.759] - Launch lazy future ...
[17:02:28.759] Packages needed by the future expression (n = 0): <none>
[17:02:28.759] Packages needed by future strategies (n = 0): <none>
[17:02:28.760] {
[17:02:28.760]     {
[17:02:28.760]         {
[17:02:28.760]             ...future.startTime <- base::Sys.time()
[17:02:28.760]             {
[17:02:28.760]                 {
[17:02:28.760]                   {
[17:02:28.760]                     base::local({
[17:02:28.760]                       has_future <- base::requireNamespace("future", 
[17:02:28.760]                         quietly = TRUE)
[17:02:28.760]                       if (has_future) {
[17:02:28.760]                         ns <- base::getNamespace("future")
[17:02:28.760]                         version <- ns[[".package"]][["version"]]
[17:02:28.760]                         if (is.null(version)) 
[17:02:28.760]                           version <- utils::packageVersion("future")
[17:02:28.760]                       }
[17:02:28.760]                       else {
[17:02:28.760]                         version <- NULL
[17:02:28.760]                       }
[17:02:28.760]                       if (!has_future || version < "1.8.0") {
[17:02:28.760]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.760]                           "", base::R.version$version.string), 
[17:02:28.760]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.760]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.760]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.760]                             "release", "version")], collapse = " "), 
[17:02:28.760]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.760]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.760]                           info)
[17:02:28.760]                         info <- base::paste(info, collapse = "; ")
[17:02:28.760]                         if (!has_future) {
[17:02:28.760]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.760]                             info)
[17:02:28.760]                         }
[17:02:28.760]                         else {
[17:02:28.760]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.760]                             info, version)
[17:02:28.760]                         }
[17:02:28.760]                         base::stop(msg)
[17:02:28.760]                       }
[17:02:28.760]                     })
[17:02:28.760]                   }
[17:02:28.760]                   ...future.strategy.old <- future::plan("list")
[17:02:28.760]                   options(future.plan = NULL)
[17:02:28.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.760]                 }
[17:02:28.760]                 ...future.workdir <- getwd()
[17:02:28.760]             }
[17:02:28.760]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.760]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.760]         }
[17:02:28.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.760]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.760]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.760]             base::names(...future.oldOptions))
[17:02:28.760]     }
[17:02:28.760]     if (FALSE) {
[17:02:28.760]     }
[17:02:28.760]     else {
[17:02:28.760]         if (TRUE) {
[17:02:28.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.760]                 open = "w")
[17:02:28.760]         }
[17:02:28.760]         else {
[17:02:28.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.760]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.760]         }
[17:02:28.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.760]             base::sink(type = "output", split = FALSE)
[17:02:28.760]             base::close(...future.stdout)
[17:02:28.760]         }, add = TRUE)
[17:02:28.760]     }
[17:02:28.760]     ...future.frame <- base::sys.nframe()
[17:02:28.760]     ...future.conditions <- base::list()
[17:02:28.760]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.760]     if (FALSE) {
[17:02:28.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.760]     }
[17:02:28.760]     ...future.result <- base::tryCatch({
[17:02:28.760]         base::withCallingHandlers({
[17:02:28.760]             ...future.value <- base::withVisible(base::local(2))
[17:02:28.760]             future::FutureResult(value = ...future.value$value, 
[17:02:28.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.760]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.760]                     ...future.globalenv.names))
[17:02:28.760]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.760]         }, condition = base::local({
[17:02:28.760]             c <- base::c
[17:02:28.760]             inherits <- base::inherits
[17:02:28.760]             invokeRestart <- base::invokeRestart
[17:02:28.760]             length <- base::length
[17:02:28.760]             list <- base::list
[17:02:28.760]             seq.int <- base::seq.int
[17:02:28.760]             signalCondition <- base::signalCondition
[17:02:28.760]             sys.calls <- base::sys.calls
[17:02:28.760]             `[[` <- base::`[[`
[17:02:28.760]             `+` <- base::`+`
[17:02:28.760]             `<<-` <- base::`<<-`
[17:02:28.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.760]                   3L)]
[17:02:28.760]             }
[17:02:28.760]             function(cond) {
[17:02:28.760]                 is_error <- inherits(cond, "error")
[17:02:28.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.760]                   NULL)
[17:02:28.760]                 if (is_error) {
[17:02:28.760]                   sessionInformation <- function() {
[17:02:28.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.760]                       search = base::search(), system = base::Sys.info())
[17:02:28.760]                   }
[17:02:28.760]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.760]                     cond$call), session = sessionInformation(), 
[17:02:28.760]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.760]                   signalCondition(cond)
[17:02:28.760]                 }
[17:02:28.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.760]                 "immediateCondition"))) {
[17:02:28.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.760]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.760]                   if (TRUE && !signal) {
[17:02:28.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.760]                     {
[17:02:28.760]                       inherits <- base::inherits
[17:02:28.760]                       invokeRestart <- base::invokeRestart
[17:02:28.760]                       is.null <- base::is.null
[17:02:28.760]                       muffled <- FALSE
[17:02:28.760]                       if (inherits(cond, "message")) {
[17:02:28.760]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.760]                         if (muffled) 
[17:02:28.760]                           invokeRestart("muffleMessage")
[17:02:28.760]                       }
[17:02:28.760]                       else if (inherits(cond, "warning")) {
[17:02:28.760]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.760]                         if (muffled) 
[17:02:28.760]                           invokeRestart("muffleWarning")
[17:02:28.760]                       }
[17:02:28.760]                       else if (inherits(cond, "condition")) {
[17:02:28.760]                         if (!is.null(pattern)) {
[17:02:28.760]                           computeRestarts <- base::computeRestarts
[17:02:28.760]                           grepl <- base::grepl
[17:02:28.760]                           restarts <- computeRestarts(cond)
[17:02:28.760]                           for (restart in restarts) {
[17:02:28.760]                             name <- restart$name
[17:02:28.760]                             if (is.null(name)) 
[17:02:28.760]                               next
[17:02:28.760]                             if (!grepl(pattern, name)) 
[17:02:28.760]                               next
[17:02:28.760]                             invokeRestart(restart)
[17:02:28.760]                             muffled <- TRUE
[17:02:28.760]                             break
[17:02:28.760]                           }
[17:02:28.760]                         }
[17:02:28.760]                       }
[17:02:28.760]                       invisible(muffled)
[17:02:28.760]                     }
[17:02:28.760]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.760]                   }
[17:02:28.760]                 }
[17:02:28.760]                 else {
[17:02:28.760]                   if (TRUE) {
[17:02:28.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.760]                     {
[17:02:28.760]                       inherits <- base::inherits
[17:02:28.760]                       invokeRestart <- base::invokeRestart
[17:02:28.760]                       is.null <- base::is.null
[17:02:28.760]                       muffled <- FALSE
[17:02:28.760]                       if (inherits(cond, "message")) {
[17:02:28.760]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.760]                         if (muffled) 
[17:02:28.760]                           invokeRestart("muffleMessage")
[17:02:28.760]                       }
[17:02:28.760]                       else if (inherits(cond, "warning")) {
[17:02:28.760]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.760]                         if (muffled) 
[17:02:28.760]                           invokeRestart("muffleWarning")
[17:02:28.760]                       }
[17:02:28.760]                       else if (inherits(cond, "condition")) {
[17:02:28.760]                         if (!is.null(pattern)) {
[17:02:28.760]                           computeRestarts <- base::computeRestarts
[17:02:28.760]                           grepl <- base::grepl
[17:02:28.760]                           restarts <- computeRestarts(cond)
[17:02:28.760]                           for (restart in restarts) {
[17:02:28.760]                             name <- restart$name
[17:02:28.760]                             if (is.null(name)) 
[17:02:28.760]                               next
[17:02:28.760]                             if (!grepl(pattern, name)) 
[17:02:28.760]                               next
[17:02:28.760]                             invokeRestart(restart)
[17:02:28.760]                             muffled <- TRUE
[17:02:28.760]                             break
[17:02:28.760]                           }
[17:02:28.760]                         }
[17:02:28.760]                       }
[17:02:28.760]                       invisible(muffled)
[17:02:28.760]                     }
[17:02:28.760]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.760]                   }
[17:02:28.760]                 }
[17:02:28.760]             }
[17:02:28.760]         }))
[17:02:28.760]     }, error = function(ex) {
[17:02:28.760]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.760]                 ...future.rng), started = ...future.startTime, 
[17:02:28.760]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.760]             version = "1.8"), class = "FutureResult")
[17:02:28.760]     }, finally = {
[17:02:28.760]         if (!identical(...future.workdir, getwd())) 
[17:02:28.760]             setwd(...future.workdir)
[17:02:28.760]         {
[17:02:28.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.760]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.760]             }
[17:02:28.760]             base::options(...future.oldOptions)
[17:02:28.760]             if (.Platform$OS.type == "windows") {
[17:02:28.760]                 old_names <- names(...future.oldEnvVars)
[17:02:28.760]                 envs <- base::Sys.getenv()
[17:02:28.760]                 names <- names(envs)
[17:02:28.760]                 common <- intersect(names, old_names)
[17:02:28.760]                 added <- setdiff(names, old_names)
[17:02:28.760]                 removed <- setdiff(old_names, names)
[17:02:28.760]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.760]                   envs[common]]
[17:02:28.760]                 NAMES <- toupper(changed)
[17:02:28.760]                 args <- list()
[17:02:28.760]                 for (kk in seq_along(NAMES)) {
[17:02:28.760]                   name <- changed[[kk]]
[17:02:28.760]                   NAME <- NAMES[[kk]]
[17:02:28.760]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.760]                     next
[17:02:28.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.760]                 }
[17:02:28.760]                 NAMES <- toupper(added)
[17:02:28.760]                 for (kk in seq_along(NAMES)) {
[17:02:28.760]                   name <- added[[kk]]
[17:02:28.760]                   NAME <- NAMES[[kk]]
[17:02:28.760]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.760]                     next
[17:02:28.760]                   args[[name]] <- ""
[17:02:28.760]                 }
[17:02:28.760]                 NAMES <- toupper(removed)
[17:02:28.760]                 for (kk in seq_along(NAMES)) {
[17:02:28.760]                   name <- removed[[kk]]
[17:02:28.760]                   NAME <- NAMES[[kk]]
[17:02:28.760]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.760]                     next
[17:02:28.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.760]                 }
[17:02:28.760]                 if (length(args) > 0) 
[17:02:28.760]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.760]             }
[17:02:28.760]             else {
[17:02:28.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.760]             }
[17:02:28.760]             {
[17:02:28.760]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.760]                   0L) {
[17:02:28.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.760]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.760]                   base::options(opts)
[17:02:28.760]                 }
[17:02:28.760]                 {
[17:02:28.760]                   {
[17:02:28.760]                     NULL
[17:02:28.760]                     RNGkind("Mersenne-Twister")
[17:02:28.760]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.760]                       inherits = FALSE)
[17:02:28.760]                   }
[17:02:28.760]                   options(future.plan = NULL)
[17:02:28.760]                   if (is.na(NA_character_)) 
[17:02:28.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.760]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.760]                     .init = FALSE)
[17:02:28.760]                 }
[17:02:28.760]             }
[17:02:28.760]         }
[17:02:28.760]     })
[17:02:28.760]     if (TRUE) {
[17:02:28.760]         base::sink(type = "output", split = FALSE)
[17:02:28.760]         if (TRUE) {
[17:02:28.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.760]         }
[17:02:28.760]         else {
[17:02:28.760]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.760]         }
[17:02:28.760]         base::close(...future.stdout)
[17:02:28.760]         ...future.stdout <- NULL
[17:02:28.760]     }
[17:02:28.760]     ...future.result$conditions <- ...future.conditions
[17:02:28.760]     ...future.result$finished <- base::Sys.time()
[17:02:28.760]     ...future.result
[17:02:28.760] }
[17:02:28.761] plan(): Setting new future strategy stack:
[17:02:28.762] List of future strategies:
[17:02:28.762] 1. sequential:
[17:02:28.762]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.762]    - tweaked: FALSE
[17:02:28.762]    - call: NULL
[17:02:28.762] plan(): nbrOfWorkers() = 1
[17:02:28.763] plan(): Setting new future strategy stack:
[17:02:28.763] List of future strategies:
[17:02:28.763] 1. sequential:
[17:02:28.763]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.763]    - tweaked: FALSE
[17:02:28.763]    - call: plan(strategy)
[17:02:28.763] plan(): nbrOfWorkers() = 1
[17:02:28.764] SequentialFuture started (and completed)
[17:02:28.764] - Launch lazy future ... done
[17:02:28.764] run() for ‘SequentialFuture’ ... done
[17:02:28.764] getGlobalsAndPackages() ...
[17:02:28.764] Searching for globals...
[17:02:28.764] 
[17:02:28.764] Searching for globals ... DONE
[17:02:28.764] - globals: [0] <none>
[17:02:28.765] getGlobalsAndPackages() ... DONE
[17:02:28.765] run() for ‘Future’ ...
[17:02:28.765] - state: ‘created’
[17:02:28.765] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.765] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.765] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.765]   - Field: ‘label’
[17:02:28.766]   - Field: ‘local’
[17:02:28.766]   - Field: ‘owner’
[17:02:28.766]   - Field: ‘envir’
[17:02:28.766]   - Field: ‘packages’
[17:02:28.766]   - Field: ‘gc’
[17:02:28.766]   - Field: ‘conditions’
[17:02:28.766]   - Field: ‘expr’
[17:02:28.766]   - Field: ‘uuid’
[17:02:28.766]   - Field: ‘seed’
[17:02:28.766]   - Field: ‘version’
[17:02:28.766]   - Field: ‘result’
[17:02:28.767]   - Field: ‘asynchronous’
[17:02:28.767]   - Field: ‘calls’
[17:02:28.767]   - Field: ‘globals’
[17:02:28.767]   - Field: ‘stdout’
[17:02:28.767]   - Field: ‘earlySignal’
[17:02:28.767]   - Field: ‘lazy’
[17:02:28.767]   - Field: ‘state’
[17:02:28.767] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.767] - Launch lazy future ...
[17:02:28.767] Packages needed by the future expression (n = 0): <none>
[17:02:28.768] Packages needed by future strategies (n = 0): <none>
[17:02:28.768] {
[17:02:28.768]     {
[17:02:28.768]         {
[17:02:28.768]             ...future.startTime <- base::Sys.time()
[17:02:28.768]             {
[17:02:28.768]                 {
[17:02:28.768]                   {
[17:02:28.768]                     base::local({
[17:02:28.768]                       has_future <- base::requireNamespace("future", 
[17:02:28.768]                         quietly = TRUE)
[17:02:28.768]                       if (has_future) {
[17:02:28.768]                         ns <- base::getNamespace("future")
[17:02:28.768]                         version <- ns[[".package"]][["version"]]
[17:02:28.768]                         if (is.null(version)) 
[17:02:28.768]                           version <- utils::packageVersion("future")
[17:02:28.768]                       }
[17:02:28.768]                       else {
[17:02:28.768]                         version <- NULL
[17:02:28.768]                       }
[17:02:28.768]                       if (!has_future || version < "1.8.0") {
[17:02:28.768]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.768]                           "", base::R.version$version.string), 
[17:02:28.768]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.768]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.768]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.768]                             "release", "version")], collapse = " "), 
[17:02:28.768]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.768]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.768]                           info)
[17:02:28.768]                         info <- base::paste(info, collapse = "; ")
[17:02:28.768]                         if (!has_future) {
[17:02:28.768]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.768]                             info)
[17:02:28.768]                         }
[17:02:28.768]                         else {
[17:02:28.768]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.768]                             info, version)
[17:02:28.768]                         }
[17:02:28.768]                         base::stop(msg)
[17:02:28.768]                       }
[17:02:28.768]                     })
[17:02:28.768]                   }
[17:02:28.768]                   ...future.strategy.old <- future::plan("list")
[17:02:28.768]                   options(future.plan = NULL)
[17:02:28.768]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.768]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.768]                 }
[17:02:28.768]                 ...future.workdir <- getwd()
[17:02:28.768]             }
[17:02:28.768]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.768]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.768]         }
[17:02:28.768]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.768]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.768]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.768]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.768]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.768]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.768]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.768]             base::names(...future.oldOptions))
[17:02:28.768]     }
[17:02:28.768]     if (FALSE) {
[17:02:28.768]     }
[17:02:28.768]     else {
[17:02:28.768]         if (TRUE) {
[17:02:28.768]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.768]                 open = "w")
[17:02:28.768]         }
[17:02:28.768]         else {
[17:02:28.768]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.768]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.768]         }
[17:02:28.768]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.768]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.768]             base::sink(type = "output", split = FALSE)
[17:02:28.768]             base::close(...future.stdout)
[17:02:28.768]         }, add = TRUE)
[17:02:28.768]     }
[17:02:28.768]     ...future.frame <- base::sys.nframe()
[17:02:28.768]     ...future.conditions <- base::list()
[17:02:28.768]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.768]     if (FALSE) {
[17:02:28.768]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.768]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.768]     }
[17:02:28.768]     ...future.result <- base::tryCatch({
[17:02:28.768]         base::withCallingHandlers({
[17:02:28.768]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:28.768]             future::FutureResult(value = ...future.value$value, 
[17:02:28.768]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.768]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.768]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.768]                     ...future.globalenv.names))
[17:02:28.768]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.768]         }, condition = base::local({
[17:02:28.768]             c <- base::c
[17:02:28.768]             inherits <- base::inherits
[17:02:28.768]             invokeRestart <- base::invokeRestart
[17:02:28.768]             length <- base::length
[17:02:28.768]             list <- base::list
[17:02:28.768]             seq.int <- base::seq.int
[17:02:28.768]             signalCondition <- base::signalCondition
[17:02:28.768]             sys.calls <- base::sys.calls
[17:02:28.768]             `[[` <- base::`[[`
[17:02:28.768]             `+` <- base::`+`
[17:02:28.768]             `<<-` <- base::`<<-`
[17:02:28.768]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.768]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.768]                   3L)]
[17:02:28.768]             }
[17:02:28.768]             function(cond) {
[17:02:28.768]                 is_error <- inherits(cond, "error")
[17:02:28.768]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.768]                   NULL)
[17:02:28.768]                 if (is_error) {
[17:02:28.768]                   sessionInformation <- function() {
[17:02:28.768]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.768]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.768]                       search = base::search(), system = base::Sys.info())
[17:02:28.768]                   }
[17:02:28.768]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.768]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.768]                     cond$call), session = sessionInformation(), 
[17:02:28.768]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.768]                   signalCondition(cond)
[17:02:28.768]                 }
[17:02:28.768]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.768]                 "immediateCondition"))) {
[17:02:28.768]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.768]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.768]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.768]                   if (TRUE && !signal) {
[17:02:28.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.768]                     {
[17:02:28.768]                       inherits <- base::inherits
[17:02:28.768]                       invokeRestart <- base::invokeRestart
[17:02:28.768]                       is.null <- base::is.null
[17:02:28.768]                       muffled <- FALSE
[17:02:28.768]                       if (inherits(cond, "message")) {
[17:02:28.768]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.768]                         if (muffled) 
[17:02:28.768]                           invokeRestart("muffleMessage")
[17:02:28.768]                       }
[17:02:28.768]                       else if (inherits(cond, "warning")) {
[17:02:28.768]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.768]                         if (muffled) 
[17:02:28.768]                           invokeRestart("muffleWarning")
[17:02:28.768]                       }
[17:02:28.768]                       else if (inherits(cond, "condition")) {
[17:02:28.768]                         if (!is.null(pattern)) {
[17:02:28.768]                           computeRestarts <- base::computeRestarts
[17:02:28.768]                           grepl <- base::grepl
[17:02:28.768]                           restarts <- computeRestarts(cond)
[17:02:28.768]                           for (restart in restarts) {
[17:02:28.768]                             name <- restart$name
[17:02:28.768]                             if (is.null(name)) 
[17:02:28.768]                               next
[17:02:28.768]                             if (!grepl(pattern, name)) 
[17:02:28.768]                               next
[17:02:28.768]                             invokeRestart(restart)
[17:02:28.768]                             muffled <- TRUE
[17:02:28.768]                             break
[17:02:28.768]                           }
[17:02:28.768]                         }
[17:02:28.768]                       }
[17:02:28.768]                       invisible(muffled)
[17:02:28.768]                     }
[17:02:28.768]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.768]                   }
[17:02:28.768]                 }
[17:02:28.768]                 else {
[17:02:28.768]                   if (TRUE) {
[17:02:28.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.768]                     {
[17:02:28.768]                       inherits <- base::inherits
[17:02:28.768]                       invokeRestart <- base::invokeRestart
[17:02:28.768]                       is.null <- base::is.null
[17:02:28.768]                       muffled <- FALSE
[17:02:28.768]                       if (inherits(cond, "message")) {
[17:02:28.768]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.768]                         if (muffled) 
[17:02:28.768]                           invokeRestart("muffleMessage")
[17:02:28.768]                       }
[17:02:28.768]                       else if (inherits(cond, "warning")) {
[17:02:28.768]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.768]                         if (muffled) 
[17:02:28.768]                           invokeRestart("muffleWarning")
[17:02:28.768]                       }
[17:02:28.768]                       else if (inherits(cond, "condition")) {
[17:02:28.768]                         if (!is.null(pattern)) {
[17:02:28.768]                           computeRestarts <- base::computeRestarts
[17:02:28.768]                           grepl <- base::grepl
[17:02:28.768]                           restarts <- computeRestarts(cond)
[17:02:28.768]                           for (restart in restarts) {
[17:02:28.768]                             name <- restart$name
[17:02:28.768]                             if (is.null(name)) 
[17:02:28.768]                               next
[17:02:28.768]                             if (!grepl(pattern, name)) 
[17:02:28.768]                               next
[17:02:28.768]                             invokeRestart(restart)
[17:02:28.768]                             muffled <- TRUE
[17:02:28.768]                             break
[17:02:28.768]                           }
[17:02:28.768]                         }
[17:02:28.768]                       }
[17:02:28.768]                       invisible(muffled)
[17:02:28.768]                     }
[17:02:28.768]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.768]                   }
[17:02:28.768]                 }
[17:02:28.768]             }
[17:02:28.768]         }))
[17:02:28.768]     }, error = function(ex) {
[17:02:28.768]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.768]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.768]                 ...future.rng), started = ...future.startTime, 
[17:02:28.768]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.768]             version = "1.8"), class = "FutureResult")
[17:02:28.768]     }, finally = {
[17:02:28.768]         if (!identical(...future.workdir, getwd())) 
[17:02:28.768]             setwd(...future.workdir)
[17:02:28.768]         {
[17:02:28.768]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.768]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.768]             }
[17:02:28.768]             base::options(...future.oldOptions)
[17:02:28.768]             if (.Platform$OS.type == "windows") {
[17:02:28.768]                 old_names <- names(...future.oldEnvVars)
[17:02:28.768]                 envs <- base::Sys.getenv()
[17:02:28.768]                 names <- names(envs)
[17:02:28.768]                 common <- intersect(names, old_names)
[17:02:28.768]                 added <- setdiff(names, old_names)
[17:02:28.768]                 removed <- setdiff(old_names, names)
[17:02:28.768]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.768]                   envs[common]]
[17:02:28.768]                 NAMES <- toupper(changed)
[17:02:28.768]                 args <- list()
[17:02:28.768]                 for (kk in seq_along(NAMES)) {
[17:02:28.768]                   name <- changed[[kk]]
[17:02:28.768]                   NAME <- NAMES[[kk]]
[17:02:28.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.768]                     next
[17:02:28.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.768]                 }
[17:02:28.768]                 NAMES <- toupper(added)
[17:02:28.768]                 for (kk in seq_along(NAMES)) {
[17:02:28.768]                   name <- added[[kk]]
[17:02:28.768]                   NAME <- NAMES[[kk]]
[17:02:28.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.768]                     next
[17:02:28.768]                   args[[name]] <- ""
[17:02:28.768]                 }
[17:02:28.768]                 NAMES <- toupper(removed)
[17:02:28.768]                 for (kk in seq_along(NAMES)) {
[17:02:28.768]                   name <- removed[[kk]]
[17:02:28.768]                   NAME <- NAMES[[kk]]
[17:02:28.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.768]                     next
[17:02:28.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.768]                 }
[17:02:28.768]                 if (length(args) > 0) 
[17:02:28.768]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.768]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.768]             }
[17:02:28.768]             else {
[17:02:28.768]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.768]             }
[17:02:28.768]             {
[17:02:28.768]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.768]                   0L) {
[17:02:28.768]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.768]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.768]                   base::options(opts)
[17:02:28.768]                 }
[17:02:28.768]                 {
[17:02:28.768]                   {
[17:02:28.768]                     NULL
[17:02:28.768]                     RNGkind("Mersenne-Twister")
[17:02:28.768]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.768]                       inherits = FALSE)
[17:02:28.768]                   }
[17:02:28.768]                   options(future.plan = NULL)
[17:02:28.768]                   if (is.na(NA_character_)) 
[17:02:28.768]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.768]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.768]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.768]                     .init = FALSE)
[17:02:28.768]                 }
[17:02:28.768]             }
[17:02:28.768]         }
[17:02:28.768]     })
[17:02:28.768]     if (TRUE) {
[17:02:28.768]         base::sink(type = "output", split = FALSE)
[17:02:28.768]         if (TRUE) {
[17:02:28.768]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.768]         }
[17:02:28.768]         else {
[17:02:28.768]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.768]         }
[17:02:28.768]         base::close(...future.stdout)
[17:02:28.768]         ...future.stdout <- NULL
[17:02:28.768]     }
[17:02:28.768]     ...future.result$conditions <- ...future.conditions
[17:02:28.768]     ...future.result$finished <- base::Sys.time()
[17:02:28.768]     ...future.result
[17:02:28.768] }
[17:02:28.770] plan(): Setting new future strategy stack:
[17:02:28.770] List of future strategies:
[17:02:28.770] 1. sequential:
[17:02:28.770]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.770]    - tweaked: FALSE
[17:02:28.770]    - call: NULL
[17:02:28.770] plan(): nbrOfWorkers() = 1
[17:02:28.771] plan(): Setting new future strategy stack:
[17:02:28.771] List of future strategies:
[17:02:28.771] 1. sequential:
[17:02:28.771]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.771]    - tweaked: FALSE
[17:02:28.771]    - call: plan(strategy)
[17:02:28.771] plan(): nbrOfWorkers() = 1
[17:02:28.772] SequentialFuture started (and completed)
[17:02:28.772] - Launch lazy future ... done
[17:02:28.772] run() for ‘SequentialFuture’ ... done
[17:02:28.772] getGlobalsAndPackages() ...
[17:02:28.772] Searching for globals...
[17:02:28.773] - globals found: [1] ‘{’
[17:02:28.773] Searching for globals ... DONE
[17:02:28.773] Resolving globals: FALSE
[17:02:28.773] 
[17:02:28.773] 
[17:02:28.773] getGlobalsAndPackages() ... DONE
[17:02:28.774] run() for ‘Future’ ...
[17:02:28.774] - state: ‘created’
[17:02:28.776] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.776] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.776] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.776]   - Field: ‘label’
[17:02:28.777]   - Field: ‘local’
[17:02:28.777]   - Field: ‘owner’
[17:02:28.777]   - Field: ‘envir’
[17:02:28.777]   - Field: ‘packages’
[17:02:28.777]   - Field: ‘gc’
[17:02:28.777]   - Field: ‘conditions’
[17:02:28.777]   - Field: ‘expr’
[17:02:28.777]   - Field: ‘uuid’
[17:02:28.777]   - Field: ‘seed’
[17:02:28.777]   - Field: ‘version’
[17:02:28.777]   - Field: ‘result’
[17:02:28.778]   - Field: ‘asynchronous’
[17:02:28.778]   - Field: ‘calls’
[17:02:28.778]   - Field: ‘globals’
[17:02:28.778]   - Field: ‘stdout’
[17:02:28.778]   - Field: ‘earlySignal’
[17:02:28.778]   - Field: ‘lazy’
[17:02:28.778]   - Field: ‘state’
[17:02:28.778] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.778] - Launch lazy future ...
[17:02:28.778] Packages needed by the future expression (n = 0): <none>
[17:02:28.779] Packages needed by future strategies (n = 0): <none>
[17:02:28.779] {
[17:02:28.779]     {
[17:02:28.779]         {
[17:02:28.779]             ...future.startTime <- base::Sys.time()
[17:02:28.779]             {
[17:02:28.779]                 {
[17:02:28.779]                   {
[17:02:28.779]                     base::local({
[17:02:28.779]                       has_future <- base::requireNamespace("future", 
[17:02:28.779]                         quietly = TRUE)
[17:02:28.779]                       if (has_future) {
[17:02:28.779]                         ns <- base::getNamespace("future")
[17:02:28.779]                         version <- ns[[".package"]][["version"]]
[17:02:28.779]                         if (is.null(version)) 
[17:02:28.779]                           version <- utils::packageVersion("future")
[17:02:28.779]                       }
[17:02:28.779]                       else {
[17:02:28.779]                         version <- NULL
[17:02:28.779]                       }
[17:02:28.779]                       if (!has_future || version < "1.8.0") {
[17:02:28.779]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.779]                           "", base::R.version$version.string), 
[17:02:28.779]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.779]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.779]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.779]                             "release", "version")], collapse = " "), 
[17:02:28.779]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.779]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.779]                           info)
[17:02:28.779]                         info <- base::paste(info, collapse = "; ")
[17:02:28.779]                         if (!has_future) {
[17:02:28.779]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.779]                             info)
[17:02:28.779]                         }
[17:02:28.779]                         else {
[17:02:28.779]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.779]                             info, version)
[17:02:28.779]                         }
[17:02:28.779]                         base::stop(msg)
[17:02:28.779]                       }
[17:02:28.779]                     })
[17:02:28.779]                   }
[17:02:28.779]                   ...future.strategy.old <- future::plan("list")
[17:02:28.779]                   options(future.plan = NULL)
[17:02:28.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.779]                 }
[17:02:28.779]                 ...future.workdir <- getwd()
[17:02:28.779]             }
[17:02:28.779]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.779]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.779]         }
[17:02:28.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.779]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.779]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.779]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.779]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.779]             base::names(...future.oldOptions))
[17:02:28.779]     }
[17:02:28.779]     if (FALSE) {
[17:02:28.779]     }
[17:02:28.779]     else {
[17:02:28.779]         if (TRUE) {
[17:02:28.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.779]                 open = "w")
[17:02:28.779]         }
[17:02:28.779]         else {
[17:02:28.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.779]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.779]         }
[17:02:28.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.779]             base::sink(type = "output", split = FALSE)
[17:02:28.779]             base::close(...future.stdout)
[17:02:28.779]         }, add = TRUE)
[17:02:28.779]     }
[17:02:28.779]     ...future.frame <- base::sys.nframe()
[17:02:28.779]     ...future.conditions <- base::list()
[17:02:28.779]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.779]     if (FALSE) {
[17:02:28.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.779]     }
[17:02:28.779]     ...future.result <- base::tryCatch({
[17:02:28.779]         base::withCallingHandlers({
[17:02:28.779]             ...future.value <- base::withVisible(base::local({
[17:02:28.779]                 4
[17:02:28.779]             }))
[17:02:28.779]             future::FutureResult(value = ...future.value$value, 
[17:02:28.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.779]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.779]                     ...future.globalenv.names))
[17:02:28.779]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.779]         }, condition = base::local({
[17:02:28.779]             c <- base::c
[17:02:28.779]             inherits <- base::inherits
[17:02:28.779]             invokeRestart <- base::invokeRestart
[17:02:28.779]             length <- base::length
[17:02:28.779]             list <- base::list
[17:02:28.779]             seq.int <- base::seq.int
[17:02:28.779]             signalCondition <- base::signalCondition
[17:02:28.779]             sys.calls <- base::sys.calls
[17:02:28.779]             `[[` <- base::`[[`
[17:02:28.779]             `+` <- base::`+`
[17:02:28.779]             `<<-` <- base::`<<-`
[17:02:28.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.779]                   3L)]
[17:02:28.779]             }
[17:02:28.779]             function(cond) {
[17:02:28.779]                 is_error <- inherits(cond, "error")
[17:02:28.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.779]                   NULL)
[17:02:28.779]                 if (is_error) {
[17:02:28.779]                   sessionInformation <- function() {
[17:02:28.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.779]                       search = base::search(), system = base::Sys.info())
[17:02:28.779]                   }
[17:02:28.779]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.779]                     cond$call), session = sessionInformation(), 
[17:02:28.779]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.779]                   signalCondition(cond)
[17:02:28.779]                 }
[17:02:28.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.779]                 "immediateCondition"))) {
[17:02:28.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.779]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.779]                   if (TRUE && !signal) {
[17:02:28.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.779]                     {
[17:02:28.779]                       inherits <- base::inherits
[17:02:28.779]                       invokeRestart <- base::invokeRestart
[17:02:28.779]                       is.null <- base::is.null
[17:02:28.779]                       muffled <- FALSE
[17:02:28.779]                       if (inherits(cond, "message")) {
[17:02:28.779]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.779]                         if (muffled) 
[17:02:28.779]                           invokeRestart("muffleMessage")
[17:02:28.779]                       }
[17:02:28.779]                       else if (inherits(cond, "warning")) {
[17:02:28.779]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.779]                         if (muffled) 
[17:02:28.779]                           invokeRestart("muffleWarning")
[17:02:28.779]                       }
[17:02:28.779]                       else if (inherits(cond, "condition")) {
[17:02:28.779]                         if (!is.null(pattern)) {
[17:02:28.779]                           computeRestarts <- base::computeRestarts
[17:02:28.779]                           grepl <- base::grepl
[17:02:28.779]                           restarts <- computeRestarts(cond)
[17:02:28.779]                           for (restart in restarts) {
[17:02:28.779]                             name <- restart$name
[17:02:28.779]                             if (is.null(name)) 
[17:02:28.779]                               next
[17:02:28.779]                             if (!grepl(pattern, name)) 
[17:02:28.779]                               next
[17:02:28.779]                             invokeRestart(restart)
[17:02:28.779]                             muffled <- TRUE
[17:02:28.779]                             break
[17:02:28.779]                           }
[17:02:28.779]                         }
[17:02:28.779]                       }
[17:02:28.779]                       invisible(muffled)
[17:02:28.779]                     }
[17:02:28.779]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.779]                   }
[17:02:28.779]                 }
[17:02:28.779]                 else {
[17:02:28.779]                   if (TRUE) {
[17:02:28.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.779]                     {
[17:02:28.779]                       inherits <- base::inherits
[17:02:28.779]                       invokeRestart <- base::invokeRestart
[17:02:28.779]                       is.null <- base::is.null
[17:02:28.779]                       muffled <- FALSE
[17:02:28.779]                       if (inherits(cond, "message")) {
[17:02:28.779]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.779]                         if (muffled) 
[17:02:28.779]                           invokeRestart("muffleMessage")
[17:02:28.779]                       }
[17:02:28.779]                       else if (inherits(cond, "warning")) {
[17:02:28.779]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.779]                         if (muffled) 
[17:02:28.779]                           invokeRestart("muffleWarning")
[17:02:28.779]                       }
[17:02:28.779]                       else if (inherits(cond, "condition")) {
[17:02:28.779]                         if (!is.null(pattern)) {
[17:02:28.779]                           computeRestarts <- base::computeRestarts
[17:02:28.779]                           grepl <- base::grepl
[17:02:28.779]                           restarts <- computeRestarts(cond)
[17:02:28.779]                           for (restart in restarts) {
[17:02:28.779]                             name <- restart$name
[17:02:28.779]                             if (is.null(name)) 
[17:02:28.779]                               next
[17:02:28.779]                             if (!grepl(pattern, name)) 
[17:02:28.779]                               next
[17:02:28.779]                             invokeRestart(restart)
[17:02:28.779]                             muffled <- TRUE
[17:02:28.779]                             break
[17:02:28.779]                           }
[17:02:28.779]                         }
[17:02:28.779]                       }
[17:02:28.779]                       invisible(muffled)
[17:02:28.779]                     }
[17:02:28.779]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.779]                   }
[17:02:28.779]                 }
[17:02:28.779]             }
[17:02:28.779]         }))
[17:02:28.779]     }, error = function(ex) {
[17:02:28.779]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.779]                 ...future.rng), started = ...future.startTime, 
[17:02:28.779]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.779]             version = "1.8"), class = "FutureResult")
[17:02:28.779]     }, finally = {
[17:02:28.779]         if (!identical(...future.workdir, getwd())) 
[17:02:28.779]             setwd(...future.workdir)
[17:02:28.779]         {
[17:02:28.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.779]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.779]             }
[17:02:28.779]             base::options(...future.oldOptions)
[17:02:28.779]             if (.Platform$OS.type == "windows") {
[17:02:28.779]                 old_names <- names(...future.oldEnvVars)
[17:02:28.779]                 envs <- base::Sys.getenv()
[17:02:28.779]                 names <- names(envs)
[17:02:28.779]                 common <- intersect(names, old_names)
[17:02:28.779]                 added <- setdiff(names, old_names)
[17:02:28.779]                 removed <- setdiff(old_names, names)
[17:02:28.779]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.779]                   envs[common]]
[17:02:28.779]                 NAMES <- toupper(changed)
[17:02:28.779]                 args <- list()
[17:02:28.779]                 for (kk in seq_along(NAMES)) {
[17:02:28.779]                   name <- changed[[kk]]
[17:02:28.779]                   NAME <- NAMES[[kk]]
[17:02:28.779]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.779]                     next
[17:02:28.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.779]                 }
[17:02:28.779]                 NAMES <- toupper(added)
[17:02:28.779]                 for (kk in seq_along(NAMES)) {
[17:02:28.779]                   name <- added[[kk]]
[17:02:28.779]                   NAME <- NAMES[[kk]]
[17:02:28.779]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.779]                     next
[17:02:28.779]                   args[[name]] <- ""
[17:02:28.779]                 }
[17:02:28.779]                 NAMES <- toupper(removed)
[17:02:28.779]                 for (kk in seq_along(NAMES)) {
[17:02:28.779]                   name <- removed[[kk]]
[17:02:28.779]                   NAME <- NAMES[[kk]]
[17:02:28.779]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.779]                     next
[17:02:28.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.779]                 }
[17:02:28.779]                 if (length(args) > 0) 
[17:02:28.779]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.779]             }
[17:02:28.779]             else {
[17:02:28.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.779]             }
[17:02:28.779]             {
[17:02:28.779]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.779]                   0L) {
[17:02:28.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.779]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.779]                   base::options(opts)
[17:02:28.779]                 }
[17:02:28.779]                 {
[17:02:28.779]                   {
[17:02:28.779]                     NULL
[17:02:28.779]                     RNGkind("Mersenne-Twister")
[17:02:28.779]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.779]                       inherits = FALSE)
[17:02:28.779]                   }
[17:02:28.779]                   options(future.plan = NULL)
[17:02:28.779]                   if (is.na(NA_character_)) 
[17:02:28.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.779]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.779]                     .init = FALSE)
[17:02:28.779]                 }
[17:02:28.779]             }
[17:02:28.779]         }
[17:02:28.779]     })
[17:02:28.779]     if (TRUE) {
[17:02:28.779]         base::sink(type = "output", split = FALSE)
[17:02:28.779]         if (TRUE) {
[17:02:28.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.779]         }
[17:02:28.779]         else {
[17:02:28.779]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.779]         }
[17:02:28.779]         base::close(...future.stdout)
[17:02:28.779]         ...future.stdout <- NULL
[17:02:28.779]     }
[17:02:28.779]     ...future.result$conditions <- ...future.conditions
[17:02:28.779]     ...future.result$finished <- base::Sys.time()
[17:02:28.779]     ...future.result
[17:02:28.779] }
[17:02:28.781] plan(): Setting new future strategy stack:
[17:02:28.781] List of future strategies:
[17:02:28.781] 1. sequential:
[17:02:28.781]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.781]    - tweaked: FALSE
[17:02:28.781]    - call: NULL
[17:02:28.781] plan(): nbrOfWorkers() = 1
[17:02:28.782] plan(): Setting new future strategy stack:
[17:02:28.782] List of future strategies:
[17:02:28.782] 1. sequential:
[17:02:28.782]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.782]    - tweaked: FALSE
[17:02:28.782]    - call: plan(strategy)
[17:02:28.783] plan(): nbrOfWorkers() = 1
[17:02:28.783] SequentialFuture started (and completed)
[17:02:28.783] - Launch lazy future ... done
[17:02:28.783] run() for ‘SequentialFuture’ ... done
<environment: 0x55c7490909f8> 
<environment: 0x55c74787d270> 
[17:02:28.784] resolved() for ‘SequentialFuture’ ...
[17:02:28.784] - state: ‘finished’
[17:02:28.784] - run: TRUE
[17:02:28.785] - result: ‘FutureResult’
[17:02:28.785] resolved() for ‘SequentialFuture’ ... done
[17:02:28.785] resolved() for ‘SequentialFuture’ ...
[17:02:28.785] - state: ‘finished’
[17:02:28.785] - run: TRUE
[17:02:28.785] - result: ‘FutureResult’
[17:02:28.785] resolved() for ‘SequentialFuture’ ... done
[17:02:28.785] resolved() for ‘SequentialFuture’ ...
[17:02:28.785] - state: ‘finished’
[17:02:28.785] - run: TRUE
[17:02:28.786] - result: ‘FutureResult’
[17:02:28.786] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:28.787] resolve() on environment ...
[17:02:28.787]  recursive: 0
[17:02:28.787]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:28.787] signalConditionsASAP(numeric, pos=1) ...
[17:02:28.788] - nx: 4
[17:02:28.788] - relay: TRUE
[17:02:28.788] - stdout: TRUE
[17:02:28.788] - signal: TRUE
[17:02:28.788] - resignal: FALSE
[17:02:28.788] - force: TRUE
[17:02:28.788] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.788] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.788]  - until=2
[17:02:28.788]  - relaying element #2
[17:02:28.788] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:28.788] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.789] signalConditionsASAP(NULL, pos=1) ... done
[17:02:28.789]  length: 3 (resolved future 1)
[17:02:28.789] resolved() for ‘SequentialFuture’ ...
[17:02:28.789] - state: ‘finished’
[17:02:28.789] - run: TRUE
[17:02:28.789] - result: ‘FutureResult’
[17:02:28.789] resolved() for ‘SequentialFuture’ ... done
[17:02:28.789] Future #2
[17:02:28.789] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:28.789] - nx: 4
[17:02:28.790] - relay: TRUE
[17:02:28.790] - stdout: TRUE
[17:02:28.790] - signal: TRUE
[17:02:28.790] - resignal: FALSE
[17:02:28.790] - force: TRUE
[17:02:28.790] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:28.790] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.790]  - until=2
[17:02:28.790]  - relaying element #2
[17:02:28.790] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:28.790] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:28.791] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:28.791]  length: 2 (resolved future 2)
[17:02:28.791] resolved() for ‘SequentialFuture’ ...
[17:02:28.791] - state: ‘finished’
[17:02:28.791] - run: TRUE
[17:02:28.791] - result: ‘FutureResult’
[17:02:28.791] resolved() for ‘SequentialFuture’ ... done
[17:02:28.791] Future #3
[17:02:28.791] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:28.791] - nx: 4
[17:02:28.792] - relay: TRUE
[17:02:28.792] - stdout: TRUE
[17:02:28.792] - signal: TRUE
[17:02:28.792] - resignal: FALSE
[17:02:28.792] - force: TRUE
[17:02:28.792] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:28.792] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:28.792]  - until=3
[17:02:28.792]  - relaying element #3
[17:02:28.792] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:28.792] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:28.793] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:28.793]  length: 1 (resolved future 3)
[17:02:28.793] resolved() for ‘SequentialFuture’ ...
[17:02:28.793] - state: ‘finished’
[17:02:28.793] - run: TRUE
[17:02:28.793] - result: ‘FutureResult’
[17:02:28.793] resolved() for ‘SequentialFuture’ ... done
[17:02:28.793] Future #4
[17:02:28.793] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:02:28.793] - nx: 4
[17:02:28.794] - relay: TRUE
[17:02:28.794] - stdout: TRUE
[17:02:28.794] - signal: TRUE
[17:02:28.794] - resignal: FALSE
[17:02:28.794] - force: TRUE
[17:02:28.794] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:28.794] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:28.794]  - until=4
[17:02:28.794]  - relaying element #4
[17:02:28.794] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.794] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:28.795] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:02:28.795]  length: 0 (resolved future 4)
[17:02:28.795] Relaying remaining futures
[17:02:28.795] signalConditionsASAP(NULL, pos=0) ...
[17:02:28.795] - nx: 4
[17:02:28.795] - relay: TRUE
[17:02:28.795] - stdout: TRUE
[17:02:28.795] - signal: TRUE
[17:02:28.795] - resignal: FALSE
[17:02:28.795] - force: TRUE
[17:02:28.795] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.795] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:28.796] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.796] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:28.796] signalConditionsASAP(NULL, pos=0) ... done
[17:02:28.796] resolve() on environment ... DONE
<environment: 0x55c74900d2a8> 
Dimensions: c(2, 3, 1)
[17:02:28.796] getGlobalsAndPackages() ...
[17:02:28.796] Searching for globals...
[17:02:28.797] 
[17:02:28.797] Searching for globals ... DONE
[17:02:28.797] - globals: [0] <none>
[17:02:28.797] getGlobalsAndPackages() ... DONE
[17:02:28.797] run() for ‘Future’ ...
[17:02:28.797] - state: ‘created’
[17:02:28.798] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.798] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.798] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.798]   - Field: ‘label’
[17:02:28.798]   - Field: ‘local’
[17:02:28.798]   - Field: ‘owner’
[17:02:28.798]   - Field: ‘envir’
[17:02:28.798]   - Field: ‘packages’
[17:02:28.799]   - Field: ‘gc’
[17:02:28.799]   - Field: ‘conditions’
[17:02:28.799]   - Field: ‘expr’
[17:02:28.799]   - Field: ‘uuid’
[17:02:28.799]   - Field: ‘seed’
[17:02:28.799]   - Field: ‘version’
[17:02:28.799]   - Field: ‘result’
[17:02:28.799]   - Field: ‘asynchronous’
[17:02:28.799]   - Field: ‘calls’
[17:02:28.799]   - Field: ‘globals’
[17:02:28.799]   - Field: ‘stdout’
[17:02:28.800]   - Field: ‘earlySignal’
[17:02:28.800]   - Field: ‘lazy’
[17:02:28.800]   - Field: ‘state’
[17:02:28.800] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.800] - Launch lazy future ...
[17:02:28.800] Packages needed by the future expression (n = 0): <none>
[17:02:28.800] Packages needed by future strategies (n = 0): <none>
[17:02:28.801] {
[17:02:28.801]     {
[17:02:28.801]         {
[17:02:28.801]             ...future.startTime <- base::Sys.time()
[17:02:28.801]             {
[17:02:28.801]                 {
[17:02:28.801]                   {
[17:02:28.801]                     base::local({
[17:02:28.801]                       has_future <- base::requireNamespace("future", 
[17:02:28.801]                         quietly = TRUE)
[17:02:28.801]                       if (has_future) {
[17:02:28.801]                         ns <- base::getNamespace("future")
[17:02:28.801]                         version <- ns[[".package"]][["version"]]
[17:02:28.801]                         if (is.null(version)) 
[17:02:28.801]                           version <- utils::packageVersion("future")
[17:02:28.801]                       }
[17:02:28.801]                       else {
[17:02:28.801]                         version <- NULL
[17:02:28.801]                       }
[17:02:28.801]                       if (!has_future || version < "1.8.0") {
[17:02:28.801]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.801]                           "", base::R.version$version.string), 
[17:02:28.801]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.801]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.801]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.801]                             "release", "version")], collapse = " "), 
[17:02:28.801]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.801]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.801]                           info)
[17:02:28.801]                         info <- base::paste(info, collapse = "; ")
[17:02:28.801]                         if (!has_future) {
[17:02:28.801]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.801]                             info)
[17:02:28.801]                         }
[17:02:28.801]                         else {
[17:02:28.801]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.801]                             info, version)
[17:02:28.801]                         }
[17:02:28.801]                         base::stop(msg)
[17:02:28.801]                       }
[17:02:28.801]                     })
[17:02:28.801]                   }
[17:02:28.801]                   ...future.strategy.old <- future::plan("list")
[17:02:28.801]                   options(future.plan = NULL)
[17:02:28.801]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.801]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.801]                 }
[17:02:28.801]                 ...future.workdir <- getwd()
[17:02:28.801]             }
[17:02:28.801]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.801]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.801]         }
[17:02:28.801]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.801]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.801]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.801]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.801]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.801]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.801]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.801]             base::names(...future.oldOptions))
[17:02:28.801]     }
[17:02:28.801]     if (FALSE) {
[17:02:28.801]     }
[17:02:28.801]     else {
[17:02:28.801]         if (TRUE) {
[17:02:28.801]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.801]                 open = "w")
[17:02:28.801]         }
[17:02:28.801]         else {
[17:02:28.801]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.801]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.801]         }
[17:02:28.801]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.801]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.801]             base::sink(type = "output", split = FALSE)
[17:02:28.801]             base::close(...future.stdout)
[17:02:28.801]         }, add = TRUE)
[17:02:28.801]     }
[17:02:28.801]     ...future.frame <- base::sys.nframe()
[17:02:28.801]     ...future.conditions <- base::list()
[17:02:28.801]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.801]     if (FALSE) {
[17:02:28.801]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.801]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.801]     }
[17:02:28.801]     ...future.result <- base::tryCatch({
[17:02:28.801]         base::withCallingHandlers({
[17:02:28.801]             ...future.value <- base::withVisible(base::local(2))
[17:02:28.801]             future::FutureResult(value = ...future.value$value, 
[17:02:28.801]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.801]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.801]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.801]                     ...future.globalenv.names))
[17:02:28.801]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.801]         }, condition = base::local({
[17:02:28.801]             c <- base::c
[17:02:28.801]             inherits <- base::inherits
[17:02:28.801]             invokeRestart <- base::invokeRestart
[17:02:28.801]             length <- base::length
[17:02:28.801]             list <- base::list
[17:02:28.801]             seq.int <- base::seq.int
[17:02:28.801]             signalCondition <- base::signalCondition
[17:02:28.801]             sys.calls <- base::sys.calls
[17:02:28.801]             `[[` <- base::`[[`
[17:02:28.801]             `+` <- base::`+`
[17:02:28.801]             `<<-` <- base::`<<-`
[17:02:28.801]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.801]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.801]                   3L)]
[17:02:28.801]             }
[17:02:28.801]             function(cond) {
[17:02:28.801]                 is_error <- inherits(cond, "error")
[17:02:28.801]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.801]                   NULL)
[17:02:28.801]                 if (is_error) {
[17:02:28.801]                   sessionInformation <- function() {
[17:02:28.801]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.801]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.801]                       search = base::search(), system = base::Sys.info())
[17:02:28.801]                   }
[17:02:28.801]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.801]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.801]                     cond$call), session = sessionInformation(), 
[17:02:28.801]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.801]                   signalCondition(cond)
[17:02:28.801]                 }
[17:02:28.801]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.801]                 "immediateCondition"))) {
[17:02:28.801]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.801]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.801]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.801]                   if (TRUE && !signal) {
[17:02:28.801]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.801]                     {
[17:02:28.801]                       inherits <- base::inherits
[17:02:28.801]                       invokeRestart <- base::invokeRestart
[17:02:28.801]                       is.null <- base::is.null
[17:02:28.801]                       muffled <- FALSE
[17:02:28.801]                       if (inherits(cond, "message")) {
[17:02:28.801]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.801]                         if (muffled) 
[17:02:28.801]                           invokeRestart("muffleMessage")
[17:02:28.801]                       }
[17:02:28.801]                       else if (inherits(cond, "warning")) {
[17:02:28.801]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.801]                         if (muffled) 
[17:02:28.801]                           invokeRestart("muffleWarning")
[17:02:28.801]                       }
[17:02:28.801]                       else if (inherits(cond, "condition")) {
[17:02:28.801]                         if (!is.null(pattern)) {
[17:02:28.801]                           computeRestarts <- base::computeRestarts
[17:02:28.801]                           grepl <- base::grepl
[17:02:28.801]                           restarts <- computeRestarts(cond)
[17:02:28.801]                           for (restart in restarts) {
[17:02:28.801]                             name <- restart$name
[17:02:28.801]                             if (is.null(name)) 
[17:02:28.801]                               next
[17:02:28.801]                             if (!grepl(pattern, name)) 
[17:02:28.801]                               next
[17:02:28.801]                             invokeRestart(restart)
[17:02:28.801]                             muffled <- TRUE
[17:02:28.801]                             break
[17:02:28.801]                           }
[17:02:28.801]                         }
[17:02:28.801]                       }
[17:02:28.801]                       invisible(muffled)
[17:02:28.801]                     }
[17:02:28.801]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.801]                   }
[17:02:28.801]                 }
[17:02:28.801]                 else {
[17:02:28.801]                   if (TRUE) {
[17:02:28.801]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.801]                     {
[17:02:28.801]                       inherits <- base::inherits
[17:02:28.801]                       invokeRestart <- base::invokeRestart
[17:02:28.801]                       is.null <- base::is.null
[17:02:28.801]                       muffled <- FALSE
[17:02:28.801]                       if (inherits(cond, "message")) {
[17:02:28.801]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.801]                         if (muffled) 
[17:02:28.801]                           invokeRestart("muffleMessage")
[17:02:28.801]                       }
[17:02:28.801]                       else if (inherits(cond, "warning")) {
[17:02:28.801]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.801]                         if (muffled) 
[17:02:28.801]                           invokeRestart("muffleWarning")
[17:02:28.801]                       }
[17:02:28.801]                       else if (inherits(cond, "condition")) {
[17:02:28.801]                         if (!is.null(pattern)) {
[17:02:28.801]                           computeRestarts <- base::computeRestarts
[17:02:28.801]                           grepl <- base::grepl
[17:02:28.801]                           restarts <- computeRestarts(cond)
[17:02:28.801]                           for (restart in restarts) {
[17:02:28.801]                             name <- restart$name
[17:02:28.801]                             if (is.null(name)) 
[17:02:28.801]                               next
[17:02:28.801]                             if (!grepl(pattern, name)) 
[17:02:28.801]                               next
[17:02:28.801]                             invokeRestart(restart)
[17:02:28.801]                             muffled <- TRUE
[17:02:28.801]                             break
[17:02:28.801]                           }
[17:02:28.801]                         }
[17:02:28.801]                       }
[17:02:28.801]                       invisible(muffled)
[17:02:28.801]                     }
[17:02:28.801]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.801]                   }
[17:02:28.801]                 }
[17:02:28.801]             }
[17:02:28.801]         }))
[17:02:28.801]     }, error = function(ex) {
[17:02:28.801]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.801]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.801]                 ...future.rng), started = ...future.startTime, 
[17:02:28.801]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.801]             version = "1.8"), class = "FutureResult")
[17:02:28.801]     }, finally = {
[17:02:28.801]         if (!identical(...future.workdir, getwd())) 
[17:02:28.801]             setwd(...future.workdir)
[17:02:28.801]         {
[17:02:28.801]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.801]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.801]             }
[17:02:28.801]             base::options(...future.oldOptions)
[17:02:28.801]             if (.Platform$OS.type == "windows") {
[17:02:28.801]                 old_names <- names(...future.oldEnvVars)
[17:02:28.801]                 envs <- base::Sys.getenv()
[17:02:28.801]                 names <- names(envs)
[17:02:28.801]                 common <- intersect(names, old_names)
[17:02:28.801]                 added <- setdiff(names, old_names)
[17:02:28.801]                 removed <- setdiff(old_names, names)
[17:02:28.801]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.801]                   envs[common]]
[17:02:28.801]                 NAMES <- toupper(changed)
[17:02:28.801]                 args <- list()
[17:02:28.801]                 for (kk in seq_along(NAMES)) {
[17:02:28.801]                   name <- changed[[kk]]
[17:02:28.801]                   NAME <- NAMES[[kk]]
[17:02:28.801]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.801]                     next
[17:02:28.801]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.801]                 }
[17:02:28.801]                 NAMES <- toupper(added)
[17:02:28.801]                 for (kk in seq_along(NAMES)) {
[17:02:28.801]                   name <- added[[kk]]
[17:02:28.801]                   NAME <- NAMES[[kk]]
[17:02:28.801]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.801]                     next
[17:02:28.801]                   args[[name]] <- ""
[17:02:28.801]                 }
[17:02:28.801]                 NAMES <- toupper(removed)
[17:02:28.801]                 for (kk in seq_along(NAMES)) {
[17:02:28.801]                   name <- removed[[kk]]
[17:02:28.801]                   NAME <- NAMES[[kk]]
[17:02:28.801]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.801]                     next
[17:02:28.801]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.801]                 }
[17:02:28.801]                 if (length(args) > 0) 
[17:02:28.801]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.801]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.801]             }
[17:02:28.801]             else {
[17:02:28.801]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.801]             }
[17:02:28.801]             {
[17:02:28.801]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.801]                   0L) {
[17:02:28.801]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.801]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.801]                   base::options(opts)
[17:02:28.801]                 }
[17:02:28.801]                 {
[17:02:28.801]                   {
[17:02:28.801]                     NULL
[17:02:28.801]                     RNGkind("Mersenne-Twister")
[17:02:28.801]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.801]                       inherits = FALSE)
[17:02:28.801]                   }
[17:02:28.801]                   options(future.plan = NULL)
[17:02:28.801]                   if (is.na(NA_character_)) 
[17:02:28.801]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.801]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.801]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.801]                     .init = FALSE)
[17:02:28.801]                 }
[17:02:28.801]             }
[17:02:28.801]         }
[17:02:28.801]     })
[17:02:28.801]     if (TRUE) {
[17:02:28.801]         base::sink(type = "output", split = FALSE)
[17:02:28.801]         if (TRUE) {
[17:02:28.801]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.801]         }
[17:02:28.801]         else {
[17:02:28.801]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.801]         }
[17:02:28.801]         base::close(...future.stdout)
[17:02:28.801]         ...future.stdout <- NULL
[17:02:28.801]     }
[17:02:28.801]     ...future.result$conditions <- ...future.conditions
[17:02:28.801]     ...future.result$finished <- base::Sys.time()
[17:02:28.801]     ...future.result
[17:02:28.801] }
[17:02:28.802] plan(): Setting new future strategy stack:
[17:02:28.802] List of future strategies:
[17:02:28.802] 1. sequential:
[17:02:28.802]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.802]    - tweaked: FALSE
[17:02:28.802]    - call: NULL
[17:02:28.803] plan(): nbrOfWorkers() = 1
[17:02:28.806] plan(): Setting new future strategy stack:
[17:02:28.806] List of future strategies:
[17:02:28.806] 1. sequential:
[17:02:28.806]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.806]    - tweaked: FALSE
[17:02:28.806]    - call: plan(strategy)
[17:02:28.806] plan(): nbrOfWorkers() = 1
[17:02:28.807] SequentialFuture started (and completed)
[17:02:28.807] - Launch lazy future ... done
[17:02:28.807] run() for ‘SequentialFuture’ ... done
[17:02:28.807] getGlobalsAndPackages() ...
[17:02:28.807] Searching for globals...
[17:02:28.807] 
[17:02:28.807] Searching for globals ... DONE
[17:02:28.808] - globals: [0] <none>
[17:02:28.808] getGlobalsAndPackages() ... DONE
[17:02:28.808] run() for ‘Future’ ...
[17:02:28.808] - state: ‘created’
[17:02:28.808] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.808] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.808] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.809]   - Field: ‘label’
[17:02:28.809]   - Field: ‘local’
[17:02:28.809]   - Field: ‘owner’
[17:02:28.809]   - Field: ‘envir’
[17:02:28.809]   - Field: ‘packages’
[17:02:28.809]   - Field: ‘gc’
[17:02:28.809]   - Field: ‘conditions’
[17:02:28.809]   - Field: ‘expr’
[17:02:28.809]   - Field: ‘uuid’
[17:02:28.809]   - Field: ‘seed’
[17:02:28.809]   - Field: ‘version’
[17:02:28.810]   - Field: ‘result’
[17:02:28.810]   - Field: ‘asynchronous’
[17:02:28.810]   - Field: ‘calls’
[17:02:28.810]   - Field: ‘globals’
[17:02:28.810]   - Field: ‘stdout’
[17:02:28.810]   - Field: ‘earlySignal’
[17:02:28.810]   - Field: ‘lazy’
[17:02:28.810]   - Field: ‘state’
[17:02:28.810] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.810] - Launch lazy future ...
[17:02:28.810] Packages needed by the future expression (n = 0): <none>
[17:02:28.811] Packages needed by future strategies (n = 0): <none>
[17:02:28.811] {
[17:02:28.811]     {
[17:02:28.811]         {
[17:02:28.811]             ...future.startTime <- base::Sys.time()
[17:02:28.811]             {
[17:02:28.811]                 {
[17:02:28.811]                   {
[17:02:28.811]                     base::local({
[17:02:28.811]                       has_future <- base::requireNamespace("future", 
[17:02:28.811]                         quietly = TRUE)
[17:02:28.811]                       if (has_future) {
[17:02:28.811]                         ns <- base::getNamespace("future")
[17:02:28.811]                         version <- ns[[".package"]][["version"]]
[17:02:28.811]                         if (is.null(version)) 
[17:02:28.811]                           version <- utils::packageVersion("future")
[17:02:28.811]                       }
[17:02:28.811]                       else {
[17:02:28.811]                         version <- NULL
[17:02:28.811]                       }
[17:02:28.811]                       if (!has_future || version < "1.8.0") {
[17:02:28.811]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.811]                           "", base::R.version$version.string), 
[17:02:28.811]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.811]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.811]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.811]                             "release", "version")], collapse = " "), 
[17:02:28.811]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.811]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.811]                           info)
[17:02:28.811]                         info <- base::paste(info, collapse = "; ")
[17:02:28.811]                         if (!has_future) {
[17:02:28.811]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.811]                             info)
[17:02:28.811]                         }
[17:02:28.811]                         else {
[17:02:28.811]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.811]                             info, version)
[17:02:28.811]                         }
[17:02:28.811]                         base::stop(msg)
[17:02:28.811]                       }
[17:02:28.811]                     })
[17:02:28.811]                   }
[17:02:28.811]                   ...future.strategy.old <- future::plan("list")
[17:02:28.811]                   options(future.plan = NULL)
[17:02:28.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.811]                 }
[17:02:28.811]                 ...future.workdir <- getwd()
[17:02:28.811]             }
[17:02:28.811]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.811]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.811]         }
[17:02:28.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.811]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.811]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.811]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.811]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.811]             base::names(...future.oldOptions))
[17:02:28.811]     }
[17:02:28.811]     if (FALSE) {
[17:02:28.811]     }
[17:02:28.811]     else {
[17:02:28.811]         if (TRUE) {
[17:02:28.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.811]                 open = "w")
[17:02:28.811]         }
[17:02:28.811]         else {
[17:02:28.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.811]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.811]         }
[17:02:28.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.811]             base::sink(type = "output", split = FALSE)
[17:02:28.811]             base::close(...future.stdout)
[17:02:28.811]         }, add = TRUE)
[17:02:28.811]     }
[17:02:28.811]     ...future.frame <- base::sys.nframe()
[17:02:28.811]     ...future.conditions <- base::list()
[17:02:28.811]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.811]     if (FALSE) {
[17:02:28.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.811]     }
[17:02:28.811]     ...future.result <- base::tryCatch({
[17:02:28.811]         base::withCallingHandlers({
[17:02:28.811]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:28.811]             future::FutureResult(value = ...future.value$value, 
[17:02:28.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.811]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.811]                     ...future.globalenv.names))
[17:02:28.811]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.811]         }, condition = base::local({
[17:02:28.811]             c <- base::c
[17:02:28.811]             inherits <- base::inherits
[17:02:28.811]             invokeRestart <- base::invokeRestart
[17:02:28.811]             length <- base::length
[17:02:28.811]             list <- base::list
[17:02:28.811]             seq.int <- base::seq.int
[17:02:28.811]             signalCondition <- base::signalCondition
[17:02:28.811]             sys.calls <- base::sys.calls
[17:02:28.811]             `[[` <- base::`[[`
[17:02:28.811]             `+` <- base::`+`
[17:02:28.811]             `<<-` <- base::`<<-`
[17:02:28.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.811]                   3L)]
[17:02:28.811]             }
[17:02:28.811]             function(cond) {
[17:02:28.811]                 is_error <- inherits(cond, "error")
[17:02:28.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.811]                   NULL)
[17:02:28.811]                 if (is_error) {
[17:02:28.811]                   sessionInformation <- function() {
[17:02:28.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.811]                       search = base::search(), system = base::Sys.info())
[17:02:28.811]                   }
[17:02:28.811]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.811]                     cond$call), session = sessionInformation(), 
[17:02:28.811]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.811]                   signalCondition(cond)
[17:02:28.811]                 }
[17:02:28.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.811]                 "immediateCondition"))) {
[17:02:28.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.811]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.811]                   if (TRUE && !signal) {
[17:02:28.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.811]                     {
[17:02:28.811]                       inherits <- base::inherits
[17:02:28.811]                       invokeRestart <- base::invokeRestart
[17:02:28.811]                       is.null <- base::is.null
[17:02:28.811]                       muffled <- FALSE
[17:02:28.811]                       if (inherits(cond, "message")) {
[17:02:28.811]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.811]                         if (muffled) 
[17:02:28.811]                           invokeRestart("muffleMessage")
[17:02:28.811]                       }
[17:02:28.811]                       else if (inherits(cond, "warning")) {
[17:02:28.811]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.811]                         if (muffled) 
[17:02:28.811]                           invokeRestart("muffleWarning")
[17:02:28.811]                       }
[17:02:28.811]                       else if (inherits(cond, "condition")) {
[17:02:28.811]                         if (!is.null(pattern)) {
[17:02:28.811]                           computeRestarts <- base::computeRestarts
[17:02:28.811]                           grepl <- base::grepl
[17:02:28.811]                           restarts <- computeRestarts(cond)
[17:02:28.811]                           for (restart in restarts) {
[17:02:28.811]                             name <- restart$name
[17:02:28.811]                             if (is.null(name)) 
[17:02:28.811]                               next
[17:02:28.811]                             if (!grepl(pattern, name)) 
[17:02:28.811]                               next
[17:02:28.811]                             invokeRestart(restart)
[17:02:28.811]                             muffled <- TRUE
[17:02:28.811]                             break
[17:02:28.811]                           }
[17:02:28.811]                         }
[17:02:28.811]                       }
[17:02:28.811]                       invisible(muffled)
[17:02:28.811]                     }
[17:02:28.811]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.811]                   }
[17:02:28.811]                 }
[17:02:28.811]                 else {
[17:02:28.811]                   if (TRUE) {
[17:02:28.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.811]                     {
[17:02:28.811]                       inherits <- base::inherits
[17:02:28.811]                       invokeRestart <- base::invokeRestart
[17:02:28.811]                       is.null <- base::is.null
[17:02:28.811]                       muffled <- FALSE
[17:02:28.811]                       if (inherits(cond, "message")) {
[17:02:28.811]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.811]                         if (muffled) 
[17:02:28.811]                           invokeRestart("muffleMessage")
[17:02:28.811]                       }
[17:02:28.811]                       else if (inherits(cond, "warning")) {
[17:02:28.811]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.811]                         if (muffled) 
[17:02:28.811]                           invokeRestart("muffleWarning")
[17:02:28.811]                       }
[17:02:28.811]                       else if (inherits(cond, "condition")) {
[17:02:28.811]                         if (!is.null(pattern)) {
[17:02:28.811]                           computeRestarts <- base::computeRestarts
[17:02:28.811]                           grepl <- base::grepl
[17:02:28.811]                           restarts <- computeRestarts(cond)
[17:02:28.811]                           for (restart in restarts) {
[17:02:28.811]                             name <- restart$name
[17:02:28.811]                             if (is.null(name)) 
[17:02:28.811]                               next
[17:02:28.811]                             if (!grepl(pattern, name)) 
[17:02:28.811]                               next
[17:02:28.811]                             invokeRestart(restart)
[17:02:28.811]                             muffled <- TRUE
[17:02:28.811]                             break
[17:02:28.811]                           }
[17:02:28.811]                         }
[17:02:28.811]                       }
[17:02:28.811]                       invisible(muffled)
[17:02:28.811]                     }
[17:02:28.811]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.811]                   }
[17:02:28.811]                 }
[17:02:28.811]             }
[17:02:28.811]         }))
[17:02:28.811]     }, error = function(ex) {
[17:02:28.811]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.811]                 ...future.rng), started = ...future.startTime, 
[17:02:28.811]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.811]             version = "1.8"), class = "FutureResult")
[17:02:28.811]     }, finally = {
[17:02:28.811]         if (!identical(...future.workdir, getwd())) 
[17:02:28.811]             setwd(...future.workdir)
[17:02:28.811]         {
[17:02:28.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.811]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.811]             }
[17:02:28.811]             base::options(...future.oldOptions)
[17:02:28.811]             if (.Platform$OS.type == "windows") {
[17:02:28.811]                 old_names <- names(...future.oldEnvVars)
[17:02:28.811]                 envs <- base::Sys.getenv()
[17:02:28.811]                 names <- names(envs)
[17:02:28.811]                 common <- intersect(names, old_names)
[17:02:28.811]                 added <- setdiff(names, old_names)
[17:02:28.811]                 removed <- setdiff(old_names, names)
[17:02:28.811]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.811]                   envs[common]]
[17:02:28.811]                 NAMES <- toupper(changed)
[17:02:28.811]                 args <- list()
[17:02:28.811]                 for (kk in seq_along(NAMES)) {
[17:02:28.811]                   name <- changed[[kk]]
[17:02:28.811]                   NAME <- NAMES[[kk]]
[17:02:28.811]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.811]                     next
[17:02:28.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.811]                 }
[17:02:28.811]                 NAMES <- toupper(added)
[17:02:28.811]                 for (kk in seq_along(NAMES)) {
[17:02:28.811]                   name <- added[[kk]]
[17:02:28.811]                   NAME <- NAMES[[kk]]
[17:02:28.811]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.811]                     next
[17:02:28.811]                   args[[name]] <- ""
[17:02:28.811]                 }
[17:02:28.811]                 NAMES <- toupper(removed)
[17:02:28.811]                 for (kk in seq_along(NAMES)) {
[17:02:28.811]                   name <- removed[[kk]]
[17:02:28.811]                   NAME <- NAMES[[kk]]
[17:02:28.811]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.811]                     next
[17:02:28.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.811]                 }
[17:02:28.811]                 if (length(args) > 0) 
[17:02:28.811]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.811]             }
[17:02:28.811]             else {
[17:02:28.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.811]             }
[17:02:28.811]             {
[17:02:28.811]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.811]                   0L) {
[17:02:28.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.811]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.811]                   base::options(opts)
[17:02:28.811]                 }
[17:02:28.811]                 {
[17:02:28.811]                   {
[17:02:28.811]                     NULL
[17:02:28.811]                     RNGkind("Mersenne-Twister")
[17:02:28.811]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.811]                       inherits = FALSE)
[17:02:28.811]                   }
[17:02:28.811]                   options(future.plan = NULL)
[17:02:28.811]                   if (is.na(NA_character_)) 
[17:02:28.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.811]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.811]                     .init = FALSE)
[17:02:28.811]                 }
[17:02:28.811]             }
[17:02:28.811]         }
[17:02:28.811]     })
[17:02:28.811]     if (TRUE) {
[17:02:28.811]         base::sink(type = "output", split = FALSE)
[17:02:28.811]         if (TRUE) {
[17:02:28.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.811]         }
[17:02:28.811]         else {
[17:02:28.811]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.811]         }
[17:02:28.811]         base::close(...future.stdout)
[17:02:28.811]         ...future.stdout <- NULL
[17:02:28.811]     }
[17:02:28.811]     ...future.result$conditions <- ...future.conditions
[17:02:28.811]     ...future.result$finished <- base::Sys.time()
[17:02:28.811]     ...future.result
[17:02:28.811] }
[17:02:28.813] plan(): Setting new future strategy stack:
[17:02:28.813] List of future strategies:
[17:02:28.813] 1. sequential:
[17:02:28.813]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.813]    - tweaked: FALSE
[17:02:28.813]    - call: NULL
[17:02:28.813] plan(): nbrOfWorkers() = 1
[17:02:28.814] plan(): Setting new future strategy stack:
[17:02:28.814] List of future strategies:
[17:02:28.814] 1. sequential:
[17:02:28.814]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.814]    - tweaked: FALSE
[17:02:28.814]    - call: plan(strategy)
[17:02:28.815] plan(): nbrOfWorkers() = 1
[17:02:28.815] SequentialFuture started (and completed)
[17:02:28.815] - Launch lazy future ... done
[17:02:28.815] run() for ‘SequentialFuture’ ... done
[17:02:28.815] getGlobalsAndPackages() ...
[17:02:28.815] Searching for globals...
[17:02:28.816] - globals found: [1] ‘{’
[17:02:28.816] Searching for globals ... DONE
[17:02:28.816] Resolving globals: FALSE
[17:02:28.816] 
[17:02:28.817] 
[17:02:28.817] getGlobalsAndPackages() ... DONE
[17:02:28.817] run() for ‘Future’ ...
[17:02:28.817] - state: ‘created’
[17:02:28.817] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.817] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.818] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.818]   - Field: ‘label’
[17:02:28.818]   - Field: ‘local’
[17:02:28.818]   - Field: ‘owner’
[17:02:28.818]   - Field: ‘envir’
[17:02:28.818]   - Field: ‘packages’
[17:02:28.818]   - Field: ‘gc’
[17:02:28.818]   - Field: ‘conditions’
[17:02:28.818]   - Field: ‘expr’
[17:02:28.818]   - Field: ‘uuid’
[17:02:28.818]   - Field: ‘seed’
[17:02:28.819]   - Field: ‘version’
[17:02:28.819]   - Field: ‘result’
[17:02:28.819]   - Field: ‘asynchronous’
[17:02:28.819]   - Field: ‘calls’
[17:02:28.819]   - Field: ‘globals’
[17:02:28.819]   - Field: ‘stdout’
[17:02:28.819]   - Field: ‘earlySignal’
[17:02:28.819]   - Field: ‘lazy’
[17:02:28.819]   - Field: ‘state’
[17:02:28.819] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.820] - Launch lazy future ...
[17:02:28.820] Packages needed by the future expression (n = 0): <none>
[17:02:28.820] Packages needed by future strategies (n = 0): <none>
[17:02:28.820] {
[17:02:28.820]     {
[17:02:28.820]         {
[17:02:28.820]             ...future.startTime <- base::Sys.time()
[17:02:28.820]             {
[17:02:28.820]                 {
[17:02:28.820]                   {
[17:02:28.820]                     base::local({
[17:02:28.820]                       has_future <- base::requireNamespace("future", 
[17:02:28.820]                         quietly = TRUE)
[17:02:28.820]                       if (has_future) {
[17:02:28.820]                         ns <- base::getNamespace("future")
[17:02:28.820]                         version <- ns[[".package"]][["version"]]
[17:02:28.820]                         if (is.null(version)) 
[17:02:28.820]                           version <- utils::packageVersion("future")
[17:02:28.820]                       }
[17:02:28.820]                       else {
[17:02:28.820]                         version <- NULL
[17:02:28.820]                       }
[17:02:28.820]                       if (!has_future || version < "1.8.0") {
[17:02:28.820]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.820]                           "", base::R.version$version.string), 
[17:02:28.820]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.820]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.820]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.820]                             "release", "version")], collapse = " "), 
[17:02:28.820]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.820]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.820]                           info)
[17:02:28.820]                         info <- base::paste(info, collapse = "; ")
[17:02:28.820]                         if (!has_future) {
[17:02:28.820]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.820]                             info)
[17:02:28.820]                         }
[17:02:28.820]                         else {
[17:02:28.820]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.820]                             info, version)
[17:02:28.820]                         }
[17:02:28.820]                         base::stop(msg)
[17:02:28.820]                       }
[17:02:28.820]                     })
[17:02:28.820]                   }
[17:02:28.820]                   ...future.strategy.old <- future::plan("list")
[17:02:28.820]                   options(future.plan = NULL)
[17:02:28.820]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.820]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.820]                 }
[17:02:28.820]                 ...future.workdir <- getwd()
[17:02:28.820]             }
[17:02:28.820]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.820]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.820]         }
[17:02:28.820]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.820]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.820]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.820]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.820]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.820]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.820]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.820]             base::names(...future.oldOptions))
[17:02:28.820]     }
[17:02:28.820]     if (FALSE) {
[17:02:28.820]     }
[17:02:28.820]     else {
[17:02:28.820]         if (TRUE) {
[17:02:28.820]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.820]                 open = "w")
[17:02:28.820]         }
[17:02:28.820]         else {
[17:02:28.820]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.820]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.820]         }
[17:02:28.820]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.820]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.820]             base::sink(type = "output", split = FALSE)
[17:02:28.820]             base::close(...future.stdout)
[17:02:28.820]         }, add = TRUE)
[17:02:28.820]     }
[17:02:28.820]     ...future.frame <- base::sys.nframe()
[17:02:28.820]     ...future.conditions <- base::list()
[17:02:28.820]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.820]     if (FALSE) {
[17:02:28.820]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.820]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.820]     }
[17:02:28.820]     ...future.result <- base::tryCatch({
[17:02:28.820]         base::withCallingHandlers({
[17:02:28.820]             ...future.value <- base::withVisible(base::local({
[17:02:28.820]                 4
[17:02:28.820]             }))
[17:02:28.820]             future::FutureResult(value = ...future.value$value, 
[17:02:28.820]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.820]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.820]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.820]                     ...future.globalenv.names))
[17:02:28.820]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.820]         }, condition = base::local({
[17:02:28.820]             c <- base::c
[17:02:28.820]             inherits <- base::inherits
[17:02:28.820]             invokeRestart <- base::invokeRestart
[17:02:28.820]             length <- base::length
[17:02:28.820]             list <- base::list
[17:02:28.820]             seq.int <- base::seq.int
[17:02:28.820]             signalCondition <- base::signalCondition
[17:02:28.820]             sys.calls <- base::sys.calls
[17:02:28.820]             `[[` <- base::`[[`
[17:02:28.820]             `+` <- base::`+`
[17:02:28.820]             `<<-` <- base::`<<-`
[17:02:28.820]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.820]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.820]                   3L)]
[17:02:28.820]             }
[17:02:28.820]             function(cond) {
[17:02:28.820]                 is_error <- inherits(cond, "error")
[17:02:28.820]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.820]                   NULL)
[17:02:28.820]                 if (is_error) {
[17:02:28.820]                   sessionInformation <- function() {
[17:02:28.820]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.820]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.820]                       search = base::search(), system = base::Sys.info())
[17:02:28.820]                   }
[17:02:28.820]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.820]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.820]                     cond$call), session = sessionInformation(), 
[17:02:28.820]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.820]                   signalCondition(cond)
[17:02:28.820]                 }
[17:02:28.820]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.820]                 "immediateCondition"))) {
[17:02:28.820]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.820]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.820]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.820]                   if (TRUE && !signal) {
[17:02:28.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.820]                     {
[17:02:28.820]                       inherits <- base::inherits
[17:02:28.820]                       invokeRestart <- base::invokeRestart
[17:02:28.820]                       is.null <- base::is.null
[17:02:28.820]                       muffled <- FALSE
[17:02:28.820]                       if (inherits(cond, "message")) {
[17:02:28.820]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.820]                         if (muffled) 
[17:02:28.820]                           invokeRestart("muffleMessage")
[17:02:28.820]                       }
[17:02:28.820]                       else if (inherits(cond, "warning")) {
[17:02:28.820]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.820]                         if (muffled) 
[17:02:28.820]                           invokeRestart("muffleWarning")
[17:02:28.820]                       }
[17:02:28.820]                       else if (inherits(cond, "condition")) {
[17:02:28.820]                         if (!is.null(pattern)) {
[17:02:28.820]                           computeRestarts <- base::computeRestarts
[17:02:28.820]                           grepl <- base::grepl
[17:02:28.820]                           restarts <- computeRestarts(cond)
[17:02:28.820]                           for (restart in restarts) {
[17:02:28.820]                             name <- restart$name
[17:02:28.820]                             if (is.null(name)) 
[17:02:28.820]                               next
[17:02:28.820]                             if (!grepl(pattern, name)) 
[17:02:28.820]                               next
[17:02:28.820]                             invokeRestart(restart)
[17:02:28.820]                             muffled <- TRUE
[17:02:28.820]                             break
[17:02:28.820]                           }
[17:02:28.820]                         }
[17:02:28.820]                       }
[17:02:28.820]                       invisible(muffled)
[17:02:28.820]                     }
[17:02:28.820]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.820]                   }
[17:02:28.820]                 }
[17:02:28.820]                 else {
[17:02:28.820]                   if (TRUE) {
[17:02:28.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.820]                     {
[17:02:28.820]                       inherits <- base::inherits
[17:02:28.820]                       invokeRestart <- base::invokeRestart
[17:02:28.820]                       is.null <- base::is.null
[17:02:28.820]                       muffled <- FALSE
[17:02:28.820]                       if (inherits(cond, "message")) {
[17:02:28.820]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.820]                         if (muffled) 
[17:02:28.820]                           invokeRestart("muffleMessage")
[17:02:28.820]                       }
[17:02:28.820]                       else if (inherits(cond, "warning")) {
[17:02:28.820]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.820]                         if (muffled) 
[17:02:28.820]                           invokeRestart("muffleWarning")
[17:02:28.820]                       }
[17:02:28.820]                       else if (inherits(cond, "condition")) {
[17:02:28.820]                         if (!is.null(pattern)) {
[17:02:28.820]                           computeRestarts <- base::computeRestarts
[17:02:28.820]                           grepl <- base::grepl
[17:02:28.820]                           restarts <- computeRestarts(cond)
[17:02:28.820]                           for (restart in restarts) {
[17:02:28.820]                             name <- restart$name
[17:02:28.820]                             if (is.null(name)) 
[17:02:28.820]                               next
[17:02:28.820]                             if (!grepl(pattern, name)) 
[17:02:28.820]                               next
[17:02:28.820]                             invokeRestart(restart)
[17:02:28.820]                             muffled <- TRUE
[17:02:28.820]                             break
[17:02:28.820]                           }
[17:02:28.820]                         }
[17:02:28.820]                       }
[17:02:28.820]                       invisible(muffled)
[17:02:28.820]                     }
[17:02:28.820]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.820]                   }
[17:02:28.820]                 }
[17:02:28.820]             }
[17:02:28.820]         }))
[17:02:28.820]     }, error = function(ex) {
[17:02:28.820]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.820]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.820]                 ...future.rng), started = ...future.startTime, 
[17:02:28.820]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.820]             version = "1.8"), class = "FutureResult")
[17:02:28.820]     }, finally = {
[17:02:28.820]         if (!identical(...future.workdir, getwd())) 
[17:02:28.820]             setwd(...future.workdir)
[17:02:28.820]         {
[17:02:28.820]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.820]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.820]             }
[17:02:28.820]             base::options(...future.oldOptions)
[17:02:28.820]             if (.Platform$OS.type == "windows") {
[17:02:28.820]                 old_names <- names(...future.oldEnvVars)
[17:02:28.820]                 envs <- base::Sys.getenv()
[17:02:28.820]                 names <- names(envs)
[17:02:28.820]                 common <- intersect(names, old_names)
[17:02:28.820]                 added <- setdiff(names, old_names)
[17:02:28.820]                 removed <- setdiff(old_names, names)
[17:02:28.820]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.820]                   envs[common]]
[17:02:28.820]                 NAMES <- toupper(changed)
[17:02:28.820]                 args <- list()
[17:02:28.820]                 for (kk in seq_along(NAMES)) {
[17:02:28.820]                   name <- changed[[kk]]
[17:02:28.820]                   NAME <- NAMES[[kk]]
[17:02:28.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.820]                     next
[17:02:28.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.820]                 }
[17:02:28.820]                 NAMES <- toupper(added)
[17:02:28.820]                 for (kk in seq_along(NAMES)) {
[17:02:28.820]                   name <- added[[kk]]
[17:02:28.820]                   NAME <- NAMES[[kk]]
[17:02:28.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.820]                     next
[17:02:28.820]                   args[[name]] <- ""
[17:02:28.820]                 }
[17:02:28.820]                 NAMES <- toupper(removed)
[17:02:28.820]                 for (kk in seq_along(NAMES)) {
[17:02:28.820]                   name <- removed[[kk]]
[17:02:28.820]                   NAME <- NAMES[[kk]]
[17:02:28.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.820]                     next
[17:02:28.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.820]                 }
[17:02:28.820]                 if (length(args) > 0) 
[17:02:28.820]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.820]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.820]             }
[17:02:28.820]             else {
[17:02:28.820]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.820]             }
[17:02:28.820]             {
[17:02:28.820]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.820]                   0L) {
[17:02:28.820]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.820]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.820]                   base::options(opts)
[17:02:28.820]                 }
[17:02:28.820]                 {
[17:02:28.820]                   {
[17:02:28.820]                     NULL
[17:02:28.820]                     RNGkind("Mersenne-Twister")
[17:02:28.820]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.820]                       inherits = FALSE)
[17:02:28.820]                   }
[17:02:28.820]                   options(future.plan = NULL)
[17:02:28.820]                   if (is.na(NA_character_)) 
[17:02:28.820]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.820]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.820]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.820]                     .init = FALSE)
[17:02:28.820]                 }
[17:02:28.820]             }
[17:02:28.820]         }
[17:02:28.820]     })
[17:02:28.820]     if (TRUE) {
[17:02:28.820]         base::sink(type = "output", split = FALSE)
[17:02:28.820]         if (TRUE) {
[17:02:28.820]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.820]         }
[17:02:28.820]         else {
[17:02:28.820]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.820]         }
[17:02:28.820]         base::close(...future.stdout)
[17:02:28.820]         ...future.stdout <- NULL
[17:02:28.820]     }
[17:02:28.820]     ...future.result$conditions <- ...future.conditions
[17:02:28.820]     ...future.result$finished <- base::Sys.time()
[17:02:28.820]     ...future.result
[17:02:28.820] }
[17:02:28.822] plan(): Setting new future strategy stack:
[17:02:28.822] List of future strategies:
[17:02:28.822] 1. sequential:
[17:02:28.822]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.822]    - tweaked: FALSE
[17:02:28.822]    - call: NULL
[17:02:28.822] plan(): nbrOfWorkers() = 1
[17:02:28.823] plan(): Setting new future strategy stack:
[17:02:28.823] List of future strategies:
[17:02:28.823] 1. sequential:
[17:02:28.823]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.823]    - tweaked: FALSE
[17:02:28.823]    - call: plan(strategy)
[17:02:28.824] plan(): nbrOfWorkers() = 1
[17:02:28.824] SequentialFuture started (and completed)
[17:02:28.824] - Launch lazy future ... done
[17:02:28.824] run() for ‘SequentialFuture’ ... done
<environment: 0x55c7497f0d00> 
<environment: 0x55c74958d5a0> 
[17:02:28.825] resolved() for ‘SequentialFuture’ ...
[17:02:28.826] - state: ‘finished’
[17:02:28.826] - run: TRUE
[17:02:28.826] - result: ‘FutureResult’
[17:02:28.826] resolved() for ‘SequentialFuture’ ... done
[17:02:28.826] resolved() for ‘SequentialFuture’ ...
[17:02:28.826] - state: ‘finished’
[17:02:28.826] - run: TRUE
[17:02:28.826] - result: ‘FutureResult’
[17:02:28.826] resolved() for ‘SequentialFuture’ ... done
[17:02:28.826] resolved() for ‘SequentialFuture’ ...
[17:02:28.827] - state: ‘finished’
[17:02:28.827] - run: TRUE
[17:02:28.827] - result: ‘FutureResult’
[17:02:28.827] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:28.828] resolve() on environment ...
[17:02:28.828]  recursive: 0
[17:02:28.829]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:28.829] signalConditionsASAP(numeric, pos=1) ...
[17:02:28.829] - nx: 4
[17:02:28.829] - relay: TRUE
[17:02:28.829] - stdout: TRUE
[17:02:28.829] - signal: TRUE
[17:02:28.829] - resignal: FALSE
[17:02:28.829] - force: TRUE
[17:02:28.829] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.829] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.830]  - until=2
[17:02:28.830]  - relaying element #2
[17:02:28.830] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:28.830] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.830] signalConditionsASAP(NULL, pos=1) ... done
[17:02:28.830]  length: 3 (resolved future 1)
[17:02:28.830] resolved() for ‘SequentialFuture’ ...
[17:02:28.830] - state: ‘finished’
[17:02:28.830] - run: TRUE
[17:02:28.830] - result: ‘FutureResult’
[17:02:28.830] resolved() for ‘SequentialFuture’ ... done
[17:02:28.831] Future #2
[17:02:28.831] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:28.831] - nx: 4
[17:02:28.831] - relay: TRUE
[17:02:28.831] - stdout: TRUE
[17:02:28.831] - signal: TRUE
[17:02:28.831] - resignal: FALSE
[17:02:28.831] - force: TRUE
[17:02:28.831] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:28.832] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.832]  - until=2
[17:02:28.832]  - relaying element #2
[17:02:28.832] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:28.832] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:28.832] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:28.832]  length: 2 (resolved future 2)
[17:02:28.832] resolved() for ‘SequentialFuture’ ...
[17:02:28.833] - state: ‘finished’
[17:02:28.833] - run: TRUE
[17:02:28.833] - result: ‘FutureResult’
[17:02:28.833] resolved() for ‘SequentialFuture’ ... done
[17:02:28.833] Future #3
[17:02:28.833] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:28.833] - nx: 4
[17:02:28.833] - relay: TRUE
[17:02:28.833] - stdout: TRUE
[17:02:28.833] - signal: TRUE
[17:02:28.833] - resignal: FALSE
[17:02:28.834] - force: TRUE
[17:02:28.834] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:28.834] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:28.834]  - until=3
[17:02:28.834]  - relaying element #3
[17:02:28.836] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:28.836] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:28.836] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:28.836]  length: 1 (resolved future 3)
[17:02:28.837] resolved() for ‘SequentialFuture’ ...
[17:02:28.837] - state: ‘finished’
[17:02:28.837] - run: TRUE
[17:02:28.837] - result: ‘FutureResult’
[17:02:28.837] resolved() for ‘SequentialFuture’ ... done
[17:02:28.837] Future #4
[17:02:28.837] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:02:28.837] - nx: 4
[17:02:28.837] - relay: TRUE
[17:02:28.837] - stdout: TRUE
[17:02:28.838] - signal: TRUE
[17:02:28.838] - resignal: FALSE
[17:02:28.838] - force: TRUE
[17:02:28.838] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:28.838] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:28.838]  - until=4
[17:02:28.838]  - relaying element #4
[17:02:28.838] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.838] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:28.838] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:02:28.838]  length: 0 (resolved future 4)
[17:02:28.839] Relaying remaining futures
[17:02:28.839] signalConditionsASAP(NULL, pos=0) ...
[17:02:28.839] - nx: 4
[17:02:28.839] - relay: TRUE
[17:02:28.839] - stdout: TRUE
[17:02:28.839] - signal: TRUE
[17:02:28.839] - resignal: FALSE
[17:02:28.839] - force: TRUE
[17:02:28.839] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.839] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:28.839] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.840] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:28.840] signalConditionsASAP(NULL, pos=0) ... done
[17:02:28.840] resolve() on environment ... DONE
<environment: 0x55c749776218> 
Dimensions: c(2, 1, 3, 1)
[17:02:28.840] getGlobalsAndPackages() ...
[17:02:28.840] Searching for globals...
[17:02:28.841] 
[17:02:28.841] Searching for globals ... DONE
[17:02:28.841] - globals: [0] <none>
[17:02:28.841] getGlobalsAndPackages() ... DONE
[17:02:28.841] run() for ‘Future’ ...
[17:02:28.841] - state: ‘created’
[17:02:28.841] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.842] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.842] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.842]   - Field: ‘label’
[17:02:28.842]   - Field: ‘local’
[17:02:28.842]   - Field: ‘owner’
[17:02:28.842]   - Field: ‘envir’
[17:02:28.842]   - Field: ‘packages’
[17:02:28.842]   - Field: ‘gc’
[17:02:28.842]   - Field: ‘conditions’
[17:02:28.843]   - Field: ‘expr’
[17:02:28.843]   - Field: ‘uuid’
[17:02:28.843]   - Field: ‘seed’
[17:02:28.843]   - Field: ‘version’
[17:02:28.843]   - Field: ‘result’
[17:02:28.843]   - Field: ‘asynchronous’
[17:02:28.843]   - Field: ‘calls’
[17:02:28.843]   - Field: ‘globals’
[17:02:28.843]   - Field: ‘stdout’
[17:02:28.843]   - Field: ‘earlySignal’
[17:02:28.843]   - Field: ‘lazy’
[17:02:28.844]   - Field: ‘state’
[17:02:28.844] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.844] - Launch lazy future ...
[17:02:28.844] Packages needed by the future expression (n = 0): <none>
[17:02:28.844] Packages needed by future strategies (n = 0): <none>
[17:02:28.844] {
[17:02:28.844]     {
[17:02:28.844]         {
[17:02:28.844]             ...future.startTime <- base::Sys.time()
[17:02:28.844]             {
[17:02:28.844]                 {
[17:02:28.844]                   {
[17:02:28.844]                     base::local({
[17:02:28.844]                       has_future <- base::requireNamespace("future", 
[17:02:28.844]                         quietly = TRUE)
[17:02:28.844]                       if (has_future) {
[17:02:28.844]                         ns <- base::getNamespace("future")
[17:02:28.844]                         version <- ns[[".package"]][["version"]]
[17:02:28.844]                         if (is.null(version)) 
[17:02:28.844]                           version <- utils::packageVersion("future")
[17:02:28.844]                       }
[17:02:28.844]                       else {
[17:02:28.844]                         version <- NULL
[17:02:28.844]                       }
[17:02:28.844]                       if (!has_future || version < "1.8.0") {
[17:02:28.844]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.844]                           "", base::R.version$version.string), 
[17:02:28.844]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.844]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.844]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.844]                             "release", "version")], collapse = " "), 
[17:02:28.844]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.844]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.844]                           info)
[17:02:28.844]                         info <- base::paste(info, collapse = "; ")
[17:02:28.844]                         if (!has_future) {
[17:02:28.844]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.844]                             info)
[17:02:28.844]                         }
[17:02:28.844]                         else {
[17:02:28.844]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.844]                             info, version)
[17:02:28.844]                         }
[17:02:28.844]                         base::stop(msg)
[17:02:28.844]                       }
[17:02:28.844]                     })
[17:02:28.844]                   }
[17:02:28.844]                   ...future.strategy.old <- future::plan("list")
[17:02:28.844]                   options(future.plan = NULL)
[17:02:28.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.844]                 }
[17:02:28.844]                 ...future.workdir <- getwd()
[17:02:28.844]             }
[17:02:28.844]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.844]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.844]         }
[17:02:28.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.844]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.844]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.844]             base::names(...future.oldOptions))
[17:02:28.844]     }
[17:02:28.844]     if (FALSE) {
[17:02:28.844]     }
[17:02:28.844]     else {
[17:02:28.844]         if (TRUE) {
[17:02:28.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.844]                 open = "w")
[17:02:28.844]         }
[17:02:28.844]         else {
[17:02:28.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.844]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.844]         }
[17:02:28.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.844]             base::sink(type = "output", split = FALSE)
[17:02:28.844]             base::close(...future.stdout)
[17:02:28.844]         }, add = TRUE)
[17:02:28.844]     }
[17:02:28.844]     ...future.frame <- base::sys.nframe()
[17:02:28.844]     ...future.conditions <- base::list()
[17:02:28.844]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.844]     if (FALSE) {
[17:02:28.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.844]     }
[17:02:28.844]     ...future.result <- base::tryCatch({
[17:02:28.844]         base::withCallingHandlers({
[17:02:28.844]             ...future.value <- base::withVisible(base::local(2))
[17:02:28.844]             future::FutureResult(value = ...future.value$value, 
[17:02:28.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.844]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.844]                     ...future.globalenv.names))
[17:02:28.844]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.844]         }, condition = base::local({
[17:02:28.844]             c <- base::c
[17:02:28.844]             inherits <- base::inherits
[17:02:28.844]             invokeRestart <- base::invokeRestart
[17:02:28.844]             length <- base::length
[17:02:28.844]             list <- base::list
[17:02:28.844]             seq.int <- base::seq.int
[17:02:28.844]             signalCondition <- base::signalCondition
[17:02:28.844]             sys.calls <- base::sys.calls
[17:02:28.844]             `[[` <- base::`[[`
[17:02:28.844]             `+` <- base::`+`
[17:02:28.844]             `<<-` <- base::`<<-`
[17:02:28.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.844]                   3L)]
[17:02:28.844]             }
[17:02:28.844]             function(cond) {
[17:02:28.844]                 is_error <- inherits(cond, "error")
[17:02:28.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.844]                   NULL)
[17:02:28.844]                 if (is_error) {
[17:02:28.844]                   sessionInformation <- function() {
[17:02:28.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.844]                       search = base::search(), system = base::Sys.info())
[17:02:28.844]                   }
[17:02:28.844]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.844]                     cond$call), session = sessionInformation(), 
[17:02:28.844]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.844]                   signalCondition(cond)
[17:02:28.844]                 }
[17:02:28.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.844]                 "immediateCondition"))) {
[17:02:28.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.844]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.844]                   if (TRUE && !signal) {
[17:02:28.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.844]                     {
[17:02:28.844]                       inherits <- base::inherits
[17:02:28.844]                       invokeRestart <- base::invokeRestart
[17:02:28.844]                       is.null <- base::is.null
[17:02:28.844]                       muffled <- FALSE
[17:02:28.844]                       if (inherits(cond, "message")) {
[17:02:28.844]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.844]                         if (muffled) 
[17:02:28.844]                           invokeRestart("muffleMessage")
[17:02:28.844]                       }
[17:02:28.844]                       else if (inherits(cond, "warning")) {
[17:02:28.844]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.844]                         if (muffled) 
[17:02:28.844]                           invokeRestart("muffleWarning")
[17:02:28.844]                       }
[17:02:28.844]                       else if (inherits(cond, "condition")) {
[17:02:28.844]                         if (!is.null(pattern)) {
[17:02:28.844]                           computeRestarts <- base::computeRestarts
[17:02:28.844]                           grepl <- base::grepl
[17:02:28.844]                           restarts <- computeRestarts(cond)
[17:02:28.844]                           for (restart in restarts) {
[17:02:28.844]                             name <- restart$name
[17:02:28.844]                             if (is.null(name)) 
[17:02:28.844]                               next
[17:02:28.844]                             if (!grepl(pattern, name)) 
[17:02:28.844]                               next
[17:02:28.844]                             invokeRestart(restart)
[17:02:28.844]                             muffled <- TRUE
[17:02:28.844]                             break
[17:02:28.844]                           }
[17:02:28.844]                         }
[17:02:28.844]                       }
[17:02:28.844]                       invisible(muffled)
[17:02:28.844]                     }
[17:02:28.844]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.844]                   }
[17:02:28.844]                 }
[17:02:28.844]                 else {
[17:02:28.844]                   if (TRUE) {
[17:02:28.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.844]                     {
[17:02:28.844]                       inherits <- base::inherits
[17:02:28.844]                       invokeRestart <- base::invokeRestart
[17:02:28.844]                       is.null <- base::is.null
[17:02:28.844]                       muffled <- FALSE
[17:02:28.844]                       if (inherits(cond, "message")) {
[17:02:28.844]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.844]                         if (muffled) 
[17:02:28.844]                           invokeRestart("muffleMessage")
[17:02:28.844]                       }
[17:02:28.844]                       else if (inherits(cond, "warning")) {
[17:02:28.844]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.844]                         if (muffled) 
[17:02:28.844]                           invokeRestart("muffleWarning")
[17:02:28.844]                       }
[17:02:28.844]                       else if (inherits(cond, "condition")) {
[17:02:28.844]                         if (!is.null(pattern)) {
[17:02:28.844]                           computeRestarts <- base::computeRestarts
[17:02:28.844]                           grepl <- base::grepl
[17:02:28.844]                           restarts <- computeRestarts(cond)
[17:02:28.844]                           for (restart in restarts) {
[17:02:28.844]                             name <- restart$name
[17:02:28.844]                             if (is.null(name)) 
[17:02:28.844]                               next
[17:02:28.844]                             if (!grepl(pattern, name)) 
[17:02:28.844]                               next
[17:02:28.844]                             invokeRestart(restart)
[17:02:28.844]                             muffled <- TRUE
[17:02:28.844]                             break
[17:02:28.844]                           }
[17:02:28.844]                         }
[17:02:28.844]                       }
[17:02:28.844]                       invisible(muffled)
[17:02:28.844]                     }
[17:02:28.844]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.844]                   }
[17:02:28.844]                 }
[17:02:28.844]             }
[17:02:28.844]         }))
[17:02:28.844]     }, error = function(ex) {
[17:02:28.844]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.844]                 ...future.rng), started = ...future.startTime, 
[17:02:28.844]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.844]             version = "1.8"), class = "FutureResult")
[17:02:28.844]     }, finally = {
[17:02:28.844]         if (!identical(...future.workdir, getwd())) 
[17:02:28.844]             setwd(...future.workdir)
[17:02:28.844]         {
[17:02:28.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.844]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.844]             }
[17:02:28.844]             base::options(...future.oldOptions)
[17:02:28.844]             if (.Platform$OS.type == "windows") {
[17:02:28.844]                 old_names <- names(...future.oldEnvVars)
[17:02:28.844]                 envs <- base::Sys.getenv()
[17:02:28.844]                 names <- names(envs)
[17:02:28.844]                 common <- intersect(names, old_names)
[17:02:28.844]                 added <- setdiff(names, old_names)
[17:02:28.844]                 removed <- setdiff(old_names, names)
[17:02:28.844]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.844]                   envs[common]]
[17:02:28.844]                 NAMES <- toupper(changed)
[17:02:28.844]                 args <- list()
[17:02:28.844]                 for (kk in seq_along(NAMES)) {
[17:02:28.844]                   name <- changed[[kk]]
[17:02:28.844]                   NAME <- NAMES[[kk]]
[17:02:28.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.844]                     next
[17:02:28.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.844]                 }
[17:02:28.844]                 NAMES <- toupper(added)
[17:02:28.844]                 for (kk in seq_along(NAMES)) {
[17:02:28.844]                   name <- added[[kk]]
[17:02:28.844]                   NAME <- NAMES[[kk]]
[17:02:28.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.844]                     next
[17:02:28.844]                   args[[name]] <- ""
[17:02:28.844]                 }
[17:02:28.844]                 NAMES <- toupper(removed)
[17:02:28.844]                 for (kk in seq_along(NAMES)) {
[17:02:28.844]                   name <- removed[[kk]]
[17:02:28.844]                   NAME <- NAMES[[kk]]
[17:02:28.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.844]                     next
[17:02:28.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.844]                 }
[17:02:28.844]                 if (length(args) > 0) 
[17:02:28.844]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.844]             }
[17:02:28.844]             else {
[17:02:28.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.844]             }
[17:02:28.844]             {
[17:02:28.844]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.844]                   0L) {
[17:02:28.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.844]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.844]                   base::options(opts)
[17:02:28.844]                 }
[17:02:28.844]                 {
[17:02:28.844]                   {
[17:02:28.844]                     NULL
[17:02:28.844]                     RNGkind("Mersenne-Twister")
[17:02:28.844]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.844]                       inherits = FALSE)
[17:02:28.844]                   }
[17:02:28.844]                   options(future.plan = NULL)
[17:02:28.844]                   if (is.na(NA_character_)) 
[17:02:28.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.844]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.844]                     .init = FALSE)
[17:02:28.844]                 }
[17:02:28.844]             }
[17:02:28.844]         }
[17:02:28.844]     })
[17:02:28.844]     if (TRUE) {
[17:02:28.844]         base::sink(type = "output", split = FALSE)
[17:02:28.844]         if (TRUE) {
[17:02:28.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.844]         }
[17:02:28.844]         else {
[17:02:28.844]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.844]         }
[17:02:28.844]         base::close(...future.stdout)
[17:02:28.844]         ...future.stdout <- NULL
[17:02:28.844]     }
[17:02:28.844]     ...future.result$conditions <- ...future.conditions
[17:02:28.844]     ...future.result$finished <- base::Sys.time()
[17:02:28.844]     ...future.result
[17:02:28.844] }
[17:02:28.846] plan(): Setting new future strategy stack:
[17:02:28.846] List of future strategies:
[17:02:28.846] 1. sequential:
[17:02:28.846]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.846]    - tweaked: FALSE
[17:02:28.846]    - call: NULL
[17:02:28.847] plan(): nbrOfWorkers() = 1
[17:02:28.847] plan(): Setting new future strategy stack:
[17:02:28.848] List of future strategies:
[17:02:28.848] 1. sequential:
[17:02:28.848]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.848]    - tweaked: FALSE
[17:02:28.848]    - call: plan(strategy)
[17:02:28.848] plan(): nbrOfWorkers() = 1
[17:02:28.848] SequentialFuture started (and completed)
[17:02:28.848] - Launch lazy future ... done
[17:02:28.848] run() for ‘SequentialFuture’ ... done
[17:02:28.848] getGlobalsAndPackages() ...
[17:02:28.849] Searching for globals...
[17:02:28.849] 
[17:02:28.849] Searching for globals ... DONE
[17:02:28.849] - globals: [0] <none>
[17:02:28.849] getGlobalsAndPackages() ... DONE
[17:02:28.849] run() for ‘Future’ ...
[17:02:28.849] - state: ‘created’
[17:02:28.850] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.850] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.850] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.850]   - Field: ‘label’
[17:02:28.850]   - Field: ‘local’
[17:02:28.850]   - Field: ‘owner’
[17:02:28.850]   - Field: ‘envir’
[17:02:28.850]   - Field: ‘packages’
[17:02:28.850]   - Field: ‘gc’
[17:02:28.851]   - Field: ‘conditions’
[17:02:28.851]   - Field: ‘expr’
[17:02:28.851]   - Field: ‘uuid’
[17:02:28.851]   - Field: ‘seed’
[17:02:28.851]   - Field: ‘version’
[17:02:28.851]   - Field: ‘result’
[17:02:28.851]   - Field: ‘asynchronous’
[17:02:28.851]   - Field: ‘calls’
[17:02:28.851]   - Field: ‘globals’
[17:02:28.851]   - Field: ‘stdout’
[17:02:28.852]   - Field: ‘earlySignal’
[17:02:28.852]   - Field: ‘lazy’
[17:02:28.852]   - Field: ‘state’
[17:02:28.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.852] - Launch lazy future ...
[17:02:28.852] Packages needed by the future expression (n = 0): <none>
[17:02:28.852] Packages needed by future strategies (n = 0): <none>
[17:02:28.853] {
[17:02:28.853]     {
[17:02:28.853]         {
[17:02:28.853]             ...future.startTime <- base::Sys.time()
[17:02:28.853]             {
[17:02:28.853]                 {
[17:02:28.853]                   {
[17:02:28.853]                     base::local({
[17:02:28.853]                       has_future <- base::requireNamespace("future", 
[17:02:28.853]                         quietly = TRUE)
[17:02:28.853]                       if (has_future) {
[17:02:28.853]                         ns <- base::getNamespace("future")
[17:02:28.853]                         version <- ns[[".package"]][["version"]]
[17:02:28.853]                         if (is.null(version)) 
[17:02:28.853]                           version <- utils::packageVersion("future")
[17:02:28.853]                       }
[17:02:28.853]                       else {
[17:02:28.853]                         version <- NULL
[17:02:28.853]                       }
[17:02:28.853]                       if (!has_future || version < "1.8.0") {
[17:02:28.853]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.853]                           "", base::R.version$version.string), 
[17:02:28.853]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.853]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.853]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.853]                             "release", "version")], collapse = " "), 
[17:02:28.853]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.853]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.853]                           info)
[17:02:28.853]                         info <- base::paste(info, collapse = "; ")
[17:02:28.853]                         if (!has_future) {
[17:02:28.853]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.853]                             info)
[17:02:28.853]                         }
[17:02:28.853]                         else {
[17:02:28.853]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.853]                             info, version)
[17:02:28.853]                         }
[17:02:28.853]                         base::stop(msg)
[17:02:28.853]                       }
[17:02:28.853]                     })
[17:02:28.853]                   }
[17:02:28.853]                   ...future.strategy.old <- future::plan("list")
[17:02:28.853]                   options(future.plan = NULL)
[17:02:28.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.853]                 }
[17:02:28.853]                 ...future.workdir <- getwd()
[17:02:28.853]             }
[17:02:28.853]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.853]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.853]         }
[17:02:28.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.853]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.853]             base::names(...future.oldOptions))
[17:02:28.853]     }
[17:02:28.853]     if (FALSE) {
[17:02:28.853]     }
[17:02:28.853]     else {
[17:02:28.853]         if (TRUE) {
[17:02:28.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.853]                 open = "w")
[17:02:28.853]         }
[17:02:28.853]         else {
[17:02:28.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.853]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.853]         }
[17:02:28.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.853]             base::sink(type = "output", split = FALSE)
[17:02:28.853]             base::close(...future.stdout)
[17:02:28.853]         }, add = TRUE)
[17:02:28.853]     }
[17:02:28.853]     ...future.frame <- base::sys.nframe()
[17:02:28.853]     ...future.conditions <- base::list()
[17:02:28.853]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.853]     if (FALSE) {
[17:02:28.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.853]     }
[17:02:28.853]     ...future.result <- base::tryCatch({
[17:02:28.853]         base::withCallingHandlers({
[17:02:28.853]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:28.853]             future::FutureResult(value = ...future.value$value, 
[17:02:28.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.853]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.853]                     ...future.globalenv.names))
[17:02:28.853]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.853]         }, condition = base::local({
[17:02:28.853]             c <- base::c
[17:02:28.853]             inherits <- base::inherits
[17:02:28.853]             invokeRestart <- base::invokeRestart
[17:02:28.853]             length <- base::length
[17:02:28.853]             list <- base::list
[17:02:28.853]             seq.int <- base::seq.int
[17:02:28.853]             signalCondition <- base::signalCondition
[17:02:28.853]             sys.calls <- base::sys.calls
[17:02:28.853]             `[[` <- base::`[[`
[17:02:28.853]             `+` <- base::`+`
[17:02:28.853]             `<<-` <- base::`<<-`
[17:02:28.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.853]                   3L)]
[17:02:28.853]             }
[17:02:28.853]             function(cond) {
[17:02:28.853]                 is_error <- inherits(cond, "error")
[17:02:28.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.853]                   NULL)
[17:02:28.853]                 if (is_error) {
[17:02:28.853]                   sessionInformation <- function() {
[17:02:28.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.853]                       search = base::search(), system = base::Sys.info())
[17:02:28.853]                   }
[17:02:28.853]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.853]                     cond$call), session = sessionInformation(), 
[17:02:28.853]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.853]                   signalCondition(cond)
[17:02:28.853]                 }
[17:02:28.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.853]                 "immediateCondition"))) {
[17:02:28.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.853]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.853]                   if (TRUE && !signal) {
[17:02:28.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.853]                     {
[17:02:28.853]                       inherits <- base::inherits
[17:02:28.853]                       invokeRestart <- base::invokeRestart
[17:02:28.853]                       is.null <- base::is.null
[17:02:28.853]                       muffled <- FALSE
[17:02:28.853]                       if (inherits(cond, "message")) {
[17:02:28.853]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.853]                         if (muffled) 
[17:02:28.853]                           invokeRestart("muffleMessage")
[17:02:28.853]                       }
[17:02:28.853]                       else if (inherits(cond, "warning")) {
[17:02:28.853]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.853]                         if (muffled) 
[17:02:28.853]                           invokeRestart("muffleWarning")
[17:02:28.853]                       }
[17:02:28.853]                       else if (inherits(cond, "condition")) {
[17:02:28.853]                         if (!is.null(pattern)) {
[17:02:28.853]                           computeRestarts <- base::computeRestarts
[17:02:28.853]                           grepl <- base::grepl
[17:02:28.853]                           restarts <- computeRestarts(cond)
[17:02:28.853]                           for (restart in restarts) {
[17:02:28.853]                             name <- restart$name
[17:02:28.853]                             if (is.null(name)) 
[17:02:28.853]                               next
[17:02:28.853]                             if (!grepl(pattern, name)) 
[17:02:28.853]                               next
[17:02:28.853]                             invokeRestart(restart)
[17:02:28.853]                             muffled <- TRUE
[17:02:28.853]                             break
[17:02:28.853]                           }
[17:02:28.853]                         }
[17:02:28.853]                       }
[17:02:28.853]                       invisible(muffled)
[17:02:28.853]                     }
[17:02:28.853]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.853]                   }
[17:02:28.853]                 }
[17:02:28.853]                 else {
[17:02:28.853]                   if (TRUE) {
[17:02:28.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.853]                     {
[17:02:28.853]                       inherits <- base::inherits
[17:02:28.853]                       invokeRestart <- base::invokeRestart
[17:02:28.853]                       is.null <- base::is.null
[17:02:28.853]                       muffled <- FALSE
[17:02:28.853]                       if (inherits(cond, "message")) {
[17:02:28.853]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.853]                         if (muffled) 
[17:02:28.853]                           invokeRestart("muffleMessage")
[17:02:28.853]                       }
[17:02:28.853]                       else if (inherits(cond, "warning")) {
[17:02:28.853]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.853]                         if (muffled) 
[17:02:28.853]                           invokeRestart("muffleWarning")
[17:02:28.853]                       }
[17:02:28.853]                       else if (inherits(cond, "condition")) {
[17:02:28.853]                         if (!is.null(pattern)) {
[17:02:28.853]                           computeRestarts <- base::computeRestarts
[17:02:28.853]                           grepl <- base::grepl
[17:02:28.853]                           restarts <- computeRestarts(cond)
[17:02:28.853]                           for (restart in restarts) {
[17:02:28.853]                             name <- restart$name
[17:02:28.853]                             if (is.null(name)) 
[17:02:28.853]                               next
[17:02:28.853]                             if (!grepl(pattern, name)) 
[17:02:28.853]                               next
[17:02:28.853]                             invokeRestart(restart)
[17:02:28.853]                             muffled <- TRUE
[17:02:28.853]                             break
[17:02:28.853]                           }
[17:02:28.853]                         }
[17:02:28.853]                       }
[17:02:28.853]                       invisible(muffled)
[17:02:28.853]                     }
[17:02:28.853]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.853]                   }
[17:02:28.853]                 }
[17:02:28.853]             }
[17:02:28.853]         }))
[17:02:28.853]     }, error = function(ex) {
[17:02:28.853]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.853]                 ...future.rng), started = ...future.startTime, 
[17:02:28.853]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.853]             version = "1.8"), class = "FutureResult")
[17:02:28.853]     }, finally = {
[17:02:28.853]         if (!identical(...future.workdir, getwd())) 
[17:02:28.853]             setwd(...future.workdir)
[17:02:28.853]         {
[17:02:28.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.853]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.853]             }
[17:02:28.853]             base::options(...future.oldOptions)
[17:02:28.853]             if (.Platform$OS.type == "windows") {
[17:02:28.853]                 old_names <- names(...future.oldEnvVars)
[17:02:28.853]                 envs <- base::Sys.getenv()
[17:02:28.853]                 names <- names(envs)
[17:02:28.853]                 common <- intersect(names, old_names)
[17:02:28.853]                 added <- setdiff(names, old_names)
[17:02:28.853]                 removed <- setdiff(old_names, names)
[17:02:28.853]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.853]                   envs[common]]
[17:02:28.853]                 NAMES <- toupper(changed)
[17:02:28.853]                 args <- list()
[17:02:28.853]                 for (kk in seq_along(NAMES)) {
[17:02:28.853]                   name <- changed[[kk]]
[17:02:28.853]                   NAME <- NAMES[[kk]]
[17:02:28.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.853]                     next
[17:02:28.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.853]                 }
[17:02:28.853]                 NAMES <- toupper(added)
[17:02:28.853]                 for (kk in seq_along(NAMES)) {
[17:02:28.853]                   name <- added[[kk]]
[17:02:28.853]                   NAME <- NAMES[[kk]]
[17:02:28.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.853]                     next
[17:02:28.853]                   args[[name]] <- ""
[17:02:28.853]                 }
[17:02:28.853]                 NAMES <- toupper(removed)
[17:02:28.853]                 for (kk in seq_along(NAMES)) {
[17:02:28.853]                   name <- removed[[kk]]
[17:02:28.853]                   NAME <- NAMES[[kk]]
[17:02:28.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.853]                     next
[17:02:28.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.853]                 }
[17:02:28.853]                 if (length(args) > 0) 
[17:02:28.853]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.853]             }
[17:02:28.853]             else {
[17:02:28.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.853]             }
[17:02:28.853]             {
[17:02:28.853]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.853]                   0L) {
[17:02:28.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.853]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.853]                   base::options(opts)
[17:02:28.853]                 }
[17:02:28.853]                 {
[17:02:28.853]                   {
[17:02:28.853]                     NULL
[17:02:28.853]                     RNGkind("Mersenne-Twister")
[17:02:28.853]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.853]                       inherits = FALSE)
[17:02:28.853]                   }
[17:02:28.853]                   options(future.plan = NULL)
[17:02:28.853]                   if (is.na(NA_character_)) 
[17:02:28.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.853]                     .init = FALSE)
[17:02:28.853]                 }
[17:02:28.853]             }
[17:02:28.853]         }
[17:02:28.853]     })
[17:02:28.853]     if (TRUE) {
[17:02:28.853]         base::sink(type = "output", split = FALSE)
[17:02:28.853]         if (TRUE) {
[17:02:28.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.853]         }
[17:02:28.853]         else {
[17:02:28.853]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.853]         }
[17:02:28.853]         base::close(...future.stdout)
[17:02:28.853]         ...future.stdout <- NULL
[17:02:28.853]     }
[17:02:28.853]     ...future.result$conditions <- ...future.conditions
[17:02:28.853]     ...future.result$finished <- base::Sys.time()
[17:02:28.853]     ...future.result
[17:02:28.853] }
[17:02:28.854] plan(): Setting new future strategy stack:
[17:02:28.854] List of future strategies:
[17:02:28.854] 1. sequential:
[17:02:28.854]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.854]    - tweaked: FALSE
[17:02:28.854]    - call: NULL
[17:02:28.855] plan(): nbrOfWorkers() = 1
[17:02:28.856] plan(): Setting new future strategy stack:
[17:02:28.856] List of future strategies:
[17:02:28.856] 1. sequential:
[17:02:28.856]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.856]    - tweaked: FALSE
[17:02:28.856]    - call: plan(strategy)
[17:02:28.856] plan(): nbrOfWorkers() = 1
[17:02:28.856] SequentialFuture started (and completed)
[17:02:28.856] - Launch lazy future ... done
[17:02:28.856] run() for ‘SequentialFuture’ ... done
[17:02:28.857] getGlobalsAndPackages() ...
[17:02:28.857] Searching for globals...
[17:02:28.857] - globals found: [1] ‘{’
[17:02:28.857] Searching for globals ... DONE
[17:02:28.858] Resolving globals: FALSE
[17:02:28.858] 
[17:02:28.858] 
[17:02:28.858] getGlobalsAndPackages() ... DONE
[17:02:28.858] run() for ‘Future’ ...
[17:02:28.858] - state: ‘created’
[17:02:28.858] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.859] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.859] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.859]   - Field: ‘label’
[17:02:28.859]   - Field: ‘local’
[17:02:28.859]   - Field: ‘owner’
[17:02:28.859]   - Field: ‘envir’
[17:02:28.859]   - Field: ‘packages’
[17:02:28.859]   - Field: ‘gc’
[17:02:28.860]   - Field: ‘conditions’
[17:02:28.860]   - Field: ‘expr’
[17:02:28.860]   - Field: ‘uuid’
[17:02:28.860]   - Field: ‘seed’
[17:02:28.860]   - Field: ‘version’
[17:02:28.860]   - Field: ‘result’
[17:02:28.860]   - Field: ‘asynchronous’
[17:02:28.860]   - Field: ‘calls’
[17:02:28.860]   - Field: ‘globals’
[17:02:28.860]   - Field: ‘stdout’
[17:02:28.860]   - Field: ‘earlySignal’
[17:02:28.860]   - Field: ‘lazy’
[17:02:28.861]   - Field: ‘state’
[17:02:28.861] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.861] - Launch lazy future ...
[17:02:28.861] Packages needed by the future expression (n = 0): <none>
[17:02:28.861] Packages needed by future strategies (n = 0): <none>
[17:02:28.861] {
[17:02:28.861]     {
[17:02:28.861]         {
[17:02:28.861]             ...future.startTime <- base::Sys.time()
[17:02:28.861]             {
[17:02:28.861]                 {
[17:02:28.861]                   {
[17:02:28.861]                     base::local({
[17:02:28.861]                       has_future <- base::requireNamespace("future", 
[17:02:28.861]                         quietly = TRUE)
[17:02:28.861]                       if (has_future) {
[17:02:28.861]                         ns <- base::getNamespace("future")
[17:02:28.861]                         version <- ns[[".package"]][["version"]]
[17:02:28.861]                         if (is.null(version)) 
[17:02:28.861]                           version <- utils::packageVersion("future")
[17:02:28.861]                       }
[17:02:28.861]                       else {
[17:02:28.861]                         version <- NULL
[17:02:28.861]                       }
[17:02:28.861]                       if (!has_future || version < "1.8.0") {
[17:02:28.861]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.861]                           "", base::R.version$version.string), 
[17:02:28.861]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.861]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.861]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.861]                             "release", "version")], collapse = " "), 
[17:02:28.861]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.861]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.861]                           info)
[17:02:28.861]                         info <- base::paste(info, collapse = "; ")
[17:02:28.861]                         if (!has_future) {
[17:02:28.861]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.861]                             info)
[17:02:28.861]                         }
[17:02:28.861]                         else {
[17:02:28.861]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.861]                             info, version)
[17:02:28.861]                         }
[17:02:28.861]                         base::stop(msg)
[17:02:28.861]                       }
[17:02:28.861]                     })
[17:02:28.861]                   }
[17:02:28.861]                   ...future.strategy.old <- future::plan("list")
[17:02:28.861]                   options(future.plan = NULL)
[17:02:28.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.861]                 }
[17:02:28.861]                 ...future.workdir <- getwd()
[17:02:28.861]             }
[17:02:28.861]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.861]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.861]         }
[17:02:28.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.861]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.861]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.861]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.861]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.861]             base::names(...future.oldOptions))
[17:02:28.861]     }
[17:02:28.861]     if (FALSE) {
[17:02:28.861]     }
[17:02:28.861]     else {
[17:02:28.861]         if (TRUE) {
[17:02:28.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.861]                 open = "w")
[17:02:28.861]         }
[17:02:28.861]         else {
[17:02:28.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.861]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.861]         }
[17:02:28.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.861]             base::sink(type = "output", split = FALSE)
[17:02:28.861]             base::close(...future.stdout)
[17:02:28.861]         }, add = TRUE)
[17:02:28.861]     }
[17:02:28.861]     ...future.frame <- base::sys.nframe()
[17:02:28.861]     ...future.conditions <- base::list()
[17:02:28.861]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.861]     if (FALSE) {
[17:02:28.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.861]     }
[17:02:28.861]     ...future.result <- base::tryCatch({
[17:02:28.861]         base::withCallingHandlers({
[17:02:28.861]             ...future.value <- base::withVisible(base::local({
[17:02:28.861]                 4
[17:02:28.861]             }))
[17:02:28.861]             future::FutureResult(value = ...future.value$value, 
[17:02:28.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.861]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.861]                     ...future.globalenv.names))
[17:02:28.861]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.861]         }, condition = base::local({
[17:02:28.861]             c <- base::c
[17:02:28.861]             inherits <- base::inherits
[17:02:28.861]             invokeRestart <- base::invokeRestart
[17:02:28.861]             length <- base::length
[17:02:28.861]             list <- base::list
[17:02:28.861]             seq.int <- base::seq.int
[17:02:28.861]             signalCondition <- base::signalCondition
[17:02:28.861]             sys.calls <- base::sys.calls
[17:02:28.861]             `[[` <- base::`[[`
[17:02:28.861]             `+` <- base::`+`
[17:02:28.861]             `<<-` <- base::`<<-`
[17:02:28.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.861]                   3L)]
[17:02:28.861]             }
[17:02:28.861]             function(cond) {
[17:02:28.861]                 is_error <- inherits(cond, "error")
[17:02:28.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.861]                   NULL)
[17:02:28.861]                 if (is_error) {
[17:02:28.861]                   sessionInformation <- function() {
[17:02:28.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.861]                       search = base::search(), system = base::Sys.info())
[17:02:28.861]                   }
[17:02:28.861]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.861]                     cond$call), session = sessionInformation(), 
[17:02:28.861]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.861]                   signalCondition(cond)
[17:02:28.861]                 }
[17:02:28.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.861]                 "immediateCondition"))) {
[17:02:28.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.861]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.861]                   if (TRUE && !signal) {
[17:02:28.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.861]                     {
[17:02:28.861]                       inherits <- base::inherits
[17:02:28.861]                       invokeRestart <- base::invokeRestart
[17:02:28.861]                       is.null <- base::is.null
[17:02:28.861]                       muffled <- FALSE
[17:02:28.861]                       if (inherits(cond, "message")) {
[17:02:28.861]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.861]                         if (muffled) 
[17:02:28.861]                           invokeRestart("muffleMessage")
[17:02:28.861]                       }
[17:02:28.861]                       else if (inherits(cond, "warning")) {
[17:02:28.861]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.861]                         if (muffled) 
[17:02:28.861]                           invokeRestart("muffleWarning")
[17:02:28.861]                       }
[17:02:28.861]                       else if (inherits(cond, "condition")) {
[17:02:28.861]                         if (!is.null(pattern)) {
[17:02:28.861]                           computeRestarts <- base::computeRestarts
[17:02:28.861]                           grepl <- base::grepl
[17:02:28.861]                           restarts <- computeRestarts(cond)
[17:02:28.861]                           for (restart in restarts) {
[17:02:28.861]                             name <- restart$name
[17:02:28.861]                             if (is.null(name)) 
[17:02:28.861]                               next
[17:02:28.861]                             if (!grepl(pattern, name)) 
[17:02:28.861]                               next
[17:02:28.861]                             invokeRestart(restart)
[17:02:28.861]                             muffled <- TRUE
[17:02:28.861]                             break
[17:02:28.861]                           }
[17:02:28.861]                         }
[17:02:28.861]                       }
[17:02:28.861]                       invisible(muffled)
[17:02:28.861]                     }
[17:02:28.861]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.861]                   }
[17:02:28.861]                 }
[17:02:28.861]                 else {
[17:02:28.861]                   if (TRUE) {
[17:02:28.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.861]                     {
[17:02:28.861]                       inherits <- base::inherits
[17:02:28.861]                       invokeRestart <- base::invokeRestart
[17:02:28.861]                       is.null <- base::is.null
[17:02:28.861]                       muffled <- FALSE
[17:02:28.861]                       if (inherits(cond, "message")) {
[17:02:28.861]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.861]                         if (muffled) 
[17:02:28.861]                           invokeRestart("muffleMessage")
[17:02:28.861]                       }
[17:02:28.861]                       else if (inherits(cond, "warning")) {
[17:02:28.861]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.861]                         if (muffled) 
[17:02:28.861]                           invokeRestart("muffleWarning")
[17:02:28.861]                       }
[17:02:28.861]                       else if (inherits(cond, "condition")) {
[17:02:28.861]                         if (!is.null(pattern)) {
[17:02:28.861]                           computeRestarts <- base::computeRestarts
[17:02:28.861]                           grepl <- base::grepl
[17:02:28.861]                           restarts <- computeRestarts(cond)
[17:02:28.861]                           for (restart in restarts) {
[17:02:28.861]                             name <- restart$name
[17:02:28.861]                             if (is.null(name)) 
[17:02:28.861]                               next
[17:02:28.861]                             if (!grepl(pattern, name)) 
[17:02:28.861]                               next
[17:02:28.861]                             invokeRestart(restart)
[17:02:28.861]                             muffled <- TRUE
[17:02:28.861]                             break
[17:02:28.861]                           }
[17:02:28.861]                         }
[17:02:28.861]                       }
[17:02:28.861]                       invisible(muffled)
[17:02:28.861]                     }
[17:02:28.861]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.861]                   }
[17:02:28.861]                 }
[17:02:28.861]             }
[17:02:28.861]         }))
[17:02:28.861]     }, error = function(ex) {
[17:02:28.861]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.861]                 ...future.rng), started = ...future.startTime, 
[17:02:28.861]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.861]             version = "1.8"), class = "FutureResult")
[17:02:28.861]     }, finally = {
[17:02:28.861]         if (!identical(...future.workdir, getwd())) 
[17:02:28.861]             setwd(...future.workdir)
[17:02:28.861]         {
[17:02:28.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.861]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.861]             }
[17:02:28.861]             base::options(...future.oldOptions)
[17:02:28.861]             if (.Platform$OS.type == "windows") {
[17:02:28.861]                 old_names <- names(...future.oldEnvVars)
[17:02:28.861]                 envs <- base::Sys.getenv()
[17:02:28.861]                 names <- names(envs)
[17:02:28.861]                 common <- intersect(names, old_names)
[17:02:28.861]                 added <- setdiff(names, old_names)
[17:02:28.861]                 removed <- setdiff(old_names, names)
[17:02:28.861]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.861]                   envs[common]]
[17:02:28.861]                 NAMES <- toupper(changed)
[17:02:28.861]                 args <- list()
[17:02:28.861]                 for (kk in seq_along(NAMES)) {
[17:02:28.861]                   name <- changed[[kk]]
[17:02:28.861]                   NAME <- NAMES[[kk]]
[17:02:28.861]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.861]                     next
[17:02:28.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.861]                 }
[17:02:28.861]                 NAMES <- toupper(added)
[17:02:28.861]                 for (kk in seq_along(NAMES)) {
[17:02:28.861]                   name <- added[[kk]]
[17:02:28.861]                   NAME <- NAMES[[kk]]
[17:02:28.861]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.861]                     next
[17:02:28.861]                   args[[name]] <- ""
[17:02:28.861]                 }
[17:02:28.861]                 NAMES <- toupper(removed)
[17:02:28.861]                 for (kk in seq_along(NAMES)) {
[17:02:28.861]                   name <- removed[[kk]]
[17:02:28.861]                   NAME <- NAMES[[kk]]
[17:02:28.861]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.861]                     next
[17:02:28.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.861]                 }
[17:02:28.861]                 if (length(args) > 0) 
[17:02:28.861]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.861]             }
[17:02:28.861]             else {
[17:02:28.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.861]             }
[17:02:28.861]             {
[17:02:28.861]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.861]                   0L) {
[17:02:28.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.861]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.861]                   base::options(opts)
[17:02:28.861]                 }
[17:02:28.861]                 {
[17:02:28.861]                   {
[17:02:28.861]                     NULL
[17:02:28.861]                     RNGkind("Mersenne-Twister")
[17:02:28.861]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.861]                       inherits = FALSE)
[17:02:28.861]                   }
[17:02:28.861]                   options(future.plan = NULL)
[17:02:28.861]                   if (is.na(NA_character_)) 
[17:02:28.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.861]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.861]                     .init = FALSE)
[17:02:28.861]                 }
[17:02:28.861]             }
[17:02:28.861]         }
[17:02:28.861]     })
[17:02:28.861]     if (TRUE) {
[17:02:28.861]         base::sink(type = "output", split = FALSE)
[17:02:28.861]         if (TRUE) {
[17:02:28.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.861]         }
[17:02:28.861]         else {
[17:02:28.861]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.861]         }
[17:02:28.861]         base::close(...future.stdout)
[17:02:28.861]         ...future.stdout <- NULL
[17:02:28.861]     }
[17:02:28.861]     ...future.result$conditions <- ...future.conditions
[17:02:28.861]     ...future.result$finished <- base::Sys.time()
[17:02:28.861]     ...future.result
[17:02:28.861] }
[17:02:28.863] plan(): Setting new future strategy stack:
[17:02:28.863] List of future strategies:
[17:02:28.863] 1. sequential:
[17:02:28.863]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.863]    - tweaked: FALSE
[17:02:28.863]    - call: NULL
[17:02:28.864] plan(): nbrOfWorkers() = 1
[17:02:28.864] plan(): Setting new future strategy stack:
[17:02:28.864] List of future strategies:
[17:02:28.864] 1. sequential:
[17:02:28.864]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.864]    - tweaked: FALSE
[17:02:28.864]    - call: plan(strategy)
[17:02:28.867] plan(): nbrOfWorkers() = 1
[17:02:28.867] SequentialFuture started (and completed)
[17:02:28.867] - Launch lazy future ... done
[17:02:28.867] run() for ‘SequentialFuture’ ... done
<environment: 0x55c74729a978> 
<environment: 0x55c747e92358> 
[17:02:28.869] resolved() for ‘SequentialFuture’ ...
[17:02:28.869] - state: ‘finished’
[17:02:28.869] - run: TRUE
[17:02:28.869] - result: ‘FutureResult’
[17:02:28.869] resolved() for ‘SequentialFuture’ ... done
[17:02:28.869] resolved() for ‘SequentialFuture’ ...
[17:02:28.869] - state: ‘finished’
[17:02:28.869] - run: TRUE
[17:02:28.870] - result: ‘FutureResult’
[17:02:28.870] resolved() for ‘SequentialFuture’ ... done
[17:02:28.870] resolved() for ‘SequentialFuture’ ...
[17:02:28.870] - state: ‘finished’
[17:02:28.870] - run: TRUE
[17:02:28.870] - result: ‘FutureResult’
[17:02:28.870] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:28.871] resolve() on environment ...
[17:02:28.871]  recursive: 0
[17:02:28.872]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:28.872] signalConditionsASAP(numeric, pos=1) ...
[17:02:28.872] - nx: 4
[17:02:28.872] - relay: TRUE
[17:02:28.872] - stdout: TRUE
[17:02:28.872] - signal: TRUE
[17:02:28.872] - resignal: FALSE
[17:02:28.872] - force: TRUE
[17:02:28.872] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.873] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.873]  - until=2
[17:02:28.873]  - relaying element #2
[17:02:28.873] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:28.873] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.873] signalConditionsASAP(NULL, pos=1) ... done
[17:02:28.873]  length: 3 (resolved future 1)
[17:02:28.873] resolved() for ‘SequentialFuture’ ...
[17:02:28.873] - state: ‘finished’
[17:02:28.873] - run: TRUE
[17:02:28.873] - result: ‘FutureResult’
[17:02:28.874] resolved() for ‘SequentialFuture’ ... done
[17:02:28.874] Future #2
[17:02:28.874] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:28.874] - nx: 4
[17:02:28.874] - relay: TRUE
[17:02:28.874] - stdout: TRUE
[17:02:28.874] - signal: TRUE
[17:02:28.874] - resignal: FALSE
[17:02:28.874] - force: TRUE
[17:02:28.874] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:28.874] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:28.875]  - until=2
[17:02:28.875]  - relaying element #2
[17:02:28.875] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:28.875] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:28.875] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:28.875]  length: 2 (resolved future 2)
[17:02:28.875] resolved() for ‘SequentialFuture’ ...
[17:02:28.875] - state: ‘finished’
[17:02:28.875] - run: TRUE
[17:02:28.875] - result: ‘FutureResult’
[17:02:28.876] resolved() for ‘SequentialFuture’ ... done
[17:02:28.876] Future #3
[17:02:28.876] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:28.876] - nx: 4
[17:02:28.876] - relay: TRUE
[17:02:28.876] - stdout: TRUE
[17:02:28.876] - signal: TRUE
[17:02:28.876] - resignal: FALSE
[17:02:28.876] - force: TRUE
[17:02:28.876] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:28.876] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:28.877]  - until=3
[17:02:28.877]  - relaying element #3
[17:02:28.877] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:28.877] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:28.877] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:28.877]  length: 1 (resolved future 3)
[17:02:28.877] resolved() for ‘SequentialFuture’ ...
[17:02:28.877] - state: ‘finished’
[17:02:28.877] - run: TRUE
[17:02:28.877] - result: ‘FutureResult’
[17:02:28.878] resolved() for ‘SequentialFuture’ ... done
[17:02:28.878] Future #4
[17:02:28.878] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:02:28.878] - nx: 4
[17:02:28.878] - relay: TRUE
[17:02:28.878] - stdout: TRUE
[17:02:28.878] - signal: TRUE
[17:02:28.878] - resignal: FALSE
[17:02:28.878] - force: TRUE
[17:02:28.878] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:28.878] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:28.878]  - until=4
[17:02:28.879]  - relaying element #4
[17:02:28.879] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.879] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:28.879] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:02:28.879]  length: 0 (resolved future 4)
[17:02:28.879] Relaying remaining futures
[17:02:28.879] signalConditionsASAP(NULL, pos=0) ...
[17:02:28.879] - nx: 4
[17:02:28.879] - relay: TRUE
[17:02:28.879] - stdout: TRUE
[17:02:28.880] - signal: TRUE
[17:02:28.880] - resignal: FALSE
[17:02:28.880] - force: TRUE
[17:02:28.880] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.880] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:28.880] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:28.880] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:28.880] signalConditionsASAP(NULL, pos=0) ... done
[17:02:28.880] resolve() on environment ... DONE
<environment: 0x55c74734f3a8> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[17:02:28.881] plan(): Setting new future strategy stack:
[17:02:28.881] List of future strategies:
[17:02:28.881] 1. sequential:
[17:02:28.881]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.881]    - tweaked: FALSE
[17:02:28.881]    - call: plan(strategy)
[17:02:28.882] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[17:02:28.882] getGlobalsAndPackages() ...
[17:02:28.882] Searching for globals...
[17:02:28.882] 
[17:02:28.882] Searching for globals ... DONE
[17:02:28.883] - globals: [0] <none>
[17:02:28.883] getGlobalsAndPackages() ... DONE
[17:02:28.883] run() for ‘Future’ ...
[17:02:28.883] - state: ‘created’
[17:02:28.883] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.883] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.883] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.884]   - Field: ‘label’
[17:02:28.884]   - Field: ‘local’
[17:02:28.884]   - Field: ‘owner’
[17:02:28.884]   - Field: ‘envir’
[17:02:28.884]   - Field: ‘packages’
[17:02:28.884]   - Field: ‘gc’
[17:02:28.884]   - Field: ‘conditions’
[17:02:28.884]   - Field: ‘expr’
[17:02:28.884]   - Field: ‘uuid’
[17:02:28.884]   - Field: ‘seed’
[17:02:28.884]   - Field: ‘version’
[17:02:28.884]   - Field: ‘result’
[17:02:28.885]   - Field: ‘asynchronous’
[17:02:28.885]   - Field: ‘calls’
[17:02:28.885]   - Field: ‘globals’
[17:02:28.885]   - Field: ‘stdout’
[17:02:28.885]   - Field: ‘earlySignal’
[17:02:28.885]   - Field: ‘lazy’
[17:02:28.885]   - Field: ‘state’
[17:02:28.885] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.885] - Launch lazy future ...
[17:02:28.885] Packages needed by the future expression (n = 0): <none>
[17:02:28.886] Packages needed by future strategies (n = 0): <none>
[17:02:28.886] {
[17:02:28.886]     {
[17:02:28.886]         {
[17:02:28.886]             ...future.startTime <- base::Sys.time()
[17:02:28.886]             {
[17:02:28.886]                 {
[17:02:28.886]                   {
[17:02:28.886]                     base::local({
[17:02:28.886]                       has_future <- base::requireNamespace("future", 
[17:02:28.886]                         quietly = TRUE)
[17:02:28.886]                       if (has_future) {
[17:02:28.886]                         ns <- base::getNamespace("future")
[17:02:28.886]                         version <- ns[[".package"]][["version"]]
[17:02:28.886]                         if (is.null(version)) 
[17:02:28.886]                           version <- utils::packageVersion("future")
[17:02:28.886]                       }
[17:02:28.886]                       else {
[17:02:28.886]                         version <- NULL
[17:02:28.886]                       }
[17:02:28.886]                       if (!has_future || version < "1.8.0") {
[17:02:28.886]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.886]                           "", base::R.version$version.string), 
[17:02:28.886]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.886]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.886]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.886]                             "release", "version")], collapse = " "), 
[17:02:28.886]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.886]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.886]                           info)
[17:02:28.886]                         info <- base::paste(info, collapse = "; ")
[17:02:28.886]                         if (!has_future) {
[17:02:28.886]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.886]                             info)
[17:02:28.886]                         }
[17:02:28.886]                         else {
[17:02:28.886]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.886]                             info, version)
[17:02:28.886]                         }
[17:02:28.886]                         base::stop(msg)
[17:02:28.886]                       }
[17:02:28.886]                     })
[17:02:28.886]                   }
[17:02:28.886]                   ...future.strategy.old <- future::plan("list")
[17:02:28.886]                   options(future.plan = NULL)
[17:02:28.886]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.886]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.886]                 }
[17:02:28.886]                 ...future.workdir <- getwd()
[17:02:28.886]             }
[17:02:28.886]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.886]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.886]         }
[17:02:28.886]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.886]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.886]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.886]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.886]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.886]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.886]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.886]             base::names(...future.oldOptions))
[17:02:28.886]     }
[17:02:28.886]     if (FALSE) {
[17:02:28.886]     }
[17:02:28.886]     else {
[17:02:28.886]         if (TRUE) {
[17:02:28.886]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.886]                 open = "w")
[17:02:28.886]         }
[17:02:28.886]         else {
[17:02:28.886]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.886]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.886]         }
[17:02:28.886]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.886]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.886]             base::sink(type = "output", split = FALSE)
[17:02:28.886]             base::close(...future.stdout)
[17:02:28.886]         }, add = TRUE)
[17:02:28.886]     }
[17:02:28.886]     ...future.frame <- base::sys.nframe()
[17:02:28.886]     ...future.conditions <- base::list()
[17:02:28.886]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.886]     if (FALSE) {
[17:02:28.886]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.886]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.886]     }
[17:02:28.886]     ...future.result <- base::tryCatch({
[17:02:28.886]         base::withCallingHandlers({
[17:02:28.886]             ...future.value <- base::withVisible(base::local(2))
[17:02:28.886]             future::FutureResult(value = ...future.value$value, 
[17:02:28.886]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.886]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.886]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.886]                     ...future.globalenv.names))
[17:02:28.886]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.886]         }, condition = base::local({
[17:02:28.886]             c <- base::c
[17:02:28.886]             inherits <- base::inherits
[17:02:28.886]             invokeRestart <- base::invokeRestart
[17:02:28.886]             length <- base::length
[17:02:28.886]             list <- base::list
[17:02:28.886]             seq.int <- base::seq.int
[17:02:28.886]             signalCondition <- base::signalCondition
[17:02:28.886]             sys.calls <- base::sys.calls
[17:02:28.886]             `[[` <- base::`[[`
[17:02:28.886]             `+` <- base::`+`
[17:02:28.886]             `<<-` <- base::`<<-`
[17:02:28.886]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.886]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.886]                   3L)]
[17:02:28.886]             }
[17:02:28.886]             function(cond) {
[17:02:28.886]                 is_error <- inherits(cond, "error")
[17:02:28.886]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.886]                   NULL)
[17:02:28.886]                 if (is_error) {
[17:02:28.886]                   sessionInformation <- function() {
[17:02:28.886]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.886]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.886]                       search = base::search(), system = base::Sys.info())
[17:02:28.886]                   }
[17:02:28.886]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.886]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.886]                     cond$call), session = sessionInformation(), 
[17:02:28.886]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.886]                   signalCondition(cond)
[17:02:28.886]                 }
[17:02:28.886]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.886]                 "immediateCondition"))) {
[17:02:28.886]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.886]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.886]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.886]                   if (TRUE && !signal) {
[17:02:28.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.886]                     {
[17:02:28.886]                       inherits <- base::inherits
[17:02:28.886]                       invokeRestart <- base::invokeRestart
[17:02:28.886]                       is.null <- base::is.null
[17:02:28.886]                       muffled <- FALSE
[17:02:28.886]                       if (inherits(cond, "message")) {
[17:02:28.886]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.886]                         if (muffled) 
[17:02:28.886]                           invokeRestart("muffleMessage")
[17:02:28.886]                       }
[17:02:28.886]                       else if (inherits(cond, "warning")) {
[17:02:28.886]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.886]                         if (muffled) 
[17:02:28.886]                           invokeRestart("muffleWarning")
[17:02:28.886]                       }
[17:02:28.886]                       else if (inherits(cond, "condition")) {
[17:02:28.886]                         if (!is.null(pattern)) {
[17:02:28.886]                           computeRestarts <- base::computeRestarts
[17:02:28.886]                           grepl <- base::grepl
[17:02:28.886]                           restarts <- computeRestarts(cond)
[17:02:28.886]                           for (restart in restarts) {
[17:02:28.886]                             name <- restart$name
[17:02:28.886]                             if (is.null(name)) 
[17:02:28.886]                               next
[17:02:28.886]                             if (!grepl(pattern, name)) 
[17:02:28.886]                               next
[17:02:28.886]                             invokeRestart(restart)
[17:02:28.886]                             muffled <- TRUE
[17:02:28.886]                             break
[17:02:28.886]                           }
[17:02:28.886]                         }
[17:02:28.886]                       }
[17:02:28.886]                       invisible(muffled)
[17:02:28.886]                     }
[17:02:28.886]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.886]                   }
[17:02:28.886]                 }
[17:02:28.886]                 else {
[17:02:28.886]                   if (TRUE) {
[17:02:28.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.886]                     {
[17:02:28.886]                       inherits <- base::inherits
[17:02:28.886]                       invokeRestart <- base::invokeRestart
[17:02:28.886]                       is.null <- base::is.null
[17:02:28.886]                       muffled <- FALSE
[17:02:28.886]                       if (inherits(cond, "message")) {
[17:02:28.886]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.886]                         if (muffled) 
[17:02:28.886]                           invokeRestart("muffleMessage")
[17:02:28.886]                       }
[17:02:28.886]                       else if (inherits(cond, "warning")) {
[17:02:28.886]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.886]                         if (muffled) 
[17:02:28.886]                           invokeRestart("muffleWarning")
[17:02:28.886]                       }
[17:02:28.886]                       else if (inherits(cond, "condition")) {
[17:02:28.886]                         if (!is.null(pattern)) {
[17:02:28.886]                           computeRestarts <- base::computeRestarts
[17:02:28.886]                           grepl <- base::grepl
[17:02:28.886]                           restarts <- computeRestarts(cond)
[17:02:28.886]                           for (restart in restarts) {
[17:02:28.886]                             name <- restart$name
[17:02:28.886]                             if (is.null(name)) 
[17:02:28.886]                               next
[17:02:28.886]                             if (!grepl(pattern, name)) 
[17:02:28.886]                               next
[17:02:28.886]                             invokeRestart(restart)
[17:02:28.886]                             muffled <- TRUE
[17:02:28.886]                             break
[17:02:28.886]                           }
[17:02:28.886]                         }
[17:02:28.886]                       }
[17:02:28.886]                       invisible(muffled)
[17:02:28.886]                     }
[17:02:28.886]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.886]                   }
[17:02:28.886]                 }
[17:02:28.886]             }
[17:02:28.886]         }))
[17:02:28.886]     }, error = function(ex) {
[17:02:28.886]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.886]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.886]                 ...future.rng), started = ...future.startTime, 
[17:02:28.886]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.886]             version = "1.8"), class = "FutureResult")
[17:02:28.886]     }, finally = {
[17:02:28.886]         if (!identical(...future.workdir, getwd())) 
[17:02:28.886]             setwd(...future.workdir)
[17:02:28.886]         {
[17:02:28.886]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.886]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.886]             }
[17:02:28.886]             base::options(...future.oldOptions)
[17:02:28.886]             if (.Platform$OS.type == "windows") {
[17:02:28.886]                 old_names <- names(...future.oldEnvVars)
[17:02:28.886]                 envs <- base::Sys.getenv()
[17:02:28.886]                 names <- names(envs)
[17:02:28.886]                 common <- intersect(names, old_names)
[17:02:28.886]                 added <- setdiff(names, old_names)
[17:02:28.886]                 removed <- setdiff(old_names, names)
[17:02:28.886]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.886]                   envs[common]]
[17:02:28.886]                 NAMES <- toupper(changed)
[17:02:28.886]                 args <- list()
[17:02:28.886]                 for (kk in seq_along(NAMES)) {
[17:02:28.886]                   name <- changed[[kk]]
[17:02:28.886]                   NAME <- NAMES[[kk]]
[17:02:28.886]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.886]                     next
[17:02:28.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.886]                 }
[17:02:28.886]                 NAMES <- toupper(added)
[17:02:28.886]                 for (kk in seq_along(NAMES)) {
[17:02:28.886]                   name <- added[[kk]]
[17:02:28.886]                   NAME <- NAMES[[kk]]
[17:02:28.886]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.886]                     next
[17:02:28.886]                   args[[name]] <- ""
[17:02:28.886]                 }
[17:02:28.886]                 NAMES <- toupper(removed)
[17:02:28.886]                 for (kk in seq_along(NAMES)) {
[17:02:28.886]                   name <- removed[[kk]]
[17:02:28.886]                   NAME <- NAMES[[kk]]
[17:02:28.886]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.886]                     next
[17:02:28.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.886]                 }
[17:02:28.886]                 if (length(args) > 0) 
[17:02:28.886]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.886]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.886]             }
[17:02:28.886]             else {
[17:02:28.886]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.886]             }
[17:02:28.886]             {
[17:02:28.886]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.886]                   0L) {
[17:02:28.886]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.886]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.886]                   base::options(opts)
[17:02:28.886]                 }
[17:02:28.886]                 {
[17:02:28.886]                   {
[17:02:28.886]                     NULL
[17:02:28.886]                     RNGkind("Mersenne-Twister")
[17:02:28.886]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.886]                       inherits = FALSE)
[17:02:28.886]                   }
[17:02:28.886]                   options(future.plan = NULL)
[17:02:28.886]                   if (is.na(NA_character_)) 
[17:02:28.886]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.886]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.886]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.886]                     .init = FALSE)
[17:02:28.886]                 }
[17:02:28.886]             }
[17:02:28.886]         }
[17:02:28.886]     })
[17:02:28.886]     if (TRUE) {
[17:02:28.886]         base::sink(type = "output", split = FALSE)
[17:02:28.886]         if (TRUE) {
[17:02:28.886]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.886]         }
[17:02:28.886]         else {
[17:02:28.886]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.886]         }
[17:02:28.886]         base::close(...future.stdout)
[17:02:28.886]         ...future.stdout <- NULL
[17:02:28.886]     }
[17:02:28.886]     ...future.result$conditions <- ...future.conditions
[17:02:28.886]     ...future.result$finished <- base::Sys.time()
[17:02:28.886]     ...future.result
[17:02:28.886] }
[17:02:28.888] plan(): Setting new future strategy stack:
[17:02:28.888] List of future strategies:
[17:02:28.888] 1. sequential:
[17:02:28.888]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.888]    - tweaked: FALSE
[17:02:28.888]    - call: NULL
[17:02:28.888] plan(): nbrOfWorkers() = 1
[17:02:28.889] plan(): Setting new future strategy stack:
[17:02:28.889] List of future strategies:
[17:02:28.889] 1. sequential:
[17:02:28.889]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.889]    - tweaked: FALSE
[17:02:28.889]    - call: plan(strategy)
[17:02:28.889] plan(): nbrOfWorkers() = 1
[17:02:28.890] SequentialFuture started (and completed)
[17:02:28.890] - Launch lazy future ... done
[17:02:28.890] run() for ‘SequentialFuture’ ... done
[17:02:28.890] getGlobalsAndPackages() ...
[17:02:28.890] Searching for globals...
[17:02:28.890] 
[17:02:28.890] Searching for globals ... DONE
[17:02:28.891] - globals: [0] <none>
[17:02:28.891] getGlobalsAndPackages() ... DONE
[17:02:28.891] run() for ‘Future’ ...
[17:02:28.891] - state: ‘created’
[17:02:28.891] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.891] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.891] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.892]   - Field: ‘label’
[17:02:28.892]   - Field: ‘local’
[17:02:28.892]   - Field: ‘owner’
[17:02:28.892]   - Field: ‘envir’
[17:02:28.892]   - Field: ‘packages’
[17:02:28.892]   - Field: ‘gc’
[17:02:28.892]   - Field: ‘conditions’
[17:02:28.894]   - Field: ‘expr’
[17:02:28.894]   - Field: ‘uuid’
[17:02:28.894]   - Field: ‘seed’
[17:02:28.894]   - Field: ‘version’
[17:02:28.894]   - Field: ‘result’
[17:02:28.894]   - Field: ‘asynchronous’
[17:02:28.894]   - Field: ‘calls’
[17:02:28.895]   - Field: ‘globals’
[17:02:28.895]   - Field: ‘stdout’
[17:02:28.895]   - Field: ‘earlySignal’
[17:02:28.895]   - Field: ‘lazy’
[17:02:28.895]   - Field: ‘state’
[17:02:28.895] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.895] - Launch lazy future ...
[17:02:28.895] Packages needed by the future expression (n = 0): <none>
[17:02:28.895] Packages needed by future strategies (n = 0): <none>
[17:02:28.896] {
[17:02:28.896]     {
[17:02:28.896]         {
[17:02:28.896]             ...future.startTime <- base::Sys.time()
[17:02:28.896]             {
[17:02:28.896]                 {
[17:02:28.896]                   {
[17:02:28.896]                     base::local({
[17:02:28.896]                       has_future <- base::requireNamespace("future", 
[17:02:28.896]                         quietly = TRUE)
[17:02:28.896]                       if (has_future) {
[17:02:28.896]                         ns <- base::getNamespace("future")
[17:02:28.896]                         version <- ns[[".package"]][["version"]]
[17:02:28.896]                         if (is.null(version)) 
[17:02:28.896]                           version <- utils::packageVersion("future")
[17:02:28.896]                       }
[17:02:28.896]                       else {
[17:02:28.896]                         version <- NULL
[17:02:28.896]                       }
[17:02:28.896]                       if (!has_future || version < "1.8.0") {
[17:02:28.896]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.896]                           "", base::R.version$version.string), 
[17:02:28.896]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.896]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.896]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.896]                             "release", "version")], collapse = " "), 
[17:02:28.896]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.896]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.896]                           info)
[17:02:28.896]                         info <- base::paste(info, collapse = "; ")
[17:02:28.896]                         if (!has_future) {
[17:02:28.896]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.896]                             info)
[17:02:28.896]                         }
[17:02:28.896]                         else {
[17:02:28.896]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.896]                             info, version)
[17:02:28.896]                         }
[17:02:28.896]                         base::stop(msg)
[17:02:28.896]                       }
[17:02:28.896]                     })
[17:02:28.896]                   }
[17:02:28.896]                   ...future.strategy.old <- future::plan("list")
[17:02:28.896]                   options(future.plan = NULL)
[17:02:28.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.896]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.896]                 }
[17:02:28.896]                 ...future.workdir <- getwd()
[17:02:28.896]             }
[17:02:28.896]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.896]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.896]         }
[17:02:28.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.896]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.896]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.896]             base::names(...future.oldOptions))
[17:02:28.896]     }
[17:02:28.896]     if (FALSE) {
[17:02:28.896]     }
[17:02:28.896]     else {
[17:02:28.896]         if (TRUE) {
[17:02:28.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.896]                 open = "w")
[17:02:28.896]         }
[17:02:28.896]         else {
[17:02:28.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.896]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.896]         }
[17:02:28.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.896]             base::sink(type = "output", split = FALSE)
[17:02:28.896]             base::close(...future.stdout)
[17:02:28.896]         }, add = TRUE)
[17:02:28.896]     }
[17:02:28.896]     ...future.frame <- base::sys.nframe()
[17:02:28.896]     ...future.conditions <- base::list()
[17:02:28.896]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.896]     if (FALSE) {
[17:02:28.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.896]     }
[17:02:28.896]     ...future.result <- base::tryCatch({
[17:02:28.896]         base::withCallingHandlers({
[17:02:28.896]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:28.896]             future::FutureResult(value = ...future.value$value, 
[17:02:28.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.896]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.896]                     ...future.globalenv.names))
[17:02:28.896]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.896]         }, condition = base::local({
[17:02:28.896]             c <- base::c
[17:02:28.896]             inherits <- base::inherits
[17:02:28.896]             invokeRestart <- base::invokeRestart
[17:02:28.896]             length <- base::length
[17:02:28.896]             list <- base::list
[17:02:28.896]             seq.int <- base::seq.int
[17:02:28.896]             signalCondition <- base::signalCondition
[17:02:28.896]             sys.calls <- base::sys.calls
[17:02:28.896]             `[[` <- base::`[[`
[17:02:28.896]             `+` <- base::`+`
[17:02:28.896]             `<<-` <- base::`<<-`
[17:02:28.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.896]                   3L)]
[17:02:28.896]             }
[17:02:28.896]             function(cond) {
[17:02:28.896]                 is_error <- inherits(cond, "error")
[17:02:28.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.896]                   NULL)
[17:02:28.896]                 if (is_error) {
[17:02:28.896]                   sessionInformation <- function() {
[17:02:28.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.896]                       search = base::search(), system = base::Sys.info())
[17:02:28.896]                   }
[17:02:28.896]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.896]                     cond$call), session = sessionInformation(), 
[17:02:28.896]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.896]                   signalCondition(cond)
[17:02:28.896]                 }
[17:02:28.896]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.896]                 "immediateCondition"))) {
[17:02:28.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.896]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.896]                   if (TRUE && !signal) {
[17:02:28.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.896]                     {
[17:02:28.896]                       inherits <- base::inherits
[17:02:28.896]                       invokeRestart <- base::invokeRestart
[17:02:28.896]                       is.null <- base::is.null
[17:02:28.896]                       muffled <- FALSE
[17:02:28.896]                       if (inherits(cond, "message")) {
[17:02:28.896]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.896]                         if (muffled) 
[17:02:28.896]                           invokeRestart("muffleMessage")
[17:02:28.896]                       }
[17:02:28.896]                       else if (inherits(cond, "warning")) {
[17:02:28.896]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.896]                         if (muffled) 
[17:02:28.896]                           invokeRestart("muffleWarning")
[17:02:28.896]                       }
[17:02:28.896]                       else if (inherits(cond, "condition")) {
[17:02:28.896]                         if (!is.null(pattern)) {
[17:02:28.896]                           computeRestarts <- base::computeRestarts
[17:02:28.896]                           grepl <- base::grepl
[17:02:28.896]                           restarts <- computeRestarts(cond)
[17:02:28.896]                           for (restart in restarts) {
[17:02:28.896]                             name <- restart$name
[17:02:28.896]                             if (is.null(name)) 
[17:02:28.896]                               next
[17:02:28.896]                             if (!grepl(pattern, name)) 
[17:02:28.896]                               next
[17:02:28.896]                             invokeRestart(restart)
[17:02:28.896]                             muffled <- TRUE
[17:02:28.896]                             break
[17:02:28.896]                           }
[17:02:28.896]                         }
[17:02:28.896]                       }
[17:02:28.896]                       invisible(muffled)
[17:02:28.896]                     }
[17:02:28.896]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.896]                   }
[17:02:28.896]                 }
[17:02:28.896]                 else {
[17:02:28.896]                   if (TRUE) {
[17:02:28.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.896]                     {
[17:02:28.896]                       inherits <- base::inherits
[17:02:28.896]                       invokeRestart <- base::invokeRestart
[17:02:28.896]                       is.null <- base::is.null
[17:02:28.896]                       muffled <- FALSE
[17:02:28.896]                       if (inherits(cond, "message")) {
[17:02:28.896]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.896]                         if (muffled) 
[17:02:28.896]                           invokeRestart("muffleMessage")
[17:02:28.896]                       }
[17:02:28.896]                       else if (inherits(cond, "warning")) {
[17:02:28.896]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.896]                         if (muffled) 
[17:02:28.896]                           invokeRestart("muffleWarning")
[17:02:28.896]                       }
[17:02:28.896]                       else if (inherits(cond, "condition")) {
[17:02:28.896]                         if (!is.null(pattern)) {
[17:02:28.896]                           computeRestarts <- base::computeRestarts
[17:02:28.896]                           grepl <- base::grepl
[17:02:28.896]                           restarts <- computeRestarts(cond)
[17:02:28.896]                           for (restart in restarts) {
[17:02:28.896]                             name <- restart$name
[17:02:28.896]                             if (is.null(name)) 
[17:02:28.896]                               next
[17:02:28.896]                             if (!grepl(pattern, name)) 
[17:02:28.896]                               next
[17:02:28.896]                             invokeRestart(restart)
[17:02:28.896]                             muffled <- TRUE
[17:02:28.896]                             break
[17:02:28.896]                           }
[17:02:28.896]                         }
[17:02:28.896]                       }
[17:02:28.896]                       invisible(muffled)
[17:02:28.896]                     }
[17:02:28.896]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.896]                   }
[17:02:28.896]                 }
[17:02:28.896]             }
[17:02:28.896]         }))
[17:02:28.896]     }, error = function(ex) {
[17:02:28.896]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.896]                 ...future.rng), started = ...future.startTime, 
[17:02:28.896]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.896]             version = "1.8"), class = "FutureResult")
[17:02:28.896]     }, finally = {
[17:02:28.896]         if (!identical(...future.workdir, getwd())) 
[17:02:28.896]             setwd(...future.workdir)
[17:02:28.896]         {
[17:02:28.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.896]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.896]             }
[17:02:28.896]             base::options(...future.oldOptions)
[17:02:28.896]             if (.Platform$OS.type == "windows") {
[17:02:28.896]                 old_names <- names(...future.oldEnvVars)
[17:02:28.896]                 envs <- base::Sys.getenv()
[17:02:28.896]                 names <- names(envs)
[17:02:28.896]                 common <- intersect(names, old_names)
[17:02:28.896]                 added <- setdiff(names, old_names)
[17:02:28.896]                 removed <- setdiff(old_names, names)
[17:02:28.896]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.896]                   envs[common]]
[17:02:28.896]                 NAMES <- toupper(changed)
[17:02:28.896]                 args <- list()
[17:02:28.896]                 for (kk in seq_along(NAMES)) {
[17:02:28.896]                   name <- changed[[kk]]
[17:02:28.896]                   NAME <- NAMES[[kk]]
[17:02:28.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.896]                     next
[17:02:28.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.896]                 }
[17:02:28.896]                 NAMES <- toupper(added)
[17:02:28.896]                 for (kk in seq_along(NAMES)) {
[17:02:28.896]                   name <- added[[kk]]
[17:02:28.896]                   NAME <- NAMES[[kk]]
[17:02:28.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.896]                     next
[17:02:28.896]                   args[[name]] <- ""
[17:02:28.896]                 }
[17:02:28.896]                 NAMES <- toupper(removed)
[17:02:28.896]                 for (kk in seq_along(NAMES)) {
[17:02:28.896]                   name <- removed[[kk]]
[17:02:28.896]                   NAME <- NAMES[[kk]]
[17:02:28.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.896]                     next
[17:02:28.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.896]                 }
[17:02:28.896]                 if (length(args) > 0) 
[17:02:28.896]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.896]             }
[17:02:28.896]             else {
[17:02:28.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.896]             }
[17:02:28.896]             {
[17:02:28.896]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.896]                   0L) {
[17:02:28.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.896]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.896]                   base::options(opts)
[17:02:28.896]                 }
[17:02:28.896]                 {
[17:02:28.896]                   {
[17:02:28.896]                     NULL
[17:02:28.896]                     RNGkind("Mersenne-Twister")
[17:02:28.896]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.896]                       inherits = FALSE)
[17:02:28.896]                   }
[17:02:28.896]                   options(future.plan = NULL)
[17:02:28.896]                   if (is.na(NA_character_)) 
[17:02:28.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.896]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.896]                     .init = FALSE)
[17:02:28.896]                 }
[17:02:28.896]             }
[17:02:28.896]         }
[17:02:28.896]     })
[17:02:28.896]     if (TRUE) {
[17:02:28.896]         base::sink(type = "output", split = FALSE)
[17:02:28.896]         if (TRUE) {
[17:02:28.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.896]         }
[17:02:28.896]         else {
[17:02:28.896]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.896]         }
[17:02:28.896]         base::close(...future.stdout)
[17:02:28.896]         ...future.stdout <- NULL
[17:02:28.896]     }
[17:02:28.896]     ...future.result$conditions <- ...future.conditions
[17:02:28.896]     ...future.result$finished <- base::Sys.time()
[17:02:28.896]     ...future.result
[17:02:28.896] }
[17:02:28.898] plan(): Setting new future strategy stack:
[17:02:28.898] List of future strategies:
[17:02:28.898] 1. sequential:
[17:02:28.898]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.898]    - tweaked: FALSE
[17:02:28.898]    - call: NULL
[17:02:28.898] plan(): nbrOfWorkers() = 1
[17:02:28.899] plan(): Setting new future strategy stack:
[17:02:28.899] List of future strategies:
[17:02:28.899] 1. sequential:
[17:02:28.899]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.899]    - tweaked: FALSE
[17:02:28.899]    - call: plan(strategy)
[17:02:28.899] plan(): nbrOfWorkers() = 1
[17:02:28.899] SequentialFuture started (and completed)
[17:02:28.900] - Launch lazy future ... done
[17:02:28.900] run() for ‘SequentialFuture’ ... done
[17:02:28.900] getGlobalsAndPackages() ...
[17:02:28.900] Searching for globals...
[17:02:28.901] - globals found: [1] ‘{’
[17:02:28.901] Searching for globals ... DONE
[17:02:28.901] Resolving globals: FALSE
[17:02:28.901] 
[17:02:28.901] 
[17:02:28.902] getGlobalsAndPackages() ... DONE
[17:02:28.902] run() for ‘Future’ ...
[17:02:28.902] - state: ‘created’
[17:02:28.902] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.902] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.902] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.902]   - Field: ‘label’
[17:02:28.902]   - Field: ‘local’
[17:02:28.903]   - Field: ‘owner’
[17:02:28.903]   - Field: ‘envir’
[17:02:28.903]   - Field: ‘packages’
[17:02:28.903]   - Field: ‘gc’
[17:02:28.903]   - Field: ‘conditions’
[17:02:28.903]   - Field: ‘expr’
[17:02:28.903]   - Field: ‘uuid’
[17:02:28.903]   - Field: ‘seed’
[17:02:28.903]   - Field: ‘version’
[17:02:28.903]   - Field: ‘result’
[17:02:28.903]   - Field: ‘asynchronous’
[17:02:28.904]   - Field: ‘calls’
[17:02:28.904]   - Field: ‘globals’
[17:02:28.904]   - Field: ‘stdout’
[17:02:28.904]   - Field: ‘earlySignal’
[17:02:28.904]   - Field: ‘lazy’
[17:02:28.904]   - Field: ‘state’
[17:02:28.904] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.904] - Launch lazy future ...
[17:02:28.904] Packages needed by the future expression (n = 0): <none>
[17:02:28.904] Packages needed by future strategies (n = 0): <none>
[17:02:28.905] {
[17:02:28.905]     {
[17:02:28.905]         {
[17:02:28.905]             ...future.startTime <- base::Sys.time()
[17:02:28.905]             {
[17:02:28.905]                 {
[17:02:28.905]                   {
[17:02:28.905]                     base::local({
[17:02:28.905]                       has_future <- base::requireNamespace("future", 
[17:02:28.905]                         quietly = TRUE)
[17:02:28.905]                       if (has_future) {
[17:02:28.905]                         ns <- base::getNamespace("future")
[17:02:28.905]                         version <- ns[[".package"]][["version"]]
[17:02:28.905]                         if (is.null(version)) 
[17:02:28.905]                           version <- utils::packageVersion("future")
[17:02:28.905]                       }
[17:02:28.905]                       else {
[17:02:28.905]                         version <- NULL
[17:02:28.905]                       }
[17:02:28.905]                       if (!has_future || version < "1.8.0") {
[17:02:28.905]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.905]                           "", base::R.version$version.string), 
[17:02:28.905]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.905]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.905]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.905]                             "release", "version")], collapse = " "), 
[17:02:28.905]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.905]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.905]                           info)
[17:02:28.905]                         info <- base::paste(info, collapse = "; ")
[17:02:28.905]                         if (!has_future) {
[17:02:28.905]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.905]                             info)
[17:02:28.905]                         }
[17:02:28.905]                         else {
[17:02:28.905]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.905]                             info, version)
[17:02:28.905]                         }
[17:02:28.905]                         base::stop(msg)
[17:02:28.905]                       }
[17:02:28.905]                     })
[17:02:28.905]                   }
[17:02:28.905]                   ...future.strategy.old <- future::plan("list")
[17:02:28.905]                   options(future.plan = NULL)
[17:02:28.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.905]                 }
[17:02:28.905]                 ...future.workdir <- getwd()
[17:02:28.905]             }
[17:02:28.905]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.905]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.905]         }
[17:02:28.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.905]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.905]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.905]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.905]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.905]             base::names(...future.oldOptions))
[17:02:28.905]     }
[17:02:28.905]     if (FALSE) {
[17:02:28.905]     }
[17:02:28.905]     else {
[17:02:28.905]         if (TRUE) {
[17:02:28.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.905]                 open = "w")
[17:02:28.905]         }
[17:02:28.905]         else {
[17:02:28.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.905]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.905]         }
[17:02:28.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.905]             base::sink(type = "output", split = FALSE)
[17:02:28.905]             base::close(...future.stdout)
[17:02:28.905]         }, add = TRUE)
[17:02:28.905]     }
[17:02:28.905]     ...future.frame <- base::sys.nframe()
[17:02:28.905]     ...future.conditions <- base::list()
[17:02:28.905]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.905]     if (FALSE) {
[17:02:28.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.905]     }
[17:02:28.905]     ...future.result <- base::tryCatch({
[17:02:28.905]         base::withCallingHandlers({
[17:02:28.905]             ...future.value <- base::withVisible(base::local({
[17:02:28.905]                 4
[17:02:28.905]             }))
[17:02:28.905]             future::FutureResult(value = ...future.value$value, 
[17:02:28.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.905]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.905]                     ...future.globalenv.names))
[17:02:28.905]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.905]         }, condition = base::local({
[17:02:28.905]             c <- base::c
[17:02:28.905]             inherits <- base::inherits
[17:02:28.905]             invokeRestart <- base::invokeRestart
[17:02:28.905]             length <- base::length
[17:02:28.905]             list <- base::list
[17:02:28.905]             seq.int <- base::seq.int
[17:02:28.905]             signalCondition <- base::signalCondition
[17:02:28.905]             sys.calls <- base::sys.calls
[17:02:28.905]             `[[` <- base::`[[`
[17:02:28.905]             `+` <- base::`+`
[17:02:28.905]             `<<-` <- base::`<<-`
[17:02:28.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.905]                   3L)]
[17:02:28.905]             }
[17:02:28.905]             function(cond) {
[17:02:28.905]                 is_error <- inherits(cond, "error")
[17:02:28.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.905]                   NULL)
[17:02:28.905]                 if (is_error) {
[17:02:28.905]                   sessionInformation <- function() {
[17:02:28.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.905]                       search = base::search(), system = base::Sys.info())
[17:02:28.905]                   }
[17:02:28.905]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.905]                     cond$call), session = sessionInformation(), 
[17:02:28.905]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.905]                   signalCondition(cond)
[17:02:28.905]                 }
[17:02:28.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.905]                 "immediateCondition"))) {
[17:02:28.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.905]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.905]                   if (TRUE && !signal) {
[17:02:28.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.905]                     {
[17:02:28.905]                       inherits <- base::inherits
[17:02:28.905]                       invokeRestart <- base::invokeRestart
[17:02:28.905]                       is.null <- base::is.null
[17:02:28.905]                       muffled <- FALSE
[17:02:28.905]                       if (inherits(cond, "message")) {
[17:02:28.905]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.905]                         if (muffled) 
[17:02:28.905]                           invokeRestart("muffleMessage")
[17:02:28.905]                       }
[17:02:28.905]                       else if (inherits(cond, "warning")) {
[17:02:28.905]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.905]                         if (muffled) 
[17:02:28.905]                           invokeRestart("muffleWarning")
[17:02:28.905]                       }
[17:02:28.905]                       else if (inherits(cond, "condition")) {
[17:02:28.905]                         if (!is.null(pattern)) {
[17:02:28.905]                           computeRestarts <- base::computeRestarts
[17:02:28.905]                           grepl <- base::grepl
[17:02:28.905]                           restarts <- computeRestarts(cond)
[17:02:28.905]                           for (restart in restarts) {
[17:02:28.905]                             name <- restart$name
[17:02:28.905]                             if (is.null(name)) 
[17:02:28.905]                               next
[17:02:28.905]                             if (!grepl(pattern, name)) 
[17:02:28.905]                               next
[17:02:28.905]                             invokeRestart(restart)
[17:02:28.905]                             muffled <- TRUE
[17:02:28.905]                             break
[17:02:28.905]                           }
[17:02:28.905]                         }
[17:02:28.905]                       }
[17:02:28.905]                       invisible(muffled)
[17:02:28.905]                     }
[17:02:28.905]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.905]                   }
[17:02:28.905]                 }
[17:02:28.905]                 else {
[17:02:28.905]                   if (TRUE) {
[17:02:28.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.905]                     {
[17:02:28.905]                       inherits <- base::inherits
[17:02:28.905]                       invokeRestart <- base::invokeRestart
[17:02:28.905]                       is.null <- base::is.null
[17:02:28.905]                       muffled <- FALSE
[17:02:28.905]                       if (inherits(cond, "message")) {
[17:02:28.905]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.905]                         if (muffled) 
[17:02:28.905]                           invokeRestart("muffleMessage")
[17:02:28.905]                       }
[17:02:28.905]                       else if (inherits(cond, "warning")) {
[17:02:28.905]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.905]                         if (muffled) 
[17:02:28.905]                           invokeRestart("muffleWarning")
[17:02:28.905]                       }
[17:02:28.905]                       else if (inherits(cond, "condition")) {
[17:02:28.905]                         if (!is.null(pattern)) {
[17:02:28.905]                           computeRestarts <- base::computeRestarts
[17:02:28.905]                           grepl <- base::grepl
[17:02:28.905]                           restarts <- computeRestarts(cond)
[17:02:28.905]                           for (restart in restarts) {
[17:02:28.905]                             name <- restart$name
[17:02:28.905]                             if (is.null(name)) 
[17:02:28.905]                               next
[17:02:28.905]                             if (!grepl(pattern, name)) 
[17:02:28.905]                               next
[17:02:28.905]                             invokeRestart(restart)
[17:02:28.905]                             muffled <- TRUE
[17:02:28.905]                             break
[17:02:28.905]                           }
[17:02:28.905]                         }
[17:02:28.905]                       }
[17:02:28.905]                       invisible(muffled)
[17:02:28.905]                     }
[17:02:28.905]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.905]                   }
[17:02:28.905]                 }
[17:02:28.905]             }
[17:02:28.905]         }))
[17:02:28.905]     }, error = function(ex) {
[17:02:28.905]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.905]                 ...future.rng), started = ...future.startTime, 
[17:02:28.905]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.905]             version = "1.8"), class = "FutureResult")
[17:02:28.905]     }, finally = {
[17:02:28.905]         if (!identical(...future.workdir, getwd())) 
[17:02:28.905]             setwd(...future.workdir)
[17:02:28.905]         {
[17:02:28.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.905]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.905]             }
[17:02:28.905]             base::options(...future.oldOptions)
[17:02:28.905]             if (.Platform$OS.type == "windows") {
[17:02:28.905]                 old_names <- names(...future.oldEnvVars)
[17:02:28.905]                 envs <- base::Sys.getenv()
[17:02:28.905]                 names <- names(envs)
[17:02:28.905]                 common <- intersect(names, old_names)
[17:02:28.905]                 added <- setdiff(names, old_names)
[17:02:28.905]                 removed <- setdiff(old_names, names)
[17:02:28.905]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.905]                   envs[common]]
[17:02:28.905]                 NAMES <- toupper(changed)
[17:02:28.905]                 args <- list()
[17:02:28.905]                 for (kk in seq_along(NAMES)) {
[17:02:28.905]                   name <- changed[[kk]]
[17:02:28.905]                   NAME <- NAMES[[kk]]
[17:02:28.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.905]                     next
[17:02:28.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.905]                 }
[17:02:28.905]                 NAMES <- toupper(added)
[17:02:28.905]                 for (kk in seq_along(NAMES)) {
[17:02:28.905]                   name <- added[[kk]]
[17:02:28.905]                   NAME <- NAMES[[kk]]
[17:02:28.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.905]                     next
[17:02:28.905]                   args[[name]] <- ""
[17:02:28.905]                 }
[17:02:28.905]                 NAMES <- toupper(removed)
[17:02:28.905]                 for (kk in seq_along(NAMES)) {
[17:02:28.905]                   name <- removed[[kk]]
[17:02:28.905]                   NAME <- NAMES[[kk]]
[17:02:28.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.905]                     next
[17:02:28.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.905]                 }
[17:02:28.905]                 if (length(args) > 0) 
[17:02:28.905]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.905]             }
[17:02:28.905]             else {
[17:02:28.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.905]             }
[17:02:28.905]             {
[17:02:28.905]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.905]                   0L) {
[17:02:28.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.905]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.905]                   base::options(opts)
[17:02:28.905]                 }
[17:02:28.905]                 {
[17:02:28.905]                   {
[17:02:28.905]                     NULL
[17:02:28.905]                     RNGkind("Mersenne-Twister")
[17:02:28.905]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.905]                       inherits = FALSE)
[17:02:28.905]                   }
[17:02:28.905]                   options(future.plan = NULL)
[17:02:28.905]                   if (is.na(NA_character_)) 
[17:02:28.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.905]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.905]                     .init = FALSE)
[17:02:28.905]                 }
[17:02:28.905]             }
[17:02:28.905]         }
[17:02:28.905]     })
[17:02:28.905]     if (TRUE) {
[17:02:28.905]         base::sink(type = "output", split = FALSE)
[17:02:28.905]         if (TRUE) {
[17:02:28.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.905]         }
[17:02:28.905]         else {
[17:02:28.905]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.905]         }
[17:02:28.905]         base::close(...future.stdout)
[17:02:28.905]         ...future.stdout <- NULL
[17:02:28.905]     }
[17:02:28.905]     ...future.result$conditions <- ...future.conditions
[17:02:28.905]     ...future.result$finished <- base::Sys.time()
[17:02:28.905]     ...future.result
[17:02:28.905] }
[17:02:28.907] plan(): Setting new future strategy stack:
[17:02:28.907] List of future strategies:
[17:02:28.907] 1. sequential:
[17:02:28.907]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.907]    - tweaked: FALSE
[17:02:28.907]    - call: NULL
[17:02:28.907] plan(): nbrOfWorkers() = 1
[17:02:28.908] plan(): Setting new future strategy stack:
[17:02:28.908] List of future strategies:
[17:02:28.908] 1. sequential:
[17:02:28.908]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.908]    - tweaked: FALSE
[17:02:28.908]    - call: plan(strategy)
[17:02:28.908] plan(): nbrOfWorkers() = 1
[17:02:28.908] SequentialFuture started (and completed)
[17:02:28.909] - Launch lazy future ... done
[17:02:28.909] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c749574450> 
Classes 'listenv', 'environment' <environment: 0x55c7493f2cd8> 
[17:02:28.912] resolved() for ‘SequentialFuture’ ...
[17:02:28.912] - state: ‘finished’
[17:02:28.912] - run: TRUE
[17:02:28.912] - result: ‘FutureResult’
[17:02:28.912] resolved() for ‘SequentialFuture’ ... done
[17:02:28.912] resolved() for ‘SequentialFuture’ ...
[17:02:28.912] - state: ‘finished’
[17:02:28.912] - run: TRUE
[17:02:28.912] - result: ‘FutureResult’
[17:02:28.912] resolved() for ‘SequentialFuture’ ... done
[17:02:28.913] resolved() for ‘SequentialFuture’ ...
[17:02:28.913] - state: ‘finished’
[17:02:28.913] - run: TRUE
[17:02:28.913] - result: ‘FutureResult’
[17:02:28.913] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:28.915] resolve() on list environment ...
[17:02:28.915]  recursive: 0
[17:02:28.916]  length: 6
[17:02:28.916]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:28.916] signalConditionsASAP(numeric, pos=1) ...
[17:02:28.916] - nx: 6
[17:02:28.916] - relay: TRUE
[17:02:28.916] - stdout: TRUE
[17:02:28.916] - signal: TRUE
[17:02:28.916] - resignal: FALSE
[17:02:28.916] - force: TRUE
[17:02:28.916] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.917] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.917]  - until=2
[17:02:28.917]  - relaying element #2
[17:02:28.917] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.917] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.917] signalConditionsASAP(NULL, pos=1) ... done
[17:02:28.917]  length: 5 (resolved future 1)
[17:02:28.917] resolved() for ‘SequentialFuture’ ...
[17:02:28.917] - state: ‘finished’
[17:02:28.917] - run: TRUE
[17:02:28.917] - result: ‘FutureResult’
[17:02:28.918] resolved() for ‘SequentialFuture’ ... done
[17:02:28.918] Future #2
[17:02:28.918] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:28.918] - nx: 6
[17:02:28.918] - relay: TRUE
[17:02:28.918] - stdout: TRUE
[17:02:28.918] - signal: TRUE
[17:02:28.918] - resignal: FALSE
[17:02:28.918] - force: TRUE
[17:02:28.918] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.918] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.919]  - until=2
[17:02:28.919]  - relaying element #2
[17:02:28.919] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.919] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.919] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:28.919]  length: 4 (resolved future 2)
[17:02:28.919] resolved() for ‘SequentialFuture’ ...
[17:02:28.919] - state: ‘finished’
[17:02:28.919] - run: TRUE
[17:02:28.920] - result: ‘FutureResult’
[17:02:28.920] resolved() for ‘SequentialFuture’ ... done
[17:02:28.920] Future #3
[17:02:28.920] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:28.920] - nx: 6
[17:02:28.920] - relay: TRUE
[17:02:28.920] - stdout: TRUE
[17:02:28.923] - signal: TRUE
[17:02:28.923] - resignal: FALSE
[17:02:28.923] - force: TRUE
[17:02:28.923] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.923] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.923]  - until=3
[17:02:28.923]  - relaying element #3
[17:02:28.923] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.923] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.924] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:28.924]  length: 3 (resolved future 3)
[17:02:28.924] resolved() for ‘SequentialFuture’ ...
[17:02:28.924] - state: ‘finished’
[17:02:28.924] - run: TRUE
[17:02:28.924] - result: ‘FutureResult’
[17:02:28.924] resolved() for ‘SequentialFuture’ ... done
[17:02:28.924] Future #4
[17:02:28.924] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:02:28.924] - nx: 6
[17:02:28.925] - relay: TRUE
[17:02:28.925] - stdout: TRUE
[17:02:28.925] - signal: TRUE
[17:02:28.925] - resignal: FALSE
[17:02:28.925] - force: TRUE
[17:02:28.925] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.925] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.925]  - until=4
[17:02:28.925]  - relaying element #4
[17:02:28.925] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.925] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.926] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:02:28.926]  length: 2 (resolved future 4)
[17:02:28.926] signalConditionsASAP(NULL, pos=5) ...
[17:02:28.926] - nx: 6
[17:02:28.926] - relay: TRUE
[17:02:28.926] - stdout: TRUE
[17:02:28.926] - signal: TRUE
[17:02:28.926] - resignal: FALSE
[17:02:28.926] - force: TRUE
[17:02:28.926] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.926] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.926]  - until=6
[17:02:28.927]  - relaying element #6
[17:02:28.927] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:28.927] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.927] signalConditionsASAP(NULL, pos=5) ... done
[17:02:28.927]  length: 1 (resolved future 5)
[17:02:28.927] signalConditionsASAP(numeric, pos=6) ...
[17:02:28.927] - nx: 6
[17:02:28.927] - relay: TRUE
[17:02:28.927] - stdout: TRUE
[17:02:28.927] - signal: TRUE
[17:02:28.927] - resignal: FALSE
[17:02:28.928] - force: TRUE
[17:02:28.928] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:28.928] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.928]  - until=6
[17:02:28.928] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.928] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.928] signalConditionsASAP(numeric, pos=6) ... done
[17:02:28.928]  length: 0 (resolved future 6)
[17:02:28.928] Relaying remaining futures
[17:02:28.928] signalConditionsASAP(NULL, pos=0) ...
[17:02:28.928] - nx: 6
[17:02:28.928] - relay: TRUE
[17:02:28.929] - stdout: TRUE
[17:02:28.929] - signal: TRUE
[17:02:28.929] - resignal: FALSE
[17:02:28.929] - force: TRUE
[17:02:28.929] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.929] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:28.929] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:28.929] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.929] signalConditionsASAP(NULL, pos=0) ... done
[17:02:28.929] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55c7497084d8> 
Dimensions: c(1, 6)
[17:02:28.930] getGlobalsAndPackages() ...
[17:02:28.930] Searching for globals...
[17:02:28.931] 
[17:02:28.931] Searching for globals ... DONE
[17:02:28.931] - globals: [0] <none>
[17:02:28.931] getGlobalsAndPackages() ... DONE
[17:02:28.931] run() for ‘Future’ ...
[17:02:28.931] - state: ‘created’
[17:02:28.931] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.932] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.932]   - Field: ‘label’
[17:02:28.932]   - Field: ‘local’
[17:02:28.932]   - Field: ‘owner’
[17:02:28.932]   - Field: ‘envir’
[17:02:28.932]   - Field: ‘packages’
[17:02:28.932]   - Field: ‘gc’
[17:02:28.932]   - Field: ‘conditions’
[17:02:28.933]   - Field: ‘expr’
[17:02:28.933]   - Field: ‘uuid’
[17:02:28.933]   - Field: ‘seed’
[17:02:28.933]   - Field: ‘version’
[17:02:28.933]   - Field: ‘result’
[17:02:28.933]   - Field: ‘asynchronous’
[17:02:28.933]   - Field: ‘calls’
[17:02:28.933]   - Field: ‘globals’
[17:02:28.933]   - Field: ‘stdout’
[17:02:28.933]   - Field: ‘earlySignal’
[17:02:28.933]   - Field: ‘lazy’
[17:02:28.934]   - Field: ‘state’
[17:02:28.934] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.934] - Launch lazy future ...
[17:02:28.934] Packages needed by the future expression (n = 0): <none>
[17:02:28.934] Packages needed by future strategies (n = 0): <none>
[17:02:28.934] {
[17:02:28.934]     {
[17:02:28.934]         {
[17:02:28.934]             ...future.startTime <- base::Sys.time()
[17:02:28.934]             {
[17:02:28.934]                 {
[17:02:28.934]                   {
[17:02:28.934]                     base::local({
[17:02:28.934]                       has_future <- base::requireNamespace("future", 
[17:02:28.934]                         quietly = TRUE)
[17:02:28.934]                       if (has_future) {
[17:02:28.934]                         ns <- base::getNamespace("future")
[17:02:28.934]                         version <- ns[[".package"]][["version"]]
[17:02:28.934]                         if (is.null(version)) 
[17:02:28.934]                           version <- utils::packageVersion("future")
[17:02:28.934]                       }
[17:02:28.934]                       else {
[17:02:28.934]                         version <- NULL
[17:02:28.934]                       }
[17:02:28.934]                       if (!has_future || version < "1.8.0") {
[17:02:28.934]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.934]                           "", base::R.version$version.string), 
[17:02:28.934]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.934]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.934]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.934]                             "release", "version")], collapse = " "), 
[17:02:28.934]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.934]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.934]                           info)
[17:02:28.934]                         info <- base::paste(info, collapse = "; ")
[17:02:28.934]                         if (!has_future) {
[17:02:28.934]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.934]                             info)
[17:02:28.934]                         }
[17:02:28.934]                         else {
[17:02:28.934]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.934]                             info, version)
[17:02:28.934]                         }
[17:02:28.934]                         base::stop(msg)
[17:02:28.934]                       }
[17:02:28.934]                     })
[17:02:28.934]                   }
[17:02:28.934]                   ...future.strategy.old <- future::plan("list")
[17:02:28.934]                   options(future.plan = NULL)
[17:02:28.934]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.934]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.934]                 }
[17:02:28.934]                 ...future.workdir <- getwd()
[17:02:28.934]             }
[17:02:28.934]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.934]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.934]         }
[17:02:28.934]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.934]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.934]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.934]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.934]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.934]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.934]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.934]             base::names(...future.oldOptions))
[17:02:28.934]     }
[17:02:28.934]     if (FALSE) {
[17:02:28.934]     }
[17:02:28.934]     else {
[17:02:28.934]         if (TRUE) {
[17:02:28.934]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.934]                 open = "w")
[17:02:28.934]         }
[17:02:28.934]         else {
[17:02:28.934]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.934]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.934]         }
[17:02:28.934]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.934]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.934]             base::sink(type = "output", split = FALSE)
[17:02:28.934]             base::close(...future.stdout)
[17:02:28.934]         }, add = TRUE)
[17:02:28.934]     }
[17:02:28.934]     ...future.frame <- base::sys.nframe()
[17:02:28.934]     ...future.conditions <- base::list()
[17:02:28.934]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.934]     if (FALSE) {
[17:02:28.934]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.934]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.934]     }
[17:02:28.934]     ...future.result <- base::tryCatch({
[17:02:28.934]         base::withCallingHandlers({
[17:02:28.934]             ...future.value <- base::withVisible(base::local(2))
[17:02:28.934]             future::FutureResult(value = ...future.value$value, 
[17:02:28.934]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.934]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.934]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.934]                     ...future.globalenv.names))
[17:02:28.934]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.934]         }, condition = base::local({
[17:02:28.934]             c <- base::c
[17:02:28.934]             inherits <- base::inherits
[17:02:28.934]             invokeRestart <- base::invokeRestart
[17:02:28.934]             length <- base::length
[17:02:28.934]             list <- base::list
[17:02:28.934]             seq.int <- base::seq.int
[17:02:28.934]             signalCondition <- base::signalCondition
[17:02:28.934]             sys.calls <- base::sys.calls
[17:02:28.934]             `[[` <- base::`[[`
[17:02:28.934]             `+` <- base::`+`
[17:02:28.934]             `<<-` <- base::`<<-`
[17:02:28.934]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.934]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.934]                   3L)]
[17:02:28.934]             }
[17:02:28.934]             function(cond) {
[17:02:28.934]                 is_error <- inherits(cond, "error")
[17:02:28.934]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.934]                   NULL)
[17:02:28.934]                 if (is_error) {
[17:02:28.934]                   sessionInformation <- function() {
[17:02:28.934]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.934]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.934]                       search = base::search(), system = base::Sys.info())
[17:02:28.934]                   }
[17:02:28.934]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.934]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.934]                     cond$call), session = sessionInformation(), 
[17:02:28.934]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.934]                   signalCondition(cond)
[17:02:28.934]                 }
[17:02:28.934]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.934]                 "immediateCondition"))) {
[17:02:28.934]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.934]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.934]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.934]                   if (TRUE && !signal) {
[17:02:28.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.934]                     {
[17:02:28.934]                       inherits <- base::inherits
[17:02:28.934]                       invokeRestart <- base::invokeRestart
[17:02:28.934]                       is.null <- base::is.null
[17:02:28.934]                       muffled <- FALSE
[17:02:28.934]                       if (inherits(cond, "message")) {
[17:02:28.934]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.934]                         if (muffled) 
[17:02:28.934]                           invokeRestart("muffleMessage")
[17:02:28.934]                       }
[17:02:28.934]                       else if (inherits(cond, "warning")) {
[17:02:28.934]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.934]                         if (muffled) 
[17:02:28.934]                           invokeRestart("muffleWarning")
[17:02:28.934]                       }
[17:02:28.934]                       else if (inherits(cond, "condition")) {
[17:02:28.934]                         if (!is.null(pattern)) {
[17:02:28.934]                           computeRestarts <- base::computeRestarts
[17:02:28.934]                           grepl <- base::grepl
[17:02:28.934]                           restarts <- computeRestarts(cond)
[17:02:28.934]                           for (restart in restarts) {
[17:02:28.934]                             name <- restart$name
[17:02:28.934]                             if (is.null(name)) 
[17:02:28.934]                               next
[17:02:28.934]                             if (!grepl(pattern, name)) 
[17:02:28.934]                               next
[17:02:28.934]                             invokeRestart(restart)
[17:02:28.934]                             muffled <- TRUE
[17:02:28.934]                             break
[17:02:28.934]                           }
[17:02:28.934]                         }
[17:02:28.934]                       }
[17:02:28.934]                       invisible(muffled)
[17:02:28.934]                     }
[17:02:28.934]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.934]                   }
[17:02:28.934]                 }
[17:02:28.934]                 else {
[17:02:28.934]                   if (TRUE) {
[17:02:28.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.934]                     {
[17:02:28.934]                       inherits <- base::inherits
[17:02:28.934]                       invokeRestart <- base::invokeRestart
[17:02:28.934]                       is.null <- base::is.null
[17:02:28.934]                       muffled <- FALSE
[17:02:28.934]                       if (inherits(cond, "message")) {
[17:02:28.934]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.934]                         if (muffled) 
[17:02:28.934]                           invokeRestart("muffleMessage")
[17:02:28.934]                       }
[17:02:28.934]                       else if (inherits(cond, "warning")) {
[17:02:28.934]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.934]                         if (muffled) 
[17:02:28.934]                           invokeRestart("muffleWarning")
[17:02:28.934]                       }
[17:02:28.934]                       else if (inherits(cond, "condition")) {
[17:02:28.934]                         if (!is.null(pattern)) {
[17:02:28.934]                           computeRestarts <- base::computeRestarts
[17:02:28.934]                           grepl <- base::grepl
[17:02:28.934]                           restarts <- computeRestarts(cond)
[17:02:28.934]                           for (restart in restarts) {
[17:02:28.934]                             name <- restart$name
[17:02:28.934]                             if (is.null(name)) 
[17:02:28.934]                               next
[17:02:28.934]                             if (!grepl(pattern, name)) 
[17:02:28.934]                               next
[17:02:28.934]                             invokeRestart(restart)
[17:02:28.934]                             muffled <- TRUE
[17:02:28.934]                             break
[17:02:28.934]                           }
[17:02:28.934]                         }
[17:02:28.934]                       }
[17:02:28.934]                       invisible(muffled)
[17:02:28.934]                     }
[17:02:28.934]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.934]                   }
[17:02:28.934]                 }
[17:02:28.934]             }
[17:02:28.934]         }))
[17:02:28.934]     }, error = function(ex) {
[17:02:28.934]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.934]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.934]                 ...future.rng), started = ...future.startTime, 
[17:02:28.934]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.934]             version = "1.8"), class = "FutureResult")
[17:02:28.934]     }, finally = {
[17:02:28.934]         if (!identical(...future.workdir, getwd())) 
[17:02:28.934]             setwd(...future.workdir)
[17:02:28.934]         {
[17:02:28.934]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.934]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.934]             }
[17:02:28.934]             base::options(...future.oldOptions)
[17:02:28.934]             if (.Platform$OS.type == "windows") {
[17:02:28.934]                 old_names <- names(...future.oldEnvVars)
[17:02:28.934]                 envs <- base::Sys.getenv()
[17:02:28.934]                 names <- names(envs)
[17:02:28.934]                 common <- intersect(names, old_names)
[17:02:28.934]                 added <- setdiff(names, old_names)
[17:02:28.934]                 removed <- setdiff(old_names, names)
[17:02:28.934]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.934]                   envs[common]]
[17:02:28.934]                 NAMES <- toupper(changed)
[17:02:28.934]                 args <- list()
[17:02:28.934]                 for (kk in seq_along(NAMES)) {
[17:02:28.934]                   name <- changed[[kk]]
[17:02:28.934]                   NAME <- NAMES[[kk]]
[17:02:28.934]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.934]                     next
[17:02:28.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.934]                 }
[17:02:28.934]                 NAMES <- toupper(added)
[17:02:28.934]                 for (kk in seq_along(NAMES)) {
[17:02:28.934]                   name <- added[[kk]]
[17:02:28.934]                   NAME <- NAMES[[kk]]
[17:02:28.934]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.934]                     next
[17:02:28.934]                   args[[name]] <- ""
[17:02:28.934]                 }
[17:02:28.934]                 NAMES <- toupper(removed)
[17:02:28.934]                 for (kk in seq_along(NAMES)) {
[17:02:28.934]                   name <- removed[[kk]]
[17:02:28.934]                   NAME <- NAMES[[kk]]
[17:02:28.934]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.934]                     next
[17:02:28.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.934]                 }
[17:02:28.934]                 if (length(args) > 0) 
[17:02:28.934]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.934]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.934]             }
[17:02:28.934]             else {
[17:02:28.934]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.934]             }
[17:02:28.934]             {
[17:02:28.934]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.934]                   0L) {
[17:02:28.934]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.934]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.934]                   base::options(opts)
[17:02:28.934]                 }
[17:02:28.934]                 {
[17:02:28.934]                   {
[17:02:28.934]                     NULL
[17:02:28.934]                     RNGkind("Mersenne-Twister")
[17:02:28.934]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.934]                       inherits = FALSE)
[17:02:28.934]                   }
[17:02:28.934]                   options(future.plan = NULL)
[17:02:28.934]                   if (is.na(NA_character_)) 
[17:02:28.934]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.934]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.934]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.934]                     .init = FALSE)
[17:02:28.934]                 }
[17:02:28.934]             }
[17:02:28.934]         }
[17:02:28.934]     })
[17:02:28.934]     if (TRUE) {
[17:02:28.934]         base::sink(type = "output", split = FALSE)
[17:02:28.934]         if (TRUE) {
[17:02:28.934]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.934]         }
[17:02:28.934]         else {
[17:02:28.934]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.934]         }
[17:02:28.934]         base::close(...future.stdout)
[17:02:28.934]         ...future.stdout <- NULL
[17:02:28.934]     }
[17:02:28.934]     ...future.result$conditions <- ...future.conditions
[17:02:28.934]     ...future.result$finished <- base::Sys.time()
[17:02:28.934]     ...future.result
[17:02:28.934] }
[17:02:28.936] plan(): Setting new future strategy stack:
[17:02:28.936] List of future strategies:
[17:02:28.936] 1. sequential:
[17:02:28.936]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.936]    - tweaked: FALSE
[17:02:28.936]    - call: NULL
[17:02:28.937] plan(): nbrOfWorkers() = 1
[17:02:28.938] plan(): Setting new future strategy stack:
[17:02:28.938] List of future strategies:
[17:02:28.938] 1. sequential:
[17:02:28.938]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.938]    - tweaked: FALSE
[17:02:28.938]    - call: plan(strategy)
[17:02:28.938] plan(): nbrOfWorkers() = 1
[17:02:28.938] SequentialFuture started (and completed)
[17:02:28.938] - Launch lazy future ... done
[17:02:28.938] run() for ‘SequentialFuture’ ... done
[17:02:28.939] getGlobalsAndPackages() ...
[17:02:28.939] Searching for globals...
[17:02:28.939] 
[17:02:28.939] Searching for globals ... DONE
[17:02:28.939] - globals: [0] <none>
[17:02:28.939] getGlobalsAndPackages() ... DONE
[17:02:28.940] run() for ‘Future’ ...
[17:02:28.940] - state: ‘created’
[17:02:28.940] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.940] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.940] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.940]   - Field: ‘label’
[17:02:28.940]   - Field: ‘local’
[17:02:28.940]   - Field: ‘owner’
[17:02:28.940]   - Field: ‘envir’
[17:02:28.941]   - Field: ‘packages’
[17:02:28.941]   - Field: ‘gc’
[17:02:28.941]   - Field: ‘conditions’
[17:02:28.941]   - Field: ‘expr’
[17:02:28.941]   - Field: ‘uuid’
[17:02:28.941]   - Field: ‘seed’
[17:02:28.941]   - Field: ‘version’
[17:02:28.941]   - Field: ‘result’
[17:02:28.941]   - Field: ‘asynchronous’
[17:02:28.941]   - Field: ‘calls’
[17:02:28.941]   - Field: ‘globals’
[17:02:28.942]   - Field: ‘stdout’
[17:02:28.942]   - Field: ‘earlySignal’
[17:02:28.942]   - Field: ‘lazy’
[17:02:28.942]   - Field: ‘state’
[17:02:28.942] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.942] - Launch lazy future ...
[17:02:28.942] Packages needed by the future expression (n = 0): <none>
[17:02:28.942] Packages needed by future strategies (n = 0): <none>
[17:02:28.943] {
[17:02:28.943]     {
[17:02:28.943]         {
[17:02:28.943]             ...future.startTime <- base::Sys.time()
[17:02:28.943]             {
[17:02:28.943]                 {
[17:02:28.943]                   {
[17:02:28.943]                     base::local({
[17:02:28.943]                       has_future <- base::requireNamespace("future", 
[17:02:28.943]                         quietly = TRUE)
[17:02:28.943]                       if (has_future) {
[17:02:28.943]                         ns <- base::getNamespace("future")
[17:02:28.943]                         version <- ns[[".package"]][["version"]]
[17:02:28.943]                         if (is.null(version)) 
[17:02:28.943]                           version <- utils::packageVersion("future")
[17:02:28.943]                       }
[17:02:28.943]                       else {
[17:02:28.943]                         version <- NULL
[17:02:28.943]                       }
[17:02:28.943]                       if (!has_future || version < "1.8.0") {
[17:02:28.943]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.943]                           "", base::R.version$version.string), 
[17:02:28.943]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.943]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.943]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.943]                             "release", "version")], collapse = " "), 
[17:02:28.943]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.943]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.943]                           info)
[17:02:28.943]                         info <- base::paste(info, collapse = "; ")
[17:02:28.943]                         if (!has_future) {
[17:02:28.943]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.943]                             info)
[17:02:28.943]                         }
[17:02:28.943]                         else {
[17:02:28.943]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.943]                             info, version)
[17:02:28.943]                         }
[17:02:28.943]                         base::stop(msg)
[17:02:28.943]                       }
[17:02:28.943]                     })
[17:02:28.943]                   }
[17:02:28.943]                   ...future.strategy.old <- future::plan("list")
[17:02:28.943]                   options(future.plan = NULL)
[17:02:28.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.943]                 }
[17:02:28.943]                 ...future.workdir <- getwd()
[17:02:28.943]             }
[17:02:28.943]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.943]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.943]         }
[17:02:28.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.943]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.943]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.943]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.943]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.943]             base::names(...future.oldOptions))
[17:02:28.943]     }
[17:02:28.943]     if (FALSE) {
[17:02:28.943]     }
[17:02:28.943]     else {
[17:02:28.943]         if (TRUE) {
[17:02:28.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.943]                 open = "w")
[17:02:28.943]         }
[17:02:28.943]         else {
[17:02:28.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.943]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.943]         }
[17:02:28.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.943]             base::sink(type = "output", split = FALSE)
[17:02:28.943]             base::close(...future.stdout)
[17:02:28.943]         }, add = TRUE)
[17:02:28.943]     }
[17:02:28.943]     ...future.frame <- base::sys.nframe()
[17:02:28.943]     ...future.conditions <- base::list()
[17:02:28.943]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.943]     if (FALSE) {
[17:02:28.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.943]     }
[17:02:28.943]     ...future.result <- base::tryCatch({
[17:02:28.943]         base::withCallingHandlers({
[17:02:28.943]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:28.943]             future::FutureResult(value = ...future.value$value, 
[17:02:28.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.943]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.943]                     ...future.globalenv.names))
[17:02:28.943]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.943]         }, condition = base::local({
[17:02:28.943]             c <- base::c
[17:02:28.943]             inherits <- base::inherits
[17:02:28.943]             invokeRestart <- base::invokeRestart
[17:02:28.943]             length <- base::length
[17:02:28.943]             list <- base::list
[17:02:28.943]             seq.int <- base::seq.int
[17:02:28.943]             signalCondition <- base::signalCondition
[17:02:28.943]             sys.calls <- base::sys.calls
[17:02:28.943]             `[[` <- base::`[[`
[17:02:28.943]             `+` <- base::`+`
[17:02:28.943]             `<<-` <- base::`<<-`
[17:02:28.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.943]                   3L)]
[17:02:28.943]             }
[17:02:28.943]             function(cond) {
[17:02:28.943]                 is_error <- inherits(cond, "error")
[17:02:28.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.943]                   NULL)
[17:02:28.943]                 if (is_error) {
[17:02:28.943]                   sessionInformation <- function() {
[17:02:28.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.943]                       search = base::search(), system = base::Sys.info())
[17:02:28.943]                   }
[17:02:28.943]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.943]                     cond$call), session = sessionInformation(), 
[17:02:28.943]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.943]                   signalCondition(cond)
[17:02:28.943]                 }
[17:02:28.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.943]                 "immediateCondition"))) {
[17:02:28.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.943]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.943]                   if (TRUE && !signal) {
[17:02:28.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.943]                     {
[17:02:28.943]                       inherits <- base::inherits
[17:02:28.943]                       invokeRestart <- base::invokeRestart
[17:02:28.943]                       is.null <- base::is.null
[17:02:28.943]                       muffled <- FALSE
[17:02:28.943]                       if (inherits(cond, "message")) {
[17:02:28.943]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.943]                         if (muffled) 
[17:02:28.943]                           invokeRestart("muffleMessage")
[17:02:28.943]                       }
[17:02:28.943]                       else if (inherits(cond, "warning")) {
[17:02:28.943]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.943]                         if (muffled) 
[17:02:28.943]                           invokeRestart("muffleWarning")
[17:02:28.943]                       }
[17:02:28.943]                       else if (inherits(cond, "condition")) {
[17:02:28.943]                         if (!is.null(pattern)) {
[17:02:28.943]                           computeRestarts <- base::computeRestarts
[17:02:28.943]                           grepl <- base::grepl
[17:02:28.943]                           restarts <- computeRestarts(cond)
[17:02:28.943]                           for (restart in restarts) {
[17:02:28.943]                             name <- restart$name
[17:02:28.943]                             if (is.null(name)) 
[17:02:28.943]                               next
[17:02:28.943]                             if (!grepl(pattern, name)) 
[17:02:28.943]                               next
[17:02:28.943]                             invokeRestart(restart)
[17:02:28.943]                             muffled <- TRUE
[17:02:28.943]                             break
[17:02:28.943]                           }
[17:02:28.943]                         }
[17:02:28.943]                       }
[17:02:28.943]                       invisible(muffled)
[17:02:28.943]                     }
[17:02:28.943]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.943]                   }
[17:02:28.943]                 }
[17:02:28.943]                 else {
[17:02:28.943]                   if (TRUE) {
[17:02:28.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.943]                     {
[17:02:28.943]                       inherits <- base::inherits
[17:02:28.943]                       invokeRestart <- base::invokeRestart
[17:02:28.943]                       is.null <- base::is.null
[17:02:28.943]                       muffled <- FALSE
[17:02:28.943]                       if (inherits(cond, "message")) {
[17:02:28.943]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.943]                         if (muffled) 
[17:02:28.943]                           invokeRestart("muffleMessage")
[17:02:28.943]                       }
[17:02:28.943]                       else if (inherits(cond, "warning")) {
[17:02:28.943]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.943]                         if (muffled) 
[17:02:28.943]                           invokeRestart("muffleWarning")
[17:02:28.943]                       }
[17:02:28.943]                       else if (inherits(cond, "condition")) {
[17:02:28.943]                         if (!is.null(pattern)) {
[17:02:28.943]                           computeRestarts <- base::computeRestarts
[17:02:28.943]                           grepl <- base::grepl
[17:02:28.943]                           restarts <- computeRestarts(cond)
[17:02:28.943]                           for (restart in restarts) {
[17:02:28.943]                             name <- restart$name
[17:02:28.943]                             if (is.null(name)) 
[17:02:28.943]                               next
[17:02:28.943]                             if (!grepl(pattern, name)) 
[17:02:28.943]                               next
[17:02:28.943]                             invokeRestart(restart)
[17:02:28.943]                             muffled <- TRUE
[17:02:28.943]                             break
[17:02:28.943]                           }
[17:02:28.943]                         }
[17:02:28.943]                       }
[17:02:28.943]                       invisible(muffled)
[17:02:28.943]                     }
[17:02:28.943]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.943]                   }
[17:02:28.943]                 }
[17:02:28.943]             }
[17:02:28.943]         }))
[17:02:28.943]     }, error = function(ex) {
[17:02:28.943]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.943]                 ...future.rng), started = ...future.startTime, 
[17:02:28.943]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.943]             version = "1.8"), class = "FutureResult")
[17:02:28.943]     }, finally = {
[17:02:28.943]         if (!identical(...future.workdir, getwd())) 
[17:02:28.943]             setwd(...future.workdir)
[17:02:28.943]         {
[17:02:28.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.943]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.943]             }
[17:02:28.943]             base::options(...future.oldOptions)
[17:02:28.943]             if (.Platform$OS.type == "windows") {
[17:02:28.943]                 old_names <- names(...future.oldEnvVars)
[17:02:28.943]                 envs <- base::Sys.getenv()
[17:02:28.943]                 names <- names(envs)
[17:02:28.943]                 common <- intersect(names, old_names)
[17:02:28.943]                 added <- setdiff(names, old_names)
[17:02:28.943]                 removed <- setdiff(old_names, names)
[17:02:28.943]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.943]                   envs[common]]
[17:02:28.943]                 NAMES <- toupper(changed)
[17:02:28.943]                 args <- list()
[17:02:28.943]                 for (kk in seq_along(NAMES)) {
[17:02:28.943]                   name <- changed[[kk]]
[17:02:28.943]                   NAME <- NAMES[[kk]]
[17:02:28.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.943]                     next
[17:02:28.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.943]                 }
[17:02:28.943]                 NAMES <- toupper(added)
[17:02:28.943]                 for (kk in seq_along(NAMES)) {
[17:02:28.943]                   name <- added[[kk]]
[17:02:28.943]                   NAME <- NAMES[[kk]]
[17:02:28.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.943]                     next
[17:02:28.943]                   args[[name]] <- ""
[17:02:28.943]                 }
[17:02:28.943]                 NAMES <- toupper(removed)
[17:02:28.943]                 for (kk in seq_along(NAMES)) {
[17:02:28.943]                   name <- removed[[kk]]
[17:02:28.943]                   NAME <- NAMES[[kk]]
[17:02:28.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.943]                     next
[17:02:28.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.943]                 }
[17:02:28.943]                 if (length(args) > 0) 
[17:02:28.943]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.943]             }
[17:02:28.943]             else {
[17:02:28.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.943]             }
[17:02:28.943]             {
[17:02:28.943]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.943]                   0L) {
[17:02:28.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.943]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.943]                   base::options(opts)
[17:02:28.943]                 }
[17:02:28.943]                 {
[17:02:28.943]                   {
[17:02:28.943]                     NULL
[17:02:28.943]                     RNGkind("Mersenne-Twister")
[17:02:28.943]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.943]                       inherits = FALSE)
[17:02:28.943]                   }
[17:02:28.943]                   options(future.plan = NULL)
[17:02:28.943]                   if (is.na(NA_character_)) 
[17:02:28.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.943]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.943]                     .init = FALSE)
[17:02:28.943]                 }
[17:02:28.943]             }
[17:02:28.943]         }
[17:02:28.943]     })
[17:02:28.943]     if (TRUE) {
[17:02:28.943]         base::sink(type = "output", split = FALSE)
[17:02:28.943]         if (TRUE) {
[17:02:28.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.943]         }
[17:02:28.943]         else {
[17:02:28.943]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.943]         }
[17:02:28.943]         base::close(...future.stdout)
[17:02:28.943]         ...future.stdout <- NULL
[17:02:28.943]     }
[17:02:28.943]     ...future.result$conditions <- ...future.conditions
[17:02:28.943]     ...future.result$finished <- base::Sys.time()
[17:02:28.943]     ...future.result
[17:02:28.943] }
[17:02:28.944] plan(): Setting new future strategy stack:
[17:02:28.944] List of future strategies:
[17:02:28.944] 1. sequential:
[17:02:28.944]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.944]    - tweaked: FALSE
[17:02:28.944]    - call: NULL
[17:02:28.945] plan(): nbrOfWorkers() = 1
[17:02:28.946] plan(): Setting new future strategy stack:
[17:02:28.946] List of future strategies:
[17:02:28.946] 1. sequential:
[17:02:28.946]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.946]    - tweaked: FALSE
[17:02:28.946]    - call: plan(strategy)
[17:02:28.946] plan(): nbrOfWorkers() = 1
[17:02:28.946] SequentialFuture started (and completed)
[17:02:28.946] - Launch lazy future ... done
[17:02:28.946] run() for ‘SequentialFuture’ ... done
[17:02:28.947] getGlobalsAndPackages() ...
[17:02:28.947] Searching for globals...
[17:02:28.947] - globals found: [1] ‘{’
[17:02:28.948] Searching for globals ... DONE
[17:02:28.948] Resolving globals: FALSE
[17:02:28.948] 
[17:02:28.948] 
[17:02:28.948] getGlobalsAndPackages() ... DONE
[17:02:28.948] run() for ‘Future’ ...
[17:02:28.948] - state: ‘created’
[17:02:28.951] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:28.951] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:28.951] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:28.951]   - Field: ‘label’
[17:02:28.951]   - Field: ‘local’
[17:02:28.951]   - Field: ‘owner’
[17:02:28.951]   - Field: ‘envir’
[17:02:28.951]   - Field: ‘packages’
[17:02:28.952]   - Field: ‘gc’
[17:02:28.952]   - Field: ‘conditions’
[17:02:28.952]   - Field: ‘expr’
[17:02:28.952]   - Field: ‘uuid’
[17:02:28.952]   - Field: ‘seed’
[17:02:28.952]   - Field: ‘version’
[17:02:28.952]   - Field: ‘result’
[17:02:28.952]   - Field: ‘asynchronous’
[17:02:28.952]   - Field: ‘calls’
[17:02:28.952]   - Field: ‘globals’
[17:02:28.952]   - Field: ‘stdout’
[17:02:28.953]   - Field: ‘earlySignal’
[17:02:28.953]   - Field: ‘lazy’
[17:02:28.953]   - Field: ‘state’
[17:02:28.953] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:28.953] - Launch lazy future ...
[17:02:28.953] Packages needed by the future expression (n = 0): <none>
[17:02:28.953] Packages needed by future strategies (n = 0): <none>
[17:02:28.954] {
[17:02:28.954]     {
[17:02:28.954]         {
[17:02:28.954]             ...future.startTime <- base::Sys.time()
[17:02:28.954]             {
[17:02:28.954]                 {
[17:02:28.954]                   {
[17:02:28.954]                     base::local({
[17:02:28.954]                       has_future <- base::requireNamespace("future", 
[17:02:28.954]                         quietly = TRUE)
[17:02:28.954]                       if (has_future) {
[17:02:28.954]                         ns <- base::getNamespace("future")
[17:02:28.954]                         version <- ns[[".package"]][["version"]]
[17:02:28.954]                         if (is.null(version)) 
[17:02:28.954]                           version <- utils::packageVersion("future")
[17:02:28.954]                       }
[17:02:28.954]                       else {
[17:02:28.954]                         version <- NULL
[17:02:28.954]                       }
[17:02:28.954]                       if (!has_future || version < "1.8.0") {
[17:02:28.954]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:28.954]                           "", base::R.version$version.string), 
[17:02:28.954]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:28.954]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:28.954]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:28.954]                             "release", "version")], collapse = " "), 
[17:02:28.954]                           hostname = base::Sys.info()[["nodename"]])
[17:02:28.954]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:28.954]                           info)
[17:02:28.954]                         info <- base::paste(info, collapse = "; ")
[17:02:28.954]                         if (!has_future) {
[17:02:28.954]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:28.954]                             info)
[17:02:28.954]                         }
[17:02:28.954]                         else {
[17:02:28.954]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:28.954]                             info, version)
[17:02:28.954]                         }
[17:02:28.954]                         base::stop(msg)
[17:02:28.954]                       }
[17:02:28.954]                     })
[17:02:28.954]                   }
[17:02:28.954]                   ...future.strategy.old <- future::plan("list")
[17:02:28.954]                   options(future.plan = NULL)
[17:02:28.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:28.954]                 }
[17:02:28.954]                 ...future.workdir <- getwd()
[17:02:28.954]             }
[17:02:28.954]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:28.954]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:28.954]         }
[17:02:28.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:28.954]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:28.954]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:28.954]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:28.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:28.954]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:28.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:28.954]             base::names(...future.oldOptions))
[17:02:28.954]     }
[17:02:28.954]     if (FALSE) {
[17:02:28.954]     }
[17:02:28.954]     else {
[17:02:28.954]         if (TRUE) {
[17:02:28.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:28.954]                 open = "w")
[17:02:28.954]         }
[17:02:28.954]         else {
[17:02:28.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:28.954]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:28.954]         }
[17:02:28.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:28.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:28.954]             base::sink(type = "output", split = FALSE)
[17:02:28.954]             base::close(...future.stdout)
[17:02:28.954]         }, add = TRUE)
[17:02:28.954]     }
[17:02:28.954]     ...future.frame <- base::sys.nframe()
[17:02:28.954]     ...future.conditions <- base::list()
[17:02:28.954]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:28.954]     if (FALSE) {
[17:02:28.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:28.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:28.954]     }
[17:02:28.954]     ...future.result <- base::tryCatch({
[17:02:28.954]         base::withCallingHandlers({
[17:02:28.954]             ...future.value <- base::withVisible(base::local({
[17:02:28.954]                 4
[17:02:28.954]             }))
[17:02:28.954]             future::FutureResult(value = ...future.value$value, 
[17:02:28.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.954]                   ...future.rng), globalenv = if (FALSE) 
[17:02:28.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:28.954]                     ...future.globalenv.names))
[17:02:28.954]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:28.954]         }, condition = base::local({
[17:02:28.954]             c <- base::c
[17:02:28.954]             inherits <- base::inherits
[17:02:28.954]             invokeRestart <- base::invokeRestart
[17:02:28.954]             length <- base::length
[17:02:28.954]             list <- base::list
[17:02:28.954]             seq.int <- base::seq.int
[17:02:28.954]             signalCondition <- base::signalCondition
[17:02:28.954]             sys.calls <- base::sys.calls
[17:02:28.954]             `[[` <- base::`[[`
[17:02:28.954]             `+` <- base::`+`
[17:02:28.954]             `<<-` <- base::`<<-`
[17:02:28.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:28.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:28.954]                   3L)]
[17:02:28.954]             }
[17:02:28.954]             function(cond) {
[17:02:28.954]                 is_error <- inherits(cond, "error")
[17:02:28.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:28.954]                   NULL)
[17:02:28.954]                 if (is_error) {
[17:02:28.954]                   sessionInformation <- function() {
[17:02:28.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:28.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:28.954]                       search = base::search(), system = base::Sys.info())
[17:02:28.954]                   }
[17:02:28.954]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:28.954]                     cond$call), session = sessionInformation(), 
[17:02:28.954]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:28.954]                   signalCondition(cond)
[17:02:28.954]                 }
[17:02:28.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:28.954]                 "immediateCondition"))) {
[17:02:28.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:28.954]                   ...future.conditions[[length(...future.conditions) + 
[17:02:28.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:28.954]                   if (TRUE && !signal) {
[17:02:28.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.954]                     {
[17:02:28.954]                       inherits <- base::inherits
[17:02:28.954]                       invokeRestart <- base::invokeRestart
[17:02:28.954]                       is.null <- base::is.null
[17:02:28.954]                       muffled <- FALSE
[17:02:28.954]                       if (inherits(cond, "message")) {
[17:02:28.954]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.954]                         if (muffled) 
[17:02:28.954]                           invokeRestart("muffleMessage")
[17:02:28.954]                       }
[17:02:28.954]                       else if (inherits(cond, "warning")) {
[17:02:28.954]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.954]                         if (muffled) 
[17:02:28.954]                           invokeRestart("muffleWarning")
[17:02:28.954]                       }
[17:02:28.954]                       else if (inherits(cond, "condition")) {
[17:02:28.954]                         if (!is.null(pattern)) {
[17:02:28.954]                           computeRestarts <- base::computeRestarts
[17:02:28.954]                           grepl <- base::grepl
[17:02:28.954]                           restarts <- computeRestarts(cond)
[17:02:28.954]                           for (restart in restarts) {
[17:02:28.954]                             name <- restart$name
[17:02:28.954]                             if (is.null(name)) 
[17:02:28.954]                               next
[17:02:28.954]                             if (!grepl(pattern, name)) 
[17:02:28.954]                               next
[17:02:28.954]                             invokeRestart(restart)
[17:02:28.954]                             muffled <- TRUE
[17:02:28.954]                             break
[17:02:28.954]                           }
[17:02:28.954]                         }
[17:02:28.954]                       }
[17:02:28.954]                       invisible(muffled)
[17:02:28.954]                     }
[17:02:28.954]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.954]                   }
[17:02:28.954]                 }
[17:02:28.954]                 else {
[17:02:28.954]                   if (TRUE) {
[17:02:28.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:28.954]                     {
[17:02:28.954]                       inherits <- base::inherits
[17:02:28.954]                       invokeRestart <- base::invokeRestart
[17:02:28.954]                       is.null <- base::is.null
[17:02:28.954]                       muffled <- FALSE
[17:02:28.954]                       if (inherits(cond, "message")) {
[17:02:28.954]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:28.954]                         if (muffled) 
[17:02:28.954]                           invokeRestart("muffleMessage")
[17:02:28.954]                       }
[17:02:28.954]                       else if (inherits(cond, "warning")) {
[17:02:28.954]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:28.954]                         if (muffled) 
[17:02:28.954]                           invokeRestart("muffleWarning")
[17:02:28.954]                       }
[17:02:28.954]                       else if (inherits(cond, "condition")) {
[17:02:28.954]                         if (!is.null(pattern)) {
[17:02:28.954]                           computeRestarts <- base::computeRestarts
[17:02:28.954]                           grepl <- base::grepl
[17:02:28.954]                           restarts <- computeRestarts(cond)
[17:02:28.954]                           for (restart in restarts) {
[17:02:28.954]                             name <- restart$name
[17:02:28.954]                             if (is.null(name)) 
[17:02:28.954]                               next
[17:02:28.954]                             if (!grepl(pattern, name)) 
[17:02:28.954]                               next
[17:02:28.954]                             invokeRestart(restart)
[17:02:28.954]                             muffled <- TRUE
[17:02:28.954]                             break
[17:02:28.954]                           }
[17:02:28.954]                         }
[17:02:28.954]                       }
[17:02:28.954]                       invisible(muffled)
[17:02:28.954]                     }
[17:02:28.954]                     muffleCondition(cond, pattern = "^muffle")
[17:02:28.954]                   }
[17:02:28.954]                 }
[17:02:28.954]             }
[17:02:28.954]         }))
[17:02:28.954]     }, error = function(ex) {
[17:02:28.954]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:28.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:28.954]                 ...future.rng), started = ...future.startTime, 
[17:02:28.954]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:28.954]             version = "1.8"), class = "FutureResult")
[17:02:28.954]     }, finally = {
[17:02:28.954]         if (!identical(...future.workdir, getwd())) 
[17:02:28.954]             setwd(...future.workdir)
[17:02:28.954]         {
[17:02:28.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:28.954]                 ...future.oldOptions$nwarnings <- NULL
[17:02:28.954]             }
[17:02:28.954]             base::options(...future.oldOptions)
[17:02:28.954]             if (.Platform$OS.type == "windows") {
[17:02:28.954]                 old_names <- names(...future.oldEnvVars)
[17:02:28.954]                 envs <- base::Sys.getenv()
[17:02:28.954]                 names <- names(envs)
[17:02:28.954]                 common <- intersect(names, old_names)
[17:02:28.954]                 added <- setdiff(names, old_names)
[17:02:28.954]                 removed <- setdiff(old_names, names)
[17:02:28.954]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:28.954]                   envs[common]]
[17:02:28.954]                 NAMES <- toupper(changed)
[17:02:28.954]                 args <- list()
[17:02:28.954]                 for (kk in seq_along(NAMES)) {
[17:02:28.954]                   name <- changed[[kk]]
[17:02:28.954]                   NAME <- NAMES[[kk]]
[17:02:28.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.954]                     next
[17:02:28.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.954]                 }
[17:02:28.954]                 NAMES <- toupper(added)
[17:02:28.954]                 for (kk in seq_along(NAMES)) {
[17:02:28.954]                   name <- added[[kk]]
[17:02:28.954]                   NAME <- NAMES[[kk]]
[17:02:28.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.954]                     next
[17:02:28.954]                   args[[name]] <- ""
[17:02:28.954]                 }
[17:02:28.954]                 NAMES <- toupper(removed)
[17:02:28.954]                 for (kk in seq_along(NAMES)) {
[17:02:28.954]                   name <- removed[[kk]]
[17:02:28.954]                   NAME <- NAMES[[kk]]
[17:02:28.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:28.954]                     next
[17:02:28.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:28.954]                 }
[17:02:28.954]                 if (length(args) > 0) 
[17:02:28.954]                   base::do.call(base::Sys.setenv, args = args)
[17:02:28.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:28.954]             }
[17:02:28.954]             else {
[17:02:28.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:28.954]             }
[17:02:28.954]             {
[17:02:28.954]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:28.954]                   0L) {
[17:02:28.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:28.954]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:28.954]                   base::options(opts)
[17:02:28.954]                 }
[17:02:28.954]                 {
[17:02:28.954]                   {
[17:02:28.954]                     NULL
[17:02:28.954]                     RNGkind("Mersenne-Twister")
[17:02:28.954]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:28.954]                       inherits = FALSE)
[17:02:28.954]                   }
[17:02:28.954]                   options(future.plan = NULL)
[17:02:28.954]                   if (is.na(NA_character_)) 
[17:02:28.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:28.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:28.954]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:28.954]                     .init = FALSE)
[17:02:28.954]                 }
[17:02:28.954]             }
[17:02:28.954]         }
[17:02:28.954]     })
[17:02:28.954]     if (TRUE) {
[17:02:28.954]         base::sink(type = "output", split = FALSE)
[17:02:28.954]         if (TRUE) {
[17:02:28.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:28.954]         }
[17:02:28.954]         else {
[17:02:28.954]             ...future.result["stdout"] <- base::list(NULL)
[17:02:28.954]         }
[17:02:28.954]         base::close(...future.stdout)
[17:02:28.954]         ...future.stdout <- NULL
[17:02:28.954]     }
[17:02:28.954]     ...future.result$conditions <- ...future.conditions
[17:02:28.954]     ...future.result$finished <- base::Sys.time()
[17:02:28.954]     ...future.result
[17:02:28.954] }
[17:02:28.955] plan(): Setting new future strategy stack:
[17:02:28.955] List of future strategies:
[17:02:28.955] 1. sequential:
[17:02:28.955]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.955]    - tweaked: FALSE
[17:02:28.955]    - call: NULL
[17:02:28.956] plan(): nbrOfWorkers() = 1
[17:02:28.956] plan(): Setting new future strategy stack:
[17:02:28.957] List of future strategies:
[17:02:28.957] 1. sequential:
[17:02:28.957]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:28.957]    - tweaked: FALSE
[17:02:28.957]    - call: plan(strategy)
[17:02:28.957] plan(): nbrOfWorkers() = 1
[17:02:28.957] SequentialFuture started (and completed)
[17:02:28.957] - Launch lazy future ... done
[17:02:28.957] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c748f518d0> 
Classes 'listenv', 'environment' <environment: 0x55c747e1b6c8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:02:28.961] resolved() for ‘SequentialFuture’ ...
[17:02:28.961] - state: ‘finished’
[17:02:28.961] - run: TRUE
[17:02:28.961] - result: ‘FutureResult’
[17:02:28.961] resolved() for ‘SequentialFuture’ ... done
[17:02:28.961] resolved() for ‘SequentialFuture’ ...
[17:02:28.962] - state: ‘finished’
[17:02:28.962] - run: TRUE
[17:02:28.962] - result: ‘FutureResult’
[17:02:28.962] resolved() for ‘SequentialFuture’ ... done
[17:02:28.962] resolved() for ‘SequentialFuture’ ...
[17:02:28.962] - state: ‘finished’
[17:02:28.962] - run: TRUE
[17:02:28.962] - result: ‘FutureResult’
[17:02:28.962] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:28.964] resolve() on list environment ...
[17:02:28.964]  recursive: 0
[17:02:28.965]  length: 6
[17:02:28.965]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:28.966] signalConditionsASAP(numeric, pos=1) ...
[17:02:28.966] - nx: 6
[17:02:28.966] - relay: TRUE
[17:02:28.966] - stdout: TRUE
[17:02:28.966] - signal: TRUE
[17:02:28.966] - resignal: FALSE
[17:02:28.966] - force: TRUE
[17:02:28.966] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.966] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.966]  - until=2
[17:02:28.966]  - relaying element #2
[17:02:28.966] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.967] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.967] signalConditionsASAP(NULL, pos=1) ... done
[17:02:28.967]  length: 5 (resolved future 1)
[17:02:28.967] resolved() for ‘SequentialFuture’ ...
[17:02:28.967] - state: ‘finished’
[17:02:28.967] - run: TRUE
[17:02:28.967] - result: ‘FutureResult’
[17:02:28.967] resolved() for ‘SequentialFuture’ ... done
[17:02:28.967] Future #2
[17:02:28.968] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:28.968] - nx: 6
[17:02:28.968] - relay: TRUE
[17:02:28.968] - stdout: TRUE
[17:02:28.968] - signal: TRUE
[17:02:28.968] - resignal: FALSE
[17:02:28.968] - force: TRUE
[17:02:28.968] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.968] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:28.968]  - until=2
[17:02:28.968]  - relaying element #2
[17:02:28.968] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.969] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.969] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:28.969]  length: 4 (resolved future 2)
[17:02:28.969] resolved() for ‘SequentialFuture’ ...
[17:02:28.969] - state: ‘finished’
[17:02:28.969] - run: TRUE
[17:02:28.969] - result: ‘FutureResult’
[17:02:28.969] resolved() for ‘SequentialFuture’ ... done
[17:02:28.969] Future #3
[17:02:28.969] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:28.970] - nx: 6
[17:02:28.970] - relay: TRUE
[17:02:28.970] - stdout: TRUE
[17:02:28.970] - signal: TRUE
[17:02:28.970] - resignal: FALSE
[17:02:28.970] - force: TRUE
[17:02:28.970] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.970] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:28.970]  - until=3
[17:02:28.970]  - relaying element #3
[17:02:28.970] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.971] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.971] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:28.971]  length: 3 (resolved future 3)
[17:02:28.971] resolved() for ‘SequentialFuture’ ...
[17:02:28.971] - state: ‘finished’
[17:02:28.971] - run: TRUE
[17:02:28.971] - result: ‘FutureResult’
[17:02:28.971] resolved() for ‘SequentialFuture’ ... done
[17:02:28.971] Future #4
[17:02:28.971] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:02:28.971] - nx: 6
[17:02:28.972] - relay: TRUE
[17:02:28.972] - stdout: TRUE
[17:02:28.972] - signal: TRUE
[17:02:28.972] - resignal: FALSE
[17:02:28.972] - force: TRUE
[17:02:28.972] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.972] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:28.972]  - until=4
[17:02:28.972]  - relaying element #4
[17:02:28.972] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.972] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.973] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:02:28.973]  length: 2 (resolved future 4)
[17:02:28.973] signalConditionsASAP(NULL, pos=5) ...
[17:02:28.973] - nx: 6
[17:02:28.973] - relay: TRUE
[17:02:28.973] - stdout: TRUE
[17:02:28.973] - signal: TRUE
[17:02:28.973] - resignal: FALSE
[17:02:28.973] - force: TRUE
[17:02:28.999] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.999] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:28.999]  - until=6
[17:02:28.999]  - relaying element #6
[17:02:29.000] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.000] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.000] signalConditionsASAP(NULL, pos=5) ... done
[17:02:29.000]  length: 1 (resolved future 5)
[17:02:29.000] signalConditionsASAP(numeric, pos=6) ...
[17:02:29.000] - nx: 6
[17:02:29.000] - relay: TRUE
[17:02:29.000] - stdout: TRUE
[17:02:29.000] - signal: TRUE
[17:02:29.000] - resignal: FALSE
[17:02:29.001] - force: TRUE
[17:02:29.001] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.001] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.001]  - until=6
[17:02:29.001] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.001] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.001] signalConditionsASAP(numeric, pos=6) ... done
[17:02:29.001]  length: 0 (resolved future 6)
[17:02:29.001] Relaying remaining futures
[17:02:29.001] signalConditionsASAP(NULL, pos=0) ...
[17:02:29.001] - nx: 6
[17:02:29.002] - relay: TRUE
[17:02:29.002] - stdout: TRUE
[17:02:29.002] - signal: TRUE
[17:02:29.002] - resignal: FALSE
[17:02:29.002] - force: TRUE
[17:02:29.002] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.002] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:29.002] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.002] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.002] signalConditionsASAP(NULL, pos=0) ... done
[17:02:29.002] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55c749436538> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:02:29.004] getGlobalsAndPackages() ...
[17:02:29.004] Searching for globals...
[17:02:29.005] 
[17:02:29.005] Searching for globals ... DONE
[17:02:29.005] - globals: [0] <none>
[17:02:29.005] getGlobalsAndPackages() ... DONE
[17:02:29.005] run() for ‘Future’ ...
[17:02:29.005] - state: ‘created’
[17:02:29.005] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:29.006] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:29.006] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:29.006]   - Field: ‘label’
[17:02:29.006]   - Field: ‘local’
[17:02:29.006]   - Field: ‘owner’
[17:02:29.006]   - Field: ‘envir’
[17:02:29.006]   - Field: ‘packages’
[17:02:29.006]   - Field: ‘gc’
[17:02:29.006]   - Field: ‘conditions’
[17:02:29.007]   - Field: ‘expr’
[17:02:29.007]   - Field: ‘uuid’
[17:02:29.007]   - Field: ‘seed’
[17:02:29.007]   - Field: ‘version’
[17:02:29.007]   - Field: ‘result’
[17:02:29.007]   - Field: ‘asynchronous’
[17:02:29.007]   - Field: ‘calls’
[17:02:29.007]   - Field: ‘globals’
[17:02:29.007]   - Field: ‘stdout’
[17:02:29.007]   - Field: ‘earlySignal’
[17:02:29.007]   - Field: ‘lazy’
[17:02:29.008]   - Field: ‘state’
[17:02:29.008] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:29.008] - Launch lazy future ...
[17:02:29.008] Packages needed by the future expression (n = 0): <none>
[17:02:29.008] Packages needed by future strategies (n = 0): <none>
[17:02:29.008] {
[17:02:29.008]     {
[17:02:29.008]         {
[17:02:29.008]             ...future.startTime <- base::Sys.time()
[17:02:29.008]             {
[17:02:29.008]                 {
[17:02:29.008]                   {
[17:02:29.008]                     base::local({
[17:02:29.008]                       has_future <- base::requireNamespace("future", 
[17:02:29.008]                         quietly = TRUE)
[17:02:29.008]                       if (has_future) {
[17:02:29.008]                         ns <- base::getNamespace("future")
[17:02:29.008]                         version <- ns[[".package"]][["version"]]
[17:02:29.008]                         if (is.null(version)) 
[17:02:29.008]                           version <- utils::packageVersion("future")
[17:02:29.008]                       }
[17:02:29.008]                       else {
[17:02:29.008]                         version <- NULL
[17:02:29.008]                       }
[17:02:29.008]                       if (!has_future || version < "1.8.0") {
[17:02:29.008]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.008]                           "", base::R.version$version.string), 
[17:02:29.008]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:29.008]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.008]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.008]                             "release", "version")], collapse = " "), 
[17:02:29.008]                           hostname = base::Sys.info()[["nodename"]])
[17:02:29.008]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.008]                           info)
[17:02:29.008]                         info <- base::paste(info, collapse = "; ")
[17:02:29.008]                         if (!has_future) {
[17:02:29.008]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.008]                             info)
[17:02:29.008]                         }
[17:02:29.008]                         else {
[17:02:29.008]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.008]                             info, version)
[17:02:29.008]                         }
[17:02:29.008]                         base::stop(msg)
[17:02:29.008]                       }
[17:02:29.008]                     })
[17:02:29.008]                   }
[17:02:29.008]                   ...future.strategy.old <- future::plan("list")
[17:02:29.008]                   options(future.plan = NULL)
[17:02:29.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.008]                 }
[17:02:29.008]                 ...future.workdir <- getwd()
[17:02:29.008]             }
[17:02:29.008]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.008]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.008]         }
[17:02:29.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.008]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.008]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.008]             base::names(...future.oldOptions))
[17:02:29.008]     }
[17:02:29.008]     if (FALSE) {
[17:02:29.008]     }
[17:02:29.008]     else {
[17:02:29.008]         if (TRUE) {
[17:02:29.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.008]                 open = "w")
[17:02:29.008]         }
[17:02:29.008]         else {
[17:02:29.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.008]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.008]         }
[17:02:29.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.008]             base::sink(type = "output", split = FALSE)
[17:02:29.008]             base::close(...future.stdout)
[17:02:29.008]         }, add = TRUE)
[17:02:29.008]     }
[17:02:29.008]     ...future.frame <- base::sys.nframe()
[17:02:29.008]     ...future.conditions <- base::list()
[17:02:29.008]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.008]     if (FALSE) {
[17:02:29.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.008]     }
[17:02:29.008]     ...future.result <- base::tryCatch({
[17:02:29.008]         base::withCallingHandlers({
[17:02:29.008]             ...future.value <- base::withVisible(base::local(2))
[17:02:29.008]             future::FutureResult(value = ...future.value$value, 
[17:02:29.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.008]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.008]                     ...future.globalenv.names))
[17:02:29.008]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.008]         }, condition = base::local({
[17:02:29.008]             c <- base::c
[17:02:29.008]             inherits <- base::inherits
[17:02:29.008]             invokeRestart <- base::invokeRestart
[17:02:29.008]             length <- base::length
[17:02:29.008]             list <- base::list
[17:02:29.008]             seq.int <- base::seq.int
[17:02:29.008]             signalCondition <- base::signalCondition
[17:02:29.008]             sys.calls <- base::sys.calls
[17:02:29.008]             `[[` <- base::`[[`
[17:02:29.008]             `+` <- base::`+`
[17:02:29.008]             `<<-` <- base::`<<-`
[17:02:29.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.008]                   3L)]
[17:02:29.008]             }
[17:02:29.008]             function(cond) {
[17:02:29.008]                 is_error <- inherits(cond, "error")
[17:02:29.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.008]                   NULL)
[17:02:29.008]                 if (is_error) {
[17:02:29.008]                   sessionInformation <- function() {
[17:02:29.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.008]                       search = base::search(), system = base::Sys.info())
[17:02:29.008]                   }
[17:02:29.008]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.008]                     cond$call), session = sessionInformation(), 
[17:02:29.008]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.008]                   signalCondition(cond)
[17:02:29.008]                 }
[17:02:29.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.008]                 "immediateCondition"))) {
[17:02:29.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.008]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.008]                   if (TRUE && !signal) {
[17:02:29.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.008]                     {
[17:02:29.008]                       inherits <- base::inherits
[17:02:29.008]                       invokeRestart <- base::invokeRestart
[17:02:29.008]                       is.null <- base::is.null
[17:02:29.008]                       muffled <- FALSE
[17:02:29.008]                       if (inherits(cond, "message")) {
[17:02:29.008]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.008]                         if (muffled) 
[17:02:29.008]                           invokeRestart("muffleMessage")
[17:02:29.008]                       }
[17:02:29.008]                       else if (inherits(cond, "warning")) {
[17:02:29.008]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.008]                         if (muffled) 
[17:02:29.008]                           invokeRestart("muffleWarning")
[17:02:29.008]                       }
[17:02:29.008]                       else if (inherits(cond, "condition")) {
[17:02:29.008]                         if (!is.null(pattern)) {
[17:02:29.008]                           computeRestarts <- base::computeRestarts
[17:02:29.008]                           grepl <- base::grepl
[17:02:29.008]                           restarts <- computeRestarts(cond)
[17:02:29.008]                           for (restart in restarts) {
[17:02:29.008]                             name <- restart$name
[17:02:29.008]                             if (is.null(name)) 
[17:02:29.008]                               next
[17:02:29.008]                             if (!grepl(pattern, name)) 
[17:02:29.008]                               next
[17:02:29.008]                             invokeRestart(restart)
[17:02:29.008]                             muffled <- TRUE
[17:02:29.008]                             break
[17:02:29.008]                           }
[17:02:29.008]                         }
[17:02:29.008]                       }
[17:02:29.008]                       invisible(muffled)
[17:02:29.008]                     }
[17:02:29.008]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.008]                   }
[17:02:29.008]                 }
[17:02:29.008]                 else {
[17:02:29.008]                   if (TRUE) {
[17:02:29.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.008]                     {
[17:02:29.008]                       inherits <- base::inherits
[17:02:29.008]                       invokeRestart <- base::invokeRestart
[17:02:29.008]                       is.null <- base::is.null
[17:02:29.008]                       muffled <- FALSE
[17:02:29.008]                       if (inherits(cond, "message")) {
[17:02:29.008]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.008]                         if (muffled) 
[17:02:29.008]                           invokeRestart("muffleMessage")
[17:02:29.008]                       }
[17:02:29.008]                       else if (inherits(cond, "warning")) {
[17:02:29.008]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.008]                         if (muffled) 
[17:02:29.008]                           invokeRestart("muffleWarning")
[17:02:29.008]                       }
[17:02:29.008]                       else if (inherits(cond, "condition")) {
[17:02:29.008]                         if (!is.null(pattern)) {
[17:02:29.008]                           computeRestarts <- base::computeRestarts
[17:02:29.008]                           grepl <- base::grepl
[17:02:29.008]                           restarts <- computeRestarts(cond)
[17:02:29.008]                           for (restart in restarts) {
[17:02:29.008]                             name <- restart$name
[17:02:29.008]                             if (is.null(name)) 
[17:02:29.008]                               next
[17:02:29.008]                             if (!grepl(pattern, name)) 
[17:02:29.008]                               next
[17:02:29.008]                             invokeRestart(restart)
[17:02:29.008]                             muffled <- TRUE
[17:02:29.008]                             break
[17:02:29.008]                           }
[17:02:29.008]                         }
[17:02:29.008]                       }
[17:02:29.008]                       invisible(muffled)
[17:02:29.008]                     }
[17:02:29.008]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.008]                   }
[17:02:29.008]                 }
[17:02:29.008]             }
[17:02:29.008]         }))
[17:02:29.008]     }, error = function(ex) {
[17:02:29.008]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.008]                 ...future.rng), started = ...future.startTime, 
[17:02:29.008]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.008]             version = "1.8"), class = "FutureResult")
[17:02:29.008]     }, finally = {
[17:02:29.008]         if (!identical(...future.workdir, getwd())) 
[17:02:29.008]             setwd(...future.workdir)
[17:02:29.008]         {
[17:02:29.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.008]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.008]             }
[17:02:29.008]             base::options(...future.oldOptions)
[17:02:29.008]             if (.Platform$OS.type == "windows") {
[17:02:29.008]                 old_names <- names(...future.oldEnvVars)
[17:02:29.008]                 envs <- base::Sys.getenv()
[17:02:29.008]                 names <- names(envs)
[17:02:29.008]                 common <- intersect(names, old_names)
[17:02:29.008]                 added <- setdiff(names, old_names)
[17:02:29.008]                 removed <- setdiff(old_names, names)
[17:02:29.008]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.008]                   envs[common]]
[17:02:29.008]                 NAMES <- toupper(changed)
[17:02:29.008]                 args <- list()
[17:02:29.008]                 for (kk in seq_along(NAMES)) {
[17:02:29.008]                   name <- changed[[kk]]
[17:02:29.008]                   NAME <- NAMES[[kk]]
[17:02:29.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.008]                     next
[17:02:29.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.008]                 }
[17:02:29.008]                 NAMES <- toupper(added)
[17:02:29.008]                 for (kk in seq_along(NAMES)) {
[17:02:29.008]                   name <- added[[kk]]
[17:02:29.008]                   NAME <- NAMES[[kk]]
[17:02:29.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.008]                     next
[17:02:29.008]                   args[[name]] <- ""
[17:02:29.008]                 }
[17:02:29.008]                 NAMES <- toupper(removed)
[17:02:29.008]                 for (kk in seq_along(NAMES)) {
[17:02:29.008]                   name <- removed[[kk]]
[17:02:29.008]                   NAME <- NAMES[[kk]]
[17:02:29.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.008]                     next
[17:02:29.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.008]                 }
[17:02:29.008]                 if (length(args) > 0) 
[17:02:29.008]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.008]             }
[17:02:29.008]             else {
[17:02:29.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.008]             }
[17:02:29.008]             {
[17:02:29.008]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.008]                   0L) {
[17:02:29.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.008]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.008]                   base::options(opts)
[17:02:29.008]                 }
[17:02:29.008]                 {
[17:02:29.008]                   {
[17:02:29.008]                     NULL
[17:02:29.008]                     RNGkind("Mersenne-Twister")
[17:02:29.008]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:29.008]                       inherits = FALSE)
[17:02:29.008]                   }
[17:02:29.008]                   options(future.plan = NULL)
[17:02:29.008]                   if (is.na(NA_character_)) 
[17:02:29.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.008]                     .init = FALSE)
[17:02:29.008]                 }
[17:02:29.008]             }
[17:02:29.008]         }
[17:02:29.008]     })
[17:02:29.008]     if (TRUE) {
[17:02:29.008]         base::sink(type = "output", split = FALSE)
[17:02:29.008]         if (TRUE) {
[17:02:29.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.008]         }
[17:02:29.008]         else {
[17:02:29.008]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.008]         }
[17:02:29.008]         base::close(...future.stdout)
[17:02:29.008]         ...future.stdout <- NULL
[17:02:29.008]     }
[17:02:29.008]     ...future.result$conditions <- ...future.conditions
[17:02:29.008]     ...future.result$finished <- base::Sys.time()
[17:02:29.008]     ...future.result
[17:02:29.008] }
[17:02:29.010] plan(): Setting new future strategy stack:
[17:02:29.010] List of future strategies:
[17:02:29.010] 1. sequential:
[17:02:29.010]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.010]    - tweaked: FALSE
[17:02:29.010]    - call: NULL
[17:02:29.011] plan(): nbrOfWorkers() = 1
[17:02:29.011] plan(): Setting new future strategy stack:
[17:02:29.011] List of future strategies:
[17:02:29.011] 1. sequential:
[17:02:29.011]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.011]    - tweaked: FALSE
[17:02:29.011]    - call: plan(strategy)
[17:02:29.012] plan(): nbrOfWorkers() = 1
[17:02:29.012] SequentialFuture started (and completed)
[17:02:29.012] - Launch lazy future ... done
[17:02:29.012] run() for ‘SequentialFuture’ ... done
[17:02:29.012] getGlobalsAndPackages() ...
[17:02:29.012] Searching for globals...
[17:02:29.013] 
[17:02:29.013] Searching for globals ... DONE
[17:02:29.013] - globals: [0] <none>
[17:02:29.013] getGlobalsAndPackages() ... DONE
[17:02:29.013] run() for ‘Future’ ...
[17:02:29.013] - state: ‘created’
[17:02:29.013] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:29.014] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:29.014] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:29.014]   - Field: ‘label’
[17:02:29.014]   - Field: ‘local’
[17:02:29.014]   - Field: ‘owner’
[17:02:29.014]   - Field: ‘envir’
[17:02:29.014]   - Field: ‘packages’
[17:02:29.014]   - Field: ‘gc’
[17:02:29.014]   - Field: ‘conditions’
[17:02:29.015]   - Field: ‘expr’
[17:02:29.015]   - Field: ‘uuid’
[17:02:29.015]   - Field: ‘seed’
[17:02:29.015]   - Field: ‘version’
[17:02:29.015]   - Field: ‘result’
[17:02:29.015]   - Field: ‘asynchronous’
[17:02:29.015]   - Field: ‘calls’
[17:02:29.015]   - Field: ‘globals’
[17:02:29.015]   - Field: ‘stdout’
[17:02:29.015]   - Field: ‘earlySignal’
[17:02:29.015]   - Field: ‘lazy’
[17:02:29.016]   - Field: ‘state’
[17:02:29.016] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:29.016] - Launch lazy future ...
[17:02:29.016] Packages needed by the future expression (n = 0): <none>
[17:02:29.016] Packages needed by future strategies (n = 0): <none>
[17:02:29.016] {
[17:02:29.016]     {
[17:02:29.016]         {
[17:02:29.016]             ...future.startTime <- base::Sys.time()
[17:02:29.016]             {
[17:02:29.016]                 {
[17:02:29.016]                   {
[17:02:29.016]                     base::local({
[17:02:29.016]                       has_future <- base::requireNamespace("future", 
[17:02:29.016]                         quietly = TRUE)
[17:02:29.016]                       if (has_future) {
[17:02:29.016]                         ns <- base::getNamespace("future")
[17:02:29.016]                         version <- ns[[".package"]][["version"]]
[17:02:29.016]                         if (is.null(version)) 
[17:02:29.016]                           version <- utils::packageVersion("future")
[17:02:29.016]                       }
[17:02:29.016]                       else {
[17:02:29.016]                         version <- NULL
[17:02:29.016]                       }
[17:02:29.016]                       if (!has_future || version < "1.8.0") {
[17:02:29.016]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.016]                           "", base::R.version$version.string), 
[17:02:29.016]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:29.016]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.016]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.016]                             "release", "version")], collapse = " "), 
[17:02:29.016]                           hostname = base::Sys.info()[["nodename"]])
[17:02:29.016]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.016]                           info)
[17:02:29.016]                         info <- base::paste(info, collapse = "; ")
[17:02:29.016]                         if (!has_future) {
[17:02:29.016]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.016]                             info)
[17:02:29.016]                         }
[17:02:29.016]                         else {
[17:02:29.016]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.016]                             info, version)
[17:02:29.016]                         }
[17:02:29.016]                         base::stop(msg)
[17:02:29.016]                       }
[17:02:29.016]                     })
[17:02:29.016]                   }
[17:02:29.016]                   ...future.strategy.old <- future::plan("list")
[17:02:29.016]                   options(future.plan = NULL)
[17:02:29.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.016]                 }
[17:02:29.016]                 ...future.workdir <- getwd()
[17:02:29.016]             }
[17:02:29.016]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.016]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.016]         }
[17:02:29.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.016]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.016]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.016]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.016]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.016]             base::names(...future.oldOptions))
[17:02:29.016]     }
[17:02:29.016]     if (FALSE) {
[17:02:29.016]     }
[17:02:29.016]     else {
[17:02:29.016]         if (TRUE) {
[17:02:29.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.016]                 open = "w")
[17:02:29.016]         }
[17:02:29.016]         else {
[17:02:29.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.016]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.016]         }
[17:02:29.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.016]             base::sink(type = "output", split = FALSE)
[17:02:29.016]             base::close(...future.stdout)
[17:02:29.016]         }, add = TRUE)
[17:02:29.016]     }
[17:02:29.016]     ...future.frame <- base::sys.nframe()
[17:02:29.016]     ...future.conditions <- base::list()
[17:02:29.016]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.016]     if (FALSE) {
[17:02:29.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.016]     }
[17:02:29.016]     ...future.result <- base::tryCatch({
[17:02:29.016]         base::withCallingHandlers({
[17:02:29.016]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:29.016]             future::FutureResult(value = ...future.value$value, 
[17:02:29.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.016]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.016]                     ...future.globalenv.names))
[17:02:29.016]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.016]         }, condition = base::local({
[17:02:29.016]             c <- base::c
[17:02:29.016]             inherits <- base::inherits
[17:02:29.016]             invokeRestart <- base::invokeRestart
[17:02:29.016]             length <- base::length
[17:02:29.016]             list <- base::list
[17:02:29.016]             seq.int <- base::seq.int
[17:02:29.016]             signalCondition <- base::signalCondition
[17:02:29.016]             sys.calls <- base::sys.calls
[17:02:29.016]             `[[` <- base::`[[`
[17:02:29.016]             `+` <- base::`+`
[17:02:29.016]             `<<-` <- base::`<<-`
[17:02:29.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.016]                   3L)]
[17:02:29.016]             }
[17:02:29.016]             function(cond) {
[17:02:29.016]                 is_error <- inherits(cond, "error")
[17:02:29.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.016]                   NULL)
[17:02:29.016]                 if (is_error) {
[17:02:29.016]                   sessionInformation <- function() {
[17:02:29.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.016]                       search = base::search(), system = base::Sys.info())
[17:02:29.016]                   }
[17:02:29.016]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.016]                     cond$call), session = sessionInformation(), 
[17:02:29.016]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.016]                   signalCondition(cond)
[17:02:29.016]                 }
[17:02:29.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.016]                 "immediateCondition"))) {
[17:02:29.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.016]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.016]                   if (TRUE && !signal) {
[17:02:29.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.016]                     {
[17:02:29.016]                       inherits <- base::inherits
[17:02:29.016]                       invokeRestart <- base::invokeRestart
[17:02:29.016]                       is.null <- base::is.null
[17:02:29.016]                       muffled <- FALSE
[17:02:29.016]                       if (inherits(cond, "message")) {
[17:02:29.016]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.016]                         if (muffled) 
[17:02:29.016]                           invokeRestart("muffleMessage")
[17:02:29.016]                       }
[17:02:29.016]                       else if (inherits(cond, "warning")) {
[17:02:29.016]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.016]                         if (muffled) 
[17:02:29.016]                           invokeRestart("muffleWarning")
[17:02:29.016]                       }
[17:02:29.016]                       else if (inherits(cond, "condition")) {
[17:02:29.016]                         if (!is.null(pattern)) {
[17:02:29.016]                           computeRestarts <- base::computeRestarts
[17:02:29.016]                           grepl <- base::grepl
[17:02:29.016]                           restarts <- computeRestarts(cond)
[17:02:29.016]                           for (restart in restarts) {
[17:02:29.016]                             name <- restart$name
[17:02:29.016]                             if (is.null(name)) 
[17:02:29.016]                               next
[17:02:29.016]                             if (!grepl(pattern, name)) 
[17:02:29.016]                               next
[17:02:29.016]                             invokeRestart(restart)
[17:02:29.016]                             muffled <- TRUE
[17:02:29.016]                             break
[17:02:29.016]                           }
[17:02:29.016]                         }
[17:02:29.016]                       }
[17:02:29.016]                       invisible(muffled)
[17:02:29.016]                     }
[17:02:29.016]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.016]                   }
[17:02:29.016]                 }
[17:02:29.016]                 else {
[17:02:29.016]                   if (TRUE) {
[17:02:29.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.016]                     {
[17:02:29.016]                       inherits <- base::inherits
[17:02:29.016]                       invokeRestart <- base::invokeRestart
[17:02:29.016]                       is.null <- base::is.null
[17:02:29.016]                       muffled <- FALSE
[17:02:29.016]                       if (inherits(cond, "message")) {
[17:02:29.016]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.016]                         if (muffled) 
[17:02:29.016]                           invokeRestart("muffleMessage")
[17:02:29.016]                       }
[17:02:29.016]                       else if (inherits(cond, "warning")) {
[17:02:29.016]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.016]                         if (muffled) 
[17:02:29.016]                           invokeRestart("muffleWarning")
[17:02:29.016]                       }
[17:02:29.016]                       else if (inherits(cond, "condition")) {
[17:02:29.016]                         if (!is.null(pattern)) {
[17:02:29.016]                           computeRestarts <- base::computeRestarts
[17:02:29.016]                           grepl <- base::grepl
[17:02:29.016]                           restarts <- computeRestarts(cond)
[17:02:29.016]                           for (restart in restarts) {
[17:02:29.016]                             name <- restart$name
[17:02:29.016]                             if (is.null(name)) 
[17:02:29.016]                               next
[17:02:29.016]                             if (!grepl(pattern, name)) 
[17:02:29.016]                               next
[17:02:29.016]                             invokeRestart(restart)
[17:02:29.016]                             muffled <- TRUE
[17:02:29.016]                             break
[17:02:29.016]                           }
[17:02:29.016]                         }
[17:02:29.016]                       }
[17:02:29.016]                       invisible(muffled)
[17:02:29.016]                     }
[17:02:29.016]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.016]                   }
[17:02:29.016]                 }
[17:02:29.016]             }
[17:02:29.016]         }))
[17:02:29.016]     }, error = function(ex) {
[17:02:29.016]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.016]                 ...future.rng), started = ...future.startTime, 
[17:02:29.016]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.016]             version = "1.8"), class = "FutureResult")
[17:02:29.016]     }, finally = {
[17:02:29.016]         if (!identical(...future.workdir, getwd())) 
[17:02:29.016]             setwd(...future.workdir)
[17:02:29.016]         {
[17:02:29.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.016]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.016]             }
[17:02:29.016]             base::options(...future.oldOptions)
[17:02:29.016]             if (.Platform$OS.type == "windows") {
[17:02:29.016]                 old_names <- names(...future.oldEnvVars)
[17:02:29.016]                 envs <- base::Sys.getenv()
[17:02:29.016]                 names <- names(envs)
[17:02:29.016]                 common <- intersect(names, old_names)
[17:02:29.016]                 added <- setdiff(names, old_names)
[17:02:29.016]                 removed <- setdiff(old_names, names)
[17:02:29.016]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.016]                   envs[common]]
[17:02:29.016]                 NAMES <- toupper(changed)
[17:02:29.016]                 args <- list()
[17:02:29.016]                 for (kk in seq_along(NAMES)) {
[17:02:29.016]                   name <- changed[[kk]]
[17:02:29.016]                   NAME <- NAMES[[kk]]
[17:02:29.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.016]                     next
[17:02:29.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.016]                 }
[17:02:29.016]                 NAMES <- toupper(added)
[17:02:29.016]                 for (kk in seq_along(NAMES)) {
[17:02:29.016]                   name <- added[[kk]]
[17:02:29.016]                   NAME <- NAMES[[kk]]
[17:02:29.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.016]                     next
[17:02:29.016]                   args[[name]] <- ""
[17:02:29.016]                 }
[17:02:29.016]                 NAMES <- toupper(removed)
[17:02:29.016]                 for (kk in seq_along(NAMES)) {
[17:02:29.016]                   name <- removed[[kk]]
[17:02:29.016]                   NAME <- NAMES[[kk]]
[17:02:29.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.016]                     next
[17:02:29.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.016]                 }
[17:02:29.016]                 if (length(args) > 0) 
[17:02:29.016]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.016]             }
[17:02:29.016]             else {
[17:02:29.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.016]             }
[17:02:29.016]             {
[17:02:29.016]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.016]                   0L) {
[17:02:29.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.016]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.016]                   base::options(opts)
[17:02:29.016]                 }
[17:02:29.016]                 {
[17:02:29.016]                   {
[17:02:29.016]                     NULL
[17:02:29.016]                     RNGkind("Mersenne-Twister")
[17:02:29.016]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:29.016]                       inherits = FALSE)
[17:02:29.016]                   }
[17:02:29.016]                   options(future.plan = NULL)
[17:02:29.016]                   if (is.na(NA_character_)) 
[17:02:29.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.016]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.016]                     .init = FALSE)
[17:02:29.016]                 }
[17:02:29.016]             }
[17:02:29.016]         }
[17:02:29.016]     })
[17:02:29.016]     if (TRUE) {
[17:02:29.016]         base::sink(type = "output", split = FALSE)
[17:02:29.016]         if (TRUE) {
[17:02:29.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.016]         }
[17:02:29.016]         else {
[17:02:29.016]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.016]         }
[17:02:29.016]         base::close(...future.stdout)
[17:02:29.016]         ...future.stdout <- NULL
[17:02:29.016]     }
[17:02:29.016]     ...future.result$conditions <- ...future.conditions
[17:02:29.016]     ...future.result$finished <- base::Sys.time()
[17:02:29.016]     ...future.result
[17:02:29.016] }
[17:02:29.018] plan(): Setting new future strategy stack:
[17:02:29.018] List of future strategies:
[17:02:29.018] 1. sequential:
[17:02:29.018]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.018]    - tweaked: FALSE
[17:02:29.018]    - call: NULL
[17:02:29.019] plan(): nbrOfWorkers() = 1
[17:02:29.019] plan(): Setting new future strategy stack:
[17:02:29.019] List of future strategies:
[17:02:29.019] 1. sequential:
[17:02:29.019]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.019]    - tweaked: FALSE
[17:02:29.019]    - call: plan(strategy)
[17:02:29.020] plan(): nbrOfWorkers() = 1
[17:02:29.020] SequentialFuture started (and completed)
[17:02:29.020] - Launch lazy future ... done
[17:02:29.020] run() for ‘SequentialFuture’ ... done
[17:02:29.021] getGlobalsAndPackages() ...
[17:02:29.021] Searching for globals...
[17:02:29.021] - globals found: [1] ‘{’
[17:02:29.021] Searching for globals ... DONE
[17:02:29.021] Resolving globals: FALSE
[17:02:29.022] 
[17:02:29.022] 
[17:02:29.022] getGlobalsAndPackages() ... DONE
[17:02:29.022] run() for ‘Future’ ...
[17:02:29.022] - state: ‘created’
[17:02:29.022] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:29.023] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:29.023] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:29.023]   - Field: ‘label’
[17:02:29.023]   - Field: ‘local’
[17:02:29.023]   - Field: ‘owner’
[17:02:29.023]   - Field: ‘envir’
[17:02:29.023]   - Field: ‘packages’
[17:02:29.023]   - Field: ‘gc’
[17:02:29.023]   - Field: ‘conditions’
[17:02:29.023]   - Field: ‘expr’
[17:02:29.023]   - Field: ‘uuid’
[17:02:29.024]   - Field: ‘seed’
[17:02:29.024]   - Field: ‘version’
[17:02:29.024]   - Field: ‘result’
[17:02:29.024]   - Field: ‘asynchronous’
[17:02:29.024]   - Field: ‘calls’
[17:02:29.024]   - Field: ‘globals’
[17:02:29.024]   - Field: ‘stdout’
[17:02:29.024]   - Field: ‘earlySignal’
[17:02:29.024]   - Field: ‘lazy’
[17:02:29.024]   - Field: ‘state’
[17:02:29.024] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:29.025] - Launch lazy future ...
[17:02:29.025] Packages needed by the future expression (n = 0): <none>
[17:02:29.025] Packages needed by future strategies (n = 0): <none>
[17:02:29.025] {
[17:02:29.025]     {
[17:02:29.025]         {
[17:02:29.025]             ...future.startTime <- base::Sys.time()
[17:02:29.025]             {
[17:02:29.025]                 {
[17:02:29.025]                   {
[17:02:29.025]                     base::local({
[17:02:29.025]                       has_future <- base::requireNamespace("future", 
[17:02:29.025]                         quietly = TRUE)
[17:02:29.025]                       if (has_future) {
[17:02:29.025]                         ns <- base::getNamespace("future")
[17:02:29.025]                         version <- ns[[".package"]][["version"]]
[17:02:29.025]                         if (is.null(version)) 
[17:02:29.025]                           version <- utils::packageVersion("future")
[17:02:29.025]                       }
[17:02:29.025]                       else {
[17:02:29.025]                         version <- NULL
[17:02:29.025]                       }
[17:02:29.025]                       if (!has_future || version < "1.8.0") {
[17:02:29.025]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.025]                           "", base::R.version$version.string), 
[17:02:29.025]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:29.025]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.025]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.025]                             "release", "version")], collapse = " "), 
[17:02:29.025]                           hostname = base::Sys.info()[["nodename"]])
[17:02:29.025]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.025]                           info)
[17:02:29.025]                         info <- base::paste(info, collapse = "; ")
[17:02:29.025]                         if (!has_future) {
[17:02:29.025]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.025]                             info)
[17:02:29.025]                         }
[17:02:29.025]                         else {
[17:02:29.025]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.025]                             info, version)
[17:02:29.025]                         }
[17:02:29.025]                         base::stop(msg)
[17:02:29.025]                       }
[17:02:29.025]                     })
[17:02:29.025]                   }
[17:02:29.025]                   ...future.strategy.old <- future::plan("list")
[17:02:29.025]                   options(future.plan = NULL)
[17:02:29.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.025]                 }
[17:02:29.025]                 ...future.workdir <- getwd()
[17:02:29.025]             }
[17:02:29.025]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.025]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.025]         }
[17:02:29.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.025]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.025]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.025]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.025]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.025]             base::names(...future.oldOptions))
[17:02:29.025]     }
[17:02:29.025]     if (FALSE) {
[17:02:29.025]     }
[17:02:29.025]     else {
[17:02:29.025]         if (TRUE) {
[17:02:29.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.025]                 open = "w")
[17:02:29.025]         }
[17:02:29.025]         else {
[17:02:29.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.025]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.025]         }
[17:02:29.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.025]             base::sink(type = "output", split = FALSE)
[17:02:29.025]             base::close(...future.stdout)
[17:02:29.025]         }, add = TRUE)
[17:02:29.025]     }
[17:02:29.025]     ...future.frame <- base::sys.nframe()
[17:02:29.025]     ...future.conditions <- base::list()
[17:02:29.025]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.025]     if (FALSE) {
[17:02:29.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.025]     }
[17:02:29.025]     ...future.result <- base::tryCatch({
[17:02:29.025]         base::withCallingHandlers({
[17:02:29.025]             ...future.value <- base::withVisible(base::local({
[17:02:29.025]                 4
[17:02:29.025]             }))
[17:02:29.025]             future::FutureResult(value = ...future.value$value, 
[17:02:29.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.025]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.025]                     ...future.globalenv.names))
[17:02:29.025]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.025]         }, condition = base::local({
[17:02:29.025]             c <- base::c
[17:02:29.025]             inherits <- base::inherits
[17:02:29.025]             invokeRestart <- base::invokeRestart
[17:02:29.025]             length <- base::length
[17:02:29.025]             list <- base::list
[17:02:29.025]             seq.int <- base::seq.int
[17:02:29.025]             signalCondition <- base::signalCondition
[17:02:29.025]             sys.calls <- base::sys.calls
[17:02:29.025]             `[[` <- base::`[[`
[17:02:29.025]             `+` <- base::`+`
[17:02:29.025]             `<<-` <- base::`<<-`
[17:02:29.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.025]                   3L)]
[17:02:29.025]             }
[17:02:29.025]             function(cond) {
[17:02:29.025]                 is_error <- inherits(cond, "error")
[17:02:29.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.025]                   NULL)
[17:02:29.025]                 if (is_error) {
[17:02:29.025]                   sessionInformation <- function() {
[17:02:29.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.025]                       search = base::search(), system = base::Sys.info())
[17:02:29.025]                   }
[17:02:29.025]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.025]                     cond$call), session = sessionInformation(), 
[17:02:29.025]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.025]                   signalCondition(cond)
[17:02:29.025]                 }
[17:02:29.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.025]                 "immediateCondition"))) {
[17:02:29.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.025]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.025]                   if (TRUE && !signal) {
[17:02:29.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.025]                     {
[17:02:29.025]                       inherits <- base::inherits
[17:02:29.025]                       invokeRestart <- base::invokeRestart
[17:02:29.025]                       is.null <- base::is.null
[17:02:29.025]                       muffled <- FALSE
[17:02:29.025]                       if (inherits(cond, "message")) {
[17:02:29.025]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.025]                         if (muffled) 
[17:02:29.025]                           invokeRestart("muffleMessage")
[17:02:29.025]                       }
[17:02:29.025]                       else if (inherits(cond, "warning")) {
[17:02:29.025]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.025]                         if (muffled) 
[17:02:29.025]                           invokeRestart("muffleWarning")
[17:02:29.025]                       }
[17:02:29.025]                       else if (inherits(cond, "condition")) {
[17:02:29.025]                         if (!is.null(pattern)) {
[17:02:29.025]                           computeRestarts <- base::computeRestarts
[17:02:29.025]                           grepl <- base::grepl
[17:02:29.025]                           restarts <- computeRestarts(cond)
[17:02:29.025]                           for (restart in restarts) {
[17:02:29.025]                             name <- restart$name
[17:02:29.025]                             if (is.null(name)) 
[17:02:29.025]                               next
[17:02:29.025]                             if (!grepl(pattern, name)) 
[17:02:29.025]                               next
[17:02:29.025]                             invokeRestart(restart)
[17:02:29.025]                             muffled <- TRUE
[17:02:29.025]                             break
[17:02:29.025]                           }
[17:02:29.025]                         }
[17:02:29.025]                       }
[17:02:29.025]                       invisible(muffled)
[17:02:29.025]                     }
[17:02:29.025]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.025]                   }
[17:02:29.025]                 }
[17:02:29.025]                 else {
[17:02:29.025]                   if (TRUE) {
[17:02:29.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.025]                     {
[17:02:29.025]                       inherits <- base::inherits
[17:02:29.025]                       invokeRestart <- base::invokeRestart
[17:02:29.025]                       is.null <- base::is.null
[17:02:29.025]                       muffled <- FALSE
[17:02:29.025]                       if (inherits(cond, "message")) {
[17:02:29.025]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.025]                         if (muffled) 
[17:02:29.025]                           invokeRestart("muffleMessage")
[17:02:29.025]                       }
[17:02:29.025]                       else if (inherits(cond, "warning")) {
[17:02:29.025]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.025]                         if (muffled) 
[17:02:29.025]                           invokeRestart("muffleWarning")
[17:02:29.025]                       }
[17:02:29.025]                       else if (inherits(cond, "condition")) {
[17:02:29.025]                         if (!is.null(pattern)) {
[17:02:29.025]                           computeRestarts <- base::computeRestarts
[17:02:29.025]                           grepl <- base::grepl
[17:02:29.025]                           restarts <- computeRestarts(cond)
[17:02:29.025]                           for (restart in restarts) {
[17:02:29.025]                             name <- restart$name
[17:02:29.025]                             if (is.null(name)) 
[17:02:29.025]                               next
[17:02:29.025]                             if (!grepl(pattern, name)) 
[17:02:29.025]                               next
[17:02:29.025]                             invokeRestart(restart)
[17:02:29.025]                             muffled <- TRUE
[17:02:29.025]                             break
[17:02:29.025]                           }
[17:02:29.025]                         }
[17:02:29.025]                       }
[17:02:29.025]                       invisible(muffled)
[17:02:29.025]                     }
[17:02:29.025]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.025]                   }
[17:02:29.025]                 }
[17:02:29.025]             }
[17:02:29.025]         }))
[17:02:29.025]     }, error = function(ex) {
[17:02:29.025]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.025]                 ...future.rng), started = ...future.startTime, 
[17:02:29.025]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.025]             version = "1.8"), class = "FutureResult")
[17:02:29.025]     }, finally = {
[17:02:29.025]         if (!identical(...future.workdir, getwd())) 
[17:02:29.025]             setwd(...future.workdir)
[17:02:29.025]         {
[17:02:29.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.025]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.025]             }
[17:02:29.025]             base::options(...future.oldOptions)
[17:02:29.025]             if (.Platform$OS.type == "windows") {
[17:02:29.025]                 old_names <- names(...future.oldEnvVars)
[17:02:29.025]                 envs <- base::Sys.getenv()
[17:02:29.025]                 names <- names(envs)
[17:02:29.025]                 common <- intersect(names, old_names)
[17:02:29.025]                 added <- setdiff(names, old_names)
[17:02:29.025]                 removed <- setdiff(old_names, names)
[17:02:29.025]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.025]                   envs[common]]
[17:02:29.025]                 NAMES <- toupper(changed)
[17:02:29.025]                 args <- list()
[17:02:29.025]                 for (kk in seq_along(NAMES)) {
[17:02:29.025]                   name <- changed[[kk]]
[17:02:29.025]                   NAME <- NAMES[[kk]]
[17:02:29.025]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.025]                     next
[17:02:29.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.025]                 }
[17:02:29.025]                 NAMES <- toupper(added)
[17:02:29.025]                 for (kk in seq_along(NAMES)) {
[17:02:29.025]                   name <- added[[kk]]
[17:02:29.025]                   NAME <- NAMES[[kk]]
[17:02:29.025]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.025]                     next
[17:02:29.025]                   args[[name]] <- ""
[17:02:29.025]                 }
[17:02:29.025]                 NAMES <- toupper(removed)
[17:02:29.025]                 for (kk in seq_along(NAMES)) {
[17:02:29.025]                   name <- removed[[kk]]
[17:02:29.025]                   NAME <- NAMES[[kk]]
[17:02:29.025]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.025]                     next
[17:02:29.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.025]                 }
[17:02:29.025]                 if (length(args) > 0) 
[17:02:29.025]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.025]             }
[17:02:29.025]             else {
[17:02:29.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.025]             }
[17:02:29.025]             {
[17:02:29.025]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.025]                   0L) {
[17:02:29.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.025]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.025]                   base::options(opts)
[17:02:29.025]                 }
[17:02:29.025]                 {
[17:02:29.025]                   {
[17:02:29.025]                     NULL
[17:02:29.025]                     RNGkind("Mersenne-Twister")
[17:02:29.025]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:29.025]                       inherits = FALSE)
[17:02:29.025]                   }
[17:02:29.025]                   options(future.plan = NULL)
[17:02:29.025]                   if (is.na(NA_character_)) 
[17:02:29.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.025]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.025]                     .init = FALSE)
[17:02:29.025]                 }
[17:02:29.025]             }
[17:02:29.025]         }
[17:02:29.025]     })
[17:02:29.025]     if (TRUE) {
[17:02:29.025]         base::sink(type = "output", split = FALSE)
[17:02:29.025]         if (TRUE) {
[17:02:29.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.025]         }
[17:02:29.025]         else {
[17:02:29.025]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.025]         }
[17:02:29.025]         base::close(...future.stdout)
[17:02:29.025]         ...future.stdout <- NULL
[17:02:29.025]     }
[17:02:29.025]     ...future.result$conditions <- ...future.conditions
[17:02:29.025]     ...future.result$finished <- base::Sys.time()
[17:02:29.025]     ...future.result
[17:02:29.025] }
[17:02:29.027] plan(): Setting new future strategy stack:
[17:02:29.027] List of future strategies:
[17:02:29.027] 1. sequential:
[17:02:29.027]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.027]    - tweaked: FALSE
[17:02:29.027]    - call: NULL
[17:02:29.027] plan(): nbrOfWorkers() = 1
[17:02:29.028] plan(): Setting new future strategy stack:
[17:02:29.028] List of future strategies:
[17:02:29.028] 1. sequential:
[17:02:29.028]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.028]    - tweaked: FALSE
[17:02:29.028]    - call: plan(strategy)
[17:02:29.029] plan(): nbrOfWorkers() = 1
[17:02:29.029] SequentialFuture started (and completed)
[17:02:29.029] - Launch lazy future ... done
[17:02:29.029] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c74736f788> 
Classes 'listenv', 'environment' <environment: 0x55c7497610f0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:02:29.034] resolved() for ‘SequentialFuture’ ...
[17:02:29.034] - state: ‘finished’
[17:02:29.034] - run: TRUE
[17:02:29.034] - result: ‘FutureResult’
[17:02:29.034] resolved() for ‘SequentialFuture’ ... done
[17:02:29.034] resolved() for ‘SequentialFuture’ ...
[17:02:29.034] - state: ‘finished’
[17:02:29.034] - run: TRUE
[17:02:29.035] - result: ‘FutureResult’
[17:02:29.035] resolved() for ‘SequentialFuture’ ... done
[17:02:29.035] resolved() for ‘SequentialFuture’ ...
[17:02:29.035] - state: ‘finished’
[17:02:29.035] - run: TRUE
[17:02:29.035] - result: ‘FutureResult’
[17:02:29.035] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:29.037] resolve() on list environment ...
[17:02:29.037]  recursive: 0
[17:02:29.038]  length: 6
[17:02:29.038]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:29.038] signalConditionsASAP(numeric, pos=1) ...
[17:02:29.039] - nx: 6
[17:02:29.039] - relay: TRUE
[17:02:29.039] - stdout: TRUE
[17:02:29.039] - signal: TRUE
[17:02:29.039] - resignal: FALSE
[17:02:29.039] - force: TRUE
[17:02:29.039] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.039] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.039]  - until=2
[17:02:29.039]  - relaying element #2
[17:02:29.039] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.039] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.040] signalConditionsASAP(NULL, pos=1) ... done
[17:02:29.040]  length: 5 (resolved future 1)
[17:02:29.040] resolved() for ‘SequentialFuture’ ...
[17:02:29.040] - state: ‘finished’
[17:02:29.040] - run: TRUE
[17:02:29.040] - result: ‘FutureResult’
[17:02:29.040] resolved() for ‘SequentialFuture’ ... done
[17:02:29.040] Future #2
[17:02:29.040] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:29.040] - nx: 6
[17:02:29.041] - relay: TRUE
[17:02:29.041] - stdout: TRUE
[17:02:29.041] - signal: TRUE
[17:02:29.041] - resignal: FALSE
[17:02:29.041] - force: TRUE
[17:02:29.041] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.041] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.041]  - until=2
[17:02:29.041]  - relaying element #2
[17:02:29.041] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.041] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.042] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:29.042]  length: 4 (resolved future 2)
[17:02:29.042] resolved() for ‘SequentialFuture’ ...
[17:02:29.042] - state: ‘finished’
[17:02:29.042] - run: TRUE
[17:02:29.042] - result: ‘FutureResult’
[17:02:29.042] resolved() for ‘SequentialFuture’ ... done
[17:02:29.042] Future #3
[17:02:29.042] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:29.042] - nx: 6
[17:02:29.042] - relay: TRUE
[17:02:29.043] - stdout: TRUE
[17:02:29.043] - signal: TRUE
[17:02:29.043] - resignal: FALSE
[17:02:29.043] - force: TRUE
[17:02:29.043] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.043] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.043]  - until=3
[17:02:29.043]  - relaying element #3
[17:02:29.043] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.043] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.043] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:29.044]  length: 3 (resolved future 3)
[17:02:29.044] resolved() for ‘SequentialFuture’ ...
[17:02:29.044] - state: ‘finished’
[17:02:29.044] - run: TRUE
[17:02:29.044] - result: ‘FutureResult’
[17:02:29.044] resolved() for ‘SequentialFuture’ ... done
[17:02:29.044] Future #4
[17:02:29.044] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:02:29.044] - nx: 6
[17:02:29.044] - relay: TRUE
[17:02:29.045] - stdout: TRUE
[17:02:29.045] - signal: TRUE
[17:02:29.045] - resignal: FALSE
[17:02:29.045] - force: TRUE
[17:02:29.045] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.045] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.045]  - until=4
[17:02:29.045]  - relaying element #4
[17:02:29.045] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.045] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.045] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:02:29.046]  length: 2 (resolved future 4)
[17:02:29.046] signalConditionsASAP(NULL, pos=5) ...
[17:02:29.046] - nx: 6
[17:02:29.046] - relay: TRUE
[17:02:29.046] - stdout: TRUE
[17:02:29.046] - signal: TRUE
[17:02:29.046] - resignal: FALSE
[17:02:29.046] - force: TRUE
[17:02:29.046] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.046] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.046]  - until=6
[17:02:29.046]  - relaying element #6
[17:02:29.046] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.047] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.047] signalConditionsASAP(NULL, pos=5) ... done
[17:02:29.047]  length: 1 (resolved future 5)
[17:02:29.047] signalConditionsASAP(numeric, pos=6) ...
[17:02:29.047] - nx: 6
[17:02:29.047] - relay: TRUE
[17:02:29.047] - stdout: TRUE
[17:02:29.047] - signal: TRUE
[17:02:29.047] - resignal: FALSE
[17:02:29.047] - force: TRUE
[17:02:29.047] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.047] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.048]  - until=6
[17:02:29.048] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.048] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.048] signalConditionsASAP(numeric, pos=6) ... done
[17:02:29.048]  length: 0 (resolved future 6)
[17:02:29.048] Relaying remaining futures
[17:02:29.048] signalConditionsASAP(NULL, pos=0) ...
[17:02:29.048] - nx: 6
[17:02:29.048] - relay: TRUE
[17:02:29.048] - stdout: TRUE
[17:02:29.048] - signal: TRUE
[17:02:29.048] - resignal: FALSE
[17:02:29.049] - force: TRUE
[17:02:29.049] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.049] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:29.049] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.049] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.049] signalConditionsASAP(NULL, pos=0) ... done
[17:02:29.049] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55c7487f7698> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:02:29.051] getGlobalsAndPackages() ...
[17:02:29.051] Searching for globals...
[17:02:29.051] 
[17:02:29.052] Searching for globals ... DONE
[17:02:29.052] - globals: [0] <none>
[17:02:29.052] getGlobalsAndPackages() ... DONE
[17:02:29.052] run() for ‘Future’ ...
[17:02:29.052] - state: ‘created’
[17:02:29.052] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:29.052] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:29.053] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:29.053]   - Field: ‘label’
[17:02:29.053]   - Field: ‘local’
[17:02:29.053]   - Field: ‘owner’
[17:02:29.053]   - Field: ‘envir’
[17:02:29.053]   - Field: ‘packages’
[17:02:29.053]   - Field: ‘gc’
[17:02:29.053]   - Field: ‘conditions’
[17:02:29.053]   - Field: ‘expr’
[17:02:29.053]   - Field: ‘uuid’
[17:02:29.053]   - Field: ‘seed’
[17:02:29.054]   - Field: ‘version’
[17:02:29.054]   - Field: ‘result’
[17:02:29.054]   - Field: ‘asynchronous’
[17:02:29.054]   - Field: ‘calls’
[17:02:29.054]   - Field: ‘globals’
[17:02:29.054]   - Field: ‘stdout’
[17:02:29.054]   - Field: ‘earlySignal’
[17:02:29.054]   - Field: ‘lazy’
[17:02:29.054]   - Field: ‘state’
[17:02:29.054] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:29.054] - Launch lazy future ...
[17:02:29.056] Packages needed by the future expression (n = 0): <none>
[17:02:29.056] Packages needed by future strategies (n = 0): <none>
[17:02:29.057] {
[17:02:29.057]     {
[17:02:29.057]         {
[17:02:29.057]             ...future.startTime <- base::Sys.time()
[17:02:29.057]             {
[17:02:29.057]                 {
[17:02:29.057]                   {
[17:02:29.057]                     base::local({
[17:02:29.057]                       has_future <- base::requireNamespace("future", 
[17:02:29.057]                         quietly = TRUE)
[17:02:29.057]                       if (has_future) {
[17:02:29.057]                         ns <- base::getNamespace("future")
[17:02:29.057]                         version <- ns[[".package"]][["version"]]
[17:02:29.057]                         if (is.null(version)) 
[17:02:29.057]                           version <- utils::packageVersion("future")
[17:02:29.057]                       }
[17:02:29.057]                       else {
[17:02:29.057]                         version <- NULL
[17:02:29.057]                       }
[17:02:29.057]                       if (!has_future || version < "1.8.0") {
[17:02:29.057]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.057]                           "", base::R.version$version.string), 
[17:02:29.057]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:29.057]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.057]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.057]                             "release", "version")], collapse = " "), 
[17:02:29.057]                           hostname = base::Sys.info()[["nodename"]])
[17:02:29.057]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.057]                           info)
[17:02:29.057]                         info <- base::paste(info, collapse = "; ")
[17:02:29.057]                         if (!has_future) {
[17:02:29.057]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.057]                             info)
[17:02:29.057]                         }
[17:02:29.057]                         else {
[17:02:29.057]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.057]                             info, version)
[17:02:29.057]                         }
[17:02:29.057]                         base::stop(msg)
[17:02:29.057]                       }
[17:02:29.057]                     })
[17:02:29.057]                   }
[17:02:29.057]                   ...future.strategy.old <- future::plan("list")
[17:02:29.057]                   options(future.plan = NULL)
[17:02:29.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.057]                 }
[17:02:29.057]                 ...future.workdir <- getwd()
[17:02:29.057]             }
[17:02:29.057]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.057]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.057]         }
[17:02:29.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.057]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.057]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.057]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.057]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.057]             base::names(...future.oldOptions))
[17:02:29.057]     }
[17:02:29.057]     if (FALSE) {
[17:02:29.057]     }
[17:02:29.057]     else {
[17:02:29.057]         if (TRUE) {
[17:02:29.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.057]                 open = "w")
[17:02:29.057]         }
[17:02:29.057]         else {
[17:02:29.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.057]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.057]         }
[17:02:29.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.057]             base::sink(type = "output", split = FALSE)
[17:02:29.057]             base::close(...future.stdout)
[17:02:29.057]         }, add = TRUE)
[17:02:29.057]     }
[17:02:29.057]     ...future.frame <- base::sys.nframe()
[17:02:29.057]     ...future.conditions <- base::list()
[17:02:29.057]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.057]     if (FALSE) {
[17:02:29.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.057]     }
[17:02:29.057]     ...future.result <- base::tryCatch({
[17:02:29.057]         base::withCallingHandlers({
[17:02:29.057]             ...future.value <- base::withVisible(base::local(2))
[17:02:29.057]             future::FutureResult(value = ...future.value$value, 
[17:02:29.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.057]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.057]                     ...future.globalenv.names))
[17:02:29.057]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.057]         }, condition = base::local({
[17:02:29.057]             c <- base::c
[17:02:29.057]             inherits <- base::inherits
[17:02:29.057]             invokeRestart <- base::invokeRestart
[17:02:29.057]             length <- base::length
[17:02:29.057]             list <- base::list
[17:02:29.057]             seq.int <- base::seq.int
[17:02:29.057]             signalCondition <- base::signalCondition
[17:02:29.057]             sys.calls <- base::sys.calls
[17:02:29.057]             `[[` <- base::`[[`
[17:02:29.057]             `+` <- base::`+`
[17:02:29.057]             `<<-` <- base::`<<-`
[17:02:29.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.057]                   3L)]
[17:02:29.057]             }
[17:02:29.057]             function(cond) {
[17:02:29.057]                 is_error <- inherits(cond, "error")
[17:02:29.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.057]                   NULL)
[17:02:29.057]                 if (is_error) {
[17:02:29.057]                   sessionInformation <- function() {
[17:02:29.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.057]                       search = base::search(), system = base::Sys.info())
[17:02:29.057]                   }
[17:02:29.057]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.057]                     cond$call), session = sessionInformation(), 
[17:02:29.057]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.057]                   signalCondition(cond)
[17:02:29.057]                 }
[17:02:29.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.057]                 "immediateCondition"))) {
[17:02:29.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.057]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.057]                   if (TRUE && !signal) {
[17:02:29.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.057]                     {
[17:02:29.057]                       inherits <- base::inherits
[17:02:29.057]                       invokeRestart <- base::invokeRestart
[17:02:29.057]                       is.null <- base::is.null
[17:02:29.057]                       muffled <- FALSE
[17:02:29.057]                       if (inherits(cond, "message")) {
[17:02:29.057]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.057]                         if (muffled) 
[17:02:29.057]                           invokeRestart("muffleMessage")
[17:02:29.057]                       }
[17:02:29.057]                       else if (inherits(cond, "warning")) {
[17:02:29.057]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.057]                         if (muffled) 
[17:02:29.057]                           invokeRestart("muffleWarning")
[17:02:29.057]                       }
[17:02:29.057]                       else if (inherits(cond, "condition")) {
[17:02:29.057]                         if (!is.null(pattern)) {
[17:02:29.057]                           computeRestarts <- base::computeRestarts
[17:02:29.057]                           grepl <- base::grepl
[17:02:29.057]                           restarts <- computeRestarts(cond)
[17:02:29.057]                           for (restart in restarts) {
[17:02:29.057]                             name <- restart$name
[17:02:29.057]                             if (is.null(name)) 
[17:02:29.057]                               next
[17:02:29.057]                             if (!grepl(pattern, name)) 
[17:02:29.057]                               next
[17:02:29.057]                             invokeRestart(restart)
[17:02:29.057]                             muffled <- TRUE
[17:02:29.057]                             break
[17:02:29.057]                           }
[17:02:29.057]                         }
[17:02:29.057]                       }
[17:02:29.057]                       invisible(muffled)
[17:02:29.057]                     }
[17:02:29.057]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.057]                   }
[17:02:29.057]                 }
[17:02:29.057]                 else {
[17:02:29.057]                   if (TRUE) {
[17:02:29.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.057]                     {
[17:02:29.057]                       inherits <- base::inherits
[17:02:29.057]                       invokeRestart <- base::invokeRestart
[17:02:29.057]                       is.null <- base::is.null
[17:02:29.057]                       muffled <- FALSE
[17:02:29.057]                       if (inherits(cond, "message")) {
[17:02:29.057]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.057]                         if (muffled) 
[17:02:29.057]                           invokeRestart("muffleMessage")
[17:02:29.057]                       }
[17:02:29.057]                       else if (inherits(cond, "warning")) {
[17:02:29.057]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.057]                         if (muffled) 
[17:02:29.057]                           invokeRestart("muffleWarning")
[17:02:29.057]                       }
[17:02:29.057]                       else if (inherits(cond, "condition")) {
[17:02:29.057]                         if (!is.null(pattern)) {
[17:02:29.057]                           computeRestarts <- base::computeRestarts
[17:02:29.057]                           grepl <- base::grepl
[17:02:29.057]                           restarts <- computeRestarts(cond)
[17:02:29.057]                           for (restart in restarts) {
[17:02:29.057]                             name <- restart$name
[17:02:29.057]                             if (is.null(name)) 
[17:02:29.057]                               next
[17:02:29.057]                             if (!grepl(pattern, name)) 
[17:02:29.057]                               next
[17:02:29.057]                             invokeRestart(restart)
[17:02:29.057]                             muffled <- TRUE
[17:02:29.057]                             break
[17:02:29.057]                           }
[17:02:29.057]                         }
[17:02:29.057]                       }
[17:02:29.057]                       invisible(muffled)
[17:02:29.057]                     }
[17:02:29.057]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.057]                   }
[17:02:29.057]                 }
[17:02:29.057]             }
[17:02:29.057]         }))
[17:02:29.057]     }, error = function(ex) {
[17:02:29.057]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.057]                 ...future.rng), started = ...future.startTime, 
[17:02:29.057]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.057]             version = "1.8"), class = "FutureResult")
[17:02:29.057]     }, finally = {
[17:02:29.057]         if (!identical(...future.workdir, getwd())) 
[17:02:29.057]             setwd(...future.workdir)
[17:02:29.057]         {
[17:02:29.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.057]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.057]             }
[17:02:29.057]             base::options(...future.oldOptions)
[17:02:29.057]             if (.Platform$OS.type == "windows") {
[17:02:29.057]                 old_names <- names(...future.oldEnvVars)
[17:02:29.057]                 envs <- base::Sys.getenv()
[17:02:29.057]                 names <- names(envs)
[17:02:29.057]                 common <- intersect(names, old_names)
[17:02:29.057]                 added <- setdiff(names, old_names)
[17:02:29.057]                 removed <- setdiff(old_names, names)
[17:02:29.057]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.057]                   envs[common]]
[17:02:29.057]                 NAMES <- toupper(changed)
[17:02:29.057]                 args <- list()
[17:02:29.057]                 for (kk in seq_along(NAMES)) {
[17:02:29.057]                   name <- changed[[kk]]
[17:02:29.057]                   NAME <- NAMES[[kk]]
[17:02:29.057]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.057]                     next
[17:02:29.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.057]                 }
[17:02:29.057]                 NAMES <- toupper(added)
[17:02:29.057]                 for (kk in seq_along(NAMES)) {
[17:02:29.057]                   name <- added[[kk]]
[17:02:29.057]                   NAME <- NAMES[[kk]]
[17:02:29.057]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.057]                     next
[17:02:29.057]                   args[[name]] <- ""
[17:02:29.057]                 }
[17:02:29.057]                 NAMES <- toupper(removed)
[17:02:29.057]                 for (kk in seq_along(NAMES)) {
[17:02:29.057]                   name <- removed[[kk]]
[17:02:29.057]                   NAME <- NAMES[[kk]]
[17:02:29.057]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.057]                     next
[17:02:29.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.057]                 }
[17:02:29.057]                 if (length(args) > 0) 
[17:02:29.057]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.057]             }
[17:02:29.057]             else {
[17:02:29.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.057]             }
[17:02:29.057]             {
[17:02:29.057]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.057]                   0L) {
[17:02:29.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.057]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.057]                   base::options(opts)
[17:02:29.057]                 }
[17:02:29.057]                 {
[17:02:29.057]                   {
[17:02:29.057]                     NULL
[17:02:29.057]                     RNGkind("Mersenne-Twister")
[17:02:29.057]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:29.057]                       inherits = FALSE)
[17:02:29.057]                   }
[17:02:29.057]                   options(future.plan = NULL)
[17:02:29.057]                   if (is.na(NA_character_)) 
[17:02:29.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.057]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.057]                     .init = FALSE)
[17:02:29.057]                 }
[17:02:29.057]             }
[17:02:29.057]         }
[17:02:29.057]     })
[17:02:29.057]     if (TRUE) {
[17:02:29.057]         base::sink(type = "output", split = FALSE)
[17:02:29.057]         if (TRUE) {
[17:02:29.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.057]         }
[17:02:29.057]         else {
[17:02:29.057]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.057]         }
[17:02:29.057]         base::close(...future.stdout)
[17:02:29.057]         ...future.stdout <- NULL
[17:02:29.057]     }
[17:02:29.057]     ...future.result$conditions <- ...future.conditions
[17:02:29.057]     ...future.result$finished <- base::Sys.time()
[17:02:29.057]     ...future.result
[17:02:29.057] }
[17:02:29.059] plan(): Setting new future strategy stack:
[17:02:29.059] List of future strategies:
[17:02:29.059] 1. sequential:
[17:02:29.059]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.059]    - tweaked: FALSE
[17:02:29.059]    - call: NULL
[17:02:29.059] plan(): nbrOfWorkers() = 1
[17:02:29.060] plan(): Setting new future strategy stack:
[17:02:29.060] List of future strategies:
[17:02:29.060] 1. sequential:
[17:02:29.060]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.060]    - tweaked: FALSE
[17:02:29.060]    - call: plan(strategy)
[17:02:29.061] plan(): nbrOfWorkers() = 1
[17:02:29.061] SequentialFuture started (and completed)
[17:02:29.061] - Launch lazy future ... done
[17:02:29.061] run() for ‘SequentialFuture’ ... done
[17:02:29.061] getGlobalsAndPackages() ...
[17:02:29.061] Searching for globals...
[17:02:29.062] 
[17:02:29.062] Searching for globals ... DONE
[17:02:29.062] - globals: [0] <none>
[17:02:29.062] getGlobalsAndPackages() ... DONE
[17:02:29.062] run() for ‘Future’ ...
[17:02:29.062] - state: ‘created’
[17:02:29.063] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:29.063] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:29.063] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:29.063]   - Field: ‘label’
[17:02:29.063]   - Field: ‘local’
[17:02:29.063]   - Field: ‘owner’
[17:02:29.063]   - Field: ‘envir’
[17:02:29.063]   - Field: ‘packages’
[17:02:29.063]   - Field: ‘gc’
[17:02:29.064]   - Field: ‘conditions’
[17:02:29.064]   - Field: ‘expr’
[17:02:29.064]   - Field: ‘uuid’
[17:02:29.064]   - Field: ‘seed’
[17:02:29.064]   - Field: ‘version’
[17:02:29.064]   - Field: ‘result’
[17:02:29.064]   - Field: ‘asynchronous’
[17:02:29.064]   - Field: ‘calls’
[17:02:29.064]   - Field: ‘globals’
[17:02:29.064]   - Field: ‘stdout’
[17:02:29.064]   - Field: ‘earlySignal’
[17:02:29.065]   - Field: ‘lazy’
[17:02:29.065]   - Field: ‘state’
[17:02:29.065] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:29.065] - Launch lazy future ...
[17:02:29.065] Packages needed by the future expression (n = 0): <none>
[17:02:29.065] Packages needed by future strategies (n = 0): <none>
[17:02:29.066] {
[17:02:29.066]     {
[17:02:29.066]         {
[17:02:29.066]             ...future.startTime <- base::Sys.time()
[17:02:29.066]             {
[17:02:29.066]                 {
[17:02:29.066]                   {
[17:02:29.066]                     base::local({
[17:02:29.066]                       has_future <- base::requireNamespace("future", 
[17:02:29.066]                         quietly = TRUE)
[17:02:29.066]                       if (has_future) {
[17:02:29.066]                         ns <- base::getNamespace("future")
[17:02:29.066]                         version <- ns[[".package"]][["version"]]
[17:02:29.066]                         if (is.null(version)) 
[17:02:29.066]                           version <- utils::packageVersion("future")
[17:02:29.066]                       }
[17:02:29.066]                       else {
[17:02:29.066]                         version <- NULL
[17:02:29.066]                       }
[17:02:29.066]                       if (!has_future || version < "1.8.0") {
[17:02:29.066]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.066]                           "", base::R.version$version.string), 
[17:02:29.066]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:29.066]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.066]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.066]                             "release", "version")], collapse = " "), 
[17:02:29.066]                           hostname = base::Sys.info()[["nodename"]])
[17:02:29.066]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.066]                           info)
[17:02:29.066]                         info <- base::paste(info, collapse = "; ")
[17:02:29.066]                         if (!has_future) {
[17:02:29.066]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.066]                             info)
[17:02:29.066]                         }
[17:02:29.066]                         else {
[17:02:29.066]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.066]                             info, version)
[17:02:29.066]                         }
[17:02:29.066]                         base::stop(msg)
[17:02:29.066]                       }
[17:02:29.066]                     })
[17:02:29.066]                   }
[17:02:29.066]                   ...future.strategy.old <- future::plan("list")
[17:02:29.066]                   options(future.plan = NULL)
[17:02:29.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.066]                 }
[17:02:29.066]                 ...future.workdir <- getwd()
[17:02:29.066]             }
[17:02:29.066]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.066]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.066]         }
[17:02:29.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.066]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.066]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.066]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.066]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.066]             base::names(...future.oldOptions))
[17:02:29.066]     }
[17:02:29.066]     if (FALSE) {
[17:02:29.066]     }
[17:02:29.066]     else {
[17:02:29.066]         if (TRUE) {
[17:02:29.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.066]                 open = "w")
[17:02:29.066]         }
[17:02:29.066]         else {
[17:02:29.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.066]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.066]         }
[17:02:29.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.066]             base::sink(type = "output", split = FALSE)
[17:02:29.066]             base::close(...future.stdout)
[17:02:29.066]         }, add = TRUE)
[17:02:29.066]     }
[17:02:29.066]     ...future.frame <- base::sys.nframe()
[17:02:29.066]     ...future.conditions <- base::list()
[17:02:29.066]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.066]     if (FALSE) {
[17:02:29.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.066]     }
[17:02:29.066]     ...future.result <- base::tryCatch({
[17:02:29.066]         base::withCallingHandlers({
[17:02:29.066]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:29.066]             future::FutureResult(value = ...future.value$value, 
[17:02:29.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.066]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.066]                     ...future.globalenv.names))
[17:02:29.066]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.066]         }, condition = base::local({
[17:02:29.066]             c <- base::c
[17:02:29.066]             inherits <- base::inherits
[17:02:29.066]             invokeRestart <- base::invokeRestart
[17:02:29.066]             length <- base::length
[17:02:29.066]             list <- base::list
[17:02:29.066]             seq.int <- base::seq.int
[17:02:29.066]             signalCondition <- base::signalCondition
[17:02:29.066]             sys.calls <- base::sys.calls
[17:02:29.066]             `[[` <- base::`[[`
[17:02:29.066]             `+` <- base::`+`
[17:02:29.066]             `<<-` <- base::`<<-`
[17:02:29.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.066]                   3L)]
[17:02:29.066]             }
[17:02:29.066]             function(cond) {
[17:02:29.066]                 is_error <- inherits(cond, "error")
[17:02:29.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.066]                   NULL)
[17:02:29.066]                 if (is_error) {
[17:02:29.066]                   sessionInformation <- function() {
[17:02:29.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.066]                       search = base::search(), system = base::Sys.info())
[17:02:29.066]                   }
[17:02:29.066]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.066]                     cond$call), session = sessionInformation(), 
[17:02:29.066]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.066]                   signalCondition(cond)
[17:02:29.066]                 }
[17:02:29.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.066]                 "immediateCondition"))) {
[17:02:29.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.066]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.066]                   if (TRUE && !signal) {
[17:02:29.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.066]                     {
[17:02:29.066]                       inherits <- base::inherits
[17:02:29.066]                       invokeRestart <- base::invokeRestart
[17:02:29.066]                       is.null <- base::is.null
[17:02:29.066]                       muffled <- FALSE
[17:02:29.066]                       if (inherits(cond, "message")) {
[17:02:29.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.066]                         if (muffled) 
[17:02:29.066]                           invokeRestart("muffleMessage")
[17:02:29.066]                       }
[17:02:29.066]                       else if (inherits(cond, "warning")) {
[17:02:29.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.066]                         if (muffled) 
[17:02:29.066]                           invokeRestart("muffleWarning")
[17:02:29.066]                       }
[17:02:29.066]                       else if (inherits(cond, "condition")) {
[17:02:29.066]                         if (!is.null(pattern)) {
[17:02:29.066]                           computeRestarts <- base::computeRestarts
[17:02:29.066]                           grepl <- base::grepl
[17:02:29.066]                           restarts <- computeRestarts(cond)
[17:02:29.066]                           for (restart in restarts) {
[17:02:29.066]                             name <- restart$name
[17:02:29.066]                             if (is.null(name)) 
[17:02:29.066]                               next
[17:02:29.066]                             if (!grepl(pattern, name)) 
[17:02:29.066]                               next
[17:02:29.066]                             invokeRestart(restart)
[17:02:29.066]                             muffled <- TRUE
[17:02:29.066]                             break
[17:02:29.066]                           }
[17:02:29.066]                         }
[17:02:29.066]                       }
[17:02:29.066]                       invisible(muffled)
[17:02:29.066]                     }
[17:02:29.066]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.066]                   }
[17:02:29.066]                 }
[17:02:29.066]                 else {
[17:02:29.066]                   if (TRUE) {
[17:02:29.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.066]                     {
[17:02:29.066]                       inherits <- base::inherits
[17:02:29.066]                       invokeRestart <- base::invokeRestart
[17:02:29.066]                       is.null <- base::is.null
[17:02:29.066]                       muffled <- FALSE
[17:02:29.066]                       if (inherits(cond, "message")) {
[17:02:29.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.066]                         if (muffled) 
[17:02:29.066]                           invokeRestart("muffleMessage")
[17:02:29.066]                       }
[17:02:29.066]                       else if (inherits(cond, "warning")) {
[17:02:29.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.066]                         if (muffled) 
[17:02:29.066]                           invokeRestart("muffleWarning")
[17:02:29.066]                       }
[17:02:29.066]                       else if (inherits(cond, "condition")) {
[17:02:29.066]                         if (!is.null(pattern)) {
[17:02:29.066]                           computeRestarts <- base::computeRestarts
[17:02:29.066]                           grepl <- base::grepl
[17:02:29.066]                           restarts <- computeRestarts(cond)
[17:02:29.066]                           for (restart in restarts) {
[17:02:29.066]                             name <- restart$name
[17:02:29.066]                             if (is.null(name)) 
[17:02:29.066]                               next
[17:02:29.066]                             if (!grepl(pattern, name)) 
[17:02:29.066]                               next
[17:02:29.066]                             invokeRestart(restart)
[17:02:29.066]                             muffled <- TRUE
[17:02:29.066]                             break
[17:02:29.066]                           }
[17:02:29.066]                         }
[17:02:29.066]                       }
[17:02:29.066]                       invisible(muffled)
[17:02:29.066]                     }
[17:02:29.066]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.066]                   }
[17:02:29.066]                 }
[17:02:29.066]             }
[17:02:29.066]         }))
[17:02:29.066]     }, error = function(ex) {
[17:02:29.066]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.066]                 ...future.rng), started = ...future.startTime, 
[17:02:29.066]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.066]             version = "1.8"), class = "FutureResult")
[17:02:29.066]     }, finally = {
[17:02:29.066]         if (!identical(...future.workdir, getwd())) 
[17:02:29.066]             setwd(...future.workdir)
[17:02:29.066]         {
[17:02:29.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.066]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.066]             }
[17:02:29.066]             base::options(...future.oldOptions)
[17:02:29.066]             if (.Platform$OS.type == "windows") {
[17:02:29.066]                 old_names <- names(...future.oldEnvVars)
[17:02:29.066]                 envs <- base::Sys.getenv()
[17:02:29.066]                 names <- names(envs)
[17:02:29.066]                 common <- intersect(names, old_names)
[17:02:29.066]                 added <- setdiff(names, old_names)
[17:02:29.066]                 removed <- setdiff(old_names, names)
[17:02:29.066]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.066]                   envs[common]]
[17:02:29.066]                 NAMES <- toupper(changed)
[17:02:29.066]                 args <- list()
[17:02:29.066]                 for (kk in seq_along(NAMES)) {
[17:02:29.066]                   name <- changed[[kk]]
[17:02:29.066]                   NAME <- NAMES[[kk]]
[17:02:29.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.066]                     next
[17:02:29.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.066]                 }
[17:02:29.066]                 NAMES <- toupper(added)
[17:02:29.066]                 for (kk in seq_along(NAMES)) {
[17:02:29.066]                   name <- added[[kk]]
[17:02:29.066]                   NAME <- NAMES[[kk]]
[17:02:29.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.066]                     next
[17:02:29.066]                   args[[name]] <- ""
[17:02:29.066]                 }
[17:02:29.066]                 NAMES <- toupper(removed)
[17:02:29.066]                 for (kk in seq_along(NAMES)) {
[17:02:29.066]                   name <- removed[[kk]]
[17:02:29.066]                   NAME <- NAMES[[kk]]
[17:02:29.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.066]                     next
[17:02:29.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.066]                 }
[17:02:29.066]                 if (length(args) > 0) 
[17:02:29.066]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.066]             }
[17:02:29.066]             else {
[17:02:29.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.066]             }
[17:02:29.066]             {
[17:02:29.066]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.066]                   0L) {
[17:02:29.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.066]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.066]                   base::options(opts)
[17:02:29.066]                 }
[17:02:29.066]                 {
[17:02:29.066]                   {
[17:02:29.066]                     NULL
[17:02:29.066]                     RNGkind("Mersenne-Twister")
[17:02:29.066]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:29.066]                       inherits = FALSE)
[17:02:29.066]                   }
[17:02:29.066]                   options(future.plan = NULL)
[17:02:29.066]                   if (is.na(NA_character_)) 
[17:02:29.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.066]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.066]                     .init = FALSE)
[17:02:29.066]                 }
[17:02:29.066]             }
[17:02:29.066]         }
[17:02:29.066]     })
[17:02:29.066]     if (TRUE) {
[17:02:29.066]         base::sink(type = "output", split = FALSE)
[17:02:29.066]         if (TRUE) {
[17:02:29.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.066]         }
[17:02:29.066]         else {
[17:02:29.066]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.066]         }
[17:02:29.066]         base::close(...future.stdout)
[17:02:29.066]         ...future.stdout <- NULL
[17:02:29.066]     }
[17:02:29.066]     ...future.result$conditions <- ...future.conditions
[17:02:29.066]     ...future.result$finished <- base::Sys.time()
[17:02:29.066]     ...future.result
[17:02:29.066] }
[17:02:29.067] plan(): Setting new future strategy stack:
[17:02:29.067] List of future strategies:
[17:02:29.067] 1. sequential:
[17:02:29.067]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.067]    - tweaked: FALSE
[17:02:29.067]    - call: NULL
[17:02:29.068] plan(): nbrOfWorkers() = 1
[17:02:29.069] plan(): Setting new future strategy stack:
[17:02:29.069] List of future strategies:
[17:02:29.069] 1. sequential:
[17:02:29.069]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.069]    - tweaked: FALSE
[17:02:29.069]    - call: plan(strategy)
[17:02:29.069] plan(): nbrOfWorkers() = 1
[17:02:29.069] SequentialFuture started (and completed)
[17:02:29.069] - Launch lazy future ... done
[17:02:29.069] run() for ‘SequentialFuture’ ... done
[17:02:29.070] getGlobalsAndPackages() ...
[17:02:29.070] Searching for globals...
[17:02:29.071] - globals found: [1] ‘{’
[17:02:29.071] Searching for globals ... DONE
[17:02:29.071] Resolving globals: FALSE
[17:02:29.071] 
[17:02:29.071] 
[17:02:29.071] getGlobalsAndPackages() ... DONE
[17:02:29.071] run() for ‘Future’ ...
[17:02:29.072] - state: ‘created’
[17:02:29.072] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:29.072] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:29.072] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:29.072]   - Field: ‘label’
[17:02:29.072]   - Field: ‘local’
[17:02:29.072]   - Field: ‘owner’
[17:02:29.072]   - Field: ‘envir’
[17:02:29.072]   - Field: ‘packages’
[17:02:29.073]   - Field: ‘gc’
[17:02:29.073]   - Field: ‘conditions’
[17:02:29.073]   - Field: ‘expr’
[17:02:29.073]   - Field: ‘uuid’
[17:02:29.073]   - Field: ‘seed’
[17:02:29.073]   - Field: ‘version’
[17:02:29.073]   - Field: ‘result’
[17:02:29.073]   - Field: ‘asynchronous’
[17:02:29.073]   - Field: ‘calls’
[17:02:29.073]   - Field: ‘globals’
[17:02:29.073]   - Field: ‘stdout’
[17:02:29.074]   - Field: ‘earlySignal’
[17:02:29.074]   - Field: ‘lazy’
[17:02:29.074]   - Field: ‘state’
[17:02:29.074] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:29.074] - Launch lazy future ...
[17:02:29.074] Packages needed by the future expression (n = 0): <none>
[17:02:29.074] Packages needed by future strategies (n = 0): <none>
[17:02:29.075] {
[17:02:29.075]     {
[17:02:29.075]         {
[17:02:29.075]             ...future.startTime <- base::Sys.time()
[17:02:29.075]             {
[17:02:29.075]                 {
[17:02:29.075]                   {
[17:02:29.075]                     base::local({
[17:02:29.075]                       has_future <- base::requireNamespace("future", 
[17:02:29.075]                         quietly = TRUE)
[17:02:29.075]                       if (has_future) {
[17:02:29.075]                         ns <- base::getNamespace("future")
[17:02:29.075]                         version <- ns[[".package"]][["version"]]
[17:02:29.075]                         if (is.null(version)) 
[17:02:29.075]                           version <- utils::packageVersion("future")
[17:02:29.075]                       }
[17:02:29.075]                       else {
[17:02:29.075]                         version <- NULL
[17:02:29.075]                       }
[17:02:29.075]                       if (!has_future || version < "1.8.0") {
[17:02:29.075]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.075]                           "", base::R.version$version.string), 
[17:02:29.075]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:29.075]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.075]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.075]                             "release", "version")], collapse = " "), 
[17:02:29.075]                           hostname = base::Sys.info()[["nodename"]])
[17:02:29.075]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.075]                           info)
[17:02:29.075]                         info <- base::paste(info, collapse = "; ")
[17:02:29.075]                         if (!has_future) {
[17:02:29.075]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.075]                             info)
[17:02:29.075]                         }
[17:02:29.075]                         else {
[17:02:29.075]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.075]                             info, version)
[17:02:29.075]                         }
[17:02:29.075]                         base::stop(msg)
[17:02:29.075]                       }
[17:02:29.075]                     })
[17:02:29.075]                   }
[17:02:29.075]                   ...future.strategy.old <- future::plan("list")
[17:02:29.075]                   options(future.plan = NULL)
[17:02:29.075]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.075]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.075]                 }
[17:02:29.075]                 ...future.workdir <- getwd()
[17:02:29.075]             }
[17:02:29.075]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.075]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.075]         }
[17:02:29.075]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.075]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.075]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.075]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.075]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.075]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.075]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.075]             base::names(...future.oldOptions))
[17:02:29.075]     }
[17:02:29.075]     if (FALSE) {
[17:02:29.075]     }
[17:02:29.075]     else {
[17:02:29.075]         if (TRUE) {
[17:02:29.075]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.075]                 open = "w")
[17:02:29.075]         }
[17:02:29.075]         else {
[17:02:29.075]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.075]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.075]         }
[17:02:29.075]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.075]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.075]             base::sink(type = "output", split = FALSE)
[17:02:29.075]             base::close(...future.stdout)
[17:02:29.075]         }, add = TRUE)
[17:02:29.075]     }
[17:02:29.075]     ...future.frame <- base::sys.nframe()
[17:02:29.075]     ...future.conditions <- base::list()
[17:02:29.075]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.075]     if (FALSE) {
[17:02:29.075]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.075]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.075]     }
[17:02:29.075]     ...future.result <- base::tryCatch({
[17:02:29.075]         base::withCallingHandlers({
[17:02:29.075]             ...future.value <- base::withVisible(base::local({
[17:02:29.075]                 4
[17:02:29.075]             }))
[17:02:29.075]             future::FutureResult(value = ...future.value$value, 
[17:02:29.075]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.075]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.075]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.075]                     ...future.globalenv.names))
[17:02:29.075]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.075]         }, condition = base::local({
[17:02:29.075]             c <- base::c
[17:02:29.075]             inherits <- base::inherits
[17:02:29.075]             invokeRestart <- base::invokeRestart
[17:02:29.075]             length <- base::length
[17:02:29.075]             list <- base::list
[17:02:29.075]             seq.int <- base::seq.int
[17:02:29.075]             signalCondition <- base::signalCondition
[17:02:29.075]             sys.calls <- base::sys.calls
[17:02:29.075]             `[[` <- base::`[[`
[17:02:29.075]             `+` <- base::`+`
[17:02:29.075]             `<<-` <- base::`<<-`
[17:02:29.075]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.075]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.075]                   3L)]
[17:02:29.075]             }
[17:02:29.075]             function(cond) {
[17:02:29.075]                 is_error <- inherits(cond, "error")
[17:02:29.075]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.075]                   NULL)
[17:02:29.075]                 if (is_error) {
[17:02:29.075]                   sessionInformation <- function() {
[17:02:29.075]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.075]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.075]                       search = base::search(), system = base::Sys.info())
[17:02:29.075]                   }
[17:02:29.075]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.075]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.075]                     cond$call), session = sessionInformation(), 
[17:02:29.075]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.075]                   signalCondition(cond)
[17:02:29.075]                 }
[17:02:29.075]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.075]                 "immediateCondition"))) {
[17:02:29.075]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.075]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.075]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.075]                   if (TRUE && !signal) {
[17:02:29.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.075]                     {
[17:02:29.075]                       inherits <- base::inherits
[17:02:29.075]                       invokeRestart <- base::invokeRestart
[17:02:29.075]                       is.null <- base::is.null
[17:02:29.075]                       muffled <- FALSE
[17:02:29.075]                       if (inherits(cond, "message")) {
[17:02:29.075]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.075]                         if (muffled) 
[17:02:29.075]                           invokeRestart("muffleMessage")
[17:02:29.075]                       }
[17:02:29.075]                       else if (inherits(cond, "warning")) {
[17:02:29.075]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.075]                         if (muffled) 
[17:02:29.075]                           invokeRestart("muffleWarning")
[17:02:29.075]                       }
[17:02:29.075]                       else if (inherits(cond, "condition")) {
[17:02:29.075]                         if (!is.null(pattern)) {
[17:02:29.075]                           computeRestarts <- base::computeRestarts
[17:02:29.075]                           grepl <- base::grepl
[17:02:29.075]                           restarts <- computeRestarts(cond)
[17:02:29.075]                           for (restart in restarts) {
[17:02:29.075]                             name <- restart$name
[17:02:29.075]                             if (is.null(name)) 
[17:02:29.075]                               next
[17:02:29.075]                             if (!grepl(pattern, name)) 
[17:02:29.075]                               next
[17:02:29.075]                             invokeRestart(restart)
[17:02:29.075]                             muffled <- TRUE
[17:02:29.075]                             break
[17:02:29.075]                           }
[17:02:29.075]                         }
[17:02:29.075]                       }
[17:02:29.075]                       invisible(muffled)
[17:02:29.075]                     }
[17:02:29.075]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.075]                   }
[17:02:29.075]                 }
[17:02:29.075]                 else {
[17:02:29.075]                   if (TRUE) {
[17:02:29.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.075]                     {
[17:02:29.075]                       inherits <- base::inherits
[17:02:29.075]                       invokeRestart <- base::invokeRestart
[17:02:29.075]                       is.null <- base::is.null
[17:02:29.075]                       muffled <- FALSE
[17:02:29.075]                       if (inherits(cond, "message")) {
[17:02:29.075]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.075]                         if (muffled) 
[17:02:29.075]                           invokeRestart("muffleMessage")
[17:02:29.075]                       }
[17:02:29.075]                       else if (inherits(cond, "warning")) {
[17:02:29.075]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.075]                         if (muffled) 
[17:02:29.075]                           invokeRestart("muffleWarning")
[17:02:29.075]                       }
[17:02:29.075]                       else if (inherits(cond, "condition")) {
[17:02:29.075]                         if (!is.null(pattern)) {
[17:02:29.075]                           computeRestarts <- base::computeRestarts
[17:02:29.075]                           grepl <- base::grepl
[17:02:29.075]                           restarts <- computeRestarts(cond)
[17:02:29.075]                           for (restart in restarts) {
[17:02:29.075]                             name <- restart$name
[17:02:29.075]                             if (is.null(name)) 
[17:02:29.075]                               next
[17:02:29.075]                             if (!grepl(pattern, name)) 
[17:02:29.075]                               next
[17:02:29.075]                             invokeRestart(restart)
[17:02:29.075]                             muffled <- TRUE
[17:02:29.075]                             break
[17:02:29.075]                           }
[17:02:29.075]                         }
[17:02:29.075]                       }
[17:02:29.075]                       invisible(muffled)
[17:02:29.075]                     }
[17:02:29.075]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.075]                   }
[17:02:29.075]                 }
[17:02:29.075]             }
[17:02:29.075]         }))
[17:02:29.075]     }, error = function(ex) {
[17:02:29.075]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.075]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.075]                 ...future.rng), started = ...future.startTime, 
[17:02:29.075]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.075]             version = "1.8"), class = "FutureResult")
[17:02:29.075]     }, finally = {
[17:02:29.075]         if (!identical(...future.workdir, getwd())) 
[17:02:29.075]             setwd(...future.workdir)
[17:02:29.075]         {
[17:02:29.075]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.075]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.075]             }
[17:02:29.075]             base::options(...future.oldOptions)
[17:02:29.075]             if (.Platform$OS.type == "windows") {
[17:02:29.075]                 old_names <- names(...future.oldEnvVars)
[17:02:29.075]                 envs <- base::Sys.getenv()
[17:02:29.075]                 names <- names(envs)
[17:02:29.075]                 common <- intersect(names, old_names)
[17:02:29.075]                 added <- setdiff(names, old_names)
[17:02:29.075]                 removed <- setdiff(old_names, names)
[17:02:29.075]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.075]                   envs[common]]
[17:02:29.075]                 NAMES <- toupper(changed)
[17:02:29.075]                 args <- list()
[17:02:29.075]                 for (kk in seq_along(NAMES)) {
[17:02:29.075]                   name <- changed[[kk]]
[17:02:29.075]                   NAME <- NAMES[[kk]]
[17:02:29.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.075]                     next
[17:02:29.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.075]                 }
[17:02:29.075]                 NAMES <- toupper(added)
[17:02:29.075]                 for (kk in seq_along(NAMES)) {
[17:02:29.075]                   name <- added[[kk]]
[17:02:29.075]                   NAME <- NAMES[[kk]]
[17:02:29.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.075]                     next
[17:02:29.075]                   args[[name]] <- ""
[17:02:29.075]                 }
[17:02:29.075]                 NAMES <- toupper(removed)
[17:02:29.075]                 for (kk in seq_along(NAMES)) {
[17:02:29.075]                   name <- removed[[kk]]
[17:02:29.075]                   NAME <- NAMES[[kk]]
[17:02:29.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.075]                     next
[17:02:29.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.075]                 }
[17:02:29.075]                 if (length(args) > 0) 
[17:02:29.075]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.075]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.075]             }
[17:02:29.075]             else {
[17:02:29.075]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.075]             }
[17:02:29.075]             {
[17:02:29.075]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.075]                   0L) {
[17:02:29.075]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.075]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.075]                   base::options(opts)
[17:02:29.075]                 }
[17:02:29.075]                 {
[17:02:29.075]                   {
[17:02:29.075]                     NULL
[17:02:29.075]                     RNGkind("Mersenne-Twister")
[17:02:29.075]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:29.075]                       inherits = FALSE)
[17:02:29.075]                   }
[17:02:29.075]                   options(future.plan = NULL)
[17:02:29.075]                   if (is.na(NA_character_)) 
[17:02:29.075]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.075]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.075]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.075]                     .init = FALSE)
[17:02:29.075]                 }
[17:02:29.075]             }
[17:02:29.075]         }
[17:02:29.075]     })
[17:02:29.075]     if (TRUE) {
[17:02:29.075]         base::sink(type = "output", split = FALSE)
[17:02:29.075]         if (TRUE) {
[17:02:29.075]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.075]         }
[17:02:29.075]         else {
[17:02:29.075]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.075]         }
[17:02:29.075]         base::close(...future.stdout)
[17:02:29.075]         ...future.stdout <- NULL
[17:02:29.075]     }
[17:02:29.075]     ...future.result$conditions <- ...future.conditions
[17:02:29.075]     ...future.result$finished <- base::Sys.time()
[17:02:29.075]     ...future.result
[17:02:29.075] }
[17:02:29.076] plan(): Setting new future strategy stack:
[17:02:29.076] List of future strategies:
[17:02:29.076] 1. sequential:
[17:02:29.076]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.076]    - tweaked: FALSE
[17:02:29.076]    - call: NULL
[17:02:29.077] plan(): nbrOfWorkers() = 1
[17:02:29.078] plan(): Setting new future strategy stack:
[17:02:29.078] List of future strategies:
[17:02:29.078] 1. sequential:
[17:02:29.078]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.078]    - tweaked: FALSE
[17:02:29.078]    - call: plan(strategy)
[17:02:29.078] plan(): nbrOfWorkers() = 1
[17:02:29.078] SequentialFuture started (and completed)
[17:02:29.078] - Launch lazy future ... done
[17:02:29.078] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c7499e21f0> 
Classes 'listenv', 'environment' <environment: 0x55c7496b6d98> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:02:29.082] resolved() for ‘SequentialFuture’ ...
[17:02:29.082] - state: ‘finished’
[17:02:29.082] - run: TRUE
[17:02:29.082] - result: ‘FutureResult’
[17:02:29.083] resolved() for ‘SequentialFuture’ ... done
[17:02:29.083] resolved() for ‘SequentialFuture’ ...
[17:02:29.083] - state: ‘finished’
[17:02:29.083] - run: TRUE
[17:02:29.083] - result: ‘FutureResult’
[17:02:29.083] resolved() for ‘SequentialFuture’ ... done
[17:02:29.083] resolved() for ‘SequentialFuture’ ...
[17:02:29.083] - state: ‘finished’
[17:02:29.083] - run: TRUE
[17:02:29.083] - result: ‘FutureResult’
[17:02:29.083] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:29.086] resolve() on list environment ...
[17:02:29.086]  recursive: 0
[17:02:29.089]  length: 6
[17:02:29.089]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:29.089] signalConditionsASAP(numeric, pos=1) ...
[17:02:29.089] - nx: 6
[17:02:29.089] - relay: TRUE
[17:02:29.089] - stdout: TRUE
[17:02:29.089] - signal: TRUE
[17:02:29.089] - resignal: FALSE
[17:02:29.089] - force: TRUE
[17:02:29.089] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.090] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.090]  - until=2
[17:02:29.090]  - relaying element #2
[17:02:29.090] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.090] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.090] signalConditionsASAP(NULL, pos=1) ... done
[17:02:29.090]  length: 5 (resolved future 1)
[17:02:29.090] resolved() for ‘SequentialFuture’ ...
[17:02:29.090] - state: ‘finished’
[17:02:29.090] - run: TRUE
[17:02:29.090] - result: ‘FutureResult’
[17:02:29.091] resolved() for ‘SequentialFuture’ ... done
[17:02:29.091] Future #2
[17:02:29.091] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:29.091] - nx: 6
[17:02:29.091] - relay: TRUE
[17:02:29.091] - stdout: TRUE
[17:02:29.091] - signal: TRUE
[17:02:29.091] - resignal: FALSE
[17:02:29.091] - force: TRUE
[17:02:29.091] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.091] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.092]  - until=2
[17:02:29.092]  - relaying element #2
[17:02:29.092] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.092] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.092] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:29.092]  length: 4 (resolved future 2)
[17:02:29.092] resolved() for ‘SequentialFuture’ ...
[17:02:29.092] - state: ‘finished’
[17:02:29.092] - run: TRUE
[17:02:29.093] - result: ‘FutureResult’
[17:02:29.093] resolved() for ‘SequentialFuture’ ... done
[17:02:29.093] Future #3
[17:02:29.093] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:29.093] - nx: 6
[17:02:29.093] - relay: TRUE
[17:02:29.093] - stdout: TRUE
[17:02:29.093] - signal: TRUE
[17:02:29.093] - resignal: FALSE
[17:02:29.093] - force: TRUE
[17:02:29.093] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.093] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.094]  - until=3
[17:02:29.094]  - relaying element #3
[17:02:29.094] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.094] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.094] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:29.094]  length: 3 (resolved future 3)
[17:02:29.094] resolved() for ‘SequentialFuture’ ...
[17:02:29.094] - state: ‘finished’
[17:02:29.094] - run: TRUE
[17:02:29.094] - result: ‘FutureResult’
[17:02:29.095] resolved() for ‘SequentialFuture’ ... done
[17:02:29.095] Future #4
[17:02:29.095] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:02:29.095] - nx: 6
[17:02:29.095] - relay: TRUE
[17:02:29.095] - stdout: TRUE
[17:02:29.095] - signal: TRUE
[17:02:29.095] - resignal: FALSE
[17:02:29.095] - force: TRUE
[17:02:29.095] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.095] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.096]  - until=4
[17:02:29.096]  - relaying element #4
[17:02:29.096] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.096] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.096] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:02:29.096]  length: 2 (resolved future 4)
[17:02:29.096] signalConditionsASAP(NULL, pos=5) ...
[17:02:29.096] - nx: 6
[17:02:29.096] - relay: TRUE
[17:02:29.096] - stdout: TRUE
[17:02:29.096] - signal: TRUE
[17:02:29.097] - resignal: FALSE
[17:02:29.097] - force: TRUE
[17:02:29.097] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.097] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.097]  - until=6
[17:02:29.097]  - relaying element #6
[17:02:29.097] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.097] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.097] signalConditionsASAP(NULL, pos=5) ... done
[17:02:29.097]  length: 1 (resolved future 5)
[17:02:29.097] signalConditionsASAP(numeric, pos=6) ...
[17:02:29.097] - nx: 6
[17:02:29.098] - relay: TRUE
[17:02:29.098] - stdout: TRUE
[17:02:29.098] - signal: TRUE
[17:02:29.098] - resignal: FALSE
[17:02:29.098] - force: TRUE
[17:02:29.098] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.098] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.098]  - until=6
[17:02:29.098] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.098] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.098] signalConditionsASAP(numeric, pos=6) ... done
[17:02:29.098]  length: 0 (resolved future 6)
[17:02:29.099] Relaying remaining futures
[17:02:29.099] signalConditionsASAP(NULL, pos=0) ...
[17:02:29.099] - nx: 6
[17:02:29.099] - relay: TRUE
[17:02:29.099] - stdout: TRUE
[17:02:29.099] - signal: TRUE
[17:02:29.099] - resignal: FALSE
[17:02:29.099] - force: TRUE
[17:02:29.099] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.099] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:29.099] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.099] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.100] signalConditionsASAP(NULL, pos=0) ... done
[17:02:29.100] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55c749da2888> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:02:29.102] getGlobalsAndPackages() ...
[17:02:29.102] Searching for globals...
[17:02:29.102] 
[17:02:29.102] Searching for globals ... DONE
[17:02:29.102] - globals: [0] <none>
[17:02:29.102] getGlobalsAndPackages() ... DONE
[17:02:29.103] run() for ‘Future’ ...
[17:02:29.103] - state: ‘created’
[17:02:29.103] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:29.103] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:29.103] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:29.103]   - Field: ‘label’
[17:02:29.103]   - Field: ‘local’
[17:02:29.103]   - Field: ‘owner’
[17:02:29.104]   - Field: ‘envir’
[17:02:29.104]   - Field: ‘packages’
[17:02:29.104]   - Field: ‘gc’
[17:02:29.104]   - Field: ‘conditions’
[17:02:29.104]   - Field: ‘expr’
[17:02:29.104]   - Field: ‘uuid’
[17:02:29.104]   - Field: ‘seed’
[17:02:29.104]   - Field: ‘version’
[17:02:29.104]   - Field: ‘result’
[17:02:29.104]   - Field: ‘asynchronous’
[17:02:29.104]   - Field: ‘calls’
[17:02:29.105]   - Field: ‘globals’
[17:02:29.105]   - Field: ‘stdout’
[17:02:29.105]   - Field: ‘earlySignal’
[17:02:29.105]   - Field: ‘lazy’
[17:02:29.105]   - Field: ‘state’
[17:02:29.105] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:29.105] - Launch lazy future ...
[17:02:29.105] Packages needed by the future expression (n = 0): <none>
[17:02:29.105] Packages needed by future strategies (n = 0): <none>
[17:02:29.106] {
[17:02:29.106]     {
[17:02:29.106]         {
[17:02:29.106]             ...future.startTime <- base::Sys.time()
[17:02:29.106]             {
[17:02:29.106]                 {
[17:02:29.106]                   {
[17:02:29.106]                     base::local({
[17:02:29.106]                       has_future <- base::requireNamespace("future", 
[17:02:29.106]                         quietly = TRUE)
[17:02:29.106]                       if (has_future) {
[17:02:29.106]                         ns <- base::getNamespace("future")
[17:02:29.106]                         version <- ns[[".package"]][["version"]]
[17:02:29.106]                         if (is.null(version)) 
[17:02:29.106]                           version <- utils::packageVersion("future")
[17:02:29.106]                       }
[17:02:29.106]                       else {
[17:02:29.106]                         version <- NULL
[17:02:29.106]                       }
[17:02:29.106]                       if (!has_future || version < "1.8.0") {
[17:02:29.106]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.106]                           "", base::R.version$version.string), 
[17:02:29.106]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:29.106]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.106]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.106]                             "release", "version")], collapse = " "), 
[17:02:29.106]                           hostname = base::Sys.info()[["nodename"]])
[17:02:29.106]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.106]                           info)
[17:02:29.106]                         info <- base::paste(info, collapse = "; ")
[17:02:29.106]                         if (!has_future) {
[17:02:29.106]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.106]                             info)
[17:02:29.106]                         }
[17:02:29.106]                         else {
[17:02:29.106]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.106]                             info, version)
[17:02:29.106]                         }
[17:02:29.106]                         base::stop(msg)
[17:02:29.106]                       }
[17:02:29.106]                     })
[17:02:29.106]                   }
[17:02:29.106]                   ...future.strategy.old <- future::plan("list")
[17:02:29.106]                   options(future.plan = NULL)
[17:02:29.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.106]                 }
[17:02:29.106]                 ...future.workdir <- getwd()
[17:02:29.106]             }
[17:02:29.106]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.106]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.106]         }
[17:02:29.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.106]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.106]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.106]             base::names(...future.oldOptions))
[17:02:29.106]     }
[17:02:29.106]     if (FALSE) {
[17:02:29.106]     }
[17:02:29.106]     else {
[17:02:29.106]         if (TRUE) {
[17:02:29.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.106]                 open = "w")
[17:02:29.106]         }
[17:02:29.106]         else {
[17:02:29.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.106]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.106]         }
[17:02:29.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.106]             base::sink(type = "output", split = FALSE)
[17:02:29.106]             base::close(...future.stdout)
[17:02:29.106]         }, add = TRUE)
[17:02:29.106]     }
[17:02:29.106]     ...future.frame <- base::sys.nframe()
[17:02:29.106]     ...future.conditions <- base::list()
[17:02:29.106]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.106]     if (FALSE) {
[17:02:29.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.106]     }
[17:02:29.106]     ...future.result <- base::tryCatch({
[17:02:29.106]         base::withCallingHandlers({
[17:02:29.106]             ...future.value <- base::withVisible(base::local(2))
[17:02:29.106]             future::FutureResult(value = ...future.value$value, 
[17:02:29.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.106]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.106]                     ...future.globalenv.names))
[17:02:29.106]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.106]         }, condition = base::local({
[17:02:29.106]             c <- base::c
[17:02:29.106]             inherits <- base::inherits
[17:02:29.106]             invokeRestart <- base::invokeRestart
[17:02:29.106]             length <- base::length
[17:02:29.106]             list <- base::list
[17:02:29.106]             seq.int <- base::seq.int
[17:02:29.106]             signalCondition <- base::signalCondition
[17:02:29.106]             sys.calls <- base::sys.calls
[17:02:29.106]             `[[` <- base::`[[`
[17:02:29.106]             `+` <- base::`+`
[17:02:29.106]             `<<-` <- base::`<<-`
[17:02:29.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.106]                   3L)]
[17:02:29.106]             }
[17:02:29.106]             function(cond) {
[17:02:29.106]                 is_error <- inherits(cond, "error")
[17:02:29.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.106]                   NULL)
[17:02:29.106]                 if (is_error) {
[17:02:29.106]                   sessionInformation <- function() {
[17:02:29.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.106]                       search = base::search(), system = base::Sys.info())
[17:02:29.106]                   }
[17:02:29.106]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.106]                     cond$call), session = sessionInformation(), 
[17:02:29.106]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.106]                   signalCondition(cond)
[17:02:29.106]                 }
[17:02:29.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.106]                 "immediateCondition"))) {
[17:02:29.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.106]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.106]                   if (TRUE && !signal) {
[17:02:29.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.106]                     {
[17:02:29.106]                       inherits <- base::inherits
[17:02:29.106]                       invokeRestart <- base::invokeRestart
[17:02:29.106]                       is.null <- base::is.null
[17:02:29.106]                       muffled <- FALSE
[17:02:29.106]                       if (inherits(cond, "message")) {
[17:02:29.106]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.106]                         if (muffled) 
[17:02:29.106]                           invokeRestart("muffleMessage")
[17:02:29.106]                       }
[17:02:29.106]                       else if (inherits(cond, "warning")) {
[17:02:29.106]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.106]                         if (muffled) 
[17:02:29.106]                           invokeRestart("muffleWarning")
[17:02:29.106]                       }
[17:02:29.106]                       else if (inherits(cond, "condition")) {
[17:02:29.106]                         if (!is.null(pattern)) {
[17:02:29.106]                           computeRestarts <- base::computeRestarts
[17:02:29.106]                           grepl <- base::grepl
[17:02:29.106]                           restarts <- computeRestarts(cond)
[17:02:29.106]                           for (restart in restarts) {
[17:02:29.106]                             name <- restart$name
[17:02:29.106]                             if (is.null(name)) 
[17:02:29.106]                               next
[17:02:29.106]                             if (!grepl(pattern, name)) 
[17:02:29.106]                               next
[17:02:29.106]                             invokeRestart(restart)
[17:02:29.106]                             muffled <- TRUE
[17:02:29.106]                             break
[17:02:29.106]                           }
[17:02:29.106]                         }
[17:02:29.106]                       }
[17:02:29.106]                       invisible(muffled)
[17:02:29.106]                     }
[17:02:29.106]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.106]                   }
[17:02:29.106]                 }
[17:02:29.106]                 else {
[17:02:29.106]                   if (TRUE) {
[17:02:29.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.106]                     {
[17:02:29.106]                       inherits <- base::inherits
[17:02:29.106]                       invokeRestart <- base::invokeRestart
[17:02:29.106]                       is.null <- base::is.null
[17:02:29.106]                       muffled <- FALSE
[17:02:29.106]                       if (inherits(cond, "message")) {
[17:02:29.106]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.106]                         if (muffled) 
[17:02:29.106]                           invokeRestart("muffleMessage")
[17:02:29.106]                       }
[17:02:29.106]                       else if (inherits(cond, "warning")) {
[17:02:29.106]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.106]                         if (muffled) 
[17:02:29.106]                           invokeRestart("muffleWarning")
[17:02:29.106]                       }
[17:02:29.106]                       else if (inherits(cond, "condition")) {
[17:02:29.106]                         if (!is.null(pattern)) {
[17:02:29.106]                           computeRestarts <- base::computeRestarts
[17:02:29.106]                           grepl <- base::grepl
[17:02:29.106]                           restarts <- computeRestarts(cond)
[17:02:29.106]                           for (restart in restarts) {
[17:02:29.106]                             name <- restart$name
[17:02:29.106]                             if (is.null(name)) 
[17:02:29.106]                               next
[17:02:29.106]                             if (!grepl(pattern, name)) 
[17:02:29.106]                               next
[17:02:29.106]                             invokeRestart(restart)
[17:02:29.106]                             muffled <- TRUE
[17:02:29.106]                             break
[17:02:29.106]                           }
[17:02:29.106]                         }
[17:02:29.106]                       }
[17:02:29.106]                       invisible(muffled)
[17:02:29.106]                     }
[17:02:29.106]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.106]                   }
[17:02:29.106]                 }
[17:02:29.106]             }
[17:02:29.106]         }))
[17:02:29.106]     }, error = function(ex) {
[17:02:29.106]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.106]                 ...future.rng), started = ...future.startTime, 
[17:02:29.106]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.106]             version = "1.8"), class = "FutureResult")
[17:02:29.106]     }, finally = {
[17:02:29.106]         if (!identical(...future.workdir, getwd())) 
[17:02:29.106]             setwd(...future.workdir)
[17:02:29.106]         {
[17:02:29.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.106]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.106]             }
[17:02:29.106]             base::options(...future.oldOptions)
[17:02:29.106]             if (.Platform$OS.type == "windows") {
[17:02:29.106]                 old_names <- names(...future.oldEnvVars)
[17:02:29.106]                 envs <- base::Sys.getenv()
[17:02:29.106]                 names <- names(envs)
[17:02:29.106]                 common <- intersect(names, old_names)
[17:02:29.106]                 added <- setdiff(names, old_names)
[17:02:29.106]                 removed <- setdiff(old_names, names)
[17:02:29.106]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.106]                   envs[common]]
[17:02:29.106]                 NAMES <- toupper(changed)
[17:02:29.106]                 args <- list()
[17:02:29.106]                 for (kk in seq_along(NAMES)) {
[17:02:29.106]                   name <- changed[[kk]]
[17:02:29.106]                   NAME <- NAMES[[kk]]
[17:02:29.106]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.106]                     next
[17:02:29.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.106]                 }
[17:02:29.106]                 NAMES <- toupper(added)
[17:02:29.106]                 for (kk in seq_along(NAMES)) {
[17:02:29.106]                   name <- added[[kk]]
[17:02:29.106]                   NAME <- NAMES[[kk]]
[17:02:29.106]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.106]                     next
[17:02:29.106]                   args[[name]] <- ""
[17:02:29.106]                 }
[17:02:29.106]                 NAMES <- toupper(removed)
[17:02:29.106]                 for (kk in seq_along(NAMES)) {
[17:02:29.106]                   name <- removed[[kk]]
[17:02:29.106]                   NAME <- NAMES[[kk]]
[17:02:29.106]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.106]                     next
[17:02:29.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.106]                 }
[17:02:29.106]                 if (length(args) > 0) 
[17:02:29.106]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.106]             }
[17:02:29.106]             else {
[17:02:29.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.106]             }
[17:02:29.106]             {
[17:02:29.106]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.106]                   0L) {
[17:02:29.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.106]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.106]                   base::options(opts)
[17:02:29.106]                 }
[17:02:29.106]                 {
[17:02:29.106]                   {
[17:02:29.106]                     NULL
[17:02:29.106]                     RNGkind("Mersenne-Twister")
[17:02:29.106]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:29.106]                       inherits = FALSE)
[17:02:29.106]                   }
[17:02:29.106]                   options(future.plan = NULL)
[17:02:29.106]                   if (is.na(NA_character_)) 
[17:02:29.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.106]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.106]                     .init = FALSE)
[17:02:29.106]                 }
[17:02:29.106]             }
[17:02:29.106]         }
[17:02:29.106]     })
[17:02:29.106]     if (TRUE) {
[17:02:29.106]         base::sink(type = "output", split = FALSE)
[17:02:29.106]         if (TRUE) {
[17:02:29.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.106]         }
[17:02:29.106]         else {
[17:02:29.106]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.106]         }
[17:02:29.106]         base::close(...future.stdout)
[17:02:29.106]         ...future.stdout <- NULL
[17:02:29.106]     }
[17:02:29.106]     ...future.result$conditions <- ...future.conditions
[17:02:29.106]     ...future.result$finished <- base::Sys.time()
[17:02:29.106]     ...future.result
[17:02:29.106] }
[17:02:29.107] plan(): Setting new future strategy stack:
[17:02:29.108] List of future strategies:
[17:02:29.108] 1. sequential:
[17:02:29.108]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.108]    - tweaked: FALSE
[17:02:29.108]    - call: NULL
[17:02:29.108] plan(): nbrOfWorkers() = 1
[17:02:29.109] plan(): Setting new future strategy stack:
[17:02:29.109] List of future strategies:
[17:02:29.109] 1. sequential:
[17:02:29.109]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.109]    - tweaked: FALSE
[17:02:29.109]    - call: plan(strategy)
[17:02:29.109] plan(): nbrOfWorkers() = 1
[17:02:29.109] SequentialFuture started (and completed)
[17:02:29.109] - Launch lazy future ... done
[17:02:29.110] run() for ‘SequentialFuture’ ... done
[17:02:29.110] getGlobalsAndPackages() ...
[17:02:29.110] Searching for globals...
[17:02:29.110] 
[17:02:29.110] Searching for globals ... DONE
[17:02:29.110] - globals: [0] <none>
[17:02:29.110] getGlobalsAndPackages() ... DONE
[17:02:29.111] run() for ‘Future’ ...
[17:02:29.111] - state: ‘created’
[17:02:29.111] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:29.111] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:29.111] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:29.111]   - Field: ‘label’
[17:02:29.111]   - Field: ‘local’
[17:02:29.111]   - Field: ‘owner’
[17:02:29.112]   - Field: ‘envir’
[17:02:29.112]   - Field: ‘packages’
[17:02:29.112]   - Field: ‘gc’
[17:02:29.112]   - Field: ‘conditions’
[17:02:29.112]   - Field: ‘expr’
[17:02:29.112]   - Field: ‘uuid’
[17:02:29.112]   - Field: ‘seed’
[17:02:29.112]   - Field: ‘version’
[17:02:29.112]   - Field: ‘result’
[17:02:29.112]   - Field: ‘asynchronous’
[17:02:29.112]   - Field: ‘calls’
[17:02:29.113]   - Field: ‘globals’
[17:02:29.113]   - Field: ‘stdout’
[17:02:29.113]   - Field: ‘earlySignal’
[17:02:29.113]   - Field: ‘lazy’
[17:02:29.113]   - Field: ‘state’
[17:02:29.113] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:29.113] - Launch lazy future ...
[17:02:29.113] Packages needed by the future expression (n = 0): <none>
[17:02:29.113] Packages needed by future strategies (n = 0): <none>
[17:02:29.114] {
[17:02:29.114]     {
[17:02:29.114]         {
[17:02:29.114]             ...future.startTime <- base::Sys.time()
[17:02:29.114]             {
[17:02:29.114]                 {
[17:02:29.114]                   {
[17:02:29.114]                     base::local({
[17:02:29.114]                       has_future <- base::requireNamespace("future", 
[17:02:29.114]                         quietly = TRUE)
[17:02:29.114]                       if (has_future) {
[17:02:29.114]                         ns <- base::getNamespace("future")
[17:02:29.114]                         version <- ns[[".package"]][["version"]]
[17:02:29.114]                         if (is.null(version)) 
[17:02:29.114]                           version <- utils::packageVersion("future")
[17:02:29.114]                       }
[17:02:29.114]                       else {
[17:02:29.114]                         version <- NULL
[17:02:29.114]                       }
[17:02:29.114]                       if (!has_future || version < "1.8.0") {
[17:02:29.114]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.114]                           "", base::R.version$version.string), 
[17:02:29.114]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:29.114]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.114]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.114]                             "release", "version")], collapse = " "), 
[17:02:29.114]                           hostname = base::Sys.info()[["nodename"]])
[17:02:29.114]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.114]                           info)
[17:02:29.114]                         info <- base::paste(info, collapse = "; ")
[17:02:29.114]                         if (!has_future) {
[17:02:29.114]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.114]                             info)
[17:02:29.114]                         }
[17:02:29.114]                         else {
[17:02:29.114]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.114]                             info, version)
[17:02:29.114]                         }
[17:02:29.114]                         base::stop(msg)
[17:02:29.114]                       }
[17:02:29.114]                     })
[17:02:29.114]                   }
[17:02:29.114]                   ...future.strategy.old <- future::plan("list")
[17:02:29.114]                   options(future.plan = NULL)
[17:02:29.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.114]                 }
[17:02:29.114]                 ...future.workdir <- getwd()
[17:02:29.114]             }
[17:02:29.114]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.114]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.114]         }
[17:02:29.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.114]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.114]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.114]             base::names(...future.oldOptions))
[17:02:29.114]     }
[17:02:29.114]     if (FALSE) {
[17:02:29.114]     }
[17:02:29.114]     else {
[17:02:29.114]         if (TRUE) {
[17:02:29.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.114]                 open = "w")
[17:02:29.114]         }
[17:02:29.114]         else {
[17:02:29.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.114]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.114]         }
[17:02:29.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.114]             base::sink(type = "output", split = FALSE)
[17:02:29.114]             base::close(...future.stdout)
[17:02:29.114]         }, add = TRUE)
[17:02:29.114]     }
[17:02:29.114]     ...future.frame <- base::sys.nframe()
[17:02:29.114]     ...future.conditions <- base::list()
[17:02:29.114]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.114]     if (FALSE) {
[17:02:29.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.114]     }
[17:02:29.114]     ...future.result <- base::tryCatch({
[17:02:29.114]         base::withCallingHandlers({
[17:02:29.114]             ...future.value <- base::withVisible(base::local(NULL))
[17:02:29.114]             future::FutureResult(value = ...future.value$value, 
[17:02:29.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.114]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.114]                     ...future.globalenv.names))
[17:02:29.114]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.114]         }, condition = base::local({
[17:02:29.114]             c <- base::c
[17:02:29.114]             inherits <- base::inherits
[17:02:29.114]             invokeRestart <- base::invokeRestart
[17:02:29.114]             length <- base::length
[17:02:29.114]             list <- base::list
[17:02:29.114]             seq.int <- base::seq.int
[17:02:29.114]             signalCondition <- base::signalCondition
[17:02:29.114]             sys.calls <- base::sys.calls
[17:02:29.114]             `[[` <- base::`[[`
[17:02:29.114]             `+` <- base::`+`
[17:02:29.114]             `<<-` <- base::`<<-`
[17:02:29.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.114]                   3L)]
[17:02:29.114]             }
[17:02:29.114]             function(cond) {
[17:02:29.114]                 is_error <- inherits(cond, "error")
[17:02:29.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.114]                   NULL)
[17:02:29.114]                 if (is_error) {
[17:02:29.114]                   sessionInformation <- function() {
[17:02:29.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.114]                       search = base::search(), system = base::Sys.info())
[17:02:29.114]                   }
[17:02:29.114]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.114]                     cond$call), session = sessionInformation(), 
[17:02:29.114]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.114]                   signalCondition(cond)
[17:02:29.114]                 }
[17:02:29.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.114]                 "immediateCondition"))) {
[17:02:29.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.114]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.114]                   if (TRUE && !signal) {
[17:02:29.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.114]                     {
[17:02:29.114]                       inherits <- base::inherits
[17:02:29.114]                       invokeRestart <- base::invokeRestart
[17:02:29.114]                       is.null <- base::is.null
[17:02:29.114]                       muffled <- FALSE
[17:02:29.114]                       if (inherits(cond, "message")) {
[17:02:29.114]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.114]                         if (muffled) 
[17:02:29.114]                           invokeRestart("muffleMessage")
[17:02:29.114]                       }
[17:02:29.114]                       else if (inherits(cond, "warning")) {
[17:02:29.114]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.114]                         if (muffled) 
[17:02:29.114]                           invokeRestart("muffleWarning")
[17:02:29.114]                       }
[17:02:29.114]                       else if (inherits(cond, "condition")) {
[17:02:29.114]                         if (!is.null(pattern)) {
[17:02:29.114]                           computeRestarts <- base::computeRestarts
[17:02:29.114]                           grepl <- base::grepl
[17:02:29.114]                           restarts <- computeRestarts(cond)
[17:02:29.114]                           for (restart in restarts) {
[17:02:29.114]                             name <- restart$name
[17:02:29.114]                             if (is.null(name)) 
[17:02:29.114]                               next
[17:02:29.114]                             if (!grepl(pattern, name)) 
[17:02:29.114]                               next
[17:02:29.114]                             invokeRestart(restart)
[17:02:29.114]                             muffled <- TRUE
[17:02:29.114]                             break
[17:02:29.114]                           }
[17:02:29.114]                         }
[17:02:29.114]                       }
[17:02:29.114]                       invisible(muffled)
[17:02:29.114]                     }
[17:02:29.114]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.114]                   }
[17:02:29.114]                 }
[17:02:29.114]                 else {
[17:02:29.114]                   if (TRUE) {
[17:02:29.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.114]                     {
[17:02:29.114]                       inherits <- base::inherits
[17:02:29.114]                       invokeRestart <- base::invokeRestart
[17:02:29.114]                       is.null <- base::is.null
[17:02:29.114]                       muffled <- FALSE
[17:02:29.114]                       if (inherits(cond, "message")) {
[17:02:29.114]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.114]                         if (muffled) 
[17:02:29.114]                           invokeRestart("muffleMessage")
[17:02:29.114]                       }
[17:02:29.114]                       else if (inherits(cond, "warning")) {
[17:02:29.114]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.114]                         if (muffled) 
[17:02:29.114]                           invokeRestart("muffleWarning")
[17:02:29.114]                       }
[17:02:29.114]                       else if (inherits(cond, "condition")) {
[17:02:29.114]                         if (!is.null(pattern)) {
[17:02:29.114]                           computeRestarts <- base::computeRestarts
[17:02:29.114]                           grepl <- base::grepl
[17:02:29.114]                           restarts <- computeRestarts(cond)
[17:02:29.114]                           for (restart in restarts) {
[17:02:29.114]                             name <- restart$name
[17:02:29.114]                             if (is.null(name)) 
[17:02:29.114]                               next
[17:02:29.114]                             if (!grepl(pattern, name)) 
[17:02:29.114]                               next
[17:02:29.114]                             invokeRestart(restart)
[17:02:29.114]                             muffled <- TRUE
[17:02:29.114]                             break
[17:02:29.114]                           }
[17:02:29.114]                         }
[17:02:29.114]                       }
[17:02:29.114]                       invisible(muffled)
[17:02:29.114]                     }
[17:02:29.114]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.114]                   }
[17:02:29.114]                 }
[17:02:29.114]             }
[17:02:29.114]         }))
[17:02:29.114]     }, error = function(ex) {
[17:02:29.114]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.114]                 ...future.rng), started = ...future.startTime, 
[17:02:29.114]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.114]             version = "1.8"), class = "FutureResult")
[17:02:29.114]     }, finally = {
[17:02:29.114]         if (!identical(...future.workdir, getwd())) 
[17:02:29.114]             setwd(...future.workdir)
[17:02:29.114]         {
[17:02:29.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.114]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.114]             }
[17:02:29.114]             base::options(...future.oldOptions)
[17:02:29.114]             if (.Platform$OS.type == "windows") {
[17:02:29.114]                 old_names <- names(...future.oldEnvVars)
[17:02:29.114]                 envs <- base::Sys.getenv()
[17:02:29.114]                 names <- names(envs)
[17:02:29.114]                 common <- intersect(names, old_names)
[17:02:29.114]                 added <- setdiff(names, old_names)
[17:02:29.114]                 removed <- setdiff(old_names, names)
[17:02:29.114]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.114]                   envs[common]]
[17:02:29.114]                 NAMES <- toupper(changed)
[17:02:29.114]                 args <- list()
[17:02:29.114]                 for (kk in seq_along(NAMES)) {
[17:02:29.114]                   name <- changed[[kk]]
[17:02:29.114]                   NAME <- NAMES[[kk]]
[17:02:29.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.114]                     next
[17:02:29.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.114]                 }
[17:02:29.114]                 NAMES <- toupper(added)
[17:02:29.114]                 for (kk in seq_along(NAMES)) {
[17:02:29.114]                   name <- added[[kk]]
[17:02:29.114]                   NAME <- NAMES[[kk]]
[17:02:29.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.114]                     next
[17:02:29.114]                   args[[name]] <- ""
[17:02:29.114]                 }
[17:02:29.114]                 NAMES <- toupper(removed)
[17:02:29.114]                 for (kk in seq_along(NAMES)) {
[17:02:29.114]                   name <- removed[[kk]]
[17:02:29.114]                   NAME <- NAMES[[kk]]
[17:02:29.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.114]                     next
[17:02:29.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.114]                 }
[17:02:29.114]                 if (length(args) > 0) 
[17:02:29.114]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.114]             }
[17:02:29.114]             else {
[17:02:29.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.114]             }
[17:02:29.114]             {
[17:02:29.114]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.114]                   0L) {
[17:02:29.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.114]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.114]                   base::options(opts)
[17:02:29.114]                 }
[17:02:29.114]                 {
[17:02:29.114]                   {
[17:02:29.114]                     NULL
[17:02:29.114]                     RNGkind("Mersenne-Twister")
[17:02:29.114]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:29.114]                       inherits = FALSE)
[17:02:29.114]                   }
[17:02:29.114]                   options(future.plan = NULL)
[17:02:29.114]                   if (is.na(NA_character_)) 
[17:02:29.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.114]                     .init = FALSE)
[17:02:29.114]                 }
[17:02:29.114]             }
[17:02:29.114]         }
[17:02:29.114]     })
[17:02:29.114]     if (TRUE) {
[17:02:29.114]         base::sink(type = "output", split = FALSE)
[17:02:29.114]         if (TRUE) {
[17:02:29.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.114]         }
[17:02:29.114]         else {
[17:02:29.114]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.114]         }
[17:02:29.114]         base::close(...future.stdout)
[17:02:29.114]         ...future.stdout <- NULL
[17:02:29.114]     }
[17:02:29.114]     ...future.result$conditions <- ...future.conditions
[17:02:29.114]     ...future.result$finished <- base::Sys.time()
[17:02:29.114]     ...future.result
[17:02:29.114] }
[17:02:29.117] plan(): Setting new future strategy stack:
[17:02:29.117] List of future strategies:
[17:02:29.117] 1. sequential:
[17:02:29.117]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.117]    - tweaked: FALSE
[17:02:29.117]    - call: NULL
[17:02:29.117] plan(): nbrOfWorkers() = 1
[17:02:29.118] plan(): Setting new future strategy stack:
[17:02:29.118] List of future strategies:
[17:02:29.118] 1. sequential:
[17:02:29.118]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.118]    - tweaked: FALSE
[17:02:29.118]    - call: plan(strategy)
[17:02:29.119] plan(): nbrOfWorkers() = 1
[17:02:29.119] SequentialFuture started (and completed)
[17:02:29.119] - Launch lazy future ... done
[17:02:29.119] run() for ‘SequentialFuture’ ... done
[17:02:29.119] getGlobalsAndPackages() ...
[17:02:29.119] Searching for globals...
[17:02:29.120] - globals found: [1] ‘{’
[17:02:29.120] Searching for globals ... DONE
[17:02:29.120] Resolving globals: FALSE
[17:02:29.120] 
[17:02:29.121] 
[17:02:29.121] getGlobalsAndPackages() ... DONE
[17:02:29.121] run() for ‘Future’ ...
[17:02:29.121] - state: ‘created’
[17:02:29.121] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:29.121] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:29.121] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:29.122]   - Field: ‘label’
[17:02:29.122]   - Field: ‘local’
[17:02:29.122]   - Field: ‘owner’
[17:02:29.122]   - Field: ‘envir’
[17:02:29.122]   - Field: ‘packages’
[17:02:29.122]   - Field: ‘gc’
[17:02:29.122]   - Field: ‘conditions’
[17:02:29.122]   - Field: ‘expr’
[17:02:29.122]   - Field: ‘uuid’
[17:02:29.122]   - Field: ‘seed’
[17:02:29.122]   - Field: ‘version’
[17:02:29.122]   - Field: ‘result’
[17:02:29.123]   - Field: ‘asynchronous’
[17:02:29.123]   - Field: ‘calls’
[17:02:29.123]   - Field: ‘globals’
[17:02:29.123]   - Field: ‘stdout’
[17:02:29.123]   - Field: ‘earlySignal’
[17:02:29.123]   - Field: ‘lazy’
[17:02:29.123]   - Field: ‘state’
[17:02:29.123] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:29.123] - Launch lazy future ...
[17:02:29.123] Packages needed by the future expression (n = 0): <none>
[17:02:29.124] Packages needed by future strategies (n = 0): <none>
[17:02:29.124] {
[17:02:29.124]     {
[17:02:29.124]         {
[17:02:29.124]             ...future.startTime <- base::Sys.time()
[17:02:29.124]             {
[17:02:29.124]                 {
[17:02:29.124]                   {
[17:02:29.124]                     base::local({
[17:02:29.124]                       has_future <- base::requireNamespace("future", 
[17:02:29.124]                         quietly = TRUE)
[17:02:29.124]                       if (has_future) {
[17:02:29.124]                         ns <- base::getNamespace("future")
[17:02:29.124]                         version <- ns[[".package"]][["version"]]
[17:02:29.124]                         if (is.null(version)) 
[17:02:29.124]                           version <- utils::packageVersion("future")
[17:02:29.124]                       }
[17:02:29.124]                       else {
[17:02:29.124]                         version <- NULL
[17:02:29.124]                       }
[17:02:29.124]                       if (!has_future || version < "1.8.0") {
[17:02:29.124]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.124]                           "", base::R.version$version.string), 
[17:02:29.124]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:29.124]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.124]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.124]                             "release", "version")], collapse = " "), 
[17:02:29.124]                           hostname = base::Sys.info()[["nodename"]])
[17:02:29.124]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.124]                           info)
[17:02:29.124]                         info <- base::paste(info, collapse = "; ")
[17:02:29.124]                         if (!has_future) {
[17:02:29.124]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.124]                             info)
[17:02:29.124]                         }
[17:02:29.124]                         else {
[17:02:29.124]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.124]                             info, version)
[17:02:29.124]                         }
[17:02:29.124]                         base::stop(msg)
[17:02:29.124]                       }
[17:02:29.124]                     })
[17:02:29.124]                   }
[17:02:29.124]                   ...future.strategy.old <- future::plan("list")
[17:02:29.124]                   options(future.plan = NULL)
[17:02:29.124]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.124]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.124]                 }
[17:02:29.124]                 ...future.workdir <- getwd()
[17:02:29.124]             }
[17:02:29.124]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.124]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.124]         }
[17:02:29.124]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.124]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.124]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.124]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.124]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.124]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.124]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.124]             base::names(...future.oldOptions))
[17:02:29.124]     }
[17:02:29.124]     if (FALSE) {
[17:02:29.124]     }
[17:02:29.124]     else {
[17:02:29.124]         if (TRUE) {
[17:02:29.124]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.124]                 open = "w")
[17:02:29.124]         }
[17:02:29.124]         else {
[17:02:29.124]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.124]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.124]         }
[17:02:29.124]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.124]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.124]             base::sink(type = "output", split = FALSE)
[17:02:29.124]             base::close(...future.stdout)
[17:02:29.124]         }, add = TRUE)
[17:02:29.124]     }
[17:02:29.124]     ...future.frame <- base::sys.nframe()
[17:02:29.124]     ...future.conditions <- base::list()
[17:02:29.124]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.124]     if (FALSE) {
[17:02:29.124]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.124]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.124]     }
[17:02:29.124]     ...future.result <- base::tryCatch({
[17:02:29.124]         base::withCallingHandlers({
[17:02:29.124]             ...future.value <- base::withVisible(base::local({
[17:02:29.124]                 4
[17:02:29.124]             }))
[17:02:29.124]             future::FutureResult(value = ...future.value$value, 
[17:02:29.124]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.124]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.124]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.124]                     ...future.globalenv.names))
[17:02:29.124]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.124]         }, condition = base::local({
[17:02:29.124]             c <- base::c
[17:02:29.124]             inherits <- base::inherits
[17:02:29.124]             invokeRestart <- base::invokeRestart
[17:02:29.124]             length <- base::length
[17:02:29.124]             list <- base::list
[17:02:29.124]             seq.int <- base::seq.int
[17:02:29.124]             signalCondition <- base::signalCondition
[17:02:29.124]             sys.calls <- base::sys.calls
[17:02:29.124]             `[[` <- base::`[[`
[17:02:29.124]             `+` <- base::`+`
[17:02:29.124]             `<<-` <- base::`<<-`
[17:02:29.124]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.124]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.124]                   3L)]
[17:02:29.124]             }
[17:02:29.124]             function(cond) {
[17:02:29.124]                 is_error <- inherits(cond, "error")
[17:02:29.124]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.124]                   NULL)
[17:02:29.124]                 if (is_error) {
[17:02:29.124]                   sessionInformation <- function() {
[17:02:29.124]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.124]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.124]                       search = base::search(), system = base::Sys.info())
[17:02:29.124]                   }
[17:02:29.124]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.124]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.124]                     cond$call), session = sessionInformation(), 
[17:02:29.124]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.124]                   signalCondition(cond)
[17:02:29.124]                 }
[17:02:29.124]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.124]                 "immediateCondition"))) {
[17:02:29.124]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.124]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.124]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.124]                   if (TRUE && !signal) {
[17:02:29.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.124]                     {
[17:02:29.124]                       inherits <- base::inherits
[17:02:29.124]                       invokeRestart <- base::invokeRestart
[17:02:29.124]                       is.null <- base::is.null
[17:02:29.124]                       muffled <- FALSE
[17:02:29.124]                       if (inherits(cond, "message")) {
[17:02:29.124]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.124]                         if (muffled) 
[17:02:29.124]                           invokeRestart("muffleMessage")
[17:02:29.124]                       }
[17:02:29.124]                       else if (inherits(cond, "warning")) {
[17:02:29.124]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.124]                         if (muffled) 
[17:02:29.124]                           invokeRestart("muffleWarning")
[17:02:29.124]                       }
[17:02:29.124]                       else if (inherits(cond, "condition")) {
[17:02:29.124]                         if (!is.null(pattern)) {
[17:02:29.124]                           computeRestarts <- base::computeRestarts
[17:02:29.124]                           grepl <- base::grepl
[17:02:29.124]                           restarts <- computeRestarts(cond)
[17:02:29.124]                           for (restart in restarts) {
[17:02:29.124]                             name <- restart$name
[17:02:29.124]                             if (is.null(name)) 
[17:02:29.124]                               next
[17:02:29.124]                             if (!grepl(pattern, name)) 
[17:02:29.124]                               next
[17:02:29.124]                             invokeRestart(restart)
[17:02:29.124]                             muffled <- TRUE
[17:02:29.124]                             break
[17:02:29.124]                           }
[17:02:29.124]                         }
[17:02:29.124]                       }
[17:02:29.124]                       invisible(muffled)
[17:02:29.124]                     }
[17:02:29.124]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.124]                   }
[17:02:29.124]                 }
[17:02:29.124]                 else {
[17:02:29.124]                   if (TRUE) {
[17:02:29.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.124]                     {
[17:02:29.124]                       inherits <- base::inherits
[17:02:29.124]                       invokeRestart <- base::invokeRestart
[17:02:29.124]                       is.null <- base::is.null
[17:02:29.124]                       muffled <- FALSE
[17:02:29.124]                       if (inherits(cond, "message")) {
[17:02:29.124]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.124]                         if (muffled) 
[17:02:29.124]                           invokeRestart("muffleMessage")
[17:02:29.124]                       }
[17:02:29.124]                       else if (inherits(cond, "warning")) {
[17:02:29.124]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.124]                         if (muffled) 
[17:02:29.124]                           invokeRestart("muffleWarning")
[17:02:29.124]                       }
[17:02:29.124]                       else if (inherits(cond, "condition")) {
[17:02:29.124]                         if (!is.null(pattern)) {
[17:02:29.124]                           computeRestarts <- base::computeRestarts
[17:02:29.124]                           grepl <- base::grepl
[17:02:29.124]                           restarts <- computeRestarts(cond)
[17:02:29.124]                           for (restart in restarts) {
[17:02:29.124]                             name <- restart$name
[17:02:29.124]                             if (is.null(name)) 
[17:02:29.124]                               next
[17:02:29.124]                             if (!grepl(pattern, name)) 
[17:02:29.124]                               next
[17:02:29.124]                             invokeRestart(restart)
[17:02:29.124]                             muffled <- TRUE
[17:02:29.124]                             break
[17:02:29.124]                           }
[17:02:29.124]                         }
[17:02:29.124]                       }
[17:02:29.124]                       invisible(muffled)
[17:02:29.124]                     }
[17:02:29.124]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.124]                   }
[17:02:29.124]                 }
[17:02:29.124]             }
[17:02:29.124]         }))
[17:02:29.124]     }, error = function(ex) {
[17:02:29.124]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.124]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.124]                 ...future.rng), started = ...future.startTime, 
[17:02:29.124]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.124]             version = "1.8"), class = "FutureResult")
[17:02:29.124]     }, finally = {
[17:02:29.124]         if (!identical(...future.workdir, getwd())) 
[17:02:29.124]             setwd(...future.workdir)
[17:02:29.124]         {
[17:02:29.124]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.124]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.124]             }
[17:02:29.124]             base::options(...future.oldOptions)
[17:02:29.124]             if (.Platform$OS.type == "windows") {
[17:02:29.124]                 old_names <- names(...future.oldEnvVars)
[17:02:29.124]                 envs <- base::Sys.getenv()
[17:02:29.124]                 names <- names(envs)
[17:02:29.124]                 common <- intersect(names, old_names)
[17:02:29.124]                 added <- setdiff(names, old_names)
[17:02:29.124]                 removed <- setdiff(old_names, names)
[17:02:29.124]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.124]                   envs[common]]
[17:02:29.124]                 NAMES <- toupper(changed)
[17:02:29.124]                 args <- list()
[17:02:29.124]                 for (kk in seq_along(NAMES)) {
[17:02:29.124]                   name <- changed[[kk]]
[17:02:29.124]                   NAME <- NAMES[[kk]]
[17:02:29.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.124]                     next
[17:02:29.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.124]                 }
[17:02:29.124]                 NAMES <- toupper(added)
[17:02:29.124]                 for (kk in seq_along(NAMES)) {
[17:02:29.124]                   name <- added[[kk]]
[17:02:29.124]                   NAME <- NAMES[[kk]]
[17:02:29.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.124]                     next
[17:02:29.124]                   args[[name]] <- ""
[17:02:29.124]                 }
[17:02:29.124]                 NAMES <- toupper(removed)
[17:02:29.124]                 for (kk in seq_along(NAMES)) {
[17:02:29.124]                   name <- removed[[kk]]
[17:02:29.124]                   NAME <- NAMES[[kk]]
[17:02:29.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.124]                     next
[17:02:29.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.124]                 }
[17:02:29.124]                 if (length(args) > 0) 
[17:02:29.124]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.124]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.124]             }
[17:02:29.124]             else {
[17:02:29.124]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.124]             }
[17:02:29.124]             {
[17:02:29.124]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.124]                   0L) {
[17:02:29.124]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.124]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.124]                   base::options(opts)
[17:02:29.124]                 }
[17:02:29.124]                 {
[17:02:29.124]                   {
[17:02:29.124]                     NULL
[17:02:29.124]                     RNGkind("Mersenne-Twister")
[17:02:29.124]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:29.124]                       inherits = FALSE)
[17:02:29.124]                   }
[17:02:29.124]                   options(future.plan = NULL)
[17:02:29.124]                   if (is.na(NA_character_)) 
[17:02:29.124]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.124]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.124]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.124]                     .init = FALSE)
[17:02:29.124]                 }
[17:02:29.124]             }
[17:02:29.124]         }
[17:02:29.124]     })
[17:02:29.124]     if (TRUE) {
[17:02:29.124]         base::sink(type = "output", split = FALSE)
[17:02:29.124]         if (TRUE) {
[17:02:29.124]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.124]         }
[17:02:29.124]         else {
[17:02:29.124]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.124]         }
[17:02:29.124]         base::close(...future.stdout)
[17:02:29.124]         ...future.stdout <- NULL
[17:02:29.124]     }
[17:02:29.124]     ...future.result$conditions <- ...future.conditions
[17:02:29.124]     ...future.result$finished <- base::Sys.time()
[17:02:29.124]     ...future.result
[17:02:29.124] }
[17:02:29.126] plan(): Setting new future strategy stack:
[17:02:29.126] List of future strategies:
[17:02:29.126] 1. sequential:
[17:02:29.126]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.126]    - tweaked: FALSE
[17:02:29.126]    - call: NULL
[17:02:29.126] plan(): nbrOfWorkers() = 1
[17:02:29.127] plan(): Setting new future strategy stack:
[17:02:29.127] List of future strategies:
[17:02:29.127] 1. sequential:
[17:02:29.127]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.127]    - tweaked: FALSE
[17:02:29.127]    - call: plan(strategy)
[17:02:29.127] plan(): nbrOfWorkers() = 1
[17:02:29.127] SequentialFuture started (and completed)
[17:02:29.128] - Launch lazy future ... done
[17:02:29.128] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c7494b0028> 
Classes 'listenv', 'environment' <environment: 0x55c749043d00> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:02:29.131] resolved() for ‘SequentialFuture’ ...
[17:02:29.132] - state: ‘finished’
[17:02:29.132] - run: TRUE
[17:02:29.132] - result: ‘FutureResult’
[17:02:29.132] resolved() for ‘SequentialFuture’ ... done
[17:02:29.132] resolved() for ‘SequentialFuture’ ...
[17:02:29.132] - state: ‘finished’
[17:02:29.132] - run: TRUE
[17:02:29.132] - result: ‘FutureResult’
[17:02:29.132] resolved() for ‘SequentialFuture’ ... done
[17:02:29.132] resolved() for ‘SequentialFuture’ ...
[17:02:29.132] - state: ‘finished’
[17:02:29.133] - run: TRUE
[17:02:29.133] - result: ‘FutureResult’
[17:02:29.133] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:29.135] resolve() on list environment ...
[17:02:29.135]  recursive: 0
[17:02:29.136]  length: 6
[17:02:29.136]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:29.136] signalConditionsASAP(numeric, pos=1) ...
[17:02:29.137] - nx: 6
[17:02:29.137] - relay: TRUE
[17:02:29.137] - stdout: TRUE
[17:02:29.137] - signal: TRUE
[17:02:29.137] - resignal: FALSE
[17:02:29.137] - force: TRUE
[17:02:29.137] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.137] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.137]  - until=2
[17:02:29.137]  - relaying element #2
[17:02:29.137] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.137] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.138] signalConditionsASAP(NULL, pos=1) ... done
[17:02:29.138]  length: 5 (resolved future 1)
[17:02:29.138] resolved() for ‘SequentialFuture’ ...
[17:02:29.138] - state: ‘finished’
[17:02:29.138] - run: TRUE
[17:02:29.138] - result: ‘FutureResult’
[17:02:29.138] resolved() for ‘SequentialFuture’ ... done
[17:02:29.138] Future #2
[17:02:29.138] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:02:29.138] - nx: 6
[17:02:29.139] - relay: TRUE
[17:02:29.139] - stdout: TRUE
[17:02:29.139] - signal: TRUE
[17:02:29.139] - resignal: FALSE
[17:02:29.139] - force: TRUE
[17:02:29.139] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.139] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.139]  - until=2
[17:02:29.139]  - relaying element #2
[17:02:29.139] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.139] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.140] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:02:29.140]  length: 4 (resolved future 2)
[17:02:29.140] resolved() for ‘SequentialFuture’ ...
[17:02:29.140] - state: ‘finished’
[17:02:29.140] - run: TRUE
[17:02:29.140] - result: ‘FutureResult’
[17:02:29.140] resolved() for ‘SequentialFuture’ ... done
[17:02:29.140] Future #3
[17:02:29.140] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:02:29.140] - nx: 6
[17:02:29.141] - relay: TRUE
[17:02:29.141] - stdout: TRUE
[17:02:29.141] - signal: TRUE
[17:02:29.141] - resignal: FALSE
[17:02:29.141] - force: TRUE
[17:02:29.141] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.141] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.141]  - until=3
[17:02:29.141]  - relaying element #3
[17:02:29.141] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.141] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.142] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:02:29.142]  length: 3 (resolved future 3)
[17:02:29.142] resolved() for ‘SequentialFuture’ ...
[17:02:29.143] - state: ‘finished’
[17:02:29.143] - run: TRUE
[17:02:29.143] - result: ‘FutureResult’
[17:02:29.143] resolved() for ‘SequentialFuture’ ... done
[17:02:29.144] Future #4
[17:02:29.144] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:02:29.144] - nx: 6
[17:02:29.144] - relay: TRUE
[17:02:29.144] - stdout: TRUE
[17:02:29.144] - signal: TRUE
[17:02:29.144] - resignal: FALSE
[17:02:29.144] - force: TRUE
[17:02:29.144] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.144] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.144]  - until=4
[17:02:29.145]  - relaying element #4
[17:02:29.145] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.145] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.145] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:02:29.145]  length: 2 (resolved future 4)
[17:02:29.145] signalConditionsASAP(NULL, pos=5) ...
[17:02:29.145] - nx: 6
[17:02:29.145] - relay: TRUE
[17:02:29.145] - stdout: TRUE
[17:02:29.145] - signal: TRUE
[17:02:29.145] - resignal: FALSE
[17:02:29.146] - force: TRUE
[17:02:29.146] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.146] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.146]  - until=6
[17:02:29.146]  - relaying element #6
[17:02:29.146] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.146] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.146] signalConditionsASAP(NULL, pos=5) ... done
[17:02:29.146]  length: 1 (resolved future 5)
[17:02:29.146] signalConditionsASAP(numeric, pos=6) ...
[17:02:29.146] - nx: 6
[17:02:29.147] - relay: TRUE
[17:02:29.147] - stdout: TRUE
[17:02:29.147] - signal: TRUE
[17:02:29.147] - resignal: FALSE
[17:02:29.147] - force: TRUE
[17:02:29.147] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.147] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.147]  - until=6
[17:02:29.147] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.147] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.147] signalConditionsASAP(numeric, pos=6) ... done
[17:02:29.147]  length: 0 (resolved future 6)
[17:02:29.148] Relaying remaining futures
[17:02:29.148] signalConditionsASAP(NULL, pos=0) ...
[17:02:29.148] - nx: 6
[17:02:29.148] - relay: TRUE
[17:02:29.148] - stdout: TRUE
[17:02:29.148] - signal: TRUE
[17:02:29.148] - resignal: FALSE
[17:02:29.148] - force: TRUE
[17:02:29.148] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.148] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:29.148] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.148] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.149] signalConditionsASAP(NULL, pos=0) ... done
[17:02:29.149] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55c7497016c8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[17:02:29.151] plan(): Setting new future strategy stack:
[17:02:29.151] List of future strategies:
[17:02:29.151] 1. multicore:
[17:02:29.151]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:29.151]    - tweaked: FALSE
[17:02:29.151]    - call: plan(strategy)
[17:02:29.155] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:02:29.156] getGlobalsAndPackages() ...
[17:02:29.156] Searching for globals...
[17:02:29.156] 
[17:02:29.156] Searching for globals ... DONE
[17:02:29.156] - globals: [0] <none>
[17:02:29.156] getGlobalsAndPackages() ... DONE
[17:02:29.156] run() for ‘Future’ ...
[17:02:29.157] - state: ‘created’
[17:02:29.157] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:29.160] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:29.160] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:29.161]   - Field: ‘label’
[17:02:29.161]   - Field: ‘local’
[17:02:29.161]   - Field: ‘owner’
[17:02:29.161]   - Field: ‘envir’
[17:02:29.161]   - Field: ‘workers’
[17:02:29.161]   - Field: ‘packages’
[17:02:29.161]   - Field: ‘gc’
[17:02:29.161]   - Field: ‘job’
[17:02:29.161]   - Field: ‘conditions’
[17:02:29.161]   - Field: ‘expr’
[17:02:29.162]   - Field: ‘uuid’
[17:02:29.162]   - Field: ‘seed’
[17:02:29.162]   - Field: ‘version’
[17:02:29.162]   - Field: ‘result’
[17:02:29.162]   - Field: ‘asynchronous’
[17:02:29.162]   - Field: ‘calls’
[17:02:29.162]   - Field: ‘globals’
[17:02:29.162]   - Field: ‘stdout’
[17:02:29.162]   - Field: ‘earlySignal’
[17:02:29.162]   - Field: ‘lazy’
[17:02:29.162]   - Field: ‘state’
[17:02:29.162] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:29.163] - Launch lazy future ...
[17:02:29.164] Packages needed by the future expression (n = 0): <none>
[17:02:29.164] Packages needed by future strategies (n = 0): <none>
[17:02:29.164] {
[17:02:29.164]     {
[17:02:29.164]         {
[17:02:29.164]             ...future.startTime <- base::Sys.time()
[17:02:29.164]             {
[17:02:29.164]                 {
[17:02:29.164]                   {
[17:02:29.164]                     {
[17:02:29.164]                       base::local({
[17:02:29.164]                         has_future <- base::requireNamespace("future", 
[17:02:29.164]                           quietly = TRUE)
[17:02:29.164]                         if (has_future) {
[17:02:29.164]                           ns <- base::getNamespace("future")
[17:02:29.164]                           version <- ns[[".package"]][["version"]]
[17:02:29.164]                           if (is.null(version)) 
[17:02:29.164]                             version <- utils::packageVersion("future")
[17:02:29.164]                         }
[17:02:29.164]                         else {
[17:02:29.164]                           version <- NULL
[17:02:29.164]                         }
[17:02:29.164]                         if (!has_future || version < "1.8.0") {
[17:02:29.164]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.164]                             "", base::R.version$version.string), 
[17:02:29.164]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:29.164]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.164]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.164]                               "release", "version")], collapse = " "), 
[17:02:29.164]                             hostname = base::Sys.info()[["nodename"]])
[17:02:29.164]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.164]                             info)
[17:02:29.164]                           info <- base::paste(info, collapse = "; ")
[17:02:29.164]                           if (!has_future) {
[17:02:29.164]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.164]                               info)
[17:02:29.164]                           }
[17:02:29.164]                           else {
[17:02:29.164]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.164]                               info, version)
[17:02:29.164]                           }
[17:02:29.164]                           base::stop(msg)
[17:02:29.164]                         }
[17:02:29.164]                       })
[17:02:29.164]                     }
[17:02:29.164]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:29.164]                     base::options(mc.cores = 1L)
[17:02:29.164]                   }
[17:02:29.164]                   ...future.strategy.old <- future::plan("list")
[17:02:29.164]                   options(future.plan = NULL)
[17:02:29.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.164]                 }
[17:02:29.164]                 ...future.workdir <- getwd()
[17:02:29.164]             }
[17:02:29.164]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.164]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.164]         }
[17:02:29.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.164]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.164]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.164]             base::names(...future.oldOptions))
[17:02:29.164]     }
[17:02:29.164]     if (FALSE) {
[17:02:29.164]     }
[17:02:29.164]     else {
[17:02:29.164]         if (TRUE) {
[17:02:29.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.164]                 open = "w")
[17:02:29.164]         }
[17:02:29.164]         else {
[17:02:29.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.164]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.164]         }
[17:02:29.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.164]             base::sink(type = "output", split = FALSE)
[17:02:29.164]             base::close(...future.stdout)
[17:02:29.164]         }, add = TRUE)
[17:02:29.164]     }
[17:02:29.164]     ...future.frame <- base::sys.nframe()
[17:02:29.164]     ...future.conditions <- base::list()
[17:02:29.164]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.164]     if (FALSE) {
[17:02:29.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.164]     }
[17:02:29.164]     ...future.result <- base::tryCatch({
[17:02:29.164]         base::withCallingHandlers({
[17:02:29.164]             ...future.value <- base::withVisible(base::local({
[17:02:29.164]                 withCallingHandlers({
[17:02:29.164]                   2
[17:02:29.164]                 }, immediateCondition = function(cond) {
[17:02:29.164]                   save_rds <- function (object, pathname, ...) 
[17:02:29.164]                   {
[17:02:29.164]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:29.164]                     if (file_test("-f", pathname_tmp)) {
[17:02:29.164]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.164]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:29.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.164]                         fi_tmp[["mtime"]])
[17:02:29.164]                     }
[17:02:29.164]                     tryCatch({
[17:02:29.164]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:29.164]                     }, error = function(ex) {
[17:02:29.164]                       msg <- conditionMessage(ex)
[17:02:29.164]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.164]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:29.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.164]                         fi_tmp[["mtime"]], msg)
[17:02:29.164]                       ex$message <- msg
[17:02:29.164]                       stop(ex)
[17:02:29.164]                     })
[17:02:29.164]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:29.164]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:29.164]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:29.164]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.164]                       fi <- file.info(pathname)
[17:02:29.164]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:29.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.164]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:29.164]                         fi[["size"]], fi[["mtime"]])
[17:02:29.164]                       stop(msg)
[17:02:29.164]                     }
[17:02:29.164]                     invisible(pathname)
[17:02:29.164]                   }
[17:02:29.164]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:29.164]                     rootPath = tempdir()) 
[17:02:29.164]                   {
[17:02:29.164]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:29.164]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:29.164]                       tmpdir = path, fileext = ".rds")
[17:02:29.164]                     save_rds(obj, file)
[17:02:29.164]                   }
[17:02:29.164]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:29.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.164]                   {
[17:02:29.164]                     inherits <- base::inherits
[17:02:29.164]                     invokeRestart <- base::invokeRestart
[17:02:29.164]                     is.null <- base::is.null
[17:02:29.164]                     muffled <- FALSE
[17:02:29.164]                     if (inherits(cond, "message")) {
[17:02:29.164]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:29.164]                       if (muffled) 
[17:02:29.164]                         invokeRestart("muffleMessage")
[17:02:29.164]                     }
[17:02:29.164]                     else if (inherits(cond, "warning")) {
[17:02:29.164]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:29.164]                       if (muffled) 
[17:02:29.164]                         invokeRestart("muffleWarning")
[17:02:29.164]                     }
[17:02:29.164]                     else if (inherits(cond, "condition")) {
[17:02:29.164]                       if (!is.null(pattern)) {
[17:02:29.164]                         computeRestarts <- base::computeRestarts
[17:02:29.164]                         grepl <- base::grepl
[17:02:29.164]                         restarts <- computeRestarts(cond)
[17:02:29.164]                         for (restart in restarts) {
[17:02:29.164]                           name <- restart$name
[17:02:29.164]                           if (is.null(name)) 
[17:02:29.164]                             next
[17:02:29.164]                           if (!grepl(pattern, name)) 
[17:02:29.164]                             next
[17:02:29.164]                           invokeRestart(restart)
[17:02:29.164]                           muffled <- TRUE
[17:02:29.164]                           break
[17:02:29.164]                         }
[17:02:29.164]                       }
[17:02:29.164]                     }
[17:02:29.164]                     invisible(muffled)
[17:02:29.164]                   }
[17:02:29.164]                   muffleCondition(cond)
[17:02:29.164]                 })
[17:02:29.164]             }))
[17:02:29.164]             future::FutureResult(value = ...future.value$value, 
[17:02:29.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.164]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.164]                     ...future.globalenv.names))
[17:02:29.164]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.164]         }, condition = base::local({
[17:02:29.164]             c <- base::c
[17:02:29.164]             inherits <- base::inherits
[17:02:29.164]             invokeRestart <- base::invokeRestart
[17:02:29.164]             length <- base::length
[17:02:29.164]             list <- base::list
[17:02:29.164]             seq.int <- base::seq.int
[17:02:29.164]             signalCondition <- base::signalCondition
[17:02:29.164]             sys.calls <- base::sys.calls
[17:02:29.164]             `[[` <- base::`[[`
[17:02:29.164]             `+` <- base::`+`
[17:02:29.164]             `<<-` <- base::`<<-`
[17:02:29.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.164]                   3L)]
[17:02:29.164]             }
[17:02:29.164]             function(cond) {
[17:02:29.164]                 is_error <- inherits(cond, "error")
[17:02:29.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.164]                   NULL)
[17:02:29.164]                 if (is_error) {
[17:02:29.164]                   sessionInformation <- function() {
[17:02:29.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.164]                       search = base::search(), system = base::Sys.info())
[17:02:29.164]                   }
[17:02:29.164]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.164]                     cond$call), session = sessionInformation(), 
[17:02:29.164]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.164]                   signalCondition(cond)
[17:02:29.164]                 }
[17:02:29.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.164]                 "immediateCondition"))) {
[17:02:29.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.164]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.164]                   if (TRUE && !signal) {
[17:02:29.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.164]                     {
[17:02:29.164]                       inherits <- base::inherits
[17:02:29.164]                       invokeRestart <- base::invokeRestart
[17:02:29.164]                       is.null <- base::is.null
[17:02:29.164]                       muffled <- FALSE
[17:02:29.164]                       if (inherits(cond, "message")) {
[17:02:29.164]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.164]                         if (muffled) 
[17:02:29.164]                           invokeRestart("muffleMessage")
[17:02:29.164]                       }
[17:02:29.164]                       else if (inherits(cond, "warning")) {
[17:02:29.164]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.164]                         if (muffled) 
[17:02:29.164]                           invokeRestart("muffleWarning")
[17:02:29.164]                       }
[17:02:29.164]                       else if (inherits(cond, "condition")) {
[17:02:29.164]                         if (!is.null(pattern)) {
[17:02:29.164]                           computeRestarts <- base::computeRestarts
[17:02:29.164]                           grepl <- base::grepl
[17:02:29.164]                           restarts <- computeRestarts(cond)
[17:02:29.164]                           for (restart in restarts) {
[17:02:29.164]                             name <- restart$name
[17:02:29.164]                             if (is.null(name)) 
[17:02:29.164]                               next
[17:02:29.164]                             if (!grepl(pattern, name)) 
[17:02:29.164]                               next
[17:02:29.164]                             invokeRestart(restart)
[17:02:29.164]                             muffled <- TRUE
[17:02:29.164]                             break
[17:02:29.164]                           }
[17:02:29.164]                         }
[17:02:29.164]                       }
[17:02:29.164]                       invisible(muffled)
[17:02:29.164]                     }
[17:02:29.164]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.164]                   }
[17:02:29.164]                 }
[17:02:29.164]                 else {
[17:02:29.164]                   if (TRUE) {
[17:02:29.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.164]                     {
[17:02:29.164]                       inherits <- base::inherits
[17:02:29.164]                       invokeRestart <- base::invokeRestart
[17:02:29.164]                       is.null <- base::is.null
[17:02:29.164]                       muffled <- FALSE
[17:02:29.164]                       if (inherits(cond, "message")) {
[17:02:29.164]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.164]                         if (muffled) 
[17:02:29.164]                           invokeRestart("muffleMessage")
[17:02:29.164]                       }
[17:02:29.164]                       else if (inherits(cond, "warning")) {
[17:02:29.164]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.164]                         if (muffled) 
[17:02:29.164]                           invokeRestart("muffleWarning")
[17:02:29.164]                       }
[17:02:29.164]                       else if (inherits(cond, "condition")) {
[17:02:29.164]                         if (!is.null(pattern)) {
[17:02:29.164]                           computeRestarts <- base::computeRestarts
[17:02:29.164]                           grepl <- base::grepl
[17:02:29.164]                           restarts <- computeRestarts(cond)
[17:02:29.164]                           for (restart in restarts) {
[17:02:29.164]                             name <- restart$name
[17:02:29.164]                             if (is.null(name)) 
[17:02:29.164]                               next
[17:02:29.164]                             if (!grepl(pattern, name)) 
[17:02:29.164]                               next
[17:02:29.164]                             invokeRestart(restart)
[17:02:29.164]                             muffled <- TRUE
[17:02:29.164]                             break
[17:02:29.164]                           }
[17:02:29.164]                         }
[17:02:29.164]                       }
[17:02:29.164]                       invisible(muffled)
[17:02:29.164]                     }
[17:02:29.164]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.164]                   }
[17:02:29.164]                 }
[17:02:29.164]             }
[17:02:29.164]         }))
[17:02:29.164]     }, error = function(ex) {
[17:02:29.164]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.164]                 ...future.rng), started = ...future.startTime, 
[17:02:29.164]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.164]             version = "1.8"), class = "FutureResult")
[17:02:29.164]     }, finally = {
[17:02:29.164]         if (!identical(...future.workdir, getwd())) 
[17:02:29.164]             setwd(...future.workdir)
[17:02:29.164]         {
[17:02:29.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.164]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.164]             }
[17:02:29.164]             base::options(...future.oldOptions)
[17:02:29.164]             if (.Platform$OS.type == "windows") {
[17:02:29.164]                 old_names <- names(...future.oldEnvVars)
[17:02:29.164]                 envs <- base::Sys.getenv()
[17:02:29.164]                 names <- names(envs)
[17:02:29.164]                 common <- intersect(names, old_names)
[17:02:29.164]                 added <- setdiff(names, old_names)
[17:02:29.164]                 removed <- setdiff(old_names, names)
[17:02:29.164]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.164]                   envs[common]]
[17:02:29.164]                 NAMES <- toupper(changed)
[17:02:29.164]                 args <- list()
[17:02:29.164]                 for (kk in seq_along(NAMES)) {
[17:02:29.164]                   name <- changed[[kk]]
[17:02:29.164]                   NAME <- NAMES[[kk]]
[17:02:29.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.164]                     next
[17:02:29.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.164]                 }
[17:02:29.164]                 NAMES <- toupper(added)
[17:02:29.164]                 for (kk in seq_along(NAMES)) {
[17:02:29.164]                   name <- added[[kk]]
[17:02:29.164]                   NAME <- NAMES[[kk]]
[17:02:29.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.164]                     next
[17:02:29.164]                   args[[name]] <- ""
[17:02:29.164]                 }
[17:02:29.164]                 NAMES <- toupper(removed)
[17:02:29.164]                 for (kk in seq_along(NAMES)) {
[17:02:29.164]                   name <- removed[[kk]]
[17:02:29.164]                   NAME <- NAMES[[kk]]
[17:02:29.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.164]                     next
[17:02:29.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.164]                 }
[17:02:29.164]                 if (length(args) > 0) 
[17:02:29.164]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.164]             }
[17:02:29.164]             else {
[17:02:29.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.164]             }
[17:02:29.164]             {
[17:02:29.164]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.164]                   0L) {
[17:02:29.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.164]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.164]                   base::options(opts)
[17:02:29.164]                 }
[17:02:29.164]                 {
[17:02:29.164]                   {
[17:02:29.164]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:29.164]                     NULL
[17:02:29.164]                   }
[17:02:29.164]                   options(future.plan = NULL)
[17:02:29.164]                   if (is.na(NA_character_)) 
[17:02:29.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.164]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.164]                     .init = FALSE)
[17:02:29.164]                 }
[17:02:29.164]             }
[17:02:29.164]         }
[17:02:29.164]     })
[17:02:29.164]     if (TRUE) {
[17:02:29.164]         base::sink(type = "output", split = FALSE)
[17:02:29.164]         if (TRUE) {
[17:02:29.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.164]         }
[17:02:29.164]         else {
[17:02:29.164]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.164]         }
[17:02:29.164]         base::close(...future.stdout)
[17:02:29.164]         ...future.stdout <- NULL
[17:02:29.164]     }
[17:02:29.164]     ...future.result$conditions <- ...future.conditions
[17:02:29.164]     ...future.result$finished <- base::Sys.time()
[17:02:29.164]     ...future.result
[17:02:29.164] }
[17:02:29.166] requestCore(): workers = 2
[17:02:29.169] MulticoreFuture started
[17:02:29.170] - Launch lazy future ... done
[17:02:29.170] plan(): Setting new future strategy stack:
[17:02:29.170] run() for ‘MulticoreFuture’ ... done
[17:02:29.170] getGlobalsAndPackages() ...
[17:02:29.171] Searching for globals...
[17:02:29.170] List of future strategies:
[17:02:29.170] 1. sequential:
[17:02:29.170]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.170]    - tweaked: FALSE
[17:02:29.170]    - call: NULL
[17:02:29.171] plan(): nbrOfWorkers() = 1
[17:02:29.172] 
[17:02:29.172] Searching for globals ... DONE
[17:02:29.172] - globals: [0] <none>
[17:02:29.172] getGlobalsAndPackages() ... DONE
[17:02:29.173] run() for ‘Future’ ...
[17:02:29.173] - state: ‘created’
[17:02:29.173] plan(): Setting new future strategy stack:
[17:02:29.173] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:29.173] List of future strategies:
[17:02:29.173] 1. multicore:
[17:02:29.173]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:29.173]    - tweaked: FALSE
[17:02:29.173]    - call: plan(strategy)
[17:02:29.178] plan(): nbrOfWorkers() = 2
[17:02:29.179] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:29.179] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:29.179]   - Field: ‘label’
[17:02:29.180]   - Field: ‘local’
[17:02:29.180]   - Field: ‘owner’
[17:02:29.180]   - Field: ‘envir’
[17:02:29.180]   - Field: ‘workers’
[17:02:29.180]   - Field: ‘packages’
[17:02:29.180]   - Field: ‘gc’
[17:02:29.180]   - Field: ‘job’
[17:02:29.181]   - Field: ‘conditions’
[17:02:29.181]   - Field: ‘expr’
[17:02:29.181]   - Field: ‘uuid’
[17:02:29.181]   - Field: ‘seed’
[17:02:29.181]   - Field: ‘version’
[17:02:29.181]   - Field: ‘result’
[17:02:29.181]   - Field: ‘asynchronous’
[17:02:29.182]   - Field: ‘calls’
[17:02:29.182]   - Field: ‘globals’
[17:02:29.182]   - Field: ‘stdout’
[17:02:29.182]   - Field: ‘earlySignal’
[17:02:29.182]   - Field: ‘lazy’
[17:02:29.182]   - Field: ‘state’
[17:02:29.182] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:29.182] - Launch lazy future ...
[17:02:29.183] Packages needed by the future expression (n = 0): <none>
[17:02:29.183] Packages needed by future strategies (n = 0): <none>
[17:02:29.184] {
[17:02:29.184]     {
[17:02:29.184]         {
[17:02:29.184]             ...future.startTime <- base::Sys.time()
[17:02:29.184]             {
[17:02:29.184]                 {
[17:02:29.184]                   {
[17:02:29.184]                     {
[17:02:29.184]                       base::local({
[17:02:29.184]                         has_future <- base::requireNamespace("future", 
[17:02:29.184]                           quietly = TRUE)
[17:02:29.184]                         if (has_future) {
[17:02:29.184]                           ns <- base::getNamespace("future")
[17:02:29.184]                           version <- ns[[".package"]][["version"]]
[17:02:29.184]                           if (is.null(version)) 
[17:02:29.184]                             version <- utils::packageVersion("future")
[17:02:29.184]                         }
[17:02:29.184]                         else {
[17:02:29.184]                           version <- NULL
[17:02:29.184]                         }
[17:02:29.184]                         if (!has_future || version < "1.8.0") {
[17:02:29.184]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.184]                             "", base::R.version$version.string), 
[17:02:29.184]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:29.184]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.184]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.184]                               "release", "version")], collapse = " "), 
[17:02:29.184]                             hostname = base::Sys.info()[["nodename"]])
[17:02:29.184]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.184]                             info)
[17:02:29.184]                           info <- base::paste(info, collapse = "; ")
[17:02:29.184]                           if (!has_future) {
[17:02:29.184]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.184]                               info)
[17:02:29.184]                           }
[17:02:29.184]                           else {
[17:02:29.184]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.184]                               info, version)
[17:02:29.184]                           }
[17:02:29.184]                           base::stop(msg)
[17:02:29.184]                         }
[17:02:29.184]                       })
[17:02:29.184]                     }
[17:02:29.184]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:29.184]                     base::options(mc.cores = 1L)
[17:02:29.184]                   }
[17:02:29.184]                   ...future.strategy.old <- future::plan("list")
[17:02:29.184]                   options(future.plan = NULL)
[17:02:29.184]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.184]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.184]                 }
[17:02:29.184]                 ...future.workdir <- getwd()
[17:02:29.184]             }
[17:02:29.184]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.184]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.184]         }
[17:02:29.184]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.184]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.184]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.184]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.184]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.184]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.184]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.184]             base::names(...future.oldOptions))
[17:02:29.184]     }
[17:02:29.184]     if (FALSE) {
[17:02:29.184]     }
[17:02:29.184]     else {
[17:02:29.184]         if (TRUE) {
[17:02:29.184]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.184]                 open = "w")
[17:02:29.184]         }
[17:02:29.184]         else {
[17:02:29.184]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.184]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.184]         }
[17:02:29.184]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.184]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.184]             base::sink(type = "output", split = FALSE)
[17:02:29.184]             base::close(...future.stdout)
[17:02:29.184]         }, add = TRUE)
[17:02:29.184]     }
[17:02:29.184]     ...future.frame <- base::sys.nframe()
[17:02:29.184]     ...future.conditions <- base::list()
[17:02:29.184]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.184]     if (FALSE) {
[17:02:29.184]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.184]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.184]     }
[17:02:29.184]     ...future.result <- base::tryCatch({
[17:02:29.184]         base::withCallingHandlers({
[17:02:29.184]             ...future.value <- base::withVisible(base::local({
[17:02:29.184]                 withCallingHandlers({
[17:02:29.184]                   NULL
[17:02:29.184]                 }, immediateCondition = function(cond) {
[17:02:29.184]                   save_rds <- function (object, pathname, ...) 
[17:02:29.184]                   {
[17:02:29.184]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:29.184]                     if (file_test("-f", pathname_tmp)) {
[17:02:29.184]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.184]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:29.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.184]                         fi_tmp[["mtime"]])
[17:02:29.184]                     }
[17:02:29.184]                     tryCatch({
[17:02:29.184]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:29.184]                     }, error = function(ex) {
[17:02:29.184]                       msg <- conditionMessage(ex)
[17:02:29.184]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.184]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:29.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.184]                         fi_tmp[["mtime"]], msg)
[17:02:29.184]                       ex$message <- msg
[17:02:29.184]                       stop(ex)
[17:02:29.184]                     })
[17:02:29.184]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:29.184]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:29.184]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:29.184]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.184]                       fi <- file.info(pathname)
[17:02:29.184]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:29.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.184]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:29.184]                         fi[["size"]], fi[["mtime"]])
[17:02:29.184]                       stop(msg)
[17:02:29.184]                     }
[17:02:29.184]                     invisible(pathname)
[17:02:29.184]                   }
[17:02:29.184]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:29.184]                     rootPath = tempdir()) 
[17:02:29.184]                   {
[17:02:29.184]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:29.184]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:29.184]                       tmpdir = path, fileext = ".rds")
[17:02:29.184]                     save_rds(obj, file)
[17:02:29.184]                   }
[17:02:29.184]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:29.184]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.184]                   {
[17:02:29.184]                     inherits <- base::inherits
[17:02:29.184]                     invokeRestart <- base::invokeRestart
[17:02:29.184]                     is.null <- base::is.null
[17:02:29.184]                     muffled <- FALSE
[17:02:29.184]                     if (inherits(cond, "message")) {
[17:02:29.184]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:29.184]                       if (muffled) 
[17:02:29.184]                         invokeRestart("muffleMessage")
[17:02:29.184]                     }
[17:02:29.184]                     else if (inherits(cond, "warning")) {
[17:02:29.184]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:29.184]                       if (muffled) 
[17:02:29.184]                         invokeRestart("muffleWarning")
[17:02:29.184]                     }
[17:02:29.184]                     else if (inherits(cond, "condition")) {
[17:02:29.184]                       if (!is.null(pattern)) {
[17:02:29.184]                         computeRestarts <- base::computeRestarts
[17:02:29.184]                         grepl <- base::grepl
[17:02:29.184]                         restarts <- computeRestarts(cond)
[17:02:29.184]                         for (restart in restarts) {
[17:02:29.184]                           name <- restart$name
[17:02:29.184]                           if (is.null(name)) 
[17:02:29.184]                             next
[17:02:29.184]                           if (!grepl(pattern, name)) 
[17:02:29.184]                             next
[17:02:29.184]                           invokeRestart(restart)
[17:02:29.184]                           muffled <- TRUE
[17:02:29.184]                           break
[17:02:29.184]                         }
[17:02:29.184]                       }
[17:02:29.184]                     }
[17:02:29.184]                     invisible(muffled)
[17:02:29.184]                   }
[17:02:29.184]                   muffleCondition(cond)
[17:02:29.184]                 })
[17:02:29.184]             }))
[17:02:29.184]             future::FutureResult(value = ...future.value$value, 
[17:02:29.184]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.184]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.184]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.184]                     ...future.globalenv.names))
[17:02:29.184]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.184]         }, condition = base::local({
[17:02:29.184]             c <- base::c
[17:02:29.184]             inherits <- base::inherits
[17:02:29.184]             invokeRestart <- base::invokeRestart
[17:02:29.184]             length <- base::length
[17:02:29.184]             list <- base::list
[17:02:29.184]             seq.int <- base::seq.int
[17:02:29.184]             signalCondition <- base::signalCondition
[17:02:29.184]             sys.calls <- base::sys.calls
[17:02:29.184]             `[[` <- base::`[[`
[17:02:29.184]             `+` <- base::`+`
[17:02:29.184]             `<<-` <- base::`<<-`
[17:02:29.184]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.184]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.184]                   3L)]
[17:02:29.184]             }
[17:02:29.184]             function(cond) {
[17:02:29.184]                 is_error <- inherits(cond, "error")
[17:02:29.184]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.184]                   NULL)
[17:02:29.184]                 if (is_error) {
[17:02:29.184]                   sessionInformation <- function() {
[17:02:29.184]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.184]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.184]                       search = base::search(), system = base::Sys.info())
[17:02:29.184]                   }
[17:02:29.184]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.184]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.184]                     cond$call), session = sessionInformation(), 
[17:02:29.184]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.184]                   signalCondition(cond)
[17:02:29.184]                 }
[17:02:29.184]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.184]                 "immediateCondition"))) {
[17:02:29.184]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.184]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.184]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.184]                   if (TRUE && !signal) {
[17:02:29.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.184]                     {
[17:02:29.184]                       inherits <- base::inherits
[17:02:29.184]                       invokeRestart <- base::invokeRestart
[17:02:29.184]                       is.null <- base::is.null
[17:02:29.184]                       muffled <- FALSE
[17:02:29.184]                       if (inherits(cond, "message")) {
[17:02:29.184]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.184]                         if (muffled) 
[17:02:29.184]                           invokeRestart("muffleMessage")
[17:02:29.184]                       }
[17:02:29.184]                       else if (inherits(cond, "warning")) {
[17:02:29.184]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.184]                         if (muffled) 
[17:02:29.184]                           invokeRestart("muffleWarning")
[17:02:29.184]                       }
[17:02:29.184]                       else if (inherits(cond, "condition")) {
[17:02:29.184]                         if (!is.null(pattern)) {
[17:02:29.184]                           computeRestarts <- base::computeRestarts
[17:02:29.184]                           grepl <- base::grepl
[17:02:29.184]                           restarts <- computeRestarts(cond)
[17:02:29.184]                           for (restart in restarts) {
[17:02:29.184]                             name <- restart$name
[17:02:29.184]                             if (is.null(name)) 
[17:02:29.184]                               next
[17:02:29.184]                             if (!grepl(pattern, name)) 
[17:02:29.184]                               next
[17:02:29.184]                             invokeRestart(restart)
[17:02:29.184]                             muffled <- TRUE
[17:02:29.184]                             break
[17:02:29.184]                           }
[17:02:29.184]                         }
[17:02:29.184]                       }
[17:02:29.184]                       invisible(muffled)
[17:02:29.184]                     }
[17:02:29.184]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.184]                   }
[17:02:29.184]                 }
[17:02:29.184]                 else {
[17:02:29.184]                   if (TRUE) {
[17:02:29.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.184]                     {
[17:02:29.184]                       inherits <- base::inherits
[17:02:29.184]                       invokeRestart <- base::invokeRestart
[17:02:29.184]                       is.null <- base::is.null
[17:02:29.184]                       muffled <- FALSE
[17:02:29.184]                       if (inherits(cond, "message")) {
[17:02:29.184]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.184]                         if (muffled) 
[17:02:29.184]                           invokeRestart("muffleMessage")
[17:02:29.184]                       }
[17:02:29.184]                       else if (inherits(cond, "warning")) {
[17:02:29.184]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.184]                         if (muffled) 
[17:02:29.184]                           invokeRestart("muffleWarning")
[17:02:29.184]                       }
[17:02:29.184]                       else if (inherits(cond, "condition")) {
[17:02:29.184]                         if (!is.null(pattern)) {
[17:02:29.184]                           computeRestarts <- base::computeRestarts
[17:02:29.184]                           grepl <- base::grepl
[17:02:29.184]                           restarts <- computeRestarts(cond)
[17:02:29.184]                           for (restart in restarts) {
[17:02:29.184]                             name <- restart$name
[17:02:29.184]                             if (is.null(name)) 
[17:02:29.184]                               next
[17:02:29.184]                             if (!grepl(pattern, name)) 
[17:02:29.184]                               next
[17:02:29.184]                             invokeRestart(restart)
[17:02:29.184]                             muffled <- TRUE
[17:02:29.184]                             break
[17:02:29.184]                           }
[17:02:29.184]                         }
[17:02:29.184]                       }
[17:02:29.184]                       invisible(muffled)
[17:02:29.184]                     }
[17:02:29.184]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.184]                   }
[17:02:29.184]                 }
[17:02:29.184]             }
[17:02:29.184]         }))
[17:02:29.184]     }, error = function(ex) {
[17:02:29.184]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.184]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.184]                 ...future.rng), started = ...future.startTime, 
[17:02:29.184]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.184]             version = "1.8"), class = "FutureResult")
[17:02:29.184]     }, finally = {
[17:02:29.184]         if (!identical(...future.workdir, getwd())) 
[17:02:29.184]             setwd(...future.workdir)
[17:02:29.184]         {
[17:02:29.184]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.184]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.184]             }
[17:02:29.184]             base::options(...future.oldOptions)
[17:02:29.184]             if (.Platform$OS.type == "windows") {
[17:02:29.184]                 old_names <- names(...future.oldEnvVars)
[17:02:29.184]                 envs <- base::Sys.getenv()
[17:02:29.184]                 names <- names(envs)
[17:02:29.184]                 common <- intersect(names, old_names)
[17:02:29.184]                 added <- setdiff(names, old_names)
[17:02:29.184]                 removed <- setdiff(old_names, names)
[17:02:29.184]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.184]                   envs[common]]
[17:02:29.184]                 NAMES <- toupper(changed)
[17:02:29.184]                 args <- list()
[17:02:29.184]                 for (kk in seq_along(NAMES)) {
[17:02:29.184]                   name <- changed[[kk]]
[17:02:29.184]                   NAME <- NAMES[[kk]]
[17:02:29.184]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.184]                     next
[17:02:29.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.184]                 }
[17:02:29.184]                 NAMES <- toupper(added)
[17:02:29.184]                 for (kk in seq_along(NAMES)) {
[17:02:29.184]                   name <- added[[kk]]
[17:02:29.184]                   NAME <- NAMES[[kk]]
[17:02:29.184]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.184]                     next
[17:02:29.184]                   args[[name]] <- ""
[17:02:29.184]                 }
[17:02:29.184]                 NAMES <- toupper(removed)
[17:02:29.184]                 for (kk in seq_along(NAMES)) {
[17:02:29.184]                   name <- removed[[kk]]
[17:02:29.184]                   NAME <- NAMES[[kk]]
[17:02:29.184]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.184]                     next
[17:02:29.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.184]                 }
[17:02:29.184]                 if (length(args) > 0) 
[17:02:29.184]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.184]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.184]             }
[17:02:29.184]             else {
[17:02:29.184]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.184]             }
[17:02:29.184]             {
[17:02:29.184]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.184]                   0L) {
[17:02:29.184]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.184]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.184]                   base::options(opts)
[17:02:29.184]                 }
[17:02:29.184]                 {
[17:02:29.184]                   {
[17:02:29.184]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:29.184]                     NULL
[17:02:29.184]                   }
[17:02:29.184]                   options(future.plan = NULL)
[17:02:29.184]                   if (is.na(NA_character_)) 
[17:02:29.184]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.184]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.184]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.184]                     .init = FALSE)
[17:02:29.184]                 }
[17:02:29.184]             }
[17:02:29.184]         }
[17:02:29.184]     })
[17:02:29.184]     if (TRUE) {
[17:02:29.184]         base::sink(type = "output", split = FALSE)
[17:02:29.184]         if (TRUE) {
[17:02:29.184]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.184]         }
[17:02:29.184]         else {
[17:02:29.184]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.184]         }
[17:02:29.184]         base::close(...future.stdout)
[17:02:29.184]         ...future.stdout <- NULL
[17:02:29.184]     }
[17:02:29.184]     ...future.result$conditions <- ...future.conditions
[17:02:29.184]     ...future.result$finished <- base::Sys.time()
[17:02:29.184]     ...future.result
[17:02:29.184] }
[17:02:29.187] requestCore(): workers = 2
[17:02:29.198] MulticoreFuture started
[17:02:29.198] - Launch lazy future ... done
[17:02:29.199] plan(): Setting new future strategy stack:
[17:02:29.199] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[17:02:29.200] List of future strategies:
[17:02:29.200] 1. sequential:
[17:02:29.200]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.200]    - tweaked: FALSE
[17:02:29.200]    - call: NULL
[17:02:29.202] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c7490bf158> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c7496f9620> 
 $  : NULL
 $  :[17:02:29.204] plan(): Setting new future strategy stack:
 NULL
 $  :[17:02:29.204] List of future strategies:
[17:02:29.204] 1. multicore:
[17:02:29.204]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:29.204]    - tweaked: FALSE
[17:02:29.204]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c7490bf158> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c7496f9620> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:02:29.210] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:29.212] resolve() on list ...
[17:02:29.212]  recursive: 0
[17:02:29.213]  length: 6
[17:02:29.213]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:29.213] signalConditionsASAP(numeric, pos=1) ...
[17:02:29.213] - nx: 6
[17:02:29.213] - relay: TRUE
[17:02:29.213] - stdout: TRUE
[17:02:29.213] - signal: TRUE
[17:02:29.214] - resignal: FALSE
[17:02:29.214] - force: TRUE
[17:02:29.214] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.214] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.214]  - until=2
[17:02:29.214]  - relaying element #2
[17:02:29.214] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.215] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.215] signalConditionsASAP(NULL, pos=1) ... done
[17:02:29.215]  length: 5 (resolved future 1)
[17:02:29.215] Future #2
[17:02:29.216] result() for MulticoreFuture ...
[17:02:29.218] result() for MulticoreFuture ...
[17:02:29.218] result() for MulticoreFuture ... done
[17:02:29.218] result() for MulticoreFuture ... done
[17:02:29.218] result() for MulticoreFuture ...
[17:02:29.218] result() for MulticoreFuture ... done
[17:02:29.218] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:29.219] - nx: 6
[17:02:29.219] - relay: TRUE
[17:02:29.219] - stdout: TRUE
[17:02:29.219] - signal: TRUE
[17:02:29.219] - resignal: FALSE
[17:02:29.219] - force: TRUE
[17:02:29.220] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.220] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.220]  - until=2
[17:02:29.220]  - relaying element #2
[17:02:29.220] result() for MulticoreFuture ...
[17:02:29.220] result() for MulticoreFuture ... done
[17:02:29.221] result() for MulticoreFuture ...
[17:02:29.221] result() for MulticoreFuture ... done
[17:02:29.221] result() for MulticoreFuture ...
[17:02:29.221] result() for MulticoreFuture ... done
[17:02:29.221] result() for MulticoreFuture ...
[17:02:29.222] result() for MulticoreFuture ... done
[17:02:29.222] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.222] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.222] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:29.222]  length: 4 (resolved future 2)
[17:02:29.222] Future #3
[17:02:29.223] result() for MulticoreFuture ...
[17:02:29.223] result() for MulticoreFuture ...
[17:02:29.223] result() for MulticoreFuture ... done
[17:02:29.224] result() for MulticoreFuture ... done
[17:02:29.224] result() for MulticoreFuture ...
[17:02:29.224] result() for MulticoreFuture ... done
[17:02:29.224] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:29.224] - nx: 6
[17:02:29.224] - relay: TRUE
[17:02:29.224] - stdout: TRUE
[17:02:29.224] - signal: TRUE
[17:02:29.224] - resignal: FALSE
[17:02:29.225] - force: TRUE
[17:02:29.225] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.225] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.225]  - until=3
[17:02:29.225]  - relaying element #3
[17:02:29.225] result() for MulticoreFuture ...
[17:02:29.225] result() for MulticoreFuture ... done
[17:02:29.225] result() for MulticoreFuture ...
[17:02:29.225] result() for MulticoreFuture ... done
[17:02:29.226] result() for MulticoreFuture ...
[17:02:29.226] result() for MulticoreFuture ... done
[17:02:29.226] result() for MulticoreFuture ...
[17:02:29.226] result() for MulticoreFuture ... done
[17:02:29.226] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.226] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.226] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:29.226]  length: 3 (resolved future 3)
[17:02:29.226] signalConditionsASAP(NULL, pos=4) ...
[17:02:29.227] - nx: 6
[17:02:29.227] - relay: TRUE
[17:02:29.227] - stdout: TRUE
[17:02:29.227] - signal: TRUE
[17:02:29.227] - resignal: FALSE
[17:02:29.227] - force: TRUE
[17:02:29.227] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.227] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.228]  - until=5
[17:02:29.228]  - relaying element #5
[17:02:29.228] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.228] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.228] signalConditionsASAP(NULL, pos=4) ... done
[17:02:29.228]  length: 2 (resolved future 4)
[17:02:29.228] signalConditionsASAP(NULL, pos=5) ...
[17:02:29.228] - nx: 6
[17:02:29.228] - relay: TRUE
[17:02:29.228] - stdout: TRUE
[17:02:29.228] - signal: TRUE
[17:02:29.229] - resignal: FALSE
[17:02:29.229] - force: TRUE
[17:02:29.229] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.229] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.229]  - until=6
[17:02:29.229]  - relaying element #6
[17:02:29.229] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.229] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.229] signalConditionsASAP(NULL, pos=5) ... done
[17:02:29.229]  length: 1 (resolved future 5)
[17:02:29.230] signalConditionsASAP(numeric, pos=6) ...
[17:02:29.230] - nx: 6
[17:02:29.230] - relay: TRUE
[17:02:29.230] - stdout: TRUE
[17:02:29.230] - signal: TRUE
[17:02:29.230] - resignal: FALSE
[17:02:29.230] - force: TRUE
[17:02:29.230] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.230] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.230]  - until=6
[17:02:29.230] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.231] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.231] signalConditionsASAP(numeric, pos=6) ... done
[17:02:29.231]  length: 0 (resolved future 6)
[17:02:29.231] Relaying remaining futures
[17:02:29.231] signalConditionsASAP(NULL, pos=0) ...
[17:02:29.231] - nx: 6
[17:02:29.231] - relay: TRUE
[17:02:29.231] - stdout: TRUE
[17:02:29.231] - signal: TRUE
[17:02:29.231] - resignal: FALSE
[17:02:29.232] - force: TRUE
[17:02:29.232] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.232] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:29.232] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.232] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.232] signalConditionsASAP(NULL, pos=0) ... done
[17:02:29.232] resolve() on list ... DONE
[17:02:29.232] result() for MulticoreFuture ...
[17:02:29.232] result() for MulticoreFuture ... done
[17:02:29.232] result() for MulticoreFuture ...
[17:02:29.233] result() for MulticoreFuture ... done
[17:02:29.233] result() for MulticoreFuture ...
[17:02:29.233] result() for MulticoreFuture ... done
[17:02:29.233] result() for MulticoreFuture ...
[17:02:29.233] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[17:02:29.235] getGlobalsAndPackages() ...
[17:02:29.236] Searching for globals...
[17:02:29.236] 
[17:02:29.236] Searching for globals ... DONE
[17:02:29.236] - globals: [0] <none>
[17:02:29.236] getGlobalsAndPackages() ... DONE
[17:02:29.237] run() for ‘Future’ ...
[17:02:29.237] - state: ‘created’
[17:02:29.237] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:29.241] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:29.241] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:29.241]   - Field: ‘label’
[17:02:29.241]   - Field: ‘local’
[17:02:29.243]   - Field: ‘owner’
[17:02:29.243]   - Field: ‘envir’
[17:02:29.243]   - Field: ‘workers’
[17:02:29.243]   - Field: ‘packages’
[17:02:29.244]   - Field: ‘gc’
[17:02:29.244]   - Field: ‘job’
[17:02:29.244]   - Field: ‘conditions’
[17:02:29.244]   - Field: ‘expr’
[17:02:29.244]   - Field: ‘uuid’
[17:02:29.244]   - Field: ‘seed’
[17:02:29.244]   - Field: ‘version’
[17:02:29.244]   - Field: ‘result’
[17:02:29.245]   - Field: ‘asynchronous’
[17:02:29.245]   - Field: ‘calls’
[17:02:29.245]   - Field: ‘globals’
[17:02:29.245]   - Field: ‘stdout’
[17:02:29.245]   - Field: ‘earlySignal’
[17:02:29.245]   - Field: ‘lazy’
[17:02:29.245]   - Field: ‘state’
[17:02:29.245] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:29.245] - Launch lazy future ...
[17:02:29.246] Packages needed by the future expression (n = 0): <none>
[17:02:29.246] Packages needed by future strategies (n = 0): <none>
[17:02:29.246] {
[17:02:29.246]     {
[17:02:29.246]         {
[17:02:29.246]             ...future.startTime <- base::Sys.time()
[17:02:29.246]             {
[17:02:29.246]                 {
[17:02:29.246]                   {
[17:02:29.246]                     {
[17:02:29.246]                       base::local({
[17:02:29.246]                         has_future <- base::requireNamespace("future", 
[17:02:29.246]                           quietly = TRUE)
[17:02:29.246]                         if (has_future) {
[17:02:29.246]                           ns <- base::getNamespace("future")
[17:02:29.246]                           version <- ns[[".package"]][["version"]]
[17:02:29.246]                           if (is.null(version)) 
[17:02:29.246]                             version <- utils::packageVersion("future")
[17:02:29.246]                         }
[17:02:29.246]                         else {
[17:02:29.246]                           version <- NULL
[17:02:29.246]                         }
[17:02:29.246]                         if (!has_future || version < "1.8.0") {
[17:02:29.246]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.246]                             "", base::R.version$version.string), 
[17:02:29.246]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:29.246]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.246]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.246]                               "release", "version")], collapse = " "), 
[17:02:29.246]                             hostname = base::Sys.info()[["nodename"]])
[17:02:29.246]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.246]                             info)
[17:02:29.246]                           info <- base::paste(info, collapse = "; ")
[17:02:29.246]                           if (!has_future) {
[17:02:29.246]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.246]                               info)
[17:02:29.246]                           }
[17:02:29.246]                           else {
[17:02:29.246]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.246]                               info, version)
[17:02:29.246]                           }
[17:02:29.246]                           base::stop(msg)
[17:02:29.246]                         }
[17:02:29.246]                       })
[17:02:29.246]                     }
[17:02:29.246]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:29.246]                     base::options(mc.cores = 1L)
[17:02:29.246]                   }
[17:02:29.246]                   ...future.strategy.old <- future::plan("list")
[17:02:29.246]                   options(future.plan = NULL)
[17:02:29.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.246]                 }
[17:02:29.246]                 ...future.workdir <- getwd()
[17:02:29.246]             }
[17:02:29.246]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.246]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.246]         }
[17:02:29.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.246]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.246]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.246]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.246]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.246]             base::names(...future.oldOptions))
[17:02:29.246]     }
[17:02:29.246]     if (FALSE) {
[17:02:29.246]     }
[17:02:29.246]     else {
[17:02:29.246]         if (TRUE) {
[17:02:29.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.246]                 open = "w")
[17:02:29.246]         }
[17:02:29.246]         else {
[17:02:29.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.246]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.246]         }
[17:02:29.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.246]             base::sink(type = "output", split = FALSE)
[17:02:29.246]             base::close(...future.stdout)
[17:02:29.246]         }, add = TRUE)
[17:02:29.246]     }
[17:02:29.246]     ...future.frame <- base::sys.nframe()
[17:02:29.246]     ...future.conditions <- base::list()
[17:02:29.246]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.246]     if (FALSE) {
[17:02:29.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.246]     }
[17:02:29.246]     ...future.result <- base::tryCatch({
[17:02:29.246]         base::withCallingHandlers({
[17:02:29.246]             ...future.value <- base::withVisible(base::local({
[17:02:29.246]                 withCallingHandlers({
[17:02:29.246]                   2
[17:02:29.246]                 }, immediateCondition = function(cond) {
[17:02:29.246]                   save_rds <- function (object, pathname, ...) 
[17:02:29.246]                   {
[17:02:29.246]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:29.246]                     if (file_test("-f", pathname_tmp)) {
[17:02:29.246]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.246]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:29.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.246]                         fi_tmp[["mtime"]])
[17:02:29.246]                     }
[17:02:29.246]                     tryCatch({
[17:02:29.246]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:29.246]                     }, error = function(ex) {
[17:02:29.246]                       msg <- conditionMessage(ex)
[17:02:29.246]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.246]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:29.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.246]                         fi_tmp[["mtime"]], msg)
[17:02:29.246]                       ex$message <- msg
[17:02:29.246]                       stop(ex)
[17:02:29.246]                     })
[17:02:29.246]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:29.246]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:29.246]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:29.246]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.246]                       fi <- file.info(pathname)
[17:02:29.246]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:29.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.246]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:29.246]                         fi[["size"]], fi[["mtime"]])
[17:02:29.246]                       stop(msg)
[17:02:29.246]                     }
[17:02:29.246]                     invisible(pathname)
[17:02:29.246]                   }
[17:02:29.246]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:29.246]                     rootPath = tempdir()) 
[17:02:29.246]                   {
[17:02:29.246]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:29.246]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:29.246]                       tmpdir = path, fileext = ".rds")
[17:02:29.246]                     save_rds(obj, file)
[17:02:29.246]                   }
[17:02:29.246]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:29.246]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.246]                   {
[17:02:29.246]                     inherits <- base::inherits
[17:02:29.246]                     invokeRestart <- base::invokeRestart
[17:02:29.246]                     is.null <- base::is.null
[17:02:29.246]                     muffled <- FALSE
[17:02:29.246]                     if (inherits(cond, "message")) {
[17:02:29.246]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:29.246]                       if (muffled) 
[17:02:29.246]                         invokeRestart("muffleMessage")
[17:02:29.246]                     }
[17:02:29.246]                     else if (inherits(cond, "warning")) {
[17:02:29.246]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:29.246]                       if (muffled) 
[17:02:29.246]                         invokeRestart("muffleWarning")
[17:02:29.246]                     }
[17:02:29.246]                     else if (inherits(cond, "condition")) {
[17:02:29.246]                       if (!is.null(pattern)) {
[17:02:29.246]                         computeRestarts <- base::computeRestarts
[17:02:29.246]                         grepl <- base::grepl
[17:02:29.246]                         restarts <- computeRestarts(cond)
[17:02:29.246]                         for (restart in restarts) {
[17:02:29.246]                           name <- restart$name
[17:02:29.246]                           if (is.null(name)) 
[17:02:29.246]                             next
[17:02:29.246]                           if (!grepl(pattern, name)) 
[17:02:29.246]                             next
[17:02:29.246]                           invokeRestart(restart)
[17:02:29.246]                           muffled <- TRUE
[17:02:29.246]                           break
[17:02:29.246]                         }
[17:02:29.246]                       }
[17:02:29.246]                     }
[17:02:29.246]                     invisible(muffled)
[17:02:29.246]                   }
[17:02:29.246]                   muffleCondition(cond)
[17:02:29.246]                 })
[17:02:29.246]             }))
[17:02:29.246]             future::FutureResult(value = ...future.value$value, 
[17:02:29.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.246]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.246]                     ...future.globalenv.names))
[17:02:29.246]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.246]         }, condition = base::local({
[17:02:29.246]             c <- base::c
[17:02:29.246]             inherits <- base::inherits
[17:02:29.246]             invokeRestart <- base::invokeRestart
[17:02:29.246]             length <- base::length
[17:02:29.246]             list <- base::list
[17:02:29.246]             seq.int <- base::seq.int
[17:02:29.246]             signalCondition <- base::signalCondition
[17:02:29.246]             sys.calls <- base::sys.calls
[17:02:29.246]             `[[` <- base::`[[`
[17:02:29.246]             `+` <- base::`+`
[17:02:29.246]             `<<-` <- base::`<<-`
[17:02:29.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.246]                   3L)]
[17:02:29.246]             }
[17:02:29.246]             function(cond) {
[17:02:29.246]                 is_error <- inherits(cond, "error")
[17:02:29.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.246]                   NULL)
[17:02:29.246]                 if (is_error) {
[17:02:29.246]                   sessionInformation <- function() {
[17:02:29.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.246]                       search = base::search(), system = base::Sys.info())
[17:02:29.246]                   }
[17:02:29.246]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.246]                     cond$call), session = sessionInformation(), 
[17:02:29.246]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.246]                   signalCondition(cond)
[17:02:29.246]                 }
[17:02:29.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.246]                 "immediateCondition"))) {
[17:02:29.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.246]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.246]                   if (TRUE && !signal) {
[17:02:29.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.246]                     {
[17:02:29.246]                       inherits <- base::inherits
[17:02:29.246]                       invokeRestart <- base::invokeRestart
[17:02:29.246]                       is.null <- base::is.null
[17:02:29.246]                       muffled <- FALSE
[17:02:29.246]                       if (inherits(cond, "message")) {
[17:02:29.246]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.246]                         if (muffled) 
[17:02:29.246]                           invokeRestart("muffleMessage")
[17:02:29.246]                       }
[17:02:29.246]                       else if (inherits(cond, "warning")) {
[17:02:29.246]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.246]                         if (muffled) 
[17:02:29.246]                           invokeRestart("muffleWarning")
[17:02:29.246]                       }
[17:02:29.246]                       else if (inherits(cond, "condition")) {
[17:02:29.246]                         if (!is.null(pattern)) {
[17:02:29.246]                           computeRestarts <- base::computeRestarts
[17:02:29.246]                           grepl <- base::grepl
[17:02:29.246]                           restarts <- computeRestarts(cond)
[17:02:29.246]                           for (restart in restarts) {
[17:02:29.246]                             name <- restart$name
[17:02:29.246]                             if (is.null(name)) 
[17:02:29.246]                               next
[17:02:29.246]                             if (!grepl(pattern, name)) 
[17:02:29.246]                               next
[17:02:29.246]                             invokeRestart(restart)
[17:02:29.246]                             muffled <- TRUE
[17:02:29.246]                             break
[17:02:29.246]                           }
[17:02:29.246]                         }
[17:02:29.246]                       }
[17:02:29.246]                       invisible(muffled)
[17:02:29.246]                     }
[17:02:29.246]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.246]                   }
[17:02:29.246]                 }
[17:02:29.246]                 else {
[17:02:29.246]                   if (TRUE) {
[17:02:29.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.246]                     {
[17:02:29.246]                       inherits <- base::inherits
[17:02:29.246]                       invokeRestart <- base::invokeRestart
[17:02:29.246]                       is.null <- base::is.null
[17:02:29.246]                       muffled <- FALSE
[17:02:29.246]                       if (inherits(cond, "message")) {
[17:02:29.246]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.246]                         if (muffled) 
[17:02:29.246]                           invokeRestart("muffleMessage")
[17:02:29.246]                       }
[17:02:29.246]                       else if (inherits(cond, "warning")) {
[17:02:29.246]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.246]                         if (muffled) 
[17:02:29.246]                           invokeRestart("muffleWarning")
[17:02:29.246]                       }
[17:02:29.246]                       else if (inherits(cond, "condition")) {
[17:02:29.246]                         if (!is.null(pattern)) {
[17:02:29.246]                           computeRestarts <- base::computeRestarts
[17:02:29.246]                           grepl <- base::grepl
[17:02:29.246]                           restarts <- computeRestarts(cond)
[17:02:29.246]                           for (restart in restarts) {
[17:02:29.246]                             name <- restart$name
[17:02:29.246]                             if (is.null(name)) 
[17:02:29.246]                               next
[17:02:29.246]                             if (!grepl(pattern, name)) 
[17:02:29.246]                               next
[17:02:29.246]                             invokeRestart(restart)
[17:02:29.246]                             muffled <- TRUE
[17:02:29.246]                             break
[17:02:29.246]                           }
[17:02:29.246]                         }
[17:02:29.246]                       }
[17:02:29.246]                       invisible(muffled)
[17:02:29.246]                     }
[17:02:29.246]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.246]                   }
[17:02:29.246]                 }
[17:02:29.246]             }
[17:02:29.246]         }))
[17:02:29.246]     }, error = function(ex) {
[17:02:29.246]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.246]                 ...future.rng), started = ...future.startTime, 
[17:02:29.246]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.246]             version = "1.8"), class = "FutureResult")
[17:02:29.246]     }, finally = {
[17:02:29.246]         if (!identical(...future.workdir, getwd())) 
[17:02:29.246]             setwd(...future.workdir)
[17:02:29.246]         {
[17:02:29.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.246]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.246]             }
[17:02:29.246]             base::options(...future.oldOptions)
[17:02:29.246]             if (.Platform$OS.type == "windows") {
[17:02:29.246]                 old_names <- names(...future.oldEnvVars)
[17:02:29.246]                 envs <- base::Sys.getenv()
[17:02:29.246]                 names <- names(envs)
[17:02:29.246]                 common <- intersect(names, old_names)
[17:02:29.246]                 added <- setdiff(names, old_names)
[17:02:29.246]                 removed <- setdiff(old_names, names)
[17:02:29.246]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.246]                   envs[common]]
[17:02:29.246]                 NAMES <- toupper(changed)
[17:02:29.246]                 args <- list()
[17:02:29.246]                 for (kk in seq_along(NAMES)) {
[17:02:29.246]                   name <- changed[[kk]]
[17:02:29.246]                   NAME <- NAMES[[kk]]
[17:02:29.246]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.246]                     next
[17:02:29.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.246]                 }
[17:02:29.246]                 NAMES <- toupper(added)
[17:02:29.246]                 for (kk in seq_along(NAMES)) {
[17:02:29.246]                   name <- added[[kk]]
[17:02:29.246]                   NAME <- NAMES[[kk]]
[17:02:29.246]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.246]                     next
[17:02:29.246]                   args[[name]] <- ""
[17:02:29.246]                 }
[17:02:29.246]                 NAMES <- toupper(removed)
[17:02:29.246]                 for (kk in seq_along(NAMES)) {
[17:02:29.246]                   name <- removed[[kk]]
[17:02:29.246]                   NAME <- NAMES[[kk]]
[17:02:29.246]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.246]                     next
[17:02:29.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.246]                 }
[17:02:29.246]                 if (length(args) > 0) 
[17:02:29.246]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.246]             }
[17:02:29.246]             else {
[17:02:29.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.246]             }
[17:02:29.246]             {
[17:02:29.246]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.246]                   0L) {
[17:02:29.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.246]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.246]                   base::options(opts)
[17:02:29.246]                 }
[17:02:29.246]                 {
[17:02:29.246]                   {
[17:02:29.246]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:29.246]                     NULL
[17:02:29.246]                   }
[17:02:29.246]                   options(future.plan = NULL)
[17:02:29.246]                   if (is.na(NA_character_)) 
[17:02:29.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.246]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.246]                     .init = FALSE)
[17:02:29.246]                 }
[17:02:29.246]             }
[17:02:29.246]         }
[17:02:29.246]     })
[17:02:29.246]     if (TRUE) {
[17:02:29.246]         base::sink(type = "output", split = FALSE)
[17:02:29.246]         if (TRUE) {
[17:02:29.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.246]         }
[17:02:29.246]         else {
[17:02:29.246]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.246]         }
[17:02:29.246]         base::close(...future.stdout)
[17:02:29.246]         ...future.stdout <- NULL
[17:02:29.246]     }
[17:02:29.246]     ...future.result$conditions <- ...future.conditions
[17:02:29.246]     ...future.result$finished <- base::Sys.time()
[17:02:29.246]     ...future.result
[17:02:29.246] }
[17:02:29.249] requestCore(): workers = 2
[17:02:29.251] MulticoreFuture started
[17:02:29.251] - Launch lazy future ... done
[17:02:29.251] run() for ‘MulticoreFuture’ ... done
[17:02:29.252] getGlobalsAndPackages() ...
[17:02:29.252] plan(): Setting new future strategy stack:
[17:02:29.252] Searching for globals...
[17:02:29.252] List of future strategies:
[17:02:29.252] 1. sequential:
[17:02:29.252]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.252]    - tweaked: FALSE
[17:02:29.252]    - call: NULL
[17:02:29.253] 
[17:02:29.253] Searching for globals ... DONE
[17:02:29.253] plan(): nbrOfWorkers() = 1
[17:02:29.253] - globals: [0] <none>
[17:02:29.254] getGlobalsAndPackages() ... DONE
[17:02:29.254] run() for ‘Future’ ...
[17:02:29.254] - state: ‘created’
[17:02:29.255] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:29.255] plan(): Setting new future strategy stack:
[17:02:29.255] List of future strategies:
[17:02:29.255] 1. multicore:
[17:02:29.255]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:29.255]    - tweaked: FALSE
[17:02:29.255]    - call: plan(strategy)
[17:02:29.259] plan(): nbrOfWorkers() = 2
[17:02:29.260] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:29.260] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:29.260]   - Field: ‘label’
[17:02:29.260]   - Field: ‘local’
[17:02:29.261]   - Field: ‘owner’
[17:02:29.261]   - Field: ‘envir’
[17:02:29.261]   - Field: ‘workers’
[17:02:29.261]   - Field: ‘packages’
[17:02:29.261]   - Field: ‘gc’
[17:02:29.261]   - Field: ‘job’
[17:02:29.262]   - Field: ‘conditions’
[17:02:29.262]   - Field: ‘expr’
[17:02:29.262]   - Field: ‘uuid’
[17:02:29.262]   - Field: ‘seed’
[17:02:29.262]   - Field: ‘version’
[17:02:29.262]   - Field: ‘result’
[17:02:29.262]   - Field: ‘asynchronous’
[17:02:29.263]   - Field: ‘calls’
[17:02:29.263]   - Field: ‘globals’
[17:02:29.263]   - Field: ‘stdout’
[17:02:29.263]   - Field: ‘earlySignal’
[17:02:29.263]   - Field: ‘lazy’
[17:02:29.263]   - Field: ‘state’
[17:02:29.263] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:29.264] - Launch lazy future ...
[17:02:29.264] Packages needed by the future expression (n = 0): <none>
[17:02:29.264] Packages needed by future strategies (n = 0): <none>
[17:02:29.265] {
[17:02:29.265]     {
[17:02:29.265]         {
[17:02:29.265]             ...future.startTime <- base::Sys.time()
[17:02:29.265]             {
[17:02:29.265]                 {
[17:02:29.265]                   {
[17:02:29.265]                     {
[17:02:29.265]                       base::local({
[17:02:29.265]                         has_future <- base::requireNamespace("future", 
[17:02:29.265]                           quietly = TRUE)
[17:02:29.265]                         if (has_future) {
[17:02:29.265]                           ns <- base::getNamespace("future")
[17:02:29.265]                           version <- ns[[".package"]][["version"]]
[17:02:29.265]                           if (is.null(version)) 
[17:02:29.265]                             version <- utils::packageVersion("future")
[17:02:29.265]                         }
[17:02:29.265]                         else {
[17:02:29.265]                           version <- NULL
[17:02:29.265]                         }
[17:02:29.265]                         if (!has_future || version < "1.8.0") {
[17:02:29.265]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.265]                             "", base::R.version$version.string), 
[17:02:29.265]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:29.265]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.265]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.265]                               "release", "version")], collapse = " "), 
[17:02:29.265]                             hostname = base::Sys.info()[["nodename"]])
[17:02:29.265]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.265]                             info)
[17:02:29.265]                           info <- base::paste(info, collapse = "; ")
[17:02:29.265]                           if (!has_future) {
[17:02:29.265]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.265]                               info)
[17:02:29.265]                           }
[17:02:29.265]                           else {
[17:02:29.265]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.265]                               info, version)
[17:02:29.265]                           }
[17:02:29.265]                           base::stop(msg)
[17:02:29.265]                         }
[17:02:29.265]                       })
[17:02:29.265]                     }
[17:02:29.265]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:29.265]                     base::options(mc.cores = 1L)
[17:02:29.265]                   }
[17:02:29.265]                   ...future.strategy.old <- future::plan("list")
[17:02:29.265]                   options(future.plan = NULL)
[17:02:29.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.265]                 }
[17:02:29.265]                 ...future.workdir <- getwd()
[17:02:29.265]             }
[17:02:29.265]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.265]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.265]         }
[17:02:29.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.265]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.265]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.265]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.265]             base::names(...future.oldOptions))
[17:02:29.265]     }
[17:02:29.265]     if (FALSE) {
[17:02:29.265]     }
[17:02:29.265]     else {
[17:02:29.265]         if (TRUE) {
[17:02:29.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.265]                 open = "w")
[17:02:29.265]         }
[17:02:29.265]         else {
[17:02:29.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.265]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.265]         }
[17:02:29.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.265]             base::sink(type = "output", split = FALSE)
[17:02:29.265]             base::close(...future.stdout)
[17:02:29.265]         }, add = TRUE)
[17:02:29.265]     }
[17:02:29.265]     ...future.frame <- base::sys.nframe()
[17:02:29.265]     ...future.conditions <- base::list()
[17:02:29.265]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.265]     if (FALSE) {
[17:02:29.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.265]     }
[17:02:29.265]     ...future.result <- base::tryCatch({
[17:02:29.265]         base::withCallingHandlers({
[17:02:29.265]             ...future.value <- base::withVisible(base::local({
[17:02:29.265]                 withCallingHandlers({
[17:02:29.265]                   NULL
[17:02:29.265]                 }, immediateCondition = function(cond) {
[17:02:29.265]                   save_rds <- function (object, pathname, ...) 
[17:02:29.265]                   {
[17:02:29.265]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:29.265]                     if (file_test("-f", pathname_tmp)) {
[17:02:29.265]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.265]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:29.265]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.265]                         fi_tmp[["mtime"]])
[17:02:29.265]                     }
[17:02:29.265]                     tryCatch({
[17:02:29.265]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:29.265]                     }, error = function(ex) {
[17:02:29.265]                       msg <- conditionMessage(ex)
[17:02:29.265]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.265]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:29.265]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.265]                         fi_tmp[["mtime"]], msg)
[17:02:29.265]                       ex$message <- msg
[17:02:29.265]                       stop(ex)
[17:02:29.265]                     })
[17:02:29.265]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:29.265]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:29.265]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:29.265]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.265]                       fi <- file.info(pathname)
[17:02:29.265]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:29.265]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.265]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:29.265]                         fi[["size"]], fi[["mtime"]])
[17:02:29.265]                       stop(msg)
[17:02:29.265]                     }
[17:02:29.265]                     invisible(pathname)
[17:02:29.265]                   }
[17:02:29.265]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:29.265]                     rootPath = tempdir()) 
[17:02:29.265]                   {
[17:02:29.265]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:29.265]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:29.265]                       tmpdir = path, fileext = ".rds")
[17:02:29.265]                     save_rds(obj, file)
[17:02:29.265]                   }
[17:02:29.265]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:29.265]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.265]                   {
[17:02:29.265]                     inherits <- base::inherits
[17:02:29.265]                     invokeRestart <- base::invokeRestart
[17:02:29.265]                     is.null <- base::is.null
[17:02:29.265]                     muffled <- FALSE
[17:02:29.265]                     if (inherits(cond, "message")) {
[17:02:29.265]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:29.265]                       if (muffled) 
[17:02:29.265]                         invokeRestart("muffleMessage")
[17:02:29.265]                     }
[17:02:29.265]                     else if (inherits(cond, "warning")) {
[17:02:29.265]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:29.265]                       if (muffled) 
[17:02:29.265]                         invokeRestart("muffleWarning")
[17:02:29.265]                     }
[17:02:29.265]                     else if (inherits(cond, "condition")) {
[17:02:29.265]                       if (!is.null(pattern)) {
[17:02:29.265]                         computeRestarts <- base::computeRestarts
[17:02:29.265]                         grepl <- base::grepl
[17:02:29.265]                         restarts <- computeRestarts(cond)
[17:02:29.265]                         for (restart in restarts) {
[17:02:29.265]                           name <- restart$name
[17:02:29.265]                           if (is.null(name)) 
[17:02:29.265]                             next
[17:02:29.265]                           if (!grepl(pattern, name)) 
[17:02:29.265]                             next
[17:02:29.265]                           invokeRestart(restart)
[17:02:29.265]                           muffled <- TRUE
[17:02:29.265]                           break
[17:02:29.265]                         }
[17:02:29.265]                       }
[17:02:29.265]                     }
[17:02:29.265]                     invisible(muffled)
[17:02:29.265]                   }
[17:02:29.265]                   muffleCondition(cond)
[17:02:29.265]                 })
[17:02:29.265]             }))
[17:02:29.265]             future::FutureResult(value = ...future.value$value, 
[17:02:29.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.265]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.265]                     ...future.globalenv.names))
[17:02:29.265]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.265]         }, condition = base::local({
[17:02:29.265]             c <- base::c
[17:02:29.265]             inherits <- base::inherits
[17:02:29.265]             invokeRestart <- base::invokeRestart
[17:02:29.265]             length <- base::length
[17:02:29.265]             list <- base::list
[17:02:29.265]             seq.int <- base::seq.int
[17:02:29.265]             signalCondition <- base::signalCondition
[17:02:29.265]             sys.calls <- base::sys.calls
[17:02:29.265]             `[[` <- base::`[[`
[17:02:29.265]             `+` <- base::`+`
[17:02:29.265]             `<<-` <- base::`<<-`
[17:02:29.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.265]                   3L)]
[17:02:29.265]             }
[17:02:29.265]             function(cond) {
[17:02:29.265]                 is_error <- inherits(cond, "error")
[17:02:29.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.265]                   NULL)
[17:02:29.265]                 if (is_error) {
[17:02:29.265]                   sessionInformation <- function() {
[17:02:29.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.265]                       search = base::search(), system = base::Sys.info())
[17:02:29.265]                   }
[17:02:29.265]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.265]                     cond$call), session = sessionInformation(), 
[17:02:29.265]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.265]                   signalCondition(cond)
[17:02:29.265]                 }
[17:02:29.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.265]                 "immediateCondition"))) {
[17:02:29.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.265]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.265]                   if (TRUE && !signal) {
[17:02:29.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.265]                     {
[17:02:29.265]                       inherits <- base::inherits
[17:02:29.265]                       invokeRestart <- base::invokeRestart
[17:02:29.265]                       is.null <- base::is.null
[17:02:29.265]                       muffled <- FALSE
[17:02:29.265]                       if (inherits(cond, "message")) {
[17:02:29.265]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.265]                         if (muffled) 
[17:02:29.265]                           invokeRestart("muffleMessage")
[17:02:29.265]                       }
[17:02:29.265]                       else if (inherits(cond, "warning")) {
[17:02:29.265]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.265]                         if (muffled) 
[17:02:29.265]                           invokeRestart("muffleWarning")
[17:02:29.265]                       }
[17:02:29.265]                       else if (inherits(cond, "condition")) {
[17:02:29.265]                         if (!is.null(pattern)) {
[17:02:29.265]                           computeRestarts <- base::computeRestarts
[17:02:29.265]                           grepl <- base::grepl
[17:02:29.265]                           restarts <- computeRestarts(cond)
[17:02:29.265]                           for (restart in restarts) {
[17:02:29.265]                             name <- restart$name
[17:02:29.265]                             if (is.null(name)) 
[17:02:29.265]                               next
[17:02:29.265]                             if (!grepl(pattern, name)) 
[17:02:29.265]                               next
[17:02:29.265]                             invokeRestart(restart)
[17:02:29.265]                             muffled <- TRUE
[17:02:29.265]                             break
[17:02:29.265]                           }
[17:02:29.265]                         }
[17:02:29.265]                       }
[17:02:29.265]                       invisible(muffled)
[17:02:29.265]                     }
[17:02:29.265]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.265]                   }
[17:02:29.265]                 }
[17:02:29.265]                 else {
[17:02:29.265]                   if (TRUE) {
[17:02:29.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.265]                     {
[17:02:29.265]                       inherits <- base::inherits
[17:02:29.265]                       invokeRestart <- base::invokeRestart
[17:02:29.265]                       is.null <- base::is.null
[17:02:29.265]                       muffled <- FALSE
[17:02:29.265]                       if (inherits(cond, "message")) {
[17:02:29.265]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.265]                         if (muffled) 
[17:02:29.265]                           invokeRestart("muffleMessage")
[17:02:29.265]                       }
[17:02:29.265]                       else if (inherits(cond, "warning")) {
[17:02:29.265]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.265]                         if (muffled) 
[17:02:29.265]                           invokeRestart("muffleWarning")
[17:02:29.265]                       }
[17:02:29.265]                       else if (inherits(cond, "condition")) {
[17:02:29.265]                         if (!is.null(pattern)) {
[17:02:29.265]                           computeRestarts <- base::computeRestarts
[17:02:29.265]                           grepl <- base::grepl
[17:02:29.265]                           restarts <- computeRestarts(cond)
[17:02:29.265]                           for (restart in restarts) {
[17:02:29.265]                             name <- restart$name
[17:02:29.265]                             if (is.null(name)) 
[17:02:29.265]                               next
[17:02:29.265]                             if (!grepl(pattern, name)) 
[17:02:29.265]                               next
[17:02:29.265]                             invokeRestart(restart)
[17:02:29.265]                             muffled <- TRUE
[17:02:29.265]                             break
[17:02:29.265]                           }
[17:02:29.265]                         }
[17:02:29.265]                       }
[17:02:29.265]                       invisible(muffled)
[17:02:29.265]                     }
[17:02:29.265]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.265]                   }
[17:02:29.265]                 }
[17:02:29.265]             }
[17:02:29.265]         }))
[17:02:29.265]     }, error = function(ex) {
[17:02:29.265]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.265]                 ...future.rng), started = ...future.startTime, 
[17:02:29.265]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.265]             version = "1.8"), class = "FutureResult")
[17:02:29.265]     }, finally = {
[17:02:29.265]         if (!identical(...future.workdir, getwd())) 
[17:02:29.265]             setwd(...future.workdir)
[17:02:29.265]         {
[17:02:29.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.265]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.265]             }
[17:02:29.265]             base::options(...future.oldOptions)
[17:02:29.265]             if (.Platform$OS.type == "windows") {
[17:02:29.265]                 old_names <- names(...future.oldEnvVars)
[17:02:29.265]                 envs <- base::Sys.getenv()
[17:02:29.265]                 names <- names(envs)
[17:02:29.265]                 common <- intersect(names, old_names)
[17:02:29.265]                 added <- setdiff(names, old_names)
[17:02:29.265]                 removed <- setdiff(old_names, names)
[17:02:29.265]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.265]                   envs[common]]
[17:02:29.265]                 NAMES <- toupper(changed)
[17:02:29.265]                 args <- list()
[17:02:29.265]                 for (kk in seq_along(NAMES)) {
[17:02:29.265]                   name <- changed[[kk]]
[17:02:29.265]                   NAME <- NAMES[[kk]]
[17:02:29.265]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.265]                     next
[17:02:29.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.265]                 }
[17:02:29.265]                 NAMES <- toupper(added)
[17:02:29.265]                 for (kk in seq_along(NAMES)) {
[17:02:29.265]                   name <- added[[kk]]
[17:02:29.265]                   NAME <- NAMES[[kk]]
[17:02:29.265]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.265]                     next
[17:02:29.265]                   args[[name]] <- ""
[17:02:29.265]                 }
[17:02:29.265]                 NAMES <- toupper(removed)
[17:02:29.265]                 for (kk in seq_along(NAMES)) {
[17:02:29.265]                   name <- removed[[kk]]
[17:02:29.265]                   NAME <- NAMES[[kk]]
[17:02:29.265]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.265]                     next
[17:02:29.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.265]                 }
[17:02:29.265]                 if (length(args) > 0) 
[17:02:29.265]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.265]             }
[17:02:29.265]             else {
[17:02:29.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.265]             }
[17:02:29.265]             {
[17:02:29.265]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.265]                   0L) {
[17:02:29.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.265]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.265]                   base::options(opts)
[17:02:29.265]                 }
[17:02:29.265]                 {
[17:02:29.265]                   {
[17:02:29.265]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:29.265]                     NULL
[17:02:29.265]                   }
[17:02:29.265]                   options(future.plan = NULL)
[17:02:29.265]                   if (is.na(NA_character_)) 
[17:02:29.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.265]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.265]                     .init = FALSE)
[17:02:29.265]                 }
[17:02:29.265]             }
[17:02:29.265]         }
[17:02:29.265]     })
[17:02:29.265]     if (TRUE) {
[17:02:29.265]         base::sink(type = "output", split = FALSE)
[17:02:29.265]         if (TRUE) {
[17:02:29.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.265]         }
[17:02:29.265]         else {
[17:02:29.265]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.265]         }
[17:02:29.265]         base::close(...future.stdout)
[17:02:29.265]         ...future.stdout <- NULL
[17:02:29.265]     }
[17:02:29.265]     ...future.result$conditions <- ...future.conditions
[17:02:29.265]     ...future.result$finished <- base::Sys.time()
[17:02:29.265]     ...future.result
[17:02:29.265] }
[17:02:29.268] requestCore(): workers = 2
[17:02:29.271] MulticoreFuture started
[17:02:29.271] - Launch lazy future ... done
[17:02:29.271] run() for ‘MulticoreFuture’ ... done
List of 6
[17:02:29.272] plan(): Setting new future strategy stack:
 $ a: num 1
 $ b:[17:02:29.272] List of future strategies:
[17:02:29.272] 1. sequential:
[17:02:29.272]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.272]    - tweaked: FALSE
[17:02:29.272]    - call: NULL
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' [17:02:29.273] plan(): nbrOfWorkers() = 1
<environment: 0x55c749d031a8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c7477e0560> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 [17:02:29.275] plan(): Setting new future strategy stack:
$ a: num 1
[17:02:29.275] List of future strategies:
[17:02:29.275] 1. multicore:
[17:02:29.275]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:29.275]    - tweaked: FALSE
[17:02:29.275]    - call: plan(strategy)
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c749d031a8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c7477e0560> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:02:29.280] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:29.283] resolve() on list ...
[17:02:29.283]  recursive: 0
[17:02:29.283]  length: 6
[17:02:29.284]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:29.284] signalConditionsASAP(numeric, pos=1) ...
[17:02:29.284] - nx: 6
[17:02:29.284] - relay: TRUE
[17:02:29.284] - stdout: TRUE
[17:02:29.284] - signal: TRUE
[17:02:29.284] - resignal: FALSE
[17:02:29.285] - force: TRUE
[17:02:29.285] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.285] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.285]  - until=2
[17:02:29.285]  - relaying element #2
[17:02:29.285] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.285] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.286] signalConditionsASAP(NULL, pos=1) ... done
[17:02:29.286]  length: 5 (resolved future 1)
[17:02:29.286] Future #2
[17:02:29.286] result() for MulticoreFuture ...
[17:02:29.287] result() for MulticoreFuture ...
[17:02:29.287] result() for MulticoreFuture ... done
[17:02:29.287] result() for MulticoreFuture ... done
[17:02:29.288] result() for MulticoreFuture ...
[17:02:29.288] result() for MulticoreFuture ... done
[17:02:29.288] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:29.288] - nx: 6
[17:02:29.288] - relay: TRUE
[17:02:29.288] - stdout: TRUE
[17:02:29.289] - signal: TRUE
[17:02:29.289] - resignal: FALSE
[17:02:29.289] - force: TRUE
[17:02:29.289] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.289] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.289]  - until=2
[17:02:29.289]  - relaying element #2
[17:02:29.289] result() for MulticoreFuture ...
[17:02:29.290] result() for MulticoreFuture ... done
[17:02:29.290] result() for MulticoreFuture ...
[17:02:29.290] result() for MulticoreFuture ... done
[17:02:29.290] result() for MulticoreFuture ...
[17:02:29.290] result() for MulticoreFuture ... done
[17:02:29.290] result() for MulticoreFuture ...
[17:02:29.290] result() for MulticoreFuture ... done
[17:02:29.291] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.291] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.291] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:29.291]  length: 4 (resolved future 2)
[17:02:29.291] Future #3
[17:02:29.291] result() for MulticoreFuture ...
[17:02:29.292] result() for MulticoreFuture ...
[17:02:29.292] result() for MulticoreFuture ... done
[17:02:29.292] result() for MulticoreFuture ... done
[17:02:29.292] result() for MulticoreFuture ...
[17:02:29.293] result() for MulticoreFuture ... done
[17:02:29.293] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:29.293] - nx: 6
[17:02:29.293] - relay: TRUE
[17:02:29.293] - stdout: TRUE
[17:02:29.293] - signal: TRUE
[17:02:29.293] - resignal: FALSE
[17:02:29.293] - force: TRUE
[17:02:29.294] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.294] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.294]  - until=3
[17:02:29.294]  - relaying element #3
[17:02:29.294] result() for MulticoreFuture ...
[17:02:29.294] result() for MulticoreFuture ... done
[17:02:29.294] result() for MulticoreFuture ...
[17:02:29.294] result() for MulticoreFuture ... done
[17:02:29.295] result() for MulticoreFuture ...
[17:02:29.295] result() for MulticoreFuture ... done
[17:02:29.295] result() for MulticoreFuture ...
[17:02:29.295] result() for MulticoreFuture ... done
[17:02:29.295] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.295] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.297] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:29.298]  length: 3 (resolved future 3)
[17:02:29.298] signalConditionsASAP(NULL, pos=4) ...
[17:02:29.298] - nx: 6
[17:02:29.298] - relay: TRUE
[17:02:29.298] - stdout: TRUE
[17:02:29.298] - signal: TRUE
[17:02:29.299] - resignal: FALSE
[17:02:29.299] - force: TRUE
[17:02:29.299] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.299] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.299]  - until=5
[17:02:29.299]  - relaying element #5
[17:02:29.299] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.300] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.300] signalConditionsASAP(NULL, pos=4) ... done
[17:02:29.300]  length: 2 (resolved future 4)
[17:02:29.300] signalConditionsASAP(NULL, pos=5) ...
[17:02:29.300] - nx: 6
[17:02:29.300] - relay: TRUE
[17:02:29.300] - stdout: TRUE
[17:02:29.300] - signal: TRUE
[17:02:29.300] - resignal: FALSE
[17:02:29.301] - force: TRUE
[17:02:29.301] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.301] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.301]  - until=6
[17:02:29.301]  - relaying element #6
[17:02:29.301] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.301] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.301] signalConditionsASAP(NULL, pos=5) ... done
[17:02:29.301]  length: 1 (resolved future 5)
[17:02:29.302] signalConditionsASAP(numeric, pos=6) ...
[17:02:29.302] - nx: 6
[17:02:29.302] - relay: TRUE
[17:02:29.302] - stdout: TRUE
[17:02:29.302] - signal: TRUE
[17:02:29.302] - resignal: FALSE
[17:02:29.302] - force: TRUE
[17:02:29.302] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.302] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.302]  - until=6
[17:02:29.303] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.303] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.303] signalConditionsASAP(numeric, pos=6) ... done
[17:02:29.303]  length: 0 (resolved future 6)
[17:02:29.303] Relaying remaining futures
[17:02:29.303] signalConditionsASAP(NULL, pos=0) ...
[17:02:29.303] - nx: 6
[17:02:29.303] - relay: TRUE
[17:02:29.303] - stdout: TRUE
[17:02:29.304] - signal: TRUE
[17:02:29.304] - resignal: FALSE
[17:02:29.304] - force: TRUE
[17:02:29.304] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.304] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:29.304] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.304] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.304] signalConditionsASAP(NULL, pos=0) ... done
[17:02:29.304] resolve() on list ... DONE
[17:02:29.305] result() for MulticoreFuture ...
[17:02:29.305] result() for MulticoreFuture ... done
[17:02:29.305] result() for MulticoreFuture ...
[17:02:29.305] result() for MulticoreFuture ... done
[17:02:29.305] result() for MulticoreFuture ...
[17:02:29.305] result() for MulticoreFuture ... done
[17:02:29.305] result() for MulticoreFuture ...
[17:02:29.305] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:02:29.309] getGlobalsAndPackages() ...
[17:02:29.309] Searching for globals...
[17:02:29.309] 
[17:02:29.309] Searching for globals ... DONE
[17:02:29.310] - globals: [0] <none>
[17:02:29.310] getGlobalsAndPackages() ... DONE
[17:02:29.310] run() for ‘Future’ ...
[17:02:29.310] - state: ‘created’
[17:02:29.310] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:29.314] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:29.314] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:29.314]   - Field: ‘label’
[17:02:29.314]   - Field: ‘local’
[17:02:29.314]   - Field: ‘owner’
[17:02:29.314]   - Field: ‘envir’
[17:02:29.315]   - Field: ‘workers’
[17:02:29.315]   - Field: ‘packages’
[17:02:29.315]   - Field: ‘gc’
[17:02:29.315]   - Field: ‘job’
[17:02:29.315]   - Field: ‘conditions’
[17:02:29.315]   - Field: ‘expr’
[17:02:29.315]   - Field: ‘uuid’
[17:02:29.315]   - Field: ‘seed’
[17:02:29.315]   - Field: ‘version’
[17:02:29.315]   - Field: ‘result’
[17:02:29.316]   - Field: ‘asynchronous’
[17:02:29.316]   - Field: ‘calls’
[17:02:29.316]   - Field: ‘globals’
[17:02:29.316]   - Field: ‘stdout’
[17:02:29.316]   - Field: ‘earlySignal’
[17:02:29.316]   - Field: ‘lazy’
[17:02:29.316]   - Field: ‘state’
[17:02:29.316] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:29.316] - Launch lazy future ...
[17:02:29.317] Packages needed by the future expression (n = 0): <none>
[17:02:29.317] Packages needed by future strategies (n = 0): <none>
[17:02:29.317] {
[17:02:29.317]     {
[17:02:29.317]         {
[17:02:29.317]             ...future.startTime <- base::Sys.time()
[17:02:29.317]             {
[17:02:29.317]                 {
[17:02:29.317]                   {
[17:02:29.317]                     {
[17:02:29.317]                       base::local({
[17:02:29.317]                         has_future <- base::requireNamespace("future", 
[17:02:29.317]                           quietly = TRUE)
[17:02:29.317]                         if (has_future) {
[17:02:29.317]                           ns <- base::getNamespace("future")
[17:02:29.317]                           version <- ns[[".package"]][["version"]]
[17:02:29.317]                           if (is.null(version)) 
[17:02:29.317]                             version <- utils::packageVersion("future")
[17:02:29.317]                         }
[17:02:29.317]                         else {
[17:02:29.317]                           version <- NULL
[17:02:29.317]                         }
[17:02:29.317]                         if (!has_future || version < "1.8.0") {
[17:02:29.317]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.317]                             "", base::R.version$version.string), 
[17:02:29.317]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:29.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.317]                               "release", "version")], collapse = " "), 
[17:02:29.317]                             hostname = base::Sys.info()[["nodename"]])
[17:02:29.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.317]                             info)
[17:02:29.317]                           info <- base::paste(info, collapse = "; ")
[17:02:29.317]                           if (!has_future) {
[17:02:29.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.317]                               info)
[17:02:29.317]                           }
[17:02:29.317]                           else {
[17:02:29.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.317]                               info, version)
[17:02:29.317]                           }
[17:02:29.317]                           base::stop(msg)
[17:02:29.317]                         }
[17:02:29.317]                       })
[17:02:29.317]                     }
[17:02:29.317]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:29.317]                     base::options(mc.cores = 1L)
[17:02:29.317]                   }
[17:02:29.317]                   ...future.strategy.old <- future::plan("list")
[17:02:29.317]                   options(future.plan = NULL)
[17:02:29.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.317]                 }
[17:02:29.317]                 ...future.workdir <- getwd()
[17:02:29.317]             }
[17:02:29.317]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.317]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.317]         }
[17:02:29.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.317]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.317]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.317]             base::names(...future.oldOptions))
[17:02:29.317]     }
[17:02:29.317]     if (FALSE) {
[17:02:29.317]     }
[17:02:29.317]     else {
[17:02:29.317]         if (TRUE) {
[17:02:29.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.317]                 open = "w")
[17:02:29.317]         }
[17:02:29.317]         else {
[17:02:29.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.317]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.317]         }
[17:02:29.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.317]             base::sink(type = "output", split = FALSE)
[17:02:29.317]             base::close(...future.stdout)
[17:02:29.317]         }, add = TRUE)
[17:02:29.317]     }
[17:02:29.317]     ...future.frame <- base::sys.nframe()
[17:02:29.317]     ...future.conditions <- base::list()
[17:02:29.317]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.317]     if (FALSE) {
[17:02:29.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.317]     }
[17:02:29.317]     ...future.result <- base::tryCatch({
[17:02:29.317]         base::withCallingHandlers({
[17:02:29.317]             ...future.value <- base::withVisible(base::local({
[17:02:29.317]                 withCallingHandlers({
[17:02:29.317]                   2
[17:02:29.317]                 }, immediateCondition = function(cond) {
[17:02:29.317]                   save_rds <- function (object, pathname, ...) 
[17:02:29.317]                   {
[17:02:29.317]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:29.317]                     if (file_test("-f", pathname_tmp)) {
[17:02:29.317]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.317]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:29.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.317]                         fi_tmp[["mtime"]])
[17:02:29.317]                     }
[17:02:29.317]                     tryCatch({
[17:02:29.317]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:29.317]                     }, error = function(ex) {
[17:02:29.317]                       msg <- conditionMessage(ex)
[17:02:29.317]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.317]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:29.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.317]                         fi_tmp[["mtime"]], msg)
[17:02:29.317]                       ex$message <- msg
[17:02:29.317]                       stop(ex)
[17:02:29.317]                     })
[17:02:29.317]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:29.317]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:29.317]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:29.317]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.317]                       fi <- file.info(pathname)
[17:02:29.317]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:29.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.317]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:29.317]                         fi[["size"]], fi[["mtime"]])
[17:02:29.317]                       stop(msg)
[17:02:29.317]                     }
[17:02:29.317]                     invisible(pathname)
[17:02:29.317]                   }
[17:02:29.317]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:29.317]                     rootPath = tempdir()) 
[17:02:29.317]                   {
[17:02:29.317]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:29.317]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:29.317]                       tmpdir = path, fileext = ".rds")
[17:02:29.317]                     save_rds(obj, file)
[17:02:29.317]                   }
[17:02:29.317]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:29.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.317]                   {
[17:02:29.317]                     inherits <- base::inherits
[17:02:29.317]                     invokeRestart <- base::invokeRestart
[17:02:29.317]                     is.null <- base::is.null
[17:02:29.317]                     muffled <- FALSE
[17:02:29.317]                     if (inherits(cond, "message")) {
[17:02:29.317]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:29.317]                       if (muffled) 
[17:02:29.317]                         invokeRestart("muffleMessage")
[17:02:29.317]                     }
[17:02:29.317]                     else if (inherits(cond, "warning")) {
[17:02:29.317]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:29.317]                       if (muffled) 
[17:02:29.317]                         invokeRestart("muffleWarning")
[17:02:29.317]                     }
[17:02:29.317]                     else if (inherits(cond, "condition")) {
[17:02:29.317]                       if (!is.null(pattern)) {
[17:02:29.317]                         computeRestarts <- base::computeRestarts
[17:02:29.317]                         grepl <- base::grepl
[17:02:29.317]                         restarts <- computeRestarts(cond)
[17:02:29.317]                         for (restart in restarts) {
[17:02:29.317]                           name <- restart$name
[17:02:29.317]                           if (is.null(name)) 
[17:02:29.317]                             next
[17:02:29.317]                           if (!grepl(pattern, name)) 
[17:02:29.317]                             next
[17:02:29.317]                           invokeRestart(restart)
[17:02:29.317]                           muffled <- TRUE
[17:02:29.317]                           break
[17:02:29.317]                         }
[17:02:29.317]                       }
[17:02:29.317]                     }
[17:02:29.317]                     invisible(muffled)
[17:02:29.317]                   }
[17:02:29.317]                   muffleCondition(cond)
[17:02:29.317]                 })
[17:02:29.317]             }))
[17:02:29.317]             future::FutureResult(value = ...future.value$value, 
[17:02:29.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.317]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.317]                     ...future.globalenv.names))
[17:02:29.317]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.317]         }, condition = base::local({
[17:02:29.317]             c <- base::c
[17:02:29.317]             inherits <- base::inherits
[17:02:29.317]             invokeRestart <- base::invokeRestart
[17:02:29.317]             length <- base::length
[17:02:29.317]             list <- base::list
[17:02:29.317]             seq.int <- base::seq.int
[17:02:29.317]             signalCondition <- base::signalCondition
[17:02:29.317]             sys.calls <- base::sys.calls
[17:02:29.317]             `[[` <- base::`[[`
[17:02:29.317]             `+` <- base::`+`
[17:02:29.317]             `<<-` <- base::`<<-`
[17:02:29.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.317]                   3L)]
[17:02:29.317]             }
[17:02:29.317]             function(cond) {
[17:02:29.317]                 is_error <- inherits(cond, "error")
[17:02:29.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.317]                   NULL)
[17:02:29.317]                 if (is_error) {
[17:02:29.317]                   sessionInformation <- function() {
[17:02:29.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.317]                       search = base::search(), system = base::Sys.info())
[17:02:29.317]                   }
[17:02:29.317]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.317]                     cond$call), session = sessionInformation(), 
[17:02:29.317]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.317]                   signalCondition(cond)
[17:02:29.317]                 }
[17:02:29.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.317]                 "immediateCondition"))) {
[17:02:29.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.317]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.317]                   if (TRUE && !signal) {
[17:02:29.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.317]                     {
[17:02:29.317]                       inherits <- base::inherits
[17:02:29.317]                       invokeRestart <- base::invokeRestart
[17:02:29.317]                       is.null <- base::is.null
[17:02:29.317]                       muffled <- FALSE
[17:02:29.317]                       if (inherits(cond, "message")) {
[17:02:29.317]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.317]                         if (muffled) 
[17:02:29.317]                           invokeRestart("muffleMessage")
[17:02:29.317]                       }
[17:02:29.317]                       else if (inherits(cond, "warning")) {
[17:02:29.317]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.317]                         if (muffled) 
[17:02:29.317]                           invokeRestart("muffleWarning")
[17:02:29.317]                       }
[17:02:29.317]                       else if (inherits(cond, "condition")) {
[17:02:29.317]                         if (!is.null(pattern)) {
[17:02:29.317]                           computeRestarts <- base::computeRestarts
[17:02:29.317]                           grepl <- base::grepl
[17:02:29.317]                           restarts <- computeRestarts(cond)
[17:02:29.317]                           for (restart in restarts) {
[17:02:29.317]                             name <- restart$name
[17:02:29.317]                             if (is.null(name)) 
[17:02:29.317]                               next
[17:02:29.317]                             if (!grepl(pattern, name)) 
[17:02:29.317]                               next
[17:02:29.317]                             invokeRestart(restart)
[17:02:29.317]                             muffled <- TRUE
[17:02:29.317]                             break
[17:02:29.317]                           }
[17:02:29.317]                         }
[17:02:29.317]                       }
[17:02:29.317]                       invisible(muffled)
[17:02:29.317]                     }
[17:02:29.317]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.317]                   }
[17:02:29.317]                 }
[17:02:29.317]                 else {
[17:02:29.317]                   if (TRUE) {
[17:02:29.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.317]                     {
[17:02:29.317]                       inherits <- base::inherits
[17:02:29.317]                       invokeRestart <- base::invokeRestart
[17:02:29.317]                       is.null <- base::is.null
[17:02:29.317]                       muffled <- FALSE
[17:02:29.317]                       if (inherits(cond, "message")) {
[17:02:29.317]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.317]                         if (muffled) 
[17:02:29.317]                           invokeRestart("muffleMessage")
[17:02:29.317]                       }
[17:02:29.317]                       else if (inherits(cond, "warning")) {
[17:02:29.317]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.317]                         if (muffled) 
[17:02:29.317]                           invokeRestart("muffleWarning")
[17:02:29.317]                       }
[17:02:29.317]                       else if (inherits(cond, "condition")) {
[17:02:29.317]                         if (!is.null(pattern)) {
[17:02:29.317]                           computeRestarts <- base::computeRestarts
[17:02:29.317]                           grepl <- base::grepl
[17:02:29.317]                           restarts <- computeRestarts(cond)
[17:02:29.317]                           for (restart in restarts) {
[17:02:29.317]                             name <- restart$name
[17:02:29.317]                             if (is.null(name)) 
[17:02:29.317]                               next
[17:02:29.317]                             if (!grepl(pattern, name)) 
[17:02:29.317]                               next
[17:02:29.317]                             invokeRestart(restart)
[17:02:29.317]                             muffled <- TRUE
[17:02:29.317]                             break
[17:02:29.317]                           }
[17:02:29.317]                         }
[17:02:29.317]                       }
[17:02:29.317]                       invisible(muffled)
[17:02:29.317]                     }
[17:02:29.317]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.317]                   }
[17:02:29.317]                 }
[17:02:29.317]             }
[17:02:29.317]         }))
[17:02:29.317]     }, error = function(ex) {
[17:02:29.317]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.317]                 ...future.rng), started = ...future.startTime, 
[17:02:29.317]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.317]             version = "1.8"), class = "FutureResult")
[17:02:29.317]     }, finally = {
[17:02:29.317]         if (!identical(...future.workdir, getwd())) 
[17:02:29.317]             setwd(...future.workdir)
[17:02:29.317]         {
[17:02:29.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.317]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.317]             }
[17:02:29.317]             base::options(...future.oldOptions)
[17:02:29.317]             if (.Platform$OS.type == "windows") {
[17:02:29.317]                 old_names <- names(...future.oldEnvVars)
[17:02:29.317]                 envs <- base::Sys.getenv()
[17:02:29.317]                 names <- names(envs)
[17:02:29.317]                 common <- intersect(names, old_names)
[17:02:29.317]                 added <- setdiff(names, old_names)
[17:02:29.317]                 removed <- setdiff(old_names, names)
[17:02:29.317]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.317]                   envs[common]]
[17:02:29.317]                 NAMES <- toupper(changed)
[17:02:29.317]                 args <- list()
[17:02:29.317]                 for (kk in seq_along(NAMES)) {
[17:02:29.317]                   name <- changed[[kk]]
[17:02:29.317]                   NAME <- NAMES[[kk]]
[17:02:29.317]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.317]                     next
[17:02:29.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.317]                 }
[17:02:29.317]                 NAMES <- toupper(added)
[17:02:29.317]                 for (kk in seq_along(NAMES)) {
[17:02:29.317]                   name <- added[[kk]]
[17:02:29.317]                   NAME <- NAMES[[kk]]
[17:02:29.317]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.317]                     next
[17:02:29.317]                   args[[name]] <- ""
[17:02:29.317]                 }
[17:02:29.317]                 NAMES <- toupper(removed)
[17:02:29.317]                 for (kk in seq_along(NAMES)) {
[17:02:29.317]                   name <- removed[[kk]]
[17:02:29.317]                   NAME <- NAMES[[kk]]
[17:02:29.317]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.317]                     next
[17:02:29.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.317]                 }
[17:02:29.317]                 if (length(args) > 0) 
[17:02:29.317]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.317]             }
[17:02:29.317]             else {
[17:02:29.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.317]             }
[17:02:29.317]             {
[17:02:29.317]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.317]                   0L) {
[17:02:29.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.317]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.317]                   base::options(opts)
[17:02:29.317]                 }
[17:02:29.317]                 {
[17:02:29.317]                   {
[17:02:29.317]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:29.317]                     NULL
[17:02:29.317]                   }
[17:02:29.317]                   options(future.plan = NULL)
[17:02:29.317]                   if (is.na(NA_character_)) 
[17:02:29.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.317]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.317]                     .init = FALSE)
[17:02:29.317]                 }
[17:02:29.317]             }
[17:02:29.317]         }
[17:02:29.317]     })
[17:02:29.317]     if (TRUE) {
[17:02:29.317]         base::sink(type = "output", split = FALSE)
[17:02:29.317]         if (TRUE) {
[17:02:29.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.317]         }
[17:02:29.317]         else {
[17:02:29.317]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.317]         }
[17:02:29.317]         base::close(...future.stdout)
[17:02:29.317]         ...future.stdout <- NULL
[17:02:29.317]     }
[17:02:29.317]     ...future.result$conditions <- ...future.conditions
[17:02:29.317]     ...future.result$finished <- base::Sys.time()
[17:02:29.317]     ...future.result
[17:02:29.317] }
[17:02:29.319] requestCore(): workers = 2
[17:02:29.321] MulticoreFuture started
[17:02:29.321] - Launch lazy future ... done
[17:02:29.322] run() for ‘MulticoreFuture’ ... done
[17:02:29.322] getGlobalsAndPackages() ...
[17:02:29.322] Searching for globals...
[17:02:29.322] plan(): Setting new future strategy stack:
[17:02:29.323] 
[17:02:29.322] List of future strategies:
[17:02:29.322] 1. sequential:
[17:02:29.322]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.322]    - tweaked: FALSE
[17:02:29.322]    - call: NULL
[17:02:29.323] Searching for globals ... DONE
[17:02:29.323] - globals: [0] <none>
[17:02:29.323] plan(): nbrOfWorkers() = 1
[17:02:29.324] getGlobalsAndPackages() ... DONE
[17:02:29.324] run() for ‘Future’ ...
[17:02:29.324] - state: ‘created’
[17:02:29.325] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:29.325] plan(): Setting new future strategy stack:
[17:02:29.325] List of future strategies:
[17:02:29.325] 1. multicore:
[17:02:29.325]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:29.325]    - tweaked: FALSE
[17:02:29.325]    - call: plan(strategy)
[17:02:29.330] plan(): nbrOfWorkers() = 2
[17:02:29.330] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:29.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:29.330]   - Field: ‘label’
[17:02:29.330]   - Field: ‘local’
[17:02:29.331]   - Field: ‘owner’
[17:02:29.331]   - Field: ‘envir’
[17:02:29.331]   - Field: ‘workers’
[17:02:29.331]   - Field: ‘packages’
[17:02:29.331]   - Field: ‘gc’
[17:02:29.332]   - Field: ‘job’
[17:02:29.332]   - Field: ‘conditions’
[17:02:29.332]   - Field: ‘expr’
[17:02:29.332]   - Field: ‘uuid’
[17:02:29.332]   - Field: ‘seed’
[17:02:29.332]   - Field: ‘version’
[17:02:29.332]   - Field: ‘result’
[17:02:29.333]   - Field: ‘asynchronous’
[17:02:29.333]   - Field: ‘calls’
[17:02:29.333]   - Field: ‘globals’
[17:02:29.333]   - Field: ‘stdout’
[17:02:29.333]   - Field: ‘earlySignal’
[17:02:29.333]   - Field: ‘lazy’
[17:02:29.333]   - Field: ‘state’
[17:02:29.334] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:29.334] - Launch lazy future ...
[17:02:29.334] Packages needed by the future expression (n = 0): <none>
[17:02:29.334] Packages needed by future strategies (n = 0): <none>
[17:02:29.335] {
[17:02:29.335]     {
[17:02:29.335]         {
[17:02:29.335]             ...future.startTime <- base::Sys.time()
[17:02:29.335]             {
[17:02:29.335]                 {
[17:02:29.335]                   {
[17:02:29.335]                     {
[17:02:29.335]                       base::local({
[17:02:29.335]                         has_future <- base::requireNamespace("future", 
[17:02:29.335]                           quietly = TRUE)
[17:02:29.335]                         if (has_future) {
[17:02:29.335]                           ns <- base::getNamespace("future")
[17:02:29.335]                           version <- ns[[".package"]][["version"]]
[17:02:29.335]                           if (is.null(version)) 
[17:02:29.335]                             version <- utils::packageVersion("future")
[17:02:29.335]                         }
[17:02:29.335]                         else {
[17:02:29.335]                           version <- NULL
[17:02:29.335]                         }
[17:02:29.335]                         if (!has_future || version < "1.8.0") {
[17:02:29.335]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.335]                             "", base::R.version$version.string), 
[17:02:29.335]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:29.335]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.335]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.335]                               "release", "version")], collapse = " "), 
[17:02:29.335]                             hostname = base::Sys.info()[["nodename"]])
[17:02:29.335]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.335]                             info)
[17:02:29.335]                           info <- base::paste(info, collapse = "; ")
[17:02:29.335]                           if (!has_future) {
[17:02:29.335]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.335]                               info)
[17:02:29.335]                           }
[17:02:29.335]                           else {
[17:02:29.335]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.335]                               info, version)
[17:02:29.335]                           }
[17:02:29.335]                           base::stop(msg)
[17:02:29.335]                         }
[17:02:29.335]                       })
[17:02:29.335]                     }
[17:02:29.335]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:29.335]                     base::options(mc.cores = 1L)
[17:02:29.335]                   }
[17:02:29.335]                   ...future.strategy.old <- future::plan("list")
[17:02:29.335]                   options(future.plan = NULL)
[17:02:29.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.335]                 }
[17:02:29.335]                 ...future.workdir <- getwd()
[17:02:29.335]             }
[17:02:29.335]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.335]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.335]         }
[17:02:29.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.335]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.335]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.335]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.335]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.335]             base::names(...future.oldOptions))
[17:02:29.335]     }
[17:02:29.335]     if (FALSE) {
[17:02:29.335]     }
[17:02:29.335]     else {
[17:02:29.335]         if (TRUE) {
[17:02:29.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.335]                 open = "w")
[17:02:29.335]         }
[17:02:29.335]         else {
[17:02:29.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.335]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.335]         }
[17:02:29.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.335]             base::sink(type = "output", split = FALSE)
[17:02:29.335]             base::close(...future.stdout)
[17:02:29.335]         }, add = TRUE)
[17:02:29.335]     }
[17:02:29.335]     ...future.frame <- base::sys.nframe()
[17:02:29.335]     ...future.conditions <- base::list()
[17:02:29.335]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.335]     if (FALSE) {
[17:02:29.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.335]     }
[17:02:29.335]     ...future.result <- base::tryCatch({
[17:02:29.335]         base::withCallingHandlers({
[17:02:29.335]             ...future.value <- base::withVisible(base::local({
[17:02:29.335]                 withCallingHandlers({
[17:02:29.335]                   NULL
[17:02:29.335]                 }, immediateCondition = function(cond) {
[17:02:29.335]                   save_rds <- function (object, pathname, ...) 
[17:02:29.335]                   {
[17:02:29.335]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:29.335]                     if (file_test("-f", pathname_tmp)) {
[17:02:29.335]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.335]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:29.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.335]                         fi_tmp[["mtime"]])
[17:02:29.335]                     }
[17:02:29.335]                     tryCatch({
[17:02:29.335]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:29.335]                     }, error = function(ex) {
[17:02:29.335]                       msg <- conditionMessage(ex)
[17:02:29.335]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.335]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:29.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.335]                         fi_tmp[["mtime"]], msg)
[17:02:29.335]                       ex$message <- msg
[17:02:29.335]                       stop(ex)
[17:02:29.335]                     })
[17:02:29.335]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:29.335]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:29.335]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:29.335]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.335]                       fi <- file.info(pathname)
[17:02:29.335]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:29.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.335]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:29.335]                         fi[["size"]], fi[["mtime"]])
[17:02:29.335]                       stop(msg)
[17:02:29.335]                     }
[17:02:29.335]                     invisible(pathname)
[17:02:29.335]                   }
[17:02:29.335]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:29.335]                     rootPath = tempdir()) 
[17:02:29.335]                   {
[17:02:29.335]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:29.335]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:29.335]                       tmpdir = path, fileext = ".rds")
[17:02:29.335]                     save_rds(obj, file)
[17:02:29.335]                   }
[17:02:29.335]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:29.335]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.335]                   {
[17:02:29.335]                     inherits <- base::inherits
[17:02:29.335]                     invokeRestart <- base::invokeRestart
[17:02:29.335]                     is.null <- base::is.null
[17:02:29.335]                     muffled <- FALSE
[17:02:29.335]                     if (inherits(cond, "message")) {
[17:02:29.335]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:29.335]                       if (muffled) 
[17:02:29.335]                         invokeRestart("muffleMessage")
[17:02:29.335]                     }
[17:02:29.335]                     else if (inherits(cond, "warning")) {
[17:02:29.335]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:29.335]                       if (muffled) 
[17:02:29.335]                         invokeRestart("muffleWarning")
[17:02:29.335]                     }
[17:02:29.335]                     else if (inherits(cond, "condition")) {
[17:02:29.335]                       if (!is.null(pattern)) {
[17:02:29.335]                         computeRestarts <- base::computeRestarts
[17:02:29.335]                         grepl <- base::grepl
[17:02:29.335]                         restarts <- computeRestarts(cond)
[17:02:29.335]                         for (restart in restarts) {
[17:02:29.335]                           name <- restart$name
[17:02:29.335]                           if (is.null(name)) 
[17:02:29.335]                             next
[17:02:29.335]                           if (!grepl(pattern, name)) 
[17:02:29.335]                             next
[17:02:29.335]                           invokeRestart(restart)
[17:02:29.335]                           muffled <- TRUE
[17:02:29.335]                           break
[17:02:29.335]                         }
[17:02:29.335]                       }
[17:02:29.335]                     }
[17:02:29.335]                     invisible(muffled)
[17:02:29.335]                   }
[17:02:29.335]                   muffleCondition(cond)
[17:02:29.335]                 })
[17:02:29.335]             }))
[17:02:29.335]             future::FutureResult(value = ...future.value$value, 
[17:02:29.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.335]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.335]                     ...future.globalenv.names))
[17:02:29.335]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.335]         }, condition = base::local({
[17:02:29.335]             c <- base::c
[17:02:29.335]             inherits <- base::inherits
[17:02:29.335]             invokeRestart <- base::invokeRestart
[17:02:29.335]             length <- base::length
[17:02:29.335]             list <- base::list
[17:02:29.335]             seq.int <- base::seq.int
[17:02:29.335]             signalCondition <- base::signalCondition
[17:02:29.335]             sys.calls <- base::sys.calls
[17:02:29.335]             `[[` <- base::`[[`
[17:02:29.335]             `+` <- base::`+`
[17:02:29.335]             `<<-` <- base::`<<-`
[17:02:29.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.335]                   3L)]
[17:02:29.335]             }
[17:02:29.335]             function(cond) {
[17:02:29.335]                 is_error <- inherits(cond, "error")
[17:02:29.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.335]                   NULL)
[17:02:29.335]                 if (is_error) {
[17:02:29.335]                   sessionInformation <- function() {
[17:02:29.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.335]                       search = base::search(), system = base::Sys.info())
[17:02:29.335]                   }
[17:02:29.335]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.335]                     cond$call), session = sessionInformation(), 
[17:02:29.335]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.335]                   signalCondition(cond)
[17:02:29.335]                 }
[17:02:29.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.335]                 "immediateCondition"))) {
[17:02:29.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.335]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.335]                   if (TRUE && !signal) {
[17:02:29.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.335]                     {
[17:02:29.335]                       inherits <- base::inherits
[17:02:29.335]                       invokeRestart <- base::invokeRestart
[17:02:29.335]                       is.null <- base::is.null
[17:02:29.335]                       muffled <- FALSE
[17:02:29.335]                       if (inherits(cond, "message")) {
[17:02:29.335]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.335]                         if (muffled) 
[17:02:29.335]                           invokeRestart("muffleMessage")
[17:02:29.335]                       }
[17:02:29.335]                       else if (inherits(cond, "warning")) {
[17:02:29.335]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.335]                         if (muffled) 
[17:02:29.335]                           invokeRestart("muffleWarning")
[17:02:29.335]                       }
[17:02:29.335]                       else if (inherits(cond, "condition")) {
[17:02:29.335]                         if (!is.null(pattern)) {
[17:02:29.335]                           computeRestarts <- base::computeRestarts
[17:02:29.335]                           grepl <- base::grepl
[17:02:29.335]                           restarts <- computeRestarts(cond)
[17:02:29.335]                           for (restart in restarts) {
[17:02:29.335]                             name <- restart$name
[17:02:29.335]                             if (is.null(name)) 
[17:02:29.335]                               next
[17:02:29.335]                             if (!grepl(pattern, name)) 
[17:02:29.335]                               next
[17:02:29.335]                             invokeRestart(restart)
[17:02:29.335]                             muffled <- TRUE
[17:02:29.335]                             break
[17:02:29.335]                           }
[17:02:29.335]                         }
[17:02:29.335]                       }
[17:02:29.335]                       invisible(muffled)
[17:02:29.335]                     }
[17:02:29.335]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.335]                   }
[17:02:29.335]                 }
[17:02:29.335]                 else {
[17:02:29.335]                   if (TRUE) {
[17:02:29.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.335]                     {
[17:02:29.335]                       inherits <- base::inherits
[17:02:29.335]                       invokeRestart <- base::invokeRestart
[17:02:29.335]                       is.null <- base::is.null
[17:02:29.335]                       muffled <- FALSE
[17:02:29.335]                       if (inherits(cond, "message")) {
[17:02:29.335]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.335]                         if (muffled) 
[17:02:29.335]                           invokeRestart("muffleMessage")
[17:02:29.335]                       }
[17:02:29.335]                       else if (inherits(cond, "warning")) {
[17:02:29.335]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.335]                         if (muffled) 
[17:02:29.335]                           invokeRestart("muffleWarning")
[17:02:29.335]                       }
[17:02:29.335]                       else if (inherits(cond, "condition")) {
[17:02:29.335]                         if (!is.null(pattern)) {
[17:02:29.335]                           computeRestarts <- base::computeRestarts
[17:02:29.335]                           grepl <- base::grepl
[17:02:29.335]                           restarts <- computeRestarts(cond)
[17:02:29.335]                           for (restart in restarts) {
[17:02:29.335]                             name <- restart$name
[17:02:29.335]                             if (is.null(name)) 
[17:02:29.335]                               next
[17:02:29.335]                             if (!grepl(pattern, name)) 
[17:02:29.335]                               next
[17:02:29.335]                             invokeRestart(restart)
[17:02:29.335]                             muffled <- TRUE
[17:02:29.335]                             break
[17:02:29.335]                           }
[17:02:29.335]                         }
[17:02:29.335]                       }
[17:02:29.335]                       invisible(muffled)
[17:02:29.335]                     }
[17:02:29.335]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.335]                   }
[17:02:29.335]                 }
[17:02:29.335]             }
[17:02:29.335]         }))
[17:02:29.335]     }, error = function(ex) {
[17:02:29.335]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.335]                 ...future.rng), started = ...future.startTime, 
[17:02:29.335]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.335]             version = "1.8"), class = "FutureResult")
[17:02:29.335]     }, finally = {
[17:02:29.335]         if (!identical(...future.workdir, getwd())) 
[17:02:29.335]             setwd(...future.workdir)
[17:02:29.335]         {
[17:02:29.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.335]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.335]             }
[17:02:29.335]             base::options(...future.oldOptions)
[17:02:29.335]             if (.Platform$OS.type == "windows") {
[17:02:29.335]                 old_names <- names(...future.oldEnvVars)
[17:02:29.335]                 envs <- base::Sys.getenv()
[17:02:29.335]                 names <- names(envs)
[17:02:29.335]                 common <- intersect(names, old_names)
[17:02:29.335]                 added <- setdiff(names, old_names)
[17:02:29.335]                 removed <- setdiff(old_names, names)
[17:02:29.335]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.335]                   envs[common]]
[17:02:29.335]                 NAMES <- toupper(changed)
[17:02:29.335]                 args <- list()
[17:02:29.335]                 for (kk in seq_along(NAMES)) {
[17:02:29.335]                   name <- changed[[kk]]
[17:02:29.335]                   NAME <- NAMES[[kk]]
[17:02:29.335]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.335]                     next
[17:02:29.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.335]                 }
[17:02:29.335]                 NAMES <- toupper(added)
[17:02:29.335]                 for (kk in seq_along(NAMES)) {
[17:02:29.335]                   name <- added[[kk]]
[17:02:29.335]                   NAME <- NAMES[[kk]]
[17:02:29.335]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.335]                     next
[17:02:29.335]                   args[[name]] <- ""
[17:02:29.335]                 }
[17:02:29.335]                 NAMES <- toupper(removed)
[17:02:29.335]                 for (kk in seq_along(NAMES)) {
[17:02:29.335]                   name <- removed[[kk]]
[17:02:29.335]                   NAME <- NAMES[[kk]]
[17:02:29.335]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.335]                     next
[17:02:29.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.335]                 }
[17:02:29.335]                 if (length(args) > 0) 
[17:02:29.335]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.335]             }
[17:02:29.335]             else {
[17:02:29.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.335]             }
[17:02:29.335]             {
[17:02:29.335]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.335]                   0L) {
[17:02:29.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.335]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.335]                   base::options(opts)
[17:02:29.335]                 }
[17:02:29.335]                 {
[17:02:29.335]                   {
[17:02:29.335]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:29.335]                     NULL
[17:02:29.335]                   }
[17:02:29.335]                   options(future.plan = NULL)
[17:02:29.335]                   if (is.na(NA_character_)) 
[17:02:29.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.335]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.335]                     .init = FALSE)
[17:02:29.335]                 }
[17:02:29.335]             }
[17:02:29.335]         }
[17:02:29.335]     })
[17:02:29.335]     if (TRUE) {
[17:02:29.335]         base::sink(type = "output", split = FALSE)
[17:02:29.335]         if (TRUE) {
[17:02:29.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.335]         }
[17:02:29.335]         else {
[17:02:29.335]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.335]         }
[17:02:29.335]         base::close(...future.stdout)
[17:02:29.335]         ...future.stdout <- NULL
[17:02:29.335]     }
[17:02:29.335]     ...future.result$conditions <- ...future.conditions
[17:02:29.335]     ...future.result$finished <- base::Sys.time()
[17:02:29.335]     ...future.result
[17:02:29.335] }
[17:02:29.339] requestCore(): workers = 2
[17:02:29.341] MulticoreFuture started
[17:02:29.341] - Launch lazy future ... done
[17:02:29.341] run() for ‘MulticoreFuture’ ... done
List of 6
[17:02:29.342] plan(): Setting new future strategy stack:
 $ a: num 1
[17:02:29.342] List of future strategies:
[17:02:29.342] 1. sequential:
[17:02:29.342]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.342]    - tweaked: FALSE
[17:02:29.342]    - call: NULL
 $ b:[17:02:29.343] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c749069050> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74968cd98> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
[17:02:29.345] plan(): Setting new future strategy stack:
 $ a:[17:02:29.345] List of future strategies:
[17:02:29.345] 1. multicore:
[17:02:29.345]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:29.345]    - tweaked: FALSE
[17:02:29.345]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c749069050> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74968cd98> 
 $  : NULL
 $  :[17:02:29.354] plan(): nbrOfWorkers() = 2
 NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:29.360] resolve() on list ...
[17:02:29.361]  recursive: 0
[17:02:29.361]  length: 6
[17:02:29.361]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:29.361] signalConditionsASAP(numeric, pos=1) ...
[17:02:29.361] - nx: 6
[17:02:29.361] - relay: TRUE
[17:02:29.361] - stdout: TRUE
[17:02:29.362] - signal: TRUE
[17:02:29.362] - resignal: FALSE
[17:02:29.362] - force: TRUE
[17:02:29.362] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.362] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.362]  - until=2
[17:02:29.363]  - relaying element #2
[17:02:29.363] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.363] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.363] signalConditionsASAP(NULL, pos=1) ... done
[17:02:29.363]  length: 5 (resolved future 1)
[17:02:29.363] Future #2
[17:02:29.364] result() for MulticoreFuture ...
[17:02:29.364] result() for MulticoreFuture ...
[17:02:29.365] result() for MulticoreFuture ... done
[17:02:29.365] result() for MulticoreFuture ... done
[17:02:29.365] result() for MulticoreFuture ...
[17:02:29.365] result() for MulticoreFuture ... done
[17:02:29.365] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:29.365] - nx: 6
[17:02:29.365] - relay: TRUE
[17:02:29.366] - stdout: TRUE
[17:02:29.366] - signal: TRUE
[17:02:29.366] - resignal: FALSE
[17:02:29.366] - force: TRUE
[17:02:29.366] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.366] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.366]  - until=2
[17:02:29.366]  - relaying element #2
[17:02:29.367] result() for MulticoreFuture ...
[17:02:29.367] result() for MulticoreFuture ... done
[17:02:29.367] result() for MulticoreFuture ...
[17:02:29.367] result() for MulticoreFuture ... done
[17:02:29.367] result() for MulticoreFuture ...
[17:02:29.367] result() for MulticoreFuture ... done
[17:02:29.367] result() for MulticoreFuture ...
[17:02:29.368] result() for MulticoreFuture ... done
[17:02:29.368] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.368] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.368] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:29.368]  length: 4 (resolved future 2)
[17:02:29.368] Future #3
[17:02:29.369] result() for MulticoreFuture ...
[17:02:29.369] result() for MulticoreFuture ...
[17:02:29.369] result() for MulticoreFuture ... done
[17:02:29.369] result() for MulticoreFuture ... done
[17:02:29.370] result() for MulticoreFuture ...
[17:02:29.370] result() for MulticoreFuture ... done
[17:02:29.370] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:29.370] - nx: 6
[17:02:29.370] - relay: TRUE
[17:02:29.370] - stdout: TRUE
[17:02:29.370] - signal: TRUE
[17:02:29.370] - resignal: FALSE
[17:02:29.371] - force: TRUE
[17:02:29.371] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.371] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.371]  - until=3
[17:02:29.371]  - relaying element #3
[17:02:29.371] result() for MulticoreFuture ...
[17:02:29.371] result() for MulticoreFuture ... done
[17:02:29.371] result() for MulticoreFuture ...
[17:02:29.371] result() for MulticoreFuture ... done
[17:02:29.372] result() for MulticoreFuture ...
[17:02:29.372] result() for MulticoreFuture ... done
[17:02:29.372] result() for MulticoreFuture ...
[17:02:29.372] result() for MulticoreFuture ... done
[17:02:29.372] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.372] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.372] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:29.372]  length: 3 (resolved future 3)
[17:02:29.372] signalConditionsASAP(NULL, pos=4) ...
[17:02:29.373] - nx: 6
[17:02:29.373] - relay: TRUE
[17:02:29.373] - stdout: TRUE
[17:02:29.373] - signal: TRUE
[17:02:29.373] - resignal: FALSE
[17:02:29.373] - force: TRUE
[17:02:29.373] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.373] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.373]  - until=5
[17:02:29.373]  - relaying element #5
[17:02:29.373] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.374] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.374] signalConditionsASAP(NULL, pos=4) ... done
[17:02:29.374]  length: 2 (resolved future 4)
[17:02:29.374] signalConditionsASAP(NULL, pos=5) ...
[17:02:29.374] - nx: 6
[17:02:29.374] - relay: TRUE
[17:02:29.374] - stdout: TRUE
[17:02:29.374] - signal: TRUE
[17:02:29.374] - resignal: FALSE
[17:02:29.374] - force: TRUE
[17:02:29.374] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.375] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.375]  - until=6
[17:02:29.375]  - relaying element #6
[17:02:29.375] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.375] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.375] signalConditionsASAP(NULL, pos=5) ... done
[17:02:29.375]  length: 1 (resolved future 5)
[17:02:29.375] signalConditionsASAP(numeric, pos=6) ...
[17:02:29.375] - nx: 6
[17:02:29.376] - relay: TRUE
[17:02:29.376] - stdout: TRUE
[17:02:29.376] - signal: TRUE
[17:02:29.376] - resignal: FALSE
[17:02:29.376] - force: TRUE
[17:02:29.376] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.376] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.376]  - until=6
[17:02:29.376] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.376] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.376] signalConditionsASAP(numeric, pos=6) ... done
[17:02:29.377]  length: 0 (resolved future 6)
[17:02:29.377] Relaying remaining futures
[17:02:29.377] signalConditionsASAP(NULL, pos=0) ...
[17:02:29.377] - nx: 6
[17:02:29.377] - relay: TRUE
[17:02:29.377] - stdout: TRUE
[17:02:29.377] - signal: TRUE
[17:02:29.377] - resignal: FALSE
[17:02:29.377] - force: TRUE
[17:02:29.377] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.377] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:29.378] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.378] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.378] signalConditionsASAP(NULL, pos=0) ... done
[17:02:29.378] resolve() on list ... DONE
[17:02:29.378] result() for MulticoreFuture ...
[17:02:29.378] result() for MulticoreFuture ... done
[17:02:29.378] result() for MulticoreFuture ...
[17:02:29.378] result() for MulticoreFuture ... done
[17:02:29.378] result() for MulticoreFuture ...
[17:02:29.379] result() for MulticoreFuture ... done
[17:02:29.379] result() for MulticoreFuture ...
[17:02:29.379] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:02:29.382] getGlobalsAndPackages() ...
[17:02:29.382] Searching for globals...
[17:02:29.383] 
[17:02:29.383] Searching for globals ... DONE
[17:02:29.383] - globals: [0] <none>
[17:02:29.383] getGlobalsAndPackages() ... DONE
[17:02:29.383] run() for ‘Future’ ...
[17:02:29.383] - state: ‘created’
[17:02:29.384] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:29.390] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:29.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:29.390]   - Field: ‘label’
[17:02:29.390]   - Field: ‘local’
[17:02:29.390]   - Field: ‘owner’
[17:02:29.390]   - Field: ‘envir’
[17:02:29.391]   - Field: ‘workers’
[17:02:29.391]   - Field: ‘packages’
[17:02:29.391]   - Field: ‘gc’
[17:02:29.391]   - Field: ‘job’
[17:02:29.391]   - Field: ‘conditions’
[17:02:29.391]   - Field: ‘expr’
[17:02:29.391]   - Field: ‘uuid’
[17:02:29.391]   - Field: ‘seed’
[17:02:29.392]   - Field: ‘version’
[17:02:29.392]   - Field: ‘result’
[17:02:29.392]   - Field: ‘asynchronous’
[17:02:29.392]   - Field: ‘calls’
[17:02:29.392]   - Field: ‘globals’
[17:02:29.392]   - Field: ‘stdout’
[17:02:29.392]   - Field: ‘earlySignal’
[17:02:29.392]   - Field: ‘lazy’
[17:02:29.392]   - Field: ‘state’
[17:02:29.392] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:29.393] - Launch lazy future ...
[17:02:29.393] Packages needed by the future expression (n = 0): <none>
[17:02:29.393] Packages needed by future strategies (n = 0): <none>
[17:02:29.393] {
[17:02:29.393]     {
[17:02:29.393]         {
[17:02:29.393]             ...future.startTime <- base::Sys.time()
[17:02:29.393]             {
[17:02:29.393]                 {
[17:02:29.393]                   {
[17:02:29.393]                     {
[17:02:29.393]                       base::local({
[17:02:29.393]                         has_future <- base::requireNamespace("future", 
[17:02:29.393]                           quietly = TRUE)
[17:02:29.393]                         if (has_future) {
[17:02:29.393]                           ns <- base::getNamespace("future")
[17:02:29.393]                           version <- ns[[".package"]][["version"]]
[17:02:29.393]                           if (is.null(version)) 
[17:02:29.393]                             version <- utils::packageVersion("future")
[17:02:29.393]                         }
[17:02:29.393]                         else {
[17:02:29.393]                           version <- NULL
[17:02:29.393]                         }
[17:02:29.393]                         if (!has_future || version < "1.8.0") {
[17:02:29.393]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.393]                             "", base::R.version$version.string), 
[17:02:29.393]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:29.393]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.393]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.393]                               "release", "version")], collapse = " "), 
[17:02:29.393]                             hostname = base::Sys.info()[["nodename"]])
[17:02:29.393]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.393]                             info)
[17:02:29.393]                           info <- base::paste(info, collapse = "; ")
[17:02:29.393]                           if (!has_future) {
[17:02:29.393]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.393]                               info)
[17:02:29.393]                           }
[17:02:29.393]                           else {
[17:02:29.393]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.393]                               info, version)
[17:02:29.393]                           }
[17:02:29.393]                           base::stop(msg)
[17:02:29.393]                         }
[17:02:29.393]                       })
[17:02:29.393]                     }
[17:02:29.393]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:29.393]                     base::options(mc.cores = 1L)
[17:02:29.393]                   }
[17:02:29.393]                   ...future.strategy.old <- future::plan("list")
[17:02:29.393]                   options(future.plan = NULL)
[17:02:29.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.393]                 }
[17:02:29.393]                 ...future.workdir <- getwd()
[17:02:29.393]             }
[17:02:29.393]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.393]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.393]         }
[17:02:29.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.393]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.393]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.393]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.393]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.393]             base::names(...future.oldOptions))
[17:02:29.393]     }
[17:02:29.393]     if (FALSE) {
[17:02:29.393]     }
[17:02:29.393]     else {
[17:02:29.393]         if (TRUE) {
[17:02:29.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.393]                 open = "w")
[17:02:29.393]         }
[17:02:29.393]         else {
[17:02:29.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.393]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.393]         }
[17:02:29.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.393]             base::sink(type = "output", split = FALSE)
[17:02:29.393]             base::close(...future.stdout)
[17:02:29.393]         }, add = TRUE)
[17:02:29.393]     }
[17:02:29.393]     ...future.frame <- base::sys.nframe()
[17:02:29.393]     ...future.conditions <- base::list()
[17:02:29.393]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.393]     if (FALSE) {
[17:02:29.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.393]     }
[17:02:29.393]     ...future.result <- base::tryCatch({
[17:02:29.393]         base::withCallingHandlers({
[17:02:29.393]             ...future.value <- base::withVisible(base::local({
[17:02:29.393]                 withCallingHandlers({
[17:02:29.393]                   2
[17:02:29.393]                 }, immediateCondition = function(cond) {
[17:02:29.393]                   save_rds <- function (object, pathname, ...) 
[17:02:29.393]                   {
[17:02:29.393]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:29.393]                     if (file_test("-f", pathname_tmp)) {
[17:02:29.393]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.393]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:29.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.393]                         fi_tmp[["mtime"]])
[17:02:29.393]                     }
[17:02:29.393]                     tryCatch({
[17:02:29.393]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:29.393]                     }, error = function(ex) {
[17:02:29.393]                       msg <- conditionMessage(ex)
[17:02:29.393]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.393]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:29.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.393]                         fi_tmp[["mtime"]], msg)
[17:02:29.393]                       ex$message <- msg
[17:02:29.393]                       stop(ex)
[17:02:29.393]                     })
[17:02:29.393]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:29.393]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:29.393]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:29.393]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.393]                       fi <- file.info(pathname)
[17:02:29.393]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:29.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.393]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:29.393]                         fi[["size"]], fi[["mtime"]])
[17:02:29.393]                       stop(msg)
[17:02:29.393]                     }
[17:02:29.393]                     invisible(pathname)
[17:02:29.393]                   }
[17:02:29.393]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:29.393]                     rootPath = tempdir()) 
[17:02:29.393]                   {
[17:02:29.393]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:29.393]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:29.393]                       tmpdir = path, fileext = ".rds")
[17:02:29.393]                     save_rds(obj, file)
[17:02:29.393]                   }
[17:02:29.393]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:29.393]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.393]                   {
[17:02:29.393]                     inherits <- base::inherits
[17:02:29.393]                     invokeRestart <- base::invokeRestart
[17:02:29.393]                     is.null <- base::is.null
[17:02:29.393]                     muffled <- FALSE
[17:02:29.393]                     if (inherits(cond, "message")) {
[17:02:29.393]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:29.393]                       if (muffled) 
[17:02:29.393]                         invokeRestart("muffleMessage")
[17:02:29.393]                     }
[17:02:29.393]                     else if (inherits(cond, "warning")) {
[17:02:29.393]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:29.393]                       if (muffled) 
[17:02:29.393]                         invokeRestart("muffleWarning")
[17:02:29.393]                     }
[17:02:29.393]                     else if (inherits(cond, "condition")) {
[17:02:29.393]                       if (!is.null(pattern)) {
[17:02:29.393]                         computeRestarts <- base::computeRestarts
[17:02:29.393]                         grepl <- base::grepl
[17:02:29.393]                         restarts <- computeRestarts(cond)
[17:02:29.393]                         for (restart in restarts) {
[17:02:29.393]                           name <- restart$name
[17:02:29.393]                           if (is.null(name)) 
[17:02:29.393]                             next
[17:02:29.393]                           if (!grepl(pattern, name)) 
[17:02:29.393]                             next
[17:02:29.393]                           invokeRestart(restart)
[17:02:29.393]                           muffled <- TRUE
[17:02:29.393]                           break
[17:02:29.393]                         }
[17:02:29.393]                       }
[17:02:29.393]                     }
[17:02:29.393]                     invisible(muffled)
[17:02:29.393]                   }
[17:02:29.393]                   muffleCondition(cond)
[17:02:29.393]                 })
[17:02:29.393]             }))
[17:02:29.393]             future::FutureResult(value = ...future.value$value, 
[17:02:29.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.393]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.393]                     ...future.globalenv.names))
[17:02:29.393]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.393]         }, condition = base::local({
[17:02:29.393]             c <- base::c
[17:02:29.393]             inherits <- base::inherits
[17:02:29.393]             invokeRestart <- base::invokeRestart
[17:02:29.393]             length <- base::length
[17:02:29.393]             list <- base::list
[17:02:29.393]             seq.int <- base::seq.int
[17:02:29.393]             signalCondition <- base::signalCondition
[17:02:29.393]             sys.calls <- base::sys.calls
[17:02:29.393]             `[[` <- base::`[[`
[17:02:29.393]             `+` <- base::`+`
[17:02:29.393]             `<<-` <- base::`<<-`
[17:02:29.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.393]                   3L)]
[17:02:29.393]             }
[17:02:29.393]             function(cond) {
[17:02:29.393]                 is_error <- inherits(cond, "error")
[17:02:29.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.393]                   NULL)
[17:02:29.393]                 if (is_error) {
[17:02:29.393]                   sessionInformation <- function() {
[17:02:29.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.393]                       search = base::search(), system = base::Sys.info())
[17:02:29.393]                   }
[17:02:29.393]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.393]                     cond$call), session = sessionInformation(), 
[17:02:29.393]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.393]                   signalCondition(cond)
[17:02:29.393]                 }
[17:02:29.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.393]                 "immediateCondition"))) {
[17:02:29.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.393]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.393]                   if (TRUE && !signal) {
[17:02:29.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.393]                     {
[17:02:29.393]                       inherits <- base::inherits
[17:02:29.393]                       invokeRestart <- base::invokeRestart
[17:02:29.393]                       is.null <- base::is.null
[17:02:29.393]                       muffled <- FALSE
[17:02:29.393]                       if (inherits(cond, "message")) {
[17:02:29.393]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.393]                         if (muffled) 
[17:02:29.393]                           invokeRestart("muffleMessage")
[17:02:29.393]                       }
[17:02:29.393]                       else if (inherits(cond, "warning")) {
[17:02:29.393]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.393]                         if (muffled) 
[17:02:29.393]                           invokeRestart("muffleWarning")
[17:02:29.393]                       }
[17:02:29.393]                       else if (inherits(cond, "condition")) {
[17:02:29.393]                         if (!is.null(pattern)) {
[17:02:29.393]                           computeRestarts <- base::computeRestarts
[17:02:29.393]                           grepl <- base::grepl
[17:02:29.393]                           restarts <- computeRestarts(cond)
[17:02:29.393]                           for (restart in restarts) {
[17:02:29.393]                             name <- restart$name
[17:02:29.393]                             if (is.null(name)) 
[17:02:29.393]                               next
[17:02:29.393]                             if (!grepl(pattern, name)) 
[17:02:29.393]                               next
[17:02:29.393]                             invokeRestart(restart)
[17:02:29.393]                             muffled <- TRUE
[17:02:29.393]                             break
[17:02:29.393]                           }
[17:02:29.393]                         }
[17:02:29.393]                       }
[17:02:29.393]                       invisible(muffled)
[17:02:29.393]                     }
[17:02:29.393]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.393]                   }
[17:02:29.393]                 }
[17:02:29.393]                 else {
[17:02:29.393]                   if (TRUE) {
[17:02:29.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.393]                     {
[17:02:29.393]                       inherits <- base::inherits
[17:02:29.393]                       invokeRestart <- base::invokeRestart
[17:02:29.393]                       is.null <- base::is.null
[17:02:29.393]                       muffled <- FALSE
[17:02:29.393]                       if (inherits(cond, "message")) {
[17:02:29.393]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.393]                         if (muffled) 
[17:02:29.393]                           invokeRestart("muffleMessage")
[17:02:29.393]                       }
[17:02:29.393]                       else if (inherits(cond, "warning")) {
[17:02:29.393]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.393]                         if (muffled) 
[17:02:29.393]                           invokeRestart("muffleWarning")
[17:02:29.393]                       }
[17:02:29.393]                       else if (inherits(cond, "condition")) {
[17:02:29.393]                         if (!is.null(pattern)) {
[17:02:29.393]                           computeRestarts <- base::computeRestarts
[17:02:29.393]                           grepl <- base::grepl
[17:02:29.393]                           restarts <- computeRestarts(cond)
[17:02:29.393]                           for (restart in restarts) {
[17:02:29.393]                             name <- restart$name
[17:02:29.393]                             if (is.null(name)) 
[17:02:29.393]                               next
[17:02:29.393]                             if (!grepl(pattern, name)) 
[17:02:29.393]                               next
[17:02:29.393]                             invokeRestart(restart)
[17:02:29.393]                             muffled <- TRUE
[17:02:29.393]                             break
[17:02:29.393]                           }
[17:02:29.393]                         }
[17:02:29.393]                       }
[17:02:29.393]                       invisible(muffled)
[17:02:29.393]                     }
[17:02:29.393]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.393]                   }
[17:02:29.393]                 }
[17:02:29.393]             }
[17:02:29.393]         }))
[17:02:29.393]     }, error = function(ex) {
[17:02:29.393]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.393]                 ...future.rng), started = ...future.startTime, 
[17:02:29.393]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.393]             version = "1.8"), class = "FutureResult")
[17:02:29.393]     }, finally = {
[17:02:29.393]         if (!identical(...future.workdir, getwd())) 
[17:02:29.393]             setwd(...future.workdir)
[17:02:29.393]         {
[17:02:29.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.393]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.393]             }
[17:02:29.393]             base::options(...future.oldOptions)
[17:02:29.393]             if (.Platform$OS.type == "windows") {
[17:02:29.393]                 old_names <- names(...future.oldEnvVars)
[17:02:29.393]                 envs <- base::Sys.getenv()
[17:02:29.393]                 names <- names(envs)
[17:02:29.393]                 common <- intersect(names, old_names)
[17:02:29.393]                 added <- setdiff(names, old_names)
[17:02:29.393]                 removed <- setdiff(old_names, names)
[17:02:29.393]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.393]                   envs[common]]
[17:02:29.393]                 NAMES <- toupper(changed)
[17:02:29.393]                 args <- list()
[17:02:29.393]                 for (kk in seq_along(NAMES)) {
[17:02:29.393]                   name <- changed[[kk]]
[17:02:29.393]                   NAME <- NAMES[[kk]]
[17:02:29.393]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.393]                     next
[17:02:29.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.393]                 }
[17:02:29.393]                 NAMES <- toupper(added)
[17:02:29.393]                 for (kk in seq_along(NAMES)) {
[17:02:29.393]                   name <- added[[kk]]
[17:02:29.393]                   NAME <- NAMES[[kk]]
[17:02:29.393]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.393]                     next
[17:02:29.393]                   args[[name]] <- ""
[17:02:29.393]                 }
[17:02:29.393]                 NAMES <- toupper(removed)
[17:02:29.393]                 for (kk in seq_along(NAMES)) {
[17:02:29.393]                   name <- removed[[kk]]
[17:02:29.393]                   NAME <- NAMES[[kk]]
[17:02:29.393]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.393]                     next
[17:02:29.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.393]                 }
[17:02:29.393]                 if (length(args) > 0) 
[17:02:29.393]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.393]             }
[17:02:29.393]             else {
[17:02:29.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.393]             }
[17:02:29.393]             {
[17:02:29.393]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.393]                   0L) {
[17:02:29.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.393]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.393]                   base::options(opts)
[17:02:29.393]                 }
[17:02:29.393]                 {
[17:02:29.393]                   {
[17:02:29.393]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:29.393]                     NULL
[17:02:29.393]                   }
[17:02:29.393]                   options(future.plan = NULL)
[17:02:29.393]                   if (is.na(NA_character_)) 
[17:02:29.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.393]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.393]                     .init = FALSE)
[17:02:29.393]                 }
[17:02:29.393]             }
[17:02:29.393]         }
[17:02:29.393]     })
[17:02:29.393]     if (TRUE) {
[17:02:29.393]         base::sink(type = "output", split = FALSE)
[17:02:29.393]         if (TRUE) {
[17:02:29.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.393]         }
[17:02:29.393]         else {
[17:02:29.393]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.393]         }
[17:02:29.393]         base::close(...future.stdout)
[17:02:29.393]         ...future.stdout <- NULL
[17:02:29.393]     }
[17:02:29.393]     ...future.result$conditions <- ...future.conditions
[17:02:29.393]     ...future.result$finished <- base::Sys.time()
[17:02:29.393]     ...future.result
[17:02:29.393] }
[17:02:29.396] requestCore(): workers = 2
[17:02:29.398] MulticoreFuture started
[17:02:29.398] - Launch lazy future ... done
[17:02:29.399] run() for ‘MulticoreFuture’ ... done
[17:02:29.399] getGlobalsAndPackages() ...
[17:02:29.399] plan(): Setting new future strategy stack:
[17:02:29.399] Searching for globals...
[17:02:29.399] List of future strategies:
[17:02:29.399] 1. sequential:
[17:02:29.399]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.399]    - tweaked: FALSE
[17:02:29.399]    - call: NULL
[17:02:29.400] 
[17:02:29.400] plan(): nbrOfWorkers() = 1
[17:02:29.401] Searching for globals ... DONE
[17:02:29.401] - globals: [0] <none>
[17:02:29.401] getGlobalsAndPackages() ... DONE
[17:02:29.402] run() for ‘Future’ ...
[17:02:29.402] - state: ‘created’
[17:02:29.402] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:29.402] plan(): Setting new future strategy stack:
[17:02:29.403] List of future strategies:
[17:02:29.403] 1. multicore:
[17:02:29.403]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:29.403]    - tweaked: FALSE
[17:02:29.403]    - call: plan(strategy)
[17:02:29.408] plan(): nbrOfWorkers() = 2
[17:02:29.408] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:29.408] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:29.409]   - Field: ‘label’
[17:02:29.409]   - Field: ‘local’
[17:02:29.409]   - Field: ‘owner’
[17:02:29.409]   - Field: ‘envir’
[17:02:29.409]   - Field: ‘workers’
[17:02:29.409]   - Field: ‘packages’
[17:02:29.410]   - Field: ‘gc’
[17:02:29.410]   - Field: ‘job’
[17:02:29.410]   - Field: ‘conditions’
[17:02:29.410]   - Field: ‘expr’
[17:02:29.410]   - Field: ‘uuid’
[17:02:29.410]   - Field: ‘seed’
[17:02:29.410]   - Field: ‘version’
[17:02:29.411]   - Field: ‘result’
[17:02:29.411]   - Field: ‘asynchronous’
[17:02:29.411]   - Field: ‘calls’
[17:02:29.411]   - Field: ‘globals’
[17:02:29.411]   - Field: ‘stdout’
[17:02:29.411]   - Field: ‘earlySignal’
[17:02:29.412]   - Field: ‘lazy’
[17:02:29.412]   - Field: ‘state’
[17:02:29.412] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:29.412] - Launch lazy future ...
[17:02:29.412] Packages needed by the future expression (n = 0): <none>
[17:02:29.413] Packages needed by future strategies (n = 0): <none>
[17:02:29.413] {
[17:02:29.413]     {
[17:02:29.413]         {
[17:02:29.413]             ...future.startTime <- base::Sys.time()
[17:02:29.413]             {
[17:02:29.413]                 {
[17:02:29.413]                   {
[17:02:29.413]                     {
[17:02:29.413]                       base::local({
[17:02:29.413]                         has_future <- base::requireNamespace("future", 
[17:02:29.413]                           quietly = TRUE)
[17:02:29.413]                         if (has_future) {
[17:02:29.413]                           ns <- base::getNamespace("future")
[17:02:29.413]                           version <- ns[[".package"]][["version"]]
[17:02:29.413]                           if (is.null(version)) 
[17:02:29.413]                             version <- utils::packageVersion("future")
[17:02:29.413]                         }
[17:02:29.413]                         else {
[17:02:29.413]                           version <- NULL
[17:02:29.413]                         }
[17:02:29.413]                         if (!has_future || version < "1.8.0") {
[17:02:29.413]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.413]                             "", base::R.version$version.string), 
[17:02:29.413]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:29.413]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.413]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.413]                               "release", "version")], collapse = " "), 
[17:02:29.413]                             hostname = base::Sys.info()[["nodename"]])
[17:02:29.413]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.413]                             info)
[17:02:29.413]                           info <- base::paste(info, collapse = "; ")
[17:02:29.413]                           if (!has_future) {
[17:02:29.413]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.413]                               info)
[17:02:29.413]                           }
[17:02:29.413]                           else {
[17:02:29.413]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.413]                               info, version)
[17:02:29.413]                           }
[17:02:29.413]                           base::stop(msg)
[17:02:29.413]                         }
[17:02:29.413]                       })
[17:02:29.413]                     }
[17:02:29.413]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:29.413]                     base::options(mc.cores = 1L)
[17:02:29.413]                   }
[17:02:29.413]                   ...future.strategy.old <- future::plan("list")
[17:02:29.413]                   options(future.plan = NULL)
[17:02:29.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.413]                 }
[17:02:29.413]                 ...future.workdir <- getwd()
[17:02:29.413]             }
[17:02:29.413]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.413]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.413]         }
[17:02:29.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.413]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.413]             base::names(...future.oldOptions))
[17:02:29.413]     }
[17:02:29.413]     if (FALSE) {
[17:02:29.413]     }
[17:02:29.413]     else {
[17:02:29.413]         if (TRUE) {
[17:02:29.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.413]                 open = "w")
[17:02:29.413]         }
[17:02:29.413]         else {
[17:02:29.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.413]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.413]         }
[17:02:29.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.413]             base::sink(type = "output", split = FALSE)
[17:02:29.413]             base::close(...future.stdout)
[17:02:29.413]         }, add = TRUE)
[17:02:29.413]     }
[17:02:29.413]     ...future.frame <- base::sys.nframe()
[17:02:29.413]     ...future.conditions <- base::list()
[17:02:29.413]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.413]     if (FALSE) {
[17:02:29.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.413]     }
[17:02:29.413]     ...future.result <- base::tryCatch({
[17:02:29.413]         base::withCallingHandlers({
[17:02:29.413]             ...future.value <- base::withVisible(base::local({
[17:02:29.413]                 withCallingHandlers({
[17:02:29.413]                   NULL
[17:02:29.413]                 }, immediateCondition = function(cond) {
[17:02:29.413]                   save_rds <- function (object, pathname, ...) 
[17:02:29.413]                   {
[17:02:29.413]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:29.413]                     if (file_test("-f", pathname_tmp)) {
[17:02:29.413]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.413]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:29.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.413]                         fi_tmp[["mtime"]])
[17:02:29.413]                     }
[17:02:29.413]                     tryCatch({
[17:02:29.413]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:29.413]                     }, error = function(ex) {
[17:02:29.413]                       msg <- conditionMessage(ex)
[17:02:29.413]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.413]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:29.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.413]                         fi_tmp[["mtime"]], msg)
[17:02:29.413]                       ex$message <- msg
[17:02:29.413]                       stop(ex)
[17:02:29.413]                     })
[17:02:29.413]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:29.413]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:29.413]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:29.413]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.413]                       fi <- file.info(pathname)
[17:02:29.413]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:29.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.413]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:29.413]                         fi[["size"]], fi[["mtime"]])
[17:02:29.413]                       stop(msg)
[17:02:29.413]                     }
[17:02:29.413]                     invisible(pathname)
[17:02:29.413]                   }
[17:02:29.413]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:29.413]                     rootPath = tempdir()) 
[17:02:29.413]                   {
[17:02:29.413]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:29.413]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:29.413]                       tmpdir = path, fileext = ".rds")
[17:02:29.413]                     save_rds(obj, file)
[17:02:29.413]                   }
[17:02:29.413]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:29.413]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.413]                   {
[17:02:29.413]                     inherits <- base::inherits
[17:02:29.413]                     invokeRestart <- base::invokeRestart
[17:02:29.413]                     is.null <- base::is.null
[17:02:29.413]                     muffled <- FALSE
[17:02:29.413]                     if (inherits(cond, "message")) {
[17:02:29.413]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:29.413]                       if (muffled) 
[17:02:29.413]                         invokeRestart("muffleMessage")
[17:02:29.413]                     }
[17:02:29.413]                     else if (inherits(cond, "warning")) {
[17:02:29.413]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:29.413]                       if (muffled) 
[17:02:29.413]                         invokeRestart("muffleWarning")
[17:02:29.413]                     }
[17:02:29.413]                     else if (inherits(cond, "condition")) {
[17:02:29.413]                       if (!is.null(pattern)) {
[17:02:29.413]                         computeRestarts <- base::computeRestarts
[17:02:29.413]                         grepl <- base::grepl
[17:02:29.413]                         restarts <- computeRestarts(cond)
[17:02:29.413]                         for (restart in restarts) {
[17:02:29.413]                           name <- restart$name
[17:02:29.413]                           if (is.null(name)) 
[17:02:29.413]                             next
[17:02:29.413]                           if (!grepl(pattern, name)) 
[17:02:29.413]                             next
[17:02:29.413]                           invokeRestart(restart)
[17:02:29.413]                           muffled <- TRUE
[17:02:29.413]                           break
[17:02:29.413]                         }
[17:02:29.413]                       }
[17:02:29.413]                     }
[17:02:29.413]                     invisible(muffled)
[17:02:29.413]                   }
[17:02:29.413]                   muffleCondition(cond)
[17:02:29.413]                 })
[17:02:29.413]             }))
[17:02:29.413]             future::FutureResult(value = ...future.value$value, 
[17:02:29.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.413]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.413]                     ...future.globalenv.names))
[17:02:29.413]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.413]         }, condition = base::local({
[17:02:29.413]             c <- base::c
[17:02:29.413]             inherits <- base::inherits
[17:02:29.413]             invokeRestart <- base::invokeRestart
[17:02:29.413]             length <- base::length
[17:02:29.413]             list <- base::list
[17:02:29.413]             seq.int <- base::seq.int
[17:02:29.413]             signalCondition <- base::signalCondition
[17:02:29.413]             sys.calls <- base::sys.calls
[17:02:29.413]             `[[` <- base::`[[`
[17:02:29.413]             `+` <- base::`+`
[17:02:29.413]             `<<-` <- base::`<<-`
[17:02:29.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.413]                   3L)]
[17:02:29.413]             }
[17:02:29.413]             function(cond) {
[17:02:29.413]                 is_error <- inherits(cond, "error")
[17:02:29.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.413]                   NULL)
[17:02:29.413]                 if (is_error) {
[17:02:29.413]                   sessionInformation <- function() {
[17:02:29.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.413]                       search = base::search(), system = base::Sys.info())
[17:02:29.413]                   }
[17:02:29.413]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.413]                     cond$call), session = sessionInformation(), 
[17:02:29.413]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.413]                   signalCondition(cond)
[17:02:29.413]                 }
[17:02:29.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.413]                 "immediateCondition"))) {
[17:02:29.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.413]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.413]                   if (TRUE && !signal) {
[17:02:29.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.413]                     {
[17:02:29.413]                       inherits <- base::inherits
[17:02:29.413]                       invokeRestart <- base::invokeRestart
[17:02:29.413]                       is.null <- base::is.null
[17:02:29.413]                       muffled <- FALSE
[17:02:29.413]                       if (inherits(cond, "message")) {
[17:02:29.413]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.413]                         if (muffled) 
[17:02:29.413]                           invokeRestart("muffleMessage")
[17:02:29.413]                       }
[17:02:29.413]                       else if (inherits(cond, "warning")) {
[17:02:29.413]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.413]                         if (muffled) 
[17:02:29.413]                           invokeRestart("muffleWarning")
[17:02:29.413]                       }
[17:02:29.413]                       else if (inherits(cond, "condition")) {
[17:02:29.413]                         if (!is.null(pattern)) {
[17:02:29.413]                           computeRestarts <- base::computeRestarts
[17:02:29.413]                           grepl <- base::grepl
[17:02:29.413]                           restarts <- computeRestarts(cond)
[17:02:29.413]                           for (restart in restarts) {
[17:02:29.413]                             name <- restart$name
[17:02:29.413]                             if (is.null(name)) 
[17:02:29.413]                               next
[17:02:29.413]                             if (!grepl(pattern, name)) 
[17:02:29.413]                               next
[17:02:29.413]                             invokeRestart(restart)
[17:02:29.413]                             muffled <- TRUE
[17:02:29.413]                             break
[17:02:29.413]                           }
[17:02:29.413]                         }
[17:02:29.413]                       }
[17:02:29.413]                       invisible(muffled)
[17:02:29.413]                     }
[17:02:29.413]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.413]                   }
[17:02:29.413]                 }
[17:02:29.413]                 else {
[17:02:29.413]                   if (TRUE) {
[17:02:29.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.413]                     {
[17:02:29.413]                       inherits <- base::inherits
[17:02:29.413]                       invokeRestart <- base::invokeRestart
[17:02:29.413]                       is.null <- base::is.null
[17:02:29.413]                       muffled <- FALSE
[17:02:29.413]                       if (inherits(cond, "message")) {
[17:02:29.413]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.413]                         if (muffled) 
[17:02:29.413]                           invokeRestart("muffleMessage")
[17:02:29.413]                       }
[17:02:29.413]                       else if (inherits(cond, "warning")) {
[17:02:29.413]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.413]                         if (muffled) 
[17:02:29.413]                           invokeRestart("muffleWarning")
[17:02:29.413]                       }
[17:02:29.413]                       else if (inherits(cond, "condition")) {
[17:02:29.413]                         if (!is.null(pattern)) {
[17:02:29.413]                           computeRestarts <- base::computeRestarts
[17:02:29.413]                           grepl <- base::grepl
[17:02:29.413]                           restarts <- computeRestarts(cond)
[17:02:29.413]                           for (restart in restarts) {
[17:02:29.413]                             name <- restart$name
[17:02:29.413]                             if (is.null(name)) 
[17:02:29.413]                               next
[17:02:29.413]                             if (!grepl(pattern, name)) 
[17:02:29.413]                               next
[17:02:29.413]                             invokeRestart(restart)
[17:02:29.413]                             muffled <- TRUE
[17:02:29.413]                             break
[17:02:29.413]                           }
[17:02:29.413]                         }
[17:02:29.413]                       }
[17:02:29.413]                       invisible(muffled)
[17:02:29.413]                     }
[17:02:29.413]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.413]                   }
[17:02:29.413]                 }
[17:02:29.413]             }
[17:02:29.413]         }))
[17:02:29.413]     }, error = function(ex) {
[17:02:29.413]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.413]                 ...future.rng), started = ...future.startTime, 
[17:02:29.413]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.413]             version = "1.8"), class = "FutureResult")
[17:02:29.413]     }, finally = {
[17:02:29.413]         if (!identical(...future.workdir, getwd())) 
[17:02:29.413]             setwd(...future.workdir)
[17:02:29.413]         {
[17:02:29.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.413]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.413]             }
[17:02:29.413]             base::options(...future.oldOptions)
[17:02:29.413]             if (.Platform$OS.type == "windows") {
[17:02:29.413]                 old_names <- names(...future.oldEnvVars)
[17:02:29.413]                 envs <- base::Sys.getenv()
[17:02:29.413]                 names <- names(envs)
[17:02:29.413]                 common <- intersect(names, old_names)
[17:02:29.413]                 added <- setdiff(names, old_names)
[17:02:29.413]                 removed <- setdiff(old_names, names)
[17:02:29.413]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.413]                   envs[common]]
[17:02:29.413]                 NAMES <- toupper(changed)
[17:02:29.413]                 args <- list()
[17:02:29.413]                 for (kk in seq_along(NAMES)) {
[17:02:29.413]                   name <- changed[[kk]]
[17:02:29.413]                   NAME <- NAMES[[kk]]
[17:02:29.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.413]                     next
[17:02:29.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.413]                 }
[17:02:29.413]                 NAMES <- toupper(added)
[17:02:29.413]                 for (kk in seq_along(NAMES)) {
[17:02:29.413]                   name <- added[[kk]]
[17:02:29.413]                   NAME <- NAMES[[kk]]
[17:02:29.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.413]                     next
[17:02:29.413]                   args[[name]] <- ""
[17:02:29.413]                 }
[17:02:29.413]                 NAMES <- toupper(removed)
[17:02:29.413]                 for (kk in seq_along(NAMES)) {
[17:02:29.413]                   name <- removed[[kk]]
[17:02:29.413]                   NAME <- NAMES[[kk]]
[17:02:29.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.413]                     next
[17:02:29.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.413]                 }
[17:02:29.413]                 if (length(args) > 0) 
[17:02:29.413]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.413]             }
[17:02:29.413]             else {
[17:02:29.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.413]             }
[17:02:29.413]             {
[17:02:29.413]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.413]                   0L) {
[17:02:29.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.413]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.413]                   base::options(opts)
[17:02:29.413]                 }
[17:02:29.413]                 {
[17:02:29.413]                   {
[17:02:29.413]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:29.413]                     NULL
[17:02:29.413]                   }
[17:02:29.413]                   options(future.plan = NULL)
[17:02:29.413]                   if (is.na(NA_character_)) 
[17:02:29.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.413]                     .init = FALSE)
[17:02:29.413]                 }
[17:02:29.413]             }
[17:02:29.413]         }
[17:02:29.413]     })
[17:02:29.413]     if (TRUE) {
[17:02:29.413]         base::sink(type = "output", split = FALSE)
[17:02:29.413]         if (TRUE) {
[17:02:29.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.413]         }
[17:02:29.413]         else {
[17:02:29.413]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.413]         }
[17:02:29.413]         base::close(...future.stdout)
[17:02:29.413]         ...future.stdout <- NULL
[17:02:29.413]     }
[17:02:29.413]     ...future.result$conditions <- ...future.conditions
[17:02:29.413]     ...future.result$finished <- base::Sys.time()
[17:02:29.413]     ...future.result
[17:02:29.413] }
[17:02:29.417] requestCore(): workers = 2
[17:02:29.419] MulticoreFuture started
[17:02:29.420] - Launch lazy future ... done
[17:02:29.420] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[17:02:29.421] plan(): Setting new future strategy stack:
 num 1
 $ b:[17:02:29.421] List of future strategies:
[17:02:29.421] 1. sequential:
[17:02:29.421]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.421]    - tweaked: FALSE
[17:02:29.421]    - call: NULL
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' [17:02:29.422] plan(): nbrOfWorkers() = 1
<environment: 0x55c749d1d528> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c747493b18> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a:[17:02:29.424] plan(): Setting new future strategy stack:
 num 1
 $ b:[17:02:29.424] List of future strategies:
[17:02:29.424] 1. multicore:
[17:02:29.424]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:29.424]    - tweaked: FALSE
[17:02:29.424]    - call: plan(strategy)
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c749d1d528> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c747493b18> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:02:29.429] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:29.433] resolve() on list ...
[17:02:29.433]  recursive: 0
[17:02:29.433]  length: 6
[17:02:29.433]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:29.433] signalConditionsASAP(numeric, pos=1) ...
[17:02:29.433] - nx: 6
[17:02:29.434] - relay: TRUE
[17:02:29.434] - stdout: TRUE
[17:02:29.434] - signal: TRUE
[17:02:29.434] - resignal: FALSE
[17:02:29.434] - force: TRUE
[17:02:29.434] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.434] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.435]  - until=2
[17:02:29.435]  - relaying element #2
[17:02:29.435] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.435] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.435] signalConditionsASAP(NULL, pos=1) ... done
[17:02:29.435]  length: 5 (resolved future 1)
[17:02:29.436] Future #2
[17:02:29.436] result() for MulticoreFuture ...
[17:02:29.437] result() for MulticoreFuture ...
[17:02:29.437] result() for MulticoreFuture ... done
[17:02:29.437] result() for MulticoreFuture ... done
[17:02:29.437] result() for MulticoreFuture ...
[17:02:29.438] result() for MulticoreFuture ... done
[17:02:29.438] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:29.438] - nx: 6
[17:02:29.438] - relay: TRUE
[17:02:29.438] - stdout: TRUE
[17:02:29.439] - signal: TRUE
[17:02:29.439] - resignal: FALSE
[17:02:29.439] - force: TRUE
[17:02:29.439] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.439] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.439]  - until=2
[17:02:29.440]  - relaying element #2
[17:02:29.440] result() for MulticoreFuture ...
[17:02:29.440] result() for MulticoreFuture ... done
[17:02:29.440] result() for MulticoreFuture ...
[17:02:29.440] result() for MulticoreFuture ... done
[17:02:29.441] result() for MulticoreFuture ...
[17:02:29.441] result() for MulticoreFuture ... done
[17:02:29.441] result() for MulticoreFuture ...
[17:02:29.441] result() for MulticoreFuture ... done
[17:02:29.441] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.441] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.441] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:29.442]  length: 4 (resolved future 2)
[17:02:29.442] Future #3
[17:02:29.442] result() for MulticoreFuture ...
[17:02:29.443] result() for MulticoreFuture ...
[17:02:29.443] result() for MulticoreFuture ... done
[17:02:29.443] result() for MulticoreFuture ... done
[17:02:29.443] result() for MulticoreFuture ...
[17:02:29.443] result() for MulticoreFuture ... done
[17:02:29.443] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:29.444] - nx: 6
[17:02:29.444] - relay: TRUE
[17:02:29.444] - stdout: TRUE
[17:02:29.444] - signal: TRUE
[17:02:29.444] - resignal: FALSE
[17:02:29.444] - force: TRUE
[17:02:29.444] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.447] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.447]  - until=3
[17:02:29.447]  - relaying element #3
[17:02:29.448] result() for MulticoreFuture ...
[17:02:29.448] result() for MulticoreFuture ... done
[17:02:29.448] result() for MulticoreFuture ...
[17:02:29.448] result() for MulticoreFuture ... done
[17:02:29.448] result() for MulticoreFuture ...
[17:02:29.448] result() for MulticoreFuture ... done
[17:02:29.449] result() for MulticoreFuture ...
[17:02:29.449] result() for MulticoreFuture ... done
[17:02:29.449] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.449] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.449] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:29.449]  length: 3 (resolved future 3)
[17:02:29.449] signalConditionsASAP(NULL, pos=4) ...
[17:02:29.450] - nx: 6
[17:02:29.450] - relay: TRUE
[17:02:29.450] - stdout: TRUE
[17:02:29.450] - signal: TRUE
[17:02:29.450] - resignal: FALSE
[17:02:29.450] - force: TRUE
[17:02:29.450] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.450] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.450]  - until=5
[17:02:29.450]  - relaying element #5
[17:02:29.451] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.451] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.451] signalConditionsASAP(NULL, pos=4) ... done
[17:02:29.451]  length: 2 (resolved future 4)
[17:02:29.451] signalConditionsASAP(NULL, pos=5) ...
[17:02:29.451] - nx: 6
[17:02:29.451] - relay: TRUE
[17:02:29.451] - stdout: TRUE
[17:02:29.452] - signal: TRUE
[17:02:29.452] - resignal: FALSE
[17:02:29.452] - force: TRUE
[17:02:29.452] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.452] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.452]  - until=6
[17:02:29.452]  - relaying element #6
[17:02:29.452] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.452] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.452] signalConditionsASAP(NULL, pos=5) ... done
[17:02:29.453]  length: 1 (resolved future 5)
[17:02:29.453] signalConditionsASAP(numeric, pos=6) ...
[17:02:29.453] - nx: 6
[17:02:29.453] - relay: TRUE
[17:02:29.453] - stdout: TRUE
[17:02:29.453] - signal: TRUE
[17:02:29.453] - resignal: FALSE
[17:02:29.453] - force: TRUE
[17:02:29.453] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.453] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.454]  - until=6
[17:02:29.454] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.454] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.454] signalConditionsASAP(numeric, pos=6) ... done
[17:02:29.454]  length: 0 (resolved future 6)
[17:02:29.454] Relaying remaining futures
[17:02:29.454] signalConditionsASAP(NULL, pos=0) ...
[17:02:29.454] - nx: 6
[17:02:29.454] - relay: TRUE
[17:02:29.455] - stdout: TRUE
[17:02:29.455] - signal: TRUE
[17:02:29.455] - resignal: FALSE
[17:02:29.455] - force: TRUE
[17:02:29.455] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.455] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:29.455] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.455] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.455] signalConditionsASAP(NULL, pos=0) ... done
[17:02:29.456] resolve() on list ... DONE
[17:02:29.456] result() for MulticoreFuture ...
[17:02:29.456] result() for MulticoreFuture ... done
[17:02:29.456] result() for MulticoreFuture ...
[17:02:29.456] result() for MulticoreFuture ... done
[17:02:29.456] result() for MulticoreFuture ...
[17:02:29.456] result() for MulticoreFuture ... done
[17:02:29.456] result() for MulticoreFuture ...
[17:02:29.456] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:02:29.460] getGlobalsAndPackages() ...
[17:02:29.460] Searching for globals...
[17:02:29.461] 
[17:02:29.461] Searching for globals ... DONE
[17:02:29.461] - globals: [0] <none>
[17:02:29.461] getGlobalsAndPackages() ... DONE
[17:02:29.461] run() for ‘Future’ ...
[17:02:29.461] - state: ‘created’
[17:02:29.462] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:29.465] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:29.465] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:29.466]   - Field: ‘label’
[17:02:29.466]   - Field: ‘local’
[17:02:29.466]   - Field: ‘owner’
[17:02:29.466]   - Field: ‘envir’
[17:02:29.466]   - Field: ‘workers’
[17:02:29.466]   - Field: ‘packages’
[17:02:29.466]   - Field: ‘gc’
[17:02:29.466]   - Field: ‘job’
[17:02:29.466]   - Field: ‘conditions’
[17:02:29.466]   - Field: ‘expr’
[17:02:29.467]   - Field: ‘uuid’
[17:02:29.467]   - Field: ‘seed’
[17:02:29.467]   - Field: ‘version’
[17:02:29.467]   - Field: ‘result’
[17:02:29.467]   - Field: ‘asynchronous’
[17:02:29.467]   - Field: ‘calls’
[17:02:29.467]   - Field: ‘globals’
[17:02:29.467]   - Field: ‘stdout’
[17:02:29.467]   - Field: ‘earlySignal’
[17:02:29.467]   - Field: ‘lazy’
[17:02:29.468]   - Field: ‘state’
[17:02:29.468] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:29.468] - Launch lazy future ...
[17:02:29.468] Packages needed by the future expression (n = 0): <none>
[17:02:29.468] Packages needed by future strategies (n = 0): <none>
[17:02:29.469] {
[17:02:29.469]     {
[17:02:29.469]         {
[17:02:29.469]             ...future.startTime <- base::Sys.time()
[17:02:29.469]             {
[17:02:29.469]                 {
[17:02:29.469]                   {
[17:02:29.469]                     {
[17:02:29.469]                       base::local({
[17:02:29.469]                         has_future <- base::requireNamespace("future", 
[17:02:29.469]                           quietly = TRUE)
[17:02:29.469]                         if (has_future) {
[17:02:29.469]                           ns <- base::getNamespace("future")
[17:02:29.469]                           version <- ns[[".package"]][["version"]]
[17:02:29.469]                           if (is.null(version)) 
[17:02:29.469]                             version <- utils::packageVersion("future")
[17:02:29.469]                         }
[17:02:29.469]                         else {
[17:02:29.469]                           version <- NULL
[17:02:29.469]                         }
[17:02:29.469]                         if (!has_future || version < "1.8.0") {
[17:02:29.469]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.469]                             "", base::R.version$version.string), 
[17:02:29.469]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:29.469]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.469]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.469]                               "release", "version")], collapse = " "), 
[17:02:29.469]                             hostname = base::Sys.info()[["nodename"]])
[17:02:29.469]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.469]                             info)
[17:02:29.469]                           info <- base::paste(info, collapse = "; ")
[17:02:29.469]                           if (!has_future) {
[17:02:29.469]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.469]                               info)
[17:02:29.469]                           }
[17:02:29.469]                           else {
[17:02:29.469]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.469]                               info, version)
[17:02:29.469]                           }
[17:02:29.469]                           base::stop(msg)
[17:02:29.469]                         }
[17:02:29.469]                       })
[17:02:29.469]                     }
[17:02:29.469]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:29.469]                     base::options(mc.cores = 1L)
[17:02:29.469]                   }
[17:02:29.469]                   ...future.strategy.old <- future::plan("list")
[17:02:29.469]                   options(future.plan = NULL)
[17:02:29.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.469]                 }
[17:02:29.469]                 ...future.workdir <- getwd()
[17:02:29.469]             }
[17:02:29.469]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.469]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.469]         }
[17:02:29.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.469]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.469]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.469]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.469]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.469]             base::names(...future.oldOptions))
[17:02:29.469]     }
[17:02:29.469]     if (FALSE) {
[17:02:29.469]     }
[17:02:29.469]     else {
[17:02:29.469]         if (TRUE) {
[17:02:29.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.469]                 open = "w")
[17:02:29.469]         }
[17:02:29.469]         else {
[17:02:29.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.469]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.469]         }
[17:02:29.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.469]             base::sink(type = "output", split = FALSE)
[17:02:29.469]             base::close(...future.stdout)
[17:02:29.469]         }, add = TRUE)
[17:02:29.469]     }
[17:02:29.469]     ...future.frame <- base::sys.nframe()
[17:02:29.469]     ...future.conditions <- base::list()
[17:02:29.469]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.469]     if (FALSE) {
[17:02:29.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.469]     }
[17:02:29.469]     ...future.result <- base::tryCatch({
[17:02:29.469]         base::withCallingHandlers({
[17:02:29.469]             ...future.value <- base::withVisible(base::local({
[17:02:29.469]                 withCallingHandlers({
[17:02:29.469]                   2
[17:02:29.469]                 }, immediateCondition = function(cond) {
[17:02:29.469]                   save_rds <- function (object, pathname, ...) 
[17:02:29.469]                   {
[17:02:29.469]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:29.469]                     if (file_test("-f", pathname_tmp)) {
[17:02:29.469]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.469]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:29.469]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.469]                         fi_tmp[["mtime"]])
[17:02:29.469]                     }
[17:02:29.469]                     tryCatch({
[17:02:29.469]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:29.469]                     }, error = function(ex) {
[17:02:29.469]                       msg <- conditionMessage(ex)
[17:02:29.469]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.469]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:29.469]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.469]                         fi_tmp[["mtime"]], msg)
[17:02:29.469]                       ex$message <- msg
[17:02:29.469]                       stop(ex)
[17:02:29.469]                     })
[17:02:29.469]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:29.469]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:29.469]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:29.469]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.469]                       fi <- file.info(pathname)
[17:02:29.469]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:29.469]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.469]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:29.469]                         fi[["size"]], fi[["mtime"]])
[17:02:29.469]                       stop(msg)
[17:02:29.469]                     }
[17:02:29.469]                     invisible(pathname)
[17:02:29.469]                   }
[17:02:29.469]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:29.469]                     rootPath = tempdir()) 
[17:02:29.469]                   {
[17:02:29.469]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:29.469]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:29.469]                       tmpdir = path, fileext = ".rds")
[17:02:29.469]                     save_rds(obj, file)
[17:02:29.469]                   }
[17:02:29.469]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:29.469]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.469]                   {
[17:02:29.469]                     inherits <- base::inherits
[17:02:29.469]                     invokeRestart <- base::invokeRestart
[17:02:29.469]                     is.null <- base::is.null
[17:02:29.469]                     muffled <- FALSE
[17:02:29.469]                     if (inherits(cond, "message")) {
[17:02:29.469]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:29.469]                       if (muffled) 
[17:02:29.469]                         invokeRestart("muffleMessage")
[17:02:29.469]                     }
[17:02:29.469]                     else if (inherits(cond, "warning")) {
[17:02:29.469]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:29.469]                       if (muffled) 
[17:02:29.469]                         invokeRestart("muffleWarning")
[17:02:29.469]                     }
[17:02:29.469]                     else if (inherits(cond, "condition")) {
[17:02:29.469]                       if (!is.null(pattern)) {
[17:02:29.469]                         computeRestarts <- base::computeRestarts
[17:02:29.469]                         grepl <- base::grepl
[17:02:29.469]                         restarts <- computeRestarts(cond)
[17:02:29.469]                         for (restart in restarts) {
[17:02:29.469]                           name <- restart$name
[17:02:29.469]                           if (is.null(name)) 
[17:02:29.469]                             next
[17:02:29.469]                           if (!grepl(pattern, name)) 
[17:02:29.469]                             next
[17:02:29.469]                           invokeRestart(restart)
[17:02:29.469]                           muffled <- TRUE
[17:02:29.469]                           break
[17:02:29.469]                         }
[17:02:29.469]                       }
[17:02:29.469]                     }
[17:02:29.469]                     invisible(muffled)
[17:02:29.469]                   }
[17:02:29.469]                   muffleCondition(cond)
[17:02:29.469]                 })
[17:02:29.469]             }))
[17:02:29.469]             future::FutureResult(value = ...future.value$value, 
[17:02:29.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.469]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.469]                     ...future.globalenv.names))
[17:02:29.469]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.469]         }, condition = base::local({
[17:02:29.469]             c <- base::c
[17:02:29.469]             inherits <- base::inherits
[17:02:29.469]             invokeRestart <- base::invokeRestart
[17:02:29.469]             length <- base::length
[17:02:29.469]             list <- base::list
[17:02:29.469]             seq.int <- base::seq.int
[17:02:29.469]             signalCondition <- base::signalCondition
[17:02:29.469]             sys.calls <- base::sys.calls
[17:02:29.469]             `[[` <- base::`[[`
[17:02:29.469]             `+` <- base::`+`
[17:02:29.469]             `<<-` <- base::`<<-`
[17:02:29.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.469]                   3L)]
[17:02:29.469]             }
[17:02:29.469]             function(cond) {
[17:02:29.469]                 is_error <- inherits(cond, "error")
[17:02:29.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.469]                   NULL)
[17:02:29.469]                 if (is_error) {
[17:02:29.469]                   sessionInformation <- function() {
[17:02:29.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.469]                       search = base::search(), system = base::Sys.info())
[17:02:29.469]                   }
[17:02:29.469]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.469]                     cond$call), session = sessionInformation(), 
[17:02:29.469]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.469]                   signalCondition(cond)
[17:02:29.469]                 }
[17:02:29.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.469]                 "immediateCondition"))) {
[17:02:29.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.469]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.469]                   if (TRUE && !signal) {
[17:02:29.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.469]                     {
[17:02:29.469]                       inherits <- base::inherits
[17:02:29.469]                       invokeRestart <- base::invokeRestart
[17:02:29.469]                       is.null <- base::is.null
[17:02:29.469]                       muffled <- FALSE
[17:02:29.469]                       if (inherits(cond, "message")) {
[17:02:29.469]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.469]                         if (muffled) 
[17:02:29.469]                           invokeRestart("muffleMessage")
[17:02:29.469]                       }
[17:02:29.469]                       else if (inherits(cond, "warning")) {
[17:02:29.469]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.469]                         if (muffled) 
[17:02:29.469]                           invokeRestart("muffleWarning")
[17:02:29.469]                       }
[17:02:29.469]                       else if (inherits(cond, "condition")) {
[17:02:29.469]                         if (!is.null(pattern)) {
[17:02:29.469]                           computeRestarts <- base::computeRestarts
[17:02:29.469]                           grepl <- base::grepl
[17:02:29.469]                           restarts <- computeRestarts(cond)
[17:02:29.469]                           for (restart in restarts) {
[17:02:29.469]                             name <- restart$name
[17:02:29.469]                             if (is.null(name)) 
[17:02:29.469]                               next
[17:02:29.469]                             if (!grepl(pattern, name)) 
[17:02:29.469]                               next
[17:02:29.469]                             invokeRestart(restart)
[17:02:29.469]                             muffled <- TRUE
[17:02:29.469]                             break
[17:02:29.469]                           }
[17:02:29.469]                         }
[17:02:29.469]                       }
[17:02:29.469]                       invisible(muffled)
[17:02:29.469]                     }
[17:02:29.469]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.469]                   }
[17:02:29.469]                 }
[17:02:29.469]                 else {
[17:02:29.469]                   if (TRUE) {
[17:02:29.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.469]                     {
[17:02:29.469]                       inherits <- base::inherits
[17:02:29.469]                       invokeRestart <- base::invokeRestart
[17:02:29.469]                       is.null <- base::is.null
[17:02:29.469]                       muffled <- FALSE
[17:02:29.469]                       if (inherits(cond, "message")) {
[17:02:29.469]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.469]                         if (muffled) 
[17:02:29.469]                           invokeRestart("muffleMessage")
[17:02:29.469]                       }
[17:02:29.469]                       else if (inherits(cond, "warning")) {
[17:02:29.469]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.469]                         if (muffled) 
[17:02:29.469]                           invokeRestart("muffleWarning")
[17:02:29.469]                       }
[17:02:29.469]                       else if (inherits(cond, "condition")) {
[17:02:29.469]                         if (!is.null(pattern)) {
[17:02:29.469]                           computeRestarts <- base::computeRestarts
[17:02:29.469]                           grepl <- base::grepl
[17:02:29.469]                           restarts <- computeRestarts(cond)
[17:02:29.469]                           for (restart in restarts) {
[17:02:29.469]                             name <- restart$name
[17:02:29.469]                             if (is.null(name)) 
[17:02:29.469]                               next
[17:02:29.469]                             if (!grepl(pattern, name)) 
[17:02:29.469]                               next
[17:02:29.469]                             invokeRestart(restart)
[17:02:29.469]                             muffled <- TRUE
[17:02:29.469]                             break
[17:02:29.469]                           }
[17:02:29.469]                         }
[17:02:29.469]                       }
[17:02:29.469]                       invisible(muffled)
[17:02:29.469]                     }
[17:02:29.469]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.469]                   }
[17:02:29.469]                 }
[17:02:29.469]             }
[17:02:29.469]         }))
[17:02:29.469]     }, error = function(ex) {
[17:02:29.469]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.469]                 ...future.rng), started = ...future.startTime, 
[17:02:29.469]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.469]             version = "1.8"), class = "FutureResult")
[17:02:29.469]     }, finally = {
[17:02:29.469]         if (!identical(...future.workdir, getwd())) 
[17:02:29.469]             setwd(...future.workdir)
[17:02:29.469]         {
[17:02:29.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.469]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.469]             }
[17:02:29.469]             base::options(...future.oldOptions)
[17:02:29.469]             if (.Platform$OS.type == "windows") {
[17:02:29.469]                 old_names <- names(...future.oldEnvVars)
[17:02:29.469]                 envs <- base::Sys.getenv()
[17:02:29.469]                 names <- names(envs)
[17:02:29.469]                 common <- intersect(names, old_names)
[17:02:29.469]                 added <- setdiff(names, old_names)
[17:02:29.469]                 removed <- setdiff(old_names, names)
[17:02:29.469]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.469]                   envs[common]]
[17:02:29.469]                 NAMES <- toupper(changed)
[17:02:29.469]                 args <- list()
[17:02:29.469]                 for (kk in seq_along(NAMES)) {
[17:02:29.469]                   name <- changed[[kk]]
[17:02:29.469]                   NAME <- NAMES[[kk]]
[17:02:29.469]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.469]                     next
[17:02:29.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.469]                 }
[17:02:29.469]                 NAMES <- toupper(added)
[17:02:29.469]                 for (kk in seq_along(NAMES)) {
[17:02:29.469]                   name <- added[[kk]]
[17:02:29.469]                   NAME <- NAMES[[kk]]
[17:02:29.469]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.469]                     next
[17:02:29.469]                   args[[name]] <- ""
[17:02:29.469]                 }
[17:02:29.469]                 NAMES <- toupper(removed)
[17:02:29.469]                 for (kk in seq_along(NAMES)) {
[17:02:29.469]                   name <- removed[[kk]]
[17:02:29.469]                   NAME <- NAMES[[kk]]
[17:02:29.469]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.469]                     next
[17:02:29.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.469]                 }
[17:02:29.469]                 if (length(args) > 0) 
[17:02:29.469]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.469]             }
[17:02:29.469]             else {
[17:02:29.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.469]             }
[17:02:29.469]             {
[17:02:29.469]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.469]                   0L) {
[17:02:29.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.469]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.469]                   base::options(opts)
[17:02:29.469]                 }
[17:02:29.469]                 {
[17:02:29.469]                   {
[17:02:29.469]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:29.469]                     NULL
[17:02:29.469]                   }
[17:02:29.469]                   options(future.plan = NULL)
[17:02:29.469]                   if (is.na(NA_character_)) 
[17:02:29.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.469]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.469]                     .init = FALSE)
[17:02:29.469]                 }
[17:02:29.469]             }
[17:02:29.469]         }
[17:02:29.469]     })
[17:02:29.469]     if (TRUE) {
[17:02:29.469]         base::sink(type = "output", split = FALSE)
[17:02:29.469]         if (TRUE) {
[17:02:29.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.469]         }
[17:02:29.469]         else {
[17:02:29.469]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.469]         }
[17:02:29.469]         base::close(...future.stdout)
[17:02:29.469]         ...future.stdout <- NULL
[17:02:29.469]     }
[17:02:29.469]     ...future.result$conditions <- ...future.conditions
[17:02:29.469]     ...future.result$finished <- base::Sys.time()
[17:02:29.469]     ...future.result
[17:02:29.469] }
[17:02:29.471] requestCore(): workers = 2
[17:02:29.473] MulticoreFuture started
[17:02:29.473] - Launch lazy future ... done
[17:02:29.473] run() for ‘MulticoreFuture’ ... done
[17:02:29.474] getGlobalsAndPackages() ...
[17:02:29.474] plan(): Setting new future strategy stack:
[17:02:29.474] Searching for globals...
[17:02:29.475] 
[17:02:29.474] List of future strategies:
[17:02:29.474] 1. sequential:
[17:02:29.474]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.474]    - tweaked: FALSE
[17:02:29.474]    - call: NULL
[17:02:29.475] Searching for globals ... DONE
[17:02:29.475] plan(): nbrOfWorkers() = 1
[17:02:29.475] - globals: [0] <none>
[17:02:29.475] getGlobalsAndPackages() ... DONE
[17:02:29.476] run() for ‘Future’ ...
[17:02:29.476] - state: ‘created’
[17:02:29.476] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:29.477] plan(): Setting new future strategy stack:
[17:02:29.477] List of future strategies:
[17:02:29.477] 1. multicore:
[17:02:29.477]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:29.477]    - tweaked: FALSE
[17:02:29.477]    - call: plan(strategy)
[17:02:29.481] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:29.482] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:29.482]   - Field: ‘label’
[17:02:29.482] plan(): nbrOfWorkers() = 2
[17:02:29.482]   - Field: ‘local’
[17:02:29.482]   - Field: ‘owner’
[17:02:29.482]   - Field: ‘envir’
[17:02:29.482]   - Field: ‘workers’
[17:02:29.482]   - Field: ‘packages’
[17:02:29.483]   - Field: ‘gc’
[17:02:29.483]   - Field: ‘job’
[17:02:29.483]   - Field: ‘conditions’
[17:02:29.483]   - Field: ‘expr’
[17:02:29.483]   - Field: ‘uuid’
[17:02:29.483]   - Field: ‘seed’
[17:02:29.483]   - Field: ‘version’
[17:02:29.484]   - Field: ‘result’
[17:02:29.484]   - Field: ‘asynchronous’
[17:02:29.484]   - Field: ‘calls’
[17:02:29.484]   - Field: ‘globals’
[17:02:29.484]   - Field: ‘stdout’
[17:02:29.484]   - Field: ‘earlySignal’
[17:02:29.484]   - Field: ‘lazy’
[17:02:29.485]   - Field: ‘state’
[17:02:29.485] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:29.485] - Launch lazy future ...
[17:02:29.485] Packages needed by the future expression (n = 0): <none>
[17:02:29.486] Packages needed by future strategies (n = 0): <none>
[17:02:29.486] {
[17:02:29.486]     {
[17:02:29.486]         {
[17:02:29.486]             ...future.startTime <- base::Sys.time()
[17:02:29.486]             {
[17:02:29.486]                 {
[17:02:29.486]                   {
[17:02:29.486]                     {
[17:02:29.486]                       base::local({
[17:02:29.486]                         has_future <- base::requireNamespace("future", 
[17:02:29.486]                           quietly = TRUE)
[17:02:29.486]                         if (has_future) {
[17:02:29.486]                           ns <- base::getNamespace("future")
[17:02:29.486]                           version <- ns[[".package"]][["version"]]
[17:02:29.486]                           if (is.null(version)) 
[17:02:29.486]                             version <- utils::packageVersion("future")
[17:02:29.486]                         }
[17:02:29.486]                         else {
[17:02:29.486]                           version <- NULL
[17:02:29.486]                         }
[17:02:29.486]                         if (!has_future || version < "1.8.0") {
[17:02:29.486]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:29.486]                             "", base::R.version$version.string), 
[17:02:29.486]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:29.486]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:29.486]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:29.486]                               "release", "version")], collapse = " "), 
[17:02:29.486]                             hostname = base::Sys.info()[["nodename"]])
[17:02:29.486]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:29.486]                             info)
[17:02:29.486]                           info <- base::paste(info, collapse = "; ")
[17:02:29.486]                           if (!has_future) {
[17:02:29.486]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:29.486]                               info)
[17:02:29.486]                           }
[17:02:29.486]                           else {
[17:02:29.486]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:29.486]                               info, version)
[17:02:29.486]                           }
[17:02:29.486]                           base::stop(msg)
[17:02:29.486]                         }
[17:02:29.486]                       })
[17:02:29.486]                     }
[17:02:29.486]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:29.486]                     base::options(mc.cores = 1L)
[17:02:29.486]                   }
[17:02:29.486]                   ...future.strategy.old <- future::plan("list")
[17:02:29.486]                   options(future.plan = NULL)
[17:02:29.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:29.486]                 }
[17:02:29.486]                 ...future.workdir <- getwd()
[17:02:29.486]             }
[17:02:29.486]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:29.486]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:29.486]         }
[17:02:29.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:29.486]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:29.486]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:29.486]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:29.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:29.486]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:29.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:29.486]             base::names(...future.oldOptions))
[17:02:29.486]     }
[17:02:29.486]     if (FALSE) {
[17:02:29.486]     }
[17:02:29.486]     else {
[17:02:29.486]         if (TRUE) {
[17:02:29.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:29.486]                 open = "w")
[17:02:29.486]         }
[17:02:29.486]         else {
[17:02:29.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:29.486]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:29.486]         }
[17:02:29.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:29.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:29.486]             base::sink(type = "output", split = FALSE)
[17:02:29.486]             base::close(...future.stdout)
[17:02:29.486]         }, add = TRUE)
[17:02:29.486]     }
[17:02:29.486]     ...future.frame <- base::sys.nframe()
[17:02:29.486]     ...future.conditions <- base::list()
[17:02:29.486]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:29.486]     if (FALSE) {
[17:02:29.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:29.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:29.486]     }
[17:02:29.486]     ...future.result <- base::tryCatch({
[17:02:29.486]         base::withCallingHandlers({
[17:02:29.486]             ...future.value <- base::withVisible(base::local({
[17:02:29.486]                 withCallingHandlers({
[17:02:29.486]                   NULL
[17:02:29.486]                 }, immediateCondition = function(cond) {
[17:02:29.486]                   save_rds <- function (object, pathname, ...) 
[17:02:29.486]                   {
[17:02:29.486]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:29.486]                     if (file_test("-f", pathname_tmp)) {
[17:02:29.486]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.486]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:29.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.486]                         fi_tmp[["mtime"]])
[17:02:29.486]                     }
[17:02:29.486]                     tryCatch({
[17:02:29.486]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:29.486]                     }, error = function(ex) {
[17:02:29.486]                       msg <- conditionMessage(ex)
[17:02:29.486]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.486]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:29.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.486]                         fi_tmp[["mtime"]], msg)
[17:02:29.486]                       ex$message <- msg
[17:02:29.486]                       stop(ex)
[17:02:29.486]                     })
[17:02:29.486]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:29.486]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:29.486]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:29.486]                       fi_tmp <- file.info(pathname_tmp)
[17:02:29.486]                       fi <- file.info(pathname)
[17:02:29.486]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:29.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:29.486]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:29.486]                         fi[["size"]], fi[["mtime"]])
[17:02:29.486]                       stop(msg)
[17:02:29.486]                     }
[17:02:29.486]                     invisible(pathname)
[17:02:29.486]                   }
[17:02:29.486]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:29.486]                     rootPath = tempdir()) 
[17:02:29.486]                   {
[17:02:29.486]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:29.486]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:29.486]                       tmpdir = path, fileext = ".rds")
[17:02:29.486]                     save_rds(obj, file)
[17:02:29.486]                   }
[17:02:29.486]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:29.486]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.486]                   {
[17:02:29.486]                     inherits <- base::inherits
[17:02:29.486]                     invokeRestart <- base::invokeRestart
[17:02:29.486]                     is.null <- base::is.null
[17:02:29.486]                     muffled <- FALSE
[17:02:29.486]                     if (inherits(cond, "message")) {
[17:02:29.486]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:29.486]                       if (muffled) 
[17:02:29.486]                         invokeRestart("muffleMessage")
[17:02:29.486]                     }
[17:02:29.486]                     else if (inherits(cond, "warning")) {
[17:02:29.486]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:29.486]                       if (muffled) 
[17:02:29.486]                         invokeRestart("muffleWarning")
[17:02:29.486]                     }
[17:02:29.486]                     else if (inherits(cond, "condition")) {
[17:02:29.486]                       if (!is.null(pattern)) {
[17:02:29.486]                         computeRestarts <- base::computeRestarts
[17:02:29.486]                         grepl <- base::grepl
[17:02:29.486]                         restarts <- computeRestarts(cond)
[17:02:29.486]                         for (restart in restarts) {
[17:02:29.486]                           name <- restart$name
[17:02:29.486]                           if (is.null(name)) 
[17:02:29.486]                             next
[17:02:29.486]                           if (!grepl(pattern, name)) 
[17:02:29.486]                             next
[17:02:29.486]                           invokeRestart(restart)
[17:02:29.486]                           muffled <- TRUE
[17:02:29.486]                           break
[17:02:29.486]                         }
[17:02:29.486]                       }
[17:02:29.486]                     }
[17:02:29.486]                     invisible(muffled)
[17:02:29.486]                   }
[17:02:29.486]                   muffleCondition(cond)
[17:02:29.486]                 })
[17:02:29.486]             }))
[17:02:29.486]             future::FutureResult(value = ...future.value$value, 
[17:02:29.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.486]                   ...future.rng), globalenv = if (FALSE) 
[17:02:29.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:29.486]                     ...future.globalenv.names))
[17:02:29.486]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:29.486]         }, condition = base::local({
[17:02:29.486]             c <- base::c
[17:02:29.486]             inherits <- base::inherits
[17:02:29.486]             invokeRestart <- base::invokeRestart
[17:02:29.486]             length <- base::length
[17:02:29.486]             list <- base::list
[17:02:29.486]             seq.int <- base::seq.int
[17:02:29.486]             signalCondition <- base::signalCondition
[17:02:29.486]             sys.calls <- base::sys.calls
[17:02:29.486]             `[[` <- base::`[[`
[17:02:29.486]             `+` <- base::`+`
[17:02:29.486]             `<<-` <- base::`<<-`
[17:02:29.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:29.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:29.486]                   3L)]
[17:02:29.486]             }
[17:02:29.486]             function(cond) {
[17:02:29.486]                 is_error <- inherits(cond, "error")
[17:02:29.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:29.486]                   NULL)
[17:02:29.486]                 if (is_error) {
[17:02:29.486]                   sessionInformation <- function() {
[17:02:29.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:29.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:29.486]                       search = base::search(), system = base::Sys.info())
[17:02:29.486]                   }
[17:02:29.486]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:29.486]                     cond$call), session = sessionInformation(), 
[17:02:29.486]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:29.486]                   signalCondition(cond)
[17:02:29.486]                 }
[17:02:29.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:29.486]                 "immediateCondition"))) {
[17:02:29.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:29.486]                   ...future.conditions[[length(...future.conditions) + 
[17:02:29.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:29.486]                   if (TRUE && !signal) {
[17:02:29.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.486]                     {
[17:02:29.486]                       inherits <- base::inherits
[17:02:29.486]                       invokeRestart <- base::invokeRestart
[17:02:29.486]                       is.null <- base::is.null
[17:02:29.486]                       muffled <- FALSE
[17:02:29.486]                       if (inherits(cond, "message")) {
[17:02:29.486]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.486]                         if (muffled) 
[17:02:29.486]                           invokeRestart("muffleMessage")
[17:02:29.486]                       }
[17:02:29.486]                       else if (inherits(cond, "warning")) {
[17:02:29.486]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.486]                         if (muffled) 
[17:02:29.486]                           invokeRestart("muffleWarning")
[17:02:29.486]                       }
[17:02:29.486]                       else if (inherits(cond, "condition")) {
[17:02:29.486]                         if (!is.null(pattern)) {
[17:02:29.486]                           computeRestarts <- base::computeRestarts
[17:02:29.486]                           grepl <- base::grepl
[17:02:29.486]                           restarts <- computeRestarts(cond)
[17:02:29.486]                           for (restart in restarts) {
[17:02:29.486]                             name <- restart$name
[17:02:29.486]                             if (is.null(name)) 
[17:02:29.486]                               next
[17:02:29.486]                             if (!grepl(pattern, name)) 
[17:02:29.486]                               next
[17:02:29.486]                             invokeRestart(restart)
[17:02:29.486]                             muffled <- TRUE
[17:02:29.486]                             break
[17:02:29.486]                           }
[17:02:29.486]                         }
[17:02:29.486]                       }
[17:02:29.486]                       invisible(muffled)
[17:02:29.486]                     }
[17:02:29.486]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.486]                   }
[17:02:29.486]                 }
[17:02:29.486]                 else {
[17:02:29.486]                   if (TRUE) {
[17:02:29.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:29.486]                     {
[17:02:29.486]                       inherits <- base::inherits
[17:02:29.486]                       invokeRestart <- base::invokeRestart
[17:02:29.486]                       is.null <- base::is.null
[17:02:29.486]                       muffled <- FALSE
[17:02:29.486]                       if (inherits(cond, "message")) {
[17:02:29.486]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:29.486]                         if (muffled) 
[17:02:29.486]                           invokeRestart("muffleMessage")
[17:02:29.486]                       }
[17:02:29.486]                       else if (inherits(cond, "warning")) {
[17:02:29.486]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:29.486]                         if (muffled) 
[17:02:29.486]                           invokeRestart("muffleWarning")
[17:02:29.486]                       }
[17:02:29.486]                       else if (inherits(cond, "condition")) {
[17:02:29.486]                         if (!is.null(pattern)) {
[17:02:29.486]                           computeRestarts <- base::computeRestarts
[17:02:29.486]                           grepl <- base::grepl
[17:02:29.486]                           restarts <- computeRestarts(cond)
[17:02:29.486]                           for (restart in restarts) {
[17:02:29.486]                             name <- restart$name
[17:02:29.486]                             if (is.null(name)) 
[17:02:29.486]                               next
[17:02:29.486]                             if (!grepl(pattern, name)) 
[17:02:29.486]                               next
[17:02:29.486]                             invokeRestart(restart)
[17:02:29.486]                             muffled <- TRUE
[17:02:29.486]                             break
[17:02:29.486]                           }
[17:02:29.486]                         }
[17:02:29.486]                       }
[17:02:29.486]                       invisible(muffled)
[17:02:29.486]                     }
[17:02:29.486]                     muffleCondition(cond, pattern = "^muffle")
[17:02:29.486]                   }
[17:02:29.486]                 }
[17:02:29.486]             }
[17:02:29.486]         }))
[17:02:29.486]     }, error = function(ex) {
[17:02:29.486]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:29.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:29.486]                 ...future.rng), started = ...future.startTime, 
[17:02:29.486]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:29.486]             version = "1.8"), class = "FutureResult")
[17:02:29.486]     }, finally = {
[17:02:29.486]         if (!identical(...future.workdir, getwd())) 
[17:02:29.486]             setwd(...future.workdir)
[17:02:29.486]         {
[17:02:29.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:29.486]                 ...future.oldOptions$nwarnings <- NULL
[17:02:29.486]             }
[17:02:29.486]             base::options(...future.oldOptions)
[17:02:29.486]             if (.Platform$OS.type == "windows") {
[17:02:29.486]                 old_names <- names(...future.oldEnvVars)
[17:02:29.486]                 envs <- base::Sys.getenv()
[17:02:29.486]                 names <- names(envs)
[17:02:29.486]                 common <- intersect(names, old_names)
[17:02:29.486]                 added <- setdiff(names, old_names)
[17:02:29.486]                 removed <- setdiff(old_names, names)
[17:02:29.486]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:29.486]                   envs[common]]
[17:02:29.486]                 NAMES <- toupper(changed)
[17:02:29.486]                 args <- list()
[17:02:29.486]                 for (kk in seq_along(NAMES)) {
[17:02:29.486]                   name <- changed[[kk]]
[17:02:29.486]                   NAME <- NAMES[[kk]]
[17:02:29.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.486]                     next
[17:02:29.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.486]                 }
[17:02:29.486]                 NAMES <- toupper(added)
[17:02:29.486]                 for (kk in seq_along(NAMES)) {
[17:02:29.486]                   name <- added[[kk]]
[17:02:29.486]                   NAME <- NAMES[[kk]]
[17:02:29.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.486]                     next
[17:02:29.486]                   args[[name]] <- ""
[17:02:29.486]                 }
[17:02:29.486]                 NAMES <- toupper(removed)
[17:02:29.486]                 for (kk in seq_along(NAMES)) {
[17:02:29.486]                   name <- removed[[kk]]
[17:02:29.486]                   NAME <- NAMES[[kk]]
[17:02:29.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:29.486]                     next
[17:02:29.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:29.486]                 }
[17:02:29.486]                 if (length(args) > 0) 
[17:02:29.486]                   base::do.call(base::Sys.setenv, args = args)
[17:02:29.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:29.486]             }
[17:02:29.486]             else {
[17:02:29.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:29.486]             }
[17:02:29.486]             {
[17:02:29.486]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:29.486]                   0L) {
[17:02:29.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:29.486]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:29.486]                   base::options(opts)
[17:02:29.486]                 }
[17:02:29.486]                 {
[17:02:29.486]                   {
[17:02:29.486]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:29.486]                     NULL
[17:02:29.486]                   }
[17:02:29.486]                   options(future.plan = NULL)
[17:02:29.486]                   if (is.na(NA_character_)) 
[17:02:29.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:29.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:29.486]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:29.486]                     .init = FALSE)
[17:02:29.486]                 }
[17:02:29.486]             }
[17:02:29.486]         }
[17:02:29.486]     })
[17:02:29.486]     if (TRUE) {
[17:02:29.486]         base::sink(type = "output", split = FALSE)
[17:02:29.486]         if (TRUE) {
[17:02:29.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:29.486]         }
[17:02:29.486]         else {
[17:02:29.486]             ...future.result["stdout"] <- base::list(NULL)
[17:02:29.486]         }
[17:02:29.486]         base::close(...future.stdout)
[17:02:29.486]         ...future.stdout <- NULL
[17:02:29.486]     }
[17:02:29.486]     ...future.result$conditions <- ...future.conditions
[17:02:29.486]     ...future.result$finished <- base::Sys.time()
[17:02:29.486]     ...future.result
[17:02:29.486] }
[17:02:29.490] requestCore(): workers = 2
[17:02:29.492] MulticoreFuture started
[17:02:29.492] - Launch lazy future ... done
[17:02:29.493] run() for ‘MulticoreFuture’ ... done
[17:02:29.493] plan(): Setting new future strategy stack:
List of 6
 $ a:[17:02:29.493] List of future strategies:
[17:02:29.493] 1. sequential:
[17:02:29.493]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:29.493]    - tweaked: FALSE
[17:02:29.493]    - call: NULL
[17:02:29.499] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c749188f10> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c7497a1a40> 
 $  :[17:02:29.502] plan(): Setting new future strategy stack:
 NULL
 $  : NULL
 $  :[17:02:29.503] List of future strategies:
[17:02:29.503] 1. multicore:
[17:02:29.503]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:29.503]    - tweaked: FALSE
[17:02:29.503]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c749188f10> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c7497a1a40> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
[17:02:29.509] plan(): nbrOfWorkers() = 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:29.514] resolve() on list ...
[17:02:29.514]  recursive: 0
[17:02:29.514]  length: 6
[17:02:29.514]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:29.515] signalConditionsASAP(numeric, pos=1) ...
[17:02:29.515] - nx: 6
[17:02:29.515] - relay: TRUE
[17:02:29.515] - stdout: TRUE
[17:02:29.515] - signal: TRUE
[17:02:29.515] - resignal: FALSE
[17:02:29.515] - force: TRUE
[17:02:29.516] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.516] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.516]  - until=2
[17:02:29.516]  - relaying element #2
[17:02:29.516] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.516] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.516] signalConditionsASAP(NULL, pos=1) ... done
[17:02:29.516]  length: 5 (resolved future 1)
[17:02:29.517] Future #2
[17:02:29.517] result() for MulticoreFuture ...
[17:02:29.518] result() for MulticoreFuture ...
[17:02:29.518] result() for MulticoreFuture ... done
[17:02:29.518] result() for MulticoreFuture ... done
[17:02:29.518] result() for MulticoreFuture ...
[17:02:29.518] result() for MulticoreFuture ... done
[17:02:29.518] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:29.518] - nx: 6
[17:02:29.519] - relay: TRUE
[17:02:29.519] - stdout: TRUE
[17:02:29.519] - signal: TRUE
[17:02:29.519] - resignal: FALSE
[17:02:29.519] - force: TRUE
[17:02:29.519] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.519] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:29.520]  - until=2
[17:02:29.520]  - relaying element #2
[17:02:29.520] result() for MulticoreFuture ...
[17:02:29.520] result() for MulticoreFuture ... done
[17:02:29.520] result() for MulticoreFuture ...
[17:02:29.520] result() for MulticoreFuture ... done
[17:02:29.520] result() for MulticoreFuture ...
[17:02:29.520] result() for MulticoreFuture ... done
[17:02:29.521] result() for MulticoreFuture ...
[17:02:29.521] result() for MulticoreFuture ... done
[17:02:29.521] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.521] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.521] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:29.521]  length: 4 (resolved future 2)
[17:02:29.521] Future #3
[17:02:29.522] result() for MulticoreFuture ...
[17:02:29.522] result() for MulticoreFuture ...
[17:02:29.522] result() for MulticoreFuture ... done
[17:02:29.523] result() for MulticoreFuture ... done
[17:02:29.523] result() for MulticoreFuture ...
[17:02:29.523] result() for MulticoreFuture ... done
[17:02:29.523] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:29.523] - nx: 6
[17:02:29.523] - relay: TRUE
[17:02:29.523] - stdout: TRUE
[17:02:29.524] - signal: TRUE
[17:02:29.524] - resignal: FALSE
[17:02:29.524] - force: TRUE
[17:02:29.524] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.524] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:29.524]  - until=3
[17:02:29.524]  - relaying element #3
[17:02:29.525] result() for MulticoreFuture ...
[17:02:29.525] result() for MulticoreFuture ... done
[17:02:29.525] result() for MulticoreFuture ...
[17:02:29.525] result() for MulticoreFuture ... done
[17:02:29.525] result() for MulticoreFuture ...
[17:02:29.525] result() for MulticoreFuture ... done
[17:02:29.526] result() for MulticoreFuture ...
[17:02:29.526] result() for MulticoreFuture ... done
[17:02:29.526] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.526] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.526] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:29.526]  length: 3 (resolved future 3)
[17:02:29.526] signalConditionsASAP(NULL, pos=4) ...
[17:02:29.526] - nx: 6
[17:02:29.526] - relay: TRUE
[17:02:29.527] - stdout: TRUE
[17:02:29.527] - signal: TRUE
[17:02:29.527] - resignal: FALSE
[17:02:29.527] - force: TRUE
[17:02:29.527] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.527] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.527]  - until=5
[17:02:29.527]  - relaying element #5
[17:02:29.527] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.527] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.528] signalConditionsASAP(NULL, pos=4) ... done
[17:02:29.528]  length: 2 (resolved future 4)
[17:02:29.528] signalConditionsASAP(NULL, pos=5) ...
[17:02:29.528] - nx: 6
[17:02:29.528] - relay: TRUE
[17:02:29.528] - stdout: TRUE
[17:02:29.528] - signal: TRUE
[17:02:29.528] - resignal: FALSE
[17:02:29.528] - force: TRUE
[17:02:29.528] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:29.528] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.529]  - until=6
[17:02:29.529]  - relaying element #6
[17:02:29.529] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.529] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.529] signalConditionsASAP(NULL, pos=5) ... done
[17:02:29.529]  length: 1 (resolved future 5)
[17:02:29.529] signalConditionsASAP(numeric, pos=6) ...
[17:02:29.529] - nx: 6
[17:02:29.529] - relay: TRUE
[17:02:29.529] - stdout: TRUE
[17:02:29.529] - signal: TRUE
[17:02:29.530] - resignal: FALSE
[17:02:29.530] - force: TRUE
[17:02:29.530] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:29.530] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.530]  - until=6
[17:02:29.530] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.530] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.530] signalConditionsASAP(numeric, pos=6) ... done
[17:02:29.530]  length: 0 (resolved future 6)
[17:02:29.530] Relaying remaining futures
[17:02:29.531] signalConditionsASAP(NULL, pos=0) ...
[17:02:29.531] - nx: 6
[17:02:29.531] - relay: TRUE
[17:02:29.531] - stdout: TRUE
[17:02:29.531] - signal: TRUE
[17:02:29.531] - resignal: FALSE
[17:02:29.531] - force: TRUE
[17:02:29.531] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.531] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:29.531] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:29.532] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:29.532] signalConditionsASAP(NULL, pos=0) ... done
[17:02:29.532] resolve() on list ... DONE
[17:02:29.532] result() for MulticoreFuture ...
[17:02:29.532] result() for MulticoreFuture ... done
[17:02:29.532] result() for MulticoreFuture ...
[17:02:29.532] result() for MulticoreFuture ... done
[17:02:29.532] result() for MulticoreFuture ...
[17:02:29.532] result() for MulticoreFuture ... done
[17:02:29.532] result() for MulticoreFuture ...
[17:02:29.533] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[17:02:29.539] plan(): Setting new future strategy stack:
[17:02:29.539] List of future strategies:
[17:02:29.539] 1. multisession:
[17:02:29.539]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:02:29.539]    - tweaked: FALSE
[17:02:29.539]    - call: plan(strategy)
[17:02:29.539] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:02:29.539] multisession:
[17:02:29.539] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:02:29.539] - tweaked: FALSE
[17:02:29.539] - call: plan(strategy)
[17:02:29.545] getGlobalsAndPackages() ...
[17:02:29.545] Not searching for globals
[17:02:29.546] - globals: [0] <none>
[17:02:29.546] getGlobalsAndPackages() ... DONE
[17:02:29.546] [local output] makeClusterPSOCK() ...
[17:02:29.591] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:02:29.592] [local output] Base port: 11857
[17:02:29.592] [local output] Getting setup options for 2 cluster nodes ...
[17:02:29.592] [local output]  - Node 1 of 2 ...
[17:02:29.592] [local output] localMachine=TRUE => revtunnel=FALSE

[17:02:29.593] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp9yGsuH/worker.rank=1.parallelly.parent=42097.a47139dbfda9.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp9yGsuH/worker.rank=1.parallelly.parent=42097.a47139dbfda9.pid")'’
[17:02:29.782] - Possible to infer worker's PID: TRUE
[17:02:29.783] [local output] Rscript port: 11857

[17:02:29.783] [local output]  - Node 2 of 2 ...
[17:02:29.784] [local output] localMachine=TRUE => revtunnel=FALSE

[17:02:29.784] [local output] Rscript port: 11857

[17:02:29.784] [local output] Getting setup options for 2 cluster nodes ... done
[17:02:29.785] [local output]  - Parallel setup requested for some PSOCK nodes
[17:02:29.785] [local output] Setting up PSOCK nodes in parallel
[17:02:29.785] List of 36
[17:02:29.785]  $ worker          : chr "localhost"
[17:02:29.785]   ..- attr(*, "localhost")= logi TRUE
[17:02:29.785]  $ master          : chr "localhost"
[17:02:29.785]  $ port            : int 11857
[17:02:29.785]  $ connectTimeout  : num 120
[17:02:29.785]  $ timeout         : num 2592000
[17:02:29.785]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:02:29.785]  $ homogeneous     : logi TRUE
[17:02:29.785]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:02:29.785]  $ rscript_envs    : NULL
[17:02:29.785]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:02:29.785]  $ rscript_startup : NULL
[17:02:29.785]  $ rscript_sh      : chr "sh"
[17:02:29.785]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:02:29.785]  $ methods         : logi TRUE
[17:02:29.785]  $ socketOptions   : chr "no-delay"
[17:02:29.785]  $ useXDR          : logi FALSE
[17:02:29.785]  $ outfile         : chr "/dev/null"
[17:02:29.785]  $ renice          : int NA
[17:02:29.785]  $ rshcmd          : NULL
[17:02:29.785]  $ user            : chr(0) 
[17:02:29.785]  $ revtunnel       : logi FALSE
[17:02:29.785]  $ rshlogfile      : NULL
[17:02:29.785]  $ rshopts         : chr(0) 
[17:02:29.785]  $ rank            : int 1
[17:02:29.785]  $ manual          : logi FALSE
[17:02:29.785]  $ dryrun          : logi FALSE
[17:02:29.785]  $ quiet           : logi FALSE
[17:02:29.785]  $ setup_strategy  : chr "parallel"
[17:02:29.785]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:02:29.785]  $ pidfile         : chr "/tmp/Rtmp9yGsuH/worker.rank=1.parallelly.parent=42097.a47139dbfda9.pid"
[17:02:29.785]  $ rshcmd_label    : NULL
[17:02:29.785]  $ rsh_call        : NULL
[17:02:29.785]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:02:29.785]  $ localMachine    : logi TRUE
[17:02:29.785]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:02:29.785]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:02:29.785]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:02:29.785]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:02:29.785]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:02:29.785]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:02:29.785]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:02:29.785]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:02:29.785]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:02:29.785]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:02:29.785]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:02:29.785]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:02:29.785]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:02:29.785]  $ arguments       :List of 28
[17:02:29.785]   ..$ worker          : chr "localhost"
[17:02:29.785]   ..$ master          : NULL
[17:02:29.785]   ..$ port            : int 11857
[17:02:29.785]   ..$ connectTimeout  : num 120
[17:02:29.785]   ..$ timeout         : num 2592000
[17:02:29.785]   ..$ rscript         : NULL
[17:02:29.785]   ..$ homogeneous     : NULL
[17:02:29.785]   ..$ rscript_args    : NULL
[17:02:29.785]   ..$ rscript_envs    : NULL
[17:02:29.785]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:02:29.785]   ..$ rscript_startup : NULL
[17:02:29.785]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:02:29.785]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:02:29.785]   ..$ methods         : logi TRUE
[17:02:29.785]   ..$ socketOptions   : chr "no-delay"
[17:02:29.785]   ..$ useXDR          : logi FALSE
[17:02:29.785]   ..$ outfile         : chr "/dev/null"
[17:02:29.785]   ..$ renice          : int NA
[17:02:29.785]   ..$ rshcmd          : NULL
[17:02:29.785]   ..$ user            : NULL
[17:02:29.785]   ..$ revtunnel       : logi NA
[17:02:29.785]   ..$ rshlogfile      : NULL
[17:02:29.785]   ..$ rshopts         : NULL
[17:02:29.785]   ..$ rank            : int 1
[17:02:29.785]   ..$ manual          : logi FALSE
[17:02:29.785]   ..$ dryrun          : logi FALSE
[17:02:29.785]   ..$ quiet           : logi FALSE
[17:02:29.785]   ..$ setup_strategy  : chr "parallel"
[17:02:29.785]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:02:29.801] [local output] System call to launch all workers:
[17:02:29.801] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp9yGsuH/worker.rank=1.parallelly.parent=42097.a47139dbfda9.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11857 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:02:29.802] [local output] Starting PSOCK main server
[17:02:29.807] [local output] Workers launched
[17:02:29.808] [local output] Waiting for workers to connect back
[17:02:29.808]  - [local output] 0 workers out of 2 ready
[17:02:30.064]  - [local output] 0 workers out of 2 ready
[17:02:30.064]  - [local output] 1 workers out of 2 ready
[17:02:30.073]  - [local output] 1 workers out of 2 ready
[17:02:30.073]  - [local output] 2 workers out of 2 ready
[17:02:30.073] [local output] Launching of workers completed
[17:02:30.073] [local output] Collecting session information from workers
[17:02:30.074] [local output]  - Worker #1 of 2
[17:02:30.075] [local output]  - Worker #2 of 2
[17:02:30.075] [local output] makeClusterPSOCK() ... done
[17:02:30.086] Packages needed by the future expression (n = 0): <none>
[17:02:30.086] Packages needed by future strategies (n = 0): <none>
[17:02:30.086] {
[17:02:30.086]     {
[17:02:30.086]         {
[17:02:30.086]             ...future.startTime <- base::Sys.time()
[17:02:30.086]             {
[17:02:30.086]                 {
[17:02:30.086]                   {
[17:02:30.086]                     {
[17:02:30.086]                       base::local({
[17:02:30.086]                         has_future <- base::requireNamespace("future", 
[17:02:30.086]                           quietly = TRUE)
[17:02:30.086]                         if (has_future) {
[17:02:30.086]                           ns <- base::getNamespace("future")
[17:02:30.086]                           version <- ns[[".package"]][["version"]]
[17:02:30.086]                           if (is.null(version)) 
[17:02:30.086]                             version <- utils::packageVersion("future")
[17:02:30.086]                         }
[17:02:30.086]                         else {
[17:02:30.086]                           version <- NULL
[17:02:30.086]                         }
[17:02:30.086]                         if (!has_future || version < "1.8.0") {
[17:02:30.086]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.086]                             "", base::R.version$version.string), 
[17:02:30.086]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.086]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.086]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.086]                               "release", "version")], collapse = " "), 
[17:02:30.086]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.086]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.086]                             info)
[17:02:30.086]                           info <- base::paste(info, collapse = "; ")
[17:02:30.086]                           if (!has_future) {
[17:02:30.086]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.086]                               info)
[17:02:30.086]                           }
[17:02:30.086]                           else {
[17:02:30.086]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.086]                               info, version)
[17:02:30.086]                           }
[17:02:30.086]                           base::stop(msg)
[17:02:30.086]                         }
[17:02:30.086]                       })
[17:02:30.086]                     }
[17:02:30.086]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.086]                     base::options(mc.cores = 1L)
[17:02:30.086]                   }
[17:02:30.086]                   ...future.strategy.old <- future::plan("list")
[17:02:30.086]                   options(future.plan = NULL)
[17:02:30.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.086]                 }
[17:02:30.086]                 ...future.workdir <- getwd()
[17:02:30.086]             }
[17:02:30.086]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.086]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.086]         }
[17:02:30.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.086]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.086]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.086]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.086]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.086]             base::names(...future.oldOptions))
[17:02:30.086]     }
[17:02:30.086]     if (FALSE) {
[17:02:30.086]     }
[17:02:30.086]     else {
[17:02:30.086]         if (TRUE) {
[17:02:30.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.086]                 open = "w")
[17:02:30.086]         }
[17:02:30.086]         else {
[17:02:30.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.086]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.086]         }
[17:02:30.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.086]             base::sink(type = "output", split = FALSE)
[17:02:30.086]             base::close(...future.stdout)
[17:02:30.086]         }, add = TRUE)
[17:02:30.086]     }
[17:02:30.086]     ...future.frame <- base::sys.nframe()
[17:02:30.086]     ...future.conditions <- base::list()
[17:02:30.086]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.086]     if (FALSE) {
[17:02:30.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.086]     }
[17:02:30.086]     ...future.result <- base::tryCatch({
[17:02:30.086]         base::withCallingHandlers({
[17:02:30.086]             ...future.value <- base::withVisible(base::local({
[17:02:30.086]                 ...future.makeSendCondition <- base::local({
[17:02:30.086]                   sendCondition <- NULL
[17:02:30.086]                   function(frame = 1L) {
[17:02:30.086]                     if (is.function(sendCondition)) 
[17:02:30.086]                       return(sendCondition)
[17:02:30.086]                     ns <- getNamespace("parallel")
[17:02:30.086]                     if (exists("sendData", mode = "function", 
[17:02:30.086]                       envir = ns)) {
[17:02:30.086]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:30.086]                         envir = ns)
[17:02:30.086]                       envir <- sys.frame(frame)
[17:02:30.086]                       master <- NULL
[17:02:30.086]                       while (!identical(envir, .GlobalEnv) && 
[17:02:30.086]                         !identical(envir, emptyenv())) {
[17:02:30.086]                         if (exists("master", mode = "list", envir = envir, 
[17:02:30.086]                           inherits = FALSE)) {
[17:02:30.086]                           master <- get("master", mode = "list", 
[17:02:30.086]                             envir = envir, inherits = FALSE)
[17:02:30.086]                           if (inherits(master, c("SOCKnode", 
[17:02:30.086]                             "SOCK0node"))) {
[17:02:30.086]                             sendCondition <<- function(cond) {
[17:02:30.086]                               data <- list(type = "VALUE", value = cond, 
[17:02:30.086]                                 success = TRUE)
[17:02:30.086]                               parallel_sendData(master, data)
[17:02:30.086]                             }
[17:02:30.086]                             return(sendCondition)
[17:02:30.086]                           }
[17:02:30.086]                         }
[17:02:30.086]                         frame <- frame + 1L
[17:02:30.086]                         envir <- sys.frame(frame)
[17:02:30.086]                       }
[17:02:30.086]                     }
[17:02:30.086]                     sendCondition <<- function(cond) NULL
[17:02:30.086]                   }
[17:02:30.086]                 })
[17:02:30.086]                 withCallingHandlers({
[17:02:30.086]                   NA
[17:02:30.086]                 }, immediateCondition = function(cond) {
[17:02:30.086]                   sendCondition <- ...future.makeSendCondition()
[17:02:30.086]                   sendCondition(cond)
[17:02:30.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.086]                   {
[17:02:30.086]                     inherits <- base::inherits
[17:02:30.086]                     invokeRestart <- base::invokeRestart
[17:02:30.086]                     is.null <- base::is.null
[17:02:30.086]                     muffled <- FALSE
[17:02:30.086]                     if (inherits(cond, "message")) {
[17:02:30.086]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.086]                       if (muffled) 
[17:02:30.086]                         invokeRestart("muffleMessage")
[17:02:30.086]                     }
[17:02:30.086]                     else if (inherits(cond, "warning")) {
[17:02:30.086]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.086]                       if (muffled) 
[17:02:30.086]                         invokeRestart("muffleWarning")
[17:02:30.086]                     }
[17:02:30.086]                     else if (inherits(cond, "condition")) {
[17:02:30.086]                       if (!is.null(pattern)) {
[17:02:30.086]                         computeRestarts <- base::computeRestarts
[17:02:30.086]                         grepl <- base::grepl
[17:02:30.086]                         restarts <- computeRestarts(cond)
[17:02:30.086]                         for (restart in restarts) {
[17:02:30.086]                           name <- restart$name
[17:02:30.086]                           if (is.null(name)) 
[17:02:30.086]                             next
[17:02:30.086]                           if (!grepl(pattern, name)) 
[17:02:30.086]                             next
[17:02:30.086]                           invokeRestart(restart)
[17:02:30.086]                           muffled <- TRUE
[17:02:30.086]                           break
[17:02:30.086]                         }
[17:02:30.086]                       }
[17:02:30.086]                     }
[17:02:30.086]                     invisible(muffled)
[17:02:30.086]                   }
[17:02:30.086]                   muffleCondition(cond)
[17:02:30.086]                 })
[17:02:30.086]             }))
[17:02:30.086]             future::FutureResult(value = ...future.value$value, 
[17:02:30.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.086]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.086]                     ...future.globalenv.names))
[17:02:30.086]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.086]         }, condition = base::local({
[17:02:30.086]             c <- base::c
[17:02:30.086]             inherits <- base::inherits
[17:02:30.086]             invokeRestart <- base::invokeRestart
[17:02:30.086]             length <- base::length
[17:02:30.086]             list <- base::list
[17:02:30.086]             seq.int <- base::seq.int
[17:02:30.086]             signalCondition <- base::signalCondition
[17:02:30.086]             sys.calls <- base::sys.calls
[17:02:30.086]             `[[` <- base::`[[`
[17:02:30.086]             `+` <- base::`+`
[17:02:30.086]             `<<-` <- base::`<<-`
[17:02:30.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.086]                   3L)]
[17:02:30.086]             }
[17:02:30.086]             function(cond) {
[17:02:30.086]                 is_error <- inherits(cond, "error")
[17:02:30.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.086]                   NULL)
[17:02:30.086]                 if (is_error) {
[17:02:30.086]                   sessionInformation <- function() {
[17:02:30.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.086]                       search = base::search(), system = base::Sys.info())
[17:02:30.086]                   }
[17:02:30.086]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.086]                     cond$call), session = sessionInformation(), 
[17:02:30.086]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.086]                   signalCondition(cond)
[17:02:30.086]                 }
[17:02:30.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.086]                 "immediateCondition"))) {
[17:02:30.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.086]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.086]                   if (TRUE && !signal) {
[17:02:30.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.086]                     {
[17:02:30.086]                       inherits <- base::inherits
[17:02:30.086]                       invokeRestart <- base::invokeRestart
[17:02:30.086]                       is.null <- base::is.null
[17:02:30.086]                       muffled <- FALSE
[17:02:30.086]                       if (inherits(cond, "message")) {
[17:02:30.086]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.086]                         if (muffled) 
[17:02:30.086]                           invokeRestart("muffleMessage")
[17:02:30.086]                       }
[17:02:30.086]                       else if (inherits(cond, "warning")) {
[17:02:30.086]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.086]                         if (muffled) 
[17:02:30.086]                           invokeRestart("muffleWarning")
[17:02:30.086]                       }
[17:02:30.086]                       else if (inherits(cond, "condition")) {
[17:02:30.086]                         if (!is.null(pattern)) {
[17:02:30.086]                           computeRestarts <- base::computeRestarts
[17:02:30.086]                           grepl <- base::grepl
[17:02:30.086]                           restarts <- computeRestarts(cond)
[17:02:30.086]                           for (restart in restarts) {
[17:02:30.086]                             name <- restart$name
[17:02:30.086]                             if (is.null(name)) 
[17:02:30.086]                               next
[17:02:30.086]                             if (!grepl(pattern, name)) 
[17:02:30.086]                               next
[17:02:30.086]                             invokeRestart(restart)
[17:02:30.086]                             muffled <- TRUE
[17:02:30.086]                             break
[17:02:30.086]                           }
[17:02:30.086]                         }
[17:02:30.086]                       }
[17:02:30.086]                       invisible(muffled)
[17:02:30.086]                     }
[17:02:30.086]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.086]                   }
[17:02:30.086]                 }
[17:02:30.086]                 else {
[17:02:30.086]                   if (TRUE) {
[17:02:30.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.086]                     {
[17:02:30.086]                       inherits <- base::inherits
[17:02:30.086]                       invokeRestart <- base::invokeRestart
[17:02:30.086]                       is.null <- base::is.null
[17:02:30.086]                       muffled <- FALSE
[17:02:30.086]                       if (inherits(cond, "message")) {
[17:02:30.086]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.086]                         if (muffled) 
[17:02:30.086]                           invokeRestart("muffleMessage")
[17:02:30.086]                       }
[17:02:30.086]                       else if (inherits(cond, "warning")) {
[17:02:30.086]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.086]                         if (muffled) 
[17:02:30.086]                           invokeRestart("muffleWarning")
[17:02:30.086]                       }
[17:02:30.086]                       else if (inherits(cond, "condition")) {
[17:02:30.086]                         if (!is.null(pattern)) {
[17:02:30.086]                           computeRestarts <- base::computeRestarts
[17:02:30.086]                           grepl <- base::grepl
[17:02:30.086]                           restarts <- computeRestarts(cond)
[17:02:30.086]                           for (restart in restarts) {
[17:02:30.086]                             name <- restart$name
[17:02:30.086]                             if (is.null(name)) 
[17:02:30.086]                               next
[17:02:30.086]                             if (!grepl(pattern, name)) 
[17:02:30.086]                               next
[17:02:30.086]                             invokeRestart(restart)
[17:02:30.086]                             muffled <- TRUE
[17:02:30.086]                             break
[17:02:30.086]                           }
[17:02:30.086]                         }
[17:02:30.086]                       }
[17:02:30.086]                       invisible(muffled)
[17:02:30.086]                     }
[17:02:30.086]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.086]                   }
[17:02:30.086]                 }
[17:02:30.086]             }
[17:02:30.086]         }))
[17:02:30.086]     }, error = function(ex) {
[17:02:30.086]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.086]                 ...future.rng), started = ...future.startTime, 
[17:02:30.086]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.086]             version = "1.8"), class = "FutureResult")
[17:02:30.086]     }, finally = {
[17:02:30.086]         if (!identical(...future.workdir, getwd())) 
[17:02:30.086]             setwd(...future.workdir)
[17:02:30.086]         {
[17:02:30.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.086]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.086]             }
[17:02:30.086]             base::options(...future.oldOptions)
[17:02:30.086]             if (.Platform$OS.type == "windows") {
[17:02:30.086]                 old_names <- names(...future.oldEnvVars)
[17:02:30.086]                 envs <- base::Sys.getenv()
[17:02:30.086]                 names <- names(envs)
[17:02:30.086]                 common <- intersect(names, old_names)
[17:02:30.086]                 added <- setdiff(names, old_names)
[17:02:30.086]                 removed <- setdiff(old_names, names)
[17:02:30.086]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.086]                   envs[common]]
[17:02:30.086]                 NAMES <- toupper(changed)
[17:02:30.086]                 args <- list()
[17:02:30.086]                 for (kk in seq_along(NAMES)) {
[17:02:30.086]                   name <- changed[[kk]]
[17:02:30.086]                   NAME <- NAMES[[kk]]
[17:02:30.086]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.086]                     next
[17:02:30.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.086]                 }
[17:02:30.086]                 NAMES <- toupper(added)
[17:02:30.086]                 for (kk in seq_along(NAMES)) {
[17:02:30.086]                   name <- added[[kk]]
[17:02:30.086]                   NAME <- NAMES[[kk]]
[17:02:30.086]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.086]                     next
[17:02:30.086]                   args[[name]] <- ""
[17:02:30.086]                 }
[17:02:30.086]                 NAMES <- toupper(removed)
[17:02:30.086]                 for (kk in seq_along(NAMES)) {
[17:02:30.086]                   name <- removed[[kk]]
[17:02:30.086]                   NAME <- NAMES[[kk]]
[17:02:30.086]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.086]                     next
[17:02:30.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.086]                 }
[17:02:30.086]                 if (length(args) > 0) 
[17:02:30.086]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.086]             }
[17:02:30.086]             else {
[17:02:30.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.086]             }
[17:02:30.086]             {
[17:02:30.086]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.086]                   0L) {
[17:02:30.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.086]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.086]                   base::options(opts)
[17:02:30.086]                 }
[17:02:30.086]                 {
[17:02:30.086]                   {
[17:02:30.086]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.086]                     NULL
[17:02:30.086]                   }
[17:02:30.086]                   options(future.plan = NULL)
[17:02:30.086]                   if (is.na(NA_character_)) 
[17:02:30.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.086]                     .init = FALSE)
[17:02:30.086]                 }
[17:02:30.086]             }
[17:02:30.086]         }
[17:02:30.086]     })
[17:02:30.086]     if (TRUE) {
[17:02:30.086]         base::sink(type = "output", split = FALSE)
[17:02:30.086]         if (TRUE) {
[17:02:30.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.086]         }
[17:02:30.086]         else {
[17:02:30.086]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.086]         }
[17:02:30.086]         base::close(...future.stdout)
[17:02:30.086]         ...future.stdout <- NULL
[17:02:30.086]     }
[17:02:30.086]     ...future.result$conditions <- ...future.conditions
[17:02:30.086]     ...future.result$finished <- base::Sys.time()
[17:02:30.086]     ...future.result
[17:02:30.086] }
[17:02:30.138] MultisessionFuture started
[17:02:30.138] result() for ClusterFuture ...
[17:02:30.139] receiveMessageFromWorker() for ClusterFuture ...
[17:02:30.139] - Validating connection of MultisessionFuture
[17:02:30.170] - received message: FutureResult
[17:02:30.170] - Received FutureResult
[17:02:30.171] - Erased future from FutureRegistry
[17:02:30.171] result() for ClusterFuture ...
[17:02:30.171] - result already collected: FutureResult
[17:02:30.171] result() for ClusterFuture ... done
[17:02:30.171] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:30.171] result() for ClusterFuture ... done
[17:02:30.171] result() for ClusterFuture ...
[17:02:30.172] - result already collected: FutureResult
[17:02:30.172] result() for ClusterFuture ... done
[17:02:30.172] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:02:30.176] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:02:30.176] getGlobalsAndPackages() ...
[17:02:30.176] Searching for globals...
[17:02:30.177] 
[17:02:30.177] Searching for globals ... DONE
[17:02:30.177] - globals: [0] <none>
[17:02:30.177] getGlobalsAndPackages() ... DONE
[17:02:30.178] run() for ‘Future’ ...
[17:02:30.178] - state: ‘created’
[17:02:30.178] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.192] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.192] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:30.192]   - Field: ‘node’
[17:02:30.192]   - Field: ‘label’
[17:02:30.193]   - Field: ‘local’
[17:02:30.193]   - Field: ‘owner’
[17:02:30.193]   - Field: ‘envir’
[17:02:30.193]   - Field: ‘workers’
[17:02:30.193]   - Field: ‘packages’
[17:02:30.193]   - Field: ‘gc’
[17:02:30.193]   - Field: ‘conditions’
[17:02:30.193]   - Field: ‘persistent’
[17:02:30.193]   - Field: ‘expr’
[17:02:30.193]   - Field: ‘uuid’
[17:02:30.194]   - Field: ‘seed’
[17:02:30.194]   - Field: ‘version’
[17:02:30.194]   - Field: ‘result’
[17:02:30.194]   - Field: ‘asynchronous’
[17:02:30.194]   - Field: ‘calls’
[17:02:30.194]   - Field: ‘globals’
[17:02:30.194]   - Field: ‘stdout’
[17:02:30.194]   - Field: ‘earlySignal’
[17:02:30.194]   - Field: ‘lazy’
[17:02:30.195]   - Field: ‘state’
[17:02:30.195] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:30.195] - Launch lazy future ...
[17:02:30.195] Packages needed by the future expression (n = 0): <none>
[17:02:30.195] Packages needed by future strategies (n = 0): <none>
[17:02:30.196] {
[17:02:30.196]     {
[17:02:30.196]         {
[17:02:30.196]             ...future.startTime <- base::Sys.time()
[17:02:30.196]             {
[17:02:30.196]                 {
[17:02:30.196]                   {
[17:02:30.196]                     {
[17:02:30.196]                       base::local({
[17:02:30.196]                         has_future <- base::requireNamespace("future", 
[17:02:30.196]                           quietly = TRUE)
[17:02:30.196]                         if (has_future) {
[17:02:30.196]                           ns <- base::getNamespace("future")
[17:02:30.196]                           version <- ns[[".package"]][["version"]]
[17:02:30.196]                           if (is.null(version)) 
[17:02:30.196]                             version <- utils::packageVersion("future")
[17:02:30.196]                         }
[17:02:30.196]                         else {
[17:02:30.196]                           version <- NULL
[17:02:30.196]                         }
[17:02:30.196]                         if (!has_future || version < "1.8.0") {
[17:02:30.196]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.196]                             "", base::R.version$version.string), 
[17:02:30.196]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.196]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.196]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.196]                               "release", "version")], collapse = " "), 
[17:02:30.196]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.196]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.196]                             info)
[17:02:30.196]                           info <- base::paste(info, collapse = "; ")
[17:02:30.196]                           if (!has_future) {
[17:02:30.196]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.196]                               info)
[17:02:30.196]                           }
[17:02:30.196]                           else {
[17:02:30.196]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.196]                               info, version)
[17:02:30.196]                           }
[17:02:30.196]                           base::stop(msg)
[17:02:30.196]                         }
[17:02:30.196]                       })
[17:02:30.196]                     }
[17:02:30.196]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.196]                     base::options(mc.cores = 1L)
[17:02:30.196]                   }
[17:02:30.196]                   ...future.strategy.old <- future::plan("list")
[17:02:30.196]                   options(future.plan = NULL)
[17:02:30.196]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.196]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.196]                 }
[17:02:30.196]                 ...future.workdir <- getwd()
[17:02:30.196]             }
[17:02:30.196]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.196]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.196]         }
[17:02:30.196]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.196]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.196]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.196]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.196]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.196]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.196]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.196]             base::names(...future.oldOptions))
[17:02:30.196]     }
[17:02:30.196]     if (FALSE) {
[17:02:30.196]     }
[17:02:30.196]     else {
[17:02:30.196]         if (TRUE) {
[17:02:30.196]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.196]                 open = "w")
[17:02:30.196]         }
[17:02:30.196]         else {
[17:02:30.196]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.196]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.196]         }
[17:02:30.196]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.196]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.196]             base::sink(type = "output", split = FALSE)
[17:02:30.196]             base::close(...future.stdout)
[17:02:30.196]         }, add = TRUE)
[17:02:30.196]     }
[17:02:30.196]     ...future.frame <- base::sys.nframe()
[17:02:30.196]     ...future.conditions <- base::list()
[17:02:30.196]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.196]     if (FALSE) {
[17:02:30.196]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.196]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.196]     }
[17:02:30.196]     ...future.result <- base::tryCatch({
[17:02:30.196]         base::withCallingHandlers({
[17:02:30.196]             ...future.value <- base::withVisible(base::local({
[17:02:30.196]                 ...future.makeSendCondition <- base::local({
[17:02:30.196]                   sendCondition <- NULL
[17:02:30.196]                   function(frame = 1L) {
[17:02:30.196]                     if (is.function(sendCondition)) 
[17:02:30.196]                       return(sendCondition)
[17:02:30.196]                     ns <- getNamespace("parallel")
[17:02:30.196]                     if (exists("sendData", mode = "function", 
[17:02:30.196]                       envir = ns)) {
[17:02:30.196]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:30.196]                         envir = ns)
[17:02:30.196]                       envir <- sys.frame(frame)
[17:02:30.196]                       master <- NULL
[17:02:30.196]                       while (!identical(envir, .GlobalEnv) && 
[17:02:30.196]                         !identical(envir, emptyenv())) {
[17:02:30.196]                         if (exists("master", mode = "list", envir = envir, 
[17:02:30.196]                           inherits = FALSE)) {
[17:02:30.196]                           master <- get("master", mode = "list", 
[17:02:30.196]                             envir = envir, inherits = FALSE)
[17:02:30.196]                           if (inherits(master, c("SOCKnode", 
[17:02:30.196]                             "SOCK0node"))) {
[17:02:30.196]                             sendCondition <<- function(cond) {
[17:02:30.196]                               data <- list(type = "VALUE", value = cond, 
[17:02:30.196]                                 success = TRUE)
[17:02:30.196]                               parallel_sendData(master, data)
[17:02:30.196]                             }
[17:02:30.196]                             return(sendCondition)
[17:02:30.196]                           }
[17:02:30.196]                         }
[17:02:30.196]                         frame <- frame + 1L
[17:02:30.196]                         envir <- sys.frame(frame)
[17:02:30.196]                       }
[17:02:30.196]                     }
[17:02:30.196]                     sendCondition <<- function(cond) NULL
[17:02:30.196]                   }
[17:02:30.196]                 })
[17:02:30.196]                 withCallingHandlers({
[17:02:30.196]                   2
[17:02:30.196]                 }, immediateCondition = function(cond) {
[17:02:30.196]                   sendCondition <- ...future.makeSendCondition()
[17:02:30.196]                   sendCondition(cond)
[17:02:30.196]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.196]                   {
[17:02:30.196]                     inherits <- base::inherits
[17:02:30.196]                     invokeRestart <- base::invokeRestart
[17:02:30.196]                     is.null <- base::is.null
[17:02:30.196]                     muffled <- FALSE
[17:02:30.196]                     if (inherits(cond, "message")) {
[17:02:30.196]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.196]                       if (muffled) 
[17:02:30.196]                         invokeRestart("muffleMessage")
[17:02:30.196]                     }
[17:02:30.196]                     else if (inherits(cond, "warning")) {
[17:02:30.196]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.196]                       if (muffled) 
[17:02:30.196]                         invokeRestart("muffleWarning")
[17:02:30.196]                     }
[17:02:30.196]                     else if (inherits(cond, "condition")) {
[17:02:30.196]                       if (!is.null(pattern)) {
[17:02:30.196]                         computeRestarts <- base::computeRestarts
[17:02:30.196]                         grepl <- base::grepl
[17:02:30.196]                         restarts <- computeRestarts(cond)
[17:02:30.196]                         for (restart in restarts) {
[17:02:30.196]                           name <- restart$name
[17:02:30.196]                           if (is.null(name)) 
[17:02:30.196]                             next
[17:02:30.196]                           if (!grepl(pattern, name)) 
[17:02:30.196]                             next
[17:02:30.196]                           invokeRestart(restart)
[17:02:30.196]                           muffled <- TRUE
[17:02:30.196]                           break
[17:02:30.196]                         }
[17:02:30.196]                       }
[17:02:30.196]                     }
[17:02:30.196]                     invisible(muffled)
[17:02:30.196]                   }
[17:02:30.196]                   muffleCondition(cond)
[17:02:30.196]                 })
[17:02:30.196]             }))
[17:02:30.196]             future::FutureResult(value = ...future.value$value, 
[17:02:30.196]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.196]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.196]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.196]                     ...future.globalenv.names))
[17:02:30.196]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.196]         }, condition = base::local({
[17:02:30.196]             c <- base::c
[17:02:30.196]             inherits <- base::inherits
[17:02:30.196]             invokeRestart <- base::invokeRestart
[17:02:30.196]             length <- base::length
[17:02:30.196]             list <- base::list
[17:02:30.196]             seq.int <- base::seq.int
[17:02:30.196]             signalCondition <- base::signalCondition
[17:02:30.196]             sys.calls <- base::sys.calls
[17:02:30.196]             `[[` <- base::`[[`
[17:02:30.196]             `+` <- base::`+`
[17:02:30.196]             `<<-` <- base::`<<-`
[17:02:30.196]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.196]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.196]                   3L)]
[17:02:30.196]             }
[17:02:30.196]             function(cond) {
[17:02:30.196]                 is_error <- inherits(cond, "error")
[17:02:30.196]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.196]                   NULL)
[17:02:30.196]                 if (is_error) {
[17:02:30.196]                   sessionInformation <- function() {
[17:02:30.196]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.196]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.196]                       search = base::search(), system = base::Sys.info())
[17:02:30.196]                   }
[17:02:30.196]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.196]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.196]                     cond$call), session = sessionInformation(), 
[17:02:30.196]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.196]                   signalCondition(cond)
[17:02:30.196]                 }
[17:02:30.196]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.196]                 "immediateCondition"))) {
[17:02:30.196]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.196]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.196]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.196]                   if (TRUE && !signal) {
[17:02:30.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.196]                     {
[17:02:30.196]                       inherits <- base::inherits
[17:02:30.196]                       invokeRestart <- base::invokeRestart
[17:02:30.196]                       is.null <- base::is.null
[17:02:30.196]                       muffled <- FALSE
[17:02:30.196]                       if (inherits(cond, "message")) {
[17:02:30.196]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.196]                         if (muffled) 
[17:02:30.196]                           invokeRestart("muffleMessage")
[17:02:30.196]                       }
[17:02:30.196]                       else if (inherits(cond, "warning")) {
[17:02:30.196]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.196]                         if (muffled) 
[17:02:30.196]                           invokeRestart("muffleWarning")
[17:02:30.196]                       }
[17:02:30.196]                       else if (inherits(cond, "condition")) {
[17:02:30.196]                         if (!is.null(pattern)) {
[17:02:30.196]                           computeRestarts <- base::computeRestarts
[17:02:30.196]                           grepl <- base::grepl
[17:02:30.196]                           restarts <- computeRestarts(cond)
[17:02:30.196]                           for (restart in restarts) {
[17:02:30.196]                             name <- restart$name
[17:02:30.196]                             if (is.null(name)) 
[17:02:30.196]                               next
[17:02:30.196]                             if (!grepl(pattern, name)) 
[17:02:30.196]                               next
[17:02:30.196]                             invokeRestart(restart)
[17:02:30.196]                             muffled <- TRUE
[17:02:30.196]                             break
[17:02:30.196]                           }
[17:02:30.196]                         }
[17:02:30.196]                       }
[17:02:30.196]                       invisible(muffled)
[17:02:30.196]                     }
[17:02:30.196]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.196]                   }
[17:02:30.196]                 }
[17:02:30.196]                 else {
[17:02:30.196]                   if (TRUE) {
[17:02:30.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.196]                     {
[17:02:30.196]                       inherits <- base::inherits
[17:02:30.196]                       invokeRestart <- base::invokeRestart
[17:02:30.196]                       is.null <- base::is.null
[17:02:30.196]                       muffled <- FALSE
[17:02:30.196]                       if (inherits(cond, "message")) {
[17:02:30.196]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.196]                         if (muffled) 
[17:02:30.196]                           invokeRestart("muffleMessage")
[17:02:30.196]                       }
[17:02:30.196]                       else if (inherits(cond, "warning")) {
[17:02:30.196]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.196]                         if (muffled) 
[17:02:30.196]                           invokeRestart("muffleWarning")
[17:02:30.196]                       }
[17:02:30.196]                       else if (inherits(cond, "condition")) {
[17:02:30.196]                         if (!is.null(pattern)) {
[17:02:30.196]                           computeRestarts <- base::computeRestarts
[17:02:30.196]                           grepl <- base::grepl
[17:02:30.196]                           restarts <- computeRestarts(cond)
[17:02:30.196]                           for (restart in restarts) {
[17:02:30.196]                             name <- restart$name
[17:02:30.196]                             if (is.null(name)) 
[17:02:30.196]                               next
[17:02:30.196]                             if (!grepl(pattern, name)) 
[17:02:30.196]                               next
[17:02:30.196]                             invokeRestart(restart)
[17:02:30.196]                             muffled <- TRUE
[17:02:30.196]                             break
[17:02:30.196]                           }
[17:02:30.196]                         }
[17:02:30.196]                       }
[17:02:30.196]                       invisible(muffled)
[17:02:30.196]                     }
[17:02:30.196]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.196]                   }
[17:02:30.196]                 }
[17:02:30.196]             }
[17:02:30.196]         }))
[17:02:30.196]     }, error = function(ex) {
[17:02:30.196]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.196]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.196]                 ...future.rng), started = ...future.startTime, 
[17:02:30.196]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.196]             version = "1.8"), class = "FutureResult")
[17:02:30.196]     }, finally = {
[17:02:30.196]         if (!identical(...future.workdir, getwd())) 
[17:02:30.196]             setwd(...future.workdir)
[17:02:30.196]         {
[17:02:30.196]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.196]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.196]             }
[17:02:30.196]             base::options(...future.oldOptions)
[17:02:30.196]             if (.Platform$OS.type == "windows") {
[17:02:30.196]                 old_names <- names(...future.oldEnvVars)
[17:02:30.196]                 envs <- base::Sys.getenv()
[17:02:30.196]                 names <- names(envs)
[17:02:30.196]                 common <- intersect(names, old_names)
[17:02:30.196]                 added <- setdiff(names, old_names)
[17:02:30.196]                 removed <- setdiff(old_names, names)
[17:02:30.196]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.196]                   envs[common]]
[17:02:30.196]                 NAMES <- toupper(changed)
[17:02:30.196]                 args <- list()
[17:02:30.196]                 for (kk in seq_along(NAMES)) {
[17:02:30.196]                   name <- changed[[kk]]
[17:02:30.196]                   NAME <- NAMES[[kk]]
[17:02:30.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.196]                     next
[17:02:30.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.196]                 }
[17:02:30.196]                 NAMES <- toupper(added)
[17:02:30.196]                 for (kk in seq_along(NAMES)) {
[17:02:30.196]                   name <- added[[kk]]
[17:02:30.196]                   NAME <- NAMES[[kk]]
[17:02:30.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.196]                     next
[17:02:30.196]                   args[[name]] <- ""
[17:02:30.196]                 }
[17:02:30.196]                 NAMES <- toupper(removed)
[17:02:30.196]                 for (kk in seq_along(NAMES)) {
[17:02:30.196]                   name <- removed[[kk]]
[17:02:30.196]                   NAME <- NAMES[[kk]]
[17:02:30.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.196]                     next
[17:02:30.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.196]                 }
[17:02:30.196]                 if (length(args) > 0) 
[17:02:30.196]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.196]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.196]             }
[17:02:30.196]             else {
[17:02:30.196]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.196]             }
[17:02:30.196]             {
[17:02:30.196]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.196]                   0L) {
[17:02:30.196]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.196]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.196]                   base::options(opts)
[17:02:30.196]                 }
[17:02:30.196]                 {
[17:02:30.196]                   {
[17:02:30.196]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.196]                     NULL
[17:02:30.196]                   }
[17:02:30.196]                   options(future.plan = NULL)
[17:02:30.196]                   if (is.na(NA_character_)) 
[17:02:30.196]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.196]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.196]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.196]                     .init = FALSE)
[17:02:30.196]                 }
[17:02:30.196]             }
[17:02:30.196]         }
[17:02:30.196]     })
[17:02:30.196]     if (TRUE) {
[17:02:30.196]         base::sink(type = "output", split = FALSE)
[17:02:30.196]         if (TRUE) {
[17:02:30.196]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.196]         }
[17:02:30.196]         else {
[17:02:30.196]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.196]         }
[17:02:30.196]         base::close(...future.stdout)
[17:02:30.196]         ...future.stdout <- NULL
[17:02:30.196]     }
[17:02:30.196]     ...future.result$conditions <- ...future.conditions
[17:02:30.196]     ...future.result$finished <- base::Sys.time()
[17:02:30.196]     ...future.result
[17:02:30.196] }
[17:02:30.199] MultisessionFuture started
[17:02:30.199] - Launch lazy future ... done
[17:02:30.199] run() for ‘MultisessionFuture’ ... done
[17:02:30.200] getGlobalsAndPackages() ...
[17:02:30.200] Searching for globals...
[17:02:30.200] 
[17:02:30.200] Searching for globals ... DONE
[17:02:30.200] - globals: [0] <none>
[17:02:30.200] getGlobalsAndPackages() ... DONE
[17:02:30.201] run() for ‘Future’ ...
[17:02:30.201] - state: ‘created’
[17:02:30.201] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.215] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.215] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:30.215]   - Field: ‘node’
[17:02:30.215]   - Field: ‘label’
[17:02:30.215]   - Field: ‘local’
[17:02:30.215]   - Field: ‘owner’
[17:02:30.216]   - Field: ‘envir’
[17:02:30.216]   - Field: ‘workers’
[17:02:30.216]   - Field: ‘packages’
[17:02:30.216]   - Field: ‘gc’
[17:02:30.216]   - Field: ‘conditions’
[17:02:30.216]   - Field: ‘persistent’
[17:02:30.216]   - Field: ‘expr’
[17:02:30.216]   - Field: ‘uuid’
[17:02:30.216]   - Field: ‘seed’
[17:02:30.217]   - Field: ‘version’
[17:02:30.217]   - Field: ‘result’
[17:02:30.217]   - Field: ‘asynchronous’
[17:02:30.217]   - Field: ‘calls’
[17:02:30.217]   - Field: ‘globals’
[17:02:30.217]   - Field: ‘stdout’
[17:02:30.217]   - Field: ‘earlySignal’
[17:02:30.217]   - Field: ‘lazy’
[17:02:30.217]   - Field: ‘state’
[17:02:30.218] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:30.218] - Launch lazy future ...
[17:02:30.218] Packages needed by the future expression (n = 0): <none>
[17:02:30.218] Packages needed by future strategies (n = 0): <none>
[17:02:30.219] {
[17:02:30.219]     {
[17:02:30.219]         {
[17:02:30.219]             ...future.startTime <- base::Sys.time()
[17:02:30.219]             {
[17:02:30.219]                 {
[17:02:30.219]                   {
[17:02:30.219]                     {
[17:02:30.219]                       base::local({
[17:02:30.219]                         has_future <- base::requireNamespace("future", 
[17:02:30.219]                           quietly = TRUE)
[17:02:30.219]                         if (has_future) {
[17:02:30.219]                           ns <- base::getNamespace("future")
[17:02:30.219]                           version <- ns[[".package"]][["version"]]
[17:02:30.219]                           if (is.null(version)) 
[17:02:30.219]                             version <- utils::packageVersion("future")
[17:02:30.219]                         }
[17:02:30.219]                         else {
[17:02:30.219]                           version <- NULL
[17:02:30.219]                         }
[17:02:30.219]                         if (!has_future || version < "1.8.0") {
[17:02:30.219]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.219]                             "", base::R.version$version.string), 
[17:02:30.219]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.219]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.219]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.219]                               "release", "version")], collapse = " "), 
[17:02:30.219]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.219]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.219]                             info)
[17:02:30.219]                           info <- base::paste(info, collapse = "; ")
[17:02:30.219]                           if (!has_future) {
[17:02:30.219]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.219]                               info)
[17:02:30.219]                           }
[17:02:30.219]                           else {
[17:02:30.219]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.219]                               info, version)
[17:02:30.219]                           }
[17:02:30.219]                           base::stop(msg)
[17:02:30.219]                         }
[17:02:30.219]                       })
[17:02:30.219]                     }
[17:02:30.219]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.219]                     base::options(mc.cores = 1L)
[17:02:30.219]                   }
[17:02:30.219]                   ...future.strategy.old <- future::plan("list")
[17:02:30.219]                   options(future.plan = NULL)
[17:02:30.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.219]                 }
[17:02:30.219]                 ...future.workdir <- getwd()
[17:02:30.219]             }
[17:02:30.219]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.219]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.219]         }
[17:02:30.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.219]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.219]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.219]             base::names(...future.oldOptions))
[17:02:30.219]     }
[17:02:30.219]     if (FALSE) {
[17:02:30.219]     }
[17:02:30.219]     else {
[17:02:30.219]         if (TRUE) {
[17:02:30.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.219]                 open = "w")
[17:02:30.219]         }
[17:02:30.219]         else {
[17:02:30.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.219]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.219]         }
[17:02:30.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.219]             base::sink(type = "output", split = FALSE)
[17:02:30.219]             base::close(...future.stdout)
[17:02:30.219]         }, add = TRUE)
[17:02:30.219]     }
[17:02:30.219]     ...future.frame <- base::sys.nframe()
[17:02:30.219]     ...future.conditions <- base::list()
[17:02:30.219]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.219]     if (FALSE) {
[17:02:30.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.219]     }
[17:02:30.219]     ...future.result <- base::tryCatch({
[17:02:30.219]         base::withCallingHandlers({
[17:02:30.219]             ...future.value <- base::withVisible(base::local({
[17:02:30.219]                 ...future.makeSendCondition <- base::local({
[17:02:30.219]                   sendCondition <- NULL
[17:02:30.219]                   function(frame = 1L) {
[17:02:30.219]                     if (is.function(sendCondition)) 
[17:02:30.219]                       return(sendCondition)
[17:02:30.219]                     ns <- getNamespace("parallel")
[17:02:30.219]                     if (exists("sendData", mode = "function", 
[17:02:30.219]                       envir = ns)) {
[17:02:30.219]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:30.219]                         envir = ns)
[17:02:30.219]                       envir <- sys.frame(frame)
[17:02:30.219]                       master <- NULL
[17:02:30.219]                       while (!identical(envir, .GlobalEnv) && 
[17:02:30.219]                         !identical(envir, emptyenv())) {
[17:02:30.219]                         if (exists("master", mode = "list", envir = envir, 
[17:02:30.219]                           inherits = FALSE)) {
[17:02:30.219]                           master <- get("master", mode = "list", 
[17:02:30.219]                             envir = envir, inherits = FALSE)
[17:02:30.219]                           if (inherits(master, c("SOCKnode", 
[17:02:30.219]                             "SOCK0node"))) {
[17:02:30.219]                             sendCondition <<- function(cond) {
[17:02:30.219]                               data <- list(type = "VALUE", value = cond, 
[17:02:30.219]                                 success = TRUE)
[17:02:30.219]                               parallel_sendData(master, data)
[17:02:30.219]                             }
[17:02:30.219]                             return(sendCondition)
[17:02:30.219]                           }
[17:02:30.219]                         }
[17:02:30.219]                         frame <- frame + 1L
[17:02:30.219]                         envir <- sys.frame(frame)
[17:02:30.219]                       }
[17:02:30.219]                     }
[17:02:30.219]                     sendCondition <<- function(cond) NULL
[17:02:30.219]                   }
[17:02:30.219]                 })
[17:02:30.219]                 withCallingHandlers({
[17:02:30.219]                   NULL
[17:02:30.219]                 }, immediateCondition = function(cond) {
[17:02:30.219]                   sendCondition <- ...future.makeSendCondition()
[17:02:30.219]                   sendCondition(cond)
[17:02:30.219]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.219]                   {
[17:02:30.219]                     inherits <- base::inherits
[17:02:30.219]                     invokeRestart <- base::invokeRestart
[17:02:30.219]                     is.null <- base::is.null
[17:02:30.219]                     muffled <- FALSE
[17:02:30.219]                     if (inherits(cond, "message")) {
[17:02:30.219]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.219]                       if (muffled) 
[17:02:30.219]                         invokeRestart("muffleMessage")
[17:02:30.219]                     }
[17:02:30.219]                     else if (inherits(cond, "warning")) {
[17:02:30.219]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.219]                       if (muffled) 
[17:02:30.219]                         invokeRestart("muffleWarning")
[17:02:30.219]                     }
[17:02:30.219]                     else if (inherits(cond, "condition")) {
[17:02:30.219]                       if (!is.null(pattern)) {
[17:02:30.219]                         computeRestarts <- base::computeRestarts
[17:02:30.219]                         grepl <- base::grepl
[17:02:30.219]                         restarts <- computeRestarts(cond)
[17:02:30.219]                         for (restart in restarts) {
[17:02:30.219]                           name <- restart$name
[17:02:30.219]                           if (is.null(name)) 
[17:02:30.219]                             next
[17:02:30.219]                           if (!grepl(pattern, name)) 
[17:02:30.219]                             next
[17:02:30.219]                           invokeRestart(restart)
[17:02:30.219]                           muffled <- TRUE
[17:02:30.219]                           break
[17:02:30.219]                         }
[17:02:30.219]                       }
[17:02:30.219]                     }
[17:02:30.219]                     invisible(muffled)
[17:02:30.219]                   }
[17:02:30.219]                   muffleCondition(cond)
[17:02:30.219]                 })
[17:02:30.219]             }))
[17:02:30.219]             future::FutureResult(value = ...future.value$value, 
[17:02:30.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.219]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.219]                     ...future.globalenv.names))
[17:02:30.219]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.219]         }, condition = base::local({
[17:02:30.219]             c <- base::c
[17:02:30.219]             inherits <- base::inherits
[17:02:30.219]             invokeRestart <- base::invokeRestart
[17:02:30.219]             length <- base::length
[17:02:30.219]             list <- base::list
[17:02:30.219]             seq.int <- base::seq.int
[17:02:30.219]             signalCondition <- base::signalCondition
[17:02:30.219]             sys.calls <- base::sys.calls
[17:02:30.219]             `[[` <- base::`[[`
[17:02:30.219]             `+` <- base::`+`
[17:02:30.219]             `<<-` <- base::`<<-`
[17:02:30.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.219]                   3L)]
[17:02:30.219]             }
[17:02:30.219]             function(cond) {
[17:02:30.219]                 is_error <- inherits(cond, "error")
[17:02:30.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.219]                   NULL)
[17:02:30.219]                 if (is_error) {
[17:02:30.219]                   sessionInformation <- function() {
[17:02:30.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.219]                       search = base::search(), system = base::Sys.info())
[17:02:30.219]                   }
[17:02:30.219]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.219]                     cond$call), session = sessionInformation(), 
[17:02:30.219]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.219]                   signalCondition(cond)
[17:02:30.219]                 }
[17:02:30.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.219]                 "immediateCondition"))) {
[17:02:30.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.219]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.219]                   if (TRUE && !signal) {
[17:02:30.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.219]                     {
[17:02:30.219]                       inherits <- base::inherits
[17:02:30.219]                       invokeRestart <- base::invokeRestart
[17:02:30.219]                       is.null <- base::is.null
[17:02:30.219]                       muffled <- FALSE
[17:02:30.219]                       if (inherits(cond, "message")) {
[17:02:30.219]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.219]                         if (muffled) 
[17:02:30.219]                           invokeRestart("muffleMessage")
[17:02:30.219]                       }
[17:02:30.219]                       else if (inherits(cond, "warning")) {
[17:02:30.219]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.219]                         if (muffled) 
[17:02:30.219]                           invokeRestart("muffleWarning")
[17:02:30.219]                       }
[17:02:30.219]                       else if (inherits(cond, "condition")) {
[17:02:30.219]                         if (!is.null(pattern)) {
[17:02:30.219]                           computeRestarts <- base::computeRestarts
[17:02:30.219]                           grepl <- base::grepl
[17:02:30.219]                           restarts <- computeRestarts(cond)
[17:02:30.219]                           for (restart in restarts) {
[17:02:30.219]                             name <- restart$name
[17:02:30.219]                             if (is.null(name)) 
[17:02:30.219]                               next
[17:02:30.219]                             if (!grepl(pattern, name)) 
[17:02:30.219]                               next
[17:02:30.219]                             invokeRestart(restart)
[17:02:30.219]                             muffled <- TRUE
[17:02:30.219]                             break
[17:02:30.219]                           }
[17:02:30.219]                         }
[17:02:30.219]                       }
[17:02:30.219]                       invisible(muffled)
[17:02:30.219]                     }
[17:02:30.219]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.219]                   }
[17:02:30.219]                 }
[17:02:30.219]                 else {
[17:02:30.219]                   if (TRUE) {
[17:02:30.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.219]                     {
[17:02:30.219]                       inherits <- base::inherits
[17:02:30.219]                       invokeRestart <- base::invokeRestart
[17:02:30.219]                       is.null <- base::is.null
[17:02:30.219]                       muffled <- FALSE
[17:02:30.219]                       if (inherits(cond, "message")) {
[17:02:30.219]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.219]                         if (muffled) 
[17:02:30.219]                           invokeRestart("muffleMessage")
[17:02:30.219]                       }
[17:02:30.219]                       else if (inherits(cond, "warning")) {
[17:02:30.219]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.219]                         if (muffled) 
[17:02:30.219]                           invokeRestart("muffleWarning")
[17:02:30.219]                       }
[17:02:30.219]                       else if (inherits(cond, "condition")) {
[17:02:30.219]                         if (!is.null(pattern)) {
[17:02:30.219]                           computeRestarts <- base::computeRestarts
[17:02:30.219]                           grepl <- base::grepl
[17:02:30.219]                           restarts <- computeRestarts(cond)
[17:02:30.219]                           for (restart in restarts) {
[17:02:30.219]                             name <- restart$name
[17:02:30.219]                             if (is.null(name)) 
[17:02:30.219]                               next
[17:02:30.219]                             if (!grepl(pattern, name)) 
[17:02:30.219]                               next
[17:02:30.219]                             invokeRestart(restart)
[17:02:30.219]                             muffled <- TRUE
[17:02:30.219]                             break
[17:02:30.219]                           }
[17:02:30.219]                         }
[17:02:30.219]                       }
[17:02:30.219]                       invisible(muffled)
[17:02:30.219]                     }
[17:02:30.219]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.219]                   }
[17:02:30.219]                 }
[17:02:30.219]             }
[17:02:30.219]         }))
[17:02:30.219]     }, error = function(ex) {
[17:02:30.219]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.219]                 ...future.rng), started = ...future.startTime, 
[17:02:30.219]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.219]             version = "1.8"), class = "FutureResult")
[17:02:30.219]     }, finally = {
[17:02:30.219]         if (!identical(...future.workdir, getwd())) 
[17:02:30.219]             setwd(...future.workdir)
[17:02:30.219]         {
[17:02:30.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.219]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.219]             }
[17:02:30.219]             base::options(...future.oldOptions)
[17:02:30.219]             if (.Platform$OS.type == "windows") {
[17:02:30.219]                 old_names <- names(...future.oldEnvVars)
[17:02:30.219]                 envs <- base::Sys.getenv()
[17:02:30.219]                 names <- names(envs)
[17:02:30.219]                 common <- intersect(names, old_names)
[17:02:30.219]                 added <- setdiff(names, old_names)
[17:02:30.219]                 removed <- setdiff(old_names, names)
[17:02:30.219]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.219]                   envs[common]]
[17:02:30.219]                 NAMES <- toupper(changed)
[17:02:30.219]                 args <- list()
[17:02:30.219]                 for (kk in seq_along(NAMES)) {
[17:02:30.219]                   name <- changed[[kk]]
[17:02:30.219]                   NAME <- NAMES[[kk]]
[17:02:30.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.219]                     next
[17:02:30.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.219]                 }
[17:02:30.219]                 NAMES <- toupper(added)
[17:02:30.219]                 for (kk in seq_along(NAMES)) {
[17:02:30.219]                   name <- added[[kk]]
[17:02:30.219]                   NAME <- NAMES[[kk]]
[17:02:30.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.219]                     next
[17:02:30.219]                   args[[name]] <- ""
[17:02:30.219]                 }
[17:02:30.219]                 NAMES <- toupper(removed)
[17:02:30.219]                 for (kk in seq_along(NAMES)) {
[17:02:30.219]                   name <- removed[[kk]]
[17:02:30.219]                   NAME <- NAMES[[kk]]
[17:02:30.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.219]                     next
[17:02:30.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.219]                 }
[17:02:30.219]                 if (length(args) > 0) 
[17:02:30.219]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.219]             }
[17:02:30.219]             else {
[17:02:30.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.219]             }
[17:02:30.219]             {
[17:02:30.219]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.219]                   0L) {
[17:02:30.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.219]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.219]                   base::options(opts)
[17:02:30.219]                 }
[17:02:30.219]                 {
[17:02:30.219]                   {
[17:02:30.219]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.219]                     NULL
[17:02:30.219]                   }
[17:02:30.219]                   options(future.plan = NULL)
[17:02:30.219]                   if (is.na(NA_character_)) 
[17:02:30.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.219]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.219]                     .init = FALSE)
[17:02:30.219]                 }
[17:02:30.219]             }
[17:02:30.219]         }
[17:02:30.219]     })
[17:02:30.219]     if (TRUE) {
[17:02:30.219]         base::sink(type = "output", split = FALSE)
[17:02:30.219]         if (TRUE) {
[17:02:30.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.219]         }
[17:02:30.219]         else {
[17:02:30.219]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.219]         }
[17:02:30.219]         base::close(...future.stdout)
[17:02:30.219]         ...future.stdout <- NULL
[17:02:30.219]     }
[17:02:30.219]     ...future.result$conditions <- ...future.conditions
[17:02:30.219]     ...future.result$finished <- base::Sys.time()
[17:02:30.219]     ...future.result
[17:02:30.219] }
[17:02:30.271] MultisessionFuture started
[17:02:30.272] - Launch lazy future ... done
[17:02:30.272] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74a815400> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74ac74700> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74a815400> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74ac74700> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:02:30.277] receiveMessageFromWorker() for ClusterFuture ...
[17:02:30.277] - Validating connection of MultisessionFuture
[17:02:30.278] - received message: FutureResult
[17:02:30.278] - Received FutureResult
[17:02:30.278] - Erased future from FutureRegistry
[17:02:30.278] result() for ClusterFuture ...
[17:02:30.278] - result already collected: FutureResult
[17:02:30.278] result() for ClusterFuture ... done
[17:02:30.278] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:30.290] resolve() on list ...
[17:02:30.290]  recursive: 0
[17:02:30.290]  length: 6
[17:02:30.290]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:30.290] signalConditionsASAP(numeric, pos=1) ...
[17:02:30.290] - nx: 6
[17:02:30.291] - relay: TRUE
[17:02:30.291] - stdout: TRUE
[17:02:30.291] - signal: TRUE
[17:02:30.291] - resignal: FALSE
[17:02:30.291] - force: TRUE
[17:02:30.291] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.291] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.291]  - until=2
[17:02:30.291]  - relaying element #2
[17:02:30.292] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.292] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.292] signalConditionsASAP(NULL, pos=1) ... done
[17:02:30.292]  length: 5 (resolved future 1)
[17:02:30.292] Future #2
[17:02:30.292] result() for ClusterFuture ...
[17:02:30.292] - result already collected: FutureResult
[17:02:30.292] result() for ClusterFuture ... done
[17:02:30.293] result() for ClusterFuture ...
[17:02:30.293] - result already collected: FutureResult
[17:02:30.293] result() for ClusterFuture ... done
[17:02:30.293] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:30.293] - nx: 6
[17:02:30.293] - relay: TRUE
[17:02:30.293] - stdout: TRUE
[17:02:30.293] - signal: TRUE
[17:02:30.293] - resignal: FALSE
[17:02:30.294] - force: TRUE
[17:02:30.294] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.294] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.294]  - until=2
[17:02:30.294]  - relaying element #2
[17:02:30.294] result() for ClusterFuture ...
[17:02:30.294] - result already collected: FutureResult
[17:02:30.294] result() for ClusterFuture ... done
[17:02:30.294] result() for ClusterFuture ...
[17:02:30.295] - result already collected: FutureResult
[17:02:30.295] result() for ClusterFuture ... done
[17:02:30.295] result() for ClusterFuture ...
[17:02:30.295] - result already collected: FutureResult
[17:02:30.295] result() for ClusterFuture ... done
[17:02:30.295] result() for ClusterFuture ...
[17:02:30.295] - result already collected: FutureResult
[17:02:30.295] result() for ClusterFuture ... done
[17:02:30.295] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.296] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.296] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:30.296]  length: 4 (resolved future 2)
[17:02:30.304] receiveMessageFromWorker() for ClusterFuture ...
[17:02:30.304] - Validating connection of MultisessionFuture
[17:02:30.304] - received message: FutureResult
[17:02:30.304] - Received FutureResult
[17:02:30.304] - Erased future from FutureRegistry
[17:02:30.304] result() for ClusterFuture ...
[17:02:30.305] - result already collected: FutureResult
[17:02:30.305] result() for ClusterFuture ... done
[17:02:30.305] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:30.305] Future #3
[17:02:30.305] result() for ClusterFuture ...
[17:02:30.305] - result already collected: FutureResult
[17:02:30.305] result() for ClusterFuture ... done
[17:02:30.305] result() for ClusterFuture ...
[17:02:30.305] - result already collected: FutureResult
[17:02:30.306] result() for ClusterFuture ... done
[17:02:30.306] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:30.306] - nx: 6
[17:02:30.306] - relay: TRUE
[17:02:30.306] - stdout: TRUE
[17:02:30.306] - signal: TRUE
[17:02:30.306] - resignal: FALSE
[17:02:30.306] - force: TRUE
[17:02:30.306] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.307] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.307]  - until=3
[17:02:30.307]  - relaying element #3
[17:02:30.307] result() for ClusterFuture ...
[17:02:30.307] - result already collected: FutureResult
[17:02:30.307] result() for ClusterFuture ... done
[17:02:30.307] result() for ClusterFuture ...
[17:02:30.307] - result already collected: FutureResult
[17:02:30.307] result() for ClusterFuture ... done
[17:02:30.308] result() for ClusterFuture ...
[17:02:30.308] - result already collected: FutureResult
[17:02:30.308] result() for ClusterFuture ... done
[17:02:30.308] result() for ClusterFuture ...
[17:02:30.308] - result already collected: FutureResult
[17:02:30.308] result() for ClusterFuture ... done
[17:02:30.308] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.308] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.308] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:30.309]  length: 3 (resolved future 3)
[17:02:30.309] signalConditionsASAP(NULL, pos=4) ...
[17:02:30.309] - nx: 6
[17:02:30.309] - relay: TRUE
[17:02:30.309] - stdout: TRUE
[17:02:30.309] - signal: TRUE
[17:02:30.309] - resignal: FALSE
[17:02:30.309] - force: TRUE
[17:02:30.309] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.309] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.310]  - until=5
[17:02:30.310]  - relaying element #5
[17:02:30.310] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:30.310] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.310] signalConditionsASAP(NULL, pos=4) ... done
[17:02:30.310]  length: 2 (resolved future 4)
[17:02:30.310] signalConditionsASAP(NULL, pos=5) ...
[17:02:30.310] - nx: 6
[17:02:30.310] - relay: TRUE
[17:02:30.311] - stdout: TRUE
[17:02:30.311] - signal: TRUE
[17:02:30.311] - resignal: FALSE
[17:02:30.311] - force: TRUE
[17:02:30.311] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:30.311] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.311]  - until=6
[17:02:30.311]  - relaying element #6
[17:02:30.311] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:30.312] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.312] signalConditionsASAP(NULL, pos=5) ... done
[17:02:30.312]  length: 1 (resolved future 5)
[17:02:30.312] signalConditionsASAP(numeric, pos=6) ...
[17:02:30.312] - nx: 6
[17:02:30.312] - relay: TRUE
[17:02:30.312] - stdout: TRUE
[17:02:30.312] - signal: TRUE
[17:02:30.312] - resignal: FALSE
[17:02:30.313] - force: TRUE
[17:02:30.313] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:30.313] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.313]  - until=6
[17:02:30.313] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.313] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.313] signalConditionsASAP(numeric, pos=6) ... done
[17:02:30.313]  length: 0 (resolved future 6)
[17:02:30.313] Relaying remaining futures
[17:02:30.313] signalConditionsASAP(NULL, pos=0) ...
[17:02:30.314] - nx: 6
[17:02:30.314] - relay: TRUE
[17:02:30.314] - stdout: TRUE
[17:02:30.314] - signal: TRUE
[17:02:30.314] - resignal: FALSE
[17:02:30.314] - force: TRUE
[17:02:30.314] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.314] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:30.314] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.315] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.315] signalConditionsASAP(NULL, pos=0) ... done
[17:02:30.315] resolve() on list ... DONE
[17:02:30.315] result() for ClusterFuture ...
[17:02:30.317] - result already collected: FutureResult
[17:02:30.317] result() for ClusterFuture ... done
[17:02:30.317] result() for ClusterFuture ...
[17:02:30.317] - result already collected: FutureResult
[17:02:30.317] result() for ClusterFuture ... done
[17:02:30.318] result() for ClusterFuture ...
[17:02:30.318] - result already collected: FutureResult
[17:02:30.318] result() for ClusterFuture ... done
[17:02:30.318] result() for ClusterFuture ...
[17:02:30.318] - result already collected: FutureResult
[17:02:30.318] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[17:02:30.320] getGlobalsAndPackages() ...
[17:02:30.320] Searching for globals...
[17:02:30.320] 
[17:02:30.321] Searching for globals ... DONE
[17:02:30.321] - globals: [0] <none>
[17:02:30.321] getGlobalsAndPackages() ... DONE
[17:02:30.321] run() for ‘Future’ ...
[17:02:30.321] - state: ‘created’
[17:02:30.321] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.335] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.335] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:30.335]   - Field: ‘node’
[17:02:30.335]   - Field: ‘label’
[17:02:30.335]   - Field: ‘local’
[17:02:30.335]   - Field: ‘owner’
[17:02:30.336]   - Field: ‘envir’
[17:02:30.336]   - Field: ‘workers’
[17:02:30.336]   - Field: ‘packages’
[17:02:30.336]   - Field: ‘gc’
[17:02:30.336]   - Field: ‘conditions’
[17:02:30.336]   - Field: ‘persistent’
[17:02:30.336]   - Field: ‘expr’
[17:02:30.336]   - Field: ‘uuid’
[17:02:30.336]   - Field: ‘seed’
[17:02:30.336]   - Field: ‘version’
[17:02:30.336]   - Field: ‘result’
[17:02:30.336]   - Field: ‘asynchronous’
[17:02:30.337]   - Field: ‘calls’
[17:02:30.337]   - Field: ‘globals’
[17:02:30.337]   - Field: ‘stdout’
[17:02:30.337]   - Field: ‘earlySignal’
[17:02:30.337]   - Field: ‘lazy’
[17:02:30.337]   - Field: ‘state’
[17:02:30.337] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:30.337] - Launch lazy future ...
[17:02:30.337] Packages needed by the future expression (n = 0): <none>
[17:02:30.338] Packages needed by future strategies (n = 0): <none>
[17:02:30.338] {
[17:02:30.338]     {
[17:02:30.338]         {
[17:02:30.338]             ...future.startTime <- base::Sys.time()
[17:02:30.338]             {
[17:02:30.338]                 {
[17:02:30.338]                   {
[17:02:30.338]                     {
[17:02:30.338]                       base::local({
[17:02:30.338]                         has_future <- base::requireNamespace("future", 
[17:02:30.338]                           quietly = TRUE)
[17:02:30.338]                         if (has_future) {
[17:02:30.338]                           ns <- base::getNamespace("future")
[17:02:30.338]                           version <- ns[[".package"]][["version"]]
[17:02:30.338]                           if (is.null(version)) 
[17:02:30.338]                             version <- utils::packageVersion("future")
[17:02:30.338]                         }
[17:02:30.338]                         else {
[17:02:30.338]                           version <- NULL
[17:02:30.338]                         }
[17:02:30.338]                         if (!has_future || version < "1.8.0") {
[17:02:30.338]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.338]                             "", base::R.version$version.string), 
[17:02:30.338]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.338]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.338]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.338]                               "release", "version")], collapse = " "), 
[17:02:30.338]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.338]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.338]                             info)
[17:02:30.338]                           info <- base::paste(info, collapse = "; ")
[17:02:30.338]                           if (!has_future) {
[17:02:30.338]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.338]                               info)
[17:02:30.338]                           }
[17:02:30.338]                           else {
[17:02:30.338]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.338]                               info, version)
[17:02:30.338]                           }
[17:02:30.338]                           base::stop(msg)
[17:02:30.338]                         }
[17:02:30.338]                       })
[17:02:30.338]                     }
[17:02:30.338]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.338]                     base::options(mc.cores = 1L)
[17:02:30.338]                   }
[17:02:30.338]                   ...future.strategy.old <- future::plan("list")
[17:02:30.338]                   options(future.plan = NULL)
[17:02:30.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.338]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.338]                 }
[17:02:30.338]                 ...future.workdir <- getwd()
[17:02:30.338]             }
[17:02:30.338]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.338]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.338]         }
[17:02:30.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.338]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.338]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.338]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.338]             base::names(...future.oldOptions))
[17:02:30.338]     }
[17:02:30.338]     if (FALSE) {
[17:02:30.338]     }
[17:02:30.338]     else {
[17:02:30.338]         if (TRUE) {
[17:02:30.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.338]                 open = "w")
[17:02:30.338]         }
[17:02:30.338]         else {
[17:02:30.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.338]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.338]         }
[17:02:30.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.338]             base::sink(type = "output", split = FALSE)
[17:02:30.338]             base::close(...future.stdout)
[17:02:30.338]         }, add = TRUE)
[17:02:30.338]     }
[17:02:30.338]     ...future.frame <- base::sys.nframe()
[17:02:30.338]     ...future.conditions <- base::list()
[17:02:30.338]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.338]     if (FALSE) {
[17:02:30.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.338]     }
[17:02:30.338]     ...future.result <- base::tryCatch({
[17:02:30.338]         base::withCallingHandlers({
[17:02:30.338]             ...future.value <- base::withVisible(base::local({
[17:02:30.338]                 ...future.makeSendCondition <- base::local({
[17:02:30.338]                   sendCondition <- NULL
[17:02:30.338]                   function(frame = 1L) {
[17:02:30.338]                     if (is.function(sendCondition)) 
[17:02:30.338]                       return(sendCondition)
[17:02:30.338]                     ns <- getNamespace("parallel")
[17:02:30.338]                     if (exists("sendData", mode = "function", 
[17:02:30.338]                       envir = ns)) {
[17:02:30.338]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:30.338]                         envir = ns)
[17:02:30.338]                       envir <- sys.frame(frame)
[17:02:30.338]                       master <- NULL
[17:02:30.338]                       while (!identical(envir, .GlobalEnv) && 
[17:02:30.338]                         !identical(envir, emptyenv())) {
[17:02:30.338]                         if (exists("master", mode = "list", envir = envir, 
[17:02:30.338]                           inherits = FALSE)) {
[17:02:30.338]                           master <- get("master", mode = "list", 
[17:02:30.338]                             envir = envir, inherits = FALSE)
[17:02:30.338]                           if (inherits(master, c("SOCKnode", 
[17:02:30.338]                             "SOCK0node"))) {
[17:02:30.338]                             sendCondition <<- function(cond) {
[17:02:30.338]                               data <- list(type = "VALUE", value = cond, 
[17:02:30.338]                                 success = TRUE)
[17:02:30.338]                               parallel_sendData(master, data)
[17:02:30.338]                             }
[17:02:30.338]                             return(sendCondition)
[17:02:30.338]                           }
[17:02:30.338]                         }
[17:02:30.338]                         frame <- frame + 1L
[17:02:30.338]                         envir <- sys.frame(frame)
[17:02:30.338]                       }
[17:02:30.338]                     }
[17:02:30.338]                     sendCondition <<- function(cond) NULL
[17:02:30.338]                   }
[17:02:30.338]                 })
[17:02:30.338]                 withCallingHandlers({
[17:02:30.338]                   2
[17:02:30.338]                 }, immediateCondition = function(cond) {
[17:02:30.338]                   sendCondition <- ...future.makeSendCondition()
[17:02:30.338]                   sendCondition(cond)
[17:02:30.338]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.338]                   {
[17:02:30.338]                     inherits <- base::inherits
[17:02:30.338]                     invokeRestart <- base::invokeRestart
[17:02:30.338]                     is.null <- base::is.null
[17:02:30.338]                     muffled <- FALSE
[17:02:30.338]                     if (inherits(cond, "message")) {
[17:02:30.338]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.338]                       if (muffled) 
[17:02:30.338]                         invokeRestart("muffleMessage")
[17:02:30.338]                     }
[17:02:30.338]                     else if (inherits(cond, "warning")) {
[17:02:30.338]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.338]                       if (muffled) 
[17:02:30.338]                         invokeRestart("muffleWarning")
[17:02:30.338]                     }
[17:02:30.338]                     else if (inherits(cond, "condition")) {
[17:02:30.338]                       if (!is.null(pattern)) {
[17:02:30.338]                         computeRestarts <- base::computeRestarts
[17:02:30.338]                         grepl <- base::grepl
[17:02:30.338]                         restarts <- computeRestarts(cond)
[17:02:30.338]                         for (restart in restarts) {
[17:02:30.338]                           name <- restart$name
[17:02:30.338]                           if (is.null(name)) 
[17:02:30.338]                             next
[17:02:30.338]                           if (!grepl(pattern, name)) 
[17:02:30.338]                             next
[17:02:30.338]                           invokeRestart(restart)
[17:02:30.338]                           muffled <- TRUE
[17:02:30.338]                           break
[17:02:30.338]                         }
[17:02:30.338]                       }
[17:02:30.338]                     }
[17:02:30.338]                     invisible(muffled)
[17:02:30.338]                   }
[17:02:30.338]                   muffleCondition(cond)
[17:02:30.338]                 })
[17:02:30.338]             }))
[17:02:30.338]             future::FutureResult(value = ...future.value$value, 
[17:02:30.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.338]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.338]                     ...future.globalenv.names))
[17:02:30.338]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.338]         }, condition = base::local({
[17:02:30.338]             c <- base::c
[17:02:30.338]             inherits <- base::inherits
[17:02:30.338]             invokeRestart <- base::invokeRestart
[17:02:30.338]             length <- base::length
[17:02:30.338]             list <- base::list
[17:02:30.338]             seq.int <- base::seq.int
[17:02:30.338]             signalCondition <- base::signalCondition
[17:02:30.338]             sys.calls <- base::sys.calls
[17:02:30.338]             `[[` <- base::`[[`
[17:02:30.338]             `+` <- base::`+`
[17:02:30.338]             `<<-` <- base::`<<-`
[17:02:30.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.338]                   3L)]
[17:02:30.338]             }
[17:02:30.338]             function(cond) {
[17:02:30.338]                 is_error <- inherits(cond, "error")
[17:02:30.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.338]                   NULL)
[17:02:30.338]                 if (is_error) {
[17:02:30.338]                   sessionInformation <- function() {
[17:02:30.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.338]                       search = base::search(), system = base::Sys.info())
[17:02:30.338]                   }
[17:02:30.338]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.338]                     cond$call), session = sessionInformation(), 
[17:02:30.338]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.338]                   signalCondition(cond)
[17:02:30.338]                 }
[17:02:30.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.338]                 "immediateCondition"))) {
[17:02:30.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.338]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.338]                   if (TRUE && !signal) {
[17:02:30.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.338]                     {
[17:02:30.338]                       inherits <- base::inherits
[17:02:30.338]                       invokeRestart <- base::invokeRestart
[17:02:30.338]                       is.null <- base::is.null
[17:02:30.338]                       muffled <- FALSE
[17:02:30.338]                       if (inherits(cond, "message")) {
[17:02:30.338]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.338]                         if (muffled) 
[17:02:30.338]                           invokeRestart("muffleMessage")
[17:02:30.338]                       }
[17:02:30.338]                       else if (inherits(cond, "warning")) {
[17:02:30.338]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.338]                         if (muffled) 
[17:02:30.338]                           invokeRestart("muffleWarning")
[17:02:30.338]                       }
[17:02:30.338]                       else if (inherits(cond, "condition")) {
[17:02:30.338]                         if (!is.null(pattern)) {
[17:02:30.338]                           computeRestarts <- base::computeRestarts
[17:02:30.338]                           grepl <- base::grepl
[17:02:30.338]                           restarts <- computeRestarts(cond)
[17:02:30.338]                           for (restart in restarts) {
[17:02:30.338]                             name <- restart$name
[17:02:30.338]                             if (is.null(name)) 
[17:02:30.338]                               next
[17:02:30.338]                             if (!grepl(pattern, name)) 
[17:02:30.338]                               next
[17:02:30.338]                             invokeRestart(restart)
[17:02:30.338]                             muffled <- TRUE
[17:02:30.338]                             break
[17:02:30.338]                           }
[17:02:30.338]                         }
[17:02:30.338]                       }
[17:02:30.338]                       invisible(muffled)
[17:02:30.338]                     }
[17:02:30.338]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.338]                   }
[17:02:30.338]                 }
[17:02:30.338]                 else {
[17:02:30.338]                   if (TRUE) {
[17:02:30.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.338]                     {
[17:02:30.338]                       inherits <- base::inherits
[17:02:30.338]                       invokeRestart <- base::invokeRestart
[17:02:30.338]                       is.null <- base::is.null
[17:02:30.338]                       muffled <- FALSE
[17:02:30.338]                       if (inherits(cond, "message")) {
[17:02:30.338]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.338]                         if (muffled) 
[17:02:30.338]                           invokeRestart("muffleMessage")
[17:02:30.338]                       }
[17:02:30.338]                       else if (inherits(cond, "warning")) {
[17:02:30.338]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.338]                         if (muffled) 
[17:02:30.338]                           invokeRestart("muffleWarning")
[17:02:30.338]                       }
[17:02:30.338]                       else if (inherits(cond, "condition")) {
[17:02:30.338]                         if (!is.null(pattern)) {
[17:02:30.338]                           computeRestarts <- base::computeRestarts
[17:02:30.338]                           grepl <- base::grepl
[17:02:30.338]                           restarts <- computeRestarts(cond)
[17:02:30.338]                           for (restart in restarts) {
[17:02:30.338]                             name <- restart$name
[17:02:30.338]                             if (is.null(name)) 
[17:02:30.338]                               next
[17:02:30.338]                             if (!grepl(pattern, name)) 
[17:02:30.338]                               next
[17:02:30.338]                             invokeRestart(restart)
[17:02:30.338]                             muffled <- TRUE
[17:02:30.338]                             break
[17:02:30.338]                           }
[17:02:30.338]                         }
[17:02:30.338]                       }
[17:02:30.338]                       invisible(muffled)
[17:02:30.338]                     }
[17:02:30.338]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.338]                   }
[17:02:30.338]                 }
[17:02:30.338]             }
[17:02:30.338]         }))
[17:02:30.338]     }, error = function(ex) {
[17:02:30.338]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.338]                 ...future.rng), started = ...future.startTime, 
[17:02:30.338]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.338]             version = "1.8"), class = "FutureResult")
[17:02:30.338]     }, finally = {
[17:02:30.338]         if (!identical(...future.workdir, getwd())) 
[17:02:30.338]             setwd(...future.workdir)
[17:02:30.338]         {
[17:02:30.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.338]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.338]             }
[17:02:30.338]             base::options(...future.oldOptions)
[17:02:30.338]             if (.Platform$OS.type == "windows") {
[17:02:30.338]                 old_names <- names(...future.oldEnvVars)
[17:02:30.338]                 envs <- base::Sys.getenv()
[17:02:30.338]                 names <- names(envs)
[17:02:30.338]                 common <- intersect(names, old_names)
[17:02:30.338]                 added <- setdiff(names, old_names)
[17:02:30.338]                 removed <- setdiff(old_names, names)
[17:02:30.338]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.338]                   envs[common]]
[17:02:30.338]                 NAMES <- toupper(changed)
[17:02:30.338]                 args <- list()
[17:02:30.338]                 for (kk in seq_along(NAMES)) {
[17:02:30.338]                   name <- changed[[kk]]
[17:02:30.338]                   NAME <- NAMES[[kk]]
[17:02:30.338]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.338]                     next
[17:02:30.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.338]                 }
[17:02:30.338]                 NAMES <- toupper(added)
[17:02:30.338]                 for (kk in seq_along(NAMES)) {
[17:02:30.338]                   name <- added[[kk]]
[17:02:30.338]                   NAME <- NAMES[[kk]]
[17:02:30.338]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.338]                     next
[17:02:30.338]                   args[[name]] <- ""
[17:02:30.338]                 }
[17:02:30.338]                 NAMES <- toupper(removed)
[17:02:30.338]                 for (kk in seq_along(NAMES)) {
[17:02:30.338]                   name <- removed[[kk]]
[17:02:30.338]                   NAME <- NAMES[[kk]]
[17:02:30.338]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.338]                     next
[17:02:30.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.338]                 }
[17:02:30.338]                 if (length(args) > 0) 
[17:02:30.338]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.338]             }
[17:02:30.338]             else {
[17:02:30.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.338]             }
[17:02:30.338]             {
[17:02:30.338]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.338]                   0L) {
[17:02:30.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.338]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.338]                   base::options(opts)
[17:02:30.338]                 }
[17:02:30.338]                 {
[17:02:30.338]                   {
[17:02:30.338]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.338]                     NULL
[17:02:30.338]                   }
[17:02:30.338]                   options(future.plan = NULL)
[17:02:30.338]                   if (is.na(NA_character_)) 
[17:02:30.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.338]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.338]                     .init = FALSE)
[17:02:30.338]                 }
[17:02:30.338]             }
[17:02:30.338]         }
[17:02:30.338]     })
[17:02:30.338]     if (TRUE) {
[17:02:30.338]         base::sink(type = "output", split = FALSE)
[17:02:30.338]         if (TRUE) {
[17:02:30.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.338]         }
[17:02:30.338]         else {
[17:02:30.338]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.338]         }
[17:02:30.338]         base::close(...future.stdout)
[17:02:30.338]         ...future.stdout <- NULL
[17:02:30.338]     }
[17:02:30.338]     ...future.result$conditions <- ...future.conditions
[17:02:30.338]     ...future.result$finished <- base::Sys.time()
[17:02:30.338]     ...future.result
[17:02:30.338] }
[17:02:30.341] MultisessionFuture started
[17:02:30.341] - Launch lazy future ... done
[17:02:30.341] run() for ‘MultisessionFuture’ ... done
[17:02:30.341] getGlobalsAndPackages() ...
[17:02:30.341] Searching for globals...
[17:02:30.342] 
[17:02:30.342] Searching for globals ... DONE
[17:02:30.342] - globals: [0] <none>
[17:02:30.342] getGlobalsAndPackages() ... DONE
[17:02:30.342] run() for ‘Future’ ...
[17:02:30.342] - state: ‘created’
[17:02:30.342] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.356] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.356] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:30.356]   - Field: ‘node’
[17:02:30.356]   - Field: ‘label’
[17:02:30.356]   - Field: ‘local’
[17:02:30.356]   - Field: ‘owner’
[17:02:30.356]   - Field: ‘envir’
[17:02:30.357]   - Field: ‘workers’
[17:02:30.357]   - Field: ‘packages’
[17:02:30.357]   - Field: ‘gc’
[17:02:30.357]   - Field: ‘conditions’
[17:02:30.357]   - Field: ‘persistent’
[17:02:30.357]   - Field: ‘expr’
[17:02:30.357]   - Field: ‘uuid’
[17:02:30.357]   - Field: ‘seed’
[17:02:30.357]   - Field: ‘version’
[17:02:30.357]   - Field: ‘result’
[17:02:30.357]   - Field: ‘asynchronous’
[17:02:30.357]   - Field: ‘calls’
[17:02:30.358]   - Field: ‘globals’
[17:02:30.358]   - Field: ‘stdout’
[17:02:30.358]   - Field: ‘earlySignal’
[17:02:30.358]   - Field: ‘lazy’
[17:02:30.358]   - Field: ‘state’
[17:02:30.358] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:30.358] - Launch lazy future ...
[17:02:30.358] Packages needed by the future expression (n = 0): <none>
[17:02:30.358] Packages needed by future strategies (n = 0): <none>
[17:02:30.359] {
[17:02:30.359]     {
[17:02:30.359]         {
[17:02:30.359]             ...future.startTime <- base::Sys.time()
[17:02:30.359]             {
[17:02:30.359]                 {
[17:02:30.359]                   {
[17:02:30.359]                     {
[17:02:30.359]                       base::local({
[17:02:30.359]                         has_future <- base::requireNamespace("future", 
[17:02:30.359]                           quietly = TRUE)
[17:02:30.359]                         if (has_future) {
[17:02:30.359]                           ns <- base::getNamespace("future")
[17:02:30.359]                           version <- ns[[".package"]][["version"]]
[17:02:30.359]                           if (is.null(version)) 
[17:02:30.359]                             version <- utils::packageVersion("future")
[17:02:30.359]                         }
[17:02:30.359]                         else {
[17:02:30.359]                           version <- NULL
[17:02:30.359]                         }
[17:02:30.359]                         if (!has_future || version < "1.8.0") {
[17:02:30.359]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.359]                             "", base::R.version$version.string), 
[17:02:30.359]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.359]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.359]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.359]                               "release", "version")], collapse = " "), 
[17:02:30.359]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.359]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.359]                             info)
[17:02:30.359]                           info <- base::paste(info, collapse = "; ")
[17:02:30.359]                           if (!has_future) {
[17:02:30.359]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.359]                               info)
[17:02:30.359]                           }
[17:02:30.359]                           else {
[17:02:30.359]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.359]                               info, version)
[17:02:30.359]                           }
[17:02:30.359]                           base::stop(msg)
[17:02:30.359]                         }
[17:02:30.359]                       })
[17:02:30.359]                     }
[17:02:30.359]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.359]                     base::options(mc.cores = 1L)
[17:02:30.359]                   }
[17:02:30.359]                   ...future.strategy.old <- future::plan("list")
[17:02:30.359]                   options(future.plan = NULL)
[17:02:30.359]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.359]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.359]                 }
[17:02:30.359]                 ...future.workdir <- getwd()
[17:02:30.359]             }
[17:02:30.359]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.359]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.359]         }
[17:02:30.359]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.359]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.359]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.359]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.359]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.359]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.359]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.359]             base::names(...future.oldOptions))
[17:02:30.359]     }
[17:02:30.359]     if (FALSE) {
[17:02:30.359]     }
[17:02:30.359]     else {
[17:02:30.359]         if (TRUE) {
[17:02:30.359]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.359]                 open = "w")
[17:02:30.359]         }
[17:02:30.359]         else {
[17:02:30.359]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.359]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.359]         }
[17:02:30.359]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.359]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.359]             base::sink(type = "output", split = FALSE)
[17:02:30.359]             base::close(...future.stdout)
[17:02:30.359]         }, add = TRUE)
[17:02:30.359]     }
[17:02:30.359]     ...future.frame <- base::sys.nframe()
[17:02:30.359]     ...future.conditions <- base::list()
[17:02:30.359]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.359]     if (FALSE) {
[17:02:30.359]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.359]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.359]     }
[17:02:30.359]     ...future.result <- base::tryCatch({
[17:02:30.359]         base::withCallingHandlers({
[17:02:30.359]             ...future.value <- base::withVisible(base::local({
[17:02:30.359]                 ...future.makeSendCondition <- base::local({
[17:02:30.359]                   sendCondition <- NULL
[17:02:30.359]                   function(frame = 1L) {
[17:02:30.359]                     if (is.function(sendCondition)) 
[17:02:30.359]                       return(sendCondition)
[17:02:30.359]                     ns <- getNamespace("parallel")
[17:02:30.359]                     if (exists("sendData", mode = "function", 
[17:02:30.359]                       envir = ns)) {
[17:02:30.359]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:30.359]                         envir = ns)
[17:02:30.359]                       envir <- sys.frame(frame)
[17:02:30.359]                       master <- NULL
[17:02:30.359]                       while (!identical(envir, .GlobalEnv) && 
[17:02:30.359]                         !identical(envir, emptyenv())) {
[17:02:30.359]                         if (exists("master", mode = "list", envir = envir, 
[17:02:30.359]                           inherits = FALSE)) {
[17:02:30.359]                           master <- get("master", mode = "list", 
[17:02:30.359]                             envir = envir, inherits = FALSE)
[17:02:30.359]                           if (inherits(master, c("SOCKnode", 
[17:02:30.359]                             "SOCK0node"))) {
[17:02:30.359]                             sendCondition <<- function(cond) {
[17:02:30.359]                               data <- list(type = "VALUE", value = cond, 
[17:02:30.359]                                 success = TRUE)
[17:02:30.359]                               parallel_sendData(master, data)
[17:02:30.359]                             }
[17:02:30.359]                             return(sendCondition)
[17:02:30.359]                           }
[17:02:30.359]                         }
[17:02:30.359]                         frame <- frame + 1L
[17:02:30.359]                         envir <- sys.frame(frame)
[17:02:30.359]                       }
[17:02:30.359]                     }
[17:02:30.359]                     sendCondition <<- function(cond) NULL
[17:02:30.359]                   }
[17:02:30.359]                 })
[17:02:30.359]                 withCallingHandlers({
[17:02:30.359]                   NULL
[17:02:30.359]                 }, immediateCondition = function(cond) {
[17:02:30.359]                   sendCondition <- ...future.makeSendCondition()
[17:02:30.359]                   sendCondition(cond)
[17:02:30.359]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.359]                   {
[17:02:30.359]                     inherits <- base::inherits
[17:02:30.359]                     invokeRestart <- base::invokeRestart
[17:02:30.359]                     is.null <- base::is.null
[17:02:30.359]                     muffled <- FALSE
[17:02:30.359]                     if (inherits(cond, "message")) {
[17:02:30.359]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.359]                       if (muffled) 
[17:02:30.359]                         invokeRestart("muffleMessage")
[17:02:30.359]                     }
[17:02:30.359]                     else if (inherits(cond, "warning")) {
[17:02:30.359]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.359]                       if (muffled) 
[17:02:30.359]                         invokeRestart("muffleWarning")
[17:02:30.359]                     }
[17:02:30.359]                     else if (inherits(cond, "condition")) {
[17:02:30.359]                       if (!is.null(pattern)) {
[17:02:30.359]                         computeRestarts <- base::computeRestarts
[17:02:30.359]                         grepl <- base::grepl
[17:02:30.359]                         restarts <- computeRestarts(cond)
[17:02:30.359]                         for (restart in restarts) {
[17:02:30.359]                           name <- restart$name
[17:02:30.359]                           if (is.null(name)) 
[17:02:30.359]                             next
[17:02:30.359]                           if (!grepl(pattern, name)) 
[17:02:30.359]                             next
[17:02:30.359]                           invokeRestart(restart)
[17:02:30.359]                           muffled <- TRUE
[17:02:30.359]                           break
[17:02:30.359]                         }
[17:02:30.359]                       }
[17:02:30.359]                     }
[17:02:30.359]                     invisible(muffled)
[17:02:30.359]                   }
[17:02:30.359]                   muffleCondition(cond)
[17:02:30.359]                 })
[17:02:30.359]             }))
[17:02:30.359]             future::FutureResult(value = ...future.value$value, 
[17:02:30.359]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.359]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.359]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.359]                     ...future.globalenv.names))
[17:02:30.359]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.359]         }, condition = base::local({
[17:02:30.359]             c <- base::c
[17:02:30.359]             inherits <- base::inherits
[17:02:30.359]             invokeRestart <- base::invokeRestart
[17:02:30.359]             length <- base::length
[17:02:30.359]             list <- base::list
[17:02:30.359]             seq.int <- base::seq.int
[17:02:30.359]             signalCondition <- base::signalCondition
[17:02:30.359]             sys.calls <- base::sys.calls
[17:02:30.359]             `[[` <- base::`[[`
[17:02:30.359]             `+` <- base::`+`
[17:02:30.359]             `<<-` <- base::`<<-`
[17:02:30.359]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.359]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.359]                   3L)]
[17:02:30.359]             }
[17:02:30.359]             function(cond) {
[17:02:30.359]                 is_error <- inherits(cond, "error")
[17:02:30.359]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.359]                   NULL)
[17:02:30.359]                 if (is_error) {
[17:02:30.359]                   sessionInformation <- function() {
[17:02:30.359]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.359]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.359]                       search = base::search(), system = base::Sys.info())
[17:02:30.359]                   }
[17:02:30.359]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.359]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.359]                     cond$call), session = sessionInformation(), 
[17:02:30.359]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.359]                   signalCondition(cond)
[17:02:30.359]                 }
[17:02:30.359]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.359]                 "immediateCondition"))) {
[17:02:30.359]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.359]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.359]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.359]                   if (TRUE && !signal) {
[17:02:30.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.359]                     {
[17:02:30.359]                       inherits <- base::inherits
[17:02:30.359]                       invokeRestart <- base::invokeRestart
[17:02:30.359]                       is.null <- base::is.null
[17:02:30.359]                       muffled <- FALSE
[17:02:30.359]                       if (inherits(cond, "message")) {
[17:02:30.359]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.359]                         if (muffled) 
[17:02:30.359]                           invokeRestart("muffleMessage")
[17:02:30.359]                       }
[17:02:30.359]                       else if (inherits(cond, "warning")) {
[17:02:30.359]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.359]                         if (muffled) 
[17:02:30.359]                           invokeRestart("muffleWarning")
[17:02:30.359]                       }
[17:02:30.359]                       else if (inherits(cond, "condition")) {
[17:02:30.359]                         if (!is.null(pattern)) {
[17:02:30.359]                           computeRestarts <- base::computeRestarts
[17:02:30.359]                           grepl <- base::grepl
[17:02:30.359]                           restarts <- computeRestarts(cond)
[17:02:30.359]                           for (restart in restarts) {
[17:02:30.359]                             name <- restart$name
[17:02:30.359]                             if (is.null(name)) 
[17:02:30.359]                               next
[17:02:30.359]                             if (!grepl(pattern, name)) 
[17:02:30.359]                               next
[17:02:30.359]                             invokeRestart(restart)
[17:02:30.359]                             muffled <- TRUE
[17:02:30.359]                             break
[17:02:30.359]                           }
[17:02:30.359]                         }
[17:02:30.359]                       }
[17:02:30.359]                       invisible(muffled)
[17:02:30.359]                     }
[17:02:30.359]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.359]                   }
[17:02:30.359]                 }
[17:02:30.359]                 else {
[17:02:30.359]                   if (TRUE) {
[17:02:30.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.359]                     {
[17:02:30.359]                       inherits <- base::inherits
[17:02:30.359]                       invokeRestart <- base::invokeRestart
[17:02:30.359]                       is.null <- base::is.null
[17:02:30.359]                       muffled <- FALSE
[17:02:30.359]                       if (inherits(cond, "message")) {
[17:02:30.359]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.359]                         if (muffled) 
[17:02:30.359]                           invokeRestart("muffleMessage")
[17:02:30.359]                       }
[17:02:30.359]                       else if (inherits(cond, "warning")) {
[17:02:30.359]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.359]                         if (muffled) 
[17:02:30.359]                           invokeRestart("muffleWarning")
[17:02:30.359]                       }
[17:02:30.359]                       else if (inherits(cond, "condition")) {
[17:02:30.359]                         if (!is.null(pattern)) {
[17:02:30.359]                           computeRestarts <- base::computeRestarts
[17:02:30.359]                           grepl <- base::grepl
[17:02:30.359]                           restarts <- computeRestarts(cond)
[17:02:30.359]                           for (restart in restarts) {
[17:02:30.359]                             name <- restart$name
[17:02:30.359]                             if (is.null(name)) 
[17:02:30.359]                               next
[17:02:30.359]                             if (!grepl(pattern, name)) 
[17:02:30.359]                               next
[17:02:30.359]                             invokeRestart(restart)
[17:02:30.359]                             muffled <- TRUE
[17:02:30.359]                             break
[17:02:30.359]                           }
[17:02:30.359]                         }
[17:02:30.359]                       }
[17:02:30.359]                       invisible(muffled)
[17:02:30.359]                     }
[17:02:30.359]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.359]                   }
[17:02:30.359]                 }
[17:02:30.359]             }
[17:02:30.359]         }))
[17:02:30.359]     }, error = function(ex) {
[17:02:30.359]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.359]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.359]                 ...future.rng), started = ...future.startTime, 
[17:02:30.359]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.359]             version = "1.8"), class = "FutureResult")
[17:02:30.359]     }, finally = {
[17:02:30.359]         if (!identical(...future.workdir, getwd())) 
[17:02:30.359]             setwd(...future.workdir)
[17:02:30.359]         {
[17:02:30.359]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.359]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.359]             }
[17:02:30.359]             base::options(...future.oldOptions)
[17:02:30.359]             if (.Platform$OS.type == "windows") {
[17:02:30.359]                 old_names <- names(...future.oldEnvVars)
[17:02:30.359]                 envs <- base::Sys.getenv()
[17:02:30.359]                 names <- names(envs)
[17:02:30.359]                 common <- intersect(names, old_names)
[17:02:30.359]                 added <- setdiff(names, old_names)
[17:02:30.359]                 removed <- setdiff(old_names, names)
[17:02:30.359]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.359]                   envs[common]]
[17:02:30.359]                 NAMES <- toupper(changed)
[17:02:30.359]                 args <- list()
[17:02:30.359]                 for (kk in seq_along(NAMES)) {
[17:02:30.359]                   name <- changed[[kk]]
[17:02:30.359]                   NAME <- NAMES[[kk]]
[17:02:30.359]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.359]                     next
[17:02:30.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.359]                 }
[17:02:30.359]                 NAMES <- toupper(added)
[17:02:30.359]                 for (kk in seq_along(NAMES)) {
[17:02:30.359]                   name <- added[[kk]]
[17:02:30.359]                   NAME <- NAMES[[kk]]
[17:02:30.359]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.359]                     next
[17:02:30.359]                   args[[name]] <- ""
[17:02:30.359]                 }
[17:02:30.359]                 NAMES <- toupper(removed)
[17:02:30.359]                 for (kk in seq_along(NAMES)) {
[17:02:30.359]                   name <- removed[[kk]]
[17:02:30.359]                   NAME <- NAMES[[kk]]
[17:02:30.359]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.359]                     next
[17:02:30.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.359]                 }
[17:02:30.359]                 if (length(args) > 0) 
[17:02:30.359]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.359]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.359]             }
[17:02:30.359]             else {
[17:02:30.359]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.359]             }
[17:02:30.359]             {
[17:02:30.359]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.359]                   0L) {
[17:02:30.359]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.359]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.359]                   base::options(opts)
[17:02:30.359]                 }
[17:02:30.359]                 {
[17:02:30.359]                   {
[17:02:30.359]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.359]                     NULL
[17:02:30.359]                   }
[17:02:30.359]                   options(future.plan = NULL)
[17:02:30.359]                   if (is.na(NA_character_)) 
[17:02:30.359]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.359]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.359]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.359]                     .init = FALSE)
[17:02:30.359]                 }
[17:02:30.359]             }
[17:02:30.359]         }
[17:02:30.359]     })
[17:02:30.359]     if (TRUE) {
[17:02:30.359]         base::sink(type = "output", split = FALSE)
[17:02:30.359]         if (TRUE) {
[17:02:30.359]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.359]         }
[17:02:30.359]         else {
[17:02:30.359]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.359]         }
[17:02:30.359]         base::close(...future.stdout)
[17:02:30.359]         ...future.stdout <- NULL
[17:02:30.359]     }
[17:02:30.359]     ...future.result$conditions <- ...future.conditions
[17:02:30.359]     ...future.result$finished <- base::Sys.time()
[17:02:30.359]     ...future.result
[17:02:30.359] }
[17:02:30.362] MultisessionFuture started
[17:02:30.362] - Launch lazy future ... done
[17:02:30.362] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c749d85420> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c749502848> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c749d85420> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c749502848> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:02:30.368] receiveMessageFromWorker() for ClusterFuture ...
[17:02:30.368] - Validating connection of MultisessionFuture
[17:02:30.368] - received message: FutureResult
[17:02:30.369] - Received FutureResult
[17:02:30.369] - Erased future from FutureRegistry
[17:02:30.369] result() for ClusterFuture ...
[17:02:30.369] - result already collected: FutureResult
[17:02:30.369] result() for ClusterFuture ... done
[17:02:30.369] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:30.369] receiveMessageFromWorker() for ClusterFuture ...
[17:02:30.369] - Validating connection of MultisessionFuture
[17:02:30.370] - received message: FutureResult
[17:02:30.370] - Received FutureResult
[17:02:30.370] - Erased future from FutureRegistry
[17:02:30.370] result() for ClusterFuture ...
[17:02:30.370] - result already collected: FutureResult
[17:02:30.370] result() for ClusterFuture ... done
[17:02:30.370] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:30.372] resolve() on list ...
[17:02:30.372]  recursive: 0
[17:02:30.372]  length: 6
[17:02:30.372]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:30.372] signalConditionsASAP(numeric, pos=1) ...
[17:02:30.372] - nx: 6
[17:02:30.372] - relay: TRUE
[17:02:30.372] - stdout: TRUE
[17:02:30.372] - signal: TRUE
[17:02:30.373] - resignal: FALSE
[17:02:30.373] - force: TRUE
[17:02:30.373] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.373] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.373]  - until=2
[17:02:30.373]  - relaying element #2
[17:02:30.373] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.373] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.373] signalConditionsASAP(NULL, pos=1) ... done
[17:02:30.373]  length: 5 (resolved future 1)
[17:02:30.373] Future #2
[17:02:30.373] result() for ClusterFuture ...
[17:02:30.374] - result already collected: FutureResult
[17:02:30.374] result() for ClusterFuture ... done
[17:02:30.374] result() for ClusterFuture ...
[17:02:30.374] - result already collected: FutureResult
[17:02:30.374] result() for ClusterFuture ... done
[17:02:30.374] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:30.374] - nx: 6
[17:02:30.374] - relay: TRUE
[17:02:30.374] - stdout: TRUE
[17:02:30.374] - signal: TRUE
[17:02:30.374] - resignal: FALSE
[17:02:30.374] - force: TRUE
[17:02:30.375] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.375] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.375]  - until=2
[17:02:30.375]  - relaying element #2
[17:02:30.375] result() for ClusterFuture ...
[17:02:30.375] - result already collected: FutureResult
[17:02:30.375] result() for ClusterFuture ... done
[17:02:30.375] result() for ClusterFuture ...
[17:02:30.375] - result already collected: FutureResult
[17:02:30.375] result() for ClusterFuture ... done
[17:02:30.375] result() for ClusterFuture ...
[17:02:30.376] - result already collected: FutureResult
[17:02:30.376] result() for ClusterFuture ... done
[17:02:30.376] result() for ClusterFuture ...
[17:02:30.376] - result already collected: FutureResult
[17:02:30.376] result() for ClusterFuture ... done
[17:02:30.376] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.376] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.376] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:30.376]  length: 4 (resolved future 2)
[17:02:30.376] Future #3
[17:02:30.376] result() for ClusterFuture ...
[17:02:30.377] - result already collected: FutureResult
[17:02:30.377] result() for ClusterFuture ... done
[17:02:30.377] result() for ClusterFuture ...
[17:02:30.377] - result already collected: FutureResult
[17:02:30.377] result() for ClusterFuture ... done
[17:02:30.377] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:30.377] - nx: 6
[17:02:30.377] - relay: TRUE
[17:02:30.377] - stdout: TRUE
[17:02:30.377] - signal: TRUE
[17:02:30.377] - resignal: FALSE
[17:02:30.377] - force: TRUE
[17:02:30.378] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.378] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.378]  - until=3
[17:02:30.378]  - relaying element #3
[17:02:30.378] result() for ClusterFuture ...
[17:02:30.378] - result already collected: FutureResult
[17:02:30.378] result() for ClusterFuture ... done
[17:02:30.378] result() for ClusterFuture ...
[17:02:30.378] - result already collected: FutureResult
[17:02:30.378] result() for ClusterFuture ... done
[17:02:30.378] result() for ClusterFuture ...
[17:02:30.378] - result already collected: FutureResult
[17:02:30.379] result() for ClusterFuture ... done
[17:02:30.379] result() for ClusterFuture ...
[17:02:30.379] - result already collected: FutureResult
[17:02:30.379] result() for ClusterFuture ... done
[17:02:30.379] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.379] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.379] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:30.379]  length: 3 (resolved future 3)
[17:02:30.379] signalConditionsASAP(NULL, pos=4) ...
[17:02:30.379] - nx: 6
[17:02:30.379] - relay: TRUE
[17:02:30.379] - stdout: TRUE
[17:02:30.380] - signal: TRUE
[17:02:30.380] - resignal: FALSE
[17:02:30.380] - force: TRUE
[17:02:30.380] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.380] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.380]  - until=5
[17:02:30.380]  - relaying element #5
[17:02:30.380] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:30.380] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.380] signalConditionsASAP(NULL, pos=4) ... done
[17:02:30.380]  length: 2 (resolved future 4)
[17:02:30.380] signalConditionsASAP(NULL, pos=5) ...
[17:02:30.381] - nx: 6
[17:02:30.381] - relay: TRUE
[17:02:30.381] - stdout: TRUE
[17:02:30.381] - signal: TRUE
[17:02:30.381] - resignal: FALSE
[17:02:30.381] - force: TRUE
[17:02:30.381] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:30.381] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.381]  - until=6
[17:02:30.381]  - relaying element #6
[17:02:30.381] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:30.381] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.382] signalConditionsASAP(NULL, pos=5) ... done
[17:02:30.382]  length: 1 (resolved future 5)
[17:02:30.382] signalConditionsASAP(numeric, pos=6) ...
[17:02:30.382] - nx: 6
[17:02:30.382] - relay: TRUE
[17:02:30.382] - stdout: TRUE
[17:02:30.382] - signal: TRUE
[17:02:30.382] - resignal: FALSE
[17:02:30.382] - force: TRUE
[17:02:30.382] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:30.382] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.382]  - until=6
[17:02:30.382] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.383] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.383] signalConditionsASAP(numeric, pos=6) ... done
[17:02:30.383]  length: 0 (resolved future 6)
[17:02:30.383] Relaying remaining futures
[17:02:30.383] signalConditionsASAP(NULL, pos=0) ...
[17:02:30.383] - nx: 6
[17:02:30.383] - relay: TRUE
[17:02:30.383] - stdout: TRUE
[17:02:30.383] - signal: TRUE
[17:02:30.383] - resignal: FALSE
[17:02:30.383] - force: TRUE
[17:02:30.383] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.384] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:30.384] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.384] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.384] signalConditionsASAP(NULL, pos=0) ... done
[17:02:30.384] resolve() on list ... DONE
[17:02:30.384] result() for ClusterFuture ...
[17:02:30.384] - result already collected: FutureResult
[17:02:30.384] result() for ClusterFuture ... done
[17:02:30.384] result() for ClusterFuture ...
[17:02:30.384] - result already collected: FutureResult
[17:02:30.384] result() for ClusterFuture ... done
[17:02:30.385] result() for ClusterFuture ...
[17:02:30.385] - result already collected: FutureResult
[17:02:30.385] result() for ClusterFuture ... done
[17:02:30.385] result() for ClusterFuture ...
[17:02:30.385] - result already collected: FutureResult
[17:02:30.385] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:02:30.388] getGlobalsAndPackages() ...
[17:02:30.388] Searching for globals...
[17:02:30.388] 
[17:02:30.388] Searching for globals ... DONE
[17:02:30.389] - globals: [0] <none>
[17:02:30.389] getGlobalsAndPackages() ... DONE
[17:02:30.389] run() for ‘Future’ ...
[17:02:30.389] - state: ‘created’
[17:02:30.389] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.403] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.403] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:30.403]   - Field: ‘node’
[17:02:30.403]   - Field: ‘label’
[17:02:30.403]   - Field: ‘local’
[17:02:30.403]   - Field: ‘owner’
[17:02:30.404]   - Field: ‘envir’
[17:02:30.404]   - Field: ‘workers’
[17:02:30.404]   - Field: ‘packages’
[17:02:30.404]   - Field: ‘gc’
[17:02:30.404]   - Field: ‘conditions’
[17:02:30.404]   - Field: ‘persistent’
[17:02:30.404]   - Field: ‘expr’
[17:02:30.404]   - Field: ‘uuid’
[17:02:30.404]   - Field: ‘seed’
[17:02:30.404]   - Field: ‘version’
[17:02:30.404]   - Field: ‘result’
[17:02:30.404]   - Field: ‘asynchronous’
[17:02:30.405]   - Field: ‘calls’
[17:02:30.405]   - Field: ‘globals’
[17:02:30.405]   - Field: ‘stdout’
[17:02:30.405]   - Field: ‘earlySignal’
[17:02:30.405]   - Field: ‘lazy’
[17:02:30.405]   - Field: ‘state’
[17:02:30.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:30.405] - Launch lazy future ...
[17:02:30.405] Packages needed by the future expression (n = 0): <none>
[17:02:30.406] Packages needed by future strategies (n = 0): <none>
[17:02:30.406] {
[17:02:30.406]     {
[17:02:30.406]         {
[17:02:30.406]             ...future.startTime <- base::Sys.time()
[17:02:30.406]             {
[17:02:30.406]                 {
[17:02:30.406]                   {
[17:02:30.406]                     {
[17:02:30.406]                       base::local({
[17:02:30.406]                         has_future <- base::requireNamespace("future", 
[17:02:30.406]                           quietly = TRUE)
[17:02:30.406]                         if (has_future) {
[17:02:30.406]                           ns <- base::getNamespace("future")
[17:02:30.406]                           version <- ns[[".package"]][["version"]]
[17:02:30.406]                           if (is.null(version)) 
[17:02:30.406]                             version <- utils::packageVersion("future")
[17:02:30.406]                         }
[17:02:30.406]                         else {
[17:02:30.406]                           version <- NULL
[17:02:30.406]                         }
[17:02:30.406]                         if (!has_future || version < "1.8.0") {
[17:02:30.406]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.406]                             "", base::R.version$version.string), 
[17:02:30.406]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.406]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.406]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.406]                               "release", "version")], collapse = " "), 
[17:02:30.406]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.406]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.406]                             info)
[17:02:30.406]                           info <- base::paste(info, collapse = "; ")
[17:02:30.406]                           if (!has_future) {
[17:02:30.406]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.406]                               info)
[17:02:30.406]                           }
[17:02:30.406]                           else {
[17:02:30.406]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.406]                               info, version)
[17:02:30.406]                           }
[17:02:30.406]                           base::stop(msg)
[17:02:30.406]                         }
[17:02:30.406]                       })
[17:02:30.406]                     }
[17:02:30.406]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.406]                     base::options(mc.cores = 1L)
[17:02:30.406]                   }
[17:02:30.406]                   ...future.strategy.old <- future::plan("list")
[17:02:30.406]                   options(future.plan = NULL)
[17:02:30.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.406]                 }
[17:02:30.406]                 ...future.workdir <- getwd()
[17:02:30.406]             }
[17:02:30.406]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.406]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.406]         }
[17:02:30.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.406]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.406]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.406]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.406]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.406]             base::names(...future.oldOptions))
[17:02:30.406]     }
[17:02:30.406]     if (FALSE) {
[17:02:30.406]     }
[17:02:30.406]     else {
[17:02:30.406]         if (TRUE) {
[17:02:30.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.406]                 open = "w")
[17:02:30.406]         }
[17:02:30.406]         else {
[17:02:30.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.406]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.406]         }
[17:02:30.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.406]             base::sink(type = "output", split = FALSE)
[17:02:30.406]             base::close(...future.stdout)
[17:02:30.406]         }, add = TRUE)
[17:02:30.406]     }
[17:02:30.406]     ...future.frame <- base::sys.nframe()
[17:02:30.406]     ...future.conditions <- base::list()
[17:02:30.406]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.406]     if (FALSE) {
[17:02:30.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.406]     }
[17:02:30.406]     ...future.result <- base::tryCatch({
[17:02:30.406]         base::withCallingHandlers({
[17:02:30.406]             ...future.value <- base::withVisible(base::local({
[17:02:30.406]                 ...future.makeSendCondition <- base::local({
[17:02:30.406]                   sendCondition <- NULL
[17:02:30.406]                   function(frame = 1L) {
[17:02:30.406]                     if (is.function(sendCondition)) 
[17:02:30.406]                       return(sendCondition)
[17:02:30.406]                     ns <- getNamespace("parallel")
[17:02:30.406]                     if (exists("sendData", mode = "function", 
[17:02:30.406]                       envir = ns)) {
[17:02:30.406]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:30.406]                         envir = ns)
[17:02:30.406]                       envir <- sys.frame(frame)
[17:02:30.406]                       master <- NULL
[17:02:30.406]                       while (!identical(envir, .GlobalEnv) && 
[17:02:30.406]                         !identical(envir, emptyenv())) {
[17:02:30.406]                         if (exists("master", mode = "list", envir = envir, 
[17:02:30.406]                           inherits = FALSE)) {
[17:02:30.406]                           master <- get("master", mode = "list", 
[17:02:30.406]                             envir = envir, inherits = FALSE)
[17:02:30.406]                           if (inherits(master, c("SOCKnode", 
[17:02:30.406]                             "SOCK0node"))) {
[17:02:30.406]                             sendCondition <<- function(cond) {
[17:02:30.406]                               data <- list(type = "VALUE", value = cond, 
[17:02:30.406]                                 success = TRUE)
[17:02:30.406]                               parallel_sendData(master, data)
[17:02:30.406]                             }
[17:02:30.406]                             return(sendCondition)
[17:02:30.406]                           }
[17:02:30.406]                         }
[17:02:30.406]                         frame <- frame + 1L
[17:02:30.406]                         envir <- sys.frame(frame)
[17:02:30.406]                       }
[17:02:30.406]                     }
[17:02:30.406]                     sendCondition <<- function(cond) NULL
[17:02:30.406]                   }
[17:02:30.406]                 })
[17:02:30.406]                 withCallingHandlers({
[17:02:30.406]                   2
[17:02:30.406]                 }, immediateCondition = function(cond) {
[17:02:30.406]                   sendCondition <- ...future.makeSendCondition()
[17:02:30.406]                   sendCondition(cond)
[17:02:30.406]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.406]                   {
[17:02:30.406]                     inherits <- base::inherits
[17:02:30.406]                     invokeRestart <- base::invokeRestart
[17:02:30.406]                     is.null <- base::is.null
[17:02:30.406]                     muffled <- FALSE
[17:02:30.406]                     if (inherits(cond, "message")) {
[17:02:30.406]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.406]                       if (muffled) 
[17:02:30.406]                         invokeRestart("muffleMessage")
[17:02:30.406]                     }
[17:02:30.406]                     else if (inherits(cond, "warning")) {
[17:02:30.406]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.406]                       if (muffled) 
[17:02:30.406]                         invokeRestart("muffleWarning")
[17:02:30.406]                     }
[17:02:30.406]                     else if (inherits(cond, "condition")) {
[17:02:30.406]                       if (!is.null(pattern)) {
[17:02:30.406]                         computeRestarts <- base::computeRestarts
[17:02:30.406]                         grepl <- base::grepl
[17:02:30.406]                         restarts <- computeRestarts(cond)
[17:02:30.406]                         for (restart in restarts) {
[17:02:30.406]                           name <- restart$name
[17:02:30.406]                           if (is.null(name)) 
[17:02:30.406]                             next
[17:02:30.406]                           if (!grepl(pattern, name)) 
[17:02:30.406]                             next
[17:02:30.406]                           invokeRestart(restart)
[17:02:30.406]                           muffled <- TRUE
[17:02:30.406]                           break
[17:02:30.406]                         }
[17:02:30.406]                       }
[17:02:30.406]                     }
[17:02:30.406]                     invisible(muffled)
[17:02:30.406]                   }
[17:02:30.406]                   muffleCondition(cond)
[17:02:30.406]                 })
[17:02:30.406]             }))
[17:02:30.406]             future::FutureResult(value = ...future.value$value, 
[17:02:30.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.406]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.406]                     ...future.globalenv.names))
[17:02:30.406]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.406]         }, condition = base::local({
[17:02:30.406]             c <- base::c
[17:02:30.406]             inherits <- base::inherits
[17:02:30.406]             invokeRestart <- base::invokeRestart
[17:02:30.406]             length <- base::length
[17:02:30.406]             list <- base::list
[17:02:30.406]             seq.int <- base::seq.int
[17:02:30.406]             signalCondition <- base::signalCondition
[17:02:30.406]             sys.calls <- base::sys.calls
[17:02:30.406]             `[[` <- base::`[[`
[17:02:30.406]             `+` <- base::`+`
[17:02:30.406]             `<<-` <- base::`<<-`
[17:02:30.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.406]                   3L)]
[17:02:30.406]             }
[17:02:30.406]             function(cond) {
[17:02:30.406]                 is_error <- inherits(cond, "error")
[17:02:30.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.406]                   NULL)
[17:02:30.406]                 if (is_error) {
[17:02:30.406]                   sessionInformation <- function() {
[17:02:30.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.406]                       search = base::search(), system = base::Sys.info())
[17:02:30.406]                   }
[17:02:30.406]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.406]                     cond$call), session = sessionInformation(), 
[17:02:30.406]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.406]                   signalCondition(cond)
[17:02:30.406]                 }
[17:02:30.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.406]                 "immediateCondition"))) {
[17:02:30.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.406]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.406]                   if (TRUE && !signal) {
[17:02:30.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.406]                     {
[17:02:30.406]                       inherits <- base::inherits
[17:02:30.406]                       invokeRestart <- base::invokeRestart
[17:02:30.406]                       is.null <- base::is.null
[17:02:30.406]                       muffled <- FALSE
[17:02:30.406]                       if (inherits(cond, "message")) {
[17:02:30.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.406]                         if (muffled) 
[17:02:30.406]                           invokeRestart("muffleMessage")
[17:02:30.406]                       }
[17:02:30.406]                       else if (inherits(cond, "warning")) {
[17:02:30.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.406]                         if (muffled) 
[17:02:30.406]                           invokeRestart("muffleWarning")
[17:02:30.406]                       }
[17:02:30.406]                       else if (inherits(cond, "condition")) {
[17:02:30.406]                         if (!is.null(pattern)) {
[17:02:30.406]                           computeRestarts <- base::computeRestarts
[17:02:30.406]                           grepl <- base::grepl
[17:02:30.406]                           restarts <- computeRestarts(cond)
[17:02:30.406]                           for (restart in restarts) {
[17:02:30.406]                             name <- restart$name
[17:02:30.406]                             if (is.null(name)) 
[17:02:30.406]                               next
[17:02:30.406]                             if (!grepl(pattern, name)) 
[17:02:30.406]                               next
[17:02:30.406]                             invokeRestart(restart)
[17:02:30.406]                             muffled <- TRUE
[17:02:30.406]                             break
[17:02:30.406]                           }
[17:02:30.406]                         }
[17:02:30.406]                       }
[17:02:30.406]                       invisible(muffled)
[17:02:30.406]                     }
[17:02:30.406]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.406]                   }
[17:02:30.406]                 }
[17:02:30.406]                 else {
[17:02:30.406]                   if (TRUE) {
[17:02:30.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.406]                     {
[17:02:30.406]                       inherits <- base::inherits
[17:02:30.406]                       invokeRestart <- base::invokeRestart
[17:02:30.406]                       is.null <- base::is.null
[17:02:30.406]                       muffled <- FALSE
[17:02:30.406]                       if (inherits(cond, "message")) {
[17:02:30.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.406]                         if (muffled) 
[17:02:30.406]                           invokeRestart("muffleMessage")
[17:02:30.406]                       }
[17:02:30.406]                       else if (inherits(cond, "warning")) {
[17:02:30.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.406]                         if (muffled) 
[17:02:30.406]                           invokeRestart("muffleWarning")
[17:02:30.406]                       }
[17:02:30.406]                       else if (inherits(cond, "condition")) {
[17:02:30.406]                         if (!is.null(pattern)) {
[17:02:30.406]                           computeRestarts <- base::computeRestarts
[17:02:30.406]                           grepl <- base::grepl
[17:02:30.406]                           restarts <- computeRestarts(cond)
[17:02:30.406]                           for (restart in restarts) {
[17:02:30.406]                             name <- restart$name
[17:02:30.406]                             if (is.null(name)) 
[17:02:30.406]                               next
[17:02:30.406]                             if (!grepl(pattern, name)) 
[17:02:30.406]                               next
[17:02:30.406]                             invokeRestart(restart)
[17:02:30.406]                             muffled <- TRUE
[17:02:30.406]                             break
[17:02:30.406]                           }
[17:02:30.406]                         }
[17:02:30.406]                       }
[17:02:30.406]                       invisible(muffled)
[17:02:30.406]                     }
[17:02:30.406]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.406]                   }
[17:02:30.406]                 }
[17:02:30.406]             }
[17:02:30.406]         }))
[17:02:30.406]     }, error = function(ex) {
[17:02:30.406]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.406]                 ...future.rng), started = ...future.startTime, 
[17:02:30.406]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.406]             version = "1.8"), class = "FutureResult")
[17:02:30.406]     }, finally = {
[17:02:30.406]         if (!identical(...future.workdir, getwd())) 
[17:02:30.406]             setwd(...future.workdir)
[17:02:30.406]         {
[17:02:30.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.406]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.406]             }
[17:02:30.406]             base::options(...future.oldOptions)
[17:02:30.406]             if (.Platform$OS.type == "windows") {
[17:02:30.406]                 old_names <- names(...future.oldEnvVars)
[17:02:30.406]                 envs <- base::Sys.getenv()
[17:02:30.406]                 names <- names(envs)
[17:02:30.406]                 common <- intersect(names, old_names)
[17:02:30.406]                 added <- setdiff(names, old_names)
[17:02:30.406]                 removed <- setdiff(old_names, names)
[17:02:30.406]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.406]                   envs[common]]
[17:02:30.406]                 NAMES <- toupper(changed)
[17:02:30.406]                 args <- list()
[17:02:30.406]                 for (kk in seq_along(NAMES)) {
[17:02:30.406]                   name <- changed[[kk]]
[17:02:30.406]                   NAME <- NAMES[[kk]]
[17:02:30.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.406]                     next
[17:02:30.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.406]                 }
[17:02:30.406]                 NAMES <- toupper(added)
[17:02:30.406]                 for (kk in seq_along(NAMES)) {
[17:02:30.406]                   name <- added[[kk]]
[17:02:30.406]                   NAME <- NAMES[[kk]]
[17:02:30.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.406]                     next
[17:02:30.406]                   args[[name]] <- ""
[17:02:30.406]                 }
[17:02:30.406]                 NAMES <- toupper(removed)
[17:02:30.406]                 for (kk in seq_along(NAMES)) {
[17:02:30.406]                   name <- removed[[kk]]
[17:02:30.406]                   NAME <- NAMES[[kk]]
[17:02:30.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.406]                     next
[17:02:30.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.406]                 }
[17:02:30.406]                 if (length(args) > 0) 
[17:02:30.406]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.406]             }
[17:02:30.406]             else {
[17:02:30.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.406]             }
[17:02:30.406]             {
[17:02:30.406]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.406]                   0L) {
[17:02:30.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.406]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.406]                   base::options(opts)
[17:02:30.406]                 }
[17:02:30.406]                 {
[17:02:30.406]                   {
[17:02:30.406]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.406]                     NULL
[17:02:30.406]                   }
[17:02:30.406]                   options(future.plan = NULL)
[17:02:30.406]                   if (is.na(NA_character_)) 
[17:02:30.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.406]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.406]                     .init = FALSE)
[17:02:30.406]                 }
[17:02:30.406]             }
[17:02:30.406]         }
[17:02:30.406]     })
[17:02:30.406]     if (TRUE) {
[17:02:30.406]         base::sink(type = "output", split = FALSE)
[17:02:30.406]         if (TRUE) {
[17:02:30.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.406]         }
[17:02:30.406]         else {
[17:02:30.406]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.406]         }
[17:02:30.406]         base::close(...future.stdout)
[17:02:30.406]         ...future.stdout <- NULL
[17:02:30.406]     }
[17:02:30.406]     ...future.result$conditions <- ...future.conditions
[17:02:30.406]     ...future.result$finished <- base::Sys.time()
[17:02:30.406]     ...future.result
[17:02:30.406] }
[17:02:30.409] MultisessionFuture started
[17:02:30.409] - Launch lazy future ... done
[17:02:30.409] run() for ‘MultisessionFuture’ ... done
[17:02:30.409] getGlobalsAndPackages() ...
[17:02:30.410] Searching for globals...
[17:02:30.410] 
[17:02:30.410] Searching for globals ... DONE
[17:02:30.410] - globals: [0] <none>
[17:02:30.410] getGlobalsAndPackages() ... DONE
[17:02:30.410] run() for ‘Future’ ...
[17:02:30.410] - state: ‘created’
[17:02:30.411] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.424] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:30.425]   - Field: ‘node’
[17:02:30.425]   - Field: ‘label’
[17:02:30.425]   - Field: ‘local’
[17:02:30.425]   - Field: ‘owner’
[17:02:30.425]   - Field: ‘envir’
[17:02:30.425]   - Field: ‘workers’
[17:02:30.425]   - Field: ‘packages’
[17:02:30.425]   - Field: ‘gc’
[17:02:30.425]   - Field: ‘conditions’
[17:02:30.425]   - Field: ‘persistent’
[17:02:30.425]   - Field: ‘expr’
[17:02:30.426]   - Field: ‘uuid’
[17:02:30.426]   - Field: ‘seed’
[17:02:30.426]   - Field: ‘version’
[17:02:30.426]   - Field: ‘result’
[17:02:30.426]   - Field: ‘asynchronous’
[17:02:30.426]   - Field: ‘calls’
[17:02:30.426]   - Field: ‘globals’
[17:02:30.426]   - Field: ‘stdout’
[17:02:30.426]   - Field: ‘earlySignal’
[17:02:30.426]   - Field: ‘lazy’
[17:02:30.426]   - Field: ‘state’
[17:02:30.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:30.427] - Launch lazy future ...
[17:02:30.427] Packages needed by the future expression (n = 0): <none>
[17:02:30.427] Packages needed by future strategies (n = 0): <none>
[17:02:30.427] {
[17:02:30.427]     {
[17:02:30.427]         {
[17:02:30.427]             ...future.startTime <- base::Sys.time()
[17:02:30.427]             {
[17:02:30.427]                 {
[17:02:30.427]                   {
[17:02:30.427]                     {
[17:02:30.427]                       base::local({
[17:02:30.427]                         has_future <- base::requireNamespace("future", 
[17:02:30.427]                           quietly = TRUE)
[17:02:30.427]                         if (has_future) {
[17:02:30.427]                           ns <- base::getNamespace("future")
[17:02:30.427]                           version <- ns[[".package"]][["version"]]
[17:02:30.427]                           if (is.null(version)) 
[17:02:30.427]                             version <- utils::packageVersion("future")
[17:02:30.427]                         }
[17:02:30.427]                         else {
[17:02:30.427]                           version <- NULL
[17:02:30.427]                         }
[17:02:30.427]                         if (!has_future || version < "1.8.0") {
[17:02:30.427]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.427]                             "", base::R.version$version.string), 
[17:02:30.427]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.427]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.427]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.427]                               "release", "version")], collapse = " "), 
[17:02:30.427]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.427]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.427]                             info)
[17:02:30.427]                           info <- base::paste(info, collapse = "; ")
[17:02:30.427]                           if (!has_future) {
[17:02:30.427]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.427]                               info)
[17:02:30.427]                           }
[17:02:30.427]                           else {
[17:02:30.427]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.427]                               info, version)
[17:02:30.427]                           }
[17:02:30.427]                           base::stop(msg)
[17:02:30.427]                         }
[17:02:30.427]                       })
[17:02:30.427]                     }
[17:02:30.427]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.427]                     base::options(mc.cores = 1L)
[17:02:30.427]                   }
[17:02:30.427]                   ...future.strategy.old <- future::plan("list")
[17:02:30.427]                   options(future.plan = NULL)
[17:02:30.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.427]                 }
[17:02:30.427]                 ...future.workdir <- getwd()
[17:02:30.427]             }
[17:02:30.427]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.427]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.427]         }
[17:02:30.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.427]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.427]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.427]             base::names(...future.oldOptions))
[17:02:30.427]     }
[17:02:30.427]     if (FALSE) {
[17:02:30.427]     }
[17:02:30.427]     else {
[17:02:30.427]         if (TRUE) {
[17:02:30.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.427]                 open = "w")
[17:02:30.427]         }
[17:02:30.427]         else {
[17:02:30.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.427]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.427]         }
[17:02:30.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.427]             base::sink(type = "output", split = FALSE)
[17:02:30.427]             base::close(...future.stdout)
[17:02:30.427]         }, add = TRUE)
[17:02:30.427]     }
[17:02:30.427]     ...future.frame <- base::sys.nframe()
[17:02:30.427]     ...future.conditions <- base::list()
[17:02:30.427]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.427]     if (FALSE) {
[17:02:30.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.427]     }
[17:02:30.427]     ...future.result <- base::tryCatch({
[17:02:30.427]         base::withCallingHandlers({
[17:02:30.427]             ...future.value <- base::withVisible(base::local({
[17:02:30.427]                 ...future.makeSendCondition <- base::local({
[17:02:30.427]                   sendCondition <- NULL
[17:02:30.427]                   function(frame = 1L) {
[17:02:30.427]                     if (is.function(sendCondition)) 
[17:02:30.427]                       return(sendCondition)
[17:02:30.427]                     ns <- getNamespace("parallel")
[17:02:30.427]                     if (exists("sendData", mode = "function", 
[17:02:30.427]                       envir = ns)) {
[17:02:30.427]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:30.427]                         envir = ns)
[17:02:30.427]                       envir <- sys.frame(frame)
[17:02:30.427]                       master <- NULL
[17:02:30.427]                       while (!identical(envir, .GlobalEnv) && 
[17:02:30.427]                         !identical(envir, emptyenv())) {
[17:02:30.427]                         if (exists("master", mode = "list", envir = envir, 
[17:02:30.427]                           inherits = FALSE)) {
[17:02:30.427]                           master <- get("master", mode = "list", 
[17:02:30.427]                             envir = envir, inherits = FALSE)
[17:02:30.427]                           if (inherits(master, c("SOCKnode", 
[17:02:30.427]                             "SOCK0node"))) {
[17:02:30.427]                             sendCondition <<- function(cond) {
[17:02:30.427]                               data <- list(type = "VALUE", value = cond, 
[17:02:30.427]                                 success = TRUE)
[17:02:30.427]                               parallel_sendData(master, data)
[17:02:30.427]                             }
[17:02:30.427]                             return(sendCondition)
[17:02:30.427]                           }
[17:02:30.427]                         }
[17:02:30.427]                         frame <- frame + 1L
[17:02:30.427]                         envir <- sys.frame(frame)
[17:02:30.427]                       }
[17:02:30.427]                     }
[17:02:30.427]                     sendCondition <<- function(cond) NULL
[17:02:30.427]                   }
[17:02:30.427]                 })
[17:02:30.427]                 withCallingHandlers({
[17:02:30.427]                   NULL
[17:02:30.427]                 }, immediateCondition = function(cond) {
[17:02:30.427]                   sendCondition <- ...future.makeSendCondition()
[17:02:30.427]                   sendCondition(cond)
[17:02:30.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.427]                   {
[17:02:30.427]                     inherits <- base::inherits
[17:02:30.427]                     invokeRestart <- base::invokeRestart
[17:02:30.427]                     is.null <- base::is.null
[17:02:30.427]                     muffled <- FALSE
[17:02:30.427]                     if (inherits(cond, "message")) {
[17:02:30.427]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.427]                       if (muffled) 
[17:02:30.427]                         invokeRestart("muffleMessage")
[17:02:30.427]                     }
[17:02:30.427]                     else if (inherits(cond, "warning")) {
[17:02:30.427]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.427]                       if (muffled) 
[17:02:30.427]                         invokeRestart("muffleWarning")
[17:02:30.427]                     }
[17:02:30.427]                     else if (inherits(cond, "condition")) {
[17:02:30.427]                       if (!is.null(pattern)) {
[17:02:30.427]                         computeRestarts <- base::computeRestarts
[17:02:30.427]                         grepl <- base::grepl
[17:02:30.427]                         restarts <- computeRestarts(cond)
[17:02:30.427]                         for (restart in restarts) {
[17:02:30.427]                           name <- restart$name
[17:02:30.427]                           if (is.null(name)) 
[17:02:30.427]                             next
[17:02:30.427]                           if (!grepl(pattern, name)) 
[17:02:30.427]                             next
[17:02:30.427]                           invokeRestart(restart)
[17:02:30.427]                           muffled <- TRUE
[17:02:30.427]                           break
[17:02:30.427]                         }
[17:02:30.427]                       }
[17:02:30.427]                     }
[17:02:30.427]                     invisible(muffled)
[17:02:30.427]                   }
[17:02:30.427]                   muffleCondition(cond)
[17:02:30.427]                 })
[17:02:30.427]             }))
[17:02:30.427]             future::FutureResult(value = ...future.value$value, 
[17:02:30.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.427]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.427]                     ...future.globalenv.names))
[17:02:30.427]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.427]         }, condition = base::local({
[17:02:30.427]             c <- base::c
[17:02:30.427]             inherits <- base::inherits
[17:02:30.427]             invokeRestart <- base::invokeRestart
[17:02:30.427]             length <- base::length
[17:02:30.427]             list <- base::list
[17:02:30.427]             seq.int <- base::seq.int
[17:02:30.427]             signalCondition <- base::signalCondition
[17:02:30.427]             sys.calls <- base::sys.calls
[17:02:30.427]             `[[` <- base::`[[`
[17:02:30.427]             `+` <- base::`+`
[17:02:30.427]             `<<-` <- base::`<<-`
[17:02:30.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.427]                   3L)]
[17:02:30.427]             }
[17:02:30.427]             function(cond) {
[17:02:30.427]                 is_error <- inherits(cond, "error")
[17:02:30.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.427]                   NULL)
[17:02:30.427]                 if (is_error) {
[17:02:30.427]                   sessionInformation <- function() {
[17:02:30.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.427]                       search = base::search(), system = base::Sys.info())
[17:02:30.427]                   }
[17:02:30.427]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.427]                     cond$call), session = sessionInformation(), 
[17:02:30.427]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.427]                   signalCondition(cond)
[17:02:30.427]                 }
[17:02:30.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.427]                 "immediateCondition"))) {
[17:02:30.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.427]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.427]                   if (TRUE && !signal) {
[17:02:30.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.427]                     {
[17:02:30.427]                       inherits <- base::inherits
[17:02:30.427]                       invokeRestart <- base::invokeRestart
[17:02:30.427]                       is.null <- base::is.null
[17:02:30.427]                       muffled <- FALSE
[17:02:30.427]                       if (inherits(cond, "message")) {
[17:02:30.427]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.427]                         if (muffled) 
[17:02:30.427]                           invokeRestart("muffleMessage")
[17:02:30.427]                       }
[17:02:30.427]                       else if (inherits(cond, "warning")) {
[17:02:30.427]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.427]                         if (muffled) 
[17:02:30.427]                           invokeRestart("muffleWarning")
[17:02:30.427]                       }
[17:02:30.427]                       else if (inherits(cond, "condition")) {
[17:02:30.427]                         if (!is.null(pattern)) {
[17:02:30.427]                           computeRestarts <- base::computeRestarts
[17:02:30.427]                           grepl <- base::grepl
[17:02:30.427]                           restarts <- computeRestarts(cond)
[17:02:30.427]                           for (restart in restarts) {
[17:02:30.427]                             name <- restart$name
[17:02:30.427]                             if (is.null(name)) 
[17:02:30.427]                               next
[17:02:30.427]                             if (!grepl(pattern, name)) 
[17:02:30.427]                               next
[17:02:30.427]                             invokeRestart(restart)
[17:02:30.427]                             muffled <- TRUE
[17:02:30.427]                             break
[17:02:30.427]                           }
[17:02:30.427]                         }
[17:02:30.427]                       }
[17:02:30.427]                       invisible(muffled)
[17:02:30.427]                     }
[17:02:30.427]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.427]                   }
[17:02:30.427]                 }
[17:02:30.427]                 else {
[17:02:30.427]                   if (TRUE) {
[17:02:30.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.427]                     {
[17:02:30.427]                       inherits <- base::inherits
[17:02:30.427]                       invokeRestart <- base::invokeRestart
[17:02:30.427]                       is.null <- base::is.null
[17:02:30.427]                       muffled <- FALSE
[17:02:30.427]                       if (inherits(cond, "message")) {
[17:02:30.427]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.427]                         if (muffled) 
[17:02:30.427]                           invokeRestart("muffleMessage")
[17:02:30.427]                       }
[17:02:30.427]                       else if (inherits(cond, "warning")) {
[17:02:30.427]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.427]                         if (muffled) 
[17:02:30.427]                           invokeRestart("muffleWarning")
[17:02:30.427]                       }
[17:02:30.427]                       else if (inherits(cond, "condition")) {
[17:02:30.427]                         if (!is.null(pattern)) {
[17:02:30.427]                           computeRestarts <- base::computeRestarts
[17:02:30.427]                           grepl <- base::grepl
[17:02:30.427]                           restarts <- computeRestarts(cond)
[17:02:30.427]                           for (restart in restarts) {
[17:02:30.427]                             name <- restart$name
[17:02:30.427]                             if (is.null(name)) 
[17:02:30.427]                               next
[17:02:30.427]                             if (!grepl(pattern, name)) 
[17:02:30.427]                               next
[17:02:30.427]                             invokeRestart(restart)
[17:02:30.427]                             muffled <- TRUE
[17:02:30.427]                             break
[17:02:30.427]                           }
[17:02:30.427]                         }
[17:02:30.427]                       }
[17:02:30.427]                       invisible(muffled)
[17:02:30.427]                     }
[17:02:30.427]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.427]                   }
[17:02:30.427]                 }
[17:02:30.427]             }
[17:02:30.427]         }))
[17:02:30.427]     }, error = function(ex) {
[17:02:30.427]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.427]                 ...future.rng), started = ...future.startTime, 
[17:02:30.427]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.427]             version = "1.8"), class = "FutureResult")
[17:02:30.427]     }, finally = {
[17:02:30.427]         if (!identical(...future.workdir, getwd())) 
[17:02:30.427]             setwd(...future.workdir)
[17:02:30.427]         {
[17:02:30.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.427]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.427]             }
[17:02:30.427]             base::options(...future.oldOptions)
[17:02:30.427]             if (.Platform$OS.type == "windows") {
[17:02:30.427]                 old_names <- names(...future.oldEnvVars)
[17:02:30.427]                 envs <- base::Sys.getenv()
[17:02:30.427]                 names <- names(envs)
[17:02:30.427]                 common <- intersect(names, old_names)
[17:02:30.427]                 added <- setdiff(names, old_names)
[17:02:30.427]                 removed <- setdiff(old_names, names)
[17:02:30.427]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.427]                   envs[common]]
[17:02:30.427]                 NAMES <- toupper(changed)
[17:02:30.427]                 args <- list()
[17:02:30.427]                 for (kk in seq_along(NAMES)) {
[17:02:30.427]                   name <- changed[[kk]]
[17:02:30.427]                   NAME <- NAMES[[kk]]
[17:02:30.427]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.427]                     next
[17:02:30.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.427]                 }
[17:02:30.427]                 NAMES <- toupper(added)
[17:02:30.427]                 for (kk in seq_along(NAMES)) {
[17:02:30.427]                   name <- added[[kk]]
[17:02:30.427]                   NAME <- NAMES[[kk]]
[17:02:30.427]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.427]                     next
[17:02:30.427]                   args[[name]] <- ""
[17:02:30.427]                 }
[17:02:30.427]                 NAMES <- toupper(removed)
[17:02:30.427]                 for (kk in seq_along(NAMES)) {
[17:02:30.427]                   name <- removed[[kk]]
[17:02:30.427]                   NAME <- NAMES[[kk]]
[17:02:30.427]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.427]                     next
[17:02:30.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.427]                 }
[17:02:30.427]                 if (length(args) > 0) 
[17:02:30.427]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.427]             }
[17:02:30.427]             else {
[17:02:30.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.427]             }
[17:02:30.427]             {
[17:02:30.427]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.427]                   0L) {
[17:02:30.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.427]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.427]                   base::options(opts)
[17:02:30.427]                 }
[17:02:30.427]                 {
[17:02:30.427]                   {
[17:02:30.427]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.427]                     NULL
[17:02:30.427]                   }
[17:02:30.427]                   options(future.plan = NULL)
[17:02:30.427]                   if (is.na(NA_character_)) 
[17:02:30.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.427]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.427]                     .init = FALSE)
[17:02:30.427]                 }
[17:02:30.427]             }
[17:02:30.427]         }
[17:02:30.427]     })
[17:02:30.427]     if (TRUE) {
[17:02:30.427]         base::sink(type = "output", split = FALSE)
[17:02:30.427]         if (TRUE) {
[17:02:30.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.427]         }
[17:02:30.427]         else {
[17:02:30.427]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.427]         }
[17:02:30.427]         base::close(...future.stdout)
[17:02:30.427]         ...future.stdout <- NULL
[17:02:30.427]     }
[17:02:30.427]     ...future.result$conditions <- ...future.conditions
[17:02:30.427]     ...future.result$finished <- base::Sys.time()
[17:02:30.427]     ...future.result
[17:02:30.427] }
[17:02:30.431] MultisessionFuture started
[17:02:30.431] - Launch lazy future ... done
[17:02:30.431] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74af16fb8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74b323fc0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74af16fb8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74b323fc0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:02:30.438] receiveMessageFromWorker() for ClusterFuture ...
[17:02:30.439] - Validating connection of MultisessionFuture
[17:02:30.439] - received message: FutureResult
[17:02:30.439] - Received FutureResult
[17:02:30.439] - Erased future from FutureRegistry
[17:02:30.439] result() for ClusterFuture ...
[17:02:30.439] - result already collected: FutureResult
[17:02:30.439] result() for ClusterFuture ... done
[17:02:30.439] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:30.440] receiveMessageFromWorker() for ClusterFuture ...
[17:02:30.440] - Validating connection of MultisessionFuture
[17:02:30.440] - received message: FutureResult
[17:02:30.440] - Received FutureResult
[17:02:30.440] - Erased future from FutureRegistry
[17:02:30.440] result() for ClusterFuture ...
[17:02:30.440] - result already collected: FutureResult
[17:02:30.441] result() for ClusterFuture ... done
[17:02:30.441] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:30.444] resolve() on list ...
[17:02:30.444]  recursive: 0
[17:02:30.444]  length: 6
[17:02:30.444]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:30.444] signalConditionsASAP(numeric, pos=1) ...
[17:02:30.444] - nx: 6
[17:02:30.444] - relay: TRUE
[17:02:30.444] - stdout: TRUE
[17:02:30.445] - signal: TRUE
[17:02:30.445] - resignal: FALSE
[17:02:30.445] - force: TRUE
[17:02:30.445] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.445] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.445]  - until=2
[17:02:30.445]  - relaying element #2
[17:02:30.445] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.445] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.445] signalConditionsASAP(NULL, pos=1) ... done
[17:02:30.445]  length: 5 (resolved future 1)
[17:02:30.445] Future #2
[17:02:30.446] result() for ClusterFuture ...
[17:02:30.446] - result already collected: FutureResult
[17:02:30.446] result() for ClusterFuture ... done
[17:02:30.446] result() for ClusterFuture ...
[17:02:30.446] - result already collected: FutureResult
[17:02:30.446] result() for ClusterFuture ... done
[17:02:30.446] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:30.446] - nx: 6
[17:02:30.446] - relay: TRUE
[17:02:30.446] - stdout: TRUE
[17:02:30.446] - signal: TRUE
[17:02:30.446] - resignal: FALSE
[17:02:30.447] - force: TRUE
[17:02:30.447] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.447] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.447]  - until=2
[17:02:30.447]  - relaying element #2
[17:02:30.447] result() for ClusterFuture ...
[17:02:30.447] - result already collected: FutureResult
[17:02:30.447] result() for ClusterFuture ... done
[17:02:30.447] result() for ClusterFuture ...
[17:02:30.447] - result already collected: FutureResult
[17:02:30.447] result() for ClusterFuture ... done
[17:02:30.448] result() for ClusterFuture ...
[17:02:30.448] - result already collected: FutureResult
[17:02:30.448] result() for ClusterFuture ... done
[17:02:30.448] result() for ClusterFuture ...
[17:02:30.448] - result already collected: FutureResult
[17:02:30.448] result() for ClusterFuture ... done
[17:02:30.448] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.448] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.448] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:30.448]  length: 4 (resolved future 2)
[17:02:30.448] Future #3
[17:02:30.448] result() for ClusterFuture ...
[17:02:30.449] - result already collected: FutureResult
[17:02:30.449] result() for ClusterFuture ... done
[17:02:30.449] result() for ClusterFuture ...
[17:02:30.449] - result already collected: FutureResult
[17:02:30.449] result() for ClusterFuture ... done
[17:02:30.449] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:30.449] - nx: 6
[17:02:30.449] - relay: TRUE
[17:02:30.449] - stdout: TRUE
[17:02:30.449] - signal: TRUE
[17:02:30.449] - resignal: FALSE
[17:02:30.449] - force: TRUE
[17:02:30.449] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.450] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.450]  - until=3
[17:02:30.450]  - relaying element #3
[17:02:30.450] result() for ClusterFuture ...
[17:02:30.450] - result already collected: FutureResult
[17:02:30.450] result() for ClusterFuture ... done
[17:02:30.450] result() for ClusterFuture ...
[17:02:30.450] - result already collected: FutureResult
[17:02:30.450] result() for ClusterFuture ... done
[17:02:30.450] result() for ClusterFuture ...
[17:02:30.450] - result already collected: FutureResult
[17:02:30.450] result() for ClusterFuture ... done
[17:02:30.451] result() for ClusterFuture ...
[17:02:30.451] - result already collected: FutureResult
[17:02:30.451] result() for ClusterFuture ... done
[17:02:30.451] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.451] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.451] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:30.451]  length: 3 (resolved future 3)
[17:02:30.451] signalConditionsASAP(NULL, pos=4) ...
[17:02:30.451] - nx: 6
[17:02:30.451] - relay: TRUE
[17:02:30.451] - stdout: TRUE
[17:02:30.451] - signal: TRUE
[17:02:30.452] - resignal: FALSE
[17:02:30.452] - force: TRUE
[17:02:30.452] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.452] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.452]  - until=5
[17:02:30.452]  - relaying element #5
[17:02:30.452] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:30.452] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.452] signalConditionsASAP(NULL, pos=4) ... done
[17:02:30.452]  length: 2 (resolved future 4)
[17:02:30.452] signalConditionsASAP(NULL, pos=5) ...
[17:02:30.452] - nx: 6
[17:02:30.453] - relay: TRUE
[17:02:30.453] - stdout: TRUE
[17:02:30.453] - signal: TRUE
[17:02:30.453] - resignal: FALSE
[17:02:30.453] - force: TRUE
[17:02:30.453] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:30.453] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.453]  - until=6
[17:02:30.453]  - relaying element #6
[17:02:30.453] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:30.453] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.453] signalConditionsASAP(NULL, pos=5) ... done
[17:02:30.453]  length: 1 (resolved future 5)
[17:02:30.454] signalConditionsASAP(numeric, pos=6) ...
[17:02:30.454] - nx: 6
[17:02:30.454] - relay: TRUE
[17:02:30.454] - stdout: TRUE
[17:02:30.454] - signal: TRUE
[17:02:30.454] - resignal: FALSE
[17:02:30.454] - force: TRUE
[17:02:30.454] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:30.454] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.454]  - until=6
[17:02:30.454] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.454] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.454] signalConditionsASAP(numeric, pos=6) ... done
[17:02:30.455]  length: 0 (resolved future 6)
[17:02:30.455] Relaying remaining futures
[17:02:30.455] signalConditionsASAP(NULL, pos=0) ...
[17:02:30.455] - nx: 6
[17:02:30.455] - relay: TRUE
[17:02:30.455] - stdout: TRUE
[17:02:30.455] - signal: TRUE
[17:02:30.455] - resignal: FALSE
[17:02:30.455] - force: TRUE
[17:02:30.455] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.455] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:30.456] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.456] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.456] signalConditionsASAP(NULL, pos=0) ... done
[17:02:30.456] resolve() on list ... DONE
[17:02:30.456] result() for ClusterFuture ...
[17:02:30.456] - result already collected: FutureResult
[17:02:30.456] result() for ClusterFuture ... done
[17:02:30.456] result() for ClusterFuture ...
[17:02:30.456] - result already collected: FutureResult
[17:02:30.456] result() for ClusterFuture ... done
[17:02:30.456] result() for ClusterFuture ...
[17:02:30.456] - result already collected: FutureResult
[17:02:30.457] result() for ClusterFuture ... done
[17:02:30.457] result() for ClusterFuture ...
[17:02:30.457] - result already collected: FutureResult
[17:02:30.457] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:02:30.460] getGlobalsAndPackages() ...
[17:02:30.460] Searching for globals...
[17:02:30.460] 
[17:02:30.460] Searching for globals ... DONE
[17:02:30.460] - globals: [0] <none>
[17:02:30.460] getGlobalsAndPackages() ... DONE
[17:02:30.461] run() for ‘Future’ ...
[17:02:30.461] - state: ‘created’
[17:02:30.461] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.475] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:30.476]   - Field: ‘node’
[17:02:30.476]   - Field: ‘label’
[17:02:30.476]   - Field: ‘local’
[17:02:30.476]   - Field: ‘owner’
[17:02:30.476]   - Field: ‘envir’
[17:02:30.476]   - Field: ‘workers’
[17:02:30.476]   - Field: ‘packages’
[17:02:30.476]   - Field: ‘gc’
[17:02:30.477]   - Field: ‘conditions’
[17:02:30.477]   - Field: ‘persistent’
[17:02:30.477]   - Field: ‘expr’
[17:02:30.477]   - Field: ‘uuid’
[17:02:30.477]   - Field: ‘seed’
[17:02:30.477]   - Field: ‘version’
[17:02:30.477]   - Field: ‘result’
[17:02:30.477]   - Field: ‘asynchronous’
[17:02:30.477]   - Field: ‘calls’
[17:02:30.477]   - Field: ‘globals’
[17:02:30.477]   - Field: ‘stdout’
[17:02:30.477]   - Field: ‘earlySignal’
[17:02:30.478]   - Field: ‘lazy’
[17:02:30.478]   - Field: ‘state’
[17:02:30.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:30.478] - Launch lazy future ...
[17:02:30.478] Packages needed by the future expression (n = 0): <none>
[17:02:30.478] Packages needed by future strategies (n = 0): <none>
[17:02:30.479] {
[17:02:30.479]     {
[17:02:30.479]         {
[17:02:30.479]             ...future.startTime <- base::Sys.time()
[17:02:30.479]             {
[17:02:30.479]                 {
[17:02:30.479]                   {
[17:02:30.479]                     {
[17:02:30.479]                       base::local({
[17:02:30.479]                         has_future <- base::requireNamespace("future", 
[17:02:30.479]                           quietly = TRUE)
[17:02:30.479]                         if (has_future) {
[17:02:30.479]                           ns <- base::getNamespace("future")
[17:02:30.479]                           version <- ns[[".package"]][["version"]]
[17:02:30.479]                           if (is.null(version)) 
[17:02:30.479]                             version <- utils::packageVersion("future")
[17:02:30.479]                         }
[17:02:30.479]                         else {
[17:02:30.479]                           version <- NULL
[17:02:30.479]                         }
[17:02:30.479]                         if (!has_future || version < "1.8.0") {
[17:02:30.479]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.479]                             "", base::R.version$version.string), 
[17:02:30.479]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.479]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.479]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.479]                               "release", "version")], collapse = " "), 
[17:02:30.479]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.479]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.479]                             info)
[17:02:30.479]                           info <- base::paste(info, collapse = "; ")
[17:02:30.479]                           if (!has_future) {
[17:02:30.479]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.479]                               info)
[17:02:30.479]                           }
[17:02:30.479]                           else {
[17:02:30.479]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.479]                               info, version)
[17:02:30.479]                           }
[17:02:30.479]                           base::stop(msg)
[17:02:30.479]                         }
[17:02:30.479]                       })
[17:02:30.479]                     }
[17:02:30.479]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.479]                     base::options(mc.cores = 1L)
[17:02:30.479]                   }
[17:02:30.479]                   ...future.strategy.old <- future::plan("list")
[17:02:30.479]                   options(future.plan = NULL)
[17:02:30.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.479]                 }
[17:02:30.479]                 ...future.workdir <- getwd()
[17:02:30.479]             }
[17:02:30.479]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.479]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.479]         }
[17:02:30.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.479]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.479]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.479]             base::names(...future.oldOptions))
[17:02:30.479]     }
[17:02:30.479]     if (FALSE) {
[17:02:30.479]     }
[17:02:30.479]     else {
[17:02:30.479]         if (TRUE) {
[17:02:30.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.479]                 open = "w")
[17:02:30.479]         }
[17:02:30.479]         else {
[17:02:30.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.479]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.479]         }
[17:02:30.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.479]             base::sink(type = "output", split = FALSE)
[17:02:30.479]             base::close(...future.stdout)
[17:02:30.479]         }, add = TRUE)
[17:02:30.479]     }
[17:02:30.479]     ...future.frame <- base::sys.nframe()
[17:02:30.479]     ...future.conditions <- base::list()
[17:02:30.479]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.479]     if (FALSE) {
[17:02:30.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.479]     }
[17:02:30.479]     ...future.result <- base::tryCatch({
[17:02:30.479]         base::withCallingHandlers({
[17:02:30.479]             ...future.value <- base::withVisible(base::local({
[17:02:30.479]                 ...future.makeSendCondition <- base::local({
[17:02:30.479]                   sendCondition <- NULL
[17:02:30.479]                   function(frame = 1L) {
[17:02:30.479]                     if (is.function(sendCondition)) 
[17:02:30.479]                       return(sendCondition)
[17:02:30.479]                     ns <- getNamespace("parallel")
[17:02:30.479]                     if (exists("sendData", mode = "function", 
[17:02:30.479]                       envir = ns)) {
[17:02:30.479]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:30.479]                         envir = ns)
[17:02:30.479]                       envir <- sys.frame(frame)
[17:02:30.479]                       master <- NULL
[17:02:30.479]                       while (!identical(envir, .GlobalEnv) && 
[17:02:30.479]                         !identical(envir, emptyenv())) {
[17:02:30.479]                         if (exists("master", mode = "list", envir = envir, 
[17:02:30.479]                           inherits = FALSE)) {
[17:02:30.479]                           master <- get("master", mode = "list", 
[17:02:30.479]                             envir = envir, inherits = FALSE)
[17:02:30.479]                           if (inherits(master, c("SOCKnode", 
[17:02:30.479]                             "SOCK0node"))) {
[17:02:30.479]                             sendCondition <<- function(cond) {
[17:02:30.479]                               data <- list(type = "VALUE", value = cond, 
[17:02:30.479]                                 success = TRUE)
[17:02:30.479]                               parallel_sendData(master, data)
[17:02:30.479]                             }
[17:02:30.479]                             return(sendCondition)
[17:02:30.479]                           }
[17:02:30.479]                         }
[17:02:30.479]                         frame <- frame + 1L
[17:02:30.479]                         envir <- sys.frame(frame)
[17:02:30.479]                       }
[17:02:30.479]                     }
[17:02:30.479]                     sendCondition <<- function(cond) NULL
[17:02:30.479]                   }
[17:02:30.479]                 })
[17:02:30.479]                 withCallingHandlers({
[17:02:30.479]                   2
[17:02:30.479]                 }, immediateCondition = function(cond) {
[17:02:30.479]                   sendCondition <- ...future.makeSendCondition()
[17:02:30.479]                   sendCondition(cond)
[17:02:30.479]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.479]                   {
[17:02:30.479]                     inherits <- base::inherits
[17:02:30.479]                     invokeRestart <- base::invokeRestart
[17:02:30.479]                     is.null <- base::is.null
[17:02:30.479]                     muffled <- FALSE
[17:02:30.479]                     if (inherits(cond, "message")) {
[17:02:30.479]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.479]                       if (muffled) 
[17:02:30.479]                         invokeRestart("muffleMessage")
[17:02:30.479]                     }
[17:02:30.479]                     else if (inherits(cond, "warning")) {
[17:02:30.479]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.479]                       if (muffled) 
[17:02:30.479]                         invokeRestart("muffleWarning")
[17:02:30.479]                     }
[17:02:30.479]                     else if (inherits(cond, "condition")) {
[17:02:30.479]                       if (!is.null(pattern)) {
[17:02:30.479]                         computeRestarts <- base::computeRestarts
[17:02:30.479]                         grepl <- base::grepl
[17:02:30.479]                         restarts <- computeRestarts(cond)
[17:02:30.479]                         for (restart in restarts) {
[17:02:30.479]                           name <- restart$name
[17:02:30.479]                           if (is.null(name)) 
[17:02:30.479]                             next
[17:02:30.479]                           if (!grepl(pattern, name)) 
[17:02:30.479]                             next
[17:02:30.479]                           invokeRestart(restart)
[17:02:30.479]                           muffled <- TRUE
[17:02:30.479]                           break
[17:02:30.479]                         }
[17:02:30.479]                       }
[17:02:30.479]                     }
[17:02:30.479]                     invisible(muffled)
[17:02:30.479]                   }
[17:02:30.479]                   muffleCondition(cond)
[17:02:30.479]                 })
[17:02:30.479]             }))
[17:02:30.479]             future::FutureResult(value = ...future.value$value, 
[17:02:30.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.479]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.479]                     ...future.globalenv.names))
[17:02:30.479]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.479]         }, condition = base::local({
[17:02:30.479]             c <- base::c
[17:02:30.479]             inherits <- base::inherits
[17:02:30.479]             invokeRestart <- base::invokeRestart
[17:02:30.479]             length <- base::length
[17:02:30.479]             list <- base::list
[17:02:30.479]             seq.int <- base::seq.int
[17:02:30.479]             signalCondition <- base::signalCondition
[17:02:30.479]             sys.calls <- base::sys.calls
[17:02:30.479]             `[[` <- base::`[[`
[17:02:30.479]             `+` <- base::`+`
[17:02:30.479]             `<<-` <- base::`<<-`
[17:02:30.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.479]                   3L)]
[17:02:30.479]             }
[17:02:30.479]             function(cond) {
[17:02:30.479]                 is_error <- inherits(cond, "error")
[17:02:30.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.479]                   NULL)
[17:02:30.479]                 if (is_error) {
[17:02:30.479]                   sessionInformation <- function() {
[17:02:30.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.479]                       search = base::search(), system = base::Sys.info())
[17:02:30.479]                   }
[17:02:30.479]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.479]                     cond$call), session = sessionInformation(), 
[17:02:30.479]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.479]                   signalCondition(cond)
[17:02:30.479]                 }
[17:02:30.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.479]                 "immediateCondition"))) {
[17:02:30.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.479]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.479]                   if (TRUE && !signal) {
[17:02:30.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.479]                     {
[17:02:30.479]                       inherits <- base::inherits
[17:02:30.479]                       invokeRestart <- base::invokeRestart
[17:02:30.479]                       is.null <- base::is.null
[17:02:30.479]                       muffled <- FALSE
[17:02:30.479]                       if (inherits(cond, "message")) {
[17:02:30.479]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.479]                         if (muffled) 
[17:02:30.479]                           invokeRestart("muffleMessage")
[17:02:30.479]                       }
[17:02:30.479]                       else if (inherits(cond, "warning")) {
[17:02:30.479]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.479]                         if (muffled) 
[17:02:30.479]                           invokeRestart("muffleWarning")
[17:02:30.479]                       }
[17:02:30.479]                       else if (inherits(cond, "condition")) {
[17:02:30.479]                         if (!is.null(pattern)) {
[17:02:30.479]                           computeRestarts <- base::computeRestarts
[17:02:30.479]                           grepl <- base::grepl
[17:02:30.479]                           restarts <- computeRestarts(cond)
[17:02:30.479]                           for (restart in restarts) {
[17:02:30.479]                             name <- restart$name
[17:02:30.479]                             if (is.null(name)) 
[17:02:30.479]                               next
[17:02:30.479]                             if (!grepl(pattern, name)) 
[17:02:30.479]                               next
[17:02:30.479]                             invokeRestart(restart)
[17:02:30.479]                             muffled <- TRUE
[17:02:30.479]                             break
[17:02:30.479]                           }
[17:02:30.479]                         }
[17:02:30.479]                       }
[17:02:30.479]                       invisible(muffled)
[17:02:30.479]                     }
[17:02:30.479]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.479]                   }
[17:02:30.479]                 }
[17:02:30.479]                 else {
[17:02:30.479]                   if (TRUE) {
[17:02:30.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.479]                     {
[17:02:30.479]                       inherits <- base::inherits
[17:02:30.479]                       invokeRestart <- base::invokeRestart
[17:02:30.479]                       is.null <- base::is.null
[17:02:30.479]                       muffled <- FALSE
[17:02:30.479]                       if (inherits(cond, "message")) {
[17:02:30.479]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.479]                         if (muffled) 
[17:02:30.479]                           invokeRestart("muffleMessage")
[17:02:30.479]                       }
[17:02:30.479]                       else if (inherits(cond, "warning")) {
[17:02:30.479]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.479]                         if (muffled) 
[17:02:30.479]                           invokeRestart("muffleWarning")
[17:02:30.479]                       }
[17:02:30.479]                       else if (inherits(cond, "condition")) {
[17:02:30.479]                         if (!is.null(pattern)) {
[17:02:30.479]                           computeRestarts <- base::computeRestarts
[17:02:30.479]                           grepl <- base::grepl
[17:02:30.479]                           restarts <- computeRestarts(cond)
[17:02:30.479]                           for (restart in restarts) {
[17:02:30.479]                             name <- restart$name
[17:02:30.479]                             if (is.null(name)) 
[17:02:30.479]                               next
[17:02:30.479]                             if (!grepl(pattern, name)) 
[17:02:30.479]                               next
[17:02:30.479]                             invokeRestart(restart)
[17:02:30.479]                             muffled <- TRUE
[17:02:30.479]                             break
[17:02:30.479]                           }
[17:02:30.479]                         }
[17:02:30.479]                       }
[17:02:30.479]                       invisible(muffled)
[17:02:30.479]                     }
[17:02:30.479]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.479]                   }
[17:02:30.479]                 }
[17:02:30.479]             }
[17:02:30.479]         }))
[17:02:30.479]     }, error = function(ex) {
[17:02:30.479]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.479]                 ...future.rng), started = ...future.startTime, 
[17:02:30.479]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.479]             version = "1.8"), class = "FutureResult")
[17:02:30.479]     }, finally = {
[17:02:30.479]         if (!identical(...future.workdir, getwd())) 
[17:02:30.479]             setwd(...future.workdir)
[17:02:30.479]         {
[17:02:30.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.479]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.479]             }
[17:02:30.479]             base::options(...future.oldOptions)
[17:02:30.479]             if (.Platform$OS.type == "windows") {
[17:02:30.479]                 old_names <- names(...future.oldEnvVars)
[17:02:30.479]                 envs <- base::Sys.getenv()
[17:02:30.479]                 names <- names(envs)
[17:02:30.479]                 common <- intersect(names, old_names)
[17:02:30.479]                 added <- setdiff(names, old_names)
[17:02:30.479]                 removed <- setdiff(old_names, names)
[17:02:30.479]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.479]                   envs[common]]
[17:02:30.479]                 NAMES <- toupper(changed)
[17:02:30.479]                 args <- list()
[17:02:30.479]                 for (kk in seq_along(NAMES)) {
[17:02:30.479]                   name <- changed[[kk]]
[17:02:30.479]                   NAME <- NAMES[[kk]]
[17:02:30.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.479]                     next
[17:02:30.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.479]                 }
[17:02:30.479]                 NAMES <- toupper(added)
[17:02:30.479]                 for (kk in seq_along(NAMES)) {
[17:02:30.479]                   name <- added[[kk]]
[17:02:30.479]                   NAME <- NAMES[[kk]]
[17:02:30.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.479]                     next
[17:02:30.479]                   args[[name]] <- ""
[17:02:30.479]                 }
[17:02:30.479]                 NAMES <- toupper(removed)
[17:02:30.479]                 for (kk in seq_along(NAMES)) {
[17:02:30.479]                   name <- removed[[kk]]
[17:02:30.479]                   NAME <- NAMES[[kk]]
[17:02:30.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.479]                     next
[17:02:30.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.479]                 }
[17:02:30.479]                 if (length(args) > 0) 
[17:02:30.479]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.479]             }
[17:02:30.479]             else {
[17:02:30.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.479]             }
[17:02:30.479]             {
[17:02:30.479]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.479]                   0L) {
[17:02:30.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.479]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.479]                   base::options(opts)
[17:02:30.479]                 }
[17:02:30.479]                 {
[17:02:30.479]                   {
[17:02:30.479]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.479]                     NULL
[17:02:30.479]                   }
[17:02:30.479]                   options(future.plan = NULL)
[17:02:30.479]                   if (is.na(NA_character_)) 
[17:02:30.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.479]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.479]                     .init = FALSE)
[17:02:30.479]                 }
[17:02:30.479]             }
[17:02:30.479]         }
[17:02:30.479]     })
[17:02:30.479]     if (TRUE) {
[17:02:30.479]         base::sink(type = "output", split = FALSE)
[17:02:30.479]         if (TRUE) {
[17:02:30.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.479]         }
[17:02:30.479]         else {
[17:02:30.479]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.479]         }
[17:02:30.479]         base::close(...future.stdout)
[17:02:30.479]         ...future.stdout <- NULL
[17:02:30.479]     }
[17:02:30.479]     ...future.result$conditions <- ...future.conditions
[17:02:30.479]     ...future.result$finished <- base::Sys.time()
[17:02:30.479]     ...future.result
[17:02:30.479] }
[17:02:30.481] MultisessionFuture started
[17:02:30.482] - Launch lazy future ... done
[17:02:30.482] run() for ‘MultisessionFuture’ ... done
[17:02:30.482] getGlobalsAndPackages() ...
[17:02:30.482] Searching for globals...
[17:02:30.482] 
[17:02:30.482] Searching for globals ... DONE
[17:02:30.482] - globals: [0] <none>
[17:02:30.482] getGlobalsAndPackages() ... DONE
[17:02:30.483] run() for ‘Future’ ...
[17:02:30.483] - state: ‘created’
[17:02:30.483] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.496] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.496] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:30.496]   - Field: ‘node’
[17:02:30.496]   - Field: ‘label’
[17:02:30.497]   - Field: ‘local’
[17:02:30.497]   - Field: ‘owner’
[17:02:30.497]   - Field: ‘envir’
[17:02:30.497]   - Field: ‘workers’
[17:02:30.497]   - Field: ‘packages’
[17:02:30.497]   - Field: ‘gc’
[17:02:30.497]   - Field: ‘conditions’
[17:02:30.497]   - Field: ‘persistent’
[17:02:30.497]   - Field: ‘expr’
[17:02:30.497]   - Field: ‘uuid’
[17:02:30.497]   - Field: ‘seed’
[17:02:30.498]   - Field: ‘version’
[17:02:30.498]   - Field: ‘result’
[17:02:30.498]   - Field: ‘asynchronous’
[17:02:30.498]   - Field: ‘calls’
[17:02:30.498]   - Field: ‘globals’
[17:02:30.498]   - Field: ‘stdout’
[17:02:30.498]   - Field: ‘earlySignal’
[17:02:30.498]   - Field: ‘lazy’
[17:02:30.498]   - Field: ‘state’
[17:02:30.498] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:30.498] - Launch lazy future ...
[17:02:30.499] Packages needed by the future expression (n = 0): <none>
[17:02:30.499] Packages needed by future strategies (n = 0): <none>
[17:02:30.499] {
[17:02:30.499]     {
[17:02:30.499]         {
[17:02:30.499]             ...future.startTime <- base::Sys.time()
[17:02:30.499]             {
[17:02:30.499]                 {
[17:02:30.499]                   {
[17:02:30.499]                     {
[17:02:30.499]                       base::local({
[17:02:30.499]                         has_future <- base::requireNamespace("future", 
[17:02:30.499]                           quietly = TRUE)
[17:02:30.499]                         if (has_future) {
[17:02:30.499]                           ns <- base::getNamespace("future")
[17:02:30.499]                           version <- ns[[".package"]][["version"]]
[17:02:30.499]                           if (is.null(version)) 
[17:02:30.499]                             version <- utils::packageVersion("future")
[17:02:30.499]                         }
[17:02:30.499]                         else {
[17:02:30.499]                           version <- NULL
[17:02:30.499]                         }
[17:02:30.499]                         if (!has_future || version < "1.8.0") {
[17:02:30.499]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.499]                             "", base::R.version$version.string), 
[17:02:30.499]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.499]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.499]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.499]                               "release", "version")], collapse = " "), 
[17:02:30.499]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.499]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.499]                             info)
[17:02:30.499]                           info <- base::paste(info, collapse = "; ")
[17:02:30.499]                           if (!has_future) {
[17:02:30.499]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.499]                               info)
[17:02:30.499]                           }
[17:02:30.499]                           else {
[17:02:30.499]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.499]                               info, version)
[17:02:30.499]                           }
[17:02:30.499]                           base::stop(msg)
[17:02:30.499]                         }
[17:02:30.499]                       })
[17:02:30.499]                     }
[17:02:30.499]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.499]                     base::options(mc.cores = 1L)
[17:02:30.499]                   }
[17:02:30.499]                   ...future.strategy.old <- future::plan("list")
[17:02:30.499]                   options(future.plan = NULL)
[17:02:30.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.499]                 }
[17:02:30.499]                 ...future.workdir <- getwd()
[17:02:30.499]             }
[17:02:30.499]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.499]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.499]         }
[17:02:30.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.499]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.499]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.499]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.499]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.499]             base::names(...future.oldOptions))
[17:02:30.499]     }
[17:02:30.499]     if (FALSE) {
[17:02:30.499]     }
[17:02:30.499]     else {
[17:02:30.499]         if (TRUE) {
[17:02:30.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.499]                 open = "w")
[17:02:30.499]         }
[17:02:30.499]         else {
[17:02:30.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.499]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.499]         }
[17:02:30.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.499]             base::sink(type = "output", split = FALSE)
[17:02:30.499]             base::close(...future.stdout)
[17:02:30.499]         }, add = TRUE)
[17:02:30.499]     }
[17:02:30.499]     ...future.frame <- base::sys.nframe()
[17:02:30.499]     ...future.conditions <- base::list()
[17:02:30.499]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.499]     if (FALSE) {
[17:02:30.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.499]     }
[17:02:30.499]     ...future.result <- base::tryCatch({
[17:02:30.499]         base::withCallingHandlers({
[17:02:30.499]             ...future.value <- base::withVisible(base::local({
[17:02:30.499]                 ...future.makeSendCondition <- base::local({
[17:02:30.499]                   sendCondition <- NULL
[17:02:30.499]                   function(frame = 1L) {
[17:02:30.499]                     if (is.function(sendCondition)) 
[17:02:30.499]                       return(sendCondition)
[17:02:30.499]                     ns <- getNamespace("parallel")
[17:02:30.499]                     if (exists("sendData", mode = "function", 
[17:02:30.499]                       envir = ns)) {
[17:02:30.499]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:30.499]                         envir = ns)
[17:02:30.499]                       envir <- sys.frame(frame)
[17:02:30.499]                       master <- NULL
[17:02:30.499]                       while (!identical(envir, .GlobalEnv) && 
[17:02:30.499]                         !identical(envir, emptyenv())) {
[17:02:30.499]                         if (exists("master", mode = "list", envir = envir, 
[17:02:30.499]                           inherits = FALSE)) {
[17:02:30.499]                           master <- get("master", mode = "list", 
[17:02:30.499]                             envir = envir, inherits = FALSE)
[17:02:30.499]                           if (inherits(master, c("SOCKnode", 
[17:02:30.499]                             "SOCK0node"))) {
[17:02:30.499]                             sendCondition <<- function(cond) {
[17:02:30.499]                               data <- list(type = "VALUE", value = cond, 
[17:02:30.499]                                 success = TRUE)
[17:02:30.499]                               parallel_sendData(master, data)
[17:02:30.499]                             }
[17:02:30.499]                             return(sendCondition)
[17:02:30.499]                           }
[17:02:30.499]                         }
[17:02:30.499]                         frame <- frame + 1L
[17:02:30.499]                         envir <- sys.frame(frame)
[17:02:30.499]                       }
[17:02:30.499]                     }
[17:02:30.499]                     sendCondition <<- function(cond) NULL
[17:02:30.499]                   }
[17:02:30.499]                 })
[17:02:30.499]                 withCallingHandlers({
[17:02:30.499]                   NULL
[17:02:30.499]                 }, immediateCondition = function(cond) {
[17:02:30.499]                   sendCondition <- ...future.makeSendCondition()
[17:02:30.499]                   sendCondition(cond)
[17:02:30.499]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.499]                   {
[17:02:30.499]                     inherits <- base::inherits
[17:02:30.499]                     invokeRestart <- base::invokeRestart
[17:02:30.499]                     is.null <- base::is.null
[17:02:30.499]                     muffled <- FALSE
[17:02:30.499]                     if (inherits(cond, "message")) {
[17:02:30.499]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.499]                       if (muffled) 
[17:02:30.499]                         invokeRestart("muffleMessage")
[17:02:30.499]                     }
[17:02:30.499]                     else if (inherits(cond, "warning")) {
[17:02:30.499]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.499]                       if (muffled) 
[17:02:30.499]                         invokeRestart("muffleWarning")
[17:02:30.499]                     }
[17:02:30.499]                     else if (inherits(cond, "condition")) {
[17:02:30.499]                       if (!is.null(pattern)) {
[17:02:30.499]                         computeRestarts <- base::computeRestarts
[17:02:30.499]                         grepl <- base::grepl
[17:02:30.499]                         restarts <- computeRestarts(cond)
[17:02:30.499]                         for (restart in restarts) {
[17:02:30.499]                           name <- restart$name
[17:02:30.499]                           if (is.null(name)) 
[17:02:30.499]                             next
[17:02:30.499]                           if (!grepl(pattern, name)) 
[17:02:30.499]                             next
[17:02:30.499]                           invokeRestart(restart)
[17:02:30.499]                           muffled <- TRUE
[17:02:30.499]                           break
[17:02:30.499]                         }
[17:02:30.499]                       }
[17:02:30.499]                     }
[17:02:30.499]                     invisible(muffled)
[17:02:30.499]                   }
[17:02:30.499]                   muffleCondition(cond)
[17:02:30.499]                 })
[17:02:30.499]             }))
[17:02:30.499]             future::FutureResult(value = ...future.value$value, 
[17:02:30.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.499]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.499]                     ...future.globalenv.names))
[17:02:30.499]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.499]         }, condition = base::local({
[17:02:30.499]             c <- base::c
[17:02:30.499]             inherits <- base::inherits
[17:02:30.499]             invokeRestart <- base::invokeRestart
[17:02:30.499]             length <- base::length
[17:02:30.499]             list <- base::list
[17:02:30.499]             seq.int <- base::seq.int
[17:02:30.499]             signalCondition <- base::signalCondition
[17:02:30.499]             sys.calls <- base::sys.calls
[17:02:30.499]             `[[` <- base::`[[`
[17:02:30.499]             `+` <- base::`+`
[17:02:30.499]             `<<-` <- base::`<<-`
[17:02:30.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.499]                   3L)]
[17:02:30.499]             }
[17:02:30.499]             function(cond) {
[17:02:30.499]                 is_error <- inherits(cond, "error")
[17:02:30.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.499]                   NULL)
[17:02:30.499]                 if (is_error) {
[17:02:30.499]                   sessionInformation <- function() {
[17:02:30.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.499]                       search = base::search(), system = base::Sys.info())
[17:02:30.499]                   }
[17:02:30.499]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.499]                     cond$call), session = sessionInformation(), 
[17:02:30.499]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.499]                   signalCondition(cond)
[17:02:30.499]                 }
[17:02:30.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.499]                 "immediateCondition"))) {
[17:02:30.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.499]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.499]                   if (TRUE && !signal) {
[17:02:30.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.499]                     {
[17:02:30.499]                       inherits <- base::inherits
[17:02:30.499]                       invokeRestart <- base::invokeRestart
[17:02:30.499]                       is.null <- base::is.null
[17:02:30.499]                       muffled <- FALSE
[17:02:30.499]                       if (inherits(cond, "message")) {
[17:02:30.499]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.499]                         if (muffled) 
[17:02:30.499]                           invokeRestart("muffleMessage")
[17:02:30.499]                       }
[17:02:30.499]                       else if (inherits(cond, "warning")) {
[17:02:30.499]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.499]                         if (muffled) 
[17:02:30.499]                           invokeRestart("muffleWarning")
[17:02:30.499]                       }
[17:02:30.499]                       else if (inherits(cond, "condition")) {
[17:02:30.499]                         if (!is.null(pattern)) {
[17:02:30.499]                           computeRestarts <- base::computeRestarts
[17:02:30.499]                           grepl <- base::grepl
[17:02:30.499]                           restarts <- computeRestarts(cond)
[17:02:30.499]                           for (restart in restarts) {
[17:02:30.499]                             name <- restart$name
[17:02:30.499]                             if (is.null(name)) 
[17:02:30.499]                               next
[17:02:30.499]                             if (!grepl(pattern, name)) 
[17:02:30.499]                               next
[17:02:30.499]                             invokeRestart(restart)
[17:02:30.499]                             muffled <- TRUE
[17:02:30.499]                             break
[17:02:30.499]                           }
[17:02:30.499]                         }
[17:02:30.499]                       }
[17:02:30.499]                       invisible(muffled)
[17:02:30.499]                     }
[17:02:30.499]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.499]                   }
[17:02:30.499]                 }
[17:02:30.499]                 else {
[17:02:30.499]                   if (TRUE) {
[17:02:30.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.499]                     {
[17:02:30.499]                       inherits <- base::inherits
[17:02:30.499]                       invokeRestart <- base::invokeRestart
[17:02:30.499]                       is.null <- base::is.null
[17:02:30.499]                       muffled <- FALSE
[17:02:30.499]                       if (inherits(cond, "message")) {
[17:02:30.499]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.499]                         if (muffled) 
[17:02:30.499]                           invokeRestart("muffleMessage")
[17:02:30.499]                       }
[17:02:30.499]                       else if (inherits(cond, "warning")) {
[17:02:30.499]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.499]                         if (muffled) 
[17:02:30.499]                           invokeRestart("muffleWarning")
[17:02:30.499]                       }
[17:02:30.499]                       else if (inherits(cond, "condition")) {
[17:02:30.499]                         if (!is.null(pattern)) {
[17:02:30.499]                           computeRestarts <- base::computeRestarts
[17:02:30.499]                           grepl <- base::grepl
[17:02:30.499]                           restarts <- computeRestarts(cond)
[17:02:30.499]                           for (restart in restarts) {
[17:02:30.499]                             name <- restart$name
[17:02:30.499]                             if (is.null(name)) 
[17:02:30.499]                               next
[17:02:30.499]                             if (!grepl(pattern, name)) 
[17:02:30.499]                               next
[17:02:30.499]                             invokeRestart(restart)
[17:02:30.499]                             muffled <- TRUE
[17:02:30.499]                             break
[17:02:30.499]                           }
[17:02:30.499]                         }
[17:02:30.499]                       }
[17:02:30.499]                       invisible(muffled)
[17:02:30.499]                     }
[17:02:30.499]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.499]                   }
[17:02:30.499]                 }
[17:02:30.499]             }
[17:02:30.499]         }))
[17:02:30.499]     }, error = function(ex) {
[17:02:30.499]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.499]                 ...future.rng), started = ...future.startTime, 
[17:02:30.499]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.499]             version = "1.8"), class = "FutureResult")
[17:02:30.499]     }, finally = {
[17:02:30.499]         if (!identical(...future.workdir, getwd())) 
[17:02:30.499]             setwd(...future.workdir)
[17:02:30.499]         {
[17:02:30.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.499]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.499]             }
[17:02:30.499]             base::options(...future.oldOptions)
[17:02:30.499]             if (.Platform$OS.type == "windows") {
[17:02:30.499]                 old_names <- names(...future.oldEnvVars)
[17:02:30.499]                 envs <- base::Sys.getenv()
[17:02:30.499]                 names <- names(envs)
[17:02:30.499]                 common <- intersect(names, old_names)
[17:02:30.499]                 added <- setdiff(names, old_names)
[17:02:30.499]                 removed <- setdiff(old_names, names)
[17:02:30.499]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.499]                   envs[common]]
[17:02:30.499]                 NAMES <- toupper(changed)
[17:02:30.499]                 args <- list()
[17:02:30.499]                 for (kk in seq_along(NAMES)) {
[17:02:30.499]                   name <- changed[[kk]]
[17:02:30.499]                   NAME <- NAMES[[kk]]
[17:02:30.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.499]                     next
[17:02:30.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.499]                 }
[17:02:30.499]                 NAMES <- toupper(added)
[17:02:30.499]                 for (kk in seq_along(NAMES)) {
[17:02:30.499]                   name <- added[[kk]]
[17:02:30.499]                   NAME <- NAMES[[kk]]
[17:02:30.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.499]                     next
[17:02:30.499]                   args[[name]] <- ""
[17:02:30.499]                 }
[17:02:30.499]                 NAMES <- toupper(removed)
[17:02:30.499]                 for (kk in seq_along(NAMES)) {
[17:02:30.499]                   name <- removed[[kk]]
[17:02:30.499]                   NAME <- NAMES[[kk]]
[17:02:30.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.499]                     next
[17:02:30.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.499]                 }
[17:02:30.499]                 if (length(args) > 0) 
[17:02:30.499]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.499]             }
[17:02:30.499]             else {
[17:02:30.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.499]             }
[17:02:30.499]             {
[17:02:30.499]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.499]                   0L) {
[17:02:30.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.499]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.499]                   base::options(opts)
[17:02:30.499]                 }
[17:02:30.499]                 {
[17:02:30.499]                   {
[17:02:30.499]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.499]                     NULL
[17:02:30.499]                   }
[17:02:30.499]                   options(future.plan = NULL)
[17:02:30.499]                   if (is.na(NA_character_)) 
[17:02:30.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.499]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.499]                     .init = FALSE)
[17:02:30.499]                 }
[17:02:30.499]             }
[17:02:30.499]         }
[17:02:30.499]     })
[17:02:30.499]     if (TRUE) {
[17:02:30.499]         base::sink(type = "output", split = FALSE)
[17:02:30.499]         if (TRUE) {
[17:02:30.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.499]         }
[17:02:30.499]         else {
[17:02:30.499]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.499]         }
[17:02:30.499]         base::close(...future.stdout)
[17:02:30.499]         ...future.stdout <- NULL
[17:02:30.499]     }
[17:02:30.499]     ...future.result$conditions <- ...future.conditions
[17:02:30.499]     ...future.result$finished <- base::Sys.time()
[17:02:30.499]     ...future.result
[17:02:30.499] }
[17:02:30.502] MultisessionFuture started
[17:02:30.502] - Launch lazy future ... done
[17:02:30.502] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74745e470> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74a124d68> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74745e470> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74a124d68> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:02:30.509] receiveMessageFromWorker() for ClusterFuture ...
[17:02:30.509] - Validating connection of MultisessionFuture
[17:02:30.509] - received message: FutureResult
[17:02:30.509] - Received FutureResult
[17:02:30.509] - Erased future from FutureRegistry
[17:02:30.509] result() for ClusterFuture ...
[17:02:30.509] - result already collected: FutureResult
[17:02:30.509] result() for ClusterFuture ... done
[17:02:30.509] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:30.510] receiveMessageFromWorker() for ClusterFuture ...
[17:02:30.510] - Validating connection of MultisessionFuture
[17:02:30.510] - received message: FutureResult
[17:02:30.510] - Received FutureResult
[17:02:30.510] - Erased future from FutureRegistry
[17:02:30.510] result() for ClusterFuture ...
[17:02:30.511] - result already collected: FutureResult
[17:02:30.511] result() for ClusterFuture ... done
[17:02:30.511] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:30.512] resolve() on list ...
[17:02:30.512]  recursive: 0
[17:02:30.513]  length: 6
[17:02:30.513]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:30.513] signalConditionsASAP(numeric, pos=1) ...
[17:02:30.513] - nx: 6
[17:02:30.513] - relay: TRUE
[17:02:30.513] - stdout: TRUE
[17:02:30.513] - signal: TRUE
[17:02:30.513] - resignal: FALSE
[17:02:30.513] - force: TRUE
[17:02:30.513] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.513] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.514]  - until=2
[17:02:30.514]  - relaying element #2
[17:02:30.514] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.514] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.514] signalConditionsASAP(NULL, pos=1) ... done
[17:02:30.514]  length: 5 (resolved future 1)
[17:02:30.514] Future #2
[17:02:30.514] result() for ClusterFuture ...
[17:02:30.514] - result already collected: FutureResult
[17:02:30.514] result() for ClusterFuture ... done
[17:02:30.514] result() for ClusterFuture ...
[17:02:30.514] - result already collected: FutureResult
[17:02:30.515] result() for ClusterFuture ... done
[17:02:30.515] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:30.515] - nx: 6
[17:02:30.515] - relay: TRUE
[17:02:30.515] - stdout: TRUE
[17:02:30.515] - signal: TRUE
[17:02:30.515] - resignal: FALSE
[17:02:30.515] - force: TRUE
[17:02:30.515] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.515] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.515]  - until=2
[17:02:30.516]  - relaying element #2
[17:02:30.516] result() for ClusterFuture ...
[17:02:30.516] - result already collected: FutureResult
[17:02:30.516] result() for ClusterFuture ... done
[17:02:30.516] result() for ClusterFuture ...
[17:02:30.516] - result already collected: FutureResult
[17:02:30.516] result() for ClusterFuture ... done
[17:02:30.516] result() for ClusterFuture ...
[17:02:30.516] - result already collected: FutureResult
[17:02:30.516] result() for ClusterFuture ... done
[17:02:30.516] result() for ClusterFuture ...
[17:02:30.516] - result already collected: FutureResult
[17:02:30.517] result() for ClusterFuture ... done
[17:02:30.517] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.517] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.517] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:30.517]  length: 4 (resolved future 2)
[17:02:30.517] Future #3
[17:02:30.517] result() for ClusterFuture ...
[17:02:30.517] - result already collected: FutureResult
[17:02:30.517] result() for ClusterFuture ... done
[17:02:30.517] result() for ClusterFuture ...
[17:02:30.517] - result already collected: FutureResult
[17:02:30.517] result() for ClusterFuture ... done
[17:02:30.518] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:30.518] - nx: 6
[17:02:30.518] - relay: TRUE
[17:02:30.518] - stdout: TRUE
[17:02:30.518] - signal: TRUE
[17:02:30.518] - resignal: FALSE
[17:02:30.518] - force: TRUE
[17:02:30.518] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.518] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.518]  - until=3
[17:02:30.518]  - relaying element #3
[17:02:30.518] result() for ClusterFuture ...
[17:02:30.519] - result already collected: FutureResult
[17:02:30.519] result() for ClusterFuture ... done
[17:02:30.519] result() for ClusterFuture ...
[17:02:30.519] - result already collected: FutureResult
[17:02:30.519] result() for ClusterFuture ... done
[17:02:30.519] result() for ClusterFuture ...
[17:02:30.519] - result already collected: FutureResult
[17:02:30.519] result() for ClusterFuture ... done
[17:02:30.519] result() for ClusterFuture ...
[17:02:30.519] - result already collected: FutureResult
[17:02:30.519] result() for ClusterFuture ... done
[17:02:30.520] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.520] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.520] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:30.520]  length: 3 (resolved future 3)
[17:02:30.520] signalConditionsASAP(NULL, pos=4) ...
[17:02:30.520] - nx: 6
[17:02:30.520] - relay: TRUE
[17:02:30.520] - stdout: TRUE
[17:02:30.520] - signal: TRUE
[17:02:30.520] - resignal: FALSE
[17:02:30.520] - force: TRUE
[17:02:30.520] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.520] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.521]  - until=5
[17:02:30.521]  - relaying element #5
[17:02:30.521] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:30.521] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.521] signalConditionsASAP(NULL, pos=4) ... done
[17:02:30.521]  length: 2 (resolved future 4)
[17:02:30.521] signalConditionsASAP(NULL, pos=5) ...
[17:02:30.521] - nx: 6
[17:02:30.521] - relay: TRUE
[17:02:30.521] - stdout: TRUE
[17:02:30.521] - signal: TRUE
[17:02:30.521] - resignal: FALSE
[17:02:30.522] - force: TRUE
[17:02:30.522] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:30.522] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.522]  - until=6
[17:02:30.522]  - relaying element #6
[17:02:30.522] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:30.522] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.522] signalConditionsASAP(NULL, pos=5) ... done
[17:02:30.522]  length: 1 (resolved future 5)
[17:02:30.522] signalConditionsASAP(numeric, pos=6) ...
[17:02:30.522] - nx: 6
[17:02:30.522] - relay: TRUE
[17:02:30.523] - stdout: TRUE
[17:02:30.523] - signal: TRUE
[17:02:30.523] - resignal: FALSE
[17:02:30.523] - force: TRUE
[17:02:30.523] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:30.523] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.523]  - until=6
[17:02:30.523] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.523] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.523] signalConditionsASAP(numeric, pos=6) ... done
[17:02:30.523]  length: 0 (resolved future 6)
[17:02:30.523] Relaying remaining futures
[17:02:30.524] signalConditionsASAP(NULL, pos=0) ...
[17:02:30.524] - nx: 6
[17:02:30.524] - relay: TRUE
[17:02:30.524] - stdout: TRUE
[17:02:30.524] - signal: TRUE
[17:02:30.524] - resignal: FALSE
[17:02:30.524] - force: TRUE
[17:02:30.524] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.524] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:30.524] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.524] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.524] signalConditionsASAP(NULL, pos=0) ... done
[17:02:30.525] resolve() on list ... DONE
[17:02:30.525] result() for ClusterFuture ...
[17:02:30.525] - result already collected: FutureResult
[17:02:30.525] result() for ClusterFuture ... done
[17:02:30.525] result() for ClusterFuture ...
[17:02:30.525] - result already collected: FutureResult
[17:02:30.525] result() for ClusterFuture ... done
[17:02:30.525] result() for ClusterFuture ...
[17:02:30.525] - result already collected: FutureResult
[17:02:30.525] result() for ClusterFuture ... done
[17:02:30.525] result() for ClusterFuture ...
[17:02:30.525] - result already collected: FutureResult
[17:02:30.526] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:02:30.529] getGlobalsAndPackages() ...
[17:02:30.529] Searching for globals...
[17:02:30.529] 
[17:02:30.529] Searching for globals ... DONE
[17:02:30.529] - globals: [0] <none>
[17:02:30.530] getGlobalsAndPackages() ... DONE
[17:02:30.530] run() for ‘Future’ ...
[17:02:30.530] - state: ‘created’
[17:02:30.530] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.544] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.544] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:30.544]   - Field: ‘node’
[17:02:30.544]   - Field: ‘label’
[17:02:30.544]   - Field: ‘local’
[17:02:30.544]   - Field: ‘owner’
[17:02:30.544]   - Field: ‘envir’
[17:02:30.544]   - Field: ‘workers’
[17:02:30.544]   - Field: ‘packages’
[17:02:30.544]   - Field: ‘gc’
[17:02:30.545]   - Field: ‘conditions’
[17:02:30.545]   - Field: ‘persistent’
[17:02:30.545]   - Field: ‘expr’
[17:02:30.545]   - Field: ‘uuid’
[17:02:30.545]   - Field: ‘seed’
[17:02:30.545]   - Field: ‘version’
[17:02:30.545]   - Field: ‘result’
[17:02:30.547]   - Field: ‘asynchronous’
[17:02:30.547]   - Field: ‘calls’
[17:02:30.547]   - Field: ‘globals’
[17:02:30.547]   - Field: ‘stdout’
[17:02:30.547]   - Field: ‘earlySignal’
[17:02:30.547]   - Field: ‘lazy’
[17:02:30.547]   - Field: ‘state’
[17:02:30.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:30.548] - Launch lazy future ...
[17:02:30.548] Packages needed by the future expression (n = 0): <none>
[17:02:30.548] Packages needed by future strategies (n = 0): <none>
[17:02:30.548] {
[17:02:30.548]     {
[17:02:30.548]         {
[17:02:30.548]             ...future.startTime <- base::Sys.time()
[17:02:30.548]             {
[17:02:30.548]                 {
[17:02:30.548]                   {
[17:02:30.548]                     {
[17:02:30.548]                       base::local({
[17:02:30.548]                         has_future <- base::requireNamespace("future", 
[17:02:30.548]                           quietly = TRUE)
[17:02:30.548]                         if (has_future) {
[17:02:30.548]                           ns <- base::getNamespace("future")
[17:02:30.548]                           version <- ns[[".package"]][["version"]]
[17:02:30.548]                           if (is.null(version)) 
[17:02:30.548]                             version <- utils::packageVersion("future")
[17:02:30.548]                         }
[17:02:30.548]                         else {
[17:02:30.548]                           version <- NULL
[17:02:30.548]                         }
[17:02:30.548]                         if (!has_future || version < "1.8.0") {
[17:02:30.548]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.548]                             "", base::R.version$version.string), 
[17:02:30.548]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.548]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.548]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.548]                               "release", "version")], collapse = " "), 
[17:02:30.548]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.548]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.548]                             info)
[17:02:30.548]                           info <- base::paste(info, collapse = "; ")
[17:02:30.548]                           if (!has_future) {
[17:02:30.548]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.548]                               info)
[17:02:30.548]                           }
[17:02:30.548]                           else {
[17:02:30.548]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.548]                               info, version)
[17:02:30.548]                           }
[17:02:30.548]                           base::stop(msg)
[17:02:30.548]                         }
[17:02:30.548]                       })
[17:02:30.548]                     }
[17:02:30.548]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.548]                     base::options(mc.cores = 1L)
[17:02:30.548]                   }
[17:02:30.548]                   ...future.strategy.old <- future::plan("list")
[17:02:30.548]                   options(future.plan = NULL)
[17:02:30.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.548]                 }
[17:02:30.548]                 ...future.workdir <- getwd()
[17:02:30.548]             }
[17:02:30.548]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.548]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.548]         }
[17:02:30.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.548]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.548]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.548]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.548]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.548]             base::names(...future.oldOptions))
[17:02:30.548]     }
[17:02:30.548]     if (FALSE) {
[17:02:30.548]     }
[17:02:30.548]     else {
[17:02:30.548]         if (TRUE) {
[17:02:30.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.548]                 open = "w")
[17:02:30.548]         }
[17:02:30.548]         else {
[17:02:30.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.548]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.548]         }
[17:02:30.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.548]             base::sink(type = "output", split = FALSE)
[17:02:30.548]             base::close(...future.stdout)
[17:02:30.548]         }, add = TRUE)
[17:02:30.548]     }
[17:02:30.548]     ...future.frame <- base::sys.nframe()
[17:02:30.548]     ...future.conditions <- base::list()
[17:02:30.548]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.548]     if (FALSE) {
[17:02:30.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.548]     }
[17:02:30.548]     ...future.result <- base::tryCatch({
[17:02:30.548]         base::withCallingHandlers({
[17:02:30.548]             ...future.value <- base::withVisible(base::local({
[17:02:30.548]                 ...future.makeSendCondition <- base::local({
[17:02:30.548]                   sendCondition <- NULL
[17:02:30.548]                   function(frame = 1L) {
[17:02:30.548]                     if (is.function(sendCondition)) 
[17:02:30.548]                       return(sendCondition)
[17:02:30.548]                     ns <- getNamespace("parallel")
[17:02:30.548]                     if (exists("sendData", mode = "function", 
[17:02:30.548]                       envir = ns)) {
[17:02:30.548]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:30.548]                         envir = ns)
[17:02:30.548]                       envir <- sys.frame(frame)
[17:02:30.548]                       master <- NULL
[17:02:30.548]                       while (!identical(envir, .GlobalEnv) && 
[17:02:30.548]                         !identical(envir, emptyenv())) {
[17:02:30.548]                         if (exists("master", mode = "list", envir = envir, 
[17:02:30.548]                           inherits = FALSE)) {
[17:02:30.548]                           master <- get("master", mode = "list", 
[17:02:30.548]                             envir = envir, inherits = FALSE)
[17:02:30.548]                           if (inherits(master, c("SOCKnode", 
[17:02:30.548]                             "SOCK0node"))) {
[17:02:30.548]                             sendCondition <<- function(cond) {
[17:02:30.548]                               data <- list(type = "VALUE", value = cond, 
[17:02:30.548]                                 success = TRUE)
[17:02:30.548]                               parallel_sendData(master, data)
[17:02:30.548]                             }
[17:02:30.548]                             return(sendCondition)
[17:02:30.548]                           }
[17:02:30.548]                         }
[17:02:30.548]                         frame <- frame + 1L
[17:02:30.548]                         envir <- sys.frame(frame)
[17:02:30.548]                       }
[17:02:30.548]                     }
[17:02:30.548]                     sendCondition <<- function(cond) NULL
[17:02:30.548]                   }
[17:02:30.548]                 })
[17:02:30.548]                 withCallingHandlers({
[17:02:30.548]                   2
[17:02:30.548]                 }, immediateCondition = function(cond) {
[17:02:30.548]                   sendCondition <- ...future.makeSendCondition()
[17:02:30.548]                   sendCondition(cond)
[17:02:30.548]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.548]                   {
[17:02:30.548]                     inherits <- base::inherits
[17:02:30.548]                     invokeRestart <- base::invokeRestart
[17:02:30.548]                     is.null <- base::is.null
[17:02:30.548]                     muffled <- FALSE
[17:02:30.548]                     if (inherits(cond, "message")) {
[17:02:30.548]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.548]                       if (muffled) 
[17:02:30.548]                         invokeRestart("muffleMessage")
[17:02:30.548]                     }
[17:02:30.548]                     else if (inherits(cond, "warning")) {
[17:02:30.548]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.548]                       if (muffled) 
[17:02:30.548]                         invokeRestart("muffleWarning")
[17:02:30.548]                     }
[17:02:30.548]                     else if (inherits(cond, "condition")) {
[17:02:30.548]                       if (!is.null(pattern)) {
[17:02:30.548]                         computeRestarts <- base::computeRestarts
[17:02:30.548]                         grepl <- base::grepl
[17:02:30.548]                         restarts <- computeRestarts(cond)
[17:02:30.548]                         for (restart in restarts) {
[17:02:30.548]                           name <- restart$name
[17:02:30.548]                           if (is.null(name)) 
[17:02:30.548]                             next
[17:02:30.548]                           if (!grepl(pattern, name)) 
[17:02:30.548]                             next
[17:02:30.548]                           invokeRestart(restart)
[17:02:30.548]                           muffled <- TRUE
[17:02:30.548]                           break
[17:02:30.548]                         }
[17:02:30.548]                       }
[17:02:30.548]                     }
[17:02:30.548]                     invisible(muffled)
[17:02:30.548]                   }
[17:02:30.548]                   muffleCondition(cond)
[17:02:30.548]                 })
[17:02:30.548]             }))
[17:02:30.548]             future::FutureResult(value = ...future.value$value, 
[17:02:30.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.548]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.548]                     ...future.globalenv.names))
[17:02:30.548]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.548]         }, condition = base::local({
[17:02:30.548]             c <- base::c
[17:02:30.548]             inherits <- base::inherits
[17:02:30.548]             invokeRestart <- base::invokeRestart
[17:02:30.548]             length <- base::length
[17:02:30.548]             list <- base::list
[17:02:30.548]             seq.int <- base::seq.int
[17:02:30.548]             signalCondition <- base::signalCondition
[17:02:30.548]             sys.calls <- base::sys.calls
[17:02:30.548]             `[[` <- base::`[[`
[17:02:30.548]             `+` <- base::`+`
[17:02:30.548]             `<<-` <- base::`<<-`
[17:02:30.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.548]                   3L)]
[17:02:30.548]             }
[17:02:30.548]             function(cond) {
[17:02:30.548]                 is_error <- inherits(cond, "error")
[17:02:30.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.548]                   NULL)
[17:02:30.548]                 if (is_error) {
[17:02:30.548]                   sessionInformation <- function() {
[17:02:30.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.548]                       search = base::search(), system = base::Sys.info())
[17:02:30.548]                   }
[17:02:30.548]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.548]                     cond$call), session = sessionInformation(), 
[17:02:30.548]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.548]                   signalCondition(cond)
[17:02:30.548]                 }
[17:02:30.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.548]                 "immediateCondition"))) {
[17:02:30.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.548]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.548]                   if (TRUE && !signal) {
[17:02:30.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.548]                     {
[17:02:30.548]                       inherits <- base::inherits
[17:02:30.548]                       invokeRestart <- base::invokeRestart
[17:02:30.548]                       is.null <- base::is.null
[17:02:30.548]                       muffled <- FALSE
[17:02:30.548]                       if (inherits(cond, "message")) {
[17:02:30.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.548]                         if (muffled) 
[17:02:30.548]                           invokeRestart("muffleMessage")
[17:02:30.548]                       }
[17:02:30.548]                       else if (inherits(cond, "warning")) {
[17:02:30.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.548]                         if (muffled) 
[17:02:30.548]                           invokeRestart("muffleWarning")
[17:02:30.548]                       }
[17:02:30.548]                       else if (inherits(cond, "condition")) {
[17:02:30.548]                         if (!is.null(pattern)) {
[17:02:30.548]                           computeRestarts <- base::computeRestarts
[17:02:30.548]                           grepl <- base::grepl
[17:02:30.548]                           restarts <- computeRestarts(cond)
[17:02:30.548]                           for (restart in restarts) {
[17:02:30.548]                             name <- restart$name
[17:02:30.548]                             if (is.null(name)) 
[17:02:30.548]                               next
[17:02:30.548]                             if (!grepl(pattern, name)) 
[17:02:30.548]                               next
[17:02:30.548]                             invokeRestart(restart)
[17:02:30.548]                             muffled <- TRUE
[17:02:30.548]                             break
[17:02:30.548]                           }
[17:02:30.548]                         }
[17:02:30.548]                       }
[17:02:30.548]                       invisible(muffled)
[17:02:30.548]                     }
[17:02:30.548]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.548]                   }
[17:02:30.548]                 }
[17:02:30.548]                 else {
[17:02:30.548]                   if (TRUE) {
[17:02:30.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.548]                     {
[17:02:30.548]                       inherits <- base::inherits
[17:02:30.548]                       invokeRestart <- base::invokeRestart
[17:02:30.548]                       is.null <- base::is.null
[17:02:30.548]                       muffled <- FALSE
[17:02:30.548]                       if (inherits(cond, "message")) {
[17:02:30.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.548]                         if (muffled) 
[17:02:30.548]                           invokeRestart("muffleMessage")
[17:02:30.548]                       }
[17:02:30.548]                       else if (inherits(cond, "warning")) {
[17:02:30.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.548]                         if (muffled) 
[17:02:30.548]                           invokeRestart("muffleWarning")
[17:02:30.548]                       }
[17:02:30.548]                       else if (inherits(cond, "condition")) {
[17:02:30.548]                         if (!is.null(pattern)) {
[17:02:30.548]                           computeRestarts <- base::computeRestarts
[17:02:30.548]                           grepl <- base::grepl
[17:02:30.548]                           restarts <- computeRestarts(cond)
[17:02:30.548]                           for (restart in restarts) {
[17:02:30.548]                             name <- restart$name
[17:02:30.548]                             if (is.null(name)) 
[17:02:30.548]                               next
[17:02:30.548]                             if (!grepl(pattern, name)) 
[17:02:30.548]                               next
[17:02:30.548]                             invokeRestart(restart)
[17:02:30.548]                             muffled <- TRUE
[17:02:30.548]                             break
[17:02:30.548]                           }
[17:02:30.548]                         }
[17:02:30.548]                       }
[17:02:30.548]                       invisible(muffled)
[17:02:30.548]                     }
[17:02:30.548]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.548]                   }
[17:02:30.548]                 }
[17:02:30.548]             }
[17:02:30.548]         }))
[17:02:30.548]     }, error = function(ex) {
[17:02:30.548]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.548]                 ...future.rng), started = ...future.startTime, 
[17:02:30.548]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.548]             version = "1.8"), class = "FutureResult")
[17:02:30.548]     }, finally = {
[17:02:30.548]         if (!identical(...future.workdir, getwd())) 
[17:02:30.548]             setwd(...future.workdir)
[17:02:30.548]         {
[17:02:30.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.548]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.548]             }
[17:02:30.548]             base::options(...future.oldOptions)
[17:02:30.548]             if (.Platform$OS.type == "windows") {
[17:02:30.548]                 old_names <- names(...future.oldEnvVars)
[17:02:30.548]                 envs <- base::Sys.getenv()
[17:02:30.548]                 names <- names(envs)
[17:02:30.548]                 common <- intersect(names, old_names)
[17:02:30.548]                 added <- setdiff(names, old_names)
[17:02:30.548]                 removed <- setdiff(old_names, names)
[17:02:30.548]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.548]                   envs[common]]
[17:02:30.548]                 NAMES <- toupper(changed)
[17:02:30.548]                 args <- list()
[17:02:30.548]                 for (kk in seq_along(NAMES)) {
[17:02:30.548]                   name <- changed[[kk]]
[17:02:30.548]                   NAME <- NAMES[[kk]]
[17:02:30.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.548]                     next
[17:02:30.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.548]                 }
[17:02:30.548]                 NAMES <- toupper(added)
[17:02:30.548]                 for (kk in seq_along(NAMES)) {
[17:02:30.548]                   name <- added[[kk]]
[17:02:30.548]                   NAME <- NAMES[[kk]]
[17:02:30.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.548]                     next
[17:02:30.548]                   args[[name]] <- ""
[17:02:30.548]                 }
[17:02:30.548]                 NAMES <- toupper(removed)
[17:02:30.548]                 for (kk in seq_along(NAMES)) {
[17:02:30.548]                   name <- removed[[kk]]
[17:02:30.548]                   NAME <- NAMES[[kk]]
[17:02:30.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.548]                     next
[17:02:30.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.548]                 }
[17:02:30.548]                 if (length(args) > 0) 
[17:02:30.548]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.548]             }
[17:02:30.548]             else {
[17:02:30.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.548]             }
[17:02:30.548]             {
[17:02:30.548]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.548]                   0L) {
[17:02:30.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.548]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.548]                   base::options(opts)
[17:02:30.548]                 }
[17:02:30.548]                 {
[17:02:30.548]                   {
[17:02:30.548]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.548]                     NULL
[17:02:30.548]                   }
[17:02:30.548]                   options(future.plan = NULL)
[17:02:30.548]                   if (is.na(NA_character_)) 
[17:02:30.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.548]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.548]                     .init = FALSE)
[17:02:30.548]                 }
[17:02:30.548]             }
[17:02:30.548]         }
[17:02:30.548]     })
[17:02:30.548]     if (TRUE) {
[17:02:30.548]         base::sink(type = "output", split = FALSE)
[17:02:30.548]         if (TRUE) {
[17:02:30.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.548]         }
[17:02:30.548]         else {
[17:02:30.548]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.548]         }
[17:02:30.548]         base::close(...future.stdout)
[17:02:30.548]         ...future.stdout <- NULL
[17:02:30.548]     }
[17:02:30.548]     ...future.result$conditions <- ...future.conditions
[17:02:30.548]     ...future.result$finished <- base::Sys.time()
[17:02:30.548]     ...future.result
[17:02:30.548] }
[17:02:30.551] MultisessionFuture started
[17:02:30.551] - Launch lazy future ... done
[17:02:30.552] run() for ‘MultisessionFuture’ ... done
[17:02:30.552] getGlobalsAndPackages() ...
[17:02:30.552] Searching for globals...
[17:02:30.552] 
[17:02:30.552] Searching for globals ... DONE
[17:02:30.552] - globals: [0] <none>
[17:02:30.552] getGlobalsAndPackages() ... DONE
[17:02:30.553] run() for ‘Future’ ...
[17:02:30.553] - state: ‘created’
[17:02:30.553] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.567] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.567] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:30.567]   - Field: ‘node’
[17:02:30.567]   - Field: ‘label’
[17:02:30.567]   - Field: ‘local’
[17:02:30.567]   - Field: ‘owner’
[17:02:30.567]   - Field: ‘envir’
[17:02:30.567]   - Field: ‘workers’
[17:02:30.567]   - Field: ‘packages’
[17:02:30.568]   - Field: ‘gc’
[17:02:30.568]   - Field: ‘conditions’
[17:02:30.568]   - Field: ‘persistent’
[17:02:30.568]   - Field: ‘expr’
[17:02:30.568]   - Field: ‘uuid’
[17:02:30.568]   - Field: ‘seed’
[17:02:30.568]   - Field: ‘version’
[17:02:30.568]   - Field: ‘result’
[17:02:30.568]   - Field: ‘asynchronous’
[17:02:30.568]   - Field: ‘calls’
[17:02:30.568]   - Field: ‘globals’
[17:02:30.568]   - Field: ‘stdout’
[17:02:30.569]   - Field: ‘earlySignal’
[17:02:30.569]   - Field: ‘lazy’
[17:02:30.569]   - Field: ‘state’
[17:02:30.569] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:30.569] - Launch lazy future ...
[17:02:30.569] Packages needed by the future expression (n = 0): <none>
[17:02:30.569] Packages needed by future strategies (n = 0): <none>
[17:02:30.570] {
[17:02:30.570]     {
[17:02:30.570]         {
[17:02:30.570]             ...future.startTime <- base::Sys.time()
[17:02:30.570]             {
[17:02:30.570]                 {
[17:02:30.570]                   {
[17:02:30.570]                     {
[17:02:30.570]                       base::local({
[17:02:30.570]                         has_future <- base::requireNamespace("future", 
[17:02:30.570]                           quietly = TRUE)
[17:02:30.570]                         if (has_future) {
[17:02:30.570]                           ns <- base::getNamespace("future")
[17:02:30.570]                           version <- ns[[".package"]][["version"]]
[17:02:30.570]                           if (is.null(version)) 
[17:02:30.570]                             version <- utils::packageVersion("future")
[17:02:30.570]                         }
[17:02:30.570]                         else {
[17:02:30.570]                           version <- NULL
[17:02:30.570]                         }
[17:02:30.570]                         if (!has_future || version < "1.8.0") {
[17:02:30.570]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.570]                             "", base::R.version$version.string), 
[17:02:30.570]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.570]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.570]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.570]                               "release", "version")], collapse = " "), 
[17:02:30.570]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.570]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.570]                             info)
[17:02:30.570]                           info <- base::paste(info, collapse = "; ")
[17:02:30.570]                           if (!has_future) {
[17:02:30.570]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.570]                               info)
[17:02:30.570]                           }
[17:02:30.570]                           else {
[17:02:30.570]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.570]                               info, version)
[17:02:30.570]                           }
[17:02:30.570]                           base::stop(msg)
[17:02:30.570]                         }
[17:02:30.570]                       })
[17:02:30.570]                     }
[17:02:30.570]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.570]                     base::options(mc.cores = 1L)
[17:02:30.570]                   }
[17:02:30.570]                   ...future.strategy.old <- future::plan("list")
[17:02:30.570]                   options(future.plan = NULL)
[17:02:30.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.570]                 }
[17:02:30.570]                 ...future.workdir <- getwd()
[17:02:30.570]             }
[17:02:30.570]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.570]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.570]         }
[17:02:30.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.570]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.570]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.570]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.570]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.570]             base::names(...future.oldOptions))
[17:02:30.570]     }
[17:02:30.570]     if (FALSE) {
[17:02:30.570]     }
[17:02:30.570]     else {
[17:02:30.570]         if (TRUE) {
[17:02:30.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.570]                 open = "w")
[17:02:30.570]         }
[17:02:30.570]         else {
[17:02:30.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.570]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.570]         }
[17:02:30.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.570]             base::sink(type = "output", split = FALSE)
[17:02:30.570]             base::close(...future.stdout)
[17:02:30.570]         }, add = TRUE)
[17:02:30.570]     }
[17:02:30.570]     ...future.frame <- base::sys.nframe()
[17:02:30.570]     ...future.conditions <- base::list()
[17:02:30.570]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.570]     if (FALSE) {
[17:02:30.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.570]     }
[17:02:30.570]     ...future.result <- base::tryCatch({
[17:02:30.570]         base::withCallingHandlers({
[17:02:30.570]             ...future.value <- base::withVisible(base::local({
[17:02:30.570]                 ...future.makeSendCondition <- base::local({
[17:02:30.570]                   sendCondition <- NULL
[17:02:30.570]                   function(frame = 1L) {
[17:02:30.570]                     if (is.function(sendCondition)) 
[17:02:30.570]                       return(sendCondition)
[17:02:30.570]                     ns <- getNamespace("parallel")
[17:02:30.570]                     if (exists("sendData", mode = "function", 
[17:02:30.570]                       envir = ns)) {
[17:02:30.570]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:30.570]                         envir = ns)
[17:02:30.570]                       envir <- sys.frame(frame)
[17:02:30.570]                       master <- NULL
[17:02:30.570]                       while (!identical(envir, .GlobalEnv) && 
[17:02:30.570]                         !identical(envir, emptyenv())) {
[17:02:30.570]                         if (exists("master", mode = "list", envir = envir, 
[17:02:30.570]                           inherits = FALSE)) {
[17:02:30.570]                           master <- get("master", mode = "list", 
[17:02:30.570]                             envir = envir, inherits = FALSE)
[17:02:30.570]                           if (inherits(master, c("SOCKnode", 
[17:02:30.570]                             "SOCK0node"))) {
[17:02:30.570]                             sendCondition <<- function(cond) {
[17:02:30.570]                               data <- list(type = "VALUE", value = cond, 
[17:02:30.570]                                 success = TRUE)
[17:02:30.570]                               parallel_sendData(master, data)
[17:02:30.570]                             }
[17:02:30.570]                             return(sendCondition)
[17:02:30.570]                           }
[17:02:30.570]                         }
[17:02:30.570]                         frame <- frame + 1L
[17:02:30.570]                         envir <- sys.frame(frame)
[17:02:30.570]                       }
[17:02:30.570]                     }
[17:02:30.570]                     sendCondition <<- function(cond) NULL
[17:02:30.570]                   }
[17:02:30.570]                 })
[17:02:30.570]                 withCallingHandlers({
[17:02:30.570]                   NULL
[17:02:30.570]                 }, immediateCondition = function(cond) {
[17:02:30.570]                   sendCondition <- ...future.makeSendCondition()
[17:02:30.570]                   sendCondition(cond)
[17:02:30.570]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.570]                   {
[17:02:30.570]                     inherits <- base::inherits
[17:02:30.570]                     invokeRestart <- base::invokeRestart
[17:02:30.570]                     is.null <- base::is.null
[17:02:30.570]                     muffled <- FALSE
[17:02:30.570]                     if (inherits(cond, "message")) {
[17:02:30.570]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.570]                       if (muffled) 
[17:02:30.570]                         invokeRestart("muffleMessage")
[17:02:30.570]                     }
[17:02:30.570]                     else if (inherits(cond, "warning")) {
[17:02:30.570]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.570]                       if (muffled) 
[17:02:30.570]                         invokeRestart("muffleWarning")
[17:02:30.570]                     }
[17:02:30.570]                     else if (inherits(cond, "condition")) {
[17:02:30.570]                       if (!is.null(pattern)) {
[17:02:30.570]                         computeRestarts <- base::computeRestarts
[17:02:30.570]                         grepl <- base::grepl
[17:02:30.570]                         restarts <- computeRestarts(cond)
[17:02:30.570]                         for (restart in restarts) {
[17:02:30.570]                           name <- restart$name
[17:02:30.570]                           if (is.null(name)) 
[17:02:30.570]                             next
[17:02:30.570]                           if (!grepl(pattern, name)) 
[17:02:30.570]                             next
[17:02:30.570]                           invokeRestart(restart)
[17:02:30.570]                           muffled <- TRUE
[17:02:30.570]                           break
[17:02:30.570]                         }
[17:02:30.570]                       }
[17:02:30.570]                     }
[17:02:30.570]                     invisible(muffled)
[17:02:30.570]                   }
[17:02:30.570]                   muffleCondition(cond)
[17:02:30.570]                 })
[17:02:30.570]             }))
[17:02:30.570]             future::FutureResult(value = ...future.value$value, 
[17:02:30.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.570]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.570]                     ...future.globalenv.names))
[17:02:30.570]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.570]         }, condition = base::local({
[17:02:30.570]             c <- base::c
[17:02:30.570]             inherits <- base::inherits
[17:02:30.570]             invokeRestart <- base::invokeRestart
[17:02:30.570]             length <- base::length
[17:02:30.570]             list <- base::list
[17:02:30.570]             seq.int <- base::seq.int
[17:02:30.570]             signalCondition <- base::signalCondition
[17:02:30.570]             sys.calls <- base::sys.calls
[17:02:30.570]             `[[` <- base::`[[`
[17:02:30.570]             `+` <- base::`+`
[17:02:30.570]             `<<-` <- base::`<<-`
[17:02:30.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.570]                   3L)]
[17:02:30.570]             }
[17:02:30.570]             function(cond) {
[17:02:30.570]                 is_error <- inherits(cond, "error")
[17:02:30.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.570]                   NULL)
[17:02:30.570]                 if (is_error) {
[17:02:30.570]                   sessionInformation <- function() {
[17:02:30.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.570]                       search = base::search(), system = base::Sys.info())
[17:02:30.570]                   }
[17:02:30.570]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.570]                     cond$call), session = sessionInformation(), 
[17:02:30.570]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.570]                   signalCondition(cond)
[17:02:30.570]                 }
[17:02:30.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.570]                 "immediateCondition"))) {
[17:02:30.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.570]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.570]                   if (TRUE && !signal) {
[17:02:30.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.570]                     {
[17:02:30.570]                       inherits <- base::inherits
[17:02:30.570]                       invokeRestart <- base::invokeRestart
[17:02:30.570]                       is.null <- base::is.null
[17:02:30.570]                       muffled <- FALSE
[17:02:30.570]                       if (inherits(cond, "message")) {
[17:02:30.570]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.570]                         if (muffled) 
[17:02:30.570]                           invokeRestart("muffleMessage")
[17:02:30.570]                       }
[17:02:30.570]                       else if (inherits(cond, "warning")) {
[17:02:30.570]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.570]                         if (muffled) 
[17:02:30.570]                           invokeRestart("muffleWarning")
[17:02:30.570]                       }
[17:02:30.570]                       else if (inherits(cond, "condition")) {
[17:02:30.570]                         if (!is.null(pattern)) {
[17:02:30.570]                           computeRestarts <- base::computeRestarts
[17:02:30.570]                           grepl <- base::grepl
[17:02:30.570]                           restarts <- computeRestarts(cond)
[17:02:30.570]                           for (restart in restarts) {
[17:02:30.570]                             name <- restart$name
[17:02:30.570]                             if (is.null(name)) 
[17:02:30.570]                               next
[17:02:30.570]                             if (!grepl(pattern, name)) 
[17:02:30.570]                               next
[17:02:30.570]                             invokeRestart(restart)
[17:02:30.570]                             muffled <- TRUE
[17:02:30.570]                             break
[17:02:30.570]                           }
[17:02:30.570]                         }
[17:02:30.570]                       }
[17:02:30.570]                       invisible(muffled)
[17:02:30.570]                     }
[17:02:30.570]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.570]                   }
[17:02:30.570]                 }
[17:02:30.570]                 else {
[17:02:30.570]                   if (TRUE) {
[17:02:30.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.570]                     {
[17:02:30.570]                       inherits <- base::inherits
[17:02:30.570]                       invokeRestart <- base::invokeRestart
[17:02:30.570]                       is.null <- base::is.null
[17:02:30.570]                       muffled <- FALSE
[17:02:30.570]                       if (inherits(cond, "message")) {
[17:02:30.570]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.570]                         if (muffled) 
[17:02:30.570]                           invokeRestart("muffleMessage")
[17:02:30.570]                       }
[17:02:30.570]                       else if (inherits(cond, "warning")) {
[17:02:30.570]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.570]                         if (muffled) 
[17:02:30.570]                           invokeRestart("muffleWarning")
[17:02:30.570]                       }
[17:02:30.570]                       else if (inherits(cond, "condition")) {
[17:02:30.570]                         if (!is.null(pattern)) {
[17:02:30.570]                           computeRestarts <- base::computeRestarts
[17:02:30.570]                           grepl <- base::grepl
[17:02:30.570]                           restarts <- computeRestarts(cond)
[17:02:30.570]                           for (restart in restarts) {
[17:02:30.570]                             name <- restart$name
[17:02:30.570]                             if (is.null(name)) 
[17:02:30.570]                               next
[17:02:30.570]                             if (!grepl(pattern, name)) 
[17:02:30.570]                               next
[17:02:30.570]                             invokeRestart(restart)
[17:02:30.570]                             muffled <- TRUE
[17:02:30.570]                             break
[17:02:30.570]                           }
[17:02:30.570]                         }
[17:02:30.570]                       }
[17:02:30.570]                       invisible(muffled)
[17:02:30.570]                     }
[17:02:30.570]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.570]                   }
[17:02:30.570]                 }
[17:02:30.570]             }
[17:02:30.570]         }))
[17:02:30.570]     }, error = function(ex) {
[17:02:30.570]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.570]                 ...future.rng), started = ...future.startTime, 
[17:02:30.570]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.570]             version = "1.8"), class = "FutureResult")
[17:02:30.570]     }, finally = {
[17:02:30.570]         if (!identical(...future.workdir, getwd())) 
[17:02:30.570]             setwd(...future.workdir)
[17:02:30.570]         {
[17:02:30.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.570]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.570]             }
[17:02:30.570]             base::options(...future.oldOptions)
[17:02:30.570]             if (.Platform$OS.type == "windows") {
[17:02:30.570]                 old_names <- names(...future.oldEnvVars)
[17:02:30.570]                 envs <- base::Sys.getenv()
[17:02:30.570]                 names <- names(envs)
[17:02:30.570]                 common <- intersect(names, old_names)
[17:02:30.570]                 added <- setdiff(names, old_names)
[17:02:30.570]                 removed <- setdiff(old_names, names)
[17:02:30.570]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.570]                   envs[common]]
[17:02:30.570]                 NAMES <- toupper(changed)
[17:02:30.570]                 args <- list()
[17:02:30.570]                 for (kk in seq_along(NAMES)) {
[17:02:30.570]                   name <- changed[[kk]]
[17:02:30.570]                   NAME <- NAMES[[kk]]
[17:02:30.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.570]                     next
[17:02:30.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.570]                 }
[17:02:30.570]                 NAMES <- toupper(added)
[17:02:30.570]                 for (kk in seq_along(NAMES)) {
[17:02:30.570]                   name <- added[[kk]]
[17:02:30.570]                   NAME <- NAMES[[kk]]
[17:02:30.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.570]                     next
[17:02:30.570]                   args[[name]] <- ""
[17:02:30.570]                 }
[17:02:30.570]                 NAMES <- toupper(removed)
[17:02:30.570]                 for (kk in seq_along(NAMES)) {
[17:02:30.570]                   name <- removed[[kk]]
[17:02:30.570]                   NAME <- NAMES[[kk]]
[17:02:30.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.570]                     next
[17:02:30.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.570]                 }
[17:02:30.570]                 if (length(args) > 0) 
[17:02:30.570]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.570]             }
[17:02:30.570]             else {
[17:02:30.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.570]             }
[17:02:30.570]             {
[17:02:30.570]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.570]                   0L) {
[17:02:30.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.570]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.570]                   base::options(opts)
[17:02:30.570]                 }
[17:02:30.570]                 {
[17:02:30.570]                   {
[17:02:30.570]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.570]                     NULL
[17:02:30.570]                   }
[17:02:30.570]                   options(future.plan = NULL)
[17:02:30.570]                   if (is.na(NA_character_)) 
[17:02:30.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.570]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.570]                     .init = FALSE)
[17:02:30.570]                 }
[17:02:30.570]             }
[17:02:30.570]         }
[17:02:30.570]     })
[17:02:30.570]     if (TRUE) {
[17:02:30.570]         base::sink(type = "output", split = FALSE)
[17:02:30.570]         if (TRUE) {
[17:02:30.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.570]         }
[17:02:30.570]         else {
[17:02:30.570]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.570]         }
[17:02:30.570]         base::close(...future.stdout)
[17:02:30.570]         ...future.stdout <- NULL
[17:02:30.570]     }
[17:02:30.570]     ...future.result$conditions <- ...future.conditions
[17:02:30.570]     ...future.result$finished <- base::Sys.time()
[17:02:30.570]     ...future.result
[17:02:30.570] }
[17:02:30.573] MultisessionFuture started
[17:02:30.573] - Launch lazy future ... done
[17:02:30.573] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74b758928> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c749e12838> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c74b758928> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c749e12838> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:02:30.579] receiveMessageFromWorker() for ClusterFuture ...
[17:02:30.579] - Validating connection of MultisessionFuture
[17:02:30.580] - received message: FutureResult
[17:02:30.580] - Received FutureResult
[17:02:30.580] - Erased future from FutureRegistry
[17:02:30.580] result() for ClusterFuture ...
[17:02:30.580] - result already collected: FutureResult
[17:02:30.580] result() for ClusterFuture ... done
[17:02:30.580] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:30.581] receiveMessageFromWorker() for ClusterFuture ...
[17:02:30.581] - Validating connection of MultisessionFuture
[17:02:30.581] - received message: FutureResult
[17:02:30.581] - Received FutureResult
[17:02:30.581] - Erased future from FutureRegistry
[17:02:30.581] result() for ClusterFuture ...
[17:02:30.581] - result already collected: FutureResult
[17:02:30.581] result() for ClusterFuture ... done
[17:02:30.581] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:02:30.583] resolve() on list ...
[17:02:30.583]  recursive: 0
[17:02:30.584]  length: 6
[17:02:30.584]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:02:30.584] signalConditionsASAP(numeric, pos=1) ...
[17:02:30.584] - nx: 6
[17:02:30.584] - relay: TRUE
[17:02:30.584] - stdout: TRUE
[17:02:30.584] - signal: TRUE
[17:02:30.584] - resignal: FALSE
[17:02:30.584] - force: TRUE
[17:02:30.584] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.584] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.585]  - until=2
[17:02:30.585]  - relaying element #2
[17:02:30.585] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.585] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.585] signalConditionsASAP(NULL, pos=1) ... done
[17:02:30.585]  length: 5 (resolved future 1)
[17:02:30.585] Future #2
[17:02:30.585] result() for ClusterFuture ...
[17:02:30.585] - result already collected: FutureResult
[17:02:30.585] result() for ClusterFuture ... done
[17:02:30.585] result() for ClusterFuture ...
[17:02:30.586] - result already collected: FutureResult
[17:02:30.586] result() for ClusterFuture ... done
[17:02:30.586] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:30.586] - nx: 6
[17:02:30.586] - relay: TRUE
[17:02:30.586] - stdout: TRUE
[17:02:30.586] - signal: TRUE
[17:02:30.586] - resignal: FALSE
[17:02:30.586] - force: TRUE
[17:02:30.586] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.586] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:30.586]  - until=2
[17:02:30.587]  - relaying element #2
[17:02:30.587] result() for ClusterFuture ...
[17:02:30.587] - result already collected: FutureResult
[17:02:30.587] result() for ClusterFuture ... done
[17:02:30.587] result() for ClusterFuture ...
[17:02:30.587] - result already collected: FutureResult
[17:02:30.587] result() for ClusterFuture ... done
[17:02:30.587] result() for ClusterFuture ...
[17:02:30.587] - result already collected: FutureResult
[17:02:30.587] result() for ClusterFuture ... done
[17:02:30.587] result() for ClusterFuture ...
[17:02:30.588] - result already collected: FutureResult
[17:02:30.588] result() for ClusterFuture ... done
[17:02:30.588] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.588] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.588] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:30.588]  length: 4 (resolved future 2)
[17:02:30.588] Future #3
[17:02:30.588] result() for ClusterFuture ...
[17:02:30.588] - result already collected: FutureResult
[17:02:30.588] result() for ClusterFuture ... done
[17:02:30.588] result() for ClusterFuture ...
[17:02:30.588] - result already collected: FutureResult
[17:02:30.589] result() for ClusterFuture ... done
[17:02:30.589] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:30.589] - nx: 6
[17:02:30.589] - relay: TRUE
[17:02:30.589] - stdout: TRUE
[17:02:30.589] - signal: TRUE
[17:02:30.589] - resignal: FALSE
[17:02:30.589] - force: TRUE
[17:02:30.589] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.589] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:30.589]  - until=3
[17:02:30.589]  - relaying element #3
[17:02:30.590] result() for ClusterFuture ...
[17:02:30.590] - result already collected: FutureResult
[17:02:30.590] result() for ClusterFuture ... done
[17:02:30.590] result() for ClusterFuture ...
[17:02:30.590] - result already collected: FutureResult
[17:02:30.590] result() for ClusterFuture ... done
[17:02:30.590] result() for ClusterFuture ...
[17:02:30.590] - result already collected: FutureResult
[17:02:30.590] result() for ClusterFuture ... done
[17:02:30.590] result() for ClusterFuture ...
[17:02:30.590] - result already collected: FutureResult
[17:02:30.590] result() for ClusterFuture ... done
[17:02:30.591] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.591] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.591] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:30.591]  length: 3 (resolved future 3)
[17:02:30.591] signalConditionsASAP(NULL, pos=4) ...
[17:02:30.591] - nx: 6
[17:02:30.591] - relay: TRUE
[17:02:30.591] - stdout: TRUE
[17:02:30.591] - signal: TRUE
[17:02:30.591] - resignal: FALSE
[17:02:30.591] - force: TRUE
[17:02:30.591] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.592] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.592]  - until=5
[17:02:30.592]  - relaying element #5
[17:02:30.592] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:30.592] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.592] signalConditionsASAP(NULL, pos=4) ... done
[17:02:30.592]  length: 2 (resolved future 4)
[17:02:30.592] signalConditionsASAP(NULL, pos=5) ...
[17:02:30.592] - nx: 6
[17:02:30.592] - relay: TRUE
[17:02:30.592] - stdout: TRUE
[17:02:30.592] - signal: TRUE
[17:02:30.593] - resignal: FALSE
[17:02:30.593] - force: TRUE
[17:02:30.593] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:30.593] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.593]  - until=6
[17:02:30.593]  - relaying element #6
[17:02:30.593] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:30.593] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.593] signalConditionsASAP(NULL, pos=5) ... done
[17:02:30.593]  length: 1 (resolved future 5)
[17:02:30.593] signalConditionsASAP(numeric, pos=6) ...
[17:02:30.593] - nx: 6
[17:02:30.594] - relay: TRUE
[17:02:30.594] - stdout: TRUE
[17:02:30.594] - signal: TRUE
[17:02:30.594] - resignal: FALSE
[17:02:30.594] - force: TRUE
[17:02:30.594] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:30.594] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.594]  - until=6
[17:02:30.594] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.594] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.594] signalConditionsASAP(numeric, pos=6) ... done
[17:02:30.594]  length: 0 (resolved future 6)
[17:02:30.595] Relaying remaining futures
[17:02:30.595] signalConditionsASAP(NULL, pos=0) ...
[17:02:30.595] - nx: 6
[17:02:30.595] - relay: TRUE
[17:02:30.595] - stdout: TRUE
[17:02:30.595] - signal: TRUE
[17:02:30.595] - resignal: FALSE
[17:02:30.595] - force: TRUE
[17:02:30.595] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.595] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:02:30.595] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:30.595] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:30.596] signalConditionsASAP(NULL, pos=0) ... done
[17:02:30.596] resolve() on list ... DONE
[17:02:30.596] result() for ClusterFuture ...
[17:02:30.596] - result already collected: FutureResult
[17:02:30.596] result() for ClusterFuture ... done
[17:02:30.596] result() for ClusterFuture ...
[17:02:30.596] - result already collected: FutureResult
[17:02:30.596] result() for ClusterFuture ... done
[17:02:30.596] result() for ClusterFuture ...
[17:02:30.596] - result already collected: FutureResult
[17:02:30.596] result() for ClusterFuture ... done
[17:02:30.596] result() for ClusterFuture ...
[17:02:30.597] - result already collected: FutureResult
[17:02:30.597] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[17:02:30.600] plan(): Setting new future strategy stack:
[17:02:30.600] List of future strategies:
[17:02:30.600] 1. multicore:
[17:02:30.600]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:30.600]    - tweaked: FALSE
[17:02:30.600]    - call: plan(strategy)
[17:02:30.605] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:02:30.605] getGlobalsAndPackages() ...
[17:02:30.605] Searching for globals...
[17:02:30.606] 
[17:02:30.606] Searching for globals ... DONE
[17:02:30.606] - globals: [0] <none>
[17:02:30.606] getGlobalsAndPackages() ... DONE
[17:02:30.607] run() for ‘Future’ ...
[17:02:30.607] - state: ‘created’
[17:02:30.607] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.611] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.612] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:30.612]   - Field: ‘label’
[17:02:30.612]   - Field: ‘local’
[17:02:30.612]   - Field: ‘owner’
[17:02:30.612]   - Field: ‘envir’
[17:02:30.612]   - Field: ‘workers’
[17:02:30.612]   - Field: ‘packages’
[17:02:30.612]   - Field: ‘gc’
[17:02:30.612]   - Field: ‘job’
[17:02:30.612]   - Field: ‘conditions’
[17:02:30.613]   - Field: ‘expr’
[17:02:30.613]   - Field: ‘uuid’
[17:02:30.613]   - Field: ‘seed’
[17:02:30.613]   - Field: ‘version’
[17:02:30.613]   - Field: ‘result’
[17:02:30.613]   - Field: ‘asynchronous’
[17:02:30.613]   - Field: ‘calls’
[17:02:30.613]   - Field: ‘globals’
[17:02:30.613]   - Field: ‘stdout’
[17:02:30.613]   - Field: ‘earlySignal’
[17:02:30.613]   - Field: ‘lazy’
[17:02:30.614]   - Field: ‘state’
[17:02:30.614] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:30.614] - Launch lazy future ...
[17:02:30.614] Packages needed by the future expression (n = 0): <none>
[17:02:30.614] Packages needed by future strategies (n = 0): <none>
[17:02:30.614] {
[17:02:30.614]     {
[17:02:30.614]         {
[17:02:30.614]             ...future.startTime <- base::Sys.time()
[17:02:30.614]             {
[17:02:30.614]                 {
[17:02:30.614]                   {
[17:02:30.614]                     {
[17:02:30.614]                       base::local({
[17:02:30.614]                         has_future <- base::requireNamespace("future", 
[17:02:30.614]                           quietly = TRUE)
[17:02:30.614]                         if (has_future) {
[17:02:30.614]                           ns <- base::getNamespace("future")
[17:02:30.614]                           version <- ns[[".package"]][["version"]]
[17:02:30.614]                           if (is.null(version)) 
[17:02:30.614]                             version <- utils::packageVersion("future")
[17:02:30.614]                         }
[17:02:30.614]                         else {
[17:02:30.614]                           version <- NULL
[17:02:30.614]                         }
[17:02:30.614]                         if (!has_future || version < "1.8.0") {
[17:02:30.614]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.614]                             "", base::R.version$version.string), 
[17:02:30.614]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.614]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.614]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.614]                               "release", "version")], collapse = " "), 
[17:02:30.614]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.614]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.614]                             info)
[17:02:30.614]                           info <- base::paste(info, collapse = "; ")
[17:02:30.614]                           if (!has_future) {
[17:02:30.614]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.614]                               info)
[17:02:30.614]                           }
[17:02:30.614]                           else {
[17:02:30.614]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.614]                               info, version)
[17:02:30.614]                           }
[17:02:30.614]                           base::stop(msg)
[17:02:30.614]                         }
[17:02:30.614]                       })
[17:02:30.614]                     }
[17:02:30.614]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.614]                     base::options(mc.cores = 1L)
[17:02:30.614]                   }
[17:02:30.614]                   ...future.strategy.old <- future::plan("list")
[17:02:30.614]                   options(future.plan = NULL)
[17:02:30.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.614]                 }
[17:02:30.614]                 ...future.workdir <- getwd()
[17:02:30.614]             }
[17:02:30.614]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.614]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.614]         }
[17:02:30.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.614]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.614]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.614]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.614]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.614]             base::names(...future.oldOptions))
[17:02:30.614]     }
[17:02:30.614]     if (FALSE) {
[17:02:30.614]     }
[17:02:30.614]     else {
[17:02:30.614]         if (TRUE) {
[17:02:30.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.614]                 open = "w")
[17:02:30.614]         }
[17:02:30.614]         else {
[17:02:30.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.614]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.614]         }
[17:02:30.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.614]             base::sink(type = "output", split = FALSE)
[17:02:30.614]             base::close(...future.stdout)
[17:02:30.614]         }, add = TRUE)
[17:02:30.614]     }
[17:02:30.614]     ...future.frame <- base::sys.nframe()
[17:02:30.614]     ...future.conditions <- base::list()
[17:02:30.614]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.614]     if (FALSE) {
[17:02:30.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.614]     }
[17:02:30.614]     ...future.result <- base::tryCatch({
[17:02:30.614]         base::withCallingHandlers({
[17:02:30.614]             ...future.value <- base::withVisible(base::local({
[17:02:30.614]                 withCallingHandlers({
[17:02:30.614]                   2
[17:02:30.614]                 }, immediateCondition = function(cond) {
[17:02:30.614]                   save_rds <- function (object, pathname, ...) 
[17:02:30.614]                   {
[17:02:30.614]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:30.614]                     if (file_test("-f", pathname_tmp)) {
[17:02:30.614]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.614]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:30.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.614]                         fi_tmp[["mtime"]])
[17:02:30.614]                     }
[17:02:30.614]                     tryCatch({
[17:02:30.614]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:30.614]                     }, error = function(ex) {
[17:02:30.614]                       msg <- conditionMessage(ex)
[17:02:30.614]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.614]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:30.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.614]                         fi_tmp[["mtime"]], msg)
[17:02:30.614]                       ex$message <- msg
[17:02:30.614]                       stop(ex)
[17:02:30.614]                     })
[17:02:30.614]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:30.614]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:30.614]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:30.614]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.614]                       fi <- file.info(pathname)
[17:02:30.614]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:30.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.614]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:30.614]                         fi[["size"]], fi[["mtime"]])
[17:02:30.614]                       stop(msg)
[17:02:30.614]                     }
[17:02:30.614]                     invisible(pathname)
[17:02:30.614]                   }
[17:02:30.614]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:30.614]                     rootPath = tempdir()) 
[17:02:30.614]                   {
[17:02:30.614]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:30.614]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:30.614]                       tmpdir = path, fileext = ".rds")
[17:02:30.614]                     save_rds(obj, file)
[17:02:30.614]                   }
[17:02:30.614]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:30.614]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.614]                   {
[17:02:30.614]                     inherits <- base::inherits
[17:02:30.614]                     invokeRestart <- base::invokeRestart
[17:02:30.614]                     is.null <- base::is.null
[17:02:30.614]                     muffled <- FALSE
[17:02:30.614]                     if (inherits(cond, "message")) {
[17:02:30.614]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.614]                       if (muffled) 
[17:02:30.614]                         invokeRestart("muffleMessage")
[17:02:30.614]                     }
[17:02:30.614]                     else if (inherits(cond, "warning")) {
[17:02:30.614]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.614]                       if (muffled) 
[17:02:30.614]                         invokeRestart("muffleWarning")
[17:02:30.614]                     }
[17:02:30.614]                     else if (inherits(cond, "condition")) {
[17:02:30.614]                       if (!is.null(pattern)) {
[17:02:30.614]                         computeRestarts <- base::computeRestarts
[17:02:30.614]                         grepl <- base::grepl
[17:02:30.614]                         restarts <- computeRestarts(cond)
[17:02:30.614]                         for (restart in restarts) {
[17:02:30.614]                           name <- restart$name
[17:02:30.614]                           if (is.null(name)) 
[17:02:30.614]                             next
[17:02:30.614]                           if (!grepl(pattern, name)) 
[17:02:30.614]                             next
[17:02:30.614]                           invokeRestart(restart)
[17:02:30.614]                           muffled <- TRUE
[17:02:30.614]                           break
[17:02:30.614]                         }
[17:02:30.614]                       }
[17:02:30.614]                     }
[17:02:30.614]                     invisible(muffled)
[17:02:30.614]                   }
[17:02:30.614]                   muffleCondition(cond)
[17:02:30.614]                 })
[17:02:30.614]             }))
[17:02:30.614]             future::FutureResult(value = ...future.value$value, 
[17:02:30.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.614]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.614]                     ...future.globalenv.names))
[17:02:30.614]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.614]         }, condition = base::local({
[17:02:30.614]             c <- base::c
[17:02:30.614]             inherits <- base::inherits
[17:02:30.614]             invokeRestart <- base::invokeRestart
[17:02:30.614]             length <- base::length
[17:02:30.614]             list <- base::list
[17:02:30.614]             seq.int <- base::seq.int
[17:02:30.614]             signalCondition <- base::signalCondition
[17:02:30.614]             sys.calls <- base::sys.calls
[17:02:30.614]             `[[` <- base::`[[`
[17:02:30.614]             `+` <- base::`+`
[17:02:30.614]             `<<-` <- base::`<<-`
[17:02:30.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.614]                   3L)]
[17:02:30.614]             }
[17:02:30.614]             function(cond) {
[17:02:30.614]                 is_error <- inherits(cond, "error")
[17:02:30.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.614]                   NULL)
[17:02:30.614]                 if (is_error) {
[17:02:30.614]                   sessionInformation <- function() {
[17:02:30.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.614]                       search = base::search(), system = base::Sys.info())
[17:02:30.614]                   }
[17:02:30.614]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.614]                     cond$call), session = sessionInformation(), 
[17:02:30.614]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.614]                   signalCondition(cond)
[17:02:30.614]                 }
[17:02:30.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.614]                 "immediateCondition"))) {
[17:02:30.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.614]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.614]                   if (TRUE && !signal) {
[17:02:30.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.614]                     {
[17:02:30.614]                       inherits <- base::inherits
[17:02:30.614]                       invokeRestart <- base::invokeRestart
[17:02:30.614]                       is.null <- base::is.null
[17:02:30.614]                       muffled <- FALSE
[17:02:30.614]                       if (inherits(cond, "message")) {
[17:02:30.614]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.614]                         if (muffled) 
[17:02:30.614]                           invokeRestart("muffleMessage")
[17:02:30.614]                       }
[17:02:30.614]                       else if (inherits(cond, "warning")) {
[17:02:30.614]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.614]                         if (muffled) 
[17:02:30.614]                           invokeRestart("muffleWarning")
[17:02:30.614]                       }
[17:02:30.614]                       else if (inherits(cond, "condition")) {
[17:02:30.614]                         if (!is.null(pattern)) {
[17:02:30.614]                           computeRestarts <- base::computeRestarts
[17:02:30.614]                           grepl <- base::grepl
[17:02:30.614]                           restarts <- computeRestarts(cond)
[17:02:30.614]                           for (restart in restarts) {
[17:02:30.614]                             name <- restart$name
[17:02:30.614]                             if (is.null(name)) 
[17:02:30.614]                               next
[17:02:30.614]                             if (!grepl(pattern, name)) 
[17:02:30.614]                               next
[17:02:30.614]                             invokeRestart(restart)
[17:02:30.614]                             muffled <- TRUE
[17:02:30.614]                             break
[17:02:30.614]                           }
[17:02:30.614]                         }
[17:02:30.614]                       }
[17:02:30.614]                       invisible(muffled)
[17:02:30.614]                     }
[17:02:30.614]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.614]                   }
[17:02:30.614]                 }
[17:02:30.614]                 else {
[17:02:30.614]                   if (TRUE) {
[17:02:30.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.614]                     {
[17:02:30.614]                       inherits <- base::inherits
[17:02:30.614]                       invokeRestart <- base::invokeRestart
[17:02:30.614]                       is.null <- base::is.null
[17:02:30.614]                       muffled <- FALSE
[17:02:30.614]                       if (inherits(cond, "message")) {
[17:02:30.614]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.614]                         if (muffled) 
[17:02:30.614]                           invokeRestart("muffleMessage")
[17:02:30.614]                       }
[17:02:30.614]                       else if (inherits(cond, "warning")) {
[17:02:30.614]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.614]                         if (muffled) 
[17:02:30.614]                           invokeRestart("muffleWarning")
[17:02:30.614]                       }
[17:02:30.614]                       else if (inherits(cond, "condition")) {
[17:02:30.614]                         if (!is.null(pattern)) {
[17:02:30.614]                           computeRestarts <- base::computeRestarts
[17:02:30.614]                           grepl <- base::grepl
[17:02:30.614]                           restarts <- computeRestarts(cond)
[17:02:30.614]                           for (restart in restarts) {
[17:02:30.614]                             name <- restart$name
[17:02:30.614]                             if (is.null(name)) 
[17:02:30.614]                               next
[17:02:30.614]                             if (!grepl(pattern, name)) 
[17:02:30.614]                               next
[17:02:30.614]                             invokeRestart(restart)
[17:02:30.614]                             muffled <- TRUE
[17:02:30.614]                             break
[17:02:30.614]                           }
[17:02:30.614]                         }
[17:02:30.614]                       }
[17:02:30.614]                       invisible(muffled)
[17:02:30.614]                     }
[17:02:30.614]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.614]                   }
[17:02:30.614]                 }
[17:02:30.614]             }
[17:02:30.614]         }))
[17:02:30.614]     }, error = function(ex) {
[17:02:30.614]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.614]                 ...future.rng), started = ...future.startTime, 
[17:02:30.614]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.614]             version = "1.8"), class = "FutureResult")
[17:02:30.614]     }, finally = {
[17:02:30.614]         if (!identical(...future.workdir, getwd())) 
[17:02:30.614]             setwd(...future.workdir)
[17:02:30.614]         {
[17:02:30.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.614]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.614]             }
[17:02:30.614]             base::options(...future.oldOptions)
[17:02:30.614]             if (.Platform$OS.type == "windows") {
[17:02:30.614]                 old_names <- names(...future.oldEnvVars)
[17:02:30.614]                 envs <- base::Sys.getenv()
[17:02:30.614]                 names <- names(envs)
[17:02:30.614]                 common <- intersect(names, old_names)
[17:02:30.614]                 added <- setdiff(names, old_names)
[17:02:30.614]                 removed <- setdiff(old_names, names)
[17:02:30.614]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.614]                   envs[common]]
[17:02:30.614]                 NAMES <- toupper(changed)
[17:02:30.614]                 args <- list()
[17:02:30.614]                 for (kk in seq_along(NAMES)) {
[17:02:30.614]                   name <- changed[[kk]]
[17:02:30.614]                   NAME <- NAMES[[kk]]
[17:02:30.614]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.614]                     next
[17:02:30.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.614]                 }
[17:02:30.614]                 NAMES <- toupper(added)
[17:02:30.614]                 for (kk in seq_along(NAMES)) {
[17:02:30.614]                   name <- added[[kk]]
[17:02:30.614]                   NAME <- NAMES[[kk]]
[17:02:30.614]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.614]                     next
[17:02:30.614]                   args[[name]] <- ""
[17:02:30.614]                 }
[17:02:30.614]                 NAMES <- toupper(removed)
[17:02:30.614]                 for (kk in seq_along(NAMES)) {
[17:02:30.614]                   name <- removed[[kk]]
[17:02:30.614]                   NAME <- NAMES[[kk]]
[17:02:30.614]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.614]                     next
[17:02:30.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.614]                 }
[17:02:30.614]                 if (length(args) > 0) 
[17:02:30.614]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.614]             }
[17:02:30.614]             else {
[17:02:30.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.614]             }
[17:02:30.614]             {
[17:02:30.614]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.614]                   0L) {
[17:02:30.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.614]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.614]                   base::options(opts)
[17:02:30.614]                 }
[17:02:30.614]                 {
[17:02:30.614]                   {
[17:02:30.614]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.614]                     NULL
[17:02:30.614]                   }
[17:02:30.614]                   options(future.plan = NULL)
[17:02:30.614]                   if (is.na(NA_character_)) 
[17:02:30.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.614]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.614]                     .init = FALSE)
[17:02:30.614]                 }
[17:02:30.614]             }
[17:02:30.614]         }
[17:02:30.614]     })
[17:02:30.614]     if (TRUE) {
[17:02:30.614]         base::sink(type = "output", split = FALSE)
[17:02:30.614]         if (TRUE) {
[17:02:30.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.614]         }
[17:02:30.614]         else {
[17:02:30.614]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.614]         }
[17:02:30.614]         base::close(...future.stdout)
[17:02:30.614]         ...future.stdout <- NULL
[17:02:30.614]     }
[17:02:30.614]     ...future.result$conditions <- ...future.conditions
[17:02:30.614]     ...future.result$finished <- base::Sys.time()
[17:02:30.614]     ...future.result
[17:02:30.614] }
[17:02:30.617] requestCore(): workers = 2
[17:02:30.619] MulticoreFuture started
[17:02:30.619] - Launch lazy future ... done
[17:02:30.619] run() for ‘MulticoreFuture’ ... done
[17:02:30.620] getGlobalsAndPackages() ...
[17:02:30.620] Searching for globals...
[17:02:30.620] plan(): Setting new future strategy stack:
[17:02:30.621] 
[17:02:30.620] List of future strategies:
[17:02:30.620] 1. sequential:
[17:02:30.620]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:30.620]    - tweaked: FALSE
[17:02:30.620]    - call: NULL
[17:02:30.621] Searching for globals ... DONE
[17:02:30.621] - globals: [0] <none>
[17:02:30.621] plan(): nbrOfWorkers() = 1
[17:02:30.621] getGlobalsAndPackages() ... DONE
[17:02:30.622] run() for ‘Future’ ...
[17:02:30.622] - state: ‘created’
[17:02:30.622] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.623] plan(): Setting new future strategy stack:
[17:02:30.623] List of future strategies:
[17:02:30.623] 1. multicore:
[17:02:30.623]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:30.623]    - tweaked: FALSE
[17:02:30.623]    - call: plan(strategy)
[17:02:30.627] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.627] plan(): nbrOfWorkers() = 2
[17:02:30.627] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:30.628]   - Field: ‘label’
[17:02:30.628]   - Field: ‘local’
[17:02:30.628]   - Field: ‘owner’
[17:02:30.628]   - Field: ‘envir’
[17:02:30.628]   - Field: ‘workers’
[17:02:30.628]   - Field: ‘packages’
[17:02:30.628]   - Field: ‘gc’
[17:02:30.629]   - Field: ‘job’
[17:02:30.629]   - Field: ‘conditions’
[17:02:30.629]   - Field: ‘expr’
[17:02:30.629]   - Field: ‘uuid’
[17:02:30.629]   - Field: ‘seed’
[17:02:30.629]   - Field: ‘version’
[17:02:30.629]   - Field: ‘result’
[17:02:30.630]   - Field: ‘asynchronous’
[17:02:30.630]   - Field: ‘calls’
[17:02:30.630]   - Field: ‘globals’
[17:02:30.630]   - Field: ‘stdout’
[17:02:30.630]   - Field: ‘earlySignal’
[17:02:30.630]   - Field: ‘lazy’
[17:02:30.630]   - Field: ‘state’
[17:02:30.630] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:30.631] - Launch lazy future ...
[17:02:30.631] Packages needed by the future expression (n = 0): <none>
[17:02:30.631] Packages needed by future strategies (n = 0): <none>
[17:02:30.632] {
[17:02:30.632]     {
[17:02:30.632]         {
[17:02:30.632]             ...future.startTime <- base::Sys.time()
[17:02:30.632]             {
[17:02:30.632]                 {
[17:02:30.632]                   {
[17:02:30.632]                     {
[17:02:30.632]                       base::local({
[17:02:30.632]                         has_future <- base::requireNamespace("future", 
[17:02:30.632]                           quietly = TRUE)
[17:02:30.632]                         if (has_future) {
[17:02:30.632]                           ns <- base::getNamespace("future")
[17:02:30.632]                           version <- ns[[".package"]][["version"]]
[17:02:30.632]                           if (is.null(version)) 
[17:02:30.632]                             version <- utils::packageVersion("future")
[17:02:30.632]                         }
[17:02:30.632]                         else {
[17:02:30.632]                           version <- NULL
[17:02:30.632]                         }
[17:02:30.632]                         if (!has_future || version < "1.8.0") {
[17:02:30.632]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.632]                             "", base::R.version$version.string), 
[17:02:30.632]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.632]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.632]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.632]                               "release", "version")], collapse = " "), 
[17:02:30.632]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.632]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.632]                             info)
[17:02:30.632]                           info <- base::paste(info, collapse = "; ")
[17:02:30.632]                           if (!has_future) {
[17:02:30.632]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.632]                               info)
[17:02:30.632]                           }
[17:02:30.632]                           else {
[17:02:30.632]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.632]                               info, version)
[17:02:30.632]                           }
[17:02:30.632]                           base::stop(msg)
[17:02:30.632]                         }
[17:02:30.632]                       })
[17:02:30.632]                     }
[17:02:30.632]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.632]                     base::options(mc.cores = 1L)
[17:02:30.632]                   }
[17:02:30.632]                   ...future.strategy.old <- future::plan("list")
[17:02:30.632]                   options(future.plan = NULL)
[17:02:30.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.632]                 }
[17:02:30.632]                 ...future.workdir <- getwd()
[17:02:30.632]             }
[17:02:30.632]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.632]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.632]         }
[17:02:30.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.632]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.632]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.632]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.632]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.632]             base::names(...future.oldOptions))
[17:02:30.632]     }
[17:02:30.632]     if (FALSE) {
[17:02:30.632]     }
[17:02:30.632]     else {
[17:02:30.632]         if (TRUE) {
[17:02:30.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.632]                 open = "w")
[17:02:30.632]         }
[17:02:30.632]         else {
[17:02:30.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.632]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.632]         }
[17:02:30.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.632]             base::sink(type = "output", split = FALSE)
[17:02:30.632]             base::close(...future.stdout)
[17:02:30.632]         }, add = TRUE)
[17:02:30.632]     }
[17:02:30.632]     ...future.frame <- base::sys.nframe()
[17:02:30.632]     ...future.conditions <- base::list()
[17:02:30.632]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.632]     if (FALSE) {
[17:02:30.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.632]     }
[17:02:30.632]     ...future.result <- base::tryCatch({
[17:02:30.632]         base::withCallingHandlers({
[17:02:30.632]             ...future.value <- base::withVisible(base::local({
[17:02:30.632]                 withCallingHandlers({
[17:02:30.632]                   NULL
[17:02:30.632]                 }, immediateCondition = function(cond) {
[17:02:30.632]                   save_rds <- function (object, pathname, ...) 
[17:02:30.632]                   {
[17:02:30.632]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:30.632]                     if (file_test("-f", pathname_tmp)) {
[17:02:30.632]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.632]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:30.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.632]                         fi_tmp[["mtime"]])
[17:02:30.632]                     }
[17:02:30.632]                     tryCatch({
[17:02:30.632]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:30.632]                     }, error = function(ex) {
[17:02:30.632]                       msg <- conditionMessage(ex)
[17:02:30.632]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.632]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:30.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.632]                         fi_tmp[["mtime"]], msg)
[17:02:30.632]                       ex$message <- msg
[17:02:30.632]                       stop(ex)
[17:02:30.632]                     })
[17:02:30.632]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:30.632]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:30.632]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:30.632]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.632]                       fi <- file.info(pathname)
[17:02:30.632]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:30.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.632]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:30.632]                         fi[["size"]], fi[["mtime"]])
[17:02:30.632]                       stop(msg)
[17:02:30.632]                     }
[17:02:30.632]                     invisible(pathname)
[17:02:30.632]                   }
[17:02:30.632]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:30.632]                     rootPath = tempdir()) 
[17:02:30.632]                   {
[17:02:30.632]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:30.632]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:30.632]                       tmpdir = path, fileext = ".rds")
[17:02:30.632]                     save_rds(obj, file)
[17:02:30.632]                   }
[17:02:30.632]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:30.632]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.632]                   {
[17:02:30.632]                     inherits <- base::inherits
[17:02:30.632]                     invokeRestart <- base::invokeRestart
[17:02:30.632]                     is.null <- base::is.null
[17:02:30.632]                     muffled <- FALSE
[17:02:30.632]                     if (inherits(cond, "message")) {
[17:02:30.632]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.632]                       if (muffled) 
[17:02:30.632]                         invokeRestart("muffleMessage")
[17:02:30.632]                     }
[17:02:30.632]                     else if (inherits(cond, "warning")) {
[17:02:30.632]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.632]                       if (muffled) 
[17:02:30.632]                         invokeRestart("muffleWarning")
[17:02:30.632]                     }
[17:02:30.632]                     else if (inherits(cond, "condition")) {
[17:02:30.632]                       if (!is.null(pattern)) {
[17:02:30.632]                         computeRestarts <- base::computeRestarts
[17:02:30.632]                         grepl <- base::grepl
[17:02:30.632]                         restarts <- computeRestarts(cond)
[17:02:30.632]                         for (restart in restarts) {
[17:02:30.632]                           name <- restart$name
[17:02:30.632]                           if (is.null(name)) 
[17:02:30.632]                             next
[17:02:30.632]                           if (!grepl(pattern, name)) 
[17:02:30.632]                             next
[17:02:30.632]                           invokeRestart(restart)
[17:02:30.632]                           muffled <- TRUE
[17:02:30.632]                           break
[17:02:30.632]                         }
[17:02:30.632]                       }
[17:02:30.632]                     }
[17:02:30.632]                     invisible(muffled)
[17:02:30.632]                   }
[17:02:30.632]                   muffleCondition(cond)
[17:02:30.632]                 })
[17:02:30.632]             }))
[17:02:30.632]             future::FutureResult(value = ...future.value$value, 
[17:02:30.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.632]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.632]                     ...future.globalenv.names))
[17:02:30.632]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.632]         }, condition = base::local({
[17:02:30.632]             c <- base::c
[17:02:30.632]             inherits <- base::inherits
[17:02:30.632]             invokeRestart <- base::invokeRestart
[17:02:30.632]             length <- base::length
[17:02:30.632]             list <- base::list
[17:02:30.632]             seq.int <- base::seq.int
[17:02:30.632]             signalCondition <- base::signalCondition
[17:02:30.632]             sys.calls <- base::sys.calls
[17:02:30.632]             `[[` <- base::`[[`
[17:02:30.632]             `+` <- base::`+`
[17:02:30.632]             `<<-` <- base::`<<-`
[17:02:30.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.632]                   3L)]
[17:02:30.632]             }
[17:02:30.632]             function(cond) {
[17:02:30.632]                 is_error <- inherits(cond, "error")
[17:02:30.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.632]                   NULL)
[17:02:30.632]                 if (is_error) {
[17:02:30.632]                   sessionInformation <- function() {
[17:02:30.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.632]                       search = base::search(), system = base::Sys.info())
[17:02:30.632]                   }
[17:02:30.632]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.632]                     cond$call), session = sessionInformation(), 
[17:02:30.632]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.632]                   signalCondition(cond)
[17:02:30.632]                 }
[17:02:30.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.632]                 "immediateCondition"))) {
[17:02:30.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.632]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.632]                   if (TRUE && !signal) {
[17:02:30.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.632]                     {
[17:02:30.632]                       inherits <- base::inherits
[17:02:30.632]                       invokeRestart <- base::invokeRestart
[17:02:30.632]                       is.null <- base::is.null
[17:02:30.632]                       muffled <- FALSE
[17:02:30.632]                       if (inherits(cond, "message")) {
[17:02:30.632]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.632]                         if (muffled) 
[17:02:30.632]                           invokeRestart("muffleMessage")
[17:02:30.632]                       }
[17:02:30.632]                       else if (inherits(cond, "warning")) {
[17:02:30.632]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.632]                         if (muffled) 
[17:02:30.632]                           invokeRestart("muffleWarning")
[17:02:30.632]                       }
[17:02:30.632]                       else if (inherits(cond, "condition")) {
[17:02:30.632]                         if (!is.null(pattern)) {
[17:02:30.632]                           computeRestarts <- base::computeRestarts
[17:02:30.632]                           grepl <- base::grepl
[17:02:30.632]                           restarts <- computeRestarts(cond)
[17:02:30.632]                           for (restart in restarts) {
[17:02:30.632]                             name <- restart$name
[17:02:30.632]                             if (is.null(name)) 
[17:02:30.632]                               next
[17:02:30.632]                             if (!grepl(pattern, name)) 
[17:02:30.632]                               next
[17:02:30.632]                             invokeRestart(restart)
[17:02:30.632]                             muffled <- TRUE
[17:02:30.632]                             break
[17:02:30.632]                           }
[17:02:30.632]                         }
[17:02:30.632]                       }
[17:02:30.632]                       invisible(muffled)
[17:02:30.632]                     }
[17:02:30.632]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.632]                   }
[17:02:30.632]                 }
[17:02:30.632]                 else {
[17:02:30.632]                   if (TRUE) {
[17:02:30.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.632]                     {
[17:02:30.632]                       inherits <- base::inherits
[17:02:30.632]                       invokeRestart <- base::invokeRestart
[17:02:30.632]                       is.null <- base::is.null
[17:02:30.632]                       muffled <- FALSE
[17:02:30.632]                       if (inherits(cond, "message")) {
[17:02:30.632]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.632]                         if (muffled) 
[17:02:30.632]                           invokeRestart("muffleMessage")
[17:02:30.632]                       }
[17:02:30.632]                       else if (inherits(cond, "warning")) {
[17:02:30.632]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.632]                         if (muffled) 
[17:02:30.632]                           invokeRestart("muffleWarning")
[17:02:30.632]                       }
[17:02:30.632]                       else if (inherits(cond, "condition")) {
[17:02:30.632]                         if (!is.null(pattern)) {
[17:02:30.632]                           computeRestarts <- base::computeRestarts
[17:02:30.632]                           grepl <- base::grepl
[17:02:30.632]                           restarts <- computeRestarts(cond)
[17:02:30.632]                           for (restart in restarts) {
[17:02:30.632]                             name <- restart$name
[17:02:30.632]                             if (is.null(name)) 
[17:02:30.632]                               next
[17:02:30.632]                             if (!grepl(pattern, name)) 
[17:02:30.632]                               next
[17:02:30.632]                             invokeRestart(restart)
[17:02:30.632]                             muffled <- TRUE
[17:02:30.632]                             break
[17:02:30.632]                           }
[17:02:30.632]                         }
[17:02:30.632]                       }
[17:02:30.632]                       invisible(muffled)
[17:02:30.632]                     }
[17:02:30.632]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.632]                   }
[17:02:30.632]                 }
[17:02:30.632]             }
[17:02:30.632]         }))
[17:02:30.632]     }, error = function(ex) {
[17:02:30.632]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.632]                 ...future.rng), started = ...future.startTime, 
[17:02:30.632]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.632]             version = "1.8"), class = "FutureResult")
[17:02:30.632]     }, finally = {
[17:02:30.632]         if (!identical(...future.workdir, getwd())) 
[17:02:30.632]             setwd(...future.workdir)
[17:02:30.632]         {
[17:02:30.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.632]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.632]             }
[17:02:30.632]             base::options(...future.oldOptions)
[17:02:30.632]             if (.Platform$OS.type == "windows") {
[17:02:30.632]                 old_names <- names(...future.oldEnvVars)
[17:02:30.632]                 envs <- base::Sys.getenv()
[17:02:30.632]                 names <- names(envs)
[17:02:30.632]                 common <- intersect(names, old_names)
[17:02:30.632]                 added <- setdiff(names, old_names)
[17:02:30.632]                 removed <- setdiff(old_names, names)
[17:02:30.632]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.632]                   envs[common]]
[17:02:30.632]                 NAMES <- toupper(changed)
[17:02:30.632]                 args <- list()
[17:02:30.632]                 for (kk in seq_along(NAMES)) {
[17:02:30.632]                   name <- changed[[kk]]
[17:02:30.632]                   NAME <- NAMES[[kk]]
[17:02:30.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.632]                     next
[17:02:30.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.632]                 }
[17:02:30.632]                 NAMES <- toupper(added)
[17:02:30.632]                 for (kk in seq_along(NAMES)) {
[17:02:30.632]                   name <- added[[kk]]
[17:02:30.632]                   NAME <- NAMES[[kk]]
[17:02:30.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.632]                     next
[17:02:30.632]                   args[[name]] <- ""
[17:02:30.632]                 }
[17:02:30.632]                 NAMES <- toupper(removed)
[17:02:30.632]                 for (kk in seq_along(NAMES)) {
[17:02:30.632]                   name <- removed[[kk]]
[17:02:30.632]                   NAME <- NAMES[[kk]]
[17:02:30.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.632]                     next
[17:02:30.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.632]                 }
[17:02:30.632]                 if (length(args) > 0) 
[17:02:30.632]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.632]             }
[17:02:30.632]             else {
[17:02:30.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.632]             }
[17:02:30.632]             {
[17:02:30.632]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.632]                   0L) {
[17:02:30.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.632]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.632]                   base::options(opts)
[17:02:30.632]                 }
[17:02:30.632]                 {
[17:02:30.632]                   {
[17:02:30.632]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.632]                     NULL
[17:02:30.632]                   }
[17:02:30.632]                   options(future.plan = NULL)
[17:02:30.632]                   if (is.na(NA_character_)) 
[17:02:30.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.632]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.632]                     .init = FALSE)
[17:02:30.632]                 }
[17:02:30.632]             }
[17:02:30.632]         }
[17:02:30.632]     })
[17:02:30.632]     if (TRUE) {
[17:02:30.632]         base::sink(type = "output", split = FALSE)
[17:02:30.632]         if (TRUE) {
[17:02:30.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.632]         }
[17:02:30.632]         else {
[17:02:30.632]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.632]         }
[17:02:30.632]         base::close(...future.stdout)
[17:02:30.632]         ...future.stdout <- NULL
[17:02:30.632]     }
[17:02:30.632]     ...future.result$conditions <- ...future.conditions
[17:02:30.632]     ...future.result$finished <- base::Sys.time()
[17:02:30.632]     ...future.result
[17:02:30.632] }
[17:02:30.635] requestCore(): workers = 2
[17:02:30.638] MulticoreFuture started
[17:02:30.638] - Launch lazy future ... done
[17:02:30.638] run() for ‘MulticoreFuture’ ... done
[17:02:30.639] plan(): Setting new future strategy stack:
[17:02:30.639] getGlobalsAndPackages() ...
[17:02:30.639] Searching for globals...
[17:02:30.639] List of future strategies:
[17:02:30.639] 1. sequential:
[17:02:30.639]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:30.639]    - tweaked: FALSE
[17:02:30.639]    - call: NULL
[17:02:30.640] plan(): nbrOfWorkers() = 1
[17:02:30.641] - globals found: [1] ‘{’
[17:02:30.641] Searching for globals ... DONE
[17:02:30.641] Resolving globals: FALSE
[17:02:30.641] 
[17:02:30.642] 
[17:02:30.642] getGlobalsAndPackages() ... DONE
[17:02:30.642] plan(): Setting new future strategy stack:
[17:02:30.642] run() for ‘Future’ ...
[17:02:30.642] - state: ‘created’
[17:02:30.643] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.642] List of future strategies:
[17:02:30.642] 1. multicore:
[17:02:30.642]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:30.642]    - tweaked: FALSE
[17:02:30.642]    - call: plan(strategy)
[17:02:30.648] plan(): nbrOfWorkers() = 2
[17:02:30.648] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.648] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:30.648]   - Field: ‘label’
[17:02:30.648]   - Field: ‘local’
[17:02:30.648]   - Field: ‘owner’
[17:02:30.649]   - Field: ‘envir’
[17:02:30.649]   - Field: ‘workers’
[17:02:30.649]   - Field: ‘packages’
[17:02:30.649]   - Field: ‘gc’
[17:02:30.649]   - Field: ‘job’
[17:02:30.649]   - Field: ‘conditions’
[17:02:30.649]   - Field: ‘expr’
[17:02:30.650]   - Field: ‘uuid’
[17:02:30.650]   - Field: ‘seed’
[17:02:30.650]   - Field: ‘version’
[17:02:30.650]   - Field: ‘result’
[17:02:30.650]   - Field: ‘asynchronous’
[17:02:30.650]   - Field: ‘calls’
[17:02:30.650]   - Field: ‘globals’
[17:02:30.650]   - Field: ‘stdout’
[17:02:30.651]   - Field: ‘earlySignal’
[17:02:30.651]   - Field: ‘lazy’
[17:02:30.651]   - Field: ‘state’
[17:02:30.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:30.651] - Launch lazy future ...
[17:02:30.652] Packages needed by the future expression (n = 0): <none>
[17:02:30.652] Packages needed by future strategies (n = 0): <none>
[17:02:30.652] {
[17:02:30.652]     {
[17:02:30.652]         {
[17:02:30.652]             ...future.startTime <- base::Sys.time()
[17:02:30.652]             {
[17:02:30.652]                 {
[17:02:30.652]                   {
[17:02:30.652]                     {
[17:02:30.652]                       base::local({
[17:02:30.652]                         has_future <- base::requireNamespace("future", 
[17:02:30.652]                           quietly = TRUE)
[17:02:30.652]                         if (has_future) {
[17:02:30.652]                           ns <- base::getNamespace("future")
[17:02:30.652]                           version <- ns[[".package"]][["version"]]
[17:02:30.652]                           if (is.null(version)) 
[17:02:30.652]                             version <- utils::packageVersion("future")
[17:02:30.652]                         }
[17:02:30.652]                         else {
[17:02:30.652]                           version <- NULL
[17:02:30.652]                         }
[17:02:30.652]                         if (!has_future || version < "1.8.0") {
[17:02:30.652]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.652]                             "", base::R.version$version.string), 
[17:02:30.652]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.652]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.652]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.652]                               "release", "version")], collapse = " "), 
[17:02:30.652]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.652]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.652]                             info)
[17:02:30.652]                           info <- base::paste(info, collapse = "; ")
[17:02:30.652]                           if (!has_future) {
[17:02:30.652]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.652]                               info)
[17:02:30.652]                           }
[17:02:30.652]                           else {
[17:02:30.652]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.652]                               info, version)
[17:02:30.652]                           }
[17:02:30.652]                           base::stop(msg)
[17:02:30.652]                         }
[17:02:30.652]                       })
[17:02:30.652]                     }
[17:02:30.652]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.652]                     base::options(mc.cores = 1L)
[17:02:30.652]                   }
[17:02:30.652]                   ...future.strategy.old <- future::plan("list")
[17:02:30.652]                   options(future.plan = NULL)
[17:02:30.652]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.652]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.652]                 }
[17:02:30.652]                 ...future.workdir <- getwd()
[17:02:30.652]             }
[17:02:30.652]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.652]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.652]         }
[17:02:30.652]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.652]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.652]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.652]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.652]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.652]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.652]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.652]             base::names(...future.oldOptions))
[17:02:30.652]     }
[17:02:30.652]     if (FALSE) {
[17:02:30.652]     }
[17:02:30.652]     else {
[17:02:30.652]         if (TRUE) {
[17:02:30.652]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.652]                 open = "w")
[17:02:30.652]         }
[17:02:30.652]         else {
[17:02:30.652]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.652]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.652]         }
[17:02:30.652]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.652]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.652]             base::sink(type = "output", split = FALSE)
[17:02:30.652]             base::close(...future.stdout)
[17:02:30.652]         }, add = TRUE)
[17:02:30.652]     }
[17:02:30.652]     ...future.frame <- base::sys.nframe()
[17:02:30.652]     ...future.conditions <- base::list()
[17:02:30.652]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.652]     if (FALSE) {
[17:02:30.652]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.652]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.652]     }
[17:02:30.652]     ...future.result <- base::tryCatch({
[17:02:30.652]         base::withCallingHandlers({
[17:02:30.652]             ...future.value <- base::withVisible(base::local({
[17:02:30.652]                 withCallingHandlers({
[17:02:30.652]                   {
[17:02:30.652]                     4
[17:02:30.652]                   }
[17:02:30.652]                 }, immediateCondition = function(cond) {
[17:02:30.652]                   save_rds <- function (object, pathname, ...) 
[17:02:30.652]                   {
[17:02:30.652]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:30.652]                     if (file_test("-f", pathname_tmp)) {
[17:02:30.652]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.652]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:30.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.652]                         fi_tmp[["mtime"]])
[17:02:30.652]                     }
[17:02:30.652]                     tryCatch({
[17:02:30.652]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:30.652]                     }, error = function(ex) {
[17:02:30.652]                       msg <- conditionMessage(ex)
[17:02:30.652]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.652]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:30.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.652]                         fi_tmp[["mtime"]], msg)
[17:02:30.652]                       ex$message <- msg
[17:02:30.652]                       stop(ex)
[17:02:30.652]                     })
[17:02:30.652]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:30.652]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:30.652]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:30.652]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.652]                       fi <- file.info(pathname)
[17:02:30.652]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:30.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.652]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:30.652]                         fi[["size"]], fi[["mtime"]])
[17:02:30.652]                       stop(msg)
[17:02:30.652]                     }
[17:02:30.652]                     invisible(pathname)
[17:02:30.652]                   }
[17:02:30.652]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:30.652]                     rootPath = tempdir()) 
[17:02:30.652]                   {
[17:02:30.652]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:30.652]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:30.652]                       tmpdir = path, fileext = ".rds")
[17:02:30.652]                     save_rds(obj, file)
[17:02:30.652]                   }
[17:02:30.652]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:30.652]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.652]                   {
[17:02:30.652]                     inherits <- base::inherits
[17:02:30.652]                     invokeRestart <- base::invokeRestart
[17:02:30.652]                     is.null <- base::is.null
[17:02:30.652]                     muffled <- FALSE
[17:02:30.652]                     if (inherits(cond, "message")) {
[17:02:30.652]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.652]                       if (muffled) 
[17:02:30.652]                         invokeRestart("muffleMessage")
[17:02:30.652]                     }
[17:02:30.652]                     else if (inherits(cond, "warning")) {
[17:02:30.652]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.652]                       if (muffled) 
[17:02:30.652]                         invokeRestart("muffleWarning")
[17:02:30.652]                     }
[17:02:30.652]                     else if (inherits(cond, "condition")) {
[17:02:30.652]                       if (!is.null(pattern)) {
[17:02:30.652]                         computeRestarts <- base::computeRestarts
[17:02:30.652]                         grepl <- base::grepl
[17:02:30.652]                         restarts <- computeRestarts(cond)
[17:02:30.652]                         for (restart in restarts) {
[17:02:30.652]                           name <- restart$name
[17:02:30.652]                           if (is.null(name)) 
[17:02:30.652]                             next
[17:02:30.652]                           if (!grepl(pattern, name)) 
[17:02:30.652]                             next
[17:02:30.652]                           invokeRestart(restart)
[17:02:30.652]                           muffled <- TRUE
[17:02:30.652]                           break
[17:02:30.652]                         }
[17:02:30.652]                       }
[17:02:30.652]                     }
[17:02:30.652]                     invisible(muffled)
[17:02:30.652]                   }
[17:02:30.652]                   muffleCondition(cond)
[17:02:30.652]                 })
[17:02:30.652]             }))
[17:02:30.652]             future::FutureResult(value = ...future.value$value, 
[17:02:30.652]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.652]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.652]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.652]                     ...future.globalenv.names))
[17:02:30.652]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.652]         }, condition = base::local({
[17:02:30.652]             c <- base::c
[17:02:30.652]             inherits <- base::inherits
[17:02:30.652]             invokeRestart <- base::invokeRestart
[17:02:30.652]             length <- base::length
[17:02:30.652]             list <- base::list
[17:02:30.652]             seq.int <- base::seq.int
[17:02:30.652]             signalCondition <- base::signalCondition
[17:02:30.652]             sys.calls <- base::sys.calls
[17:02:30.652]             `[[` <- base::`[[`
[17:02:30.652]             `+` <- base::`+`
[17:02:30.652]             `<<-` <- base::`<<-`
[17:02:30.652]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.652]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.652]                   3L)]
[17:02:30.652]             }
[17:02:30.652]             function(cond) {
[17:02:30.652]                 is_error <- inherits(cond, "error")
[17:02:30.652]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.652]                   NULL)
[17:02:30.652]                 if (is_error) {
[17:02:30.652]                   sessionInformation <- function() {
[17:02:30.652]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.652]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.652]                       search = base::search(), system = base::Sys.info())
[17:02:30.652]                   }
[17:02:30.652]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.652]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.652]                     cond$call), session = sessionInformation(), 
[17:02:30.652]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.652]                   signalCondition(cond)
[17:02:30.652]                 }
[17:02:30.652]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.652]                 "immediateCondition"))) {
[17:02:30.652]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.652]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.652]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.652]                   if (TRUE && !signal) {
[17:02:30.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.652]                     {
[17:02:30.652]                       inherits <- base::inherits
[17:02:30.652]                       invokeRestart <- base::invokeRestart
[17:02:30.652]                       is.null <- base::is.null
[17:02:30.652]                       muffled <- FALSE
[17:02:30.652]                       if (inherits(cond, "message")) {
[17:02:30.652]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.652]                         if (muffled) 
[17:02:30.652]                           invokeRestart("muffleMessage")
[17:02:30.652]                       }
[17:02:30.652]                       else if (inherits(cond, "warning")) {
[17:02:30.652]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.652]                         if (muffled) 
[17:02:30.652]                           invokeRestart("muffleWarning")
[17:02:30.652]                       }
[17:02:30.652]                       else if (inherits(cond, "condition")) {
[17:02:30.652]                         if (!is.null(pattern)) {
[17:02:30.652]                           computeRestarts <- base::computeRestarts
[17:02:30.652]                           grepl <- base::grepl
[17:02:30.652]                           restarts <- computeRestarts(cond)
[17:02:30.652]                           for (restart in restarts) {
[17:02:30.652]                             name <- restart$name
[17:02:30.652]                             if (is.null(name)) 
[17:02:30.652]                               next
[17:02:30.652]                             if (!grepl(pattern, name)) 
[17:02:30.652]                               next
[17:02:30.652]                             invokeRestart(restart)
[17:02:30.652]                             muffled <- TRUE
[17:02:30.652]                             break
[17:02:30.652]                           }
[17:02:30.652]                         }
[17:02:30.652]                       }
[17:02:30.652]                       invisible(muffled)
[17:02:30.652]                     }
[17:02:30.652]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.652]                   }
[17:02:30.652]                 }
[17:02:30.652]                 else {
[17:02:30.652]                   if (TRUE) {
[17:02:30.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.652]                     {
[17:02:30.652]                       inherits <- base::inherits
[17:02:30.652]                       invokeRestart <- base::invokeRestart
[17:02:30.652]                       is.null <- base::is.null
[17:02:30.652]                       muffled <- FALSE
[17:02:30.652]                       if (inherits(cond, "message")) {
[17:02:30.652]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.652]                         if (muffled) 
[17:02:30.652]                           invokeRestart("muffleMessage")
[17:02:30.652]                       }
[17:02:30.652]                       else if (inherits(cond, "warning")) {
[17:02:30.652]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.652]                         if (muffled) 
[17:02:30.652]                           invokeRestart("muffleWarning")
[17:02:30.652]                       }
[17:02:30.652]                       else if (inherits(cond, "condition")) {
[17:02:30.652]                         if (!is.null(pattern)) {
[17:02:30.652]                           computeRestarts <- base::computeRestarts
[17:02:30.652]                           grepl <- base::grepl
[17:02:30.652]                           restarts <- computeRestarts(cond)
[17:02:30.652]                           for (restart in restarts) {
[17:02:30.652]                             name <- restart$name
[17:02:30.652]                             if (is.null(name)) 
[17:02:30.652]                               next
[17:02:30.652]                             if (!grepl(pattern, name)) 
[17:02:30.652]                               next
[17:02:30.652]                             invokeRestart(restart)
[17:02:30.652]                             muffled <- TRUE
[17:02:30.652]                             break
[17:02:30.652]                           }
[17:02:30.652]                         }
[17:02:30.652]                       }
[17:02:30.652]                       invisible(muffled)
[17:02:30.652]                     }
[17:02:30.652]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.652]                   }
[17:02:30.652]                 }
[17:02:30.652]             }
[17:02:30.652]         }))
[17:02:30.652]     }, error = function(ex) {
[17:02:30.652]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.652]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.652]                 ...future.rng), started = ...future.startTime, 
[17:02:30.652]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.652]             version = "1.8"), class = "FutureResult")
[17:02:30.652]     }, finally = {
[17:02:30.652]         if (!identical(...future.workdir, getwd())) 
[17:02:30.652]             setwd(...future.workdir)
[17:02:30.652]         {
[17:02:30.652]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.652]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.652]             }
[17:02:30.652]             base::options(...future.oldOptions)
[17:02:30.652]             if (.Platform$OS.type == "windows") {
[17:02:30.652]                 old_names <- names(...future.oldEnvVars)
[17:02:30.652]                 envs <- base::Sys.getenv()
[17:02:30.652]                 names <- names(envs)
[17:02:30.652]                 common <- intersect(names, old_names)
[17:02:30.652]                 added <- setdiff(names, old_names)
[17:02:30.652]                 removed <- setdiff(old_names, names)
[17:02:30.652]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.652]                   envs[common]]
[17:02:30.652]                 NAMES <- toupper(changed)
[17:02:30.652]                 args <- list()
[17:02:30.652]                 for (kk in seq_along(NAMES)) {
[17:02:30.652]                   name <- changed[[kk]]
[17:02:30.652]                   NAME <- NAMES[[kk]]
[17:02:30.652]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.652]                     next
[17:02:30.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.652]                 }
[17:02:30.652]                 NAMES <- toupper(added)
[17:02:30.652]                 for (kk in seq_along(NAMES)) {
[17:02:30.652]                   name <- added[[kk]]
[17:02:30.652]                   NAME <- NAMES[[kk]]
[17:02:30.652]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.652]                     next
[17:02:30.652]                   args[[name]] <- ""
[17:02:30.652]                 }
[17:02:30.652]                 NAMES <- toupper(removed)
[17:02:30.652]                 for (kk in seq_along(NAMES)) {
[17:02:30.652]                   name <- removed[[kk]]
[17:02:30.652]                   NAME <- NAMES[[kk]]
[17:02:30.652]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.652]                     next
[17:02:30.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.652]                 }
[17:02:30.652]                 if (length(args) > 0) 
[17:02:30.652]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.652]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.652]             }
[17:02:30.652]             else {
[17:02:30.652]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.652]             }
[17:02:30.652]             {
[17:02:30.652]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.652]                   0L) {
[17:02:30.652]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.652]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.652]                   base::options(opts)
[17:02:30.652]                 }
[17:02:30.652]                 {
[17:02:30.652]                   {
[17:02:30.652]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.652]                     NULL
[17:02:30.652]                   }
[17:02:30.652]                   options(future.plan = NULL)
[17:02:30.652]                   if (is.na(NA_character_)) 
[17:02:30.652]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.652]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.652]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.652]                     .init = FALSE)
[17:02:30.652]                 }
[17:02:30.652]             }
[17:02:30.652]         }
[17:02:30.652]     })
[17:02:30.652]     if (TRUE) {
[17:02:30.652]         base::sink(type = "output", split = FALSE)
[17:02:30.652]         if (TRUE) {
[17:02:30.652]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.652]         }
[17:02:30.652]         else {
[17:02:30.652]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.652]         }
[17:02:30.652]         base::close(...future.stdout)
[17:02:30.652]         ...future.stdout <- NULL
[17:02:30.652]     }
[17:02:30.652]     ...future.result$conditions <- ...future.conditions
[17:02:30.652]     ...future.result$finished <- base::Sys.time()
[17:02:30.652]     ...future.result
[17:02:30.652] }
[17:02:30.656] requestCore(): workers = 2
[17:02:30.656] Poll #1 (0): usedCores() = 2, workers = 2
[17:02:30.667] result() for MulticoreFuture ...
[17:02:30.668] result() for MulticoreFuture ...
[17:02:30.668] result() for MulticoreFuture ... done
[17:02:30.668] result() for MulticoreFuture ... done
[17:02:30.668] result() for MulticoreFuture ...
[17:02:30.669] result() for MulticoreFuture ... done
[17:02:30.671] MulticoreFuture started
[17:02:30.672] - Launch lazy future ... done
[17:02:30.672] run() for ‘MulticoreFuture’ ... done
[17:02:30.672] plan(): Setting new future strategy stack:
<environment: 0x55c74ac282c8> 
[17:02:30.673] List of future strategies:
[17:02:30.673] 1. sequential:
[17:02:30.673]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:30.673]    - tweaked: FALSE
[17:02:30.673]    - call: NULL
[17:02:30.674] plan(): nbrOfWorkers() = 1
<environment: 0x55c74b6cf900> 
[17:02:30.676] plan(): Setting new future strategy stack:
[17:02:30.677] List of future strategies:
[17:02:30.677] 1. multicore:
[17:02:30.677]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:30.677]    - tweaked: FALSE
[17:02:30.677]    - call: plan(strategy)
[17:02:30.682] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:30.684] resolve() on environment ...
[17:02:30.684]  recursive: 0
[17:02:30.685]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:30.685] signalConditionsASAP(numeric, pos=1) ...
[17:02:30.685] - nx: 4
[17:02:30.685] - relay: TRUE
[17:02:30.685] - stdout: TRUE
[17:02:30.686] - signal: TRUE
[17:02:30.686] - resignal: FALSE
[17:02:30.686] - force: TRUE
[17:02:30.686] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:30.686] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:30.686]  - until=2
[17:02:30.686]  - relaying element #2
[17:02:30.686] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:30.687] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:30.687] signalConditionsASAP(NULL, pos=1) ... done
[17:02:30.687]  length: 3 (resolved future 1)
[17:02:30.687] Future #2
[17:02:30.687] result() for MulticoreFuture ...
[17:02:30.687] result() for MulticoreFuture ... done
[17:02:30.687] result() for MulticoreFuture ...
[17:02:30.688] result() for MulticoreFuture ... done
[17:02:30.688] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:30.688] - nx: 4
[17:02:30.688] - relay: TRUE
[17:02:30.688] - stdout: TRUE
[17:02:30.688] - signal: TRUE
[17:02:30.688] - resignal: FALSE
[17:02:30.688] - force: TRUE
[17:02:30.688] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:30.689] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:30.689]  - until=2
[17:02:30.695]  - relaying element #2
[17:02:30.695] result() for MulticoreFuture ...
[17:02:30.695] result() for MulticoreFuture ... done
[17:02:30.695] result() for MulticoreFuture ...
[17:02:30.695] result() for MulticoreFuture ... done
[17:02:30.696] result() for MulticoreFuture ...
[17:02:30.696] result() for MulticoreFuture ... done
[17:02:30.696] result() for MulticoreFuture ...
[17:02:30.696] result() for MulticoreFuture ... done
[17:02:30.696] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:30.696] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:30.696] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:30.697]  length: 2 (resolved future 2)
[17:02:30.697] Future #3
[17:02:30.697] result() for MulticoreFuture ...
[17:02:30.698] result() for MulticoreFuture ...
[17:02:30.698] result() for MulticoreFuture ... done
[17:02:30.698] result() for MulticoreFuture ... done
[17:02:30.698] result() for MulticoreFuture ...
[17:02:30.698] result() for MulticoreFuture ... done
[17:02:30.699] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:30.699] - nx: 4
[17:02:30.699] - relay: TRUE
[17:02:30.699] - stdout: TRUE
[17:02:30.699] - signal: TRUE
[17:02:30.699] - resignal: FALSE
[17:02:30.699] - force: TRUE
[17:02:30.699] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:30.700] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:30.700]  - until=3
[17:02:30.700]  - relaying element #3
[17:02:30.700] result() for MulticoreFuture ...
[17:02:30.700] result() for MulticoreFuture ... done
[17:02:30.700] result() for MulticoreFuture ...
[17:02:30.700] result() for MulticoreFuture ... done
[17:02:30.701] result() for MulticoreFuture ...
[17:02:30.701] result() for MulticoreFuture ... done
[17:02:30.701] result() for MulticoreFuture ...
[17:02:30.701] result() for MulticoreFuture ... done
[17:02:30.701] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:30.701] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:30.701] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:30.702]  length: 1 (resolved future 3)
[17:02:30.702] Future #4
[17:02:30.702] result() for MulticoreFuture ...
[17:02:30.703] result() for MulticoreFuture ...
[17:02:30.703] result() for MulticoreFuture ... done
[17:02:30.703] result() for MulticoreFuture ... done
[17:02:30.703] result() for MulticoreFuture ...
[17:02:30.703] result() for MulticoreFuture ... done
[17:02:30.704] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:02:30.704] - nx: 4
[17:02:30.704] - relay: TRUE
[17:02:30.704] - stdout: TRUE
[17:02:30.704] - signal: TRUE
[17:02:30.704] - resignal: FALSE
[17:02:30.705] - force: TRUE
[17:02:30.705] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:30.705] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:30.705]  - until=4
[17:02:30.705]  - relaying element #4
[17:02:30.705] result() for MulticoreFuture ...
[17:02:30.705] result() for MulticoreFuture ... done
[17:02:30.706] result() for MulticoreFuture ...
[17:02:30.706] result() for MulticoreFuture ... done
[17:02:30.706] result() for MulticoreFuture ...
[17:02:30.706] result() for MulticoreFuture ... done
[17:02:30.706] result() for MulticoreFuture ...
[17:02:30.706] result() for MulticoreFuture ... done
[17:02:30.707] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:30.707] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:30.707] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:02:30.707]  length: 0 (resolved future 4)
[17:02:30.707] Relaying remaining futures
[17:02:30.707] signalConditionsASAP(NULL, pos=0) ...
[17:02:30.707] - nx: 4
[17:02:30.707] - relay: TRUE
[17:02:30.707] - stdout: TRUE
[17:02:30.707] - signal: TRUE
[17:02:30.708] - resignal: FALSE
[17:02:30.708] - force: TRUE
[17:02:30.708] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:30.708] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:30.708] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:30.708] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:30.708] signalConditionsASAP(NULL, pos=0) ... done
[17:02:30.708] resolve() on environment ... DONE
[17:02:30.708] result() for MulticoreFuture ...
[17:02:30.709] result() for MulticoreFuture ... done
[17:02:30.709] result() for MulticoreFuture ...
[17:02:30.709] result() for MulticoreFuture ... done
[17:02:30.709] result() for MulticoreFuture ...
[17:02:30.709] result() for MulticoreFuture ... done
[17:02:30.709] result() for MulticoreFuture ...
[17:02:30.709] result() for MulticoreFuture ... done
[17:02:30.710] result() for MulticoreFuture ...
[17:02:30.710] result() for MulticoreFuture ... done
[17:02:30.710] result() for MulticoreFuture ...
[17:02:30.710] result() for MulticoreFuture ... done
<environment: 0x55c74b7857a8> 
Dimensions: c(1, 6)
[17:02:30.711] getGlobalsAndPackages() ...
[17:02:30.711] Searching for globals...
[17:02:30.711] 
[17:02:30.712] Searching for globals ... DONE
[17:02:30.712] - globals: [0] <none>
[17:02:30.712] getGlobalsAndPackages() ... DONE
[17:02:30.712] run() for ‘Future’ ...
[17:02:30.712] - state: ‘created’
[17:02:30.713] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.717] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:30.717]   - Field: ‘label’
[17:02:30.717]   - Field: ‘local’
[17:02:30.717]   - Field: ‘owner’
[17:02:30.717]   - Field: ‘envir’
[17:02:30.717]   - Field: ‘workers’
[17:02:30.718]   - Field: ‘packages’
[17:02:30.718]   - Field: ‘gc’
[17:02:30.718]   - Field: ‘job’
[17:02:30.718]   - Field: ‘conditions’
[17:02:30.718]   - Field: ‘expr’
[17:02:30.718]   - Field: ‘uuid’
[17:02:30.718]   - Field: ‘seed’
[17:02:30.718]   - Field: ‘version’
[17:02:30.718]   - Field: ‘result’
[17:02:30.719]   - Field: ‘asynchronous’
[17:02:30.719]   - Field: ‘calls’
[17:02:30.719]   - Field: ‘globals’
[17:02:30.719]   - Field: ‘stdout’
[17:02:30.719]   - Field: ‘earlySignal’
[17:02:30.719]   - Field: ‘lazy’
[17:02:30.719]   - Field: ‘state’
[17:02:30.719] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:30.719] - Launch lazy future ...
[17:02:30.720] Packages needed by the future expression (n = 0): <none>
[17:02:30.720] Packages needed by future strategies (n = 0): <none>
[17:02:30.720] {
[17:02:30.720]     {
[17:02:30.720]         {
[17:02:30.720]             ...future.startTime <- base::Sys.time()
[17:02:30.720]             {
[17:02:30.720]                 {
[17:02:30.720]                   {
[17:02:30.720]                     {
[17:02:30.720]                       base::local({
[17:02:30.720]                         has_future <- base::requireNamespace("future", 
[17:02:30.720]                           quietly = TRUE)
[17:02:30.720]                         if (has_future) {
[17:02:30.720]                           ns <- base::getNamespace("future")
[17:02:30.720]                           version <- ns[[".package"]][["version"]]
[17:02:30.720]                           if (is.null(version)) 
[17:02:30.720]                             version <- utils::packageVersion("future")
[17:02:30.720]                         }
[17:02:30.720]                         else {
[17:02:30.720]                           version <- NULL
[17:02:30.720]                         }
[17:02:30.720]                         if (!has_future || version < "1.8.0") {
[17:02:30.720]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.720]                             "", base::R.version$version.string), 
[17:02:30.720]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.720]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.720]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.720]                               "release", "version")], collapse = " "), 
[17:02:30.720]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.720]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.720]                             info)
[17:02:30.720]                           info <- base::paste(info, collapse = "; ")
[17:02:30.720]                           if (!has_future) {
[17:02:30.720]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.720]                               info)
[17:02:30.720]                           }
[17:02:30.720]                           else {
[17:02:30.720]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.720]                               info, version)
[17:02:30.720]                           }
[17:02:30.720]                           base::stop(msg)
[17:02:30.720]                         }
[17:02:30.720]                       })
[17:02:30.720]                     }
[17:02:30.720]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.720]                     base::options(mc.cores = 1L)
[17:02:30.720]                   }
[17:02:30.720]                   ...future.strategy.old <- future::plan("list")
[17:02:30.720]                   options(future.plan = NULL)
[17:02:30.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.720]                 }
[17:02:30.720]                 ...future.workdir <- getwd()
[17:02:30.720]             }
[17:02:30.720]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.720]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.720]         }
[17:02:30.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.720]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.720]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.720]             base::names(...future.oldOptions))
[17:02:30.720]     }
[17:02:30.720]     if (FALSE) {
[17:02:30.720]     }
[17:02:30.720]     else {
[17:02:30.720]         if (TRUE) {
[17:02:30.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.720]                 open = "w")
[17:02:30.720]         }
[17:02:30.720]         else {
[17:02:30.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.720]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.720]         }
[17:02:30.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.720]             base::sink(type = "output", split = FALSE)
[17:02:30.720]             base::close(...future.stdout)
[17:02:30.720]         }, add = TRUE)
[17:02:30.720]     }
[17:02:30.720]     ...future.frame <- base::sys.nframe()
[17:02:30.720]     ...future.conditions <- base::list()
[17:02:30.720]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.720]     if (FALSE) {
[17:02:30.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.720]     }
[17:02:30.720]     ...future.result <- base::tryCatch({
[17:02:30.720]         base::withCallingHandlers({
[17:02:30.720]             ...future.value <- base::withVisible(base::local({
[17:02:30.720]                 withCallingHandlers({
[17:02:30.720]                   2
[17:02:30.720]                 }, immediateCondition = function(cond) {
[17:02:30.720]                   save_rds <- function (object, pathname, ...) 
[17:02:30.720]                   {
[17:02:30.720]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:30.720]                     if (file_test("-f", pathname_tmp)) {
[17:02:30.720]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.720]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:30.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.720]                         fi_tmp[["mtime"]])
[17:02:30.720]                     }
[17:02:30.720]                     tryCatch({
[17:02:30.720]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:30.720]                     }, error = function(ex) {
[17:02:30.720]                       msg <- conditionMessage(ex)
[17:02:30.720]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.720]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:30.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.720]                         fi_tmp[["mtime"]], msg)
[17:02:30.720]                       ex$message <- msg
[17:02:30.720]                       stop(ex)
[17:02:30.720]                     })
[17:02:30.720]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:30.720]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:30.720]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:30.720]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.720]                       fi <- file.info(pathname)
[17:02:30.720]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:30.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.720]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:30.720]                         fi[["size"]], fi[["mtime"]])
[17:02:30.720]                       stop(msg)
[17:02:30.720]                     }
[17:02:30.720]                     invisible(pathname)
[17:02:30.720]                   }
[17:02:30.720]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:30.720]                     rootPath = tempdir()) 
[17:02:30.720]                   {
[17:02:30.720]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:30.720]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:30.720]                       tmpdir = path, fileext = ".rds")
[17:02:30.720]                     save_rds(obj, file)
[17:02:30.720]                   }
[17:02:30.720]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:30.720]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.720]                   {
[17:02:30.720]                     inherits <- base::inherits
[17:02:30.720]                     invokeRestart <- base::invokeRestart
[17:02:30.720]                     is.null <- base::is.null
[17:02:30.720]                     muffled <- FALSE
[17:02:30.720]                     if (inherits(cond, "message")) {
[17:02:30.720]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.720]                       if (muffled) 
[17:02:30.720]                         invokeRestart("muffleMessage")
[17:02:30.720]                     }
[17:02:30.720]                     else if (inherits(cond, "warning")) {
[17:02:30.720]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.720]                       if (muffled) 
[17:02:30.720]                         invokeRestart("muffleWarning")
[17:02:30.720]                     }
[17:02:30.720]                     else if (inherits(cond, "condition")) {
[17:02:30.720]                       if (!is.null(pattern)) {
[17:02:30.720]                         computeRestarts <- base::computeRestarts
[17:02:30.720]                         grepl <- base::grepl
[17:02:30.720]                         restarts <- computeRestarts(cond)
[17:02:30.720]                         for (restart in restarts) {
[17:02:30.720]                           name <- restart$name
[17:02:30.720]                           if (is.null(name)) 
[17:02:30.720]                             next
[17:02:30.720]                           if (!grepl(pattern, name)) 
[17:02:30.720]                             next
[17:02:30.720]                           invokeRestart(restart)
[17:02:30.720]                           muffled <- TRUE
[17:02:30.720]                           break
[17:02:30.720]                         }
[17:02:30.720]                       }
[17:02:30.720]                     }
[17:02:30.720]                     invisible(muffled)
[17:02:30.720]                   }
[17:02:30.720]                   muffleCondition(cond)
[17:02:30.720]                 })
[17:02:30.720]             }))
[17:02:30.720]             future::FutureResult(value = ...future.value$value, 
[17:02:30.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.720]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.720]                     ...future.globalenv.names))
[17:02:30.720]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.720]         }, condition = base::local({
[17:02:30.720]             c <- base::c
[17:02:30.720]             inherits <- base::inherits
[17:02:30.720]             invokeRestart <- base::invokeRestart
[17:02:30.720]             length <- base::length
[17:02:30.720]             list <- base::list
[17:02:30.720]             seq.int <- base::seq.int
[17:02:30.720]             signalCondition <- base::signalCondition
[17:02:30.720]             sys.calls <- base::sys.calls
[17:02:30.720]             `[[` <- base::`[[`
[17:02:30.720]             `+` <- base::`+`
[17:02:30.720]             `<<-` <- base::`<<-`
[17:02:30.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.720]                   3L)]
[17:02:30.720]             }
[17:02:30.720]             function(cond) {
[17:02:30.720]                 is_error <- inherits(cond, "error")
[17:02:30.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.720]                   NULL)
[17:02:30.720]                 if (is_error) {
[17:02:30.720]                   sessionInformation <- function() {
[17:02:30.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.720]                       search = base::search(), system = base::Sys.info())
[17:02:30.720]                   }
[17:02:30.720]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.720]                     cond$call), session = sessionInformation(), 
[17:02:30.720]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.720]                   signalCondition(cond)
[17:02:30.720]                 }
[17:02:30.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.720]                 "immediateCondition"))) {
[17:02:30.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.720]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.720]                   if (TRUE && !signal) {
[17:02:30.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.720]                     {
[17:02:30.720]                       inherits <- base::inherits
[17:02:30.720]                       invokeRestart <- base::invokeRestart
[17:02:30.720]                       is.null <- base::is.null
[17:02:30.720]                       muffled <- FALSE
[17:02:30.720]                       if (inherits(cond, "message")) {
[17:02:30.720]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.720]                         if (muffled) 
[17:02:30.720]                           invokeRestart("muffleMessage")
[17:02:30.720]                       }
[17:02:30.720]                       else if (inherits(cond, "warning")) {
[17:02:30.720]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.720]                         if (muffled) 
[17:02:30.720]                           invokeRestart("muffleWarning")
[17:02:30.720]                       }
[17:02:30.720]                       else if (inherits(cond, "condition")) {
[17:02:30.720]                         if (!is.null(pattern)) {
[17:02:30.720]                           computeRestarts <- base::computeRestarts
[17:02:30.720]                           grepl <- base::grepl
[17:02:30.720]                           restarts <- computeRestarts(cond)
[17:02:30.720]                           for (restart in restarts) {
[17:02:30.720]                             name <- restart$name
[17:02:30.720]                             if (is.null(name)) 
[17:02:30.720]                               next
[17:02:30.720]                             if (!grepl(pattern, name)) 
[17:02:30.720]                               next
[17:02:30.720]                             invokeRestart(restart)
[17:02:30.720]                             muffled <- TRUE
[17:02:30.720]                             break
[17:02:30.720]                           }
[17:02:30.720]                         }
[17:02:30.720]                       }
[17:02:30.720]                       invisible(muffled)
[17:02:30.720]                     }
[17:02:30.720]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.720]                   }
[17:02:30.720]                 }
[17:02:30.720]                 else {
[17:02:30.720]                   if (TRUE) {
[17:02:30.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.720]                     {
[17:02:30.720]                       inherits <- base::inherits
[17:02:30.720]                       invokeRestart <- base::invokeRestart
[17:02:30.720]                       is.null <- base::is.null
[17:02:30.720]                       muffled <- FALSE
[17:02:30.720]                       if (inherits(cond, "message")) {
[17:02:30.720]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.720]                         if (muffled) 
[17:02:30.720]                           invokeRestart("muffleMessage")
[17:02:30.720]                       }
[17:02:30.720]                       else if (inherits(cond, "warning")) {
[17:02:30.720]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.720]                         if (muffled) 
[17:02:30.720]                           invokeRestart("muffleWarning")
[17:02:30.720]                       }
[17:02:30.720]                       else if (inherits(cond, "condition")) {
[17:02:30.720]                         if (!is.null(pattern)) {
[17:02:30.720]                           computeRestarts <- base::computeRestarts
[17:02:30.720]                           grepl <- base::grepl
[17:02:30.720]                           restarts <- computeRestarts(cond)
[17:02:30.720]                           for (restart in restarts) {
[17:02:30.720]                             name <- restart$name
[17:02:30.720]                             if (is.null(name)) 
[17:02:30.720]                               next
[17:02:30.720]                             if (!grepl(pattern, name)) 
[17:02:30.720]                               next
[17:02:30.720]                             invokeRestart(restart)
[17:02:30.720]                             muffled <- TRUE
[17:02:30.720]                             break
[17:02:30.720]                           }
[17:02:30.720]                         }
[17:02:30.720]                       }
[17:02:30.720]                       invisible(muffled)
[17:02:30.720]                     }
[17:02:30.720]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.720]                   }
[17:02:30.720]                 }
[17:02:30.720]             }
[17:02:30.720]         }))
[17:02:30.720]     }, error = function(ex) {
[17:02:30.720]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.720]                 ...future.rng), started = ...future.startTime, 
[17:02:30.720]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.720]             version = "1.8"), class = "FutureResult")
[17:02:30.720]     }, finally = {
[17:02:30.720]         if (!identical(...future.workdir, getwd())) 
[17:02:30.720]             setwd(...future.workdir)
[17:02:30.720]         {
[17:02:30.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.720]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.720]             }
[17:02:30.720]             base::options(...future.oldOptions)
[17:02:30.720]             if (.Platform$OS.type == "windows") {
[17:02:30.720]                 old_names <- names(...future.oldEnvVars)
[17:02:30.720]                 envs <- base::Sys.getenv()
[17:02:30.720]                 names <- names(envs)
[17:02:30.720]                 common <- intersect(names, old_names)
[17:02:30.720]                 added <- setdiff(names, old_names)
[17:02:30.720]                 removed <- setdiff(old_names, names)
[17:02:30.720]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.720]                   envs[common]]
[17:02:30.720]                 NAMES <- toupper(changed)
[17:02:30.720]                 args <- list()
[17:02:30.720]                 for (kk in seq_along(NAMES)) {
[17:02:30.720]                   name <- changed[[kk]]
[17:02:30.720]                   NAME <- NAMES[[kk]]
[17:02:30.720]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.720]                     next
[17:02:30.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.720]                 }
[17:02:30.720]                 NAMES <- toupper(added)
[17:02:30.720]                 for (kk in seq_along(NAMES)) {
[17:02:30.720]                   name <- added[[kk]]
[17:02:30.720]                   NAME <- NAMES[[kk]]
[17:02:30.720]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.720]                     next
[17:02:30.720]                   args[[name]] <- ""
[17:02:30.720]                 }
[17:02:30.720]                 NAMES <- toupper(removed)
[17:02:30.720]                 for (kk in seq_along(NAMES)) {
[17:02:30.720]                   name <- removed[[kk]]
[17:02:30.720]                   NAME <- NAMES[[kk]]
[17:02:30.720]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.720]                     next
[17:02:30.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.720]                 }
[17:02:30.720]                 if (length(args) > 0) 
[17:02:30.720]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.720]             }
[17:02:30.720]             else {
[17:02:30.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.720]             }
[17:02:30.720]             {
[17:02:30.720]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.720]                   0L) {
[17:02:30.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.720]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.720]                   base::options(opts)
[17:02:30.720]                 }
[17:02:30.720]                 {
[17:02:30.720]                   {
[17:02:30.720]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.720]                     NULL
[17:02:30.720]                   }
[17:02:30.720]                   options(future.plan = NULL)
[17:02:30.720]                   if (is.na(NA_character_)) 
[17:02:30.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.720]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.720]                     .init = FALSE)
[17:02:30.720]                 }
[17:02:30.720]             }
[17:02:30.720]         }
[17:02:30.720]     })
[17:02:30.720]     if (TRUE) {
[17:02:30.720]         base::sink(type = "output", split = FALSE)
[17:02:30.720]         if (TRUE) {
[17:02:30.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.720]         }
[17:02:30.720]         else {
[17:02:30.720]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.720]         }
[17:02:30.720]         base::close(...future.stdout)
[17:02:30.720]         ...future.stdout <- NULL
[17:02:30.720]     }
[17:02:30.720]     ...future.result$conditions <- ...future.conditions
[17:02:30.720]     ...future.result$finished <- base::Sys.time()
[17:02:30.720]     ...future.result
[17:02:30.720] }
[17:02:30.723] requestCore(): workers = 2
[17:02:30.725] MulticoreFuture started
[17:02:30.725] - Launch lazy future ... done
[17:02:30.726] run() for ‘MulticoreFuture’ ... done
[17:02:30.726] getGlobalsAndPackages() ...
[17:02:30.726] Searching for globals...
[17:02:30.726] plan(): Setting new future strategy stack:
[17:02:30.727] 
[17:02:30.726] List of future strategies:
[17:02:30.726] 1. sequential:
[17:02:30.726]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:30.726]    - tweaked: FALSE
[17:02:30.726]    - call: NULL
[17:02:30.727] Searching for globals ... DONE
[17:02:30.727] - globals: [0] <none>
[17:02:30.727] plan(): nbrOfWorkers() = 1
[17:02:30.727] getGlobalsAndPackages() ... DONE
[17:02:30.728] run() for ‘Future’ ...
[17:02:30.728] - state: ‘created’
[17:02:30.728] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.729] plan(): Setting new future strategy stack:
[17:02:30.729] List of future strategies:
[17:02:30.729] 1. multicore:
[17:02:30.729]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:30.729]    - tweaked: FALSE
[17:02:30.729]    - call: plan(strategy)
[17:02:30.734] plan(): nbrOfWorkers() = 2
[17:02:30.734] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.734] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:30.734]   - Field: ‘label’
[17:02:30.734]   - Field: ‘local’
[17:02:30.734]   - Field: ‘owner’
[17:02:30.734]   - Field: ‘envir’
[17:02:30.735]   - Field: ‘workers’
[17:02:30.735]   - Field: ‘packages’
[17:02:30.735]   - Field: ‘gc’
[17:02:30.735]   - Field: ‘job’
[17:02:30.735]   - Field: ‘conditions’
[17:02:30.735]   - Field: ‘expr’
[17:02:30.736]   - Field: ‘uuid’
[17:02:30.736]   - Field: ‘seed’
[17:02:30.736]   - Field: ‘version’
[17:02:30.736]   - Field: ‘result’
[17:02:30.736]   - Field: ‘asynchronous’
[17:02:30.736]   - Field: ‘calls’
[17:02:30.737]   - Field: ‘globals’
[17:02:30.737]   - Field: ‘stdout’
[17:02:30.737]   - Field: ‘earlySignal’
[17:02:30.737]   - Field: ‘lazy’
[17:02:30.737]   - Field: ‘state’
[17:02:30.738] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:30.738] - Launch lazy future ...
[17:02:30.738] Packages needed by the future expression (n = 0): <none>
[17:02:30.738] Packages needed by future strategies (n = 0): <none>
[17:02:30.739] {
[17:02:30.739]     {
[17:02:30.739]         {
[17:02:30.739]             ...future.startTime <- base::Sys.time()
[17:02:30.739]             {
[17:02:30.739]                 {
[17:02:30.739]                   {
[17:02:30.739]                     {
[17:02:30.739]                       base::local({
[17:02:30.739]                         has_future <- base::requireNamespace("future", 
[17:02:30.739]                           quietly = TRUE)
[17:02:30.739]                         if (has_future) {
[17:02:30.739]                           ns <- base::getNamespace("future")
[17:02:30.739]                           version <- ns[[".package"]][["version"]]
[17:02:30.739]                           if (is.null(version)) 
[17:02:30.739]                             version <- utils::packageVersion("future")
[17:02:30.739]                         }
[17:02:30.739]                         else {
[17:02:30.739]                           version <- NULL
[17:02:30.739]                         }
[17:02:30.739]                         if (!has_future || version < "1.8.0") {
[17:02:30.739]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.739]                             "", base::R.version$version.string), 
[17:02:30.739]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.739]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.739]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.739]                               "release", "version")], collapse = " "), 
[17:02:30.739]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.739]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.739]                             info)
[17:02:30.739]                           info <- base::paste(info, collapse = "; ")
[17:02:30.739]                           if (!has_future) {
[17:02:30.739]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.739]                               info)
[17:02:30.739]                           }
[17:02:30.739]                           else {
[17:02:30.739]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.739]                               info, version)
[17:02:30.739]                           }
[17:02:30.739]                           base::stop(msg)
[17:02:30.739]                         }
[17:02:30.739]                       })
[17:02:30.739]                     }
[17:02:30.739]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.739]                     base::options(mc.cores = 1L)
[17:02:30.739]                   }
[17:02:30.739]                   ...future.strategy.old <- future::plan("list")
[17:02:30.739]                   options(future.plan = NULL)
[17:02:30.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.739]                 }
[17:02:30.739]                 ...future.workdir <- getwd()
[17:02:30.739]             }
[17:02:30.739]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.739]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.739]         }
[17:02:30.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.739]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.739]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.739]             base::names(...future.oldOptions))
[17:02:30.739]     }
[17:02:30.739]     if (FALSE) {
[17:02:30.739]     }
[17:02:30.739]     else {
[17:02:30.739]         if (TRUE) {
[17:02:30.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.739]                 open = "w")
[17:02:30.739]         }
[17:02:30.739]         else {
[17:02:30.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.739]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.739]         }
[17:02:30.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.739]             base::sink(type = "output", split = FALSE)
[17:02:30.739]             base::close(...future.stdout)
[17:02:30.739]         }, add = TRUE)
[17:02:30.739]     }
[17:02:30.739]     ...future.frame <- base::sys.nframe()
[17:02:30.739]     ...future.conditions <- base::list()
[17:02:30.739]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.739]     if (FALSE) {
[17:02:30.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.739]     }
[17:02:30.739]     ...future.result <- base::tryCatch({
[17:02:30.739]         base::withCallingHandlers({
[17:02:30.739]             ...future.value <- base::withVisible(base::local({
[17:02:30.739]                 withCallingHandlers({
[17:02:30.739]                   NULL
[17:02:30.739]                 }, immediateCondition = function(cond) {
[17:02:30.739]                   save_rds <- function (object, pathname, ...) 
[17:02:30.739]                   {
[17:02:30.739]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:30.739]                     if (file_test("-f", pathname_tmp)) {
[17:02:30.739]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.739]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:30.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.739]                         fi_tmp[["mtime"]])
[17:02:30.739]                     }
[17:02:30.739]                     tryCatch({
[17:02:30.739]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:30.739]                     }, error = function(ex) {
[17:02:30.739]                       msg <- conditionMessage(ex)
[17:02:30.739]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.739]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:30.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.739]                         fi_tmp[["mtime"]], msg)
[17:02:30.739]                       ex$message <- msg
[17:02:30.739]                       stop(ex)
[17:02:30.739]                     })
[17:02:30.739]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:30.739]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:30.739]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:30.739]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.739]                       fi <- file.info(pathname)
[17:02:30.739]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:30.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.739]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:30.739]                         fi[["size"]], fi[["mtime"]])
[17:02:30.739]                       stop(msg)
[17:02:30.739]                     }
[17:02:30.739]                     invisible(pathname)
[17:02:30.739]                   }
[17:02:30.739]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:30.739]                     rootPath = tempdir()) 
[17:02:30.739]                   {
[17:02:30.739]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:30.739]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:30.739]                       tmpdir = path, fileext = ".rds")
[17:02:30.739]                     save_rds(obj, file)
[17:02:30.739]                   }
[17:02:30.739]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:30.739]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.739]                   {
[17:02:30.739]                     inherits <- base::inherits
[17:02:30.739]                     invokeRestart <- base::invokeRestart
[17:02:30.739]                     is.null <- base::is.null
[17:02:30.739]                     muffled <- FALSE
[17:02:30.739]                     if (inherits(cond, "message")) {
[17:02:30.739]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.739]                       if (muffled) 
[17:02:30.739]                         invokeRestart("muffleMessage")
[17:02:30.739]                     }
[17:02:30.739]                     else if (inherits(cond, "warning")) {
[17:02:30.739]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.739]                       if (muffled) 
[17:02:30.739]                         invokeRestart("muffleWarning")
[17:02:30.739]                     }
[17:02:30.739]                     else if (inherits(cond, "condition")) {
[17:02:30.739]                       if (!is.null(pattern)) {
[17:02:30.739]                         computeRestarts <- base::computeRestarts
[17:02:30.739]                         grepl <- base::grepl
[17:02:30.739]                         restarts <- computeRestarts(cond)
[17:02:30.739]                         for (restart in restarts) {
[17:02:30.739]                           name <- restart$name
[17:02:30.739]                           if (is.null(name)) 
[17:02:30.739]                             next
[17:02:30.739]                           if (!grepl(pattern, name)) 
[17:02:30.739]                             next
[17:02:30.739]                           invokeRestart(restart)
[17:02:30.739]                           muffled <- TRUE
[17:02:30.739]                           break
[17:02:30.739]                         }
[17:02:30.739]                       }
[17:02:30.739]                     }
[17:02:30.739]                     invisible(muffled)
[17:02:30.739]                   }
[17:02:30.739]                   muffleCondition(cond)
[17:02:30.739]                 })
[17:02:30.739]             }))
[17:02:30.739]             future::FutureResult(value = ...future.value$value, 
[17:02:30.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.739]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.739]                     ...future.globalenv.names))
[17:02:30.739]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.739]         }, condition = base::local({
[17:02:30.739]             c <- base::c
[17:02:30.739]             inherits <- base::inherits
[17:02:30.739]             invokeRestart <- base::invokeRestart
[17:02:30.739]             length <- base::length
[17:02:30.739]             list <- base::list
[17:02:30.739]             seq.int <- base::seq.int
[17:02:30.739]             signalCondition <- base::signalCondition
[17:02:30.739]             sys.calls <- base::sys.calls
[17:02:30.739]             `[[` <- base::`[[`
[17:02:30.739]             `+` <- base::`+`
[17:02:30.739]             `<<-` <- base::`<<-`
[17:02:30.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.739]                   3L)]
[17:02:30.739]             }
[17:02:30.739]             function(cond) {
[17:02:30.739]                 is_error <- inherits(cond, "error")
[17:02:30.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.739]                   NULL)
[17:02:30.739]                 if (is_error) {
[17:02:30.739]                   sessionInformation <- function() {
[17:02:30.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.739]                       search = base::search(), system = base::Sys.info())
[17:02:30.739]                   }
[17:02:30.739]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.739]                     cond$call), session = sessionInformation(), 
[17:02:30.739]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.739]                   signalCondition(cond)
[17:02:30.739]                 }
[17:02:30.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.739]                 "immediateCondition"))) {
[17:02:30.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.739]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.739]                   if (TRUE && !signal) {
[17:02:30.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.739]                     {
[17:02:30.739]                       inherits <- base::inherits
[17:02:30.739]                       invokeRestart <- base::invokeRestart
[17:02:30.739]                       is.null <- base::is.null
[17:02:30.739]                       muffled <- FALSE
[17:02:30.739]                       if (inherits(cond, "message")) {
[17:02:30.739]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.739]                         if (muffled) 
[17:02:30.739]                           invokeRestart("muffleMessage")
[17:02:30.739]                       }
[17:02:30.739]                       else if (inherits(cond, "warning")) {
[17:02:30.739]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.739]                         if (muffled) 
[17:02:30.739]                           invokeRestart("muffleWarning")
[17:02:30.739]                       }
[17:02:30.739]                       else if (inherits(cond, "condition")) {
[17:02:30.739]                         if (!is.null(pattern)) {
[17:02:30.739]                           computeRestarts <- base::computeRestarts
[17:02:30.739]                           grepl <- base::grepl
[17:02:30.739]                           restarts <- computeRestarts(cond)
[17:02:30.739]                           for (restart in restarts) {
[17:02:30.739]                             name <- restart$name
[17:02:30.739]                             if (is.null(name)) 
[17:02:30.739]                               next
[17:02:30.739]                             if (!grepl(pattern, name)) 
[17:02:30.739]                               next
[17:02:30.739]                             invokeRestart(restart)
[17:02:30.739]                             muffled <- TRUE
[17:02:30.739]                             break
[17:02:30.739]                           }
[17:02:30.739]                         }
[17:02:30.739]                       }
[17:02:30.739]                       invisible(muffled)
[17:02:30.739]                     }
[17:02:30.739]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.739]                   }
[17:02:30.739]                 }
[17:02:30.739]                 else {
[17:02:30.739]                   if (TRUE) {
[17:02:30.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.739]                     {
[17:02:30.739]                       inherits <- base::inherits
[17:02:30.739]                       invokeRestart <- base::invokeRestart
[17:02:30.739]                       is.null <- base::is.null
[17:02:30.739]                       muffled <- FALSE
[17:02:30.739]                       if (inherits(cond, "message")) {
[17:02:30.739]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.739]                         if (muffled) 
[17:02:30.739]                           invokeRestart("muffleMessage")
[17:02:30.739]                       }
[17:02:30.739]                       else if (inherits(cond, "warning")) {
[17:02:30.739]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.739]                         if (muffled) 
[17:02:30.739]                           invokeRestart("muffleWarning")
[17:02:30.739]                       }
[17:02:30.739]                       else if (inherits(cond, "condition")) {
[17:02:30.739]                         if (!is.null(pattern)) {
[17:02:30.739]                           computeRestarts <- base::computeRestarts
[17:02:30.739]                           grepl <- base::grepl
[17:02:30.739]                           restarts <- computeRestarts(cond)
[17:02:30.739]                           for (restart in restarts) {
[17:02:30.739]                             name <- restart$name
[17:02:30.739]                             if (is.null(name)) 
[17:02:30.739]                               next
[17:02:30.739]                             if (!grepl(pattern, name)) 
[17:02:30.739]                               next
[17:02:30.739]                             invokeRestart(restart)
[17:02:30.739]                             muffled <- TRUE
[17:02:30.739]                             break
[17:02:30.739]                           }
[17:02:30.739]                         }
[17:02:30.739]                       }
[17:02:30.739]                       invisible(muffled)
[17:02:30.739]                     }
[17:02:30.739]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.739]                   }
[17:02:30.739]                 }
[17:02:30.739]             }
[17:02:30.739]         }))
[17:02:30.739]     }, error = function(ex) {
[17:02:30.739]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.739]                 ...future.rng), started = ...future.startTime, 
[17:02:30.739]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.739]             version = "1.8"), class = "FutureResult")
[17:02:30.739]     }, finally = {
[17:02:30.739]         if (!identical(...future.workdir, getwd())) 
[17:02:30.739]             setwd(...future.workdir)
[17:02:30.739]         {
[17:02:30.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.739]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.739]             }
[17:02:30.739]             base::options(...future.oldOptions)
[17:02:30.739]             if (.Platform$OS.type == "windows") {
[17:02:30.739]                 old_names <- names(...future.oldEnvVars)
[17:02:30.739]                 envs <- base::Sys.getenv()
[17:02:30.739]                 names <- names(envs)
[17:02:30.739]                 common <- intersect(names, old_names)
[17:02:30.739]                 added <- setdiff(names, old_names)
[17:02:30.739]                 removed <- setdiff(old_names, names)
[17:02:30.739]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.739]                   envs[common]]
[17:02:30.739]                 NAMES <- toupper(changed)
[17:02:30.739]                 args <- list()
[17:02:30.739]                 for (kk in seq_along(NAMES)) {
[17:02:30.739]                   name <- changed[[kk]]
[17:02:30.739]                   NAME <- NAMES[[kk]]
[17:02:30.739]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.739]                     next
[17:02:30.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.739]                 }
[17:02:30.739]                 NAMES <- toupper(added)
[17:02:30.739]                 for (kk in seq_along(NAMES)) {
[17:02:30.739]                   name <- added[[kk]]
[17:02:30.739]                   NAME <- NAMES[[kk]]
[17:02:30.739]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.739]                     next
[17:02:30.739]                   args[[name]] <- ""
[17:02:30.739]                 }
[17:02:30.739]                 NAMES <- toupper(removed)
[17:02:30.739]                 for (kk in seq_along(NAMES)) {
[17:02:30.739]                   name <- removed[[kk]]
[17:02:30.739]                   NAME <- NAMES[[kk]]
[17:02:30.739]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.739]                     next
[17:02:30.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.739]                 }
[17:02:30.739]                 if (length(args) > 0) 
[17:02:30.739]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.739]             }
[17:02:30.739]             else {
[17:02:30.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.739]             }
[17:02:30.739]             {
[17:02:30.739]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.739]                   0L) {
[17:02:30.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.739]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.739]                   base::options(opts)
[17:02:30.739]                 }
[17:02:30.739]                 {
[17:02:30.739]                   {
[17:02:30.739]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.739]                     NULL
[17:02:30.739]                   }
[17:02:30.739]                   options(future.plan = NULL)
[17:02:30.739]                   if (is.na(NA_character_)) 
[17:02:30.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.739]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.739]                     .init = FALSE)
[17:02:30.739]                 }
[17:02:30.739]             }
[17:02:30.739]         }
[17:02:30.739]     })
[17:02:30.739]     if (TRUE) {
[17:02:30.739]         base::sink(type = "output", split = FALSE)
[17:02:30.739]         if (TRUE) {
[17:02:30.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.739]         }
[17:02:30.739]         else {
[17:02:30.739]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.739]         }
[17:02:30.739]         base::close(...future.stdout)
[17:02:30.739]         ...future.stdout <- NULL
[17:02:30.739]     }
[17:02:30.739]     ...future.result$conditions <- ...future.conditions
[17:02:30.739]     ...future.result$finished <- base::Sys.time()
[17:02:30.739]     ...future.result
[17:02:30.739] }
[17:02:30.743] requestCore(): workers = 2
[17:02:30.746] MulticoreFuture started
[17:02:30.746] - Launch lazy future ... done
[17:02:30.746] run() for ‘MulticoreFuture’ ... done
[17:02:30.747] plan(): Setting new future strategy stack:
[17:02:30.747] getGlobalsAndPackages() ...
[17:02:30.748] Searching for globals...
[17:02:30.747] List of future strategies:
[17:02:30.747] 1. sequential:
[17:02:30.747]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:30.747]    - tweaked: FALSE
[17:02:30.747]    - call: NULL
[17:02:30.748] plan(): nbrOfWorkers() = 1
[17:02:30.749] - globals found: [1] ‘{’
[17:02:30.749] Searching for globals ... DONE
[17:02:30.750] Resolving globals: FALSE
[17:02:30.750] 
[17:02:30.750] 
[17:02:30.750] getGlobalsAndPackages() ... DONE
[17:02:30.751] plan(): Setting new future strategy stack:
[17:02:30.751] run() for ‘Future’ ...
[17:02:30.751] - state: ‘created’
[17:02:30.751] List of future strategies:
[17:02:30.751] 1. multicore:
[17:02:30.751]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:30.751]    - tweaked: FALSE
[17:02:30.751]    - call: plan(strategy)
[17:02:30.751] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.757] plan(): nbrOfWorkers() = 2
[17:02:30.757] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.757] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:30.757]   - Field: ‘label’
[17:02:30.758]   - Field: ‘local’
[17:02:30.758]   - Field: ‘owner’
[17:02:30.758]   - Field: ‘envir’
[17:02:30.758]   - Field: ‘workers’
[17:02:30.758]   - Field: ‘packages’
[17:02:30.758]   - Field: ‘gc’
[17:02:30.758]   - Field: ‘job’
[17:02:30.759]   - Field: ‘conditions’
[17:02:30.759]   - Field: ‘expr’
[17:02:30.759]   - Field: ‘uuid’
[17:02:30.759]   - Field: ‘seed’
[17:02:30.759]   - Field: ‘version’
[17:02:30.759]   - Field: ‘result’
[17:02:30.760]   - Field: ‘asynchronous’
[17:02:30.760]   - Field: ‘calls’
[17:02:30.760]   - Field: ‘globals’
[17:02:30.760]   - Field: ‘stdout’
[17:02:30.760]   - Field: ‘earlySignal’
[17:02:30.760]   - Field: ‘lazy’
[17:02:30.760]   - Field: ‘state’
[17:02:30.761] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:30.761] - Launch lazy future ...
[17:02:30.761] Packages needed by the future expression (n = 0): <none>
[17:02:30.761] Packages needed by future strategies (n = 0): <none>
[17:02:30.762] {
[17:02:30.762]     {
[17:02:30.762]         {
[17:02:30.762]             ...future.startTime <- base::Sys.time()
[17:02:30.762]             {
[17:02:30.762]                 {
[17:02:30.762]                   {
[17:02:30.762]                     {
[17:02:30.762]                       base::local({
[17:02:30.762]                         has_future <- base::requireNamespace("future", 
[17:02:30.762]                           quietly = TRUE)
[17:02:30.762]                         if (has_future) {
[17:02:30.762]                           ns <- base::getNamespace("future")
[17:02:30.762]                           version <- ns[[".package"]][["version"]]
[17:02:30.762]                           if (is.null(version)) 
[17:02:30.762]                             version <- utils::packageVersion("future")
[17:02:30.762]                         }
[17:02:30.762]                         else {
[17:02:30.762]                           version <- NULL
[17:02:30.762]                         }
[17:02:30.762]                         if (!has_future || version < "1.8.0") {
[17:02:30.762]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.762]                             "", base::R.version$version.string), 
[17:02:30.762]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.762]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.762]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.762]                               "release", "version")], collapse = " "), 
[17:02:30.762]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.762]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.762]                             info)
[17:02:30.762]                           info <- base::paste(info, collapse = "; ")
[17:02:30.762]                           if (!has_future) {
[17:02:30.762]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.762]                               info)
[17:02:30.762]                           }
[17:02:30.762]                           else {
[17:02:30.762]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.762]                               info, version)
[17:02:30.762]                           }
[17:02:30.762]                           base::stop(msg)
[17:02:30.762]                         }
[17:02:30.762]                       })
[17:02:30.762]                     }
[17:02:30.762]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.762]                     base::options(mc.cores = 1L)
[17:02:30.762]                   }
[17:02:30.762]                   ...future.strategy.old <- future::plan("list")
[17:02:30.762]                   options(future.plan = NULL)
[17:02:30.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.762]                 }
[17:02:30.762]                 ...future.workdir <- getwd()
[17:02:30.762]             }
[17:02:30.762]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.762]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.762]         }
[17:02:30.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.762]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.762]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.762]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.762]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.762]             base::names(...future.oldOptions))
[17:02:30.762]     }
[17:02:30.762]     if (FALSE) {
[17:02:30.762]     }
[17:02:30.762]     else {
[17:02:30.762]         if (TRUE) {
[17:02:30.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.762]                 open = "w")
[17:02:30.762]         }
[17:02:30.762]         else {
[17:02:30.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.762]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.762]         }
[17:02:30.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.762]             base::sink(type = "output", split = FALSE)
[17:02:30.762]             base::close(...future.stdout)
[17:02:30.762]         }, add = TRUE)
[17:02:30.762]     }
[17:02:30.762]     ...future.frame <- base::sys.nframe()
[17:02:30.762]     ...future.conditions <- base::list()
[17:02:30.762]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.762]     if (FALSE) {
[17:02:30.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.762]     }
[17:02:30.762]     ...future.result <- base::tryCatch({
[17:02:30.762]         base::withCallingHandlers({
[17:02:30.762]             ...future.value <- base::withVisible(base::local({
[17:02:30.762]                 withCallingHandlers({
[17:02:30.762]                   {
[17:02:30.762]                     4
[17:02:30.762]                   }
[17:02:30.762]                 }, immediateCondition = function(cond) {
[17:02:30.762]                   save_rds <- function (object, pathname, ...) 
[17:02:30.762]                   {
[17:02:30.762]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:30.762]                     if (file_test("-f", pathname_tmp)) {
[17:02:30.762]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.762]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:30.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.762]                         fi_tmp[["mtime"]])
[17:02:30.762]                     }
[17:02:30.762]                     tryCatch({
[17:02:30.762]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:30.762]                     }, error = function(ex) {
[17:02:30.762]                       msg <- conditionMessage(ex)
[17:02:30.762]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.762]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:30.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.762]                         fi_tmp[["mtime"]], msg)
[17:02:30.762]                       ex$message <- msg
[17:02:30.762]                       stop(ex)
[17:02:30.762]                     })
[17:02:30.762]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:30.762]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:30.762]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:30.762]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.762]                       fi <- file.info(pathname)
[17:02:30.762]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:30.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.762]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:30.762]                         fi[["size"]], fi[["mtime"]])
[17:02:30.762]                       stop(msg)
[17:02:30.762]                     }
[17:02:30.762]                     invisible(pathname)
[17:02:30.762]                   }
[17:02:30.762]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:30.762]                     rootPath = tempdir()) 
[17:02:30.762]                   {
[17:02:30.762]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:30.762]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:30.762]                       tmpdir = path, fileext = ".rds")
[17:02:30.762]                     save_rds(obj, file)
[17:02:30.762]                   }
[17:02:30.762]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:30.762]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.762]                   {
[17:02:30.762]                     inherits <- base::inherits
[17:02:30.762]                     invokeRestart <- base::invokeRestart
[17:02:30.762]                     is.null <- base::is.null
[17:02:30.762]                     muffled <- FALSE
[17:02:30.762]                     if (inherits(cond, "message")) {
[17:02:30.762]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.762]                       if (muffled) 
[17:02:30.762]                         invokeRestart("muffleMessage")
[17:02:30.762]                     }
[17:02:30.762]                     else if (inherits(cond, "warning")) {
[17:02:30.762]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.762]                       if (muffled) 
[17:02:30.762]                         invokeRestart("muffleWarning")
[17:02:30.762]                     }
[17:02:30.762]                     else if (inherits(cond, "condition")) {
[17:02:30.762]                       if (!is.null(pattern)) {
[17:02:30.762]                         computeRestarts <- base::computeRestarts
[17:02:30.762]                         grepl <- base::grepl
[17:02:30.762]                         restarts <- computeRestarts(cond)
[17:02:30.762]                         for (restart in restarts) {
[17:02:30.762]                           name <- restart$name
[17:02:30.762]                           if (is.null(name)) 
[17:02:30.762]                             next
[17:02:30.762]                           if (!grepl(pattern, name)) 
[17:02:30.762]                             next
[17:02:30.762]                           invokeRestart(restart)
[17:02:30.762]                           muffled <- TRUE
[17:02:30.762]                           break
[17:02:30.762]                         }
[17:02:30.762]                       }
[17:02:30.762]                     }
[17:02:30.762]                     invisible(muffled)
[17:02:30.762]                   }
[17:02:30.762]                   muffleCondition(cond)
[17:02:30.762]                 })
[17:02:30.762]             }))
[17:02:30.762]             future::FutureResult(value = ...future.value$value, 
[17:02:30.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.762]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.762]                     ...future.globalenv.names))
[17:02:30.762]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.762]         }, condition = base::local({
[17:02:30.762]             c <- base::c
[17:02:30.762]             inherits <- base::inherits
[17:02:30.762]             invokeRestart <- base::invokeRestart
[17:02:30.762]             length <- base::length
[17:02:30.762]             list <- base::list
[17:02:30.762]             seq.int <- base::seq.int
[17:02:30.762]             signalCondition <- base::signalCondition
[17:02:30.762]             sys.calls <- base::sys.calls
[17:02:30.762]             `[[` <- base::`[[`
[17:02:30.762]             `+` <- base::`+`
[17:02:30.762]             `<<-` <- base::`<<-`
[17:02:30.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.762]                   3L)]
[17:02:30.762]             }
[17:02:30.762]             function(cond) {
[17:02:30.762]                 is_error <- inherits(cond, "error")
[17:02:30.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.762]                   NULL)
[17:02:30.762]                 if (is_error) {
[17:02:30.762]                   sessionInformation <- function() {
[17:02:30.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.762]                       search = base::search(), system = base::Sys.info())
[17:02:30.762]                   }
[17:02:30.762]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.762]                     cond$call), session = sessionInformation(), 
[17:02:30.762]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.762]                   signalCondition(cond)
[17:02:30.762]                 }
[17:02:30.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.762]                 "immediateCondition"))) {
[17:02:30.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.762]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.762]                   if (TRUE && !signal) {
[17:02:30.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.762]                     {
[17:02:30.762]                       inherits <- base::inherits
[17:02:30.762]                       invokeRestart <- base::invokeRestart
[17:02:30.762]                       is.null <- base::is.null
[17:02:30.762]                       muffled <- FALSE
[17:02:30.762]                       if (inherits(cond, "message")) {
[17:02:30.762]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.762]                         if (muffled) 
[17:02:30.762]                           invokeRestart("muffleMessage")
[17:02:30.762]                       }
[17:02:30.762]                       else if (inherits(cond, "warning")) {
[17:02:30.762]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.762]                         if (muffled) 
[17:02:30.762]                           invokeRestart("muffleWarning")
[17:02:30.762]                       }
[17:02:30.762]                       else if (inherits(cond, "condition")) {
[17:02:30.762]                         if (!is.null(pattern)) {
[17:02:30.762]                           computeRestarts <- base::computeRestarts
[17:02:30.762]                           grepl <- base::grepl
[17:02:30.762]                           restarts <- computeRestarts(cond)
[17:02:30.762]                           for (restart in restarts) {
[17:02:30.762]                             name <- restart$name
[17:02:30.762]                             if (is.null(name)) 
[17:02:30.762]                               next
[17:02:30.762]                             if (!grepl(pattern, name)) 
[17:02:30.762]                               next
[17:02:30.762]                             invokeRestart(restart)
[17:02:30.762]                             muffled <- TRUE
[17:02:30.762]                             break
[17:02:30.762]                           }
[17:02:30.762]                         }
[17:02:30.762]                       }
[17:02:30.762]                       invisible(muffled)
[17:02:30.762]                     }
[17:02:30.762]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.762]                   }
[17:02:30.762]                 }
[17:02:30.762]                 else {
[17:02:30.762]                   if (TRUE) {
[17:02:30.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.762]                     {
[17:02:30.762]                       inherits <- base::inherits
[17:02:30.762]                       invokeRestart <- base::invokeRestart
[17:02:30.762]                       is.null <- base::is.null
[17:02:30.762]                       muffled <- FALSE
[17:02:30.762]                       if (inherits(cond, "message")) {
[17:02:30.762]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.762]                         if (muffled) 
[17:02:30.762]                           invokeRestart("muffleMessage")
[17:02:30.762]                       }
[17:02:30.762]                       else if (inherits(cond, "warning")) {
[17:02:30.762]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.762]                         if (muffled) 
[17:02:30.762]                           invokeRestart("muffleWarning")
[17:02:30.762]                       }
[17:02:30.762]                       else if (inherits(cond, "condition")) {
[17:02:30.762]                         if (!is.null(pattern)) {
[17:02:30.762]                           computeRestarts <- base::computeRestarts
[17:02:30.762]                           grepl <- base::grepl
[17:02:30.762]                           restarts <- computeRestarts(cond)
[17:02:30.762]                           for (restart in restarts) {
[17:02:30.762]                             name <- restart$name
[17:02:30.762]                             if (is.null(name)) 
[17:02:30.762]                               next
[17:02:30.762]                             if (!grepl(pattern, name)) 
[17:02:30.762]                               next
[17:02:30.762]                             invokeRestart(restart)
[17:02:30.762]                             muffled <- TRUE
[17:02:30.762]                             break
[17:02:30.762]                           }
[17:02:30.762]                         }
[17:02:30.762]                       }
[17:02:30.762]                       invisible(muffled)
[17:02:30.762]                     }
[17:02:30.762]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.762]                   }
[17:02:30.762]                 }
[17:02:30.762]             }
[17:02:30.762]         }))
[17:02:30.762]     }, error = function(ex) {
[17:02:30.762]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.762]                 ...future.rng), started = ...future.startTime, 
[17:02:30.762]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.762]             version = "1.8"), class = "FutureResult")
[17:02:30.762]     }, finally = {
[17:02:30.762]         if (!identical(...future.workdir, getwd())) 
[17:02:30.762]             setwd(...future.workdir)
[17:02:30.762]         {
[17:02:30.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.762]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.762]             }
[17:02:30.762]             base::options(...future.oldOptions)
[17:02:30.762]             if (.Platform$OS.type == "windows") {
[17:02:30.762]                 old_names <- names(...future.oldEnvVars)
[17:02:30.762]                 envs <- base::Sys.getenv()
[17:02:30.762]                 names <- names(envs)
[17:02:30.762]                 common <- intersect(names, old_names)
[17:02:30.762]                 added <- setdiff(names, old_names)
[17:02:30.762]                 removed <- setdiff(old_names, names)
[17:02:30.762]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.762]                   envs[common]]
[17:02:30.762]                 NAMES <- toupper(changed)
[17:02:30.762]                 args <- list()
[17:02:30.762]                 for (kk in seq_along(NAMES)) {
[17:02:30.762]                   name <- changed[[kk]]
[17:02:30.762]                   NAME <- NAMES[[kk]]
[17:02:30.762]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.762]                     next
[17:02:30.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.762]                 }
[17:02:30.762]                 NAMES <- toupper(added)
[17:02:30.762]                 for (kk in seq_along(NAMES)) {
[17:02:30.762]                   name <- added[[kk]]
[17:02:30.762]                   NAME <- NAMES[[kk]]
[17:02:30.762]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.762]                     next
[17:02:30.762]                   args[[name]] <- ""
[17:02:30.762]                 }
[17:02:30.762]                 NAMES <- toupper(removed)
[17:02:30.762]                 for (kk in seq_along(NAMES)) {
[17:02:30.762]                   name <- removed[[kk]]
[17:02:30.762]                   NAME <- NAMES[[kk]]
[17:02:30.762]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.762]                     next
[17:02:30.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.762]                 }
[17:02:30.762]                 if (length(args) > 0) 
[17:02:30.762]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.762]             }
[17:02:30.762]             else {
[17:02:30.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.762]             }
[17:02:30.762]             {
[17:02:30.762]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.762]                   0L) {
[17:02:30.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.762]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.762]                   base::options(opts)
[17:02:30.762]                 }
[17:02:30.762]                 {
[17:02:30.762]                   {
[17:02:30.762]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.762]                     NULL
[17:02:30.762]                   }
[17:02:30.762]                   options(future.plan = NULL)
[17:02:30.762]                   if (is.na(NA_character_)) 
[17:02:30.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.762]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.762]                     .init = FALSE)
[17:02:30.762]                 }
[17:02:30.762]             }
[17:02:30.762]         }
[17:02:30.762]     })
[17:02:30.762]     if (TRUE) {
[17:02:30.762]         base::sink(type = "output", split = FALSE)
[17:02:30.762]         if (TRUE) {
[17:02:30.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.762]         }
[17:02:30.762]         else {
[17:02:30.762]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.762]         }
[17:02:30.762]         base::close(...future.stdout)
[17:02:30.762]         ...future.stdout <- NULL
[17:02:30.762]     }
[17:02:30.762]     ...future.result$conditions <- ...future.conditions
[17:02:30.762]     ...future.result$finished <- base::Sys.time()
[17:02:30.762]     ...future.result
[17:02:30.762] }
[17:02:30.765] requestCore(): workers = 2
[17:02:30.766] Poll #1 (0): usedCores() = 2, workers = 2
[17:02:30.788] result() for MulticoreFuture ...
[17:02:30.789] result() for MulticoreFuture ...
[17:02:30.789] result() for MulticoreFuture ... done
[17:02:30.790] result() for MulticoreFuture ... done
[17:02:30.790] result() for MulticoreFuture ...
[17:02:30.790] result() for MulticoreFuture ... done
[17:02:30.793] MulticoreFuture started
[17:02:30.793] - Launch lazy future ... done
[17:02:30.793] run() for ‘MulticoreFuture’ ... done
[17:02:30.794] plan(): Setting new future strategy stack:
<environment: 0x55c749617e70> 
[17:02:30.794] List of future strategies:
[17:02:30.794] 1. sequential:
[17:02:30.794]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:30.794]    - tweaked: FALSE
[17:02:30.794]    - call: NULL
[17:02:30.796] plan(): nbrOfWorkers() = 1
<environment: 0x55c74ad005f8> 
[17:02:30.798] plan(): Setting new future strategy stack:
[17:02:30.798] List of future strategies:
[17:02:30.798] 1. multicore:
[17:02:30.798]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:30.798]    - tweaked: FALSE
[17:02:30.798]    - call: plan(strategy)
[17:02:30.803] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:30.805] resolve() on environment ...
[17:02:30.806]  recursive: 0
[17:02:30.806]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:30.807] signalConditionsASAP(numeric, pos=1) ...
[17:02:30.807] - nx: 4
[17:02:30.807] - relay: TRUE
[17:02:30.807] - stdout: TRUE
[17:02:30.807] - signal: TRUE
[17:02:30.807] - resignal: FALSE
[17:02:30.807] - force: TRUE
[17:02:30.808] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:30.808] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:30.808]  - until=2
[17:02:30.808]  - relaying element #2
[17:02:30.808] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:30.808] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:30.808] signalConditionsASAP(NULL, pos=1) ... done
[17:02:30.809]  length: 3 (resolved future 1)
[17:02:30.809] Future #2
[17:02:30.809] result() for MulticoreFuture ...
[17:02:30.809] result() for MulticoreFuture ... done
[17:02:30.809] result() for MulticoreFuture ...
[17:02:30.809] result() for MulticoreFuture ... done
[17:02:30.810] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:30.810] - nx: 4
[17:02:30.810] - relay: TRUE
[17:02:30.810] - stdout: TRUE
[17:02:30.810] - signal: TRUE
[17:02:30.810] - resignal: FALSE
[17:02:30.810] - force: TRUE
[17:02:30.810] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:30.810] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:30.811]  - until=2
[17:02:30.811]  - relaying element #2
[17:02:30.811] result() for MulticoreFuture ...
[17:02:30.811] result() for MulticoreFuture ... done
[17:02:30.811] result() for MulticoreFuture ...
[17:02:30.811] result() for MulticoreFuture ... done
[17:02:30.811] result() for MulticoreFuture ...
[17:02:30.812] result() for MulticoreFuture ... done
[17:02:30.812] result() for MulticoreFuture ...
[17:02:30.812] result() for MulticoreFuture ... done
[17:02:30.812] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:30.812] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:30.812] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:30.812]  length: 2 (resolved future 2)
[17:02:30.813] Future #3
[17:02:30.813] result() for MulticoreFuture ...
[17:02:30.814] result() for MulticoreFuture ...
[17:02:30.814] result() for MulticoreFuture ... done
[17:02:30.814] result() for MulticoreFuture ... done
[17:02:30.814] result() for MulticoreFuture ...
[17:02:30.814] result() for MulticoreFuture ... done
[17:02:30.814] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:30.814] - nx: 4
[17:02:30.815] - relay: TRUE
[17:02:30.815] - stdout: TRUE
[17:02:30.815] - signal: TRUE
[17:02:30.815] - resignal: FALSE
[17:02:30.815] - force: TRUE
[17:02:30.815] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:30.815] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:30.815]  - until=3
[17:02:30.816]  - relaying element #3
[17:02:30.816] result() for MulticoreFuture ...
[17:02:30.816] result() for MulticoreFuture ... done
[17:02:30.816] result() for MulticoreFuture ...
[17:02:30.816] result() for MulticoreFuture ... done
[17:02:30.816] result() for MulticoreFuture ...
[17:02:30.816] result() for MulticoreFuture ... done
[17:02:30.816] result() for MulticoreFuture ...
[17:02:30.817] result() for MulticoreFuture ... done
[17:02:30.817] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:30.817] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:30.817] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:30.817]  length: 1 (resolved future 3)
[17:02:30.817] Future #4
[17:02:30.818] result() for MulticoreFuture ...
[17:02:30.818] result() for MulticoreFuture ...
[17:02:30.818] result() for MulticoreFuture ... done
[17:02:30.819] result() for MulticoreFuture ... done
[17:02:30.819] result() for MulticoreFuture ...
[17:02:30.819] result() for MulticoreFuture ... done
[17:02:30.819] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:02:30.819] - nx: 4
[17:02:30.820] - relay: TRUE
[17:02:30.820] - stdout: TRUE
[17:02:30.820] - signal: TRUE
[17:02:30.820] - resignal: FALSE
[17:02:30.820] - force: TRUE
[17:02:30.820] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:30.820] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:30.821]  - until=4
[17:02:30.821]  - relaying element #4
[17:02:30.821] result() for MulticoreFuture ...
[17:02:30.821] result() for MulticoreFuture ... done
[17:02:30.821] result() for MulticoreFuture ...
[17:02:30.821] result() for MulticoreFuture ... done
[17:02:30.822] result() for MulticoreFuture ...
[17:02:30.822] result() for MulticoreFuture ... done
[17:02:30.822] result() for MulticoreFuture ...
[17:02:30.822] result() for MulticoreFuture ... done
[17:02:30.822] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:30.822] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:30.822] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:02:30.822]  length: 0 (resolved future 4)
[17:02:30.822] Relaying remaining futures
[17:02:30.823] signalConditionsASAP(NULL, pos=0) ...
[17:02:30.823] - nx: 4
[17:02:30.823] - relay: TRUE
[17:02:30.823] - stdout: TRUE
[17:02:30.823] - signal: TRUE
[17:02:30.823] - resignal: FALSE
[17:02:30.823] - force: TRUE
[17:02:30.823] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:30.823] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:30.824] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:30.824] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:30.824] signalConditionsASAP(NULL, pos=0) ... done
[17:02:30.824] resolve() on environment ... DONE
[17:02:30.824] result() for MulticoreFuture ...
[17:02:30.824] result() for MulticoreFuture ... done
[17:02:30.824] result() for MulticoreFuture ...
[17:02:30.824] result() for MulticoreFuture ... done
[17:02:30.824] result() for MulticoreFuture ...
[17:02:30.825] result() for MulticoreFuture ... done
[17:02:30.825] result() for MulticoreFuture ...
[17:02:30.825] result() for MulticoreFuture ... done
[17:02:30.825] result() for MulticoreFuture ...
[17:02:30.825] result() for MulticoreFuture ... done
[17:02:30.825] result() for MulticoreFuture ...
[17:02:30.825] result() for MulticoreFuture ... done
<environment: 0x55c74adbf458> 
Dimensions: c(2, 3)
[17:02:30.826] getGlobalsAndPackages() ...
[17:02:30.826] Searching for globals...
[17:02:30.826] 
[17:02:30.826] Searching for globals ... DONE
[17:02:30.827] - globals: [0] <none>
[17:02:30.827] getGlobalsAndPackages() ... DONE
[17:02:30.827] run() for ‘Future’ ...
[17:02:30.827] - state: ‘created’
[17:02:30.827] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.832] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.832] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:30.832]   - Field: ‘label’
[17:02:30.832]   - Field: ‘local’
[17:02:30.832]   - Field: ‘owner’
[17:02:30.832]   - Field: ‘envir’
[17:02:30.833]   - Field: ‘workers’
[17:02:30.833]   - Field: ‘packages’
[17:02:30.833]   - Field: ‘gc’
[17:02:30.833]   - Field: ‘job’
[17:02:30.833]   - Field: ‘conditions’
[17:02:30.833]   - Field: ‘expr’
[17:02:30.833]   - Field: ‘uuid’
[17:02:30.833]   - Field: ‘seed’
[17:02:30.833]   - Field: ‘version’
[17:02:30.834]   - Field: ‘result’
[17:02:30.834]   - Field: ‘asynchronous’
[17:02:30.834]   - Field: ‘calls’
[17:02:30.834]   - Field: ‘globals’
[17:02:30.834]   - Field: ‘stdout’
[17:02:30.834]   - Field: ‘earlySignal’
[17:02:30.834]   - Field: ‘lazy’
[17:02:30.834]   - Field: ‘state’
[17:02:30.834] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:30.834] - Launch lazy future ...
[17:02:30.835] Packages needed by the future expression (n = 0): <none>
[17:02:30.835] Packages needed by future strategies (n = 0): <none>
[17:02:30.836] {
[17:02:30.836]     {
[17:02:30.836]         {
[17:02:30.836]             ...future.startTime <- base::Sys.time()
[17:02:30.836]             {
[17:02:30.836]                 {
[17:02:30.836]                   {
[17:02:30.836]                     {
[17:02:30.836]                       base::local({
[17:02:30.836]                         has_future <- base::requireNamespace("future", 
[17:02:30.836]                           quietly = TRUE)
[17:02:30.836]                         if (has_future) {
[17:02:30.836]                           ns <- base::getNamespace("future")
[17:02:30.836]                           version <- ns[[".package"]][["version"]]
[17:02:30.836]                           if (is.null(version)) 
[17:02:30.836]                             version <- utils::packageVersion("future")
[17:02:30.836]                         }
[17:02:30.836]                         else {
[17:02:30.836]                           version <- NULL
[17:02:30.836]                         }
[17:02:30.836]                         if (!has_future || version < "1.8.0") {
[17:02:30.836]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.836]                             "", base::R.version$version.string), 
[17:02:30.836]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.836]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.836]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.836]                               "release", "version")], collapse = " "), 
[17:02:30.836]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.836]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.836]                             info)
[17:02:30.836]                           info <- base::paste(info, collapse = "; ")
[17:02:30.836]                           if (!has_future) {
[17:02:30.836]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.836]                               info)
[17:02:30.836]                           }
[17:02:30.836]                           else {
[17:02:30.836]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.836]                               info, version)
[17:02:30.836]                           }
[17:02:30.836]                           base::stop(msg)
[17:02:30.836]                         }
[17:02:30.836]                       })
[17:02:30.836]                     }
[17:02:30.836]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.836]                     base::options(mc.cores = 1L)
[17:02:30.836]                   }
[17:02:30.836]                   ...future.strategy.old <- future::plan("list")
[17:02:30.836]                   options(future.plan = NULL)
[17:02:30.836]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.836]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.836]                 }
[17:02:30.836]                 ...future.workdir <- getwd()
[17:02:30.836]             }
[17:02:30.836]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.836]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.836]         }
[17:02:30.836]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.836]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.836]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.836]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.836]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.836]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.836]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.836]             base::names(...future.oldOptions))
[17:02:30.836]     }
[17:02:30.836]     if (FALSE) {
[17:02:30.836]     }
[17:02:30.836]     else {
[17:02:30.836]         if (TRUE) {
[17:02:30.836]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.836]                 open = "w")
[17:02:30.836]         }
[17:02:30.836]         else {
[17:02:30.836]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.836]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.836]         }
[17:02:30.836]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.836]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.836]             base::sink(type = "output", split = FALSE)
[17:02:30.836]             base::close(...future.stdout)
[17:02:30.836]         }, add = TRUE)
[17:02:30.836]     }
[17:02:30.836]     ...future.frame <- base::sys.nframe()
[17:02:30.836]     ...future.conditions <- base::list()
[17:02:30.836]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.836]     if (FALSE) {
[17:02:30.836]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.836]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.836]     }
[17:02:30.836]     ...future.result <- base::tryCatch({
[17:02:30.836]         base::withCallingHandlers({
[17:02:30.836]             ...future.value <- base::withVisible(base::local({
[17:02:30.836]                 withCallingHandlers({
[17:02:30.836]                   2
[17:02:30.836]                 }, immediateCondition = function(cond) {
[17:02:30.836]                   save_rds <- function (object, pathname, ...) 
[17:02:30.836]                   {
[17:02:30.836]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:30.836]                     if (file_test("-f", pathname_tmp)) {
[17:02:30.836]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.836]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:30.836]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.836]                         fi_tmp[["mtime"]])
[17:02:30.836]                     }
[17:02:30.836]                     tryCatch({
[17:02:30.836]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:30.836]                     }, error = function(ex) {
[17:02:30.836]                       msg <- conditionMessage(ex)
[17:02:30.836]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.836]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:30.836]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.836]                         fi_tmp[["mtime"]], msg)
[17:02:30.836]                       ex$message <- msg
[17:02:30.836]                       stop(ex)
[17:02:30.836]                     })
[17:02:30.836]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:30.836]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:30.836]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:30.836]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.836]                       fi <- file.info(pathname)
[17:02:30.836]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:30.836]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.836]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:30.836]                         fi[["size"]], fi[["mtime"]])
[17:02:30.836]                       stop(msg)
[17:02:30.836]                     }
[17:02:30.836]                     invisible(pathname)
[17:02:30.836]                   }
[17:02:30.836]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:30.836]                     rootPath = tempdir()) 
[17:02:30.836]                   {
[17:02:30.836]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:30.836]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:30.836]                       tmpdir = path, fileext = ".rds")
[17:02:30.836]                     save_rds(obj, file)
[17:02:30.836]                   }
[17:02:30.836]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:30.836]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.836]                   {
[17:02:30.836]                     inherits <- base::inherits
[17:02:30.836]                     invokeRestart <- base::invokeRestart
[17:02:30.836]                     is.null <- base::is.null
[17:02:30.836]                     muffled <- FALSE
[17:02:30.836]                     if (inherits(cond, "message")) {
[17:02:30.836]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.836]                       if (muffled) 
[17:02:30.836]                         invokeRestart("muffleMessage")
[17:02:30.836]                     }
[17:02:30.836]                     else if (inherits(cond, "warning")) {
[17:02:30.836]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.836]                       if (muffled) 
[17:02:30.836]                         invokeRestart("muffleWarning")
[17:02:30.836]                     }
[17:02:30.836]                     else if (inherits(cond, "condition")) {
[17:02:30.836]                       if (!is.null(pattern)) {
[17:02:30.836]                         computeRestarts <- base::computeRestarts
[17:02:30.836]                         grepl <- base::grepl
[17:02:30.836]                         restarts <- computeRestarts(cond)
[17:02:30.836]                         for (restart in restarts) {
[17:02:30.836]                           name <- restart$name
[17:02:30.836]                           if (is.null(name)) 
[17:02:30.836]                             next
[17:02:30.836]                           if (!grepl(pattern, name)) 
[17:02:30.836]                             next
[17:02:30.836]                           invokeRestart(restart)
[17:02:30.836]                           muffled <- TRUE
[17:02:30.836]                           break
[17:02:30.836]                         }
[17:02:30.836]                       }
[17:02:30.836]                     }
[17:02:30.836]                     invisible(muffled)
[17:02:30.836]                   }
[17:02:30.836]                   muffleCondition(cond)
[17:02:30.836]                 })
[17:02:30.836]             }))
[17:02:30.836]             future::FutureResult(value = ...future.value$value, 
[17:02:30.836]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.836]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.836]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.836]                     ...future.globalenv.names))
[17:02:30.836]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.836]         }, condition = base::local({
[17:02:30.836]             c <- base::c
[17:02:30.836]             inherits <- base::inherits
[17:02:30.836]             invokeRestart <- base::invokeRestart
[17:02:30.836]             length <- base::length
[17:02:30.836]             list <- base::list
[17:02:30.836]             seq.int <- base::seq.int
[17:02:30.836]             signalCondition <- base::signalCondition
[17:02:30.836]             sys.calls <- base::sys.calls
[17:02:30.836]             `[[` <- base::`[[`
[17:02:30.836]             `+` <- base::`+`
[17:02:30.836]             `<<-` <- base::`<<-`
[17:02:30.836]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.836]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.836]                   3L)]
[17:02:30.836]             }
[17:02:30.836]             function(cond) {
[17:02:30.836]                 is_error <- inherits(cond, "error")
[17:02:30.836]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.836]                   NULL)
[17:02:30.836]                 if (is_error) {
[17:02:30.836]                   sessionInformation <- function() {
[17:02:30.836]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.836]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.836]                       search = base::search(), system = base::Sys.info())
[17:02:30.836]                   }
[17:02:30.836]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.836]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.836]                     cond$call), session = sessionInformation(), 
[17:02:30.836]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.836]                   signalCondition(cond)
[17:02:30.836]                 }
[17:02:30.836]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.836]                 "immediateCondition"))) {
[17:02:30.836]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.836]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.836]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.836]                   if (TRUE && !signal) {
[17:02:30.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.836]                     {
[17:02:30.836]                       inherits <- base::inherits
[17:02:30.836]                       invokeRestart <- base::invokeRestart
[17:02:30.836]                       is.null <- base::is.null
[17:02:30.836]                       muffled <- FALSE
[17:02:30.836]                       if (inherits(cond, "message")) {
[17:02:30.836]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.836]                         if (muffled) 
[17:02:30.836]                           invokeRestart("muffleMessage")
[17:02:30.836]                       }
[17:02:30.836]                       else if (inherits(cond, "warning")) {
[17:02:30.836]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.836]                         if (muffled) 
[17:02:30.836]                           invokeRestart("muffleWarning")
[17:02:30.836]                       }
[17:02:30.836]                       else if (inherits(cond, "condition")) {
[17:02:30.836]                         if (!is.null(pattern)) {
[17:02:30.836]                           computeRestarts <- base::computeRestarts
[17:02:30.836]                           grepl <- base::grepl
[17:02:30.836]                           restarts <- computeRestarts(cond)
[17:02:30.836]                           for (restart in restarts) {
[17:02:30.836]                             name <- restart$name
[17:02:30.836]                             if (is.null(name)) 
[17:02:30.836]                               next
[17:02:30.836]                             if (!grepl(pattern, name)) 
[17:02:30.836]                               next
[17:02:30.836]                             invokeRestart(restart)
[17:02:30.836]                             muffled <- TRUE
[17:02:30.836]                             break
[17:02:30.836]                           }
[17:02:30.836]                         }
[17:02:30.836]                       }
[17:02:30.836]                       invisible(muffled)
[17:02:30.836]                     }
[17:02:30.836]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.836]                   }
[17:02:30.836]                 }
[17:02:30.836]                 else {
[17:02:30.836]                   if (TRUE) {
[17:02:30.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.836]                     {
[17:02:30.836]                       inherits <- base::inherits
[17:02:30.836]                       invokeRestart <- base::invokeRestart
[17:02:30.836]                       is.null <- base::is.null
[17:02:30.836]                       muffled <- FALSE
[17:02:30.836]                       if (inherits(cond, "message")) {
[17:02:30.836]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.836]                         if (muffled) 
[17:02:30.836]                           invokeRestart("muffleMessage")
[17:02:30.836]                       }
[17:02:30.836]                       else if (inherits(cond, "warning")) {
[17:02:30.836]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.836]                         if (muffled) 
[17:02:30.836]                           invokeRestart("muffleWarning")
[17:02:30.836]                       }
[17:02:30.836]                       else if (inherits(cond, "condition")) {
[17:02:30.836]                         if (!is.null(pattern)) {
[17:02:30.836]                           computeRestarts <- base::computeRestarts
[17:02:30.836]                           grepl <- base::grepl
[17:02:30.836]                           restarts <- computeRestarts(cond)
[17:02:30.836]                           for (restart in restarts) {
[17:02:30.836]                             name <- restart$name
[17:02:30.836]                             if (is.null(name)) 
[17:02:30.836]                               next
[17:02:30.836]                             if (!grepl(pattern, name)) 
[17:02:30.836]                               next
[17:02:30.836]                             invokeRestart(restart)
[17:02:30.836]                             muffled <- TRUE
[17:02:30.836]                             break
[17:02:30.836]                           }
[17:02:30.836]                         }
[17:02:30.836]                       }
[17:02:30.836]                       invisible(muffled)
[17:02:30.836]                     }
[17:02:30.836]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.836]                   }
[17:02:30.836]                 }
[17:02:30.836]             }
[17:02:30.836]         }))
[17:02:30.836]     }, error = function(ex) {
[17:02:30.836]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.836]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.836]                 ...future.rng), started = ...future.startTime, 
[17:02:30.836]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.836]             version = "1.8"), class = "FutureResult")
[17:02:30.836]     }, finally = {
[17:02:30.836]         if (!identical(...future.workdir, getwd())) 
[17:02:30.836]             setwd(...future.workdir)
[17:02:30.836]         {
[17:02:30.836]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.836]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.836]             }
[17:02:30.836]             base::options(...future.oldOptions)
[17:02:30.836]             if (.Platform$OS.type == "windows") {
[17:02:30.836]                 old_names <- names(...future.oldEnvVars)
[17:02:30.836]                 envs <- base::Sys.getenv()
[17:02:30.836]                 names <- names(envs)
[17:02:30.836]                 common <- intersect(names, old_names)
[17:02:30.836]                 added <- setdiff(names, old_names)
[17:02:30.836]                 removed <- setdiff(old_names, names)
[17:02:30.836]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.836]                   envs[common]]
[17:02:30.836]                 NAMES <- toupper(changed)
[17:02:30.836]                 args <- list()
[17:02:30.836]                 for (kk in seq_along(NAMES)) {
[17:02:30.836]                   name <- changed[[kk]]
[17:02:30.836]                   NAME <- NAMES[[kk]]
[17:02:30.836]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.836]                     next
[17:02:30.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.836]                 }
[17:02:30.836]                 NAMES <- toupper(added)
[17:02:30.836]                 for (kk in seq_along(NAMES)) {
[17:02:30.836]                   name <- added[[kk]]
[17:02:30.836]                   NAME <- NAMES[[kk]]
[17:02:30.836]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.836]                     next
[17:02:30.836]                   args[[name]] <- ""
[17:02:30.836]                 }
[17:02:30.836]                 NAMES <- toupper(removed)
[17:02:30.836]                 for (kk in seq_along(NAMES)) {
[17:02:30.836]                   name <- removed[[kk]]
[17:02:30.836]                   NAME <- NAMES[[kk]]
[17:02:30.836]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.836]                     next
[17:02:30.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.836]                 }
[17:02:30.836]                 if (length(args) > 0) 
[17:02:30.836]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.836]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.836]             }
[17:02:30.836]             else {
[17:02:30.836]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.836]             }
[17:02:30.836]             {
[17:02:30.836]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.836]                   0L) {
[17:02:30.836]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.836]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.836]                   base::options(opts)
[17:02:30.836]                 }
[17:02:30.836]                 {
[17:02:30.836]                   {
[17:02:30.836]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.836]                     NULL
[17:02:30.836]                   }
[17:02:30.836]                   options(future.plan = NULL)
[17:02:30.836]                   if (is.na(NA_character_)) 
[17:02:30.836]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.836]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.836]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.836]                     .init = FALSE)
[17:02:30.836]                 }
[17:02:30.836]             }
[17:02:30.836]         }
[17:02:30.836]     })
[17:02:30.836]     if (TRUE) {
[17:02:30.836]         base::sink(type = "output", split = FALSE)
[17:02:30.836]         if (TRUE) {
[17:02:30.836]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.836]         }
[17:02:30.836]         else {
[17:02:30.836]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.836]         }
[17:02:30.836]         base::close(...future.stdout)
[17:02:30.836]         ...future.stdout <- NULL
[17:02:30.836]     }
[17:02:30.836]     ...future.result$conditions <- ...future.conditions
[17:02:30.836]     ...future.result$finished <- base::Sys.time()
[17:02:30.836]     ...future.result
[17:02:30.836] }
[17:02:30.838] requestCore(): workers = 2
[17:02:30.841] MulticoreFuture started
[17:02:30.841] - Launch lazy future ... done
[17:02:30.841] run() for ‘MulticoreFuture’ ... done
[17:02:30.842] getGlobalsAndPackages() ...
[17:02:30.842] Searching for globals...
[17:02:30.842] plan(): Setting new future strategy stack:
[17:02:30.843] 
[17:02:30.843] Searching for globals ... DONE
[17:02:30.843] - globals: [0] <none>
[17:02:30.842] List of future strategies:
[17:02:30.842] 1. sequential:
[17:02:30.842]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:30.842]    - tweaked: FALSE
[17:02:30.842]    - call: NULL
[17:02:30.843] getGlobalsAndPackages() ... DONE
[17:02:30.843] plan(): nbrOfWorkers() = 1
[17:02:30.844] run() for ‘Future’ ...
[17:02:30.844] - state: ‘created’
[17:02:30.844] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.845] plan(): Setting new future strategy stack:
[17:02:30.845] List of future strategies:
[17:02:30.845] 1. multicore:
[17:02:30.845]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:30.845]    - tweaked: FALSE
[17:02:30.845]    - call: plan(strategy)
[17:02:30.849] plan(): nbrOfWorkers() = 2
[17:02:30.849] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.855] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:30.856]   - Field: ‘label’
[17:02:30.856]   - Field: ‘local’
[17:02:30.856]   - Field: ‘owner’
[17:02:30.856]   - Field: ‘envir’
[17:02:30.856]   - Field: ‘workers’
[17:02:30.856]   - Field: ‘packages’
[17:02:30.856]   - Field: ‘gc’
[17:02:30.857]   - Field: ‘job’
[17:02:30.857]   - Field: ‘conditions’
[17:02:30.857]   - Field: ‘expr’
[17:02:30.857]   - Field: ‘uuid’
[17:02:30.857]   - Field: ‘seed’
[17:02:30.857]   - Field: ‘version’
[17:02:30.857]   - Field: ‘result’
[17:02:30.858]   - Field: ‘asynchronous’
[17:02:30.858]   - Field: ‘calls’
[17:02:30.858]   - Field: ‘globals’
[17:02:30.858]   - Field: ‘stdout’
[17:02:30.858]   - Field: ‘earlySignal’
[17:02:30.858]   - Field: ‘lazy’
[17:02:30.858]   - Field: ‘state’
[17:02:30.858] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:30.859] - Launch lazy future ...
[17:02:30.859] Packages needed by the future expression (n = 0): <none>
[17:02:30.859] Packages needed by future strategies (n = 0): <none>
[17:02:30.860] {
[17:02:30.860]     {
[17:02:30.860]         {
[17:02:30.860]             ...future.startTime <- base::Sys.time()
[17:02:30.860]             {
[17:02:30.860]                 {
[17:02:30.860]                   {
[17:02:30.860]                     {
[17:02:30.860]                       base::local({
[17:02:30.860]                         has_future <- base::requireNamespace("future", 
[17:02:30.860]                           quietly = TRUE)
[17:02:30.860]                         if (has_future) {
[17:02:30.860]                           ns <- base::getNamespace("future")
[17:02:30.860]                           version <- ns[[".package"]][["version"]]
[17:02:30.860]                           if (is.null(version)) 
[17:02:30.860]                             version <- utils::packageVersion("future")
[17:02:30.860]                         }
[17:02:30.860]                         else {
[17:02:30.860]                           version <- NULL
[17:02:30.860]                         }
[17:02:30.860]                         if (!has_future || version < "1.8.0") {
[17:02:30.860]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.860]                             "", base::R.version$version.string), 
[17:02:30.860]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.860]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.860]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.860]                               "release", "version")], collapse = " "), 
[17:02:30.860]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.860]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.860]                             info)
[17:02:30.860]                           info <- base::paste(info, collapse = "; ")
[17:02:30.860]                           if (!has_future) {
[17:02:30.860]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.860]                               info)
[17:02:30.860]                           }
[17:02:30.860]                           else {
[17:02:30.860]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.860]                               info, version)
[17:02:30.860]                           }
[17:02:30.860]                           base::stop(msg)
[17:02:30.860]                         }
[17:02:30.860]                       })
[17:02:30.860]                     }
[17:02:30.860]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.860]                     base::options(mc.cores = 1L)
[17:02:30.860]                   }
[17:02:30.860]                   ...future.strategy.old <- future::plan("list")
[17:02:30.860]                   options(future.plan = NULL)
[17:02:30.860]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.860]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.860]                 }
[17:02:30.860]                 ...future.workdir <- getwd()
[17:02:30.860]             }
[17:02:30.860]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.860]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.860]         }
[17:02:30.860]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.860]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.860]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.860]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.860]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.860]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.860]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.860]             base::names(...future.oldOptions))
[17:02:30.860]     }
[17:02:30.860]     if (FALSE) {
[17:02:30.860]     }
[17:02:30.860]     else {
[17:02:30.860]         if (TRUE) {
[17:02:30.860]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.860]                 open = "w")
[17:02:30.860]         }
[17:02:30.860]         else {
[17:02:30.860]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.860]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.860]         }
[17:02:30.860]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.860]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.860]             base::sink(type = "output", split = FALSE)
[17:02:30.860]             base::close(...future.stdout)
[17:02:30.860]         }, add = TRUE)
[17:02:30.860]     }
[17:02:30.860]     ...future.frame <- base::sys.nframe()
[17:02:30.860]     ...future.conditions <- base::list()
[17:02:30.860]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.860]     if (FALSE) {
[17:02:30.860]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.860]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.860]     }
[17:02:30.860]     ...future.result <- base::tryCatch({
[17:02:30.860]         base::withCallingHandlers({
[17:02:30.860]             ...future.value <- base::withVisible(base::local({
[17:02:30.860]                 withCallingHandlers({
[17:02:30.860]                   NULL
[17:02:30.860]                 }, immediateCondition = function(cond) {
[17:02:30.860]                   save_rds <- function (object, pathname, ...) 
[17:02:30.860]                   {
[17:02:30.860]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:30.860]                     if (file_test("-f", pathname_tmp)) {
[17:02:30.860]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.860]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:30.860]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.860]                         fi_tmp[["mtime"]])
[17:02:30.860]                     }
[17:02:30.860]                     tryCatch({
[17:02:30.860]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:30.860]                     }, error = function(ex) {
[17:02:30.860]                       msg <- conditionMessage(ex)
[17:02:30.860]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.860]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:30.860]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.860]                         fi_tmp[["mtime"]], msg)
[17:02:30.860]                       ex$message <- msg
[17:02:30.860]                       stop(ex)
[17:02:30.860]                     })
[17:02:30.860]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:30.860]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:30.860]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:30.860]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.860]                       fi <- file.info(pathname)
[17:02:30.860]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:30.860]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.860]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:30.860]                         fi[["size"]], fi[["mtime"]])
[17:02:30.860]                       stop(msg)
[17:02:30.860]                     }
[17:02:30.860]                     invisible(pathname)
[17:02:30.860]                   }
[17:02:30.860]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:30.860]                     rootPath = tempdir()) 
[17:02:30.860]                   {
[17:02:30.860]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:30.860]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:30.860]                       tmpdir = path, fileext = ".rds")
[17:02:30.860]                     save_rds(obj, file)
[17:02:30.860]                   }
[17:02:30.860]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:30.860]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.860]                   {
[17:02:30.860]                     inherits <- base::inherits
[17:02:30.860]                     invokeRestart <- base::invokeRestart
[17:02:30.860]                     is.null <- base::is.null
[17:02:30.860]                     muffled <- FALSE
[17:02:30.860]                     if (inherits(cond, "message")) {
[17:02:30.860]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.860]                       if (muffled) 
[17:02:30.860]                         invokeRestart("muffleMessage")
[17:02:30.860]                     }
[17:02:30.860]                     else if (inherits(cond, "warning")) {
[17:02:30.860]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.860]                       if (muffled) 
[17:02:30.860]                         invokeRestart("muffleWarning")
[17:02:30.860]                     }
[17:02:30.860]                     else if (inherits(cond, "condition")) {
[17:02:30.860]                       if (!is.null(pattern)) {
[17:02:30.860]                         computeRestarts <- base::computeRestarts
[17:02:30.860]                         grepl <- base::grepl
[17:02:30.860]                         restarts <- computeRestarts(cond)
[17:02:30.860]                         for (restart in restarts) {
[17:02:30.860]                           name <- restart$name
[17:02:30.860]                           if (is.null(name)) 
[17:02:30.860]                             next
[17:02:30.860]                           if (!grepl(pattern, name)) 
[17:02:30.860]                             next
[17:02:30.860]                           invokeRestart(restart)
[17:02:30.860]                           muffled <- TRUE
[17:02:30.860]                           break
[17:02:30.860]                         }
[17:02:30.860]                       }
[17:02:30.860]                     }
[17:02:30.860]                     invisible(muffled)
[17:02:30.860]                   }
[17:02:30.860]                   muffleCondition(cond)
[17:02:30.860]                 })
[17:02:30.860]             }))
[17:02:30.860]             future::FutureResult(value = ...future.value$value, 
[17:02:30.860]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.860]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.860]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.860]                     ...future.globalenv.names))
[17:02:30.860]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.860]         }, condition = base::local({
[17:02:30.860]             c <- base::c
[17:02:30.860]             inherits <- base::inherits
[17:02:30.860]             invokeRestart <- base::invokeRestart
[17:02:30.860]             length <- base::length
[17:02:30.860]             list <- base::list
[17:02:30.860]             seq.int <- base::seq.int
[17:02:30.860]             signalCondition <- base::signalCondition
[17:02:30.860]             sys.calls <- base::sys.calls
[17:02:30.860]             `[[` <- base::`[[`
[17:02:30.860]             `+` <- base::`+`
[17:02:30.860]             `<<-` <- base::`<<-`
[17:02:30.860]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.860]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.860]                   3L)]
[17:02:30.860]             }
[17:02:30.860]             function(cond) {
[17:02:30.860]                 is_error <- inherits(cond, "error")
[17:02:30.860]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.860]                   NULL)
[17:02:30.860]                 if (is_error) {
[17:02:30.860]                   sessionInformation <- function() {
[17:02:30.860]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.860]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.860]                       search = base::search(), system = base::Sys.info())
[17:02:30.860]                   }
[17:02:30.860]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.860]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.860]                     cond$call), session = sessionInformation(), 
[17:02:30.860]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.860]                   signalCondition(cond)
[17:02:30.860]                 }
[17:02:30.860]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.860]                 "immediateCondition"))) {
[17:02:30.860]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.860]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.860]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.860]                   if (TRUE && !signal) {
[17:02:30.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.860]                     {
[17:02:30.860]                       inherits <- base::inherits
[17:02:30.860]                       invokeRestart <- base::invokeRestart
[17:02:30.860]                       is.null <- base::is.null
[17:02:30.860]                       muffled <- FALSE
[17:02:30.860]                       if (inherits(cond, "message")) {
[17:02:30.860]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.860]                         if (muffled) 
[17:02:30.860]                           invokeRestart("muffleMessage")
[17:02:30.860]                       }
[17:02:30.860]                       else if (inherits(cond, "warning")) {
[17:02:30.860]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.860]                         if (muffled) 
[17:02:30.860]                           invokeRestart("muffleWarning")
[17:02:30.860]                       }
[17:02:30.860]                       else if (inherits(cond, "condition")) {
[17:02:30.860]                         if (!is.null(pattern)) {
[17:02:30.860]                           computeRestarts <- base::computeRestarts
[17:02:30.860]                           grepl <- base::grepl
[17:02:30.860]                           restarts <- computeRestarts(cond)
[17:02:30.860]                           for (restart in restarts) {
[17:02:30.860]                             name <- restart$name
[17:02:30.860]                             if (is.null(name)) 
[17:02:30.860]                               next
[17:02:30.860]                             if (!grepl(pattern, name)) 
[17:02:30.860]                               next
[17:02:30.860]                             invokeRestart(restart)
[17:02:30.860]                             muffled <- TRUE
[17:02:30.860]                             break
[17:02:30.860]                           }
[17:02:30.860]                         }
[17:02:30.860]                       }
[17:02:30.860]                       invisible(muffled)
[17:02:30.860]                     }
[17:02:30.860]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.860]                   }
[17:02:30.860]                 }
[17:02:30.860]                 else {
[17:02:30.860]                   if (TRUE) {
[17:02:30.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.860]                     {
[17:02:30.860]                       inherits <- base::inherits
[17:02:30.860]                       invokeRestart <- base::invokeRestart
[17:02:30.860]                       is.null <- base::is.null
[17:02:30.860]                       muffled <- FALSE
[17:02:30.860]                       if (inherits(cond, "message")) {
[17:02:30.860]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.860]                         if (muffled) 
[17:02:30.860]                           invokeRestart("muffleMessage")
[17:02:30.860]                       }
[17:02:30.860]                       else if (inherits(cond, "warning")) {
[17:02:30.860]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.860]                         if (muffled) 
[17:02:30.860]                           invokeRestart("muffleWarning")
[17:02:30.860]                       }
[17:02:30.860]                       else if (inherits(cond, "condition")) {
[17:02:30.860]                         if (!is.null(pattern)) {
[17:02:30.860]                           computeRestarts <- base::computeRestarts
[17:02:30.860]                           grepl <- base::grepl
[17:02:30.860]                           restarts <- computeRestarts(cond)
[17:02:30.860]                           for (restart in restarts) {
[17:02:30.860]                             name <- restart$name
[17:02:30.860]                             if (is.null(name)) 
[17:02:30.860]                               next
[17:02:30.860]                             if (!grepl(pattern, name)) 
[17:02:30.860]                               next
[17:02:30.860]                             invokeRestart(restart)
[17:02:30.860]                             muffled <- TRUE
[17:02:30.860]                             break
[17:02:30.860]                           }
[17:02:30.860]                         }
[17:02:30.860]                       }
[17:02:30.860]                       invisible(muffled)
[17:02:30.860]                     }
[17:02:30.860]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.860]                   }
[17:02:30.860]                 }
[17:02:30.860]             }
[17:02:30.860]         }))
[17:02:30.860]     }, error = function(ex) {
[17:02:30.860]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.860]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.860]                 ...future.rng), started = ...future.startTime, 
[17:02:30.860]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.860]             version = "1.8"), class = "FutureResult")
[17:02:30.860]     }, finally = {
[17:02:30.860]         if (!identical(...future.workdir, getwd())) 
[17:02:30.860]             setwd(...future.workdir)
[17:02:30.860]         {
[17:02:30.860]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.860]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.860]             }
[17:02:30.860]             base::options(...future.oldOptions)
[17:02:30.860]             if (.Platform$OS.type == "windows") {
[17:02:30.860]                 old_names <- names(...future.oldEnvVars)
[17:02:30.860]                 envs <- base::Sys.getenv()
[17:02:30.860]                 names <- names(envs)
[17:02:30.860]                 common <- intersect(names, old_names)
[17:02:30.860]                 added <- setdiff(names, old_names)
[17:02:30.860]                 removed <- setdiff(old_names, names)
[17:02:30.860]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.860]                   envs[common]]
[17:02:30.860]                 NAMES <- toupper(changed)
[17:02:30.860]                 args <- list()
[17:02:30.860]                 for (kk in seq_along(NAMES)) {
[17:02:30.860]                   name <- changed[[kk]]
[17:02:30.860]                   NAME <- NAMES[[kk]]
[17:02:30.860]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.860]                     next
[17:02:30.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.860]                 }
[17:02:30.860]                 NAMES <- toupper(added)
[17:02:30.860]                 for (kk in seq_along(NAMES)) {
[17:02:30.860]                   name <- added[[kk]]
[17:02:30.860]                   NAME <- NAMES[[kk]]
[17:02:30.860]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.860]                     next
[17:02:30.860]                   args[[name]] <- ""
[17:02:30.860]                 }
[17:02:30.860]                 NAMES <- toupper(removed)
[17:02:30.860]                 for (kk in seq_along(NAMES)) {
[17:02:30.860]                   name <- removed[[kk]]
[17:02:30.860]                   NAME <- NAMES[[kk]]
[17:02:30.860]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.860]                     next
[17:02:30.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.860]                 }
[17:02:30.860]                 if (length(args) > 0) 
[17:02:30.860]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.860]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.860]             }
[17:02:30.860]             else {
[17:02:30.860]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.860]             }
[17:02:30.860]             {
[17:02:30.860]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.860]                   0L) {
[17:02:30.860]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.860]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.860]                   base::options(opts)
[17:02:30.860]                 }
[17:02:30.860]                 {
[17:02:30.860]                   {
[17:02:30.860]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.860]                     NULL
[17:02:30.860]                   }
[17:02:30.860]                   options(future.plan = NULL)
[17:02:30.860]                   if (is.na(NA_character_)) 
[17:02:30.860]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.860]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.860]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.860]                     .init = FALSE)
[17:02:30.860]                 }
[17:02:30.860]             }
[17:02:30.860]         }
[17:02:30.860]     })
[17:02:30.860]     if (TRUE) {
[17:02:30.860]         base::sink(type = "output", split = FALSE)
[17:02:30.860]         if (TRUE) {
[17:02:30.860]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.860]         }
[17:02:30.860]         else {
[17:02:30.860]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.860]         }
[17:02:30.860]         base::close(...future.stdout)
[17:02:30.860]         ...future.stdout <- NULL
[17:02:30.860]     }
[17:02:30.860]     ...future.result$conditions <- ...future.conditions
[17:02:30.860]     ...future.result$finished <- base::Sys.time()
[17:02:30.860]     ...future.result
[17:02:30.860] }
[17:02:30.863] requestCore(): workers = 2
[17:02:30.866] MulticoreFuture started
[17:02:30.866] - Launch lazy future ... done
[17:02:30.866] run() for ‘MulticoreFuture’ ... done
[17:02:30.867] plan(): Setting new future strategy stack:
[17:02:30.867] getGlobalsAndPackages() ...
[17:02:30.867] Searching for globals...
[17:02:30.867] List of future strategies:
[17:02:30.867] 1. sequential:
[17:02:30.867]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:30.867]    - tweaked: FALSE
[17:02:30.867]    - call: NULL
[17:02:30.868] plan(): nbrOfWorkers() = 1
[17:02:30.869] - globals found: [1] ‘{’
[17:02:30.869] Searching for globals ... DONE
[17:02:30.869] Resolving globals: FALSE
[17:02:30.870] 
[17:02:30.870] 
[17:02:30.870] getGlobalsAndPackages() ... DONE
[17:02:30.870] plan(): Setting new future strategy stack:
[17:02:30.871] run() for ‘Future’ ...
[17:02:30.870] List of future strategies:
[17:02:30.870] 1. multicore:
[17:02:30.870]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:30.870]    - tweaked: FALSE
[17:02:30.870]    - call: plan(strategy)
[17:02:30.871] - state: ‘created’
[17:02:30.871] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.876] plan(): nbrOfWorkers() = 2
[17:02:30.877] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.877] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:30.877]   - Field: ‘label’
[17:02:30.877]   - Field: ‘local’
[17:02:30.877]   - Field: ‘owner’
[17:02:30.877]   - Field: ‘envir’
[17:02:30.878]   - Field: ‘workers’
[17:02:30.878]   - Field: ‘packages’
[17:02:30.878]   - Field: ‘gc’
[17:02:30.878]   - Field: ‘job’
[17:02:30.878]   - Field: ‘conditions’
[17:02:30.878]   - Field: ‘expr’
[17:02:30.878]   - Field: ‘uuid’
[17:02:30.879]   - Field: ‘seed’
[17:02:30.879]   - Field: ‘version’
[17:02:30.879]   - Field: ‘result’
[17:02:30.879]   - Field: ‘asynchronous’
[17:02:30.879]   - Field: ‘calls’
[17:02:30.879]   - Field: ‘globals’
[17:02:30.879]   - Field: ‘stdout’
[17:02:30.880]   - Field: ‘earlySignal’
[17:02:30.880]   - Field: ‘lazy’
[17:02:30.880]   - Field: ‘state’
[17:02:30.880] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:30.880] - Launch lazy future ...
[17:02:30.881] Packages needed by the future expression (n = 0): <none>
[17:02:30.881] Packages needed by future strategies (n = 0): <none>
[17:02:30.882] {
[17:02:30.882]     {
[17:02:30.882]         {
[17:02:30.882]             ...future.startTime <- base::Sys.time()
[17:02:30.882]             {
[17:02:30.882]                 {
[17:02:30.882]                   {
[17:02:30.882]                     {
[17:02:30.882]                       base::local({
[17:02:30.882]                         has_future <- base::requireNamespace("future", 
[17:02:30.882]                           quietly = TRUE)
[17:02:30.882]                         if (has_future) {
[17:02:30.882]                           ns <- base::getNamespace("future")
[17:02:30.882]                           version <- ns[[".package"]][["version"]]
[17:02:30.882]                           if (is.null(version)) 
[17:02:30.882]                             version <- utils::packageVersion("future")
[17:02:30.882]                         }
[17:02:30.882]                         else {
[17:02:30.882]                           version <- NULL
[17:02:30.882]                         }
[17:02:30.882]                         if (!has_future || version < "1.8.0") {
[17:02:30.882]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.882]                             "", base::R.version$version.string), 
[17:02:30.882]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.882]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.882]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.882]                               "release", "version")], collapse = " "), 
[17:02:30.882]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.882]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.882]                             info)
[17:02:30.882]                           info <- base::paste(info, collapse = "; ")
[17:02:30.882]                           if (!has_future) {
[17:02:30.882]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.882]                               info)
[17:02:30.882]                           }
[17:02:30.882]                           else {
[17:02:30.882]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.882]                               info, version)
[17:02:30.882]                           }
[17:02:30.882]                           base::stop(msg)
[17:02:30.882]                         }
[17:02:30.882]                       })
[17:02:30.882]                     }
[17:02:30.882]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.882]                     base::options(mc.cores = 1L)
[17:02:30.882]                   }
[17:02:30.882]                   ...future.strategy.old <- future::plan("list")
[17:02:30.882]                   options(future.plan = NULL)
[17:02:30.882]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.882]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.882]                 }
[17:02:30.882]                 ...future.workdir <- getwd()
[17:02:30.882]             }
[17:02:30.882]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.882]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.882]         }
[17:02:30.882]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.882]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.882]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.882]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.882]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.882]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.882]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.882]             base::names(...future.oldOptions))
[17:02:30.882]     }
[17:02:30.882]     if (FALSE) {
[17:02:30.882]     }
[17:02:30.882]     else {
[17:02:30.882]         if (TRUE) {
[17:02:30.882]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.882]                 open = "w")
[17:02:30.882]         }
[17:02:30.882]         else {
[17:02:30.882]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.882]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.882]         }
[17:02:30.882]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.882]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.882]             base::sink(type = "output", split = FALSE)
[17:02:30.882]             base::close(...future.stdout)
[17:02:30.882]         }, add = TRUE)
[17:02:30.882]     }
[17:02:30.882]     ...future.frame <- base::sys.nframe()
[17:02:30.882]     ...future.conditions <- base::list()
[17:02:30.882]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.882]     if (FALSE) {
[17:02:30.882]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.882]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.882]     }
[17:02:30.882]     ...future.result <- base::tryCatch({
[17:02:30.882]         base::withCallingHandlers({
[17:02:30.882]             ...future.value <- base::withVisible(base::local({
[17:02:30.882]                 withCallingHandlers({
[17:02:30.882]                   {
[17:02:30.882]                     4
[17:02:30.882]                   }
[17:02:30.882]                 }, immediateCondition = function(cond) {
[17:02:30.882]                   save_rds <- function (object, pathname, ...) 
[17:02:30.882]                   {
[17:02:30.882]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:30.882]                     if (file_test("-f", pathname_tmp)) {
[17:02:30.882]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.882]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:30.882]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.882]                         fi_tmp[["mtime"]])
[17:02:30.882]                     }
[17:02:30.882]                     tryCatch({
[17:02:30.882]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:30.882]                     }, error = function(ex) {
[17:02:30.882]                       msg <- conditionMessage(ex)
[17:02:30.882]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.882]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:30.882]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.882]                         fi_tmp[["mtime"]], msg)
[17:02:30.882]                       ex$message <- msg
[17:02:30.882]                       stop(ex)
[17:02:30.882]                     })
[17:02:30.882]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:30.882]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:30.882]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:30.882]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.882]                       fi <- file.info(pathname)
[17:02:30.882]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:30.882]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.882]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:30.882]                         fi[["size"]], fi[["mtime"]])
[17:02:30.882]                       stop(msg)
[17:02:30.882]                     }
[17:02:30.882]                     invisible(pathname)
[17:02:30.882]                   }
[17:02:30.882]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:30.882]                     rootPath = tempdir()) 
[17:02:30.882]                   {
[17:02:30.882]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:30.882]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:30.882]                       tmpdir = path, fileext = ".rds")
[17:02:30.882]                     save_rds(obj, file)
[17:02:30.882]                   }
[17:02:30.882]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:30.882]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.882]                   {
[17:02:30.882]                     inherits <- base::inherits
[17:02:30.882]                     invokeRestart <- base::invokeRestart
[17:02:30.882]                     is.null <- base::is.null
[17:02:30.882]                     muffled <- FALSE
[17:02:30.882]                     if (inherits(cond, "message")) {
[17:02:30.882]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.882]                       if (muffled) 
[17:02:30.882]                         invokeRestart("muffleMessage")
[17:02:30.882]                     }
[17:02:30.882]                     else if (inherits(cond, "warning")) {
[17:02:30.882]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.882]                       if (muffled) 
[17:02:30.882]                         invokeRestart("muffleWarning")
[17:02:30.882]                     }
[17:02:30.882]                     else if (inherits(cond, "condition")) {
[17:02:30.882]                       if (!is.null(pattern)) {
[17:02:30.882]                         computeRestarts <- base::computeRestarts
[17:02:30.882]                         grepl <- base::grepl
[17:02:30.882]                         restarts <- computeRestarts(cond)
[17:02:30.882]                         for (restart in restarts) {
[17:02:30.882]                           name <- restart$name
[17:02:30.882]                           if (is.null(name)) 
[17:02:30.882]                             next
[17:02:30.882]                           if (!grepl(pattern, name)) 
[17:02:30.882]                             next
[17:02:30.882]                           invokeRestart(restart)
[17:02:30.882]                           muffled <- TRUE
[17:02:30.882]                           break
[17:02:30.882]                         }
[17:02:30.882]                       }
[17:02:30.882]                     }
[17:02:30.882]                     invisible(muffled)
[17:02:30.882]                   }
[17:02:30.882]                   muffleCondition(cond)
[17:02:30.882]                 })
[17:02:30.882]             }))
[17:02:30.882]             future::FutureResult(value = ...future.value$value, 
[17:02:30.882]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.882]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.882]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.882]                     ...future.globalenv.names))
[17:02:30.882]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.882]         }, condition = base::local({
[17:02:30.882]             c <- base::c
[17:02:30.882]             inherits <- base::inherits
[17:02:30.882]             invokeRestart <- base::invokeRestart
[17:02:30.882]             length <- base::length
[17:02:30.882]             list <- base::list
[17:02:30.882]             seq.int <- base::seq.int
[17:02:30.882]             signalCondition <- base::signalCondition
[17:02:30.882]             sys.calls <- base::sys.calls
[17:02:30.882]             `[[` <- base::`[[`
[17:02:30.882]             `+` <- base::`+`
[17:02:30.882]             `<<-` <- base::`<<-`
[17:02:30.882]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.882]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.882]                   3L)]
[17:02:30.882]             }
[17:02:30.882]             function(cond) {
[17:02:30.882]                 is_error <- inherits(cond, "error")
[17:02:30.882]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.882]                   NULL)
[17:02:30.882]                 if (is_error) {
[17:02:30.882]                   sessionInformation <- function() {
[17:02:30.882]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.882]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.882]                       search = base::search(), system = base::Sys.info())
[17:02:30.882]                   }
[17:02:30.882]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.882]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.882]                     cond$call), session = sessionInformation(), 
[17:02:30.882]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.882]                   signalCondition(cond)
[17:02:30.882]                 }
[17:02:30.882]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.882]                 "immediateCondition"))) {
[17:02:30.882]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.882]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.882]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.882]                   if (TRUE && !signal) {
[17:02:30.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.882]                     {
[17:02:30.882]                       inherits <- base::inherits
[17:02:30.882]                       invokeRestart <- base::invokeRestart
[17:02:30.882]                       is.null <- base::is.null
[17:02:30.882]                       muffled <- FALSE
[17:02:30.882]                       if (inherits(cond, "message")) {
[17:02:30.882]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.882]                         if (muffled) 
[17:02:30.882]                           invokeRestart("muffleMessage")
[17:02:30.882]                       }
[17:02:30.882]                       else if (inherits(cond, "warning")) {
[17:02:30.882]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.882]                         if (muffled) 
[17:02:30.882]                           invokeRestart("muffleWarning")
[17:02:30.882]                       }
[17:02:30.882]                       else if (inherits(cond, "condition")) {
[17:02:30.882]                         if (!is.null(pattern)) {
[17:02:30.882]                           computeRestarts <- base::computeRestarts
[17:02:30.882]                           grepl <- base::grepl
[17:02:30.882]                           restarts <- computeRestarts(cond)
[17:02:30.882]                           for (restart in restarts) {
[17:02:30.882]                             name <- restart$name
[17:02:30.882]                             if (is.null(name)) 
[17:02:30.882]                               next
[17:02:30.882]                             if (!grepl(pattern, name)) 
[17:02:30.882]                               next
[17:02:30.882]                             invokeRestart(restart)
[17:02:30.882]                             muffled <- TRUE
[17:02:30.882]                             break
[17:02:30.882]                           }
[17:02:30.882]                         }
[17:02:30.882]                       }
[17:02:30.882]                       invisible(muffled)
[17:02:30.882]                     }
[17:02:30.882]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.882]                   }
[17:02:30.882]                 }
[17:02:30.882]                 else {
[17:02:30.882]                   if (TRUE) {
[17:02:30.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.882]                     {
[17:02:30.882]                       inherits <- base::inherits
[17:02:30.882]                       invokeRestart <- base::invokeRestart
[17:02:30.882]                       is.null <- base::is.null
[17:02:30.882]                       muffled <- FALSE
[17:02:30.882]                       if (inherits(cond, "message")) {
[17:02:30.882]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.882]                         if (muffled) 
[17:02:30.882]                           invokeRestart("muffleMessage")
[17:02:30.882]                       }
[17:02:30.882]                       else if (inherits(cond, "warning")) {
[17:02:30.882]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.882]                         if (muffled) 
[17:02:30.882]                           invokeRestart("muffleWarning")
[17:02:30.882]                       }
[17:02:30.882]                       else if (inherits(cond, "condition")) {
[17:02:30.882]                         if (!is.null(pattern)) {
[17:02:30.882]                           computeRestarts <- base::computeRestarts
[17:02:30.882]                           grepl <- base::grepl
[17:02:30.882]                           restarts <- computeRestarts(cond)
[17:02:30.882]                           for (restart in restarts) {
[17:02:30.882]                             name <- restart$name
[17:02:30.882]                             if (is.null(name)) 
[17:02:30.882]                               next
[17:02:30.882]                             if (!grepl(pattern, name)) 
[17:02:30.882]                               next
[17:02:30.882]                             invokeRestart(restart)
[17:02:30.882]                             muffled <- TRUE
[17:02:30.882]                             break
[17:02:30.882]                           }
[17:02:30.882]                         }
[17:02:30.882]                       }
[17:02:30.882]                       invisible(muffled)
[17:02:30.882]                     }
[17:02:30.882]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.882]                   }
[17:02:30.882]                 }
[17:02:30.882]             }
[17:02:30.882]         }))
[17:02:30.882]     }, error = function(ex) {
[17:02:30.882]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.882]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.882]                 ...future.rng), started = ...future.startTime, 
[17:02:30.882]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.882]             version = "1.8"), class = "FutureResult")
[17:02:30.882]     }, finally = {
[17:02:30.882]         if (!identical(...future.workdir, getwd())) 
[17:02:30.882]             setwd(...future.workdir)
[17:02:30.882]         {
[17:02:30.882]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.882]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.882]             }
[17:02:30.882]             base::options(...future.oldOptions)
[17:02:30.882]             if (.Platform$OS.type == "windows") {
[17:02:30.882]                 old_names <- names(...future.oldEnvVars)
[17:02:30.882]                 envs <- base::Sys.getenv()
[17:02:30.882]                 names <- names(envs)
[17:02:30.882]                 common <- intersect(names, old_names)
[17:02:30.882]                 added <- setdiff(names, old_names)
[17:02:30.882]                 removed <- setdiff(old_names, names)
[17:02:30.882]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.882]                   envs[common]]
[17:02:30.882]                 NAMES <- toupper(changed)
[17:02:30.882]                 args <- list()
[17:02:30.882]                 for (kk in seq_along(NAMES)) {
[17:02:30.882]                   name <- changed[[kk]]
[17:02:30.882]                   NAME <- NAMES[[kk]]
[17:02:30.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.882]                     next
[17:02:30.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.882]                 }
[17:02:30.882]                 NAMES <- toupper(added)
[17:02:30.882]                 for (kk in seq_along(NAMES)) {
[17:02:30.882]                   name <- added[[kk]]
[17:02:30.882]                   NAME <- NAMES[[kk]]
[17:02:30.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.882]                     next
[17:02:30.882]                   args[[name]] <- ""
[17:02:30.882]                 }
[17:02:30.882]                 NAMES <- toupper(removed)
[17:02:30.882]                 for (kk in seq_along(NAMES)) {
[17:02:30.882]                   name <- removed[[kk]]
[17:02:30.882]                   NAME <- NAMES[[kk]]
[17:02:30.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.882]                     next
[17:02:30.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.882]                 }
[17:02:30.882]                 if (length(args) > 0) 
[17:02:30.882]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.882]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.882]             }
[17:02:30.882]             else {
[17:02:30.882]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.882]             }
[17:02:30.882]             {
[17:02:30.882]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.882]                   0L) {
[17:02:30.882]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.882]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.882]                   base::options(opts)
[17:02:30.882]                 }
[17:02:30.882]                 {
[17:02:30.882]                   {
[17:02:30.882]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.882]                     NULL
[17:02:30.882]                   }
[17:02:30.882]                   options(future.plan = NULL)
[17:02:30.882]                   if (is.na(NA_character_)) 
[17:02:30.882]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.882]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.882]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.882]                     .init = FALSE)
[17:02:30.882]                 }
[17:02:30.882]             }
[17:02:30.882]         }
[17:02:30.882]     })
[17:02:30.882]     if (TRUE) {
[17:02:30.882]         base::sink(type = "output", split = FALSE)
[17:02:30.882]         if (TRUE) {
[17:02:30.882]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.882]         }
[17:02:30.882]         else {
[17:02:30.882]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.882]         }
[17:02:30.882]         base::close(...future.stdout)
[17:02:30.882]         ...future.stdout <- NULL
[17:02:30.882]     }
[17:02:30.882]     ...future.result$conditions <- ...future.conditions
[17:02:30.882]     ...future.result$finished <- base::Sys.time()
[17:02:30.882]     ...future.result
[17:02:30.882] }
[17:02:30.885] requestCore(): workers = 2
[17:02:30.886] Poll #1 (0): usedCores() = 2, workers = 2
[17:02:30.896] result() for MulticoreFuture ...
[17:02:30.897] result() for MulticoreFuture ...
[17:02:30.897] result() for MulticoreFuture ... done
[17:02:30.898] result() for MulticoreFuture ... done
[17:02:30.898] result() for MulticoreFuture ...
[17:02:30.898] result() for MulticoreFuture ... done
[17:02:30.901] MulticoreFuture started
[17:02:30.901] - Launch lazy future ... done
[17:02:30.901] run() for ‘MulticoreFuture’ ... done
[17:02:30.902] plan(): Setting new future strategy stack:
<environment: 0x55c74b525c40> 
[17:02:30.902] List of future strategies:
[17:02:30.902] 1. sequential:
[17:02:30.902]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:30.902]    - tweaked: FALSE
[17:02:30.902]    - call: NULL
[17:02:30.904] plan(): nbrOfWorkers() = 1
<environment: 0x55c74945c800> 
[17:02:30.907] plan(): Setting new future strategy stack:
[17:02:30.907] List of future strategies:
[17:02:30.907] 1. multicore:
[17:02:30.907]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:30.907]    - tweaked: FALSE
[17:02:30.907]    - call: plan(strategy)
[17:02:30.912] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:30.915] resolve() on environment ...
[17:02:30.915]  recursive: 0
[17:02:30.916]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:30.916] signalConditionsASAP(numeric, pos=1) ...
[17:02:30.916] - nx: 4
[17:02:30.916] - relay: TRUE
[17:02:30.916] - stdout: TRUE
[17:02:30.916] - signal: TRUE
[17:02:30.917] - resignal: FALSE
[17:02:30.917] - force: TRUE
[17:02:30.917] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:30.917] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:30.917]  - until=2
[17:02:30.917]  - relaying element #2
[17:02:30.917] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:30.918] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:30.918] signalConditionsASAP(NULL, pos=1) ... done
[17:02:30.918]  length: 3 (resolved future 1)
[17:02:30.918] Future #2
[17:02:30.918] result() for MulticoreFuture ...
[17:02:30.918] result() for MulticoreFuture ... done
[17:02:30.919] result() for MulticoreFuture ...
[17:02:30.919] result() for MulticoreFuture ... done
[17:02:30.919] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:30.919] - nx: 4
[17:02:30.919] - relay: TRUE
[17:02:30.919] - stdout: TRUE
[17:02:30.919] - signal: TRUE
[17:02:30.920] - resignal: FALSE
[17:02:30.920] - force: TRUE
[17:02:30.920] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:30.920] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:30.920]  - until=2
[17:02:30.920]  - relaying element #2
[17:02:30.920] result() for MulticoreFuture ...
[17:02:30.921] result() for MulticoreFuture ... done
[17:02:30.921] result() for MulticoreFuture ...
[17:02:30.921] result() for MulticoreFuture ... done
[17:02:30.921] result() for MulticoreFuture ...
[17:02:30.921] result() for MulticoreFuture ... done
[17:02:30.922] result() for MulticoreFuture ...
[17:02:30.922] result() for MulticoreFuture ... done
[17:02:30.922] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:30.922] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:30.922] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:30.922]  length: 2 (resolved future 2)
[17:02:30.923] Future #3
[17:02:30.923] result() for MulticoreFuture ...
[17:02:30.924] result() for MulticoreFuture ...
[17:02:30.924] result() for MulticoreFuture ... done
[17:02:30.924] result() for MulticoreFuture ... done
[17:02:30.924] result() for MulticoreFuture ...
[17:02:30.924] result() for MulticoreFuture ... done
[17:02:30.925] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:30.925] - nx: 4
[17:02:30.925] - relay: TRUE
[17:02:30.925] - stdout: TRUE
[17:02:30.925] - signal: TRUE
[17:02:30.925] - resignal: FALSE
[17:02:30.925] - force: TRUE
[17:02:30.926] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:30.926] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:30.926]  - until=3
[17:02:30.926]  - relaying element #3
[17:02:30.926] result() for MulticoreFuture ...
[17:02:30.927] result() for MulticoreFuture ... done
[17:02:30.927] result() for MulticoreFuture ...
[17:02:30.927] result() for MulticoreFuture ... done
[17:02:30.927] result() for MulticoreFuture ...
[17:02:30.927] result() for MulticoreFuture ... done
[17:02:30.928] result() for MulticoreFuture ...
[17:02:30.928] result() for MulticoreFuture ... done
[17:02:30.928] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:30.928] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:30.928] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:30.929]  length: 1 (resolved future 3)
[17:02:30.929] Future #4
[17:02:30.929] result() for MulticoreFuture ...
[17:02:30.930] result() for MulticoreFuture ...
[17:02:30.930] result() for MulticoreFuture ... done
[17:02:30.930] result() for MulticoreFuture ... done
[17:02:30.931] result() for MulticoreFuture ...
[17:02:30.931] result() for MulticoreFuture ... done
[17:02:30.931] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:02:30.931] - nx: 4
[17:02:30.932] - relay: TRUE
[17:02:30.932] - stdout: TRUE
[17:02:30.932] - signal: TRUE
[17:02:30.932] - resignal: FALSE
[17:02:30.932] - force: TRUE
[17:02:30.932] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:30.932] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:30.933]  - until=4
[17:02:30.933]  - relaying element #4
[17:02:30.933] result() for MulticoreFuture ...
[17:02:30.933] result() for MulticoreFuture ... done
[17:02:30.933] result() for MulticoreFuture ...
[17:02:30.934] result() for MulticoreFuture ... done
[17:02:30.934] result() for MulticoreFuture ...
[17:02:30.934] result() for MulticoreFuture ... done
[17:02:30.934] result() for MulticoreFuture ...
[17:02:30.934] result() for MulticoreFuture ... done
[17:02:30.934] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:30.934] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:30.935] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:02:30.935]  length: 0 (resolved future 4)
[17:02:30.935] Relaying remaining futures
[17:02:30.935] signalConditionsASAP(NULL, pos=0) ...
[17:02:30.935] - nx: 4
[17:02:30.935] - relay: TRUE
[17:02:30.935] - stdout: TRUE
[17:02:30.935] - signal: TRUE
[17:02:30.935] - resignal: FALSE
[17:02:30.936] - force: TRUE
[17:02:30.936] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:30.936] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:30.936] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:30.936] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:30.936] signalConditionsASAP(NULL, pos=0) ... done
[17:02:30.936] resolve() on environment ... DONE
[17:02:30.936] result() for MulticoreFuture ...
[17:02:30.937] result() for MulticoreFuture ... done
[17:02:30.937] result() for MulticoreFuture ...
[17:02:30.937] result() for MulticoreFuture ... done
[17:02:30.937] result() for MulticoreFuture ...
[17:02:30.937] result() for MulticoreFuture ... done
[17:02:30.937] result() for MulticoreFuture ...
[17:02:30.937] result() for MulticoreFuture ... done
[17:02:30.937] result() for MulticoreFuture ...
[17:02:30.938] result() for MulticoreFuture ... done
[17:02:30.938] result() for MulticoreFuture ...
[17:02:30.938] result() for MulticoreFuture ... done
<environment: 0x55c749194500> 
Dimensions: c(2, 3, 1)
[17:02:30.938] getGlobalsAndPackages() ...
[17:02:30.938] Searching for globals...
[17:02:30.939] 
[17:02:30.939] Searching for globals ... DONE
[17:02:30.939] - globals: [0] <none>
[17:02:30.939] getGlobalsAndPackages() ... DONE
[17:02:30.940] run() for ‘Future’ ...
[17:02:30.940] - state: ‘created’
[17:02:30.940] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.945] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.945] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:30.945]   - Field: ‘label’
[17:02:30.945]   - Field: ‘local’
[17:02:30.945]   - Field: ‘owner’
[17:02:30.945]   - Field: ‘envir’
[17:02:30.945]   - Field: ‘workers’
[17:02:30.946]   - Field: ‘packages’
[17:02:30.946]   - Field: ‘gc’
[17:02:30.946]   - Field: ‘job’
[17:02:30.946]   - Field: ‘conditions’
[17:02:30.946]   - Field: ‘expr’
[17:02:30.946]   - Field: ‘uuid’
[17:02:30.946]   - Field: ‘seed’
[17:02:30.946]   - Field: ‘version’
[17:02:30.946]   - Field: ‘result’
[17:02:30.946]   - Field: ‘asynchronous’
[17:02:30.947]   - Field: ‘calls’
[17:02:30.947]   - Field: ‘globals’
[17:02:30.947]   - Field: ‘stdout’
[17:02:30.947]   - Field: ‘earlySignal’
[17:02:30.947]   - Field: ‘lazy’
[17:02:30.947]   - Field: ‘state’
[17:02:30.947] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:30.947] - Launch lazy future ...
[17:02:30.948] Packages needed by the future expression (n = 0): <none>
[17:02:30.948] Packages needed by future strategies (n = 0): <none>
[17:02:30.948] {
[17:02:30.948]     {
[17:02:30.948]         {
[17:02:30.948]             ...future.startTime <- base::Sys.time()
[17:02:30.948]             {
[17:02:30.948]                 {
[17:02:30.948]                   {
[17:02:30.948]                     {
[17:02:30.948]                       base::local({
[17:02:30.948]                         has_future <- base::requireNamespace("future", 
[17:02:30.948]                           quietly = TRUE)
[17:02:30.948]                         if (has_future) {
[17:02:30.948]                           ns <- base::getNamespace("future")
[17:02:30.948]                           version <- ns[[".package"]][["version"]]
[17:02:30.948]                           if (is.null(version)) 
[17:02:30.948]                             version <- utils::packageVersion("future")
[17:02:30.948]                         }
[17:02:30.948]                         else {
[17:02:30.948]                           version <- NULL
[17:02:30.948]                         }
[17:02:30.948]                         if (!has_future || version < "1.8.0") {
[17:02:30.948]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.948]                             "", base::R.version$version.string), 
[17:02:30.948]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.948]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.948]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.948]                               "release", "version")], collapse = " "), 
[17:02:30.948]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.948]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.948]                             info)
[17:02:30.948]                           info <- base::paste(info, collapse = "; ")
[17:02:30.948]                           if (!has_future) {
[17:02:30.948]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.948]                               info)
[17:02:30.948]                           }
[17:02:30.948]                           else {
[17:02:30.948]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.948]                               info, version)
[17:02:30.948]                           }
[17:02:30.948]                           base::stop(msg)
[17:02:30.948]                         }
[17:02:30.948]                       })
[17:02:30.948]                     }
[17:02:30.948]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.948]                     base::options(mc.cores = 1L)
[17:02:30.948]                   }
[17:02:30.948]                   ...future.strategy.old <- future::plan("list")
[17:02:30.948]                   options(future.plan = NULL)
[17:02:30.948]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.948]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.948]                 }
[17:02:30.948]                 ...future.workdir <- getwd()
[17:02:30.948]             }
[17:02:30.948]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.948]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.948]         }
[17:02:30.948]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.948]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.948]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.948]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.948]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.948]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.948]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.948]             base::names(...future.oldOptions))
[17:02:30.948]     }
[17:02:30.948]     if (FALSE) {
[17:02:30.948]     }
[17:02:30.948]     else {
[17:02:30.948]         if (TRUE) {
[17:02:30.948]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.948]                 open = "w")
[17:02:30.948]         }
[17:02:30.948]         else {
[17:02:30.948]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.948]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.948]         }
[17:02:30.948]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.948]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.948]             base::sink(type = "output", split = FALSE)
[17:02:30.948]             base::close(...future.stdout)
[17:02:30.948]         }, add = TRUE)
[17:02:30.948]     }
[17:02:30.948]     ...future.frame <- base::sys.nframe()
[17:02:30.948]     ...future.conditions <- base::list()
[17:02:30.948]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.948]     if (FALSE) {
[17:02:30.948]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.948]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.948]     }
[17:02:30.948]     ...future.result <- base::tryCatch({
[17:02:30.948]         base::withCallingHandlers({
[17:02:30.948]             ...future.value <- base::withVisible(base::local({
[17:02:30.948]                 withCallingHandlers({
[17:02:30.948]                   2
[17:02:30.948]                 }, immediateCondition = function(cond) {
[17:02:30.948]                   save_rds <- function (object, pathname, ...) 
[17:02:30.948]                   {
[17:02:30.948]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:30.948]                     if (file_test("-f", pathname_tmp)) {
[17:02:30.948]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.948]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:30.948]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.948]                         fi_tmp[["mtime"]])
[17:02:30.948]                     }
[17:02:30.948]                     tryCatch({
[17:02:30.948]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:30.948]                     }, error = function(ex) {
[17:02:30.948]                       msg <- conditionMessage(ex)
[17:02:30.948]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.948]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:30.948]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.948]                         fi_tmp[["mtime"]], msg)
[17:02:30.948]                       ex$message <- msg
[17:02:30.948]                       stop(ex)
[17:02:30.948]                     })
[17:02:30.948]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:30.948]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:30.948]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:30.948]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.948]                       fi <- file.info(pathname)
[17:02:30.948]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:30.948]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.948]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:30.948]                         fi[["size"]], fi[["mtime"]])
[17:02:30.948]                       stop(msg)
[17:02:30.948]                     }
[17:02:30.948]                     invisible(pathname)
[17:02:30.948]                   }
[17:02:30.948]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:30.948]                     rootPath = tempdir()) 
[17:02:30.948]                   {
[17:02:30.948]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:30.948]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:30.948]                       tmpdir = path, fileext = ".rds")
[17:02:30.948]                     save_rds(obj, file)
[17:02:30.948]                   }
[17:02:30.948]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:30.948]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.948]                   {
[17:02:30.948]                     inherits <- base::inherits
[17:02:30.948]                     invokeRestart <- base::invokeRestart
[17:02:30.948]                     is.null <- base::is.null
[17:02:30.948]                     muffled <- FALSE
[17:02:30.948]                     if (inherits(cond, "message")) {
[17:02:30.948]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.948]                       if (muffled) 
[17:02:30.948]                         invokeRestart("muffleMessage")
[17:02:30.948]                     }
[17:02:30.948]                     else if (inherits(cond, "warning")) {
[17:02:30.948]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.948]                       if (muffled) 
[17:02:30.948]                         invokeRestart("muffleWarning")
[17:02:30.948]                     }
[17:02:30.948]                     else if (inherits(cond, "condition")) {
[17:02:30.948]                       if (!is.null(pattern)) {
[17:02:30.948]                         computeRestarts <- base::computeRestarts
[17:02:30.948]                         grepl <- base::grepl
[17:02:30.948]                         restarts <- computeRestarts(cond)
[17:02:30.948]                         for (restart in restarts) {
[17:02:30.948]                           name <- restart$name
[17:02:30.948]                           if (is.null(name)) 
[17:02:30.948]                             next
[17:02:30.948]                           if (!grepl(pattern, name)) 
[17:02:30.948]                             next
[17:02:30.948]                           invokeRestart(restart)
[17:02:30.948]                           muffled <- TRUE
[17:02:30.948]                           break
[17:02:30.948]                         }
[17:02:30.948]                       }
[17:02:30.948]                     }
[17:02:30.948]                     invisible(muffled)
[17:02:30.948]                   }
[17:02:30.948]                   muffleCondition(cond)
[17:02:30.948]                 })
[17:02:30.948]             }))
[17:02:30.948]             future::FutureResult(value = ...future.value$value, 
[17:02:30.948]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.948]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.948]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.948]                     ...future.globalenv.names))
[17:02:30.948]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.948]         }, condition = base::local({
[17:02:30.948]             c <- base::c
[17:02:30.948]             inherits <- base::inherits
[17:02:30.948]             invokeRestart <- base::invokeRestart
[17:02:30.948]             length <- base::length
[17:02:30.948]             list <- base::list
[17:02:30.948]             seq.int <- base::seq.int
[17:02:30.948]             signalCondition <- base::signalCondition
[17:02:30.948]             sys.calls <- base::sys.calls
[17:02:30.948]             `[[` <- base::`[[`
[17:02:30.948]             `+` <- base::`+`
[17:02:30.948]             `<<-` <- base::`<<-`
[17:02:30.948]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.948]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.948]                   3L)]
[17:02:30.948]             }
[17:02:30.948]             function(cond) {
[17:02:30.948]                 is_error <- inherits(cond, "error")
[17:02:30.948]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.948]                   NULL)
[17:02:30.948]                 if (is_error) {
[17:02:30.948]                   sessionInformation <- function() {
[17:02:30.948]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.948]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.948]                       search = base::search(), system = base::Sys.info())
[17:02:30.948]                   }
[17:02:30.948]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.948]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.948]                     cond$call), session = sessionInformation(), 
[17:02:30.948]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.948]                   signalCondition(cond)
[17:02:30.948]                 }
[17:02:30.948]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.948]                 "immediateCondition"))) {
[17:02:30.948]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.948]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.948]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.948]                   if (TRUE && !signal) {
[17:02:30.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.948]                     {
[17:02:30.948]                       inherits <- base::inherits
[17:02:30.948]                       invokeRestart <- base::invokeRestart
[17:02:30.948]                       is.null <- base::is.null
[17:02:30.948]                       muffled <- FALSE
[17:02:30.948]                       if (inherits(cond, "message")) {
[17:02:30.948]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.948]                         if (muffled) 
[17:02:30.948]                           invokeRestart("muffleMessage")
[17:02:30.948]                       }
[17:02:30.948]                       else if (inherits(cond, "warning")) {
[17:02:30.948]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.948]                         if (muffled) 
[17:02:30.948]                           invokeRestart("muffleWarning")
[17:02:30.948]                       }
[17:02:30.948]                       else if (inherits(cond, "condition")) {
[17:02:30.948]                         if (!is.null(pattern)) {
[17:02:30.948]                           computeRestarts <- base::computeRestarts
[17:02:30.948]                           grepl <- base::grepl
[17:02:30.948]                           restarts <- computeRestarts(cond)
[17:02:30.948]                           for (restart in restarts) {
[17:02:30.948]                             name <- restart$name
[17:02:30.948]                             if (is.null(name)) 
[17:02:30.948]                               next
[17:02:30.948]                             if (!grepl(pattern, name)) 
[17:02:30.948]                               next
[17:02:30.948]                             invokeRestart(restart)
[17:02:30.948]                             muffled <- TRUE
[17:02:30.948]                             break
[17:02:30.948]                           }
[17:02:30.948]                         }
[17:02:30.948]                       }
[17:02:30.948]                       invisible(muffled)
[17:02:30.948]                     }
[17:02:30.948]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.948]                   }
[17:02:30.948]                 }
[17:02:30.948]                 else {
[17:02:30.948]                   if (TRUE) {
[17:02:30.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.948]                     {
[17:02:30.948]                       inherits <- base::inherits
[17:02:30.948]                       invokeRestart <- base::invokeRestart
[17:02:30.948]                       is.null <- base::is.null
[17:02:30.948]                       muffled <- FALSE
[17:02:30.948]                       if (inherits(cond, "message")) {
[17:02:30.948]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.948]                         if (muffled) 
[17:02:30.948]                           invokeRestart("muffleMessage")
[17:02:30.948]                       }
[17:02:30.948]                       else if (inherits(cond, "warning")) {
[17:02:30.948]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.948]                         if (muffled) 
[17:02:30.948]                           invokeRestart("muffleWarning")
[17:02:30.948]                       }
[17:02:30.948]                       else if (inherits(cond, "condition")) {
[17:02:30.948]                         if (!is.null(pattern)) {
[17:02:30.948]                           computeRestarts <- base::computeRestarts
[17:02:30.948]                           grepl <- base::grepl
[17:02:30.948]                           restarts <- computeRestarts(cond)
[17:02:30.948]                           for (restart in restarts) {
[17:02:30.948]                             name <- restart$name
[17:02:30.948]                             if (is.null(name)) 
[17:02:30.948]                               next
[17:02:30.948]                             if (!grepl(pattern, name)) 
[17:02:30.948]                               next
[17:02:30.948]                             invokeRestart(restart)
[17:02:30.948]                             muffled <- TRUE
[17:02:30.948]                             break
[17:02:30.948]                           }
[17:02:30.948]                         }
[17:02:30.948]                       }
[17:02:30.948]                       invisible(muffled)
[17:02:30.948]                     }
[17:02:30.948]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.948]                   }
[17:02:30.948]                 }
[17:02:30.948]             }
[17:02:30.948]         }))
[17:02:30.948]     }, error = function(ex) {
[17:02:30.948]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.948]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.948]                 ...future.rng), started = ...future.startTime, 
[17:02:30.948]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.948]             version = "1.8"), class = "FutureResult")
[17:02:30.948]     }, finally = {
[17:02:30.948]         if (!identical(...future.workdir, getwd())) 
[17:02:30.948]             setwd(...future.workdir)
[17:02:30.948]         {
[17:02:30.948]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.948]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.948]             }
[17:02:30.948]             base::options(...future.oldOptions)
[17:02:30.948]             if (.Platform$OS.type == "windows") {
[17:02:30.948]                 old_names <- names(...future.oldEnvVars)
[17:02:30.948]                 envs <- base::Sys.getenv()
[17:02:30.948]                 names <- names(envs)
[17:02:30.948]                 common <- intersect(names, old_names)
[17:02:30.948]                 added <- setdiff(names, old_names)
[17:02:30.948]                 removed <- setdiff(old_names, names)
[17:02:30.948]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.948]                   envs[common]]
[17:02:30.948]                 NAMES <- toupper(changed)
[17:02:30.948]                 args <- list()
[17:02:30.948]                 for (kk in seq_along(NAMES)) {
[17:02:30.948]                   name <- changed[[kk]]
[17:02:30.948]                   NAME <- NAMES[[kk]]
[17:02:30.948]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.948]                     next
[17:02:30.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.948]                 }
[17:02:30.948]                 NAMES <- toupper(added)
[17:02:30.948]                 for (kk in seq_along(NAMES)) {
[17:02:30.948]                   name <- added[[kk]]
[17:02:30.948]                   NAME <- NAMES[[kk]]
[17:02:30.948]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.948]                     next
[17:02:30.948]                   args[[name]] <- ""
[17:02:30.948]                 }
[17:02:30.948]                 NAMES <- toupper(removed)
[17:02:30.948]                 for (kk in seq_along(NAMES)) {
[17:02:30.948]                   name <- removed[[kk]]
[17:02:30.948]                   NAME <- NAMES[[kk]]
[17:02:30.948]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.948]                     next
[17:02:30.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.948]                 }
[17:02:30.948]                 if (length(args) > 0) 
[17:02:30.948]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.948]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.948]             }
[17:02:30.948]             else {
[17:02:30.948]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.948]             }
[17:02:30.948]             {
[17:02:30.948]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.948]                   0L) {
[17:02:30.948]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.948]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.948]                   base::options(opts)
[17:02:30.948]                 }
[17:02:30.948]                 {
[17:02:30.948]                   {
[17:02:30.948]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.948]                     NULL
[17:02:30.948]                   }
[17:02:30.948]                   options(future.plan = NULL)
[17:02:30.948]                   if (is.na(NA_character_)) 
[17:02:30.948]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.948]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.948]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.948]                     .init = FALSE)
[17:02:30.948]                 }
[17:02:30.948]             }
[17:02:30.948]         }
[17:02:30.948]     })
[17:02:30.948]     if (TRUE) {
[17:02:30.948]         base::sink(type = "output", split = FALSE)
[17:02:30.948]         if (TRUE) {
[17:02:30.948]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.948]         }
[17:02:30.948]         else {
[17:02:30.948]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.948]         }
[17:02:30.948]         base::close(...future.stdout)
[17:02:30.948]         ...future.stdout <- NULL
[17:02:30.948]     }
[17:02:30.948]     ...future.result$conditions <- ...future.conditions
[17:02:30.948]     ...future.result$finished <- base::Sys.time()
[17:02:30.948]     ...future.result
[17:02:30.948] }
[17:02:30.951] requestCore(): workers = 2
[17:02:30.954] MulticoreFuture started
[17:02:30.954] - Launch lazy future ... done
[17:02:30.954] run() for ‘MulticoreFuture’ ... done
[17:02:30.954] getGlobalsAndPackages() ...
[17:02:30.955] Searching for globals...
[17:02:30.955] plan(): Setting new future strategy stack:
[17:02:30.955] 
[17:02:30.956] Searching for globals ... DONE
[17:02:30.956] - globals: [0] <none>
[17:02:30.955] List of future strategies:
[17:02:30.955] 1. sequential:
[17:02:30.955]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:30.955]    - tweaked: FALSE
[17:02:30.955]    - call: NULL
[17:02:30.956] getGlobalsAndPackages() ... DONE
[17:02:30.956] plan(): nbrOfWorkers() = 1
[17:02:30.956] run() for ‘Future’ ...
[17:02:30.957] - state: ‘created’
[17:02:30.957] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.958] plan(): Setting new future strategy stack:
[17:02:30.958] List of future strategies:
[17:02:30.958] 1. multicore:
[17:02:30.958]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:30.958]    - tweaked: FALSE
[17:02:30.958]    - call: plan(strategy)
[17:02:30.962] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:30.962] plan(): nbrOfWorkers() = 2
[17:02:30.962]   - Field: ‘label’
[17:02:30.962]   - Field: ‘local’
[17:02:30.963]   - Field: ‘owner’
[17:02:30.963]   - Field: ‘envir’
[17:02:30.963]   - Field: ‘workers’
[17:02:30.963]   - Field: ‘packages’
[17:02:30.963]   - Field: ‘gc’
[17:02:30.963]   - Field: ‘job’
[17:02:30.963]   - Field: ‘conditions’
[17:02:30.964]   - Field: ‘expr’
[17:02:30.964]   - Field: ‘uuid’
[17:02:30.964]   - Field: ‘seed’
[17:02:30.964]   - Field: ‘version’
[17:02:30.964]   - Field: ‘result’
[17:02:30.964]   - Field: ‘asynchronous’
[17:02:30.964]   - Field: ‘calls’
[17:02:30.965]   - Field: ‘globals’
[17:02:30.965]   - Field: ‘stdout’
[17:02:30.965]   - Field: ‘earlySignal’
[17:02:30.965]   - Field: ‘lazy’
[17:02:30.965]   - Field: ‘state’
[17:02:30.965] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:30.965] - Launch lazy future ...
[17:02:30.966] Packages needed by the future expression (n = 0): <none>
[17:02:30.966] Packages needed by future strategies (n = 0): <none>
[17:02:30.967] {
[17:02:30.967]     {
[17:02:30.967]         {
[17:02:30.967]             ...future.startTime <- base::Sys.time()
[17:02:30.967]             {
[17:02:30.967]                 {
[17:02:30.967]                   {
[17:02:30.967]                     {
[17:02:30.967]                       base::local({
[17:02:30.967]                         has_future <- base::requireNamespace("future", 
[17:02:30.967]                           quietly = TRUE)
[17:02:30.967]                         if (has_future) {
[17:02:30.967]                           ns <- base::getNamespace("future")
[17:02:30.967]                           version <- ns[[".package"]][["version"]]
[17:02:30.967]                           if (is.null(version)) 
[17:02:30.967]                             version <- utils::packageVersion("future")
[17:02:30.967]                         }
[17:02:30.967]                         else {
[17:02:30.967]                           version <- NULL
[17:02:30.967]                         }
[17:02:30.967]                         if (!has_future || version < "1.8.0") {
[17:02:30.967]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.967]                             "", base::R.version$version.string), 
[17:02:30.967]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.967]                               "release", "version")], collapse = " "), 
[17:02:30.967]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.967]                             info)
[17:02:30.967]                           info <- base::paste(info, collapse = "; ")
[17:02:30.967]                           if (!has_future) {
[17:02:30.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.967]                               info)
[17:02:30.967]                           }
[17:02:30.967]                           else {
[17:02:30.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.967]                               info, version)
[17:02:30.967]                           }
[17:02:30.967]                           base::stop(msg)
[17:02:30.967]                         }
[17:02:30.967]                       })
[17:02:30.967]                     }
[17:02:30.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.967]                     base::options(mc.cores = 1L)
[17:02:30.967]                   }
[17:02:30.967]                   ...future.strategy.old <- future::plan("list")
[17:02:30.967]                   options(future.plan = NULL)
[17:02:30.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.967]                 }
[17:02:30.967]                 ...future.workdir <- getwd()
[17:02:30.967]             }
[17:02:30.967]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.967]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.967]         }
[17:02:30.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.967]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.967]             base::names(...future.oldOptions))
[17:02:30.967]     }
[17:02:30.967]     if (FALSE) {
[17:02:30.967]     }
[17:02:30.967]     else {
[17:02:30.967]         if (TRUE) {
[17:02:30.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.967]                 open = "w")
[17:02:30.967]         }
[17:02:30.967]         else {
[17:02:30.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.967]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.967]         }
[17:02:30.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.967]             base::sink(type = "output", split = FALSE)
[17:02:30.967]             base::close(...future.stdout)
[17:02:30.967]         }, add = TRUE)
[17:02:30.967]     }
[17:02:30.967]     ...future.frame <- base::sys.nframe()
[17:02:30.967]     ...future.conditions <- base::list()
[17:02:30.967]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.967]     if (FALSE) {
[17:02:30.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.967]     }
[17:02:30.967]     ...future.result <- base::tryCatch({
[17:02:30.967]         base::withCallingHandlers({
[17:02:30.967]             ...future.value <- base::withVisible(base::local({
[17:02:30.967]                 withCallingHandlers({
[17:02:30.967]                   NULL
[17:02:30.967]                 }, immediateCondition = function(cond) {
[17:02:30.967]                   save_rds <- function (object, pathname, ...) 
[17:02:30.967]                   {
[17:02:30.967]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:30.967]                     if (file_test("-f", pathname_tmp)) {
[17:02:30.967]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.967]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:30.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.967]                         fi_tmp[["mtime"]])
[17:02:30.967]                     }
[17:02:30.967]                     tryCatch({
[17:02:30.967]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:30.967]                     }, error = function(ex) {
[17:02:30.967]                       msg <- conditionMessage(ex)
[17:02:30.967]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.967]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:30.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.967]                         fi_tmp[["mtime"]], msg)
[17:02:30.967]                       ex$message <- msg
[17:02:30.967]                       stop(ex)
[17:02:30.967]                     })
[17:02:30.967]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:30.967]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:30.967]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:30.967]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.967]                       fi <- file.info(pathname)
[17:02:30.967]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:30.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.967]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:30.967]                         fi[["size"]], fi[["mtime"]])
[17:02:30.967]                       stop(msg)
[17:02:30.967]                     }
[17:02:30.967]                     invisible(pathname)
[17:02:30.967]                   }
[17:02:30.967]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:30.967]                     rootPath = tempdir()) 
[17:02:30.967]                   {
[17:02:30.967]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:30.967]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:30.967]                       tmpdir = path, fileext = ".rds")
[17:02:30.967]                     save_rds(obj, file)
[17:02:30.967]                   }
[17:02:30.967]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:30.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.967]                   {
[17:02:30.967]                     inherits <- base::inherits
[17:02:30.967]                     invokeRestart <- base::invokeRestart
[17:02:30.967]                     is.null <- base::is.null
[17:02:30.967]                     muffled <- FALSE
[17:02:30.967]                     if (inherits(cond, "message")) {
[17:02:30.967]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.967]                       if (muffled) 
[17:02:30.967]                         invokeRestart("muffleMessage")
[17:02:30.967]                     }
[17:02:30.967]                     else if (inherits(cond, "warning")) {
[17:02:30.967]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.967]                       if (muffled) 
[17:02:30.967]                         invokeRestart("muffleWarning")
[17:02:30.967]                     }
[17:02:30.967]                     else if (inherits(cond, "condition")) {
[17:02:30.967]                       if (!is.null(pattern)) {
[17:02:30.967]                         computeRestarts <- base::computeRestarts
[17:02:30.967]                         grepl <- base::grepl
[17:02:30.967]                         restarts <- computeRestarts(cond)
[17:02:30.967]                         for (restart in restarts) {
[17:02:30.967]                           name <- restart$name
[17:02:30.967]                           if (is.null(name)) 
[17:02:30.967]                             next
[17:02:30.967]                           if (!grepl(pattern, name)) 
[17:02:30.967]                             next
[17:02:30.967]                           invokeRestart(restart)
[17:02:30.967]                           muffled <- TRUE
[17:02:30.967]                           break
[17:02:30.967]                         }
[17:02:30.967]                       }
[17:02:30.967]                     }
[17:02:30.967]                     invisible(muffled)
[17:02:30.967]                   }
[17:02:30.967]                   muffleCondition(cond)
[17:02:30.967]                 })
[17:02:30.967]             }))
[17:02:30.967]             future::FutureResult(value = ...future.value$value, 
[17:02:30.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.967]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.967]                     ...future.globalenv.names))
[17:02:30.967]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.967]         }, condition = base::local({
[17:02:30.967]             c <- base::c
[17:02:30.967]             inherits <- base::inherits
[17:02:30.967]             invokeRestart <- base::invokeRestart
[17:02:30.967]             length <- base::length
[17:02:30.967]             list <- base::list
[17:02:30.967]             seq.int <- base::seq.int
[17:02:30.967]             signalCondition <- base::signalCondition
[17:02:30.967]             sys.calls <- base::sys.calls
[17:02:30.967]             `[[` <- base::`[[`
[17:02:30.967]             `+` <- base::`+`
[17:02:30.967]             `<<-` <- base::`<<-`
[17:02:30.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.967]                   3L)]
[17:02:30.967]             }
[17:02:30.967]             function(cond) {
[17:02:30.967]                 is_error <- inherits(cond, "error")
[17:02:30.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.967]                   NULL)
[17:02:30.967]                 if (is_error) {
[17:02:30.967]                   sessionInformation <- function() {
[17:02:30.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.967]                       search = base::search(), system = base::Sys.info())
[17:02:30.967]                   }
[17:02:30.967]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.967]                     cond$call), session = sessionInformation(), 
[17:02:30.967]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.967]                   signalCondition(cond)
[17:02:30.967]                 }
[17:02:30.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.967]                 "immediateCondition"))) {
[17:02:30.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.967]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.967]                   if (TRUE && !signal) {
[17:02:30.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.967]                     {
[17:02:30.967]                       inherits <- base::inherits
[17:02:30.967]                       invokeRestart <- base::invokeRestart
[17:02:30.967]                       is.null <- base::is.null
[17:02:30.967]                       muffled <- FALSE
[17:02:30.967]                       if (inherits(cond, "message")) {
[17:02:30.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.967]                         if (muffled) 
[17:02:30.967]                           invokeRestart("muffleMessage")
[17:02:30.967]                       }
[17:02:30.967]                       else if (inherits(cond, "warning")) {
[17:02:30.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.967]                         if (muffled) 
[17:02:30.967]                           invokeRestart("muffleWarning")
[17:02:30.967]                       }
[17:02:30.967]                       else if (inherits(cond, "condition")) {
[17:02:30.967]                         if (!is.null(pattern)) {
[17:02:30.967]                           computeRestarts <- base::computeRestarts
[17:02:30.967]                           grepl <- base::grepl
[17:02:30.967]                           restarts <- computeRestarts(cond)
[17:02:30.967]                           for (restart in restarts) {
[17:02:30.967]                             name <- restart$name
[17:02:30.967]                             if (is.null(name)) 
[17:02:30.967]                               next
[17:02:30.967]                             if (!grepl(pattern, name)) 
[17:02:30.967]                               next
[17:02:30.967]                             invokeRestart(restart)
[17:02:30.967]                             muffled <- TRUE
[17:02:30.967]                             break
[17:02:30.967]                           }
[17:02:30.967]                         }
[17:02:30.967]                       }
[17:02:30.967]                       invisible(muffled)
[17:02:30.967]                     }
[17:02:30.967]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.967]                   }
[17:02:30.967]                 }
[17:02:30.967]                 else {
[17:02:30.967]                   if (TRUE) {
[17:02:30.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.967]                     {
[17:02:30.967]                       inherits <- base::inherits
[17:02:30.967]                       invokeRestart <- base::invokeRestart
[17:02:30.967]                       is.null <- base::is.null
[17:02:30.967]                       muffled <- FALSE
[17:02:30.967]                       if (inherits(cond, "message")) {
[17:02:30.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.967]                         if (muffled) 
[17:02:30.967]                           invokeRestart("muffleMessage")
[17:02:30.967]                       }
[17:02:30.967]                       else if (inherits(cond, "warning")) {
[17:02:30.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.967]                         if (muffled) 
[17:02:30.967]                           invokeRestart("muffleWarning")
[17:02:30.967]                       }
[17:02:30.967]                       else if (inherits(cond, "condition")) {
[17:02:30.967]                         if (!is.null(pattern)) {
[17:02:30.967]                           computeRestarts <- base::computeRestarts
[17:02:30.967]                           grepl <- base::grepl
[17:02:30.967]                           restarts <- computeRestarts(cond)
[17:02:30.967]                           for (restart in restarts) {
[17:02:30.967]                             name <- restart$name
[17:02:30.967]                             if (is.null(name)) 
[17:02:30.967]                               next
[17:02:30.967]                             if (!grepl(pattern, name)) 
[17:02:30.967]                               next
[17:02:30.967]                             invokeRestart(restart)
[17:02:30.967]                             muffled <- TRUE
[17:02:30.967]                             break
[17:02:30.967]                           }
[17:02:30.967]                         }
[17:02:30.967]                       }
[17:02:30.967]                       invisible(muffled)
[17:02:30.967]                     }
[17:02:30.967]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.967]                   }
[17:02:30.967]                 }
[17:02:30.967]             }
[17:02:30.967]         }))
[17:02:30.967]     }, error = function(ex) {
[17:02:30.967]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.967]                 ...future.rng), started = ...future.startTime, 
[17:02:30.967]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.967]             version = "1.8"), class = "FutureResult")
[17:02:30.967]     }, finally = {
[17:02:30.967]         if (!identical(...future.workdir, getwd())) 
[17:02:30.967]             setwd(...future.workdir)
[17:02:30.967]         {
[17:02:30.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.967]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.967]             }
[17:02:30.967]             base::options(...future.oldOptions)
[17:02:30.967]             if (.Platform$OS.type == "windows") {
[17:02:30.967]                 old_names <- names(...future.oldEnvVars)
[17:02:30.967]                 envs <- base::Sys.getenv()
[17:02:30.967]                 names <- names(envs)
[17:02:30.967]                 common <- intersect(names, old_names)
[17:02:30.967]                 added <- setdiff(names, old_names)
[17:02:30.967]                 removed <- setdiff(old_names, names)
[17:02:30.967]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.967]                   envs[common]]
[17:02:30.967]                 NAMES <- toupper(changed)
[17:02:30.967]                 args <- list()
[17:02:30.967]                 for (kk in seq_along(NAMES)) {
[17:02:30.967]                   name <- changed[[kk]]
[17:02:30.967]                   NAME <- NAMES[[kk]]
[17:02:30.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.967]                     next
[17:02:30.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.967]                 }
[17:02:30.967]                 NAMES <- toupper(added)
[17:02:30.967]                 for (kk in seq_along(NAMES)) {
[17:02:30.967]                   name <- added[[kk]]
[17:02:30.967]                   NAME <- NAMES[[kk]]
[17:02:30.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.967]                     next
[17:02:30.967]                   args[[name]] <- ""
[17:02:30.967]                 }
[17:02:30.967]                 NAMES <- toupper(removed)
[17:02:30.967]                 for (kk in seq_along(NAMES)) {
[17:02:30.967]                   name <- removed[[kk]]
[17:02:30.967]                   NAME <- NAMES[[kk]]
[17:02:30.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.967]                     next
[17:02:30.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.967]                 }
[17:02:30.967]                 if (length(args) > 0) 
[17:02:30.967]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.967]             }
[17:02:30.967]             else {
[17:02:30.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.967]             }
[17:02:30.967]             {
[17:02:30.967]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.967]                   0L) {
[17:02:30.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.967]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.967]                   base::options(opts)
[17:02:30.967]                 }
[17:02:30.967]                 {
[17:02:30.967]                   {
[17:02:30.967]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.967]                     NULL
[17:02:30.967]                   }
[17:02:30.967]                   options(future.plan = NULL)
[17:02:30.967]                   if (is.na(NA_character_)) 
[17:02:30.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.967]                     .init = FALSE)
[17:02:30.967]                 }
[17:02:30.967]             }
[17:02:30.967]         }
[17:02:30.967]     })
[17:02:30.967]     if (TRUE) {
[17:02:30.967]         base::sink(type = "output", split = FALSE)
[17:02:30.967]         if (TRUE) {
[17:02:30.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.967]         }
[17:02:30.967]         else {
[17:02:30.967]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.967]         }
[17:02:30.967]         base::close(...future.stdout)
[17:02:30.967]         ...future.stdout <- NULL
[17:02:30.967]     }
[17:02:30.967]     ...future.result$conditions <- ...future.conditions
[17:02:30.967]     ...future.result$finished <- base::Sys.time()
[17:02:30.967]     ...future.result
[17:02:30.967] }
[17:02:30.970] requestCore(): workers = 2
[17:02:30.973] MulticoreFuture started
[17:02:30.974] - Launch lazy future ... done
[17:02:30.974] run() for ‘MulticoreFuture’ ... done
[17:02:30.974] plan(): Setting new future strategy stack:
[17:02:30.975] getGlobalsAndPackages() ...
[17:02:30.975] Searching for globals...
[17:02:30.975] List of future strategies:
[17:02:30.975] 1. sequential:
[17:02:30.975]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:30.975]    - tweaked: FALSE
[17:02:30.975]    - call: NULL
[17:02:30.976] plan(): nbrOfWorkers() = 1
[17:02:30.976] - globals found: [1] ‘{’
[17:02:30.976] Searching for globals ... DONE
[17:02:30.977] Resolving globals: FALSE
[17:02:30.977] 
[17:02:30.977] 
[17:02:30.977] getGlobalsAndPackages() ... DONE
[17:02:30.978] run() for ‘Future’ ...
[17:02:30.978] plan(): Setting new future strategy stack:
[17:02:30.978] - state: ‘created’
[17:02:30.978] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:30.978] List of future strategies:
[17:02:30.978] 1. multicore:
[17:02:30.978]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:30.978]    - tweaked: FALSE
[17:02:30.978]    - call: plan(strategy)
[17:02:30.983] plan(): nbrOfWorkers() = 2
[17:02:30.983] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:30.983] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:30.984]   - Field: ‘label’
[17:02:30.984]   - Field: ‘local’
[17:02:30.984]   - Field: ‘owner’
[17:02:30.984]   - Field: ‘envir’
[17:02:30.984]   - Field: ‘workers’
[17:02:30.984]   - Field: ‘packages’
[17:02:30.985]   - Field: ‘gc’
[17:02:30.985]   - Field: ‘job’
[17:02:30.985]   - Field: ‘conditions’
[17:02:30.985]   - Field: ‘expr’
[17:02:30.985]   - Field: ‘uuid’
[17:02:30.985]   - Field: ‘seed’
[17:02:30.985]   - Field: ‘version’
[17:02:30.985]   - Field: ‘result’
[17:02:30.986]   - Field: ‘asynchronous’
[17:02:30.986]   - Field: ‘calls’
[17:02:30.986]   - Field: ‘globals’
[17:02:30.986]   - Field: ‘stdout’
[17:02:30.986]   - Field: ‘earlySignal’
[17:02:30.986]   - Field: ‘lazy’
[17:02:30.986]   - Field: ‘state’
[17:02:30.987] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:30.987] - Launch lazy future ...
[17:02:30.987] Packages needed by the future expression (n = 0): <none>
[17:02:30.987] Packages needed by future strategies (n = 0): <none>
[17:02:30.988] {
[17:02:30.988]     {
[17:02:30.988]         {
[17:02:30.988]             ...future.startTime <- base::Sys.time()
[17:02:30.988]             {
[17:02:30.988]                 {
[17:02:30.988]                   {
[17:02:30.988]                     {
[17:02:30.988]                       base::local({
[17:02:30.988]                         has_future <- base::requireNamespace("future", 
[17:02:30.988]                           quietly = TRUE)
[17:02:30.988]                         if (has_future) {
[17:02:30.988]                           ns <- base::getNamespace("future")
[17:02:30.988]                           version <- ns[[".package"]][["version"]]
[17:02:30.988]                           if (is.null(version)) 
[17:02:30.988]                             version <- utils::packageVersion("future")
[17:02:30.988]                         }
[17:02:30.988]                         else {
[17:02:30.988]                           version <- NULL
[17:02:30.988]                         }
[17:02:30.988]                         if (!has_future || version < "1.8.0") {
[17:02:30.988]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:30.988]                             "", base::R.version$version.string), 
[17:02:30.988]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:30.988]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:30.988]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:30.988]                               "release", "version")], collapse = " "), 
[17:02:30.988]                             hostname = base::Sys.info()[["nodename"]])
[17:02:30.988]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:30.988]                             info)
[17:02:30.988]                           info <- base::paste(info, collapse = "; ")
[17:02:30.988]                           if (!has_future) {
[17:02:30.988]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:30.988]                               info)
[17:02:30.988]                           }
[17:02:30.988]                           else {
[17:02:30.988]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:30.988]                               info, version)
[17:02:30.988]                           }
[17:02:30.988]                           base::stop(msg)
[17:02:30.988]                         }
[17:02:30.988]                       })
[17:02:30.988]                     }
[17:02:30.988]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:30.988]                     base::options(mc.cores = 1L)
[17:02:30.988]                   }
[17:02:30.988]                   ...future.strategy.old <- future::plan("list")
[17:02:30.988]                   options(future.plan = NULL)
[17:02:30.988]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.988]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:30.988]                 }
[17:02:30.988]                 ...future.workdir <- getwd()
[17:02:30.988]             }
[17:02:30.988]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:30.988]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:30.988]         }
[17:02:30.988]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:30.988]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:30.988]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:30.988]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:30.988]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:30.988]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:30.988]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:30.988]             base::names(...future.oldOptions))
[17:02:30.988]     }
[17:02:30.988]     if (FALSE) {
[17:02:30.988]     }
[17:02:30.988]     else {
[17:02:30.988]         if (TRUE) {
[17:02:30.988]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:30.988]                 open = "w")
[17:02:30.988]         }
[17:02:30.988]         else {
[17:02:30.988]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:30.988]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:30.988]         }
[17:02:30.988]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:30.988]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:30.988]             base::sink(type = "output", split = FALSE)
[17:02:30.988]             base::close(...future.stdout)
[17:02:30.988]         }, add = TRUE)
[17:02:30.988]     }
[17:02:30.988]     ...future.frame <- base::sys.nframe()
[17:02:30.988]     ...future.conditions <- base::list()
[17:02:30.988]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:30.988]     if (FALSE) {
[17:02:30.988]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:30.988]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:30.988]     }
[17:02:30.988]     ...future.result <- base::tryCatch({
[17:02:30.988]         base::withCallingHandlers({
[17:02:30.988]             ...future.value <- base::withVisible(base::local({
[17:02:30.988]                 withCallingHandlers({
[17:02:30.988]                   {
[17:02:30.988]                     4
[17:02:30.988]                   }
[17:02:30.988]                 }, immediateCondition = function(cond) {
[17:02:30.988]                   save_rds <- function (object, pathname, ...) 
[17:02:30.988]                   {
[17:02:30.988]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:30.988]                     if (file_test("-f", pathname_tmp)) {
[17:02:30.988]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.988]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:30.988]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.988]                         fi_tmp[["mtime"]])
[17:02:30.988]                     }
[17:02:30.988]                     tryCatch({
[17:02:30.988]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:30.988]                     }, error = function(ex) {
[17:02:30.988]                       msg <- conditionMessage(ex)
[17:02:30.988]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.988]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:30.988]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.988]                         fi_tmp[["mtime"]], msg)
[17:02:30.988]                       ex$message <- msg
[17:02:30.988]                       stop(ex)
[17:02:30.988]                     })
[17:02:30.988]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:30.988]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:30.988]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:30.988]                       fi_tmp <- file.info(pathname_tmp)
[17:02:30.988]                       fi <- file.info(pathname)
[17:02:30.988]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:30.988]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:30.988]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:30.988]                         fi[["size"]], fi[["mtime"]])
[17:02:30.988]                       stop(msg)
[17:02:30.988]                     }
[17:02:30.988]                     invisible(pathname)
[17:02:30.988]                   }
[17:02:30.988]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:30.988]                     rootPath = tempdir()) 
[17:02:30.988]                   {
[17:02:30.988]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:30.988]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:30.988]                       tmpdir = path, fileext = ".rds")
[17:02:30.988]                     save_rds(obj, file)
[17:02:30.988]                   }
[17:02:30.988]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:30.988]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.988]                   {
[17:02:30.988]                     inherits <- base::inherits
[17:02:30.988]                     invokeRestart <- base::invokeRestart
[17:02:30.988]                     is.null <- base::is.null
[17:02:30.988]                     muffled <- FALSE
[17:02:30.988]                     if (inherits(cond, "message")) {
[17:02:30.988]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:30.988]                       if (muffled) 
[17:02:30.988]                         invokeRestart("muffleMessage")
[17:02:30.988]                     }
[17:02:30.988]                     else if (inherits(cond, "warning")) {
[17:02:30.988]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:30.988]                       if (muffled) 
[17:02:30.988]                         invokeRestart("muffleWarning")
[17:02:30.988]                     }
[17:02:30.988]                     else if (inherits(cond, "condition")) {
[17:02:30.988]                       if (!is.null(pattern)) {
[17:02:30.988]                         computeRestarts <- base::computeRestarts
[17:02:30.988]                         grepl <- base::grepl
[17:02:30.988]                         restarts <- computeRestarts(cond)
[17:02:30.988]                         for (restart in restarts) {
[17:02:30.988]                           name <- restart$name
[17:02:30.988]                           if (is.null(name)) 
[17:02:30.988]                             next
[17:02:30.988]                           if (!grepl(pattern, name)) 
[17:02:30.988]                             next
[17:02:30.988]                           invokeRestart(restart)
[17:02:30.988]                           muffled <- TRUE
[17:02:30.988]                           break
[17:02:30.988]                         }
[17:02:30.988]                       }
[17:02:30.988]                     }
[17:02:30.988]                     invisible(muffled)
[17:02:30.988]                   }
[17:02:30.988]                   muffleCondition(cond)
[17:02:30.988]                 })
[17:02:30.988]             }))
[17:02:30.988]             future::FutureResult(value = ...future.value$value, 
[17:02:30.988]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.988]                   ...future.rng), globalenv = if (FALSE) 
[17:02:30.988]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:30.988]                     ...future.globalenv.names))
[17:02:30.988]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:30.988]         }, condition = base::local({
[17:02:30.988]             c <- base::c
[17:02:30.988]             inherits <- base::inherits
[17:02:30.988]             invokeRestart <- base::invokeRestart
[17:02:30.988]             length <- base::length
[17:02:30.988]             list <- base::list
[17:02:30.988]             seq.int <- base::seq.int
[17:02:30.988]             signalCondition <- base::signalCondition
[17:02:30.988]             sys.calls <- base::sys.calls
[17:02:30.988]             `[[` <- base::`[[`
[17:02:30.988]             `+` <- base::`+`
[17:02:30.988]             `<<-` <- base::`<<-`
[17:02:30.988]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:30.988]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:30.988]                   3L)]
[17:02:30.988]             }
[17:02:30.988]             function(cond) {
[17:02:30.988]                 is_error <- inherits(cond, "error")
[17:02:30.988]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:30.988]                   NULL)
[17:02:30.988]                 if (is_error) {
[17:02:30.988]                   sessionInformation <- function() {
[17:02:30.988]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:30.988]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:30.988]                       search = base::search(), system = base::Sys.info())
[17:02:30.988]                   }
[17:02:30.988]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.988]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:30.988]                     cond$call), session = sessionInformation(), 
[17:02:30.988]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:30.988]                   signalCondition(cond)
[17:02:30.988]                 }
[17:02:30.988]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:30.988]                 "immediateCondition"))) {
[17:02:30.988]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:30.988]                   ...future.conditions[[length(...future.conditions) + 
[17:02:30.988]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:30.988]                   if (TRUE && !signal) {
[17:02:30.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.988]                     {
[17:02:30.988]                       inherits <- base::inherits
[17:02:30.988]                       invokeRestart <- base::invokeRestart
[17:02:30.988]                       is.null <- base::is.null
[17:02:30.988]                       muffled <- FALSE
[17:02:30.988]                       if (inherits(cond, "message")) {
[17:02:30.988]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.988]                         if (muffled) 
[17:02:30.988]                           invokeRestart("muffleMessage")
[17:02:30.988]                       }
[17:02:30.988]                       else if (inherits(cond, "warning")) {
[17:02:30.988]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.988]                         if (muffled) 
[17:02:30.988]                           invokeRestart("muffleWarning")
[17:02:30.988]                       }
[17:02:30.988]                       else if (inherits(cond, "condition")) {
[17:02:30.988]                         if (!is.null(pattern)) {
[17:02:30.988]                           computeRestarts <- base::computeRestarts
[17:02:30.988]                           grepl <- base::grepl
[17:02:30.988]                           restarts <- computeRestarts(cond)
[17:02:30.988]                           for (restart in restarts) {
[17:02:30.988]                             name <- restart$name
[17:02:30.988]                             if (is.null(name)) 
[17:02:30.988]                               next
[17:02:30.988]                             if (!grepl(pattern, name)) 
[17:02:30.988]                               next
[17:02:30.988]                             invokeRestart(restart)
[17:02:30.988]                             muffled <- TRUE
[17:02:30.988]                             break
[17:02:30.988]                           }
[17:02:30.988]                         }
[17:02:30.988]                       }
[17:02:30.988]                       invisible(muffled)
[17:02:30.988]                     }
[17:02:30.988]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.988]                   }
[17:02:30.988]                 }
[17:02:30.988]                 else {
[17:02:30.988]                   if (TRUE) {
[17:02:30.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:30.988]                     {
[17:02:30.988]                       inherits <- base::inherits
[17:02:30.988]                       invokeRestart <- base::invokeRestart
[17:02:30.988]                       is.null <- base::is.null
[17:02:30.988]                       muffled <- FALSE
[17:02:30.988]                       if (inherits(cond, "message")) {
[17:02:30.988]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:30.988]                         if (muffled) 
[17:02:30.988]                           invokeRestart("muffleMessage")
[17:02:30.988]                       }
[17:02:30.988]                       else if (inherits(cond, "warning")) {
[17:02:30.988]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:30.988]                         if (muffled) 
[17:02:30.988]                           invokeRestart("muffleWarning")
[17:02:30.988]                       }
[17:02:30.988]                       else if (inherits(cond, "condition")) {
[17:02:30.988]                         if (!is.null(pattern)) {
[17:02:30.988]                           computeRestarts <- base::computeRestarts
[17:02:30.988]                           grepl <- base::grepl
[17:02:30.988]                           restarts <- computeRestarts(cond)
[17:02:30.988]                           for (restart in restarts) {
[17:02:30.988]                             name <- restart$name
[17:02:30.988]                             if (is.null(name)) 
[17:02:30.988]                               next
[17:02:30.988]                             if (!grepl(pattern, name)) 
[17:02:30.988]                               next
[17:02:30.988]                             invokeRestart(restart)
[17:02:30.988]                             muffled <- TRUE
[17:02:30.988]                             break
[17:02:30.988]                           }
[17:02:30.988]                         }
[17:02:30.988]                       }
[17:02:30.988]                       invisible(muffled)
[17:02:30.988]                     }
[17:02:30.988]                     muffleCondition(cond, pattern = "^muffle")
[17:02:30.988]                   }
[17:02:30.988]                 }
[17:02:30.988]             }
[17:02:30.988]         }))
[17:02:30.988]     }, error = function(ex) {
[17:02:30.988]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:30.988]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:30.988]                 ...future.rng), started = ...future.startTime, 
[17:02:30.988]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:30.988]             version = "1.8"), class = "FutureResult")
[17:02:30.988]     }, finally = {
[17:02:30.988]         if (!identical(...future.workdir, getwd())) 
[17:02:30.988]             setwd(...future.workdir)
[17:02:30.988]         {
[17:02:30.988]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:30.988]                 ...future.oldOptions$nwarnings <- NULL
[17:02:30.988]             }
[17:02:30.988]             base::options(...future.oldOptions)
[17:02:30.988]             if (.Platform$OS.type == "windows") {
[17:02:30.988]                 old_names <- names(...future.oldEnvVars)
[17:02:30.988]                 envs <- base::Sys.getenv()
[17:02:30.988]                 names <- names(envs)
[17:02:30.988]                 common <- intersect(names, old_names)
[17:02:30.988]                 added <- setdiff(names, old_names)
[17:02:30.988]                 removed <- setdiff(old_names, names)
[17:02:30.988]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:30.988]                   envs[common]]
[17:02:30.988]                 NAMES <- toupper(changed)
[17:02:30.988]                 args <- list()
[17:02:30.988]                 for (kk in seq_along(NAMES)) {
[17:02:30.988]                   name <- changed[[kk]]
[17:02:30.988]                   NAME <- NAMES[[kk]]
[17:02:30.988]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.988]                     next
[17:02:30.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.988]                 }
[17:02:30.988]                 NAMES <- toupper(added)
[17:02:30.988]                 for (kk in seq_along(NAMES)) {
[17:02:30.988]                   name <- added[[kk]]
[17:02:30.988]                   NAME <- NAMES[[kk]]
[17:02:30.988]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.988]                     next
[17:02:30.988]                   args[[name]] <- ""
[17:02:30.988]                 }
[17:02:30.988]                 NAMES <- toupper(removed)
[17:02:30.988]                 for (kk in seq_along(NAMES)) {
[17:02:30.988]                   name <- removed[[kk]]
[17:02:30.988]                   NAME <- NAMES[[kk]]
[17:02:30.988]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:30.988]                     next
[17:02:30.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:30.988]                 }
[17:02:30.988]                 if (length(args) > 0) 
[17:02:30.988]                   base::do.call(base::Sys.setenv, args = args)
[17:02:30.988]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:30.988]             }
[17:02:30.988]             else {
[17:02:30.988]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:30.988]             }
[17:02:30.988]             {
[17:02:30.988]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:30.988]                   0L) {
[17:02:30.988]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:30.988]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:30.988]                   base::options(opts)
[17:02:30.988]                 }
[17:02:30.988]                 {
[17:02:30.988]                   {
[17:02:30.988]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:30.988]                     NULL
[17:02:30.988]                   }
[17:02:30.988]                   options(future.plan = NULL)
[17:02:30.988]                   if (is.na(NA_character_)) 
[17:02:30.988]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:30.988]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:30.988]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:30.988]                     .init = FALSE)
[17:02:30.988]                 }
[17:02:30.988]             }
[17:02:30.988]         }
[17:02:30.988]     })
[17:02:30.988]     if (TRUE) {
[17:02:30.988]         base::sink(type = "output", split = FALSE)
[17:02:30.988]         if (TRUE) {
[17:02:30.988]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:30.988]         }
[17:02:30.988]         else {
[17:02:30.988]             ...future.result["stdout"] <- base::list(NULL)
[17:02:30.988]         }
[17:02:30.988]         base::close(...future.stdout)
[17:02:30.988]         ...future.stdout <- NULL
[17:02:30.988]     }
[17:02:30.988]     ...future.result$conditions <- ...future.conditions
[17:02:30.988]     ...future.result$finished <- base::Sys.time()
[17:02:30.988]     ...future.result
[17:02:30.988] }
[17:02:30.991] requestCore(): workers = 2
[17:02:30.992] Poll #1 (0): usedCores() = 2, workers = 2
[17:02:31.002] result() for MulticoreFuture ...
[17:02:31.003] result() for MulticoreFuture ...
[17:02:31.004] result() for MulticoreFuture ... done
[17:02:31.004] result() for MulticoreFuture ... done
[17:02:31.004] result() for MulticoreFuture ...
[17:02:31.004] result() for MulticoreFuture ... done
[17:02:31.007] MulticoreFuture started
[17:02:31.007] - Launch lazy future ... done
[17:02:31.007] run() for ‘MulticoreFuture’ ... done
[17:02:31.008] plan(): Setting new future strategy stack:
<environment: 0x55c74a51be50> 
[17:02:31.008] List of future strategies:
[17:02:31.008] 1. sequential:
[17:02:31.008]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:31.008]    - tweaked: FALSE
[17:02:31.008]    - call: NULL
[17:02:31.010] plan(): nbrOfWorkers() = 1
<environment: 0x55c74b197698> 
[17:02:31.012] plan(): Setting new future strategy stack:
[17:02:31.012] List of future strategies:
[17:02:31.012] 1. multicore:
[17:02:31.012]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:31.012]    - tweaked: FALSE
[17:02:31.012]    - call: plan(strategy)
[17:02:31.017] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:31.019] resolve() on environment ...
[17:02:31.020]  recursive: 0
[17:02:31.020]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:31.020] signalConditionsASAP(numeric, pos=1) ...
[17:02:31.021] - nx: 4
[17:02:31.021] - relay: TRUE
[17:02:31.021] - stdout: TRUE
[17:02:31.021] - signal: TRUE
[17:02:31.021] - resignal: FALSE
[17:02:31.021] - force: TRUE
[17:02:31.021] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.022] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.022]  - until=2
[17:02:31.022]  - relaying element #2
[17:02:31.022] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:31.022] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.022] signalConditionsASAP(NULL, pos=1) ... done
[17:02:31.022]  length: 3 (resolved future 1)
[17:02:31.023] Future #2
[17:02:31.023] result() for MulticoreFuture ...
[17:02:31.023] result() for MulticoreFuture ... done
[17:02:31.023] result() for MulticoreFuture ...
[17:02:31.023] result() for MulticoreFuture ... done
[17:02:31.023] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:31.024] - nx: 4
[17:02:31.024] - relay: TRUE
[17:02:31.024] - stdout: TRUE
[17:02:31.024] - signal: TRUE
[17:02:31.024] - resignal: FALSE
[17:02:31.024] - force: TRUE
[17:02:31.024] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:31.024] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.024]  - until=2
[17:02:31.025]  - relaying element #2
[17:02:31.025] result() for MulticoreFuture ...
[17:02:31.025] result() for MulticoreFuture ... done
[17:02:31.025] result() for MulticoreFuture ...
[17:02:31.025] result() for MulticoreFuture ... done
[17:02:31.025] result() for MulticoreFuture ...
[17:02:31.025] result() for MulticoreFuture ... done
[17:02:31.026] result() for MulticoreFuture ...
[17:02:31.026] result() for MulticoreFuture ... done
[17:02:31.026] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:31.026] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:31.026] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:31.026]  length: 2 (resolved future 2)
[17:02:31.026] Future #3
[17:02:31.027] result() for MulticoreFuture ...
[17:02:31.027] result() for MulticoreFuture ...
[17:02:31.028] result() for MulticoreFuture ... done
[17:02:31.028] result() for MulticoreFuture ... done
[17:02:31.028] result() for MulticoreFuture ...
[17:02:31.028] result() for MulticoreFuture ... done
[17:02:31.028] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:31.028] - nx: 4
[17:02:31.028] - relay: TRUE
[17:02:31.029] - stdout: TRUE
[17:02:31.029] - signal: TRUE
[17:02:31.029] - resignal: FALSE
[17:02:31.029] - force: TRUE
[17:02:31.029] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:31.029] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:31.029]  - until=3
[17:02:31.029]  - relaying element #3
[17:02:31.029] result() for MulticoreFuture ...
[17:02:31.030] result() for MulticoreFuture ... done
[17:02:31.030] result() for MulticoreFuture ...
[17:02:31.030] result() for MulticoreFuture ... done
[17:02:31.030] result() for MulticoreFuture ...
[17:02:31.030] result() for MulticoreFuture ... done
[17:02:31.030] result() for MulticoreFuture ...
[17:02:31.030] result() for MulticoreFuture ... done
[17:02:31.031] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:31.031] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:31.031] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:31.031]  length: 1 (resolved future 3)
[17:02:31.031] Future #4
[17:02:31.031] result() for MulticoreFuture ...
[17:02:31.032] result() for MulticoreFuture ...
[17:02:31.032] result() for MulticoreFuture ... done
[17:02:31.032] result() for MulticoreFuture ... done
[17:02:31.033] result() for MulticoreFuture ...
[17:02:31.033] result() for MulticoreFuture ... done
[17:02:31.033] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:02:31.033] - nx: 4
[17:02:31.033] - relay: TRUE
[17:02:31.033] - stdout: TRUE
[17:02:31.034] - signal: TRUE
[17:02:31.034] - resignal: FALSE
[17:02:31.034] - force: TRUE
[17:02:31.034] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:31.034] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:31.034]  - until=4
[17:02:31.035]  - relaying element #4
[17:02:31.035] result() for MulticoreFuture ...
[17:02:31.035] result() for MulticoreFuture ... done
[17:02:31.035] result() for MulticoreFuture ...
[17:02:31.035] result() for MulticoreFuture ... done
[17:02:31.035] result() for MulticoreFuture ...
[17:02:31.036] result() for MulticoreFuture ... done
[17:02:31.036] result() for MulticoreFuture ...
[17:02:31.036] result() for MulticoreFuture ... done
[17:02:31.036] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.036] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:31.036] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:02:31.036]  length: 0 (resolved future 4)
[17:02:31.036] Relaying remaining futures
[17:02:31.036] signalConditionsASAP(NULL, pos=0) ...
[17:02:31.036] - nx: 4
[17:02:31.037] - relay: TRUE
[17:02:31.037] - stdout: TRUE
[17:02:31.037] - signal: TRUE
[17:02:31.037] - resignal: FALSE
[17:02:31.037] - force: TRUE
[17:02:31.037] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.037] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:31.037] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.037] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:31.037] signalConditionsASAP(NULL, pos=0) ... done
[17:02:31.038] resolve() on environment ... DONE
[17:02:31.038] result() for MulticoreFuture ...
[17:02:31.038] result() for MulticoreFuture ... done
[17:02:31.038] result() for MulticoreFuture ...
[17:02:31.038] result() for MulticoreFuture ... done
[17:02:31.038] result() for MulticoreFuture ...
[17:02:31.038] result() for MulticoreFuture ... done
[17:02:31.038] result() for MulticoreFuture ...
[17:02:31.038] result() for MulticoreFuture ... done
[17:02:31.039] result() for MulticoreFuture ...
[17:02:31.039] result() for MulticoreFuture ... done
[17:02:31.039] result() for MulticoreFuture ...
[17:02:31.039] result() for MulticoreFuture ... done
<environment: 0x55c74b261408> 
Dimensions: c(2, 1, 3, 1)
[17:02:31.039] getGlobalsAndPackages() ...
[17:02:31.040] Searching for globals...
[17:02:31.044] 
[17:02:31.044] Searching for globals ... DONE
[17:02:31.044] - globals: [0] <none>
[17:02:31.044] getGlobalsAndPackages() ... DONE
[17:02:31.044] run() for ‘Future’ ...
[17:02:31.044] - state: ‘created’
[17:02:31.045] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.049] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.049] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:31.049]   - Field: ‘label’
[17:02:31.049]   - Field: ‘local’
[17:02:31.049]   - Field: ‘owner’
[17:02:31.049]   - Field: ‘envir’
[17:02:31.049]   - Field: ‘workers’
[17:02:31.049]   - Field: ‘packages’
[17:02:31.050]   - Field: ‘gc’
[17:02:31.050]   - Field: ‘job’
[17:02:31.050]   - Field: ‘conditions’
[17:02:31.050]   - Field: ‘expr’
[17:02:31.050]   - Field: ‘uuid’
[17:02:31.050]   - Field: ‘seed’
[17:02:31.050]   - Field: ‘version’
[17:02:31.050]   - Field: ‘result’
[17:02:31.050]   - Field: ‘asynchronous’
[17:02:31.051]   - Field: ‘calls’
[17:02:31.051]   - Field: ‘globals’
[17:02:31.051]   - Field: ‘stdout’
[17:02:31.051]   - Field: ‘earlySignal’
[17:02:31.051]   - Field: ‘lazy’
[17:02:31.051]   - Field: ‘state’
[17:02:31.051] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:31.051] - Launch lazy future ...
[17:02:31.052] Packages needed by the future expression (n = 0): <none>
[17:02:31.052] Packages needed by future strategies (n = 0): <none>
[17:02:31.052] {
[17:02:31.052]     {
[17:02:31.052]         {
[17:02:31.052]             ...future.startTime <- base::Sys.time()
[17:02:31.052]             {
[17:02:31.052]                 {
[17:02:31.052]                   {
[17:02:31.052]                     {
[17:02:31.052]                       base::local({
[17:02:31.052]                         has_future <- base::requireNamespace("future", 
[17:02:31.052]                           quietly = TRUE)
[17:02:31.052]                         if (has_future) {
[17:02:31.052]                           ns <- base::getNamespace("future")
[17:02:31.052]                           version <- ns[[".package"]][["version"]]
[17:02:31.052]                           if (is.null(version)) 
[17:02:31.052]                             version <- utils::packageVersion("future")
[17:02:31.052]                         }
[17:02:31.052]                         else {
[17:02:31.052]                           version <- NULL
[17:02:31.052]                         }
[17:02:31.052]                         if (!has_future || version < "1.8.0") {
[17:02:31.052]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.052]                             "", base::R.version$version.string), 
[17:02:31.052]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.052]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.052]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.052]                               "release", "version")], collapse = " "), 
[17:02:31.052]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.052]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.052]                             info)
[17:02:31.052]                           info <- base::paste(info, collapse = "; ")
[17:02:31.052]                           if (!has_future) {
[17:02:31.052]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.052]                               info)
[17:02:31.052]                           }
[17:02:31.052]                           else {
[17:02:31.052]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.052]                               info, version)
[17:02:31.052]                           }
[17:02:31.052]                           base::stop(msg)
[17:02:31.052]                         }
[17:02:31.052]                       })
[17:02:31.052]                     }
[17:02:31.052]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.052]                     base::options(mc.cores = 1L)
[17:02:31.052]                   }
[17:02:31.052]                   ...future.strategy.old <- future::plan("list")
[17:02:31.052]                   options(future.plan = NULL)
[17:02:31.052]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.052]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.052]                 }
[17:02:31.052]                 ...future.workdir <- getwd()
[17:02:31.052]             }
[17:02:31.052]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.052]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.052]         }
[17:02:31.052]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.052]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.052]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.052]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.052]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.052]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.052]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.052]             base::names(...future.oldOptions))
[17:02:31.052]     }
[17:02:31.052]     if (FALSE) {
[17:02:31.052]     }
[17:02:31.052]     else {
[17:02:31.052]         if (TRUE) {
[17:02:31.052]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.052]                 open = "w")
[17:02:31.052]         }
[17:02:31.052]         else {
[17:02:31.052]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.052]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.052]         }
[17:02:31.052]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.052]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.052]             base::sink(type = "output", split = FALSE)
[17:02:31.052]             base::close(...future.stdout)
[17:02:31.052]         }, add = TRUE)
[17:02:31.052]     }
[17:02:31.052]     ...future.frame <- base::sys.nframe()
[17:02:31.052]     ...future.conditions <- base::list()
[17:02:31.052]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.052]     if (FALSE) {
[17:02:31.052]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.052]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.052]     }
[17:02:31.052]     ...future.result <- base::tryCatch({
[17:02:31.052]         base::withCallingHandlers({
[17:02:31.052]             ...future.value <- base::withVisible(base::local({
[17:02:31.052]                 withCallingHandlers({
[17:02:31.052]                   2
[17:02:31.052]                 }, immediateCondition = function(cond) {
[17:02:31.052]                   save_rds <- function (object, pathname, ...) 
[17:02:31.052]                   {
[17:02:31.052]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:31.052]                     if (file_test("-f", pathname_tmp)) {
[17:02:31.052]                       fi_tmp <- file.info(pathname_tmp)
[17:02:31.052]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:31.052]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:31.052]                         fi_tmp[["mtime"]])
[17:02:31.052]                     }
[17:02:31.052]                     tryCatch({
[17:02:31.052]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:31.052]                     }, error = function(ex) {
[17:02:31.052]                       msg <- conditionMessage(ex)
[17:02:31.052]                       fi_tmp <- file.info(pathname_tmp)
[17:02:31.052]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:31.052]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:31.052]                         fi_tmp[["mtime"]], msg)
[17:02:31.052]                       ex$message <- msg
[17:02:31.052]                       stop(ex)
[17:02:31.052]                     })
[17:02:31.052]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:31.052]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:31.052]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:31.052]                       fi_tmp <- file.info(pathname_tmp)
[17:02:31.052]                       fi <- file.info(pathname)
[17:02:31.052]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:31.052]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:31.052]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:31.052]                         fi[["size"]], fi[["mtime"]])
[17:02:31.052]                       stop(msg)
[17:02:31.052]                     }
[17:02:31.052]                     invisible(pathname)
[17:02:31.052]                   }
[17:02:31.052]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:31.052]                     rootPath = tempdir()) 
[17:02:31.052]                   {
[17:02:31.052]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:31.052]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:31.052]                       tmpdir = path, fileext = ".rds")
[17:02:31.052]                     save_rds(obj, file)
[17:02:31.052]                   }
[17:02:31.052]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:31.052]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.052]                   {
[17:02:31.052]                     inherits <- base::inherits
[17:02:31.052]                     invokeRestart <- base::invokeRestart
[17:02:31.052]                     is.null <- base::is.null
[17:02:31.052]                     muffled <- FALSE
[17:02:31.052]                     if (inherits(cond, "message")) {
[17:02:31.052]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.052]                       if (muffled) 
[17:02:31.052]                         invokeRestart("muffleMessage")
[17:02:31.052]                     }
[17:02:31.052]                     else if (inherits(cond, "warning")) {
[17:02:31.052]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.052]                       if (muffled) 
[17:02:31.052]                         invokeRestart("muffleWarning")
[17:02:31.052]                     }
[17:02:31.052]                     else if (inherits(cond, "condition")) {
[17:02:31.052]                       if (!is.null(pattern)) {
[17:02:31.052]                         computeRestarts <- base::computeRestarts
[17:02:31.052]                         grepl <- base::grepl
[17:02:31.052]                         restarts <- computeRestarts(cond)
[17:02:31.052]                         for (restart in restarts) {
[17:02:31.052]                           name <- restart$name
[17:02:31.052]                           if (is.null(name)) 
[17:02:31.052]                             next
[17:02:31.052]                           if (!grepl(pattern, name)) 
[17:02:31.052]                             next
[17:02:31.052]                           invokeRestart(restart)
[17:02:31.052]                           muffled <- TRUE
[17:02:31.052]                           break
[17:02:31.052]                         }
[17:02:31.052]                       }
[17:02:31.052]                     }
[17:02:31.052]                     invisible(muffled)
[17:02:31.052]                   }
[17:02:31.052]                   muffleCondition(cond)
[17:02:31.052]                 })
[17:02:31.052]             }))
[17:02:31.052]             future::FutureResult(value = ...future.value$value, 
[17:02:31.052]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.052]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.052]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.052]                     ...future.globalenv.names))
[17:02:31.052]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.052]         }, condition = base::local({
[17:02:31.052]             c <- base::c
[17:02:31.052]             inherits <- base::inherits
[17:02:31.052]             invokeRestart <- base::invokeRestart
[17:02:31.052]             length <- base::length
[17:02:31.052]             list <- base::list
[17:02:31.052]             seq.int <- base::seq.int
[17:02:31.052]             signalCondition <- base::signalCondition
[17:02:31.052]             sys.calls <- base::sys.calls
[17:02:31.052]             `[[` <- base::`[[`
[17:02:31.052]             `+` <- base::`+`
[17:02:31.052]             `<<-` <- base::`<<-`
[17:02:31.052]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.052]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.052]                   3L)]
[17:02:31.052]             }
[17:02:31.052]             function(cond) {
[17:02:31.052]                 is_error <- inherits(cond, "error")
[17:02:31.052]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.052]                   NULL)
[17:02:31.052]                 if (is_error) {
[17:02:31.052]                   sessionInformation <- function() {
[17:02:31.052]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.052]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.052]                       search = base::search(), system = base::Sys.info())
[17:02:31.052]                   }
[17:02:31.052]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.052]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.052]                     cond$call), session = sessionInformation(), 
[17:02:31.052]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.052]                   signalCondition(cond)
[17:02:31.052]                 }
[17:02:31.052]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.052]                 "immediateCondition"))) {
[17:02:31.052]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.052]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.052]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.052]                   if (TRUE && !signal) {
[17:02:31.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.052]                     {
[17:02:31.052]                       inherits <- base::inherits
[17:02:31.052]                       invokeRestart <- base::invokeRestart
[17:02:31.052]                       is.null <- base::is.null
[17:02:31.052]                       muffled <- FALSE
[17:02:31.052]                       if (inherits(cond, "message")) {
[17:02:31.052]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.052]                         if (muffled) 
[17:02:31.052]                           invokeRestart("muffleMessage")
[17:02:31.052]                       }
[17:02:31.052]                       else if (inherits(cond, "warning")) {
[17:02:31.052]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.052]                         if (muffled) 
[17:02:31.052]                           invokeRestart("muffleWarning")
[17:02:31.052]                       }
[17:02:31.052]                       else if (inherits(cond, "condition")) {
[17:02:31.052]                         if (!is.null(pattern)) {
[17:02:31.052]                           computeRestarts <- base::computeRestarts
[17:02:31.052]                           grepl <- base::grepl
[17:02:31.052]                           restarts <- computeRestarts(cond)
[17:02:31.052]                           for (restart in restarts) {
[17:02:31.052]                             name <- restart$name
[17:02:31.052]                             if (is.null(name)) 
[17:02:31.052]                               next
[17:02:31.052]                             if (!grepl(pattern, name)) 
[17:02:31.052]                               next
[17:02:31.052]                             invokeRestart(restart)
[17:02:31.052]                             muffled <- TRUE
[17:02:31.052]                             break
[17:02:31.052]                           }
[17:02:31.052]                         }
[17:02:31.052]                       }
[17:02:31.052]                       invisible(muffled)
[17:02:31.052]                     }
[17:02:31.052]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.052]                   }
[17:02:31.052]                 }
[17:02:31.052]                 else {
[17:02:31.052]                   if (TRUE) {
[17:02:31.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.052]                     {
[17:02:31.052]                       inherits <- base::inherits
[17:02:31.052]                       invokeRestart <- base::invokeRestart
[17:02:31.052]                       is.null <- base::is.null
[17:02:31.052]                       muffled <- FALSE
[17:02:31.052]                       if (inherits(cond, "message")) {
[17:02:31.052]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.052]                         if (muffled) 
[17:02:31.052]                           invokeRestart("muffleMessage")
[17:02:31.052]                       }
[17:02:31.052]                       else if (inherits(cond, "warning")) {
[17:02:31.052]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.052]                         if (muffled) 
[17:02:31.052]                           invokeRestart("muffleWarning")
[17:02:31.052]                       }
[17:02:31.052]                       else if (inherits(cond, "condition")) {
[17:02:31.052]                         if (!is.null(pattern)) {
[17:02:31.052]                           computeRestarts <- base::computeRestarts
[17:02:31.052]                           grepl <- base::grepl
[17:02:31.052]                           restarts <- computeRestarts(cond)
[17:02:31.052]                           for (restart in restarts) {
[17:02:31.052]                             name <- restart$name
[17:02:31.052]                             if (is.null(name)) 
[17:02:31.052]                               next
[17:02:31.052]                             if (!grepl(pattern, name)) 
[17:02:31.052]                               next
[17:02:31.052]                             invokeRestart(restart)
[17:02:31.052]                             muffled <- TRUE
[17:02:31.052]                             break
[17:02:31.052]                           }
[17:02:31.052]                         }
[17:02:31.052]                       }
[17:02:31.052]                       invisible(muffled)
[17:02:31.052]                     }
[17:02:31.052]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.052]                   }
[17:02:31.052]                 }
[17:02:31.052]             }
[17:02:31.052]         }))
[17:02:31.052]     }, error = function(ex) {
[17:02:31.052]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.052]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.052]                 ...future.rng), started = ...future.startTime, 
[17:02:31.052]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.052]             version = "1.8"), class = "FutureResult")
[17:02:31.052]     }, finally = {
[17:02:31.052]         if (!identical(...future.workdir, getwd())) 
[17:02:31.052]             setwd(...future.workdir)
[17:02:31.052]         {
[17:02:31.052]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.052]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.052]             }
[17:02:31.052]             base::options(...future.oldOptions)
[17:02:31.052]             if (.Platform$OS.type == "windows") {
[17:02:31.052]                 old_names <- names(...future.oldEnvVars)
[17:02:31.052]                 envs <- base::Sys.getenv()
[17:02:31.052]                 names <- names(envs)
[17:02:31.052]                 common <- intersect(names, old_names)
[17:02:31.052]                 added <- setdiff(names, old_names)
[17:02:31.052]                 removed <- setdiff(old_names, names)
[17:02:31.052]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.052]                   envs[common]]
[17:02:31.052]                 NAMES <- toupper(changed)
[17:02:31.052]                 args <- list()
[17:02:31.052]                 for (kk in seq_along(NAMES)) {
[17:02:31.052]                   name <- changed[[kk]]
[17:02:31.052]                   NAME <- NAMES[[kk]]
[17:02:31.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.052]                     next
[17:02:31.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.052]                 }
[17:02:31.052]                 NAMES <- toupper(added)
[17:02:31.052]                 for (kk in seq_along(NAMES)) {
[17:02:31.052]                   name <- added[[kk]]
[17:02:31.052]                   NAME <- NAMES[[kk]]
[17:02:31.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.052]                     next
[17:02:31.052]                   args[[name]] <- ""
[17:02:31.052]                 }
[17:02:31.052]                 NAMES <- toupper(removed)
[17:02:31.052]                 for (kk in seq_along(NAMES)) {
[17:02:31.052]                   name <- removed[[kk]]
[17:02:31.052]                   NAME <- NAMES[[kk]]
[17:02:31.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.052]                     next
[17:02:31.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.052]                 }
[17:02:31.052]                 if (length(args) > 0) 
[17:02:31.052]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.052]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.052]             }
[17:02:31.052]             else {
[17:02:31.052]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.052]             }
[17:02:31.052]             {
[17:02:31.052]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.052]                   0L) {
[17:02:31.052]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.052]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.052]                   base::options(opts)
[17:02:31.052]                 }
[17:02:31.052]                 {
[17:02:31.052]                   {
[17:02:31.052]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.052]                     NULL
[17:02:31.052]                   }
[17:02:31.052]                   options(future.plan = NULL)
[17:02:31.052]                   if (is.na(NA_character_)) 
[17:02:31.052]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.052]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.052]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.052]                     .init = FALSE)
[17:02:31.052]                 }
[17:02:31.052]             }
[17:02:31.052]         }
[17:02:31.052]     })
[17:02:31.052]     if (TRUE) {
[17:02:31.052]         base::sink(type = "output", split = FALSE)
[17:02:31.052]         if (TRUE) {
[17:02:31.052]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.052]         }
[17:02:31.052]         else {
[17:02:31.052]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.052]         }
[17:02:31.052]         base::close(...future.stdout)
[17:02:31.052]         ...future.stdout <- NULL
[17:02:31.052]     }
[17:02:31.052]     ...future.result$conditions <- ...future.conditions
[17:02:31.052]     ...future.result$finished <- base::Sys.time()
[17:02:31.052]     ...future.result
[17:02:31.052] }
[17:02:31.055] requestCore(): workers = 2
[17:02:31.057] MulticoreFuture started
[17:02:31.057] - Launch lazy future ... done
[17:02:31.057] run() for ‘MulticoreFuture’ ... done
[17:02:31.058] getGlobalsAndPackages() ...
[17:02:31.058] Searching for globals...
[17:02:31.058] plan(): Setting new future strategy stack:
[17:02:31.059] 
[17:02:31.058] List of future strategies:
[17:02:31.058] 1. sequential:
[17:02:31.058]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:31.058]    - tweaked: FALSE
[17:02:31.058]    - call: NULL
[17:02:31.059] Searching for globals ... DONE
[17:02:31.059] plan(): nbrOfWorkers() = 1
[17:02:31.059] - globals: [0] <none>
[17:02:31.059] getGlobalsAndPackages() ... DONE
[17:02:31.060] run() for ‘Future’ ...
[17:02:31.060] - state: ‘created’
[17:02:31.060] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.061] plan(): Setting new future strategy stack:
[17:02:31.061] List of future strategies:
[17:02:31.061] 1. multicore:
[17:02:31.061]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:31.061]    - tweaked: FALSE
[17:02:31.061]    - call: plan(strategy)
[17:02:31.065] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.065] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:31.066]   - Field: ‘label’
[17:02:31.066] plan(): nbrOfWorkers() = 2
[17:02:31.066]   - Field: ‘local’
[17:02:31.066]   - Field: ‘owner’
[17:02:31.066]   - Field: ‘envir’
[17:02:31.066]   - Field: ‘workers’
[17:02:31.066]   - Field: ‘packages’
[17:02:31.067]   - Field: ‘gc’
[17:02:31.067]   - Field: ‘job’
[17:02:31.067]   - Field: ‘conditions’
[17:02:31.067]   - Field: ‘expr’
[17:02:31.067]   - Field: ‘uuid’
[17:02:31.067]   - Field: ‘seed’
[17:02:31.067]   - Field: ‘version’
[17:02:31.068]   - Field: ‘result’
[17:02:31.068]   - Field: ‘asynchronous’
[17:02:31.068]   - Field: ‘calls’
[17:02:31.068]   - Field: ‘globals’
[17:02:31.068]   - Field: ‘stdout’
[17:02:31.068]   - Field: ‘earlySignal’
[17:02:31.068]   - Field: ‘lazy’
[17:02:31.069]   - Field: ‘state’
[17:02:31.069] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:31.069] - Launch lazy future ...
[17:02:31.069] Packages needed by the future expression (n = 0): <none>
[17:02:31.069] Packages needed by future strategies (n = 0): <none>
[17:02:31.070] {
[17:02:31.070]     {
[17:02:31.070]         {
[17:02:31.070]             ...future.startTime <- base::Sys.time()
[17:02:31.070]             {
[17:02:31.070]                 {
[17:02:31.070]                   {
[17:02:31.070]                     {
[17:02:31.070]                       base::local({
[17:02:31.070]                         has_future <- base::requireNamespace("future", 
[17:02:31.070]                           quietly = TRUE)
[17:02:31.070]                         if (has_future) {
[17:02:31.070]                           ns <- base::getNamespace("future")
[17:02:31.070]                           version <- ns[[".package"]][["version"]]
[17:02:31.070]                           if (is.null(version)) 
[17:02:31.070]                             version <- utils::packageVersion("future")
[17:02:31.070]                         }
[17:02:31.070]                         else {
[17:02:31.070]                           version <- NULL
[17:02:31.070]                         }
[17:02:31.070]                         if (!has_future || version < "1.8.0") {
[17:02:31.070]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.070]                             "", base::R.version$version.string), 
[17:02:31.070]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.070]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.070]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.070]                               "release", "version")], collapse = " "), 
[17:02:31.070]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.070]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.070]                             info)
[17:02:31.070]                           info <- base::paste(info, collapse = "; ")
[17:02:31.070]                           if (!has_future) {
[17:02:31.070]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.070]                               info)
[17:02:31.070]                           }
[17:02:31.070]                           else {
[17:02:31.070]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.070]                               info, version)
[17:02:31.070]                           }
[17:02:31.070]                           base::stop(msg)
[17:02:31.070]                         }
[17:02:31.070]                       })
[17:02:31.070]                     }
[17:02:31.070]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.070]                     base::options(mc.cores = 1L)
[17:02:31.070]                   }
[17:02:31.070]                   ...future.strategy.old <- future::plan("list")
[17:02:31.070]                   options(future.plan = NULL)
[17:02:31.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.070]                 }
[17:02:31.070]                 ...future.workdir <- getwd()
[17:02:31.070]             }
[17:02:31.070]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.070]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.070]         }
[17:02:31.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.070]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.070]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.070]             base::names(...future.oldOptions))
[17:02:31.070]     }
[17:02:31.070]     if (FALSE) {
[17:02:31.070]     }
[17:02:31.070]     else {
[17:02:31.070]         if (TRUE) {
[17:02:31.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.070]                 open = "w")
[17:02:31.070]         }
[17:02:31.070]         else {
[17:02:31.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.070]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.070]         }
[17:02:31.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.070]             base::sink(type = "output", split = FALSE)
[17:02:31.070]             base::close(...future.stdout)
[17:02:31.070]         }, add = TRUE)
[17:02:31.070]     }
[17:02:31.070]     ...future.frame <- base::sys.nframe()
[17:02:31.070]     ...future.conditions <- base::list()
[17:02:31.070]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.070]     if (FALSE) {
[17:02:31.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.070]     }
[17:02:31.070]     ...future.result <- base::tryCatch({
[17:02:31.070]         base::withCallingHandlers({
[17:02:31.070]             ...future.value <- base::withVisible(base::local({
[17:02:31.070]                 withCallingHandlers({
[17:02:31.070]                   NULL
[17:02:31.070]                 }, immediateCondition = function(cond) {
[17:02:31.070]                   save_rds <- function (object, pathname, ...) 
[17:02:31.070]                   {
[17:02:31.070]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:31.070]                     if (file_test("-f", pathname_tmp)) {
[17:02:31.070]                       fi_tmp <- file.info(pathname_tmp)
[17:02:31.070]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:31.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:31.070]                         fi_tmp[["mtime"]])
[17:02:31.070]                     }
[17:02:31.070]                     tryCatch({
[17:02:31.070]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:31.070]                     }, error = function(ex) {
[17:02:31.070]                       msg <- conditionMessage(ex)
[17:02:31.070]                       fi_tmp <- file.info(pathname_tmp)
[17:02:31.070]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:31.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:31.070]                         fi_tmp[["mtime"]], msg)
[17:02:31.070]                       ex$message <- msg
[17:02:31.070]                       stop(ex)
[17:02:31.070]                     })
[17:02:31.070]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:31.070]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:31.070]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:31.070]                       fi_tmp <- file.info(pathname_tmp)
[17:02:31.070]                       fi <- file.info(pathname)
[17:02:31.070]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:31.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:31.070]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:31.070]                         fi[["size"]], fi[["mtime"]])
[17:02:31.070]                       stop(msg)
[17:02:31.070]                     }
[17:02:31.070]                     invisible(pathname)
[17:02:31.070]                   }
[17:02:31.070]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:31.070]                     rootPath = tempdir()) 
[17:02:31.070]                   {
[17:02:31.070]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:31.070]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:31.070]                       tmpdir = path, fileext = ".rds")
[17:02:31.070]                     save_rds(obj, file)
[17:02:31.070]                   }
[17:02:31.070]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:31.070]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.070]                   {
[17:02:31.070]                     inherits <- base::inherits
[17:02:31.070]                     invokeRestart <- base::invokeRestart
[17:02:31.070]                     is.null <- base::is.null
[17:02:31.070]                     muffled <- FALSE
[17:02:31.070]                     if (inherits(cond, "message")) {
[17:02:31.070]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.070]                       if (muffled) 
[17:02:31.070]                         invokeRestart("muffleMessage")
[17:02:31.070]                     }
[17:02:31.070]                     else if (inherits(cond, "warning")) {
[17:02:31.070]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.070]                       if (muffled) 
[17:02:31.070]                         invokeRestart("muffleWarning")
[17:02:31.070]                     }
[17:02:31.070]                     else if (inherits(cond, "condition")) {
[17:02:31.070]                       if (!is.null(pattern)) {
[17:02:31.070]                         computeRestarts <- base::computeRestarts
[17:02:31.070]                         grepl <- base::grepl
[17:02:31.070]                         restarts <- computeRestarts(cond)
[17:02:31.070]                         for (restart in restarts) {
[17:02:31.070]                           name <- restart$name
[17:02:31.070]                           if (is.null(name)) 
[17:02:31.070]                             next
[17:02:31.070]                           if (!grepl(pattern, name)) 
[17:02:31.070]                             next
[17:02:31.070]                           invokeRestart(restart)
[17:02:31.070]                           muffled <- TRUE
[17:02:31.070]                           break
[17:02:31.070]                         }
[17:02:31.070]                       }
[17:02:31.070]                     }
[17:02:31.070]                     invisible(muffled)
[17:02:31.070]                   }
[17:02:31.070]                   muffleCondition(cond)
[17:02:31.070]                 })
[17:02:31.070]             }))
[17:02:31.070]             future::FutureResult(value = ...future.value$value, 
[17:02:31.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.070]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.070]                     ...future.globalenv.names))
[17:02:31.070]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.070]         }, condition = base::local({
[17:02:31.070]             c <- base::c
[17:02:31.070]             inherits <- base::inherits
[17:02:31.070]             invokeRestart <- base::invokeRestart
[17:02:31.070]             length <- base::length
[17:02:31.070]             list <- base::list
[17:02:31.070]             seq.int <- base::seq.int
[17:02:31.070]             signalCondition <- base::signalCondition
[17:02:31.070]             sys.calls <- base::sys.calls
[17:02:31.070]             `[[` <- base::`[[`
[17:02:31.070]             `+` <- base::`+`
[17:02:31.070]             `<<-` <- base::`<<-`
[17:02:31.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.070]                   3L)]
[17:02:31.070]             }
[17:02:31.070]             function(cond) {
[17:02:31.070]                 is_error <- inherits(cond, "error")
[17:02:31.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.070]                   NULL)
[17:02:31.070]                 if (is_error) {
[17:02:31.070]                   sessionInformation <- function() {
[17:02:31.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.070]                       search = base::search(), system = base::Sys.info())
[17:02:31.070]                   }
[17:02:31.070]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.070]                     cond$call), session = sessionInformation(), 
[17:02:31.070]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.070]                   signalCondition(cond)
[17:02:31.070]                 }
[17:02:31.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.070]                 "immediateCondition"))) {
[17:02:31.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.070]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.070]                   if (TRUE && !signal) {
[17:02:31.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.070]                     {
[17:02:31.070]                       inherits <- base::inherits
[17:02:31.070]                       invokeRestart <- base::invokeRestart
[17:02:31.070]                       is.null <- base::is.null
[17:02:31.070]                       muffled <- FALSE
[17:02:31.070]                       if (inherits(cond, "message")) {
[17:02:31.070]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.070]                         if (muffled) 
[17:02:31.070]                           invokeRestart("muffleMessage")
[17:02:31.070]                       }
[17:02:31.070]                       else if (inherits(cond, "warning")) {
[17:02:31.070]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.070]                         if (muffled) 
[17:02:31.070]                           invokeRestart("muffleWarning")
[17:02:31.070]                       }
[17:02:31.070]                       else if (inherits(cond, "condition")) {
[17:02:31.070]                         if (!is.null(pattern)) {
[17:02:31.070]                           computeRestarts <- base::computeRestarts
[17:02:31.070]                           grepl <- base::grepl
[17:02:31.070]                           restarts <- computeRestarts(cond)
[17:02:31.070]                           for (restart in restarts) {
[17:02:31.070]                             name <- restart$name
[17:02:31.070]                             if (is.null(name)) 
[17:02:31.070]                               next
[17:02:31.070]                             if (!grepl(pattern, name)) 
[17:02:31.070]                               next
[17:02:31.070]                             invokeRestart(restart)
[17:02:31.070]                             muffled <- TRUE
[17:02:31.070]                             break
[17:02:31.070]                           }
[17:02:31.070]                         }
[17:02:31.070]                       }
[17:02:31.070]                       invisible(muffled)
[17:02:31.070]                     }
[17:02:31.070]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.070]                   }
[17:02:31.070]                 }
[17:02:31.070]                 else {
[17:02:31.070]                   if (TRUE) {
[17:02:31.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.070]                     {
[17:02:31.070]                       inherits <- base::inherits
[17:02:31.070]                       invokeRestart <- base::invokeRestart
[17:02:31.070]                       is.null <- base::is.null
[17:02:31.070]                       muffled <- FALSE
[17:02:31.070]                       if (inherits(cond, "message")) {
[17:02:31.070]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.070]                         if (muffled) 
[17:02:31.070]                           invokeRestart("muffleMessage")
[17:02:31.070]                       }
[17:02:31.070]                       else if (inherits(cond, "warning")) {
[17:02:31.070]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.070]                         if (muffled) 
[17:02:31.070]                           invokeRestart("muffleWarning")
[17:02:31.070]                       }
[17:02:31.070]                       else if (inherits(cond, "condition")) {
[17:02:31.070]                         if (!is.null(pattern)) {
[17:02:31.070]                           computeRestarts <- base::computeRestarts
[17:02:31.070]                           grepl <- base::grepl
[17:02:31.070]                           restarts <- computeRestarts(cond)
[17:02:31.070]                           for (restart in restarts) {
[17:02:31.070]                             name <- restart$name
[17:02:31.070]                             if (is.null(name)) 
[17:02:31.070]                               next
[17:02:31.070]                             if (!grepl(pattern, name)) 
[17:02:31.070]                               next
[17:02:31.070]                             invokeRestart(restart)
[17:02:31.070]                             muffled <- TRUE
[17:02:31.070]                             break
[17:02:31.070]                           }
[17:02:31.070]                         }
[17:02:31.070]                       }
[17:02:31.070]                       invisible(muffled)
[17:02:31.070]                     }
[17:02:31.070]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.070]                   }
[17:02:31.070]                 }
[17:02:31.070]             }
[17:02:31.070]         }))
[17:02:31.070]     }, error = function(ex) {
[17:02:31.070]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.070]                 ...future.rng), started = ...future.startTime, 
[17:02:31.070]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.070]             version = "1.8"), class = "FutureResult")
[17:02:31.070]     }, finally = {
[17:02:31.070]         if (!identical(...future.workdir, getwd())) 
[17:02:31.070]             setwd(...future.workdir)
[17:02:31.070]         {
[17:02:31.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.070]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.070]             }
[17:02:31.070]             base::options(...future.oldOptions)
[17:02:31.070]             if (.Platform$OS.type == "windows") {
[17:02:31.070]                 old_names <- names(...future.oldEnvVars)
[17:02:31.070]                 envs <- base::Sys.getenv()
[17:02:31.070]                 names <- names(envs)
[17:02:31.070]                 common <- intersect(names, old_names)
[17:02:31.070]                 added <- setdiff(names, old_names)
[17:02:31.070]                 removed <- setdiff(old_names, names)
[17:02:31.070]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.070]                   envs[common]]
[17:02:31.070]                 NAMES <- toupper(changed)
[17:02:31.070]                 args <- list()
[17:02:31.070]                 for (kk in seq_along(NAMES)) {
[17:02:31.070]                   name <- changed[[kk]]
[17:02:31.070]                   NAME <- NAMES[[kk]]
[17:02:31.070]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.070]                     next
[17:02:31.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.070]                 }
[17:02:31.070]                 NAMES <- toupper(added)
[17:02:31.070]                 for (kk in seq_along(NAMES)) {
[17:02:31.070]                   name <- added[[kk]]
[17:02:31.070]                   NAME <- NAMES[[kk]]
[17:02:31.070]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.070]                     next
[17:02:31.070]                   args[[name]] <- ""
[17:02:31.070]                 }
[17:02:31.070]                 NAMES <- toupper(removed)
[17:02:31.070]                 for (kk in seq_along(NAMES)) {
[17:02:31.070]                   name <- removed[[kk]]
[17:02:31.070]                   NAME <- NAMES[[kk]]
[17:02:31.070]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.070]                     next
[17:02:31.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.070]                 }
[17:02:31.070]                 if (length(args) > 0) 
[17:02:31.070]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.070]             }
[17:02:31.070]             else {
[17:02:31.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.070]             }
[17:02:31.070]             {
[17:02:31.070]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.070]                   0L) {
[17:02:31.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.070]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.070]                   base::options(opts)
[17:02:31.070]                 }
[17:02:31.070]                 {
[17:02:31.070]                   {
[17:02:31.070]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.070]                     NULL
[17:02:31.070]                   }
[17:02:31.070]                   options(future.plan = NULL)
[17:02:31.070]                   if (is.na(NA_character_)) 
[17:02:31.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.070]                     .init = FALSE)
[17:02:31.070]                 }
[17:02:31.070]             }
[17:02:31.070]         }
[17:02:31.070]     })
[17:02:31.070]     if (TRUE) {
[17:02:31.070]         base::sink(type = "output", split = FALSE)
[17:02:31.070]         if (TRUE) {
[17:02:31.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.070]         }
[17:02:31.070]         else {
[17:02:31.070]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.070]         }
[17:02:31.070]         base::close(...future.stdout)
[17:02:31.070]         ...future.stdout <- NULL
[17:02:31.070]     }
[17:02:31.070]     ...future.result$conditions <- ...future.conditions
[17:02:31.070]     ...future.result$finished <- base::Sys.time()
[17:02:31.070]     ...future.result
[17:02:31.070] }
[17:02:31.074] requestCore(): workers = 2
[17:02:31.077] MulticoreFuture started
[17:02:31.077] - Launch lazy future ... done
[17:02:31.077] run() for ‘MulticoreFuture’ ... done
[17:02:31.078] plan(): Setting new future strategy stack:
[17:02:31.078] getGlobalsAndPackages() ...
[17:02:31.078] Searching for globals...
[17:02:31.078] List of future strategies:
[17:02:31.078] 1. sequential:
[17:02:31.078]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:31.078]    - tweaked: FALSE
[17:02:31.078]    - call: NULL
[17:02:31.079] plan(): nbrOfWorkers() = 1
[17:02:31.080] - globals found: [1] ‘{’
[17:02:31.080] Searching for globals ... DONE
[17:02:31.080] Resolving globals: FALSE
[17:02:31.081] 
[17:02:31.081] 
[17:02:31.081] getGlobalsAndPackages() ... DONE
[17:02:31.081] run() for ‘Future’ ...
[17:02:31.081] plan(): Setting new future strategy stack:
[17:02:31.082] - state: ‘created’
[17:02:31.082] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.082] List of future strategies:
[17:02:31.082] 1. multicore:
[17:02:31.082]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:31.082]    - tweaked: FALSE
[17:02:31.082]    - call: plan(strategy)
[17:02:31.087] plan(): nbrOfWorkers() = 2
[17:02:31.088] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.088] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:31.088]   - Field: ‘label’
[17:02:31.088]   - Field: ‘local’
[17:02:31.088]   - Field: ‘owner’
[17:02:31.088]   - Field: ‘envir’
[17:02:31.089]   - Field: ‘workers’
[17:02:31.089]   - Field: ‘packages’
[17:02:31.089]   - Field: ‘gc’
[17:02:31.089]   - Field: ‘job’
[17:02:31.089]   - Field: ‘conditions’
[17:02:31.089]   - Field: ‘expr’
[17:02:31.089]   - Field: ‘uuid’
[17:02:31.090]   - Field: ‘seed’
[17:02:31.090]   - Field: ‘version’
[17:02:31.090]   - Field: ‘result’
[17:02:31.090]   - Field: ‘asynchronous’
[17:02:31.090]   - Field: ‘calls’
[17:02:31.090]   - Field: ‘globals’
[17:02:31.090]   - Field: ‘stdout’
[17:02:31.091]   - Field: ‘earlySignal’
[17:02:31.091]   - Field: ‘lazy’
[17:02:31.091]   - Field: ‘state’
[17:02:31.091] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:31.091] - Launch lazy future ...
[17:02:31.092] Packages needed by the future expression (n = 0): <none>
[17:02:31.092] Packages needed by future strategies (n = 0): <none>
[17:02:31.093] {
[17:02:31.093]     {
[17:02:31.093]         {
[17:02:31.093]             ...future.startTime <- base::Sys.time()
[17:02:31.093]             {
[17:02:31.093]                 {
[17:02:31.093]                   {
[17:02:31.093]                     {
[17:02:31.093]                       base::local({
[17:02:31.093]                         has_future <- base::requireNamespace("future", 
[17:02:31.093]                           quietly = TRUE)
[17:02:31.093]                         if (has_future) {
[17:02:31.093]                           ns <- base::getNamespace("future")
[17:02:31.093]                           version <- ns[[".package"]][["version"]]
[17:02:31.093]                           if (is.null(version)) 
[17:02:31.093]                             version <- utils::packageVersion("future")
[17:02:31.093]                         }
[17:02:31.093]                         else {
[17:02:31.093]                           version <- NULL
[17:02:31.093]                         }
[17:02:31.093]                         if (!has_future || version < "1.8.0") {
[17:02:31.093]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.093]                             "", base::R.version$version.string), 
[17:02:31.093]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.093]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.093]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.093]                               "release", "version")], collapse = " "), 
[17:02:31.093]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.093]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.093]                             info)
[17:02:31.093]                           info <- base::paste(info, collapse = "; ")
[17:02:31.093]                           if (!has_future) {
[17:02:31.093]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.093]                               info)
[17:02:31.093]                           }
[17:02:31.093]                           else {
[17:02:31.093]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.093]                               info, version)
[17:02:31.093]                           }
[17:02:31.093]                           base::stop(msg)
[17:02:31.093]                         }
[17:02:31.093]                       })
[17:02:31.093]                     }
[17:02:31.093]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.093]                     base::options(mc.cores = 1L)
[17:02:31.093]                   }
[17:02:31.093]                   ...future.strategy.old <- future::plan("list")
[17:02:31.093]                   options(future.plan = NULL)
[17:02:31.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.093]                 }
[17:02:31.093]                 ...future.workdir <- getwd()
[17:02:31.093]             }
[17:02:31.093]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.093]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.093]         }
[17:02:31.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.093]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.093]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.093]             base::names(...future.oldOptions))
[17:02:31.093]     }
[17:02:31.093]     if (FALSE) {
[17:02:31.093]     }
[17:02:31.093]     else {
[17:02:31.093]         if (TRUE) {
[17:02:31.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.093]                 open = "w")
[17:02:31.093]         }
[17:02:31.093]         else {
[17:02:31.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.093]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.093]         }
[17:02:31.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.093]             base::sink(type = "output", split = FALSE)
[17:02:31.093]             base::close(...future.stdout)
[17:02:31.093]         }, add = TRUE)
[17:02:31.093]     }
[17:02:31.093]     ...future.frame <- base::sys.nframe()
[17:02:31.093]     ...future.conditions <- base::list()
[17:02:31.093]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.093]     if (FALSE) {
[17:02:31.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.093]     }
[17:02:31.093]     ...future.result <- base::tryCatch({
[17:02:31.093]         base::withCallingHandlers({
[17:02:31.093]             ...future.value <- base::withVisible(base::local({
[17:02:31.093]                 withCallingHandlers({
[17:02:31.093]                   {
[17:02:31.093]                     4
[17:02:31.093]                   }
[17:02:31.093]                 }, immediateCondition = function(cond) {
[17:02:31.093]                   save_rds <- function (object, pathname, ...) 
[17:02:31.093]                   {
[17:02:31.093]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:31.093]                     if (file_test("-f", pathname_tmp)) {
[17:02:31.093]                       fi_tmp <- file.info(pathname_tmp)
[17:02:31.093]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:31.093]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:31.093]                         fi_tmp[["mtime"]])
[17:02:31.093]                     }
[17:02:31.093]                     tryCatch({
[17:02:31.093]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:31.093]                     }, error = function(ex) {
[17:02:31.093]                       msg <- conditionMessage(ex)
[17:02:31.093]                       fi_tmp <- file.info(pathname_tmp)
[17:02:31.093]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:31.093]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:31.093]                         fi_tmp[["mtime"]], msg)
[17:02:31.093]                       ex$message <- msg
[17:02:31.093]                       stop(ex)
[17:02:31.093]                     })
[17:02:31.093]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:31.093]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:31.093]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:31.093]                       fi_tmp <- file.info(pathname_tmp)
[17:02:31.093]                       fi <- file.info(pathname)
[17:02:31.093]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:31.093]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:31.093]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:31.093]                         fi[["size"]], fi[["mtime"]])
[17:02:31.093]                       stop(msg)
[17:02:31.093]                     }
[17:02:31.093]                     invisible(pathname)
[17:02:31.093]                   }
[17:02:31.093]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:31.093]                     rootPath = tempdir()) 
[17:02:31.093]                   {
[17:02:31.093]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:31.093]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:31.093]                       tmpdir = path, fileext = ".rds")
[17:02:31.093]                     save_rds(obj, file)
[17:02:31.093]                   }
[17:02:31.093]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:31.093]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.093]                   {
[17:02:31.093]                     inherits <- base::inherits
[17:02:31.093]                     invokeRestart <- base::invokeRestart
[17:02:31.093]                     is.null <- base::is.null
[17:02:31.093]                     muffled <- FALSE
[17:02:31.093]                     if (inherits(cond, "message")) {
[17:02:31.093]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.093]                       if (muffled) 
[17:02:31.093]                         invokeRestart("muffleMessage")
[17:02:31.093]                     }
[17:02:31.093]                     else if (inherits(cond, "warning")) {
[17:02:31.093]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.093]                       if (muffled) 
[17:02:31.093]                         invokeRestart("muffleWarning")
[17:02:31.093]                     }
[17:02:31.093]                     else if (inherits(cond, "condition")) {
[17:02:31.093]                       if (!is.null(pattern)) {
[17:02:31.093]                         computeRestarts <- base::computeRestarts
[17:02:31.093]                         grepl <- base::grepl
[17:02:31.093]                         restarts <- computeRestarts(cond)
[17:02:31.093]                         for (restart in restarts) {
[17:02:31.093]                           name <- restart$name
[17:02:31.093]                           if (is.null(name)) 
[17:02:31.093]                             next
[17:02:31.093]                           if (!grepl(pattern, name)) 
[17:02:31.093]                             next
[17:02:31.093]                           invokeRestart(restart)
[17:02:31.093]                           muffled <- TRUE
[17:02:31.093]                           break
[17:02:31.093]                         }
[17:02:31.093]                       }
[17:02:31.093]                     }
[17:02:31.093]                     invisible(muffled)
[17:02:31.093]                   }
[17:02:31.093]                   muffleCondition(cond)
[17:02:31.093]                 })
[17:02:31.093]             }))
[17:02:31.093]             future::FutureResult(value = ...future.value$value, 
[17:02:31.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.093]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.093]                     ...future.globalenv.names))
[17:02:31.093]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.093]         }, condition = base::local({
[17:02:31.093]             c <- base::c
[17:02:31.093]             inherits <- base::inherits
[17:02:31.093]             invokeRestart <- base::invokeRestart
[17:02:31.093]             length <- base::length
[17:02:31.093]             list <- base::list
[17:02:31.093]             seq.int <- base::seq.int
[17:02:31.093]             signalCondition <- base::signalCondition
[17:02:31.093]             sys.calls <- base::sys.calls
[17:02:31.093]             `[[` <- base::`[[`
[17:02:31.093]             `+` <- base::`+`
[17:02:31.093]             `<<-` <- base::`<<-`
[17:02:31.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.093]                   3L)]
[17:02:31.093]             }
[17:02:31.093]             function(cond) {
[17:02:31.093]                 is_error <- inherits(cond, "error")
[17:02:31.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.093]                   NULL)
[17:02:31.093]                 if (is_error) {
[17:02:31.093]                   sessionInformation <- function() {
[17:02:31.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.093]                       search = base::search(), system = base::Sys.info())
[17:02:31.093]                   }
[17:02:31.093]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.093]                     cond$call), session = sessionInformation(), 
[17:02:31.093]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.093]                   signalCondition(cond)
[17:02:31.093]                 }
[17:02:31.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.093]                 "immediateCondition"))) {
[17:02:31.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.093]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.093]                   if (TRUE && !signal) {
[17:02:31.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.093]                     {
[17:02:31.093]                       inherits <- base::inherits
[17:02:31.093]                       invokeRestart <- base::invokeRestart
[17:02:31.093]                       is.null <- base::is.null
[17:02:31.093]                       muffled <- FALSE
[17:02:31.093]                       if (inherits(cond, "message")) {
[17:02:31.093]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.093]                         if (muffled) 
[17:02:31.093]                           invokeRestart("muffleMessage")
[17:02:31.093]                       }
[17:02:31.093]                       else if (inherits(cond, "warning")) {
[17:02:31.093]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.093]                         if (muffled) 
[17:02:31.093]                           invokeRestart("muffleWarning")
[17:02:31.093]                       }
[17:02:31.093]                       else if (inherits(cond, "condition")) {
[17:02:31.093]                         if (!is.null(pattern)) {
[17:02:31.093]                           computeRestarts <- base::computeRestarts
[17:02:31.093]                           grepl <- base::grepl
[17:02:31.093]                           restarts <- computeRestarts(cond)
[17:02:31.093]                           for (restart in restarts) {
[17:02:31.093]                             name <- restart$name
[17:02:31.093]                             if (is.null(name)) 
[17:02:31.093]                               next
[17:02:31.093]                             if (!grepl(pattern, name)) 
[17:02:31.093]                               next
[17:02:31.093]                             invokeRestart(restart)
[17:02:31.093]                             muffled <- TRUE
[17:02:31.093]                             break
[17:02:31.093]                           }
[17:02:31.093]                         }
[17:02:31.093]                       }
[17:02:31.093]                       invisible(muffled)
[17:02:31.093]                     }
[17:02:31.093]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.093]                   }
[17:02:31.093]                 }
[17:02:31.093]                 else {
[17:02:31.093]                   if (TRUE) {
[17:02:31.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.093]                     {
[17:02:31.093]                       inherits <- base::inherits
[17:02:31.093]                       invokeRestart <- base::invokeRestart
[17:02:31.093]                       is.null <- base::is.null
[17:02:31.093]                       muffled <- FALSE
[17:02:31.093]                       if (inherits(cond, "message")) {
[17:02:31.093]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.093]                         if (muffled) 
[17:02:31.093]                           invokeRestart("muffleMessage")
[17:02:31.093]                       }
[17:02:31.093]                       else if (inherits(cond, "warning")) {
[17:02:31.093]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.093]                         if (muffled) 
[17:02:31.093]                           invokeRestart("muffleWarning")
[17:02:31.093]                       }
[17:02:31.093]                       else if (inherits(cond, "condition")) {
[17:02:31.093]                         if (!is.null(pattern)) {
[17:02:31.093]                           computeRestarts <- base::computeRestarts
[17:02:31.093]                           grepl <- base::grepl
[17:02:31.093]                           restarts <- computeRestarts(cond)
[17:02:31.093]                           for (restart in restarts) {
[17:02:31.093]                             name <- restart$name
[17:02:31.093]                             if (is.null(name)) 
[17:02:31.093]                               next
[17:02:31.093]                             if (!grepl(pattern, name)) 
[17:02:31.093]                               next
[17:02:31.093]                             invokeRestart(restart)
[17:02:31.093]                             muffled <- TRUE
[17:02:31.093]                             break
[17:02:31.093]                           }
[17:02:31.093]                         }
[17:02:31.093]                       }
[17:02:31.093]                       invisible(muffled)
[17:02:31.093]                     }
[17:02:31.093]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.093]                   }
[17:02:31.093]                 }
[17:02:31.093]             }
[17:02:31.093]         }))
[17:02:31.093]     }, error = function(ex) {
[17:02:31.093]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.093]                 ...future.rng), started = ...future.startTime, 
[17:02:31.093]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.093]             version = "1.8"), class = "FutureResult")
[17:02:31.093]     }, finally = {
[17:02:31.093]         if (!identical(...future.workdir, getwd())) 
[17:02:31.093]             setwd(...future.workdir)
[17:02:31.093]         {
[17:02:31.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.093]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.093]             }
[17:02:31.093]             base::options(...future.oldOptions)
[17:02:31.093]             if (.Platform$OS.type == "windows") {
[17:02:31.093]                 old_names <- names(...future.oldEnvVars)
[17:02:31.093]                 envs <- base::Sys.getenv()
[17:02:31.093]                 names <- names(envs)
[17:02:31.093]                 common <- intersect(names, old_names)
[17:02:31.093]                 added <- setdiff(names, old_names)
[17:02:31.093]                 removed <- setdiff(old_names, names)
[17:02:31.093]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.093]                   envs[common]]
[17:02:31.093]                 NAMES <- toupper(changed)
[17:02:31.093]                 args <- list()
[17:02:31.093]                 for (kk in seq_along(NAMES)) {
[17:02:31.093]                   name <- changed[[kk]]
[17:02:31.093]                   NAME <- NAMES[[kk]]
[17:02:31.093]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.093]                     next
[17:02:31.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.093]                 }
[17:02:31.093]                 NAMES <- toupper(added)
[17:02:31.093]                 for (kk in seq_along(NAMES)) {
[17:02:31.093]                   name <- added[[kk]]
[17:02:31.093]                   NAME <- NAMES[[kk]]
[17:02:31.093]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.093]                     next
[17:02:31.093]                   args[[name]] <- ""
[17:02:31.093]                 }
[17:02:31.093]                 NAMES <- toupper(removed)
[17:02:31.093]                 for (kk in seq_along(NAMES)) {
[17:02:31.093]                   name <- removed[[kk]]
[17:02:31.093]                   NAME <- NAMES[[kk]]
[17:02:31.093]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.093]                     next
[17:02:31.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.093]                 }
[17:02:31.093]                 if (length(args) > 0) 
[17:02:31.093]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.093]             }
[17:02:31.093]             else {
[17:02:31.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.093]             }
[17:02:31.093]             {
[17:02:31.093]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.093]                   0L) {
[17:02:31.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.093]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.093]                   base::options(opts)
[17:02:31.093]                 }
[17:02:31.093]                 {
[17:02:31.093]                   {
[17:02:31.093]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.093]                     NULL
[17:02:31.093]                   }
[17:02:31.093]                   options(future.plan = NULL)
[17:02:31.093]                   if (is.na(NA_character_)) 
[17:02:31.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.093]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.093]                     .init = FALSE)
[17:02:31.093]                 }
[17:02:31.093]             }
[17:02:31.093]         }
[17:02:31.093]     })
[17:02:31.093]     if (TRUE) {
[17:02:31.093]         base::sink(type = "output", split = FALSE)
[17:02:31.093]         if (TRUE) {
[17:02:31.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.093]         }
[17:02:31.093]         else {
[17:02:31.093]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.093]         }
[17:02:31.093]         base::close(...future.stdout)
[17:02:31.093]         ...future.stdout <- NULL
[17:02:31.093]     }
[17:02:31.093]     ...future.result$conditions <- ...future.conditions
[17:02:31.093]     ...future.result$finished <- base::Sys.time()
[17:02:31.093]     ...future.result
[17:02:31.093] }
[17:02:31.096] requestCore(): workers = 2
[17:02:31.096] Poll #1 (0): usedCores() = 2, workers = 2
[17:02:31.107] result() for MulticoreFuture ...
[17:02:31.108] result() for MulticoreFuture ...
[17:02:31.108] result() for MulticoreFuture ... done
[17:02:31.108] result() for MulticoreFuture ... done
[17:02:31.109] result() for MulticoreFuture ...
[17:02:31.109] result() for MulticoreFuture ... done
[17:02:31.112] MulticoreFuture started
[17:02:31.112] - Launch lazy future ... done
[17:02:31.112] run() for ‘MulticoreFuture’ ... done
[17:02:31.113] plan(): Setting new future strategy stack:
<environment: 0x55c74b8a3228> 
[17:02:31.113] List of future strategies:
[17:02:31.113] 1. sequential:
[17:02:31.113]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:31.113]    - tweaked: FALSE
[17:02:31.113]    - call: NULL
[17:02:31.115] plan(): nbrOfWorkers() = 1
<environment: 0x55c74811d0b0> 
[17:02:31.118] plan(): Setting new future strategy stack:
[17:02:31.118] List of future strategies:
[17:02:31.118] 1. multicore:
[17:02:31.118]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:31.118]    - tweaked: FALSE
[17:02:31.118]    - call: plan(strategy)
[17:02:31.124] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:31.126] resolve() on environment ...
[17:02:31.127]  recursive: 0
[17:02:31.128]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:31.128] signalConditionsASAP(numeric, pos=1) ...
[17:02:31.128] - nx: 4
[17:02:31.128] - relay: TRUE
[17:02:31.128] - stdout: TRUE
[17:02:31.128] - signal: TRUE
[17:02:31.129] - resignal: FALSE
[17:02:31.129] - force: TRUE
[17:02:31.129] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.129] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.129]  - until=2
[17:02:31.129]  - relaying element #2
[17:02:31.129] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:31.130] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.130] signalConditionsASAP(NULL, pos=1) ... done
[17:02:31.130]  length: 3 (resolved future 1)
[17:02:31.130] Future #2
[17:02:31.130] result() for MulticoreFuture ...
[17:02:31.130] result() for MulticoreFuture ... done
[17:02:31.131] result() for MulticoreFuture ...
[17:02:31.131] result() for MulticoreFuture ... done
[17:02:31.131] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:31.131] - nx: 4
[17:02:31.131] - relay: TRUE
[17:02:31.131] - stdout: TRUE
[17:02:31.131] - signal: TRUE
[17:02:31.132] - resignal: FALSE
[17:02:31.132] - force: TRUE
[17:02:31.132] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:31.132] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.132]  - until=2
[17:02:31.132]  - relaying element #2
[17:02:31.132] result() for MulticoreFuture ...
[17:02:31.133] result() for MulticoreFuture ... done
[17:02:31.133] result() for MulticoreFuture ...
[17:02:31.133] result() for MulticoreFuture ... done
[17:02:31.133] result() for MulticoreFuture ...
[17:02:31.133] result() for MulticoreFuture ... done
[17:02:31.133] result() for MulticoreFuture ...
[17:02:31.133] result() for MulticoreFuture ... done
[17:02:31.134] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:31.134] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:31.134] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:31.134]  length: 2 (resolved future 2)
[17:02:31.134] Future #3
[17:02:31.134] result() for MulticoreFuture ...
[17:02:31.135] result() for MulticoreFuture ...
[17:02:31.136] result() for MulticoreFuture ... done
[17:02:31.136] result() for MulticoreFuture ... done
[17:02:31.136] result() for MulticoreFuture ...
[17:02:31.136] result() for MulticoreFuture ... done
[17:02:31.136] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:31.137] - nx: 4
[17:02:31.137] - relay: TRUE
[17:02:31.137] - stdout: TRUE
[17:02:31.137] - signal: TRUE
[17:02:31.137] - resignal: FALSE
[17:02:31.137] - force: TRUE
[17:02:31.138] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:31.138] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:31.138]  - until=3
[17:02:31.138]  - relaying element #3
[17:02:31.138] result() for MulticoreFuture ...
[17:02:31.138] result() for MulticoreFuture ... done
[17:02:31.139] result() for MulticoreFuture ...
[17:02:31.139] result() for MulticoreFuture ... done
[17:02:31.139] result() for MulticoreFuture ...
[17:02:31.139] result() for MulticoreFuture ... done
[17:02:31.140] result() for MulticoreFuture ...
[17:02:31.140] result() for MulticoreFuture ... done
[17:02:31.140] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:31.140] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:31.140] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:31.140]  length: 1 (resolved future 3)
[17:02:31.141] Future #4
[17:02:31.141] result() for MulticoreFuture ...
[17:02:31.142] result() for MulticoreFuture ...
[17:02:31.142] result() for MulticoreFuture ... done
[17:02:31.142] result() for MulticoreFuture ... done
[17:02:31.142] result() for MulticoreFuture ...
[17:02:31.142] result() for MulticoreFuture ... done
[17:02:31.142] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:02:31.143] - nx: 4
[17:02:31.143] - relay: TRUE
[17:02:31.143] - stdout: TRUE
[17:02:31.143] - signal: TRUE
[17:02:31.143] - resignal: FALSE
[17:02:31.143] - force: TRUE
[17:02:31.144] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:31.144] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:31.144]  - until=4
[17:02:31.144]  - relaying element #4
[17:02:31.144] result() for MulticoreFuture ...
[17:02:31.144] result() for MulticoreFuture ... done
[17:02:31.145] result() for MulticoreFuture ...
[17:02:31.145] result() for MulticoreFuture ... done
[17:02:31.145] result() for MulticoreFuture ...
[17:02:31.145] result() for MulticoreFuture ... done
[17:02:31.145] result() for MulticoreFuture ...
[17:02:31.145] result() for MulticoreFuture ... done
[17:02:31.146] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.146] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:31.146] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:02:31.146]  length: 0 (resolved future 4)
[17:02:31.146] Relaying remaining futures
[17:02:31.146] signalConditionsASAP(NULL, pos=0) ...
[17:02:31.146] - nx: 4
[17:02:31.146] - relay: TRUE
[17:02:31.146] - stdout: TRUE
[17:02:31.146] - signal: TRUE
[17:02:31.147] - resignal: FALSE
[17:02:31.147] - force: TRUE
[17:02:31.147] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.147] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:31.147] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.147] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:31.147] signalConditionsASAP(NULL, pos=0) ... done
[17:02:31.147] resolve() on environment ... DONE
[17:02:31.148] result() for MulticoreFuture ...
[17:02:31.148] result() for MulticoreFuture ... done
[17:02:31.148] result() for MulticoreFuture ...
[17:02:31.148] result() for MulticoreFuture ... done
[17:02:31.148] result() for MulticoreFuture ...
[17:02:31.148] result() for MulticoreFuture ... done
[17:02:31.148] result() for MulticoreFuture ...
[17:02:31.148] result() for MulticoreFuture ... done
[17:02:31.148] result() for MulticoreFuture ...
[17:02:31.149] result() for MulticoreFuture ... done
[17:02:31.149] result() for MulticoreFuture ...
[17:02:31.149] result() for MulticoreFuture ... done
<environment: 0x55c747c02ff0> 
Type of future: multisession
[17:02:31.149] plan(): Setting new future strategy stack:
[17:02:31.149] List of future strategies:
[17:02:31.149] 1. multisession:
[17:02:31.149]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:02:31.149]    - tweaked: FALSE
[17:02:31.149]    - call: plan(strategy)
[17:02:31.150] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:02:31.150] multisession:
[17:02:31.150] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:02:31.150] - tweaked: FALSE
[17:02:31.150] - call: plan(strategy)
[17:02:31.154] getGlobalsAndPackages() ...
[17:02:31.154] Not searching for globals
[17:02:31.154] - globals: [0] <none>
[17:02:31.154] getGlobalsAndPackages() ... DONE
[17:02:31.155] [local output] makeClusterPSOCK() ...
[17:02:31.159] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:02:31.159] [local output] Base port: 11248
[17:02:31.160] [local output] Getting setup options for 2 cluster nodes ...
[17:02:31.160] [local output]  - Node 1 of 2 ...
[17:02:31.160] [local output] localMachine=TRUE => revtunnel=FALSE

[17:02:31.161] [local output] Rscript port: 11248

[17:02:31.161] [local output]  - Node 2 of 2 ...
[17:02:31.162] [local output] localMachine=TRUE => revtunnel=FALSE

[17:02:31.162] [local output] Rscript port: 11248

[17:02:31.163] [local output] Getting setup options for 2 cluster nodes ... done
[17:02:31.163] [local output]  - Parallel setup requested for some PSOCK nodes
[17:02:31.163] [local output] Setting up PSOCK nodes in parallel
[17:02:31.163] List of 36
[17:02:31.163]  $ worker          : chr "localhost"
[17:02:31.163]   ..- attr(*, "localhost")= logi TRUE
[17:02:31.163]  $ master          : chr "localhost"
[17:02:31.163]  $ port            : int 11248
[17:02:31.163]  $ connectTimeout  : num 120
[17:02:31.163]  $ timeout         : num 2592000
[17:02:31.163]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:02:31.163]  $ homogeneous     : logi TRUE
[17:02:31.163]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:02:31.163]  $ rscript_envs    : NULL
[17:02:31.163]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:02:31.163]  $ rscript_startup : NULL
[17:02:31.163]  $ rscript_sh      : chr "sh"
[17:02:31.163]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:02:31.163]  $ methods         : logi TRUE
[17:02:31.163]  $ socketOptions   : chr "no-delay"
[17:02:31.163]  $ useXDR          : logi FALSE
[17:02:31.163]  $ outfile         : chr "/dev/null"
[17:02:31.163]  $ renice          : int NA
[17:02:31.163]  $ rshcmd          : NULL
[17:02:31.163]  $ user            : chr(0) 
[17:02:31.163]  $ revtunnel       : logi FALSE
[17:02:31.163]  $ rshlogfile      : NULL
[17:02:31.163]  $ rshopts         : chr(0) 
[17:02:31.163]  $ rank            : int 1
[17:02:31.163]  $ manual          : logi FALSE
[17:02:31.163]  $ dryrun          : logi FALSE
[17:02:31.163]  $ quiet           : logi FALSE
[17:02:31.163]  $ setup_strategy  : chr "parallel"
[17:02:31.163]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:02:31.163]  $ pidfile         : chr "/tmp/Rtmp9yGsuH/worker.rank=1.parallelly.parent=42097.a4715554c09d.pid"
[17:02:31.163]  $ rshcmd_label    : NULL
[17:02:31.163]  $ rsh_call        : NULL
[17:02:31.163]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:02:31.163]  $ localMachine    : logi TRUE
[17:02:31.163]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:02:31.163]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:02:31.163]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:02:31.163]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:02:31.163]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:02:31.163]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:02:31.163]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:02:31.163]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:02:31.163]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:02:31.163]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:02:31.163]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:02:31.163]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:02:31.163]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:02:31.163]  $ arguments       :List of 28
[17:02:31.163]   ..$ worker          : chr "localhost"
[17:02:31.163]   ..$ master          : NULL
[17:02:31.163]   ..$ port            : int 11248
[17:02:31.163]   ..$ connectTimeout  : num 120
[17:02:31.163]   ..$ timeout         : num 2592000
[17:02:31.163]   ..$ rscript         : NULL
[17:02:31.163]   ..$ homogeneous     : NULL
[17:02:31.163]   ..$ rscript_args    : NULL
[17:02:31.163]   ..$ rscript_envs    : NULL
[17:02:31.163]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:02:31.163]   ..$ rscript_startup : NULL
[17:02:31.163]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:02:31.163]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:02:31.163]   ..$ methods         : logi TRUE
[17:02:31.163]   ..$ socketOptions   : chr "no-delay"
[17:02:31.163]   ..$ useXDR          : logi FALSE
[17:02:31.163]   ..$ outfile         : chr "/dev/null"
[17:02:31.163]   ..$ renice          : int NA
[17:02:31.163]   ..$ rshcmd          : NULL
[17:02:31.163]   ..$ user            : NULL
[17:02:31.163]   ..$ revtunnel       : logi NA
[17:02:31.163]   ..$ rshlogfile      : NULL
[17:02:31.163]   ..$ rshopts         : NULL
[17:02:31.163]   ..$ rank            : int 1
[17:02:31.163]   ..$ manual          : logi FALSE
[17:02:31.163]   ..$ dryrun          : logi FALSE
[17:02:31.163]   ..$ quiet           : logi FALSE
[17:02:31.163]   ..$ setup_strategy  : chr "parallel"
[17:02:31.163]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:02:31.182] [local output] System call to launch all workers:
[17:02:31.182] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp9yGsuH/worker.rank=1.parallelly.parent=42097.a4715554c09d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11248 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:02:31.183] [local output] Starting PSOCK main server
[17:02:31.184] [local output] Workers launched
[17:02:31.184] [local output] Waiting for workers to connect back
[17:02:31.184]  - [local output] 0 workers out of 2 ready
[17:02:31.429]  - [local output] 0 workers out of 2 ready
[17:02:31.430]  - [local output] 1 workers out of 2 ready
[17:02:31.430]  - [local output] 2 workers out of 2 ready
[17:02:31.430] [local output] Launching of workers completed
[17:02:31.430] [local output] Collecting session information from workers
[17:02:31.431] [local output]  - Worker #1 of 2
[17:02:31.432] [local output]  - Worker #2 of 2
[17:02:31.432] [local output] makeClusterPSOCK() ... done
[17:02:31.443] Packages needed by the future expression (n = 0): <none>
[17:02:31.443] Packages needed by future strategies (n = 0): <none>
[17:02:31.446] {
[17:02:31.446]     {
[17:02:31.446]         {
[17:02:31.446]             ...future.startTime <- base::Sys.time()
[17:02:31.446]             {
[17:02:31.446]                 {
[17:02:31.446]                   {
[17:02:31.446]                     {
[17:02:31.446]                       base::local({
[17:02:31.446]                         has_future <- base::requireNamespace("future", 
[17:02:31.446]                           quietly = TRUE)
[17:02:31.446]                         if (has_future) {
[17:02:31.446]                           ns <- base::getNamespace("future")
[17:02:31.446]                           version <- ns[[".package"]][["version"]]
[17:02:31.446]                           if (is.null(version)) 
[17:02:31.446]                             version <- utils::packageVersion("future")
[17:02:31.446]                         }
[17:02:31.446]                         else {
[17:02:31.446]                           version <- NULL
[17:02:31.446]                         }
[17:02:31.446]                         if (!has_future || version < "1.8.0") {
[17:02:31.446]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.446]                             "", base::R.version$version.string), 
[17:02:31.446]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.446]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.446]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.446]                               "release", "version")], collapse = " "), 
[17:02:31.446]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.446]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.446]                             info)
[17:02:31.446]                           info <- base::paste(info, collapse = "; ")
[17:02:31.446]                           if (!has_future) {
[17:02:31.446]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.446]                               info)
[17:02:31.446]                           }
[17:02:31.446]                           else {
[17:02:31.446]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.446]                               info, version)
[17:02:31.446]                           }
[17:02:31.446]                           base::stop(msg)
[17:02:31.446]                         }
[17:02:31.446]                       })
[17:02:31.446]                     }
[17:02:31.446]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.446]                     base::options(mc.cores = 1L)
[17:02:31.446]                   }
[17:02:31.446]                   ...future.strategy.old <- future::plan("list")
[17:02:31.446]                   options(future.plan = NULL)
[17:02:31.446]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.446]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.446]                 }
[17:02:31.446]                 ...future.workdir <- getwd()
[17:02:31.446]             }
[17:02:31.446]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.446]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.446]         }
[17:02:31.446]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.446]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.446]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.446]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.446]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.446]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.446]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.446]             base::names(...future.oldOptions))
[17:02:31.446]     }
[17:02:31.446]     if (FALSE) {
[17:02:31.446]     }
[17:02:31.446]     else {
[17:02:31.446]         if (TRUE) {
[17:02:31.446]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.446]                 open = "w")
[17:02:31.446]         }
[17:02:31.446]         else {
[17:02:31.446]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.446]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.446]         }
[17:02:31.446]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.446]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.446]             base::sink(type = "output", split = FALSE)
[17:02:31.446]             base::close(...future.stdout)
[17:02:31.446]         }, add = TRUE)
[17:02:31.446]     }
[17:02:31.446]     ...future.frame <- base::sys.nframe()
[17:02:31.446]     ...future.conditions <- base::list()
[17:02:31.446]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.446]     if (FALSE) {
[17:02:31.446]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.446]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.446]     }
[17:02:31.446]     ...future.result <- base::tryCatch({
[17:02:31.446]         base::withCallingHandlers({
[17:02:31.446]             ...future.value <- base::withVisible(base::local({
[17:02:31.446]                 ...future.makeSendCondition <- base::local({
[17:02:31.446]                   sendCondition <- NULL
[17:02:31.446]                   function(frame = 1L) {
[17:02:31.446]                     if (is.function(sendCondition)) 
[17:02:31.446]                       return(sendCondition)
[17:02:31.446]                     ns <- getNamespace("parallel")
[17:02:31.446]                     if (exists("sendData", mode = "function", 
[17:02:31.446]                       envir = ns)) {
[17:02:31.446]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:31.446]                         envir = ns)
[17:02:31.446]                       envir <- sys.frame(frame)
[17:02:31.446]                       master <- NULL
[17:02:31.446]                       while (!identical(envir, .GlobalEnv) && 
[17:02:31.446]                         !identical(envir, emptyenv())) {
[17:02:31.446]                         if (exists("master", mode = "list", envir = envir, 
[17:02:31.446]                           inherits = FALSE)) {
[17:02:31.446]                           master <- get("master", mode = "list", 
[17:02:31.446]                             envir = envir, inherits = FALSE)
[17:02:31.446]                           if (inherits(master, c("SOCKnode", 
[17:02:31.446]                             "SOCK0node"))) {
[17:02:31.446]                             sendCondition <<- function(cond) {
[17:02:31.446]                               data <- list(type = "VALUE", value = cond, 
[17:02:31.446]                                 success = TRUE)
[17:02:31.446]                               parallel_sendData(master, data)
[17:02:31.446]                             }
[17:02:31.446]                             return(sendCondition)
[17:02:31.446]                           }
[17:02:31.446]                         }
[17:02:31.446]                         frame <- frame + 1L
[17:02:31.446]                         envir <- sys.frame(frame)
[17:02:31.446]                       }
[17:02:31.446]                     }
[17:02:31.446]                     sendCondition <<- function(cond) NULL
[17:02:31.446]                   }
[17:02:31.446]                 })
[17:02:31.446]                 withCallingHandlers({
[17:02:31.446]                   NA
[17:02:31.446]                 }, immediateCondition = function(cond) {
[17:02:31.446]                   sendCondition <- ...future.makeSendCondition()
[17:02:31.446]                   sendCondition(cond)
[17:02:31.446]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.446]                   {
[17:02:31.446]                     inherits <- base::inherits
[17:02:31.446]                     invokeRestart <- base::invokeRestart
[17:02:31.446]                     is.null <- base::is.null
[17:02:31.446]                     muffled <- FALSE
[17:02:31.446]                     if (inherits(cond, "message")) {
[17:02:31.446]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.446]                       if (muffled) 
[17:02:31.446]                         invokeRestart("muffleMessage")
[17:02:31.446]                     }
[17:02:31.446]                     else if (inherits(cond, "warning")) {
[17:02:31.446]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.446]                       if (muffled) 
[17:02:31.446]                         invokeRestart("muffleWarning")
[17:02:31.446]                     }
[17:02:31.446]                     else if (inherits(cond, "condition")) {
[17:02:31.446]                       if (!is.null(pattern)) {
[17:02:31.446]                         computeRestarts <- base::computeRestarts
[17:02:31.446]                         grepl <- base::grepl
[17:02:31.446]                         restarts <- computeRestarts(cond)
[17:02:31.446]                         for (restart in restarts) {
[17:02:31.446]                           name <- restart$name
[17:02:31.446]                           if (is.null(name)) 
[17:02:31.446]                             next
[17:02:31.446]                           if (!grepl(pattern, name)) 
[17:02:31.446]                             next
[17:02:31.446]                           invokeRestart(restart)
[17:02:31.446]                           muffled <- TRUE
[17:02:31.446]                           break
[17:02:31.446]                         }
[17:02:31.446]                       }
[17:02:31.446]                     }
[17:02:31.446]                     invisible(muffled)
[17:02:31.446]                   }
[17:02:31.446]                   muffleCondition(cond)
[17:02:31.446]                 })
[17:02:31.446]             }))
[17:02:31.446]             future::FutureResult(value = ...future.value$value, 
[17:02:31.446]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.446]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.446]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.446]                     ...future.globalenv.names))
[17:02:31.446]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.446]         }, condition = base::local({
[17:02:31.446]             c <- base::c
[17:02:31.446]             inherits <- base::inherits
[17:02:31.446]             invokeRestart <- base::invokeRestart
[17:02:31.446]             length <- base::length
[17:02:31.446]             list <- base::list
[17:02:31.446]             seq.int <- base::seq.int
[17:02:31.446]             signalCondition <- base::signalCondition
[17:02:31.446]             sys.calls <- base::sys.calls
[17:02:31.446]             `[[` <- base::`[[`
[17:02:31.446]             `+` <- base::`+`
[17:02:31.446]             `<<-` <- base::`<<-`
[17:02:31.446]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.446]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.446]                   3L)]
[17:02:31.446]             }
[17:02:31.446]             function(cond) {
[17:02:31.446]                 is_error <- inherits(cond, "error")
[17:02:31.446]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.446]                   NULL)
[17:02:31.446]                 if (is_error) {
[17:02:31.446]                   sessionInformation <- function() {
[17:02:31.446]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.446]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.446]                       search = base::search(), system = base::Sys.info())
[17:02:31.446]                   }
[17:02:31.446]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.446]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.446]                     cond$call), session = sessionInformation(), 
[17:02:31.446]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.446]                   signalCondition(cond)
[17:02:31.446]                 }
[17:02:31.446]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.446]                 "immediateCondition"))) {
[17:02:31.446]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.446]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.446]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.446]                   if (TRUE && !signal) {
[17:02:31.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.446]                     {
[17:02:31.446]                       inherits <- base::inherits
[17:02:31.446]                       invokeRestart <- base::invokeRestart
[17:02:31.446]                       is.null <- base::is.null
[17:02:31.446]                       muffled <- FALSE
[17:02:31.446]                       if (inherits(cond, "message")) {
[17:02:31.446]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.446]                         if (muffled) 
[17:02:31.446]                           invokeRestart("muffleMessage")
[17:02:31.446]                       }
[17:02:31.446]                       else if (inherits(cond, "warning")) {
[17:02:31.446]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.446]                         if (muffled) 
[17:02:31.446]                           invokeRestart("muffleWarning")
[17:02:31.446]                       }
[17:02:31.446]                       else if (inherits(cond, "condition")) {
[17:02:31.446]                         if (!is.null(pattern)) {
[17:02:31.446]                           computeRestarts <- base::computeRestarts
[17:02:31.446]                           grepl <- base::grepl
[17:02:31.446]                           restarts <- computeRestarts(cond)
[17:02:31.446]                           for (restart in restarts) {
[17:02:31.446]                             name <- restart$name
[17:02:31.446]                             if (is.null(name)) 
[17:02:31.446]                               next
[17:02:31.446]                             if (!grepl(pattern, name)) 
[17:02:31.446]                               next
[17:02:31.446]                             invokeRestart(restart)
[17:02:31.446]                             muffled <- TRUE
[17:02:31.446]                             break
[17:02:31.446]                           }
[17:02:31.446]                         }
[17:02:31.446]                       }
[17:02:31.446]                       invisible(muffled)
[17:02:31.446]                     }
[17:02:31.446]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.446]                   }
[17:02:31.446]                 }
[17:02:31.446]                 else {
[17:02:31.446]                   if (TRUE) {
[17:02:31.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.446]                     {
[17:02:31.446]                       inherits <- base::inherits
[17:02:31.446]                       invokeRestart <- base::invokeRestart
[17:02:31.446]                       is.null <- base::is.null
[17:02:31.446]                       muffled <- FALSE
[17:02:31.446]                       if (inherits(cond, "message")) {
[17:02:31.446]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.446]                         if (muffled) 
[17:02:31.446]                           invokeRestart("muffleMessage")
[17:02:31.446]                       }
[17:02:31.446]                       else if (inherits(cond, "warning")) {
[17:02:31.446]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.446]                         if (muffled) 
[17:02:31.446]                           invokeRestart("muffleWarning")
[17:02:31.446]                       }
[17:02:31.446]                       else if (inherits(cond, "condition")) {
[17:02:31.446]                         if (!is.null(pattern)) {
[17:02:31.446]                           computeRestarts <- base::computeRestarts
[17:02:31.446]                           grepl <- base::grepl
[17:02:31.446]                           restarts <- computeRestarts(cond)
[17:02:31.446]                           for (restart in restarts) {
[17:02:31.446]                             name <- restart$name
[17:02:31.446]                             if (is.null(name)) 
[17:02:31.446]                               next
[17:02:31.446]                             if (!grepl(pattern, name)) 
[17:02:31.446]                               next
[17:02:31.446]                             invokeRestart(restart)
[17:02:31.446]                             muffled <- TRUE
[17:02:31.446]                             break
[17:02:31.446]                           }
[17:02:31.446]                         }
[17:02:31.446]                       }
[17:02:31.446]                       invisible(muffled)
[17:02:31.446]                     }
[17:02:31.446]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.446]                   }
[17:02:31.446]                 }
[17:02:31.446]             }
[17:02:31.446]         }))
[17:02:31.446]     }, error = function(ex) {
[17:02:31.446]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.446]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.446]                 ...future.rng), started = ...future.startTime, 
[17:02:31.446]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.446]             version = "1.8"), class = "FutureResult")
[17:02:31.446]     }, finally = {
[17:02:31.446]         if (!identical(...future.workdir, getwd())) 
[17:02:31.446]             setwd(...future.workdir)
[17:02:31.446]         {
[17:02:31.446]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.446]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.446]             }
[17:02:31.446]             base::options(...future.oldOptions)
[17:02:31.446]             if (.Platform$OS.type == "windows") {
[17:02:31.446]                 old_names <- names(...future.oldEnvVars)
[17:02:31.446]                 envs <- base::Sys.getenv()
[17:02:31.446]                 names <- names(envs)
[17:02:31.446]                 common <- intersect(names, old_names)
[17:02:31.446]                 added <- setdiff(names, old_names)
[17:02:31.446]                 removed <- setdiff(old_names, names)
[17:02:31.446]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.446]                   envs[common]]
[17:02:31.446]                 NAMES <- toupper(changed)
[17:02:31.446]                 args <- list()
[17:02:31.446]                 for (kk in seq_along(NAMES)) {
[17:02:31.446]                   name <- changed[[kk]]
[17:02:31.446]                   NAME <- NAMES[[kk]]
[17:02:31.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.446]                     next
[17:02:31.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.446]                 }
[17:02:31.446]                 NAMES <- toupper(added)
[17:02:31.446]                 for (kk in seq_along(NAMES)) {
[17:02:31.446]                   name <- added[[kk]]
[17:02:31.446]                   NAME <- NAMES[[kk]]
[17:02:31.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.446]                     next
[17:02:31.446]                   args[[name]] <- ""
[17:02:31.446]                 }
[17:02:31.446]                 NAMES <- toupper(removed)
[17:02:31.446]                 for (kk in seq_along(NAMES)) {
[17:02:31.446]                   name <- removed[[kk]]
[17:02:31.446]                   NAME <- NAMES[[kk]]
[17:02:31.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.446]                     next
[17:02:31.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.446]                 }
[17:02:31.446]                 if (length(args) > 0) 
[17:02:31.446]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.446]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.446]             }
[17:02:31.446]             else {
[17:02:31.446]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.446]             }
[17:02:31.446]             {
[17:02:31.446]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.446]                   0L) {
[17:02:31.446]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.446]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.446]                   base::options(opts)
[17:02:31.446]                 }
[17:02:31.446]                 {
[17:02:31.446]                   {
[17:02:31.446]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.446]                     NULL
[17:02:31.446]                   }
[17:02:31.446]                   options(future.plan = NULL)
[17:02:31.446]                   if (is.na(NA_character_)) 
[17:02:31.446]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.446]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.446]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.446]                     .init = FALSE)
[17:02:31.446]                 }
[17:02:31.446]             }
[17:02:31.446]         }
[17:02:31.446]     })
[17:02:31.446]     if (TRUE) {
[17:02:31.446]         base::sink(type = "output", split = FALSE)
[17:02:31.446]         if (TRUE) {
[17:02:31.446]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.446]         }
[17:02:31.446]         else {
[17:02:31.446]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.446]         }
[17:02:31.446]         base::close(...future.stdout)
[17:02:31.446]         ...future.stdout <- NULL
[17:02:31.446]     }
[17:02:31.446]     ...future.result$conditions <- ...future.conditions
[17:02:31.446]     ...future.result$finished <- base::Sys.time()
[17:02:31.446]     ...future.result
[17:02:31.446] }
[17:02:31.500] MultisessionFuture started
[17:02:31.501] result() for ClusterFuture ...
[17:02:31.501] receiveMessageFromWorker() for ClusterFuture ...
[17:02:31.501] - Validating connection of MultisessionFuture
[17:02:31.534] - received message: FutureResult
[17:02:31.534] - Received FutureResult
[17:02:31.534] - Erased future from FutureRegistry
[17:02:31.535] result() for ClusterFuture ...
[17:02:31.535] - result already collected: FutureResult
[17:02:31.535] result() for ClusterFuture ... done
[17:02:31.535] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:31.535] result() for ClusterFuture ... done
[17:02:31.535] result() for ClusterFuture ...
[17:02:31.535] - result already collected: FutureResult
[17:02:31.535] result() for ClusterFuture ... done
[17:02:31.536] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:02:31.539] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:02:31.540] getGlobalsAndPackages() ...
[17:02:31.540] Searching for globals...
[17:02:31.540] 
[17:02:31.540] Searching for globals ... DONE
[17:02:31.540] - globals: [0] <none>
[17:02:31.540] getGlobalsAndPackages() ... DONE
[17:02:31.541] run() for ‘Future’ ...
[17:02:31.541] - state: ‘created’
[17:02:31.541] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.555] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:31.555]   - Field: ‘node’
[17:02:31.555]   - Field: ‘label’
[17:02:31.556]   - Field: ‘local’
[17:02:31.556]   - Field: ‘owner’
[17:02:31.556]   - Field: ‘envir’
[17:02:31.556]   - Field: ‘workers’
[17:02:31.556]   - Field: ‘packages’
[17:02:31.556]   - Field: ‘gc’
[17:02:31.556]   - Field: ‘conditions’
[17:02:31.556]   - Field: ‘persistent’
[17:02:31.556]   - Field: ‘expr’
[17:02:31.557]   - Field: ‘uuid’
[17:02:31.557]   - Field: ‘seed’
[17:02:31.557]   - Field: ‘version’
[17:02:31.557]   - Field: ‘result’
[17:02:31.557]   - Field: ‘asynchronous’
[17:02:31.557]   - Field: ‘calls’
[17:02:31.557]   - Field: ‘globals’
[17:02:31.557]   - Field: ‘stdout’
[17:02:31.557]   - Field: ‘earlySignal’
[17:02:31.557]   - Field: ‘lazy’
[17:02:31.558]   - Field: ‘state’
[17:02:31.558] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:31.558] - Launch lazy future ...
[17:02:31.558] Packages needed by the future expression (n = 0): <none>
[17:02:31.558] Packages needed by future strategies (n = 0): <none>
[17:02:31.559] {
[17:02:31.559]     {
[17:02:31.559]         {
[17:02:31.559]             ...future.startTime <- base::Sys.time()
[17:02:31.559]             {
[17:02:31.559]                 {
[17:02:31.559]                   {
[17:02:31.559]                     {
[17:02:31.559]                       base::local({
[17:02:31.559]                         has_future <- base::requireNamespace("future", 
[17:02:31.559]                           quietly = TRUE)
[17:02:31.559]                         if (has_future) {
[17:02:31.559]                           ns <- base::getNamespace("future")
[17:02:31.559]                           version <- ns[[".package"]][["version"]]
[17:02:31.559]                           if (is.null(version)) 
[17:02:31.559]                             version <- utils::packageVersion("future")
[17:02:31.559]                         }
[17:02:31.559]                         else {
[17:02:31.559]                           version <- NULL
[17:02:31.559]                         }
[17:02:31.559]                         if (!has_future || version < "1.8.0") {
[17:02:31.559]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.559]                             "", base::R.version$version.string), 
[17:02:31.559]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.559]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.559]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.559]                               "release", "version")], collapse = " "), 
[17:02:31.559]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.559]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.559]                             info)
[17:02:31.559]                           info <- base::paste(info, collapse = "; ")
[17:02:31.559]                           if (!has_future) {
[17:02:31.559]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.559]                               info)
[17:02:31.559]                           }
[17:02:31.559]                           else {
[17:02:31.559]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.559]                               info, version)
[17:02:31.559]                           }
[17:02:31.559]                           base::stop(msg)
[17:02:31.559]                         }
[17:02:31.559]                       })
[17:02:31.559]                     }
[17:02:31.559]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.559]                     base::options(mc.cores = 1L)
[17:02:31.559]                   }
[17:02:31.559]                   ...future.strategy.old <- future::plan("list")
[17:02:31.559]                   options(future.plan = NULL)
[17:02:31.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.559]                 }
[17:02:31.559]                 ...future.workdir <- getwd()
[17:02:31.559]             }
[17:02:31.559]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.559]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.559]         }
[17:02:31.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.559]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.559]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.559]             base::names(...future.oldOptions))
[17:02:31.559]     }
[17:02:31.559]     if (FALSE) {
[17:02:31.559]     }
[17:02:31.559]     else {
[17:02:31.559]         if (TRUE) {
[17:02:31.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.559]                 open = "w")
[17:02:31.559]         }
[17:02:31.559]         else {
[17:02:31.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.559]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.559]         }
[17:02:31.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.559]             base::sink(type = "output", split = FALSE)
[17:02:31.559]             base::close(...future.stdout)
[17:02:31.559]         }, add = TRUE)
[17:02:31.559]     }
[17:02:31.559]     ...future.frame <- base::sys.nframe()
[17:02:31.559]     ...future.conditions <- base::list()
[17:02:31.559]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.559]     if (FALSE) {
[17:02:31.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.559]     }
[17:02:31.559]     ...future.result <- base::tryCatch({
[17:02:31.559]         base::withCallingHandlers({
[17:02:31.559]             ...future.value <- base::withVisible(base::local({
[17:02:31.559]                 ...future.makeSendCondition <- base::local({
[17:02:31.559]                   sendCondition <- NULL
[17:02:31.559]                   function(frame = 1L) {
[17:02:31.559]                     if (is.function(sendCondition)) 
[17:02:31.559]                       return(sendCondition)
[17:02:31.559]                     ns <- getNamespace("parallel")
[17:02:31.559]                     if (exists("sendData", mode = "function", 
[17:02:31.559]                       envir = ns)) {
[17:02:31.559]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:31.559]                         envir = ns)
[17:02:31.559]                       envir <- sys.frame(frame)
[17:02:31.559]                       master <- NULL
[17:02:31.559]                       while (!identical(envir, .GlobalEnv) && 
[17:02:31.559]                         !identical(envir, emptyenv())) {
[17:02:31.559]                         if (exists("master", mode = "list", envir = envir, 
[17:02:31.559]                           inherits = FALSE)) {
[17:02:31.559]                           master <- get("master", mode = "list", 
[17:02:31.559]                             envir = envir, inherits = FALSE)
[17:02:31.559]                           if (inherits(master, c("SOCKnode", 
[17:02:31.559]                             "SOCK0node"))) {
[17:02:31.559]                             sendCondition <<- function(cond) {
[17:02:31.559]                               data <- list(type = "VALUE", value = cond, 
[17:02:31.559]                                 success = TRUE)
[17:02:31.559]                               parallel_sendData(master, data)
[17:02:31.559]                             }
[17:02:31.559]                             return(sendCondition)
[17:02:31.559]                           }
[17:02:31.559]                         }
[17:02:31.559]                         frame <- frame + 1L
[17:02:31.559]                         envir <- sys.frame(frame)
[17:02:31.559]                       }
[17:02:31.559]                     }
[17:02:31.559]                     sendCondition <<- function(cond) NULL
[17:02:31.559]                   }
[17:02:31.559]                 })
[17:02:31.559]                 withCallingHandlers({
[17:02:31.559]                   2
[17:02:31.559]                 }, immediateCondition = function(cond) {
[17:02:31.559]                   sendCondition <- ...future.makeSendCondition()
[17:02:31.559]                   sendCondition(cond)
[17:02:31.559]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.559]                   {
[17:02:31.559]                     inherits <- base::inherits
[17:02:31.559]                     invokeRestart <- base::invokeRestart
[17:02:31.559]                     is.null <- base::is.null
[17:02:31.559]                     muffled <- FALSE
[17:02:31.559]                     if (inherits(cond, "message")) {
[17:02:31.559]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.559]                       if (muffled) 
[17:02:31.559]                         invokeRestart("muffleMessage")
[17:02:31.559]                     }
[17:02:31.559]                     else if (inherits(cond, "warning")) {
[17:02:31.559]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.559]                       if (muffled) 
[17:02:31.559]                         invokeRestart("muffleWarning")
[17:02:31.559]                     }
[17:02:31.559]                     else if (inherits(cond, "condition")) {
[17:02:31.559]                       if (!is.null(pattern)) {
[17:02:31.559]                         computeRestarts <- base::computeRestarts
[17:02:31.559]                         grepl <- base::grepl
[17:02:31.559]                         restarts <- computeRestarts(cond)
[17:02:31.559]                         for (restart in restarts) {
[17:02:31.559]                           name <- restart$name
[17:02:31.559]                           if (is.null(name)) 
[17:02:31.559]                             next
[17:02:31.559]                           if (!grepl(pattern, name)) 
[17:02:31.559]                             next
[17:02:31.559]                           invokeRestart(restart)
[17:02:31.559]                           muffled <- TRUE
[17:02:31.559]                           break
[17:02:31.559]                         }
[17:02:31.559]                       }
[17:02:31.559]                     }
[17:02:31.559]                     invisible(muffled)
[17:02:31.559]                   }
[17:02:31.559]                   muffleCondition(cond)
[17:02:31.559]                 })
[17:02:31.559]             }))
[17:02:31.559]             future::FutureResult(value = ...future.value$value, 
[17:02:31.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.559]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.559]                     ...future.globalenv.names))
[17:02:31.559]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.559]         }, condition = base::local({
[17:02:31.559]             c <- base::c
[17:02:31.559]             inherits <- base::inherits
[17:02:31.559]             invokeRestart <- base::invokeRestart
[17:02:31.559]             length <- base::length
[17:02:31.559]             list <- base::list
[17:02:31.559]             seq.int <- base::seq.int
[17:02:31.559]             signalCondition <- base::signalCondition
[17:02:31.559]             sys.calls <- base::sys.calls
[17:02:31.559]             `[[` <- base::`[[`
[17:02:31.559]             `+` <- base::`+`
[17:02:31.559]             `<<-` <- base::`<<-`
[17:02:31.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.559]                   3L)]
[17:02:31.559]             }
[17:02:31.559]             function(cond) {
[17:02:31.559]                 is_error <- inherits(cond, "error")
[17:02:31.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.559]                   NULL)
[17:02:31.559]                 if (is_error) {
[17:02:31.559]                   sessionInformation <- function() {
[17:02:31.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.559]                       search = base::search(), system = base::Sys.info())
[17:02:31.559]                   }
[17:02:31.559]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.559]                     cond$call), session = sessionInformation(), 
[17:02:31.559]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.559]                   signalCondition(cond)
[17:02:31.559]                 }
[17:02:31.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.559]                 "immediateCondition"))) {
[17:02:31.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.559]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.559]                   if (TRUE && !signal) {
[17:02:31.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.559]                     {
[17:02:31.559]                       inherits <- base::inherits
[17:02:31.559]                       invokeRestart <- base::invokeRestart
[17:02:31.559]                       is.null <- base::is.null
[17:02:31.559]                       muffled <- FALSE
[17:02:31.559]                       if (inherits(cond, "message")) {
[17:02:31.559]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.559]                         if (muffled) 
[17:02:31.559]                           invokeRestart("muffleMessage")
[17:02:31.559]                       }
[17:02:31.559]                       else if (inherits(cond, "warning")) {
[17:02:31.559]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.559]                         if (muffled) 
[17:02:31.559]                           invokeRestart("muffleWarning")
[17:02:31.559]                       }
[17:02:31.559]                       else if (inherits(cond, "condition")) {
[17:02:31.559]                         if (!is.null(pattern)) {
[17:02:31.559]                           computeRestarts <- base::computeRestarts
[17:02:31.559]                           grepl <- base::grepl
[17:02:31.559]                           restarts <- computeRestarts(cond)
[17:02:31.559]                           for (restart in restarts) {
[17:02:31.559]                             name <- restart$name
[17:02:31.559]                             if (is.null(name)) 
[17:02:31.559]                               next
[17:02:31.559]                             if (!grepl(pattern, name)) 
[17:02:31.559]                               next
[17:02:31.559]                             invokeRestart(restart)
[17:02:31.559]                             muffled <- TRUE
[17:02:31.559]                             break
[17:02:31.559]                           }
[17:02:31.559]                         }
[17:02:31.559]                       }
[17:02:31.559]                       invisible(muffled)
[17:02:31.559]                     }
[17:02:31.559]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.559]                   }
[17:02:31.559]                 }
[17:02:31.559]                 else {
[17:02:31.559]                   if (TRUE) {
[17:02:31.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.559]                     {
[17:02:31.559]                       inherits <- base::inherits
[17:02:31.559]                       invokeRestart <- base::invokeRestart
[17:02:31.559]                       is.null <- base::is.null
[17:02:31.559]                       muffled <- FALSE
[17:02:31.559]                       if (inherits(cond, "message")) {
[17:02:31.559]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.559]                         if (muffled) 
[17:02:31.559]                           invokeRestart("muffleMessage")
[17:02:31.559]                       }
[17:02:31.559]                       else if (inherits(cond, "warning")) {
[17:02:31.559]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.559]                         if (muffled) 
[17:02:31.559]                           invokeRestart("muffleWarning")
[17:02:31.559]                       }
[17:02:31.559]                       else if (inherits(cond, "condition")) {
[17:02:31.559]                         if (!is.null(pattern)) {
[17:02:31.559]                           computeRestarts <- base::computeRestarts
[17:02:31.559]                           grepl <- base::grepl
[17:02:31.559]                           restarts <- computeRestarts(cond)
[17:02:31.559]                           for (restart in restarts) {
[17:02:31.559]                             name <- restart$name
[17:02:31.559]                             if (is.null(name)) 
[17:02:31.559]                               next
[17:02:31.559]                             if (!grepl(pattern, name)) 
[17:02:31.559]                               next
[17:02:31.559]                             invokeRestart(restart)
[17:02:31.559]                             muffled <- TRUE
[17:02:31.559]                             break
[17:02:31.559]                           }
[17:02:31.559]                         }
[17:02:31.559]                       }
[17:02:31.559]                       invisible(muffled)
[17:02:31.559]                     }
[17:02:31.559]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.559]                   }
[17:02:31.559]                 }
[17:02:31.559]             }
[17:02:31.559]         }))
[17:02:31.559]     }, error = function(ex) {
[17:02:31.559]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.559]                 ...future.rng), started = ...future.startTime, 
[17:02:31.559]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.559]             version = "1.8"), class = "FutureResult")
[17:02:31.559]     }, finally = {
[17:02:31.559]         if (!identical(...future.workdir, getwd())) 
[17:02:31.559]             setwd(...future.workdir)
[17:02:31.559]         {
[17:02:31.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.559]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.559]             }
[17:02:31.559]             base::options(...future.oldOptions)
[17:02:31.559]             if (.Platform$OS.type == "windows") {
[17:02:31.559]                 old_names <- names(...future.oldEnvVars)
[17:02:31.559]                 envs <- base::Sys.getenv()
[17:02:31.559]                 names <- names(envs)
[17:02:31.559]                 common <- intersect(names, old_names)
[17:02:31.559]                 added <- setdiff(names, old_names)
[17:02:31.559]                 removed <- setdiff(old_names, names)
[17:02:31.559]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.559]                   envs[common]]
[17:02:31.559]                 NAMES <- toupper(changed)
[17:02:31.559]                 args <- list()
[17:02:31.559]                 for (kk in seq_along(NAMES)) {
[17:02:31.559]                   name <- changed[[kk]]
[17:02:31.559]                   NAME <- NAMES[[kk]]
[17:02:31.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.559]                     next
[17:02:31.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.559]                 }
[17:02:31.559]                 NAMES <- toupper(added)
[17:02:31.559]                 for (kk in seq_along(NAMES)) {
[17:02:31.559]                   name <- added[[kk]]
[17:02:31.559]                   NAME <- NAMES[[kk]]
[17:02:31.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.559]                     next
[17:02:31.559]                   args[[name]] <- ""
[17:02:31.559]                 }
[17:02:31.559]                 NAMES <- toupper(removed)
[17:02:31.559]                 for (kk in seq_along(NAMES)) {
[17:02:31.559]                   name <- removed[[kk]]
[17:02:31.559]                   NAME <- NAMES[[kk]]
[17:02:31.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.559]                     next
[17:02:31.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.559]                 }
[17:02:31.559]                 if (length(args) > 0) 
[17:02:31.559]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.559]             }
[17:02:31.559]             else {
[17:02:31.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.559]             }
[17:02:31.559]             {
[17:02:31.559]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.559]                   0L) {
[17:02:31.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.559]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.559]                   base::options(opts)
[17:02:31.559]                 }
[17:02:31.559]                 {
[17:02:31.559]                   {
[17:02:31.559]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.559]                     NULL
[17:02:31.559]                   }
[17:02:31.559]                   options(future.plan = NULL)
[17:02:31.559]                   if (is.na(NA_character_)) 
[17:02:31.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.559]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.559]                     .init = FALSE)
[17:02:31.559]                 }
[17:02:31.559]             }
[17:02:31.559]         }
[17:02:31.559]     })
[17:02:31.559]     if (TRUE) {
[17:02:31.559]         base::sink(type = "output", split = FALSE)
[17:02:31.559]         if (TRUE) {
[17:02:31.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.559]         }
[17:02:31.559]         else {
[17:02:31.559]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.559]         }
[17:02:31.559]         base::close(...future.stdout)
[17:02:31.559]         ...future.stdout <- NULL
[17:02:31.559]     }
[17:02:31.559]     ...future.result$conditions <- ...future.conditions
[17:02:31.559]     ...future.result$finished <- base::Sys.time()
[17:02:31.559]     ...future.result
[17:02:31.559] }
[17:02:31.562] MultisessionFuture started
[17:02:31.562] - Launch lazy future ... done
[17:02:31.562] run() for ‘MultisessionFuture’ ... done
[17:02:31.562] getGlobalsAndPackages() ...
[17:02:31.562] Searching for globals...
[17:02:31.563] 
[17:02:31.563] Searching for globals ... DONE
[17:02:31.563] - globals: [0] <none>
[17:02:31.563] getGlobalsAndPackages() ... DONE
[17:02:31.563] run() for ‘Future’ ...
[17:02:31.563] - state: ‘created’
[17:02:31.564] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.578] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.578] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:31.578]   - Field: ‘node’
[17:02:31.579]   - Field: ‘label’
[17:02:31.579]   - Field: ‘local’
[17:02:31.579]   - Field: ‘owner’
[17:02:31.579]   - Field: ‘envir’
[17:02:31.579]   - Field: ‘workers’
[17:02:31.579]   - Field: ‘packages’
[17:02:31.579]   - Field: ‘gc’
[17:02:31.579]   - Field: ‘conditions’
[17:02:31.580]   - Field: ‘persistent’
[17:02:31.580]   - Field: ‘expr’
[17:02:31.580]   - Field: ‘uuid’
[17:02:31.580]   - Field: ‘seed’
[17:02:31.580]   - Field: ‘version’
[17:02:31.580]   - Field: ‘result’
[17:02:31.580]   - Field: ‘asynchronous’
[17:02:31.580]   - Field: ‘calls’
[17:02:31.580]   - Field: ‘globals’
[17:02:31.580]   - Field: ‘stdout’
[17:02:31.581]   - Field: ‘earlySignal’
[17:02:31.581]   - Field: ‘lazy’
[17:02:31.581]   - Field: ‘state’
[17:02:31.581] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:31.581] - Launch lazy future ...
[17:02:31.581] Packages needed by the future expression (n = 0): <none>
[17:02:31.581] Packages needed by future strategies (n = 0): <none>
[17:02:31.582] {
[17:02:31.582]     {
[17:02:31.582]         {
[17:02:31.582]             ...future.startTime <- base::Sys.time()
[17:02:31.582]             {
[17:02:31.582]                 {
[17:02:31.582]                   {
[17:02:31.582]                     {
[17:02:31.582]                       base::local({
[17:02:31.582]                         has_future <- base::requireNamespace("future", 
[17:02:31.582]                           quietly = TRUE)
[17:02:31.582]                         if (has_future) {
[17:02:31.582]                           ns <- base::getNamespace("future")
[17:02:31.582]                           version <- ns[[".package"]][["version"]]
[17:02:31.582]                           if (is.null(version)) 
[17:02:31.582]                             version <- utils::packageVersion("future")
[17:02:31.582]                         }
[17:02:31.582]                         else {
[17:02:31.582]                           version <- NULL
[17:02:31.582]                         }
[17:02:31.582]                         if (!has_future || version < "1.8.0") {
[17:02:31.582]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.582]                             "", base::R.version$version.string), 
[17:02:31.582]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.582]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.582]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.582]                               "release", "version")], collapse = " "), 
[17:02:31.582]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.582]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.582]                             info)
[17:02:31.582]                           info <- base::paste(info, collapse = "; ")
[17:02:31.582]                           if (!has_future) {
[17:02:31.582]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.582]                               info)
[17:02:31.582]                           }
[17:02:31.582]                           else {
[17:02:31.582]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.582]                               info, version)
[17:02:31.582]                           }
[17:02:31.582]                           base::stop(msg)
[17:02:31.582]                         }
[17:02:31.582]                       })
[17:02:31.582]                     }
[17:02:31.582]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.582]                     base::options(mc.cores = 1L)
[17:02:31.582]                   }
[17:02:31.582]                   ...future.strategy.old <- future::plan("list")
[17:02:31.582]                   options(future.plan = NULL)
[17:02:31.582]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.582]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.582]                 }
[17:02:31.582]                 ...future.workdir <- getwd()
[17:02:31.582]             }
[17:02:31.582]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.582]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.582]         }
[17:02:31.582]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.582]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.582]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.582]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.582]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.582]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.582]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.582]             base::names(...future.oldOptions))
[17:02:31.582]     }
[17:02:31.582]     if (FALSE) {
[17:02:31.582]     }
[17:02:31.582]     else {
[17:02:31.582]         if (TRUE) {
[17:02:31.582]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.582]                 open = "w")
[17:02:31.582]         }
[17:02:31.582]         else {
[17:02:31.582]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.582]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.582]         }
[17:02:31.582]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.582]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.582]             base::sink(type = "output", split = FALSE)
[17:02:31.582]             base::close(...future.stdout)
[17:02:31.582]         }, add = TRUE)
[17:02:31.582]     }
[17:02:31.582]     ...future.frame <- base::sys.nframe()
[17:02:31.582]     ...future.conditions <- base::list()
[17:02:31.582]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.582]     if (FALSE) {
[17:02:31.582]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.582]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.582]     }
[17:02:31.582]     ...future.result <- base::tryCatch({
[17:02:31.582]         base::withCallingHandlers({
[17:02:31.582]             ...future.value <- base::withVisible(base::local({
[17:02:31.582]                 ...future.makeSendCondition <- base::local({
[17:02:31.582]                   sendCondition <- NULL
[17:02:31.582]                   function(frame = 1L) {
[17:02:31.582]                     if (is.function(sendCondition)) 
[17:02:31.582]                       return(sendCondition)
[17:02:31.582]                     ns <- getNamespace("parallel")
[17:02:31.582]                     if (exists("sendData", mode = "function", 
[17:02:31.582]                       envir = ns)) {
[17:02:31.582]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:31.582]                         envir = ns)
[17:02:31.582]                       envir <- sys.frame(frame)
[17:02:31.582]                       master <- NULL
[17:02:31.582]                       while (!identical(envir, .GlobalEnv) && 
[17:02:31.582]                         !identical(envir, emptyenv())) {
[17:02:31.582]                         if (exists("master", mode = "list", envir = envir, 
[17:02:31.582]                           inherits = FALSE)) {
[17:02:31.582]                           master <- get("master", mode = "list", 
[17:02:31.582]                             envir = envir, inherits = FALSE)
[17:02:31.582]                           if (inherits(master, c("SOCKnode", 
[17:02:31.582]                             "SOCK0node"))) {
[17:02:31.582]                             sendCondition <<- function(cond) {
[17:02:31.582]                               data <- list(type = "VALUE", value = cond, 
[17:02:31.582]                                 success = TRUE)
[17:02:31.582]                               parallel_sendData(master, data)
[17:02:31.582]                             }
[17:02:31.582]                             return(sendCondition)
[17:02:31.582]                           }
[17:02:31.582]                         }
[17:02:31.582]                         frame <- frame + 1L
[17:02:31.582]                         envir <- sys.frame(frame)
[17:02:31.582]                       }
[17:02:31.582]                     }
[17:02:31.582]                     sendCondition <<- function(cond) NULL
[17:02:31.582]                   }
[17:02:31.582]                 })
[17:02:31.582]                 withCallingHandlers({
[17:02:31.582]                   NULL
[17:02:31.582]                 }, immediateCondition = function(cond) {
[17:02:31.582]                   sendCondition <- ...future.makeSendCondition()
[17:02:31.582]                   sendCondition(cond)
[17:02:31.582]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.582]                   {
[17:02:31.582]                     inherits <- base::inherits
[17:02:31.582]                     invokeRestart <- base::invokeRestart
[17:02:31.582]                     is.null <- base::is.null
[17:02:31.582]                     muffled <- FALSE
[17:02:31.582]                     if (inherits(cond, "message")) {
[17:02:31.582]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.582]                       if (muffled) 
[17:02:31.582]                         invokeRestart("muffleMessage")
[17:02:31.582]                     }
[17:02:31.582]                     else if (inherits(cond, "warning")) {
[17:02:31.582]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.582]                       if (muffled) 
[17:02:31.582]                         invokeRestart("muffleWarning")
[17:02:31.582]                     }
[17:02:31.582]                     else if (inherits(cond, "condition")) {
[17:02:31.582]                       if (!is.null(pattern)) {
[17:02:31.582]                         computeRestarts <- base::computeRestarts
[17:02:31.582]                         grepl <- base::grepl
[17:02:31.582]                         restarts <- computeRestarts(cond)
[17:02:31.582]                         for (restart in restarts) {
[17:02:31.582]                           name <- restart$name
[17:02:31.582]                           if (is.null(name)) 
[17:02:31.582]                             next
[17:02:31.582]                           if (!grepl(pattern, name)) 
[17:02:31.582]                             next
[17:02:31.582]                           invokeRestart(restart)
[17:02:31.582]                           muffled <- TRUE
[17:02:31.582]                           break
[17:02:31.582]                         }
[17:02:31.582]                       }
[17:02:31.582]                     }
[17:02:31.582]                     invisible(muffled)
[17:02:31.582]                   }
[17:02:31.582]                   muffleCondition(cond)
[17:02:31.582]                 })
[17:02:31.582]             }))
[17:02:31.582]             future::FutureResult(value = ...future.value$value, 
[17:02:31.582]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.582]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.582]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.582]                     ...future.globalenv.names))
[17:02:31.582]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.582]         }, condition = base::local({
[17:02:31.582]             c <- base::c
[17:02:31.582]             inherits <- base::inherits
[17:02:31.582]             invokeRestart <- base::invokeRestart
[17:02:31.582]             length <- base::length
[17:02:31.582]             list <- base::list
[17:02:31.582]             seq.int <- base::seq.int
[17:02:31.582]             signalCondition <- base::signalCondition
[17:02:31.582]             sys.calls <- base::sys.calls
[17:02:31.582]             `[[` <- base::`[[`
[17:02:31.582]             `+` <- base::`+`
[17:02:31.582]             `<<-` <- base::`<<-`
[17:02:31.582]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.582]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.582]                   3L)]
[17:02:31.582]             }
[17:02:31.582]             function(cond) {
[17:02:31.582]                 is_error <- inherits(cond, "error")
[17:02:31.582]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.582]                   NULL)
[17:02:31.582]                 if (is_error) {
[17:02:31.582]                   sessionInformation <- function() {
[17:02:31.582]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.582]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.582]                       search = base::search(), system = base::Sys.info())
[17:02:31.582]                   }
[17:02:31.582]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.582]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.582]                     cond$call), session = sessionInformation(), 
[17:02:31.582]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.582]                   signalCondition(cond)
[17:02:31.582]                 }
[17:02:31.582]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.582]                 "immediateCondition"))) {
[17:02:31.582]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.582]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.582]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.582]                   if (TRUE && !signal) {
[17:02:31.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.582]                     {
[17:02:31.582]                       inherits <- base::inherits
[17:02:31.582]                       invokeRestart <- base::invokeRestart
[17:02:31.582]                       is.null <- base::is.null
[17:02:31.582]                       muffled <- FALSE
[17:02:31.582]                       if (inherits(cond, "message")) {
[17:02:31.582]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.582]                         if (muffled) 
[17:02:31.582]                           invokeRestart("muffleMessage")
[17:02:31.582]                       }
[17:02:31.582]                       else if (inherits(cond, "warning")) {
[17:02:31.582]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.582]                         if (muffled) 
[17:02:31.582]                           invokeRestart("muffleWarning")
[17:02:31.582]                       }
[17:02:31.582]                       else if (inherits(cond, "condition")) {
[17:02:31.582]                         if (!is.null(pattern)) {
[17:02:31.582]                           computeRestarts <- base::computeRestarts
[17:02:31.582]                           grepl <- base::grepl
[17:02:31.582]                           restarts <- computeRestarts(cond)
[17:02:31.582]                           for (restart in restarts) {
[17:02:31.582]                             name <- restart$name
[17:02:31.582]                             if (is.null(name)) 
[17:02:31.582]                               next
[17:02:31.582]                             if (!grepl(pattern, name)) 
[17:02:31.582]                               next
[17:02:31.582]                             invokeRestart(restart)
[17:02:31.582]                             muffled <- TRUE
[17:02:31.582]                             break
[17:02:31.582]                           }
[17:02:31.582]                         }
[17:02:31.582]                       }
[17:02:31.582]                       invisible(muffled)
[17:02:31.582]                     }
[17:02:31.582]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.582]                   }
[17:02:31.582]                 }
[17:02:31.582]                 else {
[17:02:31.582]                   if (TRUE) {
[17:02:31.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.582]                     {
[17:02:31.582]                       inherits <- base::inherits
[17:02:31.582]                       invokeRestart <- base::invokeRestart
[17:02:31.582]                       is.null <- base::is.null
[17:02:31.582]                       muffled <- FALSE
[17:02:31.582]                       if (inherits(cond, "message")) {
[17:02:31.582]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.582]                         if (muffled) 
[17:02:31.582]                           invokeRestart("muffleMessage")
[17:02:31.582]                       }
[17:02:31.582]                       else if (inherits(cond, "warning")) {
[17:02:31.582]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.582]                         if (muffled) 
[17:02:31.582]                           invokeRestart("muffleWarning")
[17:02:31.582]                       }
[17:02:31.582]                       else if (inherits(cond, "condition")) {
[17:02:31.582]                         if (!is.null(pattern)) {
[17:02:31.582]                           computeRestarts <- base::computeRestarts
[17:02:31.582]                           grepl <- base::grepl
[17:02:31.582]                           restarts <- computeRestarts(cond)
[17:02:31.582]                           for (restart in restarts) {
[17:02:31.582]                             name <- restart$name
[17:02:31.582]                             if (is.null(name)) 
[17:02:31.582]                               next
[17:02:31.582]                             if (!grepl(pattern, name)) 
[17:02:31.582]                               next
[17:02:31.582]                             invokeRestart(restart)
[17:02:31.582]                             muffled <- TRUE
[17:02:31.582]                             break
[17:02:31.582]                           }
[17:02:31.582]                         }
[17:02:31.582]                       }
[17:02:31.582]                       invisible(muffled)
[17:02:31.582]                     }
[17:02:31.582]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.582]                   }
[17:02:31.582]                 }
[17:02:31.582]             }
[17:02:31.582]         }))
[17:02:31.582]     }, error = function(ex) {
[17:02:31.582]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.582]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.582]                 ...future.rng), started = ...future.startTime, 
[17:02:31.582]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.582]             version = "1.8"), class = "FutureResult")
[17:02:31.582]     }, finally = {
[17:02:31.582]         if (!identical(...future.workdir, getwd())) 
[17:02:31.582]             setwd(...future.workdir)
[17:02:31.582]         {
[17:02:31.582]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.582]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.582]             }
[17:02:31.582]             base::options(...future.oldOptions)
[17:02:31.582]             if (.Platform$OS.type == "windows") {
[17:02:31.582]                 old_names <- names(...future.oldEnvVars)
[17:02:31.582]                 envs <- base::Sys.getenv()
[17:02:31.582]                 names <- names(envs)
[17:02:31.582]                 common <- intersect(names, old_names)
[17:02:31.582]                 added <- setdiff(names, old_names)
[17:02:31.582]                 removed <- setdiff(old_names, names)
[17:02:31.582]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.582]                   envs[common]]
[17:02:31.582]                 NAMES <- toupper(changed)
[17:02:31.582]                 args <- list()
[17:02:31.582]                 for (kk in seq_along(NAMES)) {
[17:02:31.582]                   name <- changed[[kk]]
[17:02:31.582]                   NAME <- NAMES[[kk]]
[17:02:31.582]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.582]                     next
[17:02:31.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.582]                 }
[17:02:31.582]                 NAMES <- toupper(added)
[17:02:31.582]                 for (kk in seq_along(NAMES)) {
[17:02:31.582]                   name <- added[[kk]]
[17:02:31.582]                   NAME <- NAMES[[kk]]
[17:02:31.582]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.582]                     next
[17:02:31.582]                   args[[name]] <- ""
[17:02:31.582]                 }
[17:02:31.582]                 NAMES <- toupper(removed)
[17:02:31.582]                 for (kk in seq_along(NAMES)) {
[17:02:31.582]                   name <- removed[[kk]]
[17:02:31.582]                   NAME <- NAMES[[kk]]
[17:02:31.582]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.582]                     next
[17:02:31.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.582]                 }
[17:02:31.582]                 if (length(args) > 0) 
[17:02:31.582]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.582]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.582]             }
[17:02:31.582]             else {
[17:02:31.582]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.582]             }
[17:02:31.582]             {
[17:02:31.582]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.582]                   0L) {
[17:02:31.582]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.582]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.582]                   base::options(opts)
[17:02:31.582]                 }
[17:02:31.582]                 {
[17:02:31.582]                   {
[17:02:31.582]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.582]                     NULL
[17:02:31.582]                   }
[17:02:31.582]                   options(future.plan = NULL)
[17:02:31.582]                   if (is.na(NA_character_)) 
[17:02:31.582]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.582]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.582]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.582]                     .init = FALSE)
[17:02:31.582]                 }
[17:02:31.582]             }
[17:02:31.582]         }
[17:02:31.582]     })
[17:02:31.582]     if (TRUE) {
[17:02:31.582]         base::sink(type = "output", split = FALSE)
[17:02:31.582]         if (TRUE) {
[17:02:31.582]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.582]         }
[17:02:31.582]         else {
[17:02:31.582]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.582]         }
[17:02:31.582]         base::close(...future.stdout)
[17:02:31.582]         ...future.stdout <- NULL
[17:02:31.582]     }
[17:02:31.582]     ...future.result$conditions <- ...future.conditions
[17:02:31.582]     ...future.result$finished <- base::Sys.time()
[17:02:31.582]     ...future.result
[17:02:31.582] }
[17:02:31.635] MultisessionFuture started
[17:02:31.636] - Launch lazy future ... done
[17:02:31.636] run() for ‘MultisessionFuture’ ... done
[17:02:31.636] getGlobalsAndPackages() ...
[17:02:31.637] Searching for globals...
[17:02:31.638] - globals found: [1] ‘{’
[17:02:31.638] Searching for globals ... DONE
[17:02:31.638] Resolving globals: FALSE
[17:02:31.639] 
[17:02:31.639] 
[17:02:31.639] getGlobalsAndPackages() ... DONE
[17:02:31.639] run() for ‘Future’ ...
[17:02:31.640] - state: ‘created’
[17:02:31.640] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.659] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.660] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:31.660]   - Field: ‘node’
[17:02:31.660]   - Field: ‘label’
[17:02:31.660]   - Field: ‘local’
[17:02:31.660]   - Field: ‘owner’
[17:02:31.660]   - Field: ‘envir’
[17:02:31.661]   - Field: ‘workers’
[17:02:31.661]   - Field: ‘packages’
[17:02:31.661]   - Field: ‘gc’
[17:02:31.661]   - Field: ‘conditions’
[17:02:31.661]   - Field: ‘persistent’
[17:02:31.661]   - Field: ‘expr’
[17:02:31.662]   - Field: ‘uuid’
[17:02:31.662]   - Field: ‘seed’
[17:02:31.662]   - Field: ‘version’
[17:02:31.662]   - Field: ‘result’
[17:02:31.662]   - Field: ‘asynchronous’
[17:02:31.662]   - Field: ‘calls’
[17:02:31.663]   - Field: ‘globals’
[17:02:31.663]   - Field: ‘stdout’
[17:02:31.663]   - Field: ‘earlySignal’
[17:02:31.663]   - Field: ‘lazy’
[17:02:31.663]   - Field: ‘state’
[17:02:31.663] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:31.664] - Launch lazy future ...
[17:02:31.664] Packages needed by the future expression (n = 0): <none>
[17:02:31.664] Packages needed by future strategies (n = 0): <none>
[17:02:31.665] {
[17:02:31.665]     {
[17:02:31.665]         {
[17:02:31.665]             ...future.startTime <- base::Sys.time()
[17:02:31.665]             {
[17:02:31.665]                 {
[17:02:31.665]                   {
[17:02:31.665]                     {
[17:02:31.665]                       base::local({
[17:02:31.665]                         has_future <- base::requireNamespace("future", 
[17:02:31.665]                           quietly = TRUE)
[17:02:31.665]                         if (has_future) {
[17:02:31.665]                           ns <- base::getNamespace("future")
[17:02:31.665]                           version <- ns[[".package"]][["version"]]
[17:02:31.665]                           if (is.null(version)) 
[17:02:31.665]                             version <- utils::packageVersion("future")
[17:02:31.665]                         }
[17:02:31.665]                         else {
[17:02:31.665]                           version <- NULL
[17:02:31.665]                         }
[17:02:31.665]                         if (!has_future || version < "1.8.0") {
[17:02:31.665]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.665]                             "", base::R.version$version.string), 
[17:02:31.665]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.665]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.665]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.665]                               "release", "version")], collapse = " "), 
[17:02:31.665]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.665]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.665]                             info)
[17:02:31.665]                           info <- base::paste(info, collapse = "; ")
[17:02:31.665]                           if (!has_future) {
[17:02:31.665]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.665]                               info)
[17:02:31.665]                           }
[17:02:31.665]                           else {
[17:02:31.665]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.665]                               info, version)
[17:02:31.665]                           }
[17:02:31.665]                           base::stop(msg)
[17:02:31.665]                         }
[17:02:31.665]                       })
[17:02:31.665]                     }
[17:02:31.665]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.665]                     base::options(mc.cores = 1L)
[17:02:31.665]                   }
[17:02:31.665]                   ...future.strategy.old <- future::plan("list")
[17:02:31.665]                   options(future.plan = NULL)
[17:02:31.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.665]                 }
[17:02:31.665]                 ...future.workdir <- getwd()
[17:02:31.665]             }
[17:02:31.665]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.665]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.665]         }
[17:02:31.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.665]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.665]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.665]             base::names(...future.oldOptions))
[17:02:31.665]     }
[17:02:31.665]     if (FALSE) {
[17:02:31.665]     }
[17:02:31.665]     else {
[17:02:31.665]         if (TRUE) {
[17:02:31.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.665]                 open = "w")
[17:02:31.665]         }
[17:02:31.665]         else {
[17:02:31.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.665]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.665]         }
[17:02:31.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.665]             base::sink(type = "output", split = FALSE)
[17:02:31.665]             base::close(...future.stdout)
[17:02:31.665]         }, add = TRUE)
[17:02:31.665]     }
[17:02:31.665]     ...future.frame <- base::sys.nframe()
[17:02:31.665]     ...future.conditions <- base::list()
[17:02:31.665]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.665]     if (FALSE) {
[17:02:31.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.665]     }
[17:02:31.665]     ...future.result <- base::tryCatch({
[17:02:31.665]         base::withCallingHandlers({
[17:02:31.665]             ...future.value <- base::withVisible(base::local({
[17:02:31.665]                 ...future.makeSendCondition <- base::local({
[17:02:31.665]                   sendCondition <- NULL
[17:02:31.665]                   function(frame = 1L) {
[17:02:31.665]                     if (is.function(sendCondition)) 
[17:02:31.665]                       return(sendCondition)
[17:02:31.665]                     ns <- getNamespace("parallel")
[17:02:31.665]                     if (exists("sendData", mode = "function", 
[17:02:31.665]                       envir = ns)) {
[17:02:31.665]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:31.665]                         envir = ns)
[17:02:31.665]                       envir <- sys.frame(frame)
[17:02:31.665]                       master <- NULL
[17:02:31.665]                       while (!identical(envir, .GlobalEnv) && 
[17:02:31.665]                         !identical(envir, emptyenv())) {
[17:02:31.665]                         if (exists("master", mode = "list", envir = envir, 
[17:02:31.665]                           inherits = FALSE)) {
[17:02:31.665]                           master <- get("master", mode = "list", 
[17:02:31.665]                             envir = envir, inherits = FALSE)
[17:02:31.665]                           if (inherits(master, c("SOCKnode", 
[17:02:31.665]                             "SOCK0node"))) {
[17:02:31.665]                             sendCondition <<- function(cond) {
[17:02:31.665]                               data <- list(type = "VALUE", value = cond, 
[17:02:31.665]                                 success = TRUE)
[17:02:31.665]                               parallel_sendData(master, data)
[17:02:31.665]                             }
[17:02:31.665]                             return(sendCondition)
[17:02:31.665]                           }
[17:02:31.665]                         }
[17:02:31.665]                         frame <- frame + 1L
[17:02:31.665]                         envir <- sys.frame(frame)
[17:02:31.665]                       }
[17:02:31.665]                     }
[17:02:31.665]                     sendCondition <<- function(cond) NULL
[17:02:31.665]                   }
[17:02:31.665]                 })
[17:02:31.665]                 withCallingHandlers({
[17:02:31.665]                   {
[17:02:31.665]                     4
[17:02:31.665]                   }
[17:02:31.665]                 }, immediateCondition = function(cond) {
[17:02:31.665]                   sendCondition <- ...future.makeSendCondition()
[17:02:31.665]                   sendCondition(cond)
[17:02:31.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.665]                   {
[17:02:31.665]                     inherits <- base::inherits
[17:02:31.665]                     invokeRestart <- base::invokeRestart
[17:02:31.665]                     is.null <- base::is.null
[17:02:31.665]                     muffled <- FALSE
[17:02:31.665]                     if (inherits(cond, "message")) {
[17:02:31.665]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.665]                       if (muffled) 
[17:02:31.665]                         invokeRestart("muffleMessage")
[17:02:31.665]                     }
[17:02:31.665]                     else if (inherits(cond, "warning")) {
[17:02:31.665]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.665]                       if (muffled) 
[17:02:31.665]                         invokeRestart("muffleWarning")
[17:02:31.665]                     }
[17:02:31.665]                     else if (inherits(cond, "condition")) {
[17:02:31.665]                       if (!is.null(pattern)) {
[17:02:31.665]                         computeRestarts <- base::computeRestarts
[17:02:31.665]                         grepl <- base::grepl
[17:02:31.665]                         restarts <- computeRestarts(cond)
[17:02:31.665]                         for (restart in restarts) {
[17:02:31.665]                           name <- restart$name
[17:02:31.665]                           if (is.null(name)) 
[17:02:31.665]                             next
[17:02:31.665]                           if (!grepl(pattern, name)) 
[17:02:31.665]                             next
[17:02:31.665]                           invokeRestart(restart)
[17:02:31.665]                           muffled <- TRUE
[17:02:31.665]                           break
[17:02:31.665]                         }
[17:02:31.665]                       }
[17:02:31.665]                     }
[17:02:31.665]                     invisible(muffled)
[17:02:31.665]                   }
[17:02:31.665]                   muffleCondition(cond)
[17:02:31.665]                 })
[17:02:31.665]             }))
[17:02:31.665]             future::FutureResult(value = ...future.value$value, 
[17:02:31.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.665]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.665]                     ...future.globalenv.names))
[17:02:31.665]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.665]         }, condition = base::local({
[17:02:31.665]             c <- base::c
[17:02:31.665]             inherits <- base::inherits
[17:02:31.665]             invokeRestart <- base::invokeRestart
[17:02:31.665]             length <- base::length
[17:02:31.665]             list <- base::list
[17:02:31.665]             seq.int <- base::seq.int
[17:02:31.665]             signalCondition <- base::signalCondition
[17:02:31.665]             sys.calls <- base::sys.calls
[17:02:31.665]             `[[` <- base::`[[`
[17:02:31.665]             `+` <- base::`+`
[17:02:31.665]             `<<-` <- base::`<<-`
[17:02:31.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.665]                   3L)]
[17:02:31.665]             }
[17:02:31.665]             function(cond) {
[17:02:31.665]                 is_error <- inherits(cond, "error")
[17:02:31.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.665]                   NULL)
[17:02:31.665]                 if (is_error) {
[17:02:31.665]                   sessionInformation <- function() {
[17:02:31.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.665]                       search = base::search(), system = base::Sys.info())
[17:02:31.665]                   }
[17:02:31.665]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.665]                     cond$call), session = sessionInformation(), 
[17:02:31.665]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.665]                   signalCondition(cond)
[17:02:31.665]                 }
[17:02:31.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.665]                 "immediateCondition"))) {
[17:02:31.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.665]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.665]                   if (TRUE && !signal) {
[17:02:31.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.665]                     {
[17:02:31.665]                       inherits <- base::inherits
[17:02:31.665]                       invokeRestart <- base::invokeRestart
[17:02:31.665]                       is.null <- base::is.null
[17:02:31.665]                       muffled <- FALSE
[17:02:31.665]                       if (inherits(cond, "message")) {
[17:02:31.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.665]                         if (muffled) 
[17:02:31.665]                           invokeRestart("muffleMessage")
[17:02:31.665]                       }
[17:02:31.665]                       else if (inherits(cond, "warning")) {
[17:02:31.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.665]                         if (muffled) 
[17:02:31.665]                           invokeRestart("muffleWarning")
[17:02:31.665]                       }
[17:02:31.665]                       else if (inherits(cond, "condition")) {
[17:02:31.665]                         if (!is.null(pattern)) {
[17:02:31.665]                           computeRestarts <- base::computeRestarts
[17:02:31.665]                           grepl <- base::grepl
[17:02:31.665]                           restarts <- computeRestarts(cond)
[17:02:31.665]                           for (restart in restarts) {
[17:02:31.665]                             name <- restart$name
[17:02:31.665]                             if (is.null(name)) 
[17:02:31.665]                               next
[17:02:31.665]                             if (!grepl(pattern, name)) 
[17:02:31.665]                               next
[17:02:31.665]                             invokeRestart(restart)
[17:02:31.665]                             muffled <- TRUE
[17:02:31.665]                             break
[17:02:31.665]                           }
[17:02:31.665]                         }
[17:02:31.665]                       }
[17:02:31.665]                       invisible(muffled)
[17:02:31.665]                     }
[17:02:31.665]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.665]                   }
[17:02:31.665]                 }
[17:02:31.665]                 else {
[17:02:31.665]                   if (TRUE) {
[17:02:31.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.665]                     {
[17:02:31.665]                       inherits <- base::inherits
[17:02:31.665]                       invokeRestart <- base::invokeRestart
[17:02:31.665]                       is.null <- base::is.null
[17:02:31.665]                       muffled <- FALSE
[17:02:31.665]                       if (inherits(cond, "message")) {
[17:02:31.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.665]                         if (muffled) 
[17:02:31.665]                           invokeRestart("muffleMessage")
[17:02:31.665]                       }
[17:02:31.665]                       else if (inherits(cond, "warning")) {
[17:02:31.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.665]                         if (muffled) 
[17:02:31.665]                           invokeRestart("muffleWarning")
[17:02:31.665]                       }
[17:02:31.665]                       else if (inherits(cond, "condition")) {
[17:02:31.665]                         if (!is.null(pattern)) {
[17:02:31.665]                           computeRestarts <- base::computeRestarts
[17:02:31.665]                           grepl <- base::grepl
[17:02:31.665]                           restarts <- computeRestarts(cond)
[17:02:31.665]                           for (restart in restarts) {
[17:02:31.665]                             name <- restart$name
[17:02:31.665]                             if (is.null(name)) 
[17:02:31.665]                               next
[17:02:31.665]                             if (!grepl(pattern, name)) 
[17:02:31.665]                               next
[17:02:31.665]                             invokeRestart(restart)
[17:02:31.665]                             muffled <- TRUE
[17:02:31.665]                             break
[17:02:31.665]                           }
[17:02:31.665]                         }
[17:02:31.665]                       }
[17:02:31.665]                       invisible(muffled)
[17:02:31.665]                     }
[17:02:31.665]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.665]                   }
[17:02:31.665]                 }
[17:02:31.665]             }
[17:02:31.665]         }))
[17:02:31.665]     }, error = function(ex) {
[17:02:31.665]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.665]                 ...future.rng), started = ...future.startTime, 
[17:02:31.665]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.665]             version = "1.8"), class = "FutureResult")
[17:02:31.665]     }, finally = {
[17:02:31.665]         if (!identical(...future.workdir, getwd())) 
[17:02:31.665]             setwd(...future.workdir)
[17:02:31.665]         {
[17:02:31.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.665]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.665]             }
[17:02:31.665]             base::options(...future.oldOptions)
[17:02:31.665]             if (.Platform$OS.type == "windows") {
[17:02:31.665]                 old_names <- names(...future.oldEnvVars)
[17:02:31.665]                 envs <- base::Sys.getenv()
[17:02:31.665]                 names <- names(envs)
[17:02:31.665]                 common <- intersect(names, old_names)
[17:02:31.665]                 added <- setdiff(names, old_names)
[17:02:31.665]                 removed <- setdiff(old_names, names)
[17:02:31.665]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.665]                   envs[common]]
[17:02:31.665]                 NAMES <- toupper(changed)
[17:02:31.665]                 args <- list()
[17:02:31.665]                 for (kk in seq_along(NAMES)) {
[17:02:31.665]                   name <- changed[[kk]]
[17:02:31.665]                   NAME <- NAMES[[kk]]
[17:02:31.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.665]                     next
[17:02:31.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.665]                 }
[17:02:31.665]                 NAMES <- toupper(added)
[17:02:31.665]                 for (kk in seq_along(NAMES)) {
[17:02:31.665]                   name <- added[[kk]]
[17:02:31.665]                   NAME <- NAMES[[kk]]
[17:02:31.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.665]                     next
[17:02:31.665]                   args[[name]] <- ""
[17:02:31.665]                 }
[17:02:31.665]                 NAMES <- toupper(removed)
[17:02:31.665]                 for (kk in seq_along(NAMES)) {
[17:02:31.665]                   name <- removed[[kk]]
[17:02:31.665]                   NAME <- NAMES[[kk]]
[17:02:31.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.665]                     next
[17:02:31.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.665]                 }
[17:02:31.665]                 if (length(args) > 0) 
[17:02:31.665]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.665]             }
[17:02:31.665]             else {
[17:02:31.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.665]             }
[17:02:31.665]             {
[17:02:31.665]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.665]                   0L) {
[17:02:31.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.665]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.665]                   base::options(opts)
[17:02:31.665]                 }
[17:02:31.665]                 {
[17:02:31.665]                   {
[17:02:31.665]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.665]                     NULL
[17:02:31.665]                   }
[17:02:31.665]                   options(future.plan = NULL)
[17:02:31.665]                   if (is.na(NA_character_)) 
[17:02:31.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.665]                     .init = FALSE)
[17:02:31.665]                 }
[17:02:31.665]             }
[17:02:31.665]         }
[17:02:31.665]     })
[17:02:31.665]     if (TRUE) {
[17:02:31.665]         base::sink(type = "output", split = FALSE)
[17:02:31.665]         if (TRUE) {
[17:02:31.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.665]         }
[17:02:31.665]         else {
[17:02:31.665]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.665]         }
[17:02:31.665]         base::close(...future.stdout)
[17:02:31.665]         ...future.stdout <- NULL
[17:02:31.665]     }
[17:02:31.665]     ...future.result$conditions <- ...future.conditions
[17:02:31.665]     ...future.result$finished <- base::Sys.time()
[17:02:31.665]     ...future.result
[17:02:31.665] }
[17:02:31.669] Poll #1 (0): usedNodes() = 2, workers = 2
[17:02:31.680] receiveMessageFromWorker() for ClusterFuture ...
[17:02:31.680] - Validating connection of MultisessionFuture
[17:02:31.680] - received message: FutureResult
[17:02:31.681] - Received FutureResult
[17:02:31.681] - Erased future from FutureRegistry
[17:02:31.681] result() for ClusterFuture ...
[17:02:31.681] - result already collected: FutureResult
[17:02:31.681] result() for ClusterFuture ... done
[17:02:31.681] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:31.682] result() for ClusterFuture ...
[17:02:31.682] - result already collected: FutureResult
[17:02:31.682] result() for ClusterFuture ... done
[17:02:31.682] result() for ClusterFuture ...
[17:02:31.682] - result already collected: FutureResult
[17:02:31.682] result() for ClusterFuture ... done
[17:02:31.683] MultisessionFuture started
[17:02:31.684] - Launch lazy future ... done
[17:02:31.684] run() for ‘MultisessionFuture’ ... done
<environment: 0x55c749de46a0> 
<environment: 0x55c74a248758> 
[17:02:31.685] receiveMessageFromWorker() for ClusterFuture ...
[17:02:31.686] - Validating connection of MultisessionFuture
[17:02:31.686] - received message: FutureResult
[17:02:31.686] - Received FutureResult
[17:02:31.686] - Erased future from FutureRegistry
[17:02:31.686] result() for ClusterFuture ...
[17:02:31.686] - result already collected: FutureResult
[17:02:31.686] result() for ClusterFuture ... done
[17:02:31.686] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:31.689] receiveMessageFromWorker() for ClusterFuture ...
[17:02:31.689] - Validating connection of MultisessionFuture
[17:02:31.689] - received message: FutureResult
[17:02:31.689] - Received FutureResult
[17:02:31.689] - Erased future from FutureRegistry
[17:02:31.689] result() for ClusterFuture ...
[17:02:31.689] - result already collected: FutureResult
[17:02:31.690] result() for ClusterFuture ... done
[17:02:31.690] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:31.691] resolve() on environment ...
[17:02:31.691]  recursive: 0
[17:02:31.691]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:31.692] signalConditionsASAP(numeric, pos=1) ...
[17:02:31.692] - nx: 4
[17:02:31.692] - relay: TRUE
[17:02:31.692] - stdout: TRUE
[17:02:31.692] - signal: TRUE
[17:02:31.692] - resignal: FALSE
[17:02:31.692] - force: TRUE
[17:02:31.692] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.692] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.692]  - until=2
[17:02:31.692]  - relaying element #2
[17:02:31.692] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:31.693] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.693] signalConditionsASAP(NULL, pos=1) ... done
[17:02:31.693]  length: 3 (resolved future 1)
[17:02:31.693] Future #2
[17:02:31.693] result() for ClusterFuture ...
[17:02:31.693] - result already collected: FutureResult
[17:02:31.693] result() for ClusterFuture ... done
[17:02:31.693] result() for ClusterFuture ...
[17:02:31.693] - result already collected: FutureResult
[17:02:31.693] result() for ClusterFuture ... done
[17:02:31.694] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:31.694] - nx: 4
[17:02:31.694] - relay: TRUE
[17:02:31.694] - stdout: TRUE
[17:02:31.694] - signal: TRUE
[17:02:31.694] - resignal: FALSE
[17:02:31.694] - force: TRUE
[17:02:31.694] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:31.694] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.694]  - until=2
[17:02:31.694]  - relaying element #2
[17:02:31.694] result() for ClusterFuture ...
[17:02:31.695] - result already collected: FutureResult
[17:02:31.695] result() for ClusterFuture ... done
[17:02:31.695] result() for ClusterFuture ...
[17:02:31.695] - result already collected: FutureResult
[17:02:31.695] result() for ClusterFuture ... done
[17:02:31.695] result() for ClusterFuture ...
[17:02:31.695] - result already collected: FutureResult
[17:02:31.695] result() for ClusterFuture ... done
[17:02:31.695] result() for ClusterFuture ...
[17:02:31.695] - result already collected: FutureResult
[17:02:31.695] result() for ClusterFuture ... done
[17:02:31.696] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:31.696] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:31.696] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:31.696]  length: 2 (resolved future 2)
[17:02:31.696] Future #3
[17:02:31.696] result() for ClusterFuture ...
[17:02:31.696] - result already collected: FutureResult
[17:02:31.696] result() for ClusterFuture ... done
[17:02:31.696] result() for ClusterFuture ...
[17:02:31.696] - result already collected: FutureResult
[17:02:31.696] result() for ClusterFuture ... done
[17:02:31.697] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:31.697] - nx: 4
[17:02:31.697] - relay: TRUE
[17:02:31.697] - stdout: TRUE
[17:02:31.697] - signal: TRUE
[17:02:31.697] - resignal: FALSE
[17:02:31.697] - force: TRUE
[17:02:31.697] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:31.697] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:31.697]  - until=3
[17:02:31.697]  - relaying element #3
[17:02:31.697] result() for ClusterFuture ...
[17:02:31.698] - result already collected: FutureResult
[17:02:31.698] result() for ClusterFuture ... done
[17:02:31.698] result() for ClusterFuture ...
[17:02:31.698] - result already collected: FutureResult
[17:02:31.698] result() for ClusterFuture ... done
[17:02:31.698] result() for ClusterFuture ...
[17:02:31.698] - result already collected: FutureResult
[17:02:31.698] result() for ClusterFuture ... done
[17:02:31.698] result() for ClusterFuture ...
[17:02:31.698] - result already collected: FutureResult
[17:02:31.698] result() for ClusterFuture ... done
[17:02:31.698] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:31.699] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:31.699] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:31.699]  length: 1 (resolved future 3)
[17:02:31.699] Future #4
[17:02:31.699] result() for ClusterFuture ...
[17:02:31.699] - result already collected: FutureResult
[17:02:31.699] result() for ClusterFuture ... done
[17:02:31.699] result() for ClusterFuture ...
[17:02:31.699] - result already collected: FutureResult
[17:02:31.699] result() for ClusterFuture ... done
[17:02:31.699] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:02:31.700] - nx: 4
[17:02:31.700] - relay: TRUE
[17:02:31.700] - stdout: TRUE
[17:02:31.700] - signal: TRUE
[17:02:31.700] - resignal: FALSE
[17:02:31.700] - force: TRUE
[17:02:31.700] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:31.700] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:31.700]  - until=4
[17:02:31.700]  - relaying element #4
[17:02:31.700] result() for ClusterFuture ...
[17:02:31.700] - result already collected: FutureResult
[17:02:31.701] result() for ClusterFuture ... done
[17:02:31.701] result() for ClusterFuture ...
[17:02:31.701] - result already collected: FutureResult
[17:02:31.701] result() for ClusterFuture ... done
[17:02:31.701] result() for ClusterFuture ...
[17:02:31.701] - result already collected: FutureResult
[17:02:31.701] result() for ClusterFuture ... done
[17:02:31.701] result() for ClusterFuture ...
[17:02:31.701] - result already collected: FutureResult
[17:02:31.701] result() for ClusterFuture ... done
[17:02:31.701] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.702] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:31.702] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:02:31.702]  length: 0 (resolved future 4)
[17:02:31.702] Relaying remaining futures
[17:02:31.702] signalConditionsASAP(NULL, pos=0) ...
[17:02:31.702] - nx: 4
[17:02:31.702] - relay: TRUE
[17:02:31.702] - stdout: TRUE
[17:02:31.702] - signal: TRUE
[17:02:31.702] - resignal: FALSE
[17:02:31.702] - force: TRUE
[17:02:31.702] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.703] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:31.703] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.703] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:31.703] signalConditionsASAP(NULL, pos=0) ... done
[17:02:31.703] resolve() on environment ... DONE
[17:02:31.703] result() for ClusterFuture ...
[17:02:31.703] - result already collected: FutureResult
[17:02:31.703] result() for ClusterFuture ... done
[17:02:31.703] result() for ClusterFuture ...
[17:02:31.703] - result already collected: FutureResult
[17:02:31.703] result() for ClusterFuture ... done
[17:02:31.704] result() for ClusterFuture ...
[17:02:31.704] - result already collected: FutureResult
[17:02:31.704] result() for ClusterFuture ... done
[17:02:31.704] result() for ClusterFuture ...
[17:02:31.704] - result already collected: FutureResult
[17:02:31.704] result() for ClusterFuture ... done
[17:02:31.704] result() for ClusterFuture ...
[17:02:31.704] - result already collected: FutureResult
[17:02:31.704] result() for ClusterFuture ... done
[17:02:31.704] result() for ClusterFuture ...
[17:02:31.704] - result already collected: FutureResult
[17:02:31.705] result() for ClusterFuture ... done
<environment: 0x55c74a823e48> 
Dimensions: c(1, 6)
[17:02:31.705] getGlobalsAndPackages() ...
[17:02:31.705] Searching for globals...
[17:02:31.705] 
[17:02:31.705] Searching for globals ... DONE
[17:02:31.706] - globals: [0] <none>
[17:02:31.706] getGlobalsAndPackages() ... DONE
[17:02:31.706] run() for ‘Future’ ...
[17:02:31.706] - state: ‘created’
[17:02:31.706] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.721] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.721] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:31.721]   - Field: ‘node’
[17:02:31.722]   - Field: ‘label’
[17:02:31.722]   - Field: ‘local’
[17:02:31.722]   - Field: ‘owner’
[17:02:31.722]   - Field: ‘envir’
[17:02:31.722]   - Field: ‘workers’
[17:02:31.722]   - Field: ‘packages’
[17:02:31.722]   - Field: ‘gc’
[17:02:31.722]   - Field: ‘conditions’
[17:02:31.723]   - Field: ‘persistent’
[17:02:31.723]   - Field: ‘expr’
[17:02:31.723]   - Field: ‘uuid’
[17:02:31.723]   - Field: ‘seed’
[17:02:31.723]   - Field: ‘version’
[17:02:31.723]   - Field: ‘result’
[17:02:31.723]   - Field: ‘asynchronous’
[17:02:31.724]   - Field: ‘calls’
[17:02:31.724]   - Field: ‘globals’
[17:02:31.724]   - Field: ‘stdout’
[17:02:31.724]   - Field: ‘earlySignal’
[17:02:31.724]   - Field: ‘lazy’
[17:02:31.724]   - Field: ‘state’
[17:02:31.724] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:31.724] - Launch lazy future ...
[17:02:31.725] Packages needed by the future expression (n = 0): <none>
[17:02:31.725] Packages needed by future strategies (n = 0): <none>
[17:02:31.725] {
[17:02:31.725]     {
[17:02:31.725]         {
[17:02:31.725]             ...future.startTime <- base::Sys.time()
[17:02:31.725]             {
[17:02:31.725]                 {
[17:02:31.725]                   {
[17:02:31.725]                     {
[17:02:31.725]                       base::local({
[17:02:31.725]                         has_future <- base::requireNamespace("future", 
[17:02:31.725]                           quietly = TRUE)
[17:02:31.725]                         if (has_future) {
[17:02:31.725]                           ns <- base::getNamespace("future")
[17:02:31.725]                           version <- ns[[".package"]][["version"]]
[17:02:31.725]                           if (is.null(version)) 
[17:02:31.725]                             version <- utils::packageVersion("future")
[17:02:31.725]                         }
[17:02:31.725]                         else {
[17:02:31.725]                           version <- NULL
[17:02:31.725]                         }
[17:02:31.725]                         if (!has_future || version < "1.8.0") {
[17:02:31.725]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.725]                             "", base::R.version$version.string), 
[17:02:31.725]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.725]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.725]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.725]                               "release", "version")], collapse = " "), 
[17:02:31.725]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.725]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.725]                             info)
[17:02:31.725]                           info <- base::paste(info, collapse = "; ")
[17:02:31.725]                           if (!has_future) {
[17:02:31.725]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.725]                               info)
[17:02:31.725]                           }
[17:02:31.725]                           else {
[17:02:31.725]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.725]                               info, version)
[17:02:31.725]                           }
[17:02:31.725]                           base::stop(msg)
[17:02:31.725]                         }
[17:02:31.725]                       })
[17:02:31.725]                     }
[17:02:31.725]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.725]                     base::options(mc.cores = 1L)
[17:02:31.725]                   }
[17:02:31.725]                   ...future.strategy.old <- future::plan("list")
[17:02:31.725]                   options(future.plan = NULL)
[17:02:31.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.725]                 }
[17:02:31.725]                 ...future.workdir <- getwd()
[17:02:31.725]             }
[17:02:31.725]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.725]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.725]         }
[17:02:31.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.725]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.725]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.725]             base::names(...future.oldOptions))
[17:02:31.725]     }
[17:02:31.725]     if (FALSE) {
[17:02:31.725]     }
[17:02:31.725]     else {
[17:02:31.725]         if (TRUE) {
[17:02:31.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.725]                 open = "w")
[17:02:31.725]         }
[17:02:31.725]         else {
[17:02:31.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.725]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.725]         }
[17:02:31.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.725]             base::sink(type = "output", split = FALSE)
[17:02:31.725]             base::close(...future.stdout)
[17:02:31.725]         }, add = TRUE)
[17:02:31.725]     }
[17:02:31.725]     ...future.frame <- base::sys.nframe()
[17:02:31.725]     ...future.conditions <- base::list()
[17:02:31.725]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.725]     if (FALSE) {
[17:02:31.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.725]     }
[17:02:31.725]     ...future.result <- base::tryCatch({
[17:02:31.725]         base::withCallingHandlers({
[17:02:31.725]             ...future.value <- base::withVisible(base::local({
[17:02:31.725]                 ...future.makeSendCondition <- base::local({
[17:02:31.725]                   sendCondition <- NULL
[17:02:31.725]                   function(frame = 1L) {
[17:02:31.725]                     if (is.function(sendCondition)) 
[17:02:31.725]                       return(sendCondition)
[17:02:31.725]                     ns <- getNamespace("parallel")
[17:02:31.725]                     if (exists("sendData", mode = "function", 
[17:02:31.725]                       envir = ns)) {
[17:02:31.725]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:31.725]                         envir = ns)
[17:02:31.725]                       envir <- sys.frame(frame)
[17:02:31.725]                       master <- NULL
[17:02:31.725]                       while (!identical(envir, .GlobalEnv) && 
[17:02:31.725]                         !identical(envir, emptyenv())) {
[17:02:31.725]                         if (exists("master", mode = "list", envir = envir, 
[17:02:31.725]                           inherits = FALSE)) {
[17:02:31.725]                           master <- get("master", mode = "list", 
[17:02:31.725]                             envir = envir, inherits = FALSE)
[17:02:31.725]                           if (inherits(master, c("SOCKnode", 
[17:02:31.725]                             "SOCK0node"))) {
[17:02:31.725]                             sendCondition <<- function(cond) {
[17:02:31.725]                               data <- list(type = "VALUE", value = cond, 
[17:02:31.725]                                 success = TRUE)
[17:02:31.725]                               parallel_sendData(master, data)
[17:02:31.725]                             }
[17:02:31.725]                             return(sendCondition)
[17:02:31.725]                           }
[17:02:31.725]                         }
[17:02:31.725]                         frame <- frame + 1L
[17:02:31.725]                         envir <- sys.frame(frame)
[17:02:31.725]                       }
[17:02:31.725]                     }
[17:02:31.725]                     sendCondition <<- function(cond) NULL
[17:02:31.725]                   }
[17:02:31.725]                 })
[17:02:31.725]                 withCallingHandlers({
[17:02:31.725]                   2
[17:02:31.725]                 }, immediateCondition = function(cond) {
[17:02:31.725]                   sendCondition <- ...future.makeSendCondition()
[17:02:31.725]                   sendCondition(cond)
[17:02:31.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.725]                   {
[17:02:31.725]                     inherits <- base::inherits
[17:02:31.725]                     invokeRestart <- base::invokeRestart
[17:02:31.725]                     is.null <- base::is.null
[17:02:31.725]                     muffled <- FALSE
[17:02:31.725]                     if (inherits(cond, "message")) {
[17:02:31.725]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.725]                       if (muffled) 
[17:02:31.725]                         invokeRestart("muffleMessage")
[17:02:31.725]                     }
[17:02:31.725]                     else if (inherits(cond, "warning")) {
[17:02:31.725]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.725]                       if (muffled) 
[17:02:31.725]                         invokeRestart("muffleWarning")
[17:02:31.725]                     }
[17:02:31.725]                     else if (inherits(cond, "condition")) {
[17:02:31.725]                       if (!is.null(pattern)) {
[17:02:31.725]                         computeRestarts <- base::computeRestarts
[17:02:31.725]                         grepl <- base::grepl
[17:02:31.725]                         restarts <- computeRestarts(cond)
[17:02:31.725]                         for (restart in restarts) {
[17:02:31.725]                           name <- restart$name
[17:02:31.725]                           if (is.null(name)) 
[17:02:31.725]                             next
[17:02:31.725]                           if (!grepl(pattern, name)) 
[17:02:31.725]                             next
[17:02:31.725]                           invokeRestart(restart)
[17:02:31.725]                           muffled <- TRUE
[17:02:31.725]                           break
[17:02:31.725]                         }
[17:02:31.725]                       }
[17:02:31.725]                     }
[17:02:31.725]                     invisible(muffled)
[17:02:31.725]                   }
[17:02:31.725]                   muffleCondition(cond)
[17:02:31.725]                 })
[17:02:31.725]             }))
[17:02:31.725]             future::FutureResult(value = ...future.value$value, 
[17:02:31.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.725]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.725]                     ...future.globalenv.names))
[17:02:31.725]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.725]         }, condition = base::local({
[17:02:31.725]             c <- base::c
[17:02:31.725]             inherits <- base::inherits
[17:02:31.725]             invokeRestart <- base::invokeRestart
[17:02:31.725]             length <- base::length
[17:02:31.725]             list <- base::list
[17:02:31.725]             seq.int <- base::seq.int
[17:02:31.725]             signalCondition <- base::signalCondition
[17:02:31.725]             sys.calls <- base::sys.calls
[17:02:31.725]             `[[` <- base::`[[`
[17:02:31.725]             `+` <- base::`+`
[17:02:31.725]             `<<-` <- base::`<<-`
[17:02:31.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.725]                   3L)]
[17:02:31.725]             }
[17:02:31.725]             function(cond) {
[17:02:31.725]                 is_error <- inherits(cond, "error")
[17:02:31.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.725]                   NULL)
[17:02:31.725]                 if (is_error) {
[17:02:31.725]                   sessionInformation <- function() {
[17:02:31.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.725]                       search = base::search(), system = base::Sys.info())
[17:02:31.725]                   }
[17:02:31.725]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.725]                     cond$call), session = sessionInformation(), 
[17:02:31.725]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.725]                   signalCondition(cond)
[17:02:31.725]                 }
[17:02:31.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.725]                 "immediateCondition"))) {
[17:02:31.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.725]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.725]                   if (TRUE && !signal) {
[17:02:31.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.725]                     {
[17:02:31.725]                       inherits <- base::inherits
[17:02:31.725]                       invokeRestart <- base::invokeRestart
[17:02:31.725]                       is.null <- base::is.null
[17:02:31.725]                       muffled <- FALSE
[17:02:31.725]                       if (inherits(cond, "message")) {
[17:02:31.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.725]                         if (muffled) 
[17:02:31.725]                           invokeRestart("muffleMessage")
[17:02:31.725]                       }
[17:02:31.725]                       else if (inherits(cond, "warning")) {
[17:02:31.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.725]                         if (muffled) 
[17:02:31.725]                           invokeRestart("muffleWarning")
[17:02:31.725]                       }
[17:02:31.725]                       else if (inherits(cond, "condition")) {
[17:02:31.725]                         if (!is.null(pattern)) {
[17:02:31.725]                           computeRestarts <- base::computeRestarts
[17:02:31.725]                           grepl <- base::grepl
[17:02:31.725]                           restarts <- computeRestarts(cond)
[17:02:31.725]                           for (restart in restarts) {
[17:02:31.725]                             name <- restart$name
[17:02:31.725]                             if (is.null(name)) 
[17:02:31.725]                               next
[17:02:31.725]                             if (!grepl(pattern, name)) 
[17:02:31.725]                               next
[17:02:31.725]                             invokeRestart(restart)
[17:02:31.725]                             muffled <- TRUE
[17:02:31.725]                             break
[17:02:31.725]                           }
[17:02:31.725]                         }
[17:02:31.725]                       }
[17:02:31.725]                       invisible(muffled)
[17:02:31.725]                     }
[17:02:31.725]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.725]                   }
[17:02:31.725]                 }
[17:02:31.725]                 else {
[17:02:31.725]                   if (TRUE) {
[17:02:31.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.725]                     {
[17:02:31.725]                       inherits <- base::inherits
[17:02:31.725]                       invokeRestart <- base::invokeRestart
[17:02:31.725]                       is.null <- base::is.null
[17:02:31.725]                       muffled <- FALSE
[17:02:31.725]                       if (inherits(cond, "message")) {
[17:02:31.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.725]                         if (muffled) 
[17:02:31.725]                           invokeRestart("muffleMessage")
[17:02:31.725]                       }
[17:02:31.725]                       else if (inherits(cond, "warning")) {
[17:02:31.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.725]                         if (muffled) 
[17:02:31.725]                           invokeRestart("muffleWarning")
[17:02:31.725]                       }
[17:02:31.725]                       else if (inherits(cond, "condition")) {
[17:02:31.725]                         if (!is.null(pattern)) {
[17:02:31.725]                           computeRestarts <- base::computeRestarts
[17:02:31.725]                           grepl <- base::grepl
[17:02:31.725]                           restarts <- computeRestarts(cond)
[17:02:31.725]                           for (restart in restarts) {
[17:02:31.725]                             name <- restart$name
[17:02:31.725]                             if (is.null(name)) 
[17:02:31.725]                               next
[17:02:31.725]                             if (!grepl(pattern, name)) 
[17:02:31.725]                               next
[17:02:31.725]                             invokeRestart(restart)
[17:02:31.725]                             muffled <- TRUE
[17:02:31.725]                             break
[17:02:31.725]                           }
[17:02:31.725]                         }
[17:02:31.725]                       }
[17:02:31.725]                       invisible(muffled)
[17:02:31.725]                     }
[17:02:31.725]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.725]                   }
[17:02:31.725]                 }
[17:02:31.725]             }
[17:02:31.725]         }))
[17:02:31.725]     }, error = function(ex) {
[17:02:31.725]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.725]                 ...future.rng), started = ...future.startTime, 
[17:02:31.725]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.725]             version = "1.8"), class = "FutureResult")
[17:02:31.725]     }, finally = {
[17:02:31.725]         if (!identical(...future.workdir, getwd())) 
[17:02:31.725]             setwd(...future.workdir)
[17:02:31.725]         {
[17:02:31.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.725]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.725]             }
[17:02:31.725]             base::options(...future.oldOptions)
[17:02:31.725]             if (.Platform$OS.type == "windows") {
[17:02:31.725]                 old_names <- names(...future.oldEnvVars)
[17:02:31.725]                 envs <- base::Sys.getenv()
[17:02:31.725]                 names <- names(envs)
[17:02:31.725]                 common <- intersect(names, old_names)
[17:02:31.725]                 added <- setdiff(names, old_names)
[17:02:31.725]                 removed <- setdiff(old_names, names)
[17:02:31.725]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.725]                   envs[common]]
[17:02:31.725]                 NAMES <- toupper(changed)
[17:02:31.725]                 args <- list()
[17:02:31.725]                 for (kk in seq_along(NAMES)) {
[17:02:31.725]                   name <- changed[[kk]]
[17:02:31.725]                   NAME <- NAMES[[kk]]
[17:02:31.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.725]                     next
[17:02:31.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.725]                 }
[17:02:31.725]                 NAMES <- toupper(added)
[17:02:31.725]                 for (kk in seq_along(NAMES)) {
[17:02:31.725]                   name <- added[[kk]]
[17:02:31.725]                   NAME <- NAMES[[kk]]
[17:02:31.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.725]                     next
[17:02:31.725]                   args[[name]] <- ""
[17:02:31.725]                 }
[17:02:31.725]                 NAMES <- toupper(removed)
[17:02:31.725]                 for (kk in seq_along(NAMES)) {
[17:02:31.725]                   name <- removed[[kk]]
[17:02:31.725]                   NAME <- NAMES[[kk]]
[17:02:31.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.725]                     next
[17:02:31.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.725]                 }
[17:02:31.725]                 if (length(args) > 0) 
[17:02:31.725]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.725]             }
[17:02:31.725]             else {
[17:02:31.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.725]             }
[17:02:31.725]             {
[17:02:31.725]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.725]                   0L) {
[17:02:31.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.725]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.725]                   base::options(opts)
[17:02:31.725]                 }
[17:02:31.725]                 {
[17:02:31.725]                   {
[17:02:31.725]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.725]                     NULL
[17:02:31.725]                   }
[17:02:31.725]                   options(future.plan = NULL)
[17:02:31.725]                   if (is.na(NA_character_)) 
[17:02:31.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.725]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.725]                     .init = FALSE)
[17:02:31.725]                 }
[17:02:31.725]             }
[17:02:31.725]         }
[17:02:31.725]     })
[17:02:31.725]     if (TRUE) {
[17:02:31.725]         base::sink(type = "output", split = FALSE)
[17:02:31.725]         if (TRUE) {
[17:02:31.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.725]         }
[17:02:31.725]         else {
[17:02:31.725]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.725]         }
[17:02:31.725]         base::close(...future.stdout)
[17:02:31.725]         ...future.stdout <- NULL
[17:02:31.725]     }
[17:02:31.725]     ...future.result$conditions <- ...future.conditions
[17:02:31.725]     ...future.result$finished <- base::Sys.time()
[17:02:31.725]     ...future.result
[17:02:31.725] }
[17:02:31.729] MultisessionFuture started
[17:02:31.729] - Launch lazy future ... done
[17:02:31.729] run() for ‘MultisessionFuture’ ... done
[17:02:31.729] getGlobalsAndPackages() ...
[17:02:31.729] Searching for globals...
[17:02:31.730] 
[17:02:31.730] Searching for globals ... DONE
[17:02:31.730] - globals: [0] <none>
[17:02:31.730] getGlobalsAndPackages() ... DONE
[17:02:31.730] run() for ‘Future’ ...
[17:02:31.730] - state: ‘created’
[17:02:31.731] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.745] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.745] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:31.745]   - Field: ‘node’
[17:02:31.745]   - Field: ‘label’
[17:02:31.745]   - Field: ‘local’
[17:02:31.746]   - Field: ‘owner’
[17:02:31.746]   - Field: ‘envir’
[17:02:31.746]   - Field: ‘workers’
[17:02:31.746]   - Field: ‘packages’
[17:02:31.746]   - Field: ‘gc’
[17:02:31.746]   - Field: ‘conditions’
[17:02:31.746]   - Field: ‘persistent’
[17:02:31.746]   - Field: ‘expr’
[17:02:31.746]   - Field: ‘uuid’
[17:02:31.746]   - Field: ‘seed’
[17:02:31.747]   - Field: ‘version’
[17:02:31.747]   - Field: ‘result’
[17:02:31.747]   - Field: ‘asynchronous’
[17:02:31.747]   - Field: ‘calls’
[17:02:31.747]   - Field: ‘globals’
[17:02:31.747]   - Field: ‘stdout’
[17:02:31.747]   - Field: ‘earlySignal’
[17:02:31.747]   - Field: ‘lazy’
[17:02:31.747]   - Field: ‘state’
[17:02:31.747] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:31.748] - Launch lazy future ...
[17:02:31.748] Packages needed by the future expression (n = 0): <none>
[17:02:31.748] Packages needed by future strategies (n = 0): <none>
[17:02:31.748] {
[17:02:31.748]     {
[17:02:31.748]         {
[17:02:31.748]             ...future.startTime <- base::Sys.time()
[17:02:31.748]             {
[17:02:31.748]                 {
[17:02:31.748]                   {
[17:02:31.748]                     {
[17:02:31.748]                       base::local({
[17:02:31.748]                         has_future <- base::requireNamespace("future", 
[17:02:31.748]                           quietly = TRUE)
[17:02:31.748]                         if (has_future) {
[17:02:31.748]                           ns <- base::getNamespace("future")
[17:02:31.748]                           version <- ns[[".package"]][["version"]]
[17:02:31.748]                           if (is.null(version)) 
[17:02:31.748]                             version <- utils::packageVersion("future")
[17:02:31.748]                         }
[17:02:31.748]                         else {
[17:02:31.748]                           version <- NULL
[17:02:31.748]                         }
[17:02:31.748]                         if (!has_future || version < "1.8.0") {
[17:02:31.748]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.748]                             "", base::R.version$version.string), 
[17:02:31.748]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.748]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.748]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.748]                               "release", "version")], collapse = " "), 
[17:02:31.748]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.748]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.748]                             info)
[17:02:31.748]                           info <- base::paste(info, collapse = "; ")
[17:02:31.748]                           if (!has_future) {
[17:02:31.748]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.748]                               info)
[17:02:31.748]                           }
[17:02:31.748]                           else {
[17:02:31.748]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.748]                               info, version)
[17:02:31.748]                           }
[17:02:31.748]                           base::stop(msg)
[17:02:31.748]                         }
[17:02:31.748]                       })
[17:02:31.748]                     }
[17:02:31.748]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.748]                     base::options(mc.cores = 1L)
[17:02:31.748]                   }
[17:02:31.748]                   ...future.strategy.old <- future::plan("list")
[17:02:31.748]                   options(future.plan = NULL)
[17:02:31.748]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.748]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.748]                 }
[17:02:31.748]                 ...future.workdir <- getwd()
[17:02:31.748]             }
[17:02:31.748]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.748]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.748]         }
[17:02:31.748]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.748]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.748]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.748]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.748]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.748]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.748]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.748]             base::names(...future.oldOptions))
[17:02:31.748]     }
[17:02:31.748]     if (FALSE) {
[17:02:31.748]     }
[17:02:31.748]     else {
[17:02:31.748]         if (TRUE) {
[17:02:31.748]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.748]                 open = "w")
[17:02:31.748]         }
[17:02:31.748]         else {
[17:02:31.748]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.748]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.748]         }
[17:02:31.748]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.748]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.748]             base::sink(type = "output", split = FALSE)
[17:02:31.748]             base::close(...future.stdout)
[17:02:31.748]         }, add = TRUE)
[17:02:31.748]     }
[17:02:31.748]     ...future.frame <- base::sys.nframe()
[17:02:31.748]     ...future.conditions <- base::list()
[17:02:31.748]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.748]     if (FALSE) {
[17:02:31.748]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.748]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.748]     }
[17:02:31.748]     ...future.result <- base::tryCatch({
[17:02:31.748]         base::withCallingHandlers({
[17:02:31.748]             ...future.value <- base::withVisible(base::local({
[17:02:31.748]                 ...future.makeSendCondition <- base::local({
[17:02:31.748]                   sendCondition <- NULL
[17:02:31.748]                   function(frame = 1L) {
[17:02:31.748]                     if (is.function(sendCondition)) 
[17:02:31.748]                       return(sendCondition)
[17:02:31.748]                     ns <- getNamespace("parallel")
[17:02:31.748]                     if (exists("sendData", mode = "function", 
[17:02:31.748]                       envir = ns)) {
[17:02:31.748]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:31.748]                         envir = ns)
[17:02:31.748]                       envir <- sys.frame(frame)
[17:02:31.748]                       master <- NULL
[17:02:31.748]                       while (!identical(envir, .GlobalEnv) && 
[17:02:31.748]                         !identical(envir, emptyenv())) {
[17:02:31.748]                         if (exists("master", mode = "list", envir = envir, 
[17:02:31.748]                           inherits = FALSE)) {
[17:02:31.748]                           master <- get("master", mode = "list", 
[17:02:31.748]                             envir = envir, inherits = FALSE)
[17:02:31.748]                           if (inherits(master, c("SOCKnode", 
[17:02:31.748]                             "SOCK0node"))) {
[17:02:31.748]                             sendCondition <<- function(cond) {
[17:02:31.748]                               data <- list(type = "VALUE", value = cond, 
[17:02:31.748]                                 success = TRUE)
[17:02:31.748]                               parallel_sendData(master, data)
[17:02:31.748]                             }
[17:02:31.748]                             return(sendCondition)
[17:02:31.748]                           }
[17:02:31.748]                         }
[17:02:31.748]                         frame <- frame + 1L
[17:02:31.748]                         envir <- sys.frame(frame)
[17:02:31.748]                       }
[17:02:31.748]                     }
[17:02:31.748]                     sendCondition <<- function(cond) NULL
[17:02:31.748]                   }
[17:02:31.748]                 })
[17:02:31.748]                 withCallingHandlers({
[17:02:31.748]                   NULL
[17:02:31.748]                 }, immediateCondition = function(cond) {
[17:02:31.748]                   sendCondition <- ...future.makeSendCondition()
[17:02:31.748]                   sendCondition(cond)
[17:02:31.748]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.748]                   {
[17:02:31.748]                     inherits <- base::inherits
[17:02:31.748]                     invokeRestart <- base::invokeRestart
[17:02:31.748]                     is.null <- base::is.null
[17:02:31.748]                     muffled <- FALSE
[17:02:31.748]                     if (inherits(cond, "message")) {
[17:02:31.748]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.748]                       if (muffled) 
[17:02:31.748]                         invokeRestart("muffleMessage")
[17:02:31.748]                     }
[17:02:31.748]                     else if (inherits(cond, "warning")) {
[17:02:31.748]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.748]                       if (muffled) 
[17:02:31.748]                         invokeRestart("muffleWarning")
[17:02:31.748]                     }
[17:02:31.748]                     else if (inherits(cond, "condition")) {
[17:02:31.748]                       if (!is.null(pattern)) {
[17:02:31.748]                         computeRestarts <- base::computeRestarts
[17:02:31.748]                         grepl <- base::grepl
[17:02:31.748]                         restarts <- computeRestarts(cond)
[17:02:31.748]                         for (restart in restarts) {
[17:02:31.748]                           name <- restart$name
[17:02:31.748]                           if (is.null(name)) 
[17:02:31.748]                             next
[17:02:31.748]                           if (!grepl(pattern, name)) 
[17:02:31.748]                             next
[17:02:31.748]                           invokeRestart(restart)
[17:02:31.748]                           muffled <- TRUE
[17:02:31.748]                           break
[17:02:31.748]                         }
[17:02:31.748]                       }
[17:02:31.748]                     }
[17:02:31.748]                     invisible(muffled)
[17:02:31.748]                   }
[17:02:31.748]                   muffleCondition(cond)
[17:02:31.748]                 })
[17:02:31.748]             }))
[17:02:31.748]             future::FutureResult(value = ...future.value$value, 
[17:02:31.748]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.748]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.748]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.748]                     ...future.globalenv.names))
[17:02:31.748]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.748]         }, condition = base::local({
[17:02:31.748]             c <- base::c
[17:02:31.748]             inherits <- base::inherits
[17:02:31.748]             invokeRestart <- base::invokeRestart
[17:02:31.748]             length <- base::length
[17:02:31.748]             list <- base::list
[17:02:31.748]             seq.int <- base::seq.int
[17:02:31.748]             signalCondition <- base::signalCondition
[17:02:31.748]             sys.calls <- base::sys.calls
[17:02:31.748]             `[[` <- base::`[[`
[17:02:31.748]             `+` <- base::`+`
[17:02:31.748]             `<<-` <- base::`<<-`
[17:02:31.748]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.748]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.748]                   3L)]
[17:02:31.748]             }
[17:02:31.748]             function(cond) {
[17:02:31.748]                 is_error <- inherits(cond, "error")
[17:02:31.748]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.748]                   NULL)
[17:02:31.748]                 if (is_error) {
[17:02:31.748]                   sessionInformation <- function() {
[17:02:31.748]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.748]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.748]                       search = base::search(), system = base::Sys.info())
[17:02:31.748]                   }
[17:02:31.748]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.748]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.748]                     cond$call), session = sessionInformation(), 
[17:02:31.748]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.748]                   signalCondition(cond)
[17:02:31.748]                 }
[17:02:31.748]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.748]                 "immediateCondition"))) {
[17:02:31.748]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.748]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.748]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.748]                   if (TRUE && !signal) {
[17:02:31.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.748]                     {
[17:02:31.748]                       inherits <- base::inherits
[17:02:31.748]                       invokeRestart <- base::invokeRestart
[17:02:31.748]                       is.null <- base::is.null
[17:02:31.748]                       muffled <- FALSE
[17:02:31.748]                       if (inherits(cond, "message")) {
[17:02:31.748]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.748]                         if (muffled) 
[17:02:31.748]                           invokeRestart("muffleMessage")
[17:02:31.748]                       }
[17:02:31.748]                       else if (inherits(cond, "warning")) {
[17:02:31.748]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.748]                         if (muffled) 
[17:02:31.748]                           invokeRestart("muffleWarning")
[17:02:31.748]                       }
[17:02:31.748]                       else if (inherits(cond, "condition")) {
[17:02:31.748]                         if (!is.null(pattern)) {
[17:02:31.748]                           computeRestarts <- base::computeRestarts
[17:02:31.748]                           grepl <- base::grepl
[17:02:31.748]                           restarts <- computeRestarts(cond)
[17:02:31.748]                           for (restart in restarts) {
[17:02:31.748]                             name <- restart$name
[17:02:31.748]                             if (is.null(name)) 
[17:02:31.748]                               next
[17:02:31.748]                             if (!grepl(pattern, name)) 
[17:02:31.748]                               next
[17:02:31.748]                             invokeRestart(restart)
[17:02:31.748]                             muffled <- TRUE
[17:02:31.748]                             break
[17:02:31.748]                           }
[17:02:31.748]                         }
[17:02:31.748]                       }
[17:02:31.748]                       invisible(muffled)
[17:02:31.748]                     }
[17:02:31.748]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.748]                   }
[17:02:31.748]                 }
[17:02:31.748]                 else {
[17:02:31.748]                   if (TRUE) {
[17:02:31.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.748]                     {
[17:02:31.748]                       inherits <- base::inherits
[17:02:31.748]                       invokeRestart <- base::invokeRestart
[17:02:31.748]                       is.null <- base::is.null
[17:02:31.748]                       muffled <- FALSE
[17:02:31.748]                       if (inherits(cond, "message")) {
[17:02:31.748]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.748]                         if (muffled) 
[17:02:31.748]                           invokeRestart("muffleMessage")
[17:02:31.748]                       }
[17:02:31.748]                       else if (inherits(cond, "warning")) {
[17:02:31.748]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.748]                         if (muffled) 
[17:02:31.748]                           invokeRestart("muffleWarning")
[17:02:31.748]                       }
[17:02:31.748]                       else if (inherits(cond, "condition")) {
[17:02:31.748]                         if (!is.null(pattern)) {
[17:02:31.748]                           computeRestarts <- base::computeRestarts
[17:02:31.748]                           grepl <- base::grepl
[17:02:31.748]                           restarts <- computeRestarts(cond)
[17:02:31.748]                           for (restart in restarts) {
[17:02:31.748]                             name <- restart$name
[17:02:31.748]                             if (is.null(name)) 
[17:02:31.748]                               next
[17:02:31.748]                             if (!grepl(pattern, name)) 
[17:02:31.748]                               next
[17:02:31.748]                             invokeRestart(restart)
[17:02:31.748]                             muffled <- TRUE
[17:02:31.748]                             break
[17:02:31.748]                           }
[17:02:31.748]                         }
[17:02:31.748]                       }
[17:02:31.748]                       invisible(muffled)
[17:02:31.748]                     }
[17:02:31.748]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.748]                   }
[17:02:31.748]                 }
[17:02:31.748]             }
[17:02:31.748]         }))
[17:02:31.748]     }, error = function(ex) {
[17:02:31.748]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.748]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.748]                 ...future.rng), started = ...future.startTime, 
[17:02:31.748]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.748]             version = "1.8"), class = "FutureResult")
[17:02:31.748]     }, finally = {
[17:02:31.748]         if (!identical(...future.workdir, getwd())) 
[17:02:31.748]             setwd(...future.workdir)
[17:02:31.748]         {
[17:02:31.748]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.748]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.748]             }
[17:02:31.748]             base::options(...future.oldOptions)
[17:02:31.748]             if (.Platform$OS.type == "windows") {
[17:02:31.748]                 old_names <- names(...future.oldEnvVars)
[17:02:31.748]                 envs <- base::Sys.getenv()
[17:02:31.748]                 names <- names(envs)
[17:02:31.748]                 common <- intersect(names, old_names)
[17:02:31.748]                 added <- setdiff(names, old_names)
[17:02:31.748]                 removed <- setdiff(old_names, names)
[17:02:31.748]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.748]                   envs[common]]
[17:02:31.748]                 NAMES <- toupper(changed)
[17:02:31.748]                 args <- list()
[17:02:31.748]                 for (kk in seq_along(NAMES)) {
[17:02:31.748]                   name <- changed[[kk]]
[17:02:31.748]                   NAME <- NAMES[[kk]]
[17:02:31.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.748]                     next
[17:02:31.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.748]                 }
[17:02:31.748]                 NAMES <- toupper(added)
[17:02:31.748]                 for (kk in seq_along(NAMES)) {
[17:02:31.748]                   name <- added[[kk]]
[17:02:31.748]                   NAME <- NAMES[[kk]]
[17:02:31.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.748]                     next
[17:02:31.748]                   args[[name]] <- ""
[17:02:31.748]                 }
[17:02:31.748]                 NAMES <- toupper(removed)
[17:02:31.748]                 for (kk in seq_along(NAMES)) {
[17:02:31.748]                   name <- removed[[kk]]
[17:02:31.748]                   NAME <- NAMES[[kk]]
[17:02:31.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.748]                     next
[17:02:31.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.748]                 }
[17:02:31.748]                 if (length(args) > 0) 
[17:02:31.748]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.748]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.748]             }
[17:02:31.748]             else {
[17:02:31.748]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.748]             }
[17:02:31.748]             {
[17:02:31.748]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.748]                   0L) {
[17:02:31.748]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.748]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.748]                   base::options(opts)
[17:02:31.748]                 }
[17:02:31.748]                 {
[17:02:31.748]                   {
[17:02:31.748]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.748]                     NULL
[17:02:31.748]                   }
[17:02:31.748]                   options(future.plan = NULL)
[17:02:31.748]                   if (is.na(NA_character_)) 
[17:02:31.748]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.748]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.748]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.748]                     .init = FALSE)
[17:02:31.748]                 }
[17:02:31.748]             }
[17:02:31.748]         }
[17:02:31.748]     })
[17:02:31.748]     if (TRUE) {
[17:02:31.748]         base::sink(type = "output", split = FALSE)
[17:02:31.748]         if (TRUE) {
[17:02:31.748]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.748]         }
[17:02:31.748]         else {
[17:02:31.748]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.748]         }
[17:02:31.748]         base::close(...future.stdout)
[17:02:31.748]         ...future.stdout <- NULL
[17:02:31.748]     }
[17:02:31.748]     ...future.result$conditions <- ...future.conditions
[17:02:31.748]     ...future.result$finished <- base::Sys.time()
[17:02:31.748]     ...future.result
[17:02:31.748] }
[17:02:31.752] MultisessionFuture started
[17:02:31.752] - Launch lazy future ... done
[17:02:31.752] run() for ‘MultisessionFuture’ ... done
[17:02:31.752] getGlobalsAndPackages() ...
[17:02:31.752] Searching for globals...
[17:02:31.759] - globals found: [1] ‘{’
[17:02:31.759] Searching for globals ... DONE
[17:02:31.759] Resolving globals: FALSE
[17:02:31.760] 
[17:02:31.760] 
[17:02:31.760] getGlobalsAndPackages() ... DONE
[17:02:31.760] run() for ‘Future’ ...
[17:02:31.761] - state: ‘created’
[17:02:31.761] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.775] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.775] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:31.775]   - Field: ‘node’
[17:02:31.775]   - Field: ‘label’
[17:02:31.775]   - Field: ‘local’
[17:02:31.775]   - Field: ‘owner’
[17:02:31.776]   - Field: ‘envir’
[17:02:31.776]   - Field: ‘workers’
[17:02:31.776]   - Field: ‘packages’
[17:02:31.776]   - Field: ‘gc’
[17:02:31.776]   - Field: ‘conditions’
[17:02:31.776]   - Field: ‘persistent’
[17:02:31.776]   - Field: ‘expr’
[17:02:31.776]   - Field: ‘uuid’
[17:02:31.776]   - Field: ‘seed’
[17:02:31.776]   - Field: ‘version’
[17:02:31.776]   - Field: ‘result’
[17:02:31.777]   - Field: ‘asynchronous’
[17:02:31.777]   - Field: ‘calls’
[17:02:31.777]   - Field: ‘globals’
[17:02:31.777]   - Field: ‘stdout’
[17:02:31.777]   - Field: ‘earlySignal’
[17:02:31.777]   - Field: ‘lazy’
[17:02:31.777]   - Field: ‘state’
[17:02:31.777] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:31.777] - Launch lazy future ...
[17:02:31.777] Packages needed by the future expression (n = 0): <none>
[17:02:31.778] Packages needed by future strategies (n = 0): <none>
[17:02:31.778] {
[17:02:31.778]     {
[17:02:31.778]         {
[17:02:31.778]             ...future.startTime <- base::Sys.time()
[17:02:31.778]             {
[17:02:31.778]                 {
[17:02:31.778]                   {
[17:02:31.778]                     {
[17:02:31.778]                       base::local({
[17:02:31.778]                         has_future <- base::requireNamespace("future", 
[17:02:31.778]                           quietly = TRUE)
[17:02:31.778]                         if (has_future) {
[17:02:31.778]                           ns <- base::getNamespace("future")
[17:02:31.778]                           version <- ns[[".package"]][["version"]]
[17:02:31.778]                           if (is.null(version)) 
[17:02:31.778]                             version <- utils::packageVersion("future")
[17:02:31.778]                         }
[17:02:31.778]                         else {
[17:02:31.778]                           version <- NULL
[17:02:31.778]                         }
[17:02:31.778]                         if (!has_future || version < "1.8.0") {
[17:02:31.778]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.778]                             "", base::R.version$version.string), 
[17:02:31.778]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.778]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.778]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.778]                               "release", "version")], collapse = " "), 
[17:02:31.778]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.778]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.778]                             info)
[17:02:31.778]                           info <- base::paste(info, collapse = "; ")
[17:02:31.778]                           if (!has_future) {
[17:02:31.778]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.778]                               info)
[17:02:31.778]                           }
[17:02:31.778]                           else {
[17:02:31.778]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.778]                               info, version)
[17:02:31.778]                           }
[17:02:31.778]                           base::stop(msg)
[17:02:31.778]                         }
[17:02:31.778]                       })
[17:02:31.778]                     }
[17:02:31.778]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.778]                     base::options(mc.cores = 1L)
[17:02:31.778]                   }
[17:02:31.778]                   ...future.strategy.old <- future::plan("list")
[17:02:31.778]                   options(future.plan = NULL)
[17:02:31.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.778]                 }
[17:02:31.778]                 ...future.workdir <- getwd()
[17:02:31.778]             }
[17:02:31.778]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.778]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.778]         }
[17:02:31.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.778]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.778]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.778]             base::names(...future.oldOptions))
[17:02:31.778]     }
[17:02:31.778]     if (FALSE) {
[17:02:31.778]     }
[17:02:31.778]     else {
[17:02:31.778]         if (TRUE) {
[17:02:31.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.778]                 open = "w")
[17:02:31.778]         }
[17:02:31.778]         else {
[17:02:31.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.778]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.778]         }
[17:02:31.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.778]             base::sink(type = "output", split = FALSE)
[17:02:31.778]             base::close(...future.stdout)
[17:02:31.778]         }, add = TRUE)
[17:02:31.778]     }
[17:02:31.778]     ...future.frame <- base::sys.nframe()
[17:02:31.778]     ...future.conditions <- base::list()
[17:02:31.778]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.778]     if (FALSE) {
[17:02:31.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.778]     }
[17:02:31.778]     ...future.result <- base::tryCatch({
[17:02:31.778]         base::withCallingHandlers({
[17:02:31.778]             ...future.value <- base::withVisible(base::local({
[17:02:31.778]                 ...future.makeSendCondition <- base::local({
[17:02:31.778]                   sendCondition <- NULL
[17:02:31.778]                   function(frame = 1L) {
[17:02:31.778]                     if (is.function(sendCondition)) 
[17:02:31.778]                       return(sendCondition)
[17:02:31.778]                     ns <- getNamespace("parallel")
[17:02:31.778]                     if (exists("sendData", mode = "function", 
[17:02:31.778]                       envir = ns)) {
[17:02:31.778]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:31.778]                         envir = ns)
[17:02:31.778]                       envir <- sys.frame(frame)
[17:02:31.778]                       master <- NULL
[17:02:31.778]                       while (!identical(envir, .GlobalEnv) && 
[17:02:31.778]                         !identical(envir, emptyenv())) {
[17:02:31.778]                         if (exists("master", mode = "list", envir = envir, 
[17:02:31.778]                           inherits = FALSE)) {
[17:02:31.778]                           master <- get("master", mode = "list", 
[17:02:31.778]                             envir = envir, inherits = FALSE)
[17:02:31.778]                           if (inherits(master, c("SOCKnode", 
[17:02:31.778]                             "SOCK0node"))) {
[17:02:31.778]                             sendCondition <<- function(cond) {
[17:02:31.778]                               data <- list(type = "VALUE", value = cond, 
[17:02:31.778]                                 success = TRUE)
[17:02:31.778]                               parallel_sendData(master, data)
[17:02:31.778]                             }
[17:02:31.778]                             return(sendCondition)
[17:02:31.778]                           }
[17:02:31.778]                         }
[17:02:31.778]                         frame <- frame + 1L
[17:02:31.778]                         envir <- sys.frame(frame)
[17:02:31.778]                       }
[17:02:31.778]                     }
[17:02:31.778]                     sendCondition <<- function(cond) NULL
[17:02:31.778]                   }
[17:02:31.778]                 })
[17:02:31.778]                 withCallingHandlers({
[17:02:31.778]                   {
[17:02:31.778]                     4
[17:02:31.778]                   }
[17:02:31.778]                 }, immediateCondition = function(cond) {
[17:02:31.778]                   sendCondition <- ...future.makeSendCondition()
[17:02:31.778]                   sendCondition(cond)
[17:02:31.778]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.778]                   {
[17:02:31.778]                     inherits <- base::inherits
[17:02:31.778]                     invokeRestart <- base::invokeRestart
[17:02:31.778]                     is.null <- base::is.null
[17:02:31.778]                     muffled <- FALSE
[17:02:31.778]                     if (inherits(cond, "message")) {
[17:02:31.778]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.778]                       if (muffled) 
[17:02:31.778]                         invokeRestart("muffleMessage")
[17:02:31.778]                     }
[17:02:31.778]                     else if (inherits(cond, "warning")) {
[17:02:31.778]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.778]                       if (muffled) 
[17:02:31.778]                         invokeRestart("muffleWarning")
[17:02:31.778]                     }
[17:02:31.778]                     else if (inherits(cond, "condition")) {
[17:02:31.778]                       if (!is.null(pattern)) {
[17:02:31.778]                         computeRestarts <- base::computeRestarts
[17:02:31.778]                         grepl <- base::grepl
[17:02:31.778]                         restarts <- computeRestarts(cond)
[17:02:31.778]                         for (restart in restarts) {
[17:02:31.778]                           name <- restart$name
[17:02:31.778]                           if (is.null(name)) 
[17:02:31.778]                             next
[17:02:31.778]                           if (!grepl(pattern, name)) 
[17:02:31.778]                             next
[17:02:31.778]                           invokeRestart(restart)
[17:02:31.778]                           muffled <- TRUE
[17:02:31.778]                           break
[17:02:31.778]                         }
[17:02:31.778]                       }
[17:02:31.778]                     }
[17:02:31.778]                     invisible(muffled)
[17:02:31.778]                   }
[17:02:31.778]                   muffleCondition(cond)
[17:02:31.778]                 })
[17:02:31.778]             }))
[17:02:31.778]             future::FutureResult(value = ...future.value$value, 
[17:02:31.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.778]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.778]                     ...future.globalenv.names))
[17:02:31.778]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.778]         }, condition = base::local({
[17:02:31.778]             c <- base::c
[17:02:31.778]             inherits <- base::inherits
[17:02:31.778]             invokeRestart <- base::invokeRestart
[17:02:31.778]             length <- base::length
[17:02:31.778]             list <- base::list
[17:02:31.778]             seq.int <- base::seq.int
[17:02:31.778]             signalCondition <- base::signalCondition
[17:02:31.778]             sys.calls <- base::sys.calls
[17:02:31.778]             `[[` <- base::`[[`
[17:02:31.778]             `+` <- base::`+`
[17:02:31.778]             `<<-` <- base::`<<-`
[17:02:31.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.778]                   3L)]
[17:02:31.778]             }
[17:02:31.778]             function(cond) {
[17:02:31.778]                 is_error <- inherits(cond, "error")
[17:02:31.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.778]                   NULL)
[17:02:31.778]                 if (is_error) {
[17:02:31.778]                   sessionInformation <- function() {
[17:02:31.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.778]                       search = base::search(), system = base::Sys.info())
[17:02:31.778]                   }
[17:02:31.778]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.778]                     cond$call), session = sessionInformation(), 
[17:02:31.778]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.778]                   signalCondition(cond)
[17:02:31.778]                 }
[17:02:31.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.778]                 "immediateCondition"))) {
[17:02:31.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.778]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.778]                   if (TRUE && !signal) {
[17:02:31.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.778]                     {
[17:02:31.778]                       inherits <- base::inherits
[17:02:31.778]                       invokeRestart <- base::invokeRestart
[17:02:31.778]                       is.null <- base::is.null
[17:02:31.778]                       muffled <- FALSE
[17:02:31.778]                       if (inherits(cond, "message")) {
[17:02:31.778]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.778]                         if (muffled) 
[17:02:31.778]                           invokeRestart("muffleMessage")
[17:02:31.778]                       }
[17:02:31.778]                       else if (inherits(cond, "warning")) {
[17:02:31.778]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.778]                         if (muffled) 
[17:02:31.778]                           invokeRestart("muffleWarning")
[17:02:31.778]                       }
[17:02:31.778]                       else if (inherits(cond, "condition")) {
[17:02:31.778]                         if (!is.null(pattern)) {
[17:02:31.778]                           computeRestarts <- base::computeRestarts
[17:02:31.778]                           grepl <- base::grepl
[17:02:31.778]                           restarts <- computeRestarts(cond)
[17:02:31.778]                           for (restart in restarts) {
[17:02:31.778]                             name <- restart$name
[17:02:31.778]                             if (is.null(name)) 
[17:02:31.778]                               next
[17:02:31.778]                             if (!grepl(pattern, name)) 
[17:02:31.778]                               next
[17:02:31.778]                             invokeRestart(restart)
[17:02:31.778]                             muffled <- TRUE
[17:02:31.778]                             break
[17:02:31.778]                           }
[17:02:31.778]                         }
[17:02:31.778]                       }
[17:02:31.778]                       invisible(muffled)
[17:02:31.778]                     }
[17:02:31.778]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.778]                   }
[17:02:31.778]                 }
[17:02:31.778]                 else {
[17:02:31.778]                   if (TRUE) {
[17:02:31.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.778]                     {
[17:02:31.778]                       inherits <- base::inherits
[17:02:31.778]                       invokeRestart <- base::invokeRestart
[17:02:31.778]                       is.null <- base::is.null
[17:02:31.778]                       muffled <- FALSE
[17:02:31.778]                       if (inherits(cond, "message")) {
[17:02:31.778]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.778]                         if (muffled) 
[17:02:31.778]                           invokeRestart("muffleMessage")
[17:02:31.778]                       }
[17:02:31.778]                       else if (inherits(cond, "warning")) {
[17:02:31.778]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.778]                         if (muffled) 
[17:02:31.778]                           invokeRestart("muffleWarning")
[17:02:31.778]                       }
[17:02:31.778]                       else if (inherits(cond, "condition")) {
[17:02:31.778]                         if (!is.null(pattern)) {
[17:02:31.778]                           computeRestarts <- base::computeRestarts
[17:02:31.778]                           grepl <- base::grepl
[17:02:31.778]                           restarts <- computeRestarts(cond)
[17:02:31.778]                           for (restart in restarts) {
[17:02:31.778]                             name <- restart$name
[17:02:31.778]                             if (is.null(name)) 
[17:02:31.778]                               next
[17:02:31.778]                             if (!grepl(pattern, name)) 
[17:02:31.778]                               next
[17:02:31.778]                             invokeRestart(restart)
[17:02:31.778]                             muffled <- TRUE
[17:02:31.778]                             break
[17:02:31.778]                           }
[17:02:31.778]                         }
[17:02:31.778]                       }
[17:02:31.778]                       invisible(muffled)
[17:02:31.778]                     }
[17:02:31.778]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.778]                   }
[17:02:31.778]                 }
[17:02:31.778]             }
[17:02:31.778]         }))
[17:02:31.778]     }, error = function(ex) {
[17:02:31.778]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.778]                 ...future.rng), started = ...future.startTime, 
[17:02:31.778]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.778]             version = "1.8"), class = "FutureResult")
[17:02:31.778]     }, finally = {
[17:02:31.778]         if (!identical(...future.workdir, getwd())) 
[17:02:31.778]             setwd(...future.workdir)
[17:02:31.778]         {
[17:02:31.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.778]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.778]             }
[17:02:31.778]             base::options(...future.oldOptions)
[17:02:31.778]             if (.Platform$OS.type == "windows") {
[17:02:31.778]                 old_names <- names(...future.oldEnvVars)
[17:02:31.778]                 envs <- base::Sys.getenv()
[17:02:31.778]                 names <- names(envs)
[17:02:31.778]                 common <- intersect(names, old_names)
[17:02:31.778]                 added <- setdiff(names, old_names)
[17:02:31.778]                 removed <- setdiff(old_names, names)
[17:02:31.778]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.778]                   envs[common]]
[17:02:31.778]                 NAMES <- toupper(changed)
[17:02:31.778]                 args <- list()
[17:02:31.778]                 for (kk in seq_along(NAMES)) {
[17:02:31.778]                   name <- changed[[kk]]
[17:02:31.778]                   NAME <- NAMES[[kk]]
[17:02:31.778]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.778]                     next
[17:02:31.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.778]                 }
[17:02:31.778]                 NAMES <- toupper(added)
[17:02:31.778]                 for (kk in seq_along(NAMES)) {
[17:02:31.778]                   name <- added[[kk]]
[17:02:31.778]                   NAME <- NAMES[[kk]]
[17:02:31.778]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.778]                     next
[17:02:31.778]                   args[[name]] <- ""
[17:02:31.778]                 }
[17:02:31.778]                 NAMES <- toupper(removed)
[17:02:31.778]                 for (kk in seq_along(NAMES)) {
[17:02:31.778]                   name <- removed[[kk]]
[17:02:31.778]                   NAME <- NAMES[[kk]]
[17:02:31.778]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.778]                     next
[17:02:31.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.778]                 }
[17:02:31.778]                 if (length(args) > 0) 
[17:02:31.778]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.778]             }
[17:02:31.778]             else {
[17:02:31.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.778]             }
[17:02:31.778]             {
[17:02:31.778]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.778]                   0L) {
[17:02:31.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.778]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.778]                   base::options(opts)
[17:02:31.778]                 }
[17:02:31.778]                 {
[17:02:31.778]                   {
[17:02:31.778]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.778]                     NULL
[17:02:31.778]                   }
[17:02:31.778]                   options(future.plan = NULL)
[17:02:31.778]                   if (is.na(NA_character_)) 
[17:02:31.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.778]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.778]                     .init = FALSE)
[17:02:31.778]                 }
[17:02:31.778]             }
[17:02:31.778]         }
[17:02:31.778]     })
[17:02:31.778]     if (TRUE) {
[17:02:31.778]         base::sink(type = "output", split = FALSE)
[17:02:31.778]         if (TRUE) {
[17:02:31.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.778]         }
[17:02:31.778]         else {
[17:02:31.778]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.778]         }
[17:02:31.778]         base::close(...future.stdout)
[17:02:31.778]         ...future.stdout <- NULL
[17:02:31.778]     }
[17:02:31.778]     ...future.result$conditions <- ...future.conditions
[17:02:31.778]     ...future.result$finished <- base::Sys.time()
[17:02:31.778]     ...future.result
[17:02:31.778] }
[17:02:31.780] Poll #1 (0): usedNodes() = 2, workers = 2
[17:02:31.791] receiveMessageFromWorker() for ClusterFuture ...
[17:02:31.791] - Validating connection of MultisessionFuture
[17:02:31.792] - received message: FutureResult
[17:02:31.792] - Received FutureResult
[17:02:31.792] - Erased future from FutureRegistry
[17:02:31.792] result() for ClusterFuture ...
[17:02:31.792] - result already collected: FutureResult
[17:02:31.792] result() for ClusterFuture ... done
[17:02:31.792] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:31.792] result() for ClusterFuture ...
[17:02:31.792] - result already collected: FutureResult
[17:02:31.792] result() for ClusterFuture ... done
[17:02:31.793] result() for ClusterFuture ...
[17:02:31.793] - result already collected: FutureResult
[17:02:31.793] result() for ClusterFuture ... done
[17:02:31.794] MultisessionFuture started
[17:02:31.794] - Launch lazy future ... done
[17:02:31.794] run() for ‘MultisessionFuture’ ... done
<environment: 0x55c74b1092d8> 
<environment: 0x55c7496a23c0> 
[17:02:31.796] receiveMessageFromWorker() for ClusterFuture ...
[17:02:31.796] - Validating connection of MultisessionFuture
[17:02:31.796] - received message: FutureResult
[17:02:31.796] - Received FutureResult
[17:02:31.796] - Erased future from FutureRegistry
[17:02:31.796] result() for ClusterFuture ...
[17:02:31.797] - result already collected: FutureResult
[17:02:31.797] result() for ClusterFuture ... done
[17:02:31.797] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:31.797] receiveMessageFromWorker() for ClusterFuture ...
[17:02:31.797] - Validating connection of MultisessionFuture
[17:02:31.797] - received message: FutureResult
[17:02:31.798] - Received FutureResult
[17:02:31.798] - Erased future from FutureRegistry
[17:02:31.798] result() for ClusterFuture ...
[17:02:31.798] - result already collected: FutureResult
[17:02:31.798] result() for ClusterFuture ... done
[17:02:31.798] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:31.799] resolve() on environment ...
[17:02:31.799]  recursive: 0
[17:02:31.800]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:31.800] signalConditionsASAP(numeric, pos=1) ...
[17:02:31.800] - nx: 4
[17:02:31.800] - relay: TRUE
[17:02:31.800] - stdout: TRUE
[17:02:31.800] - signal: TRUE
[17:02:31.800] - resignal: FALSE
[17:02:31.800] - force: TRUE
[17:02:31.800] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.801] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.801]  - until=2
[17:02:31.801]  - relaying element #2
[17:02:31.801] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:31.801] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.801] signalConditionsASAP(NULL, pos=1) ... done
[17:02:31.801]  length: 3 (resolved future 1)
[17:02:31.801] Future #2
[17:02:31.801] result() for ClusterFuture ...
[17:02:31.801] - result already collected: FutureResult
[17:02:31.801] result() for ClusterFuture ... done
[17:02:31.802] result() for ClusterFuture ...
[17:02:31.802] - result already collected: FutureResult
[17:02:31.802] result() for ClusterFuture ... done
[17:02:31.802] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:31.802] - nx: 4
[17:02:31.802] - relay: TRUE
[17:02:31.802] - stdout: TRUE
[17:02:31.802] - signal: TRUE
[17:02:31.802] - resignal: FALSE
[17:02:31.802] - force: TRUE
[17:02:31.802] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:31.802] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.803]  - until=2
[17:02:31.803]  - relaying element #2
[17:02:31.803] result() for ClusterFuture ...
[17:02:31.803] - result already collected: FutureResult
[17:02:31.803] result() for ClusterFuture ... done
[17:02:31.803] result() for ClusterFuture ...
[17:02:31.803] - result already collected: FutureResult
[17:02:31.803] result() for ClusterFuture ... done
[17:02:31.803] result() for ClusterFuture ...
[17:02:31.803] - result already collected: FutureResult
[17:02:31.803] result() for ClusterFuture ... done
[17:02:31.804] result() for ClusterFuture ...
[17:02:31.804] - result already collected: FutureResult
[17:02:31.804] result() for ClusterFuture ... done
[17:02:31.804] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:31.804] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:31.804] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:31.804]  length: 2 (resolved future 2)
[17:02:31.804] Future #3
[17:02:31.804] result() for ClusterFuture ...
[17:02:31.804] - result already collected: FutureResult
[17:02:31.804] result() for ClusterFuture ... done
[17:02:31.805] result() for ClusterFuture ...
[17:02:31.805] - result already collected: FutureResult
[17:02:31.805] result() for ClusterFuture ... done
[17:02:31.805] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:31.805] - nx: 4
[17:02:31.805] - relay: TRUE
[17:02:31.805] - stdout: TRUE
[17:02:31.805] - signal: TRUE
[17:02:31.805] - resignal: FALSE
[17:02:31.805] - force: TRUE
[17:02:31.805] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:31.805] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:31.806]  - until=3
[17:02:31.806]  - relaying element #3
[17:02:31.806] result() for ClusterFuture ...
[17:02:31.806] - result already collected: FutureResult
[17:02:31.806] result() for ClusterFuture ... done
[17:02:31.806] result() for ClusterFuture ...
[17:02:31.806] - result already collected: FutureResult
[17:02:31.806] result() for ClusterFuture ... done
[17:02:31.806] result() for ClusterFuture ...
[17:02:31.806] - result already collected: FutureResult
[17:02:31.806] result() for ClusterFuture ... done
[17:02:31.807] result() for ClusterFuture ...
[17:02:31.807] - result already collected: FutureResult
[17:02:31.807] result() for ClusterFuture ... done
[17:02:31.807] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:31.807] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:31.807] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:31.807]  length: 1 (resolved future 3)
[17:02:31.807] Future #4
[17:02:31.807] result() for ClusterFuture ...
[17:02:31.807] - result already collected: FutureResult
[17:02:31.808] result() for ClusterFuture ... done
[17:02:31.808] result() for ClusterFuture ...
[17:02:31.808] - result already collected: FutureResult
[17:02:31.808] result() for ClusterFuture ... done
[17:02:31.808] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:02:31.808] - nx: 4
[17:02:31.808] - relay: TRUE
[17:02:31.808] - stdout: TRUE
[17:02:31.808] - signal: TRUE
[17:02:31.808] - resignal: FALSE
[17:02:31.808] - force: TRUE
[17:02:31.808] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:31.809] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:31.809]  - until=4
[17:02:31.809]  - relaying element #4
[17:02:31.809] result() for ClusterFuture ...
[17:02:31.809] - result already collected: FutureResult
[17:02:31.809] result() for ClusterFuture ... done
[17:02:31.809] result() for ClusterFuture ...
[17:02:31.809] - result already collected: FutureResult
[17:02:31.809] result() for ClusterFuture ... done
[17:02:31.809] result() for ClusterFuture ...
[17:02:31.809] - result already collected: FutureResult
[17:02:31.810] result() for ClusterFuture ... done
[17:02:31.810] result() for ClusterFuture ...
[17:02:31.810] - result already collected: FutureResult
[17:02:31.810] result() for ClusterFuture ... done
[17:02:31.810] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.810] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:31.810] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:02:31.810]  length: 0 (resolved future 4)
[17:02:31.810] Relaying remaining futures
[17:02:31.810] signalConditionsASAP(NULL, pos=0) ...
[17:02:31.810] - nx: 4
[17:02:31.811] - relay: TRUE
[17:02:31.811] - stdout: TRUE
[17:02:31.811] - signal: TRUE
[17:02:31.811] - resignal: FALSE
[17:02:31.811] - force: TRUE
[17:02:31.811] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.811] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:31.811] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.811] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:31.811] signalConditionsASAP(NULL, pos=0) ... done
[17:02:31.811] resolve() on environment ... DONE
[17:02:31.812] result() for ClusterFuture ...
[17:02:31.812] - result already collected: FutureResult
[17:02:31.812] result() for ClusterFuture ... done
[17:02:31.812] result() for ClusterFuture ...
[17:02:31.812] - result already collected: FutureResult
[17:02:31.812] result() for ClusterFuture ... done
[17:02:31.812] result() for ClusterFuture ...
[17:02:31.812] - result already collected: FutureResult
[17:02:31.812] result() for ClusterFuture ... done
[17:02:31.812] result() for ClusterFuture ...
[17:02:31.812] - result already collected: FutureResult
[17:02:31.813] result() for ClusterFuture ... done
[17:02:31.813] result() for ClusterFuture ...
[17:02:31.813] - result already collected: FutureResult
[17:02:31.813] result() for ClusterFuture ... done
[17:02:31.813] result() for ClusterFuture ...
[17:02:31.813] - result already collected: FutureResult
[17:02:31.813] result() for ClusterFuture ... done
<environment: 0x55c7493d1980> 
Dimensions: c(2, 3)
[17:02:31.814] getGlobalsAndPackages() ...
[17:02:31.814] Searching for globals...
[17:02:31.814] 
[17:02:31.814] Searching for globals ... DONE
[17:02:31.814] - globals: [0] <none>
[17:02:31.814] getGlobalsAndPackages() ... DONE
[17:02:31.815] run() for ‘Future’ ...
[17:02:31.815] - state: ‘created’
[17:02:31.815] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.829] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:31.829]   - Field: ‘node’
[17:02:31.829]   - Field: ‘label’
[17:02:31.830]   - Field: ‘local’
[17:02:31.830]   - Field: ‘owner’
[17:02:31.830]   - Field: ‘envir’
[17:02:31.830]   - Field: ‘workers’
[17:02:31.830]   - Field: ‘packages’
[17:02:31.830]   - Field: ‘gc’
[17:02:31.830]   - Field: ‘conditions’
[17:02:31.830]   - Field: ‘persistent’
[17:02:31.830]   - Field: ‘expr’
[17:02:31.830]   - Field: ‘uuid’
[17:02:31.830]   - Field: ‘seed’
[17:02:31.831]   - Field: ‘version’
[17:02:31.831]   - Field: ‘result’
[17:02:31.831]   - Field: ‘asynchronous’
[17:02:31.831]   - Field: ‘calls’
[17:02:31.831]   - Field: ‘globals’
[17:02:31.831]   - Field: ‘stdout’
[17:02:31.831]   - Field: ‘earlySignal’
[17:02:31.831]   - Field: ‘lazy’
[17:02:31.832]   - Field: ‘state’
[17:02:31.832] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:31.832] - Launch lazy future ...
[17:02:31.832] Packages needed by the future expression (n = 0): <none>
[17:02:31.832] Packages needed by future strategies (n = 0): <none>
[17:02:31.833] {
[17:02:31.833]     {
[17:02:31.833]         {
[17:02:31.833]             ...future.startTime <- base::Sys.time()
[17:02:31.833]             {
[17:02:31.833]                 {
[17:02:31.833]                   {
[17:02:31.833]                     {
[17:02:31.833]                       base::local({
[17:02:31.833]                         has_future <- base::requireNamespace("future", 
[17:02:31.833]                           quietly = TRUE)
[17:02:31.833]                         if (has_future) {
[17:02:31.833]                           ns <- base::getNamespace("future")
[17:02:31.833]                           version <- ns[[".package"]][["version"]]
[17:02:31.833]                           if (is.null(version)) 
[17:02:31.833]                             version <- utils::packageVersion("future")
[17:02:31.833]                         }
[17:02:31.833]                         else {
[17:02:31.833]                           version <- NULL
[17:02:31.833]                         }
[17:02:31.833]                         if (!has_future || version < "1.8.0") {
[17:02:31.833]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.833]                             "", base::R.version$version.string), 
[17:02:31.833]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.833]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.833]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.833]                               "release", "version")], collapse = " "), 
[17:02:31.833]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.833]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.833]                             info)
[17:02:31.833]                           info <- base::paste(info, collapse = "; ")
[17:02:31.833]                           if (!has_future) {
[17:02:31.833]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.833]                               info)
[17:02:31.833]                           }
[17:02:31.833]                           else {
[17:02:31.833]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.833]                               info, version)
[17:02:31.833]                           }
[17:02:31.833]                           base::stop(msg)
[17:02:31.833]                         }
[17:02:31.833]                       })
[17:02:31.833]                     }
[17:02:31.833]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.833]                     base::options(mc.cores = 1L)
[17:02:31.833]                   }
[17:02:31.833]                   ...future.strategy.old <- future::plan("list")
[17:02:31.833]                   options(future.plan = NULL)
[17:02:31.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.833]                 }
[17:02:31.833]                 ...future.workdir <- getwd()
[17:02:31.833]             }
[17:02:31.833]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.833]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.833]         }
[17:02:31.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.833]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.833]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.833]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.833]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.833]             base::names(...future.oldOptions))
[17:02:31.833]     }
[17:02:31.833]     if (FALSE) {
[17:02:31.833]     }
[17:02:31.833]     else {
[17:02:31.833]         if (TRUE) {
[17:02:31.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.833]                 open = "w")
[17:02:31.833]         }
[17:02:31.833]         else {
[17:02:31.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.833]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.833]         }
[17:02:31.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.833]             base::sink(type = "output", split = FALSE)
[17:02:31.833]             base::close(...future.stdout)
[17:02:31.833]         }, add = TRUE)
[17:02:31.833]     }
[17:02:31.833]     ...future.frame <- base::sys.nframe()
[17:02:31.833]     ...future.conditions <- base::list()
[17:02:31.833]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.833]     if (FALSE) {
[17:02:31.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.833]     }
[17:02:31.833]     ...future.result <- base::tryCatch({
[17:02:31.833]         base::withCallingHandlers({
[17:02:31.833]             ...future.value <- base::withVisible(base::local({
[17:02:31.833]                 ...future.makeSendCondition <- base::local({
[17:02:31.833]                   sendCondition <- NULL
[17:02:31.833]                   function(frame = 1L) {
[17:02:31.833]                     if (is.function(sendCondition)) 
[17:02:31.833]                       return(sendCondition)
[17:02:31.833]                     ns <- getNamespace("parallel")
[17:02:31.833]                     if (exists("sendData", mode = "function", 
[17:02:31.833]                       envir = ns)) {
[17:02:31.833]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:31.833]                         envir = ns)
[17:02:31.833]                       envir <- sys.frame(frame)
[17:02:31.833]                       master <- NULL
[17:02:31.833]                       while (!identical(envir, .GlobalEnv) && 
[17:02:31.833]                         !identical(envir, emptyenv())) {
[17:02:31.833]                         if (exists("master", mode = "list", envir = envir, 
[17:02:31.833]                           inherits = FALSE)) {
[17:02:31.833]                           master <- get("master", mode = "list", 
[17:02:31.833]                             envir = envir, inherits = FALSE)
[17:02:31.833]                           if (inherits(master, c("SOCKnode", 
[17:02:31.833]                             "SOCK0node"))) {
[17:02:31.833]                             sendCondition <<- function(cond) {
[17:02:31.833]                               data <- list(type = "VALUE", value = cond, 
[17:02:31.833]                                 success = TRUE)
[17:02:31.833]                               parallel_sendData(master, data)
[17:02:31.833]                             }
[17:02:31.833]                             return(sendCondition)
[17:02:31.833]                           }
[17:02:31.833]                         }
[17:02:31.833]                         frame <- frame + 1L
[17:02:31.833]                         envir <- sys.frame(frame)
[17:02:31.833]                       }
[17:02:31.833]                     }
[17:02:31.833]                     sendCondition <<- function(cond) NULL
[17:02:31.833]                   }
[17:02:31.833]                 })
[17:02:31.833]                 withCallingHandlers({
[17:02:31.833]                   2
[17:02:31.833]                 }, immediateCondition = function(cond) {
[17:02:31.833]                   sendCondition <- ...future.makeSendCondition()
[17:02:31.833]                   sendCondition(cond)
[17:02:31.833]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.833]                   {
[17:02:31.833]                     inherits <- base::inherits
[17:02:31.833]                     invokeRestart <- base::invokeRestart
[17:02:31.833]                     is.null <- base::is.null
[17:02:31.833]                     muffled <- FALSE
[17:02:31.833]                     if (inherits(cond, "message")) {
[17:02:31.833]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.833]                       if (muffled) 
[17:02:31.833]                         invokeRestart("muffleMessage")
[17:02:31.833]                     }
[17:02:31.833]                     else if (inherits(cond, "warning")) {
[17:02:31.833]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.833]                       if (muffled) 
[17:02:31.833]                         invokeRestart("muffleWarning")
[17:02:31.833]                     }
[17:02:31.833]                     else if (inherits(cond, "condition")) {
[17:02:31.833]                       if (!is.null(pattern)) {
[17:02:31.833]                         computeRestarts <- base::computeRestarts
[17:02:31.833]                         grepl <- base::grepl
[17:02:31.833]                         restarts <- computeRestarts(cond)
[17:02:31.833]                         for (restart in restarts) {
[17:02:31.833]                           name <- restart$name
[17:02:31.833]                           if (is.null(name)) 
[17:02:31.833]                             next
[17:02:31.833]                           if (!grepl(pattern, name)) 
[17:02:31.833]                             next
[17:02:31.833]                           invokeRestart(restart)
[17:02:31.833]                           muffled <- TRUE
[17:02:31.833]                           break
[17:02:31.833]                         }
[17:02:31.833]                       }
[17:02:31.833]                     }
[17:02:31.833]                     invisible(muffled)
[17:02:31.833]                   }
[17:02:31.833]                   muffleCondition(cond)
[17:02:31.833]                 })
[17:02:31.833]             }))
[17:02:31.833]             future::FutureResult(value = ...future.value$value, 
[17:02:31.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.833]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.833]                     ...future.globalenv.names))
[17:02:31.833]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.833]         }, condition = base::local({
[17:02:31.833]             c <- base::c
[17:02:31.833]             inherits <- base::inherits
[17:02:31.833]             invokeRestart <- base::invokeRestart
[17:02:31.833]             length <- base::length
[17:02:31.833]             list <- base::list
[17:02:31.833]             seq.int <- base::seq.int
[17:02:31.833]             signalCondition <- base::signalCondition
[17:02:31.833]             sys.calls <- base::sys.calls
[17:02:31.833]             `[[` <- base::`[[`
[17:02:31.833]             `+` <- base::`+`
[17:02:31.833]             `<<-` <- base::`<<-`
[17:02:31.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.833]                   3L)]
[17:02:31.833]             }
[17:02:31.833]             function(cond) {
[17:02:31.833]                 is_error <- inherits(cond, "error")
[17:02:31.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.833]                   NULL)
[17:02:31.833]                 if (is_error) {
[17:02:31.833]                   sessionInformation <- function() {
[17:02:31.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.833]                       search = base::search(), system = base::Sys.info())
[17:02:31.833]                   }
[17:02:31.833]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.833]                     cond$call), session = sessionInformation(), 
[17:02:31.833]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.833]                   signalCondition(cond)
[17:02:31.833]                 }
[17:02:31.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.833]                 "immediateCondition"))) {
[17:02:31.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.833]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.833]                   if (TRUE && !signal) {
[17:02:31.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.833]                     {
[17:02:31.833]                       inherits <- base::inherits
[17:02:31.833]                       invokeRestart <- base::invokeRestart
[17:02:31.833]                       is.null <- base::is.null
[17:02:31.833]                       muffled <- FALSE
[17:02:31.833]                       if (inherits(cond, "message")) {
[17:02:31.833]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.833]                         if (muffled) 
[17:02:31.833]                           invokeRestart("muffleMessage")
[17:02:31.833]                       }
[17:02:31.833]                       else if (inherits(cond, "warning")) {
[17:02:31.833]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.833]                         if (muffled) 
[17:02:31.833]                           invokeRestart("muffleWarning")
[17:02:31.833]                       }
[17:02:31.833]                       else if (inherits(cond, "condition")) {
[17:02:31.833]                         if (!is.null(pattern)) {
[17:02:31.833]                           computeRestarts <- base::computeRestarts
[17:02:31.833]                           grepl <- base::grepl
[17:02:31.833]                           restarts <- computeRestarts(cond)
[17:02:31.833]                           for (restart in restarts) {
[17:02:31.833]                             name <- restart$name
[17:02:31.833]                             if (is.null(name)) 
[17:02:31.833]                               next
[17:02:31.833]                             if (!grepl(pattern, name)) 
[17:02:31.833]                               next
[17:02:31.833]                             invokeRestart(restart)
[17:02:31.833]                             muffled <- TRUE
[17:02:31.833]                             break
[17:02:31.833]                           }
[17:02:31.833]                         }
[17:02:31.833]                       }
[17:02:31.833]                       invisible(muffled)
[17:02:31.833]                     }
[17:02:31.833]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.833]                   }
[17:02:31.833]                 }
[17:02:31.833]                 else {
[17:02:31.833]                   if (TRUE) {
[17:02:31.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.833]                     {
[17:02:31.833]                       inherits <- base::inherits
[17:02:31.833]                       invokeRestart <- base::invokeRestart
[17:02:31.833]                       is.null <- base::is.null
[17:02:31.833]                       muffled <- FALSE
[17:02:31.833]                       if (inherits(cond, "message")) {
[17:02:31.833]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.833]                         if (muffled) 
[17:02:31.833]                           invokeRestart("muffleMessage")
[17:02:31.833]                       }
[17:02:31.833]                       else if (inherits(cond, "warning")) {
[17:02:31.833]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.833]                         if (muffled) 
[17:02:31.833]                           invokeRestart("muffleWarning")
[17:02:31.833]                       }
[17:02:31.833]                       else if (inherits(cond, "condition")) {
[17:02:31.833]                         if (!is.null(pattern)) {
[17:02:31.833]                           computeRestarts <- base::computeRestarts
[17:02:31.833]                           grepl <- base::grepl
[17:02:31.833]                           restarts <- computeRestarts(cond)
[17:02:31.833]                           for (restart in restarts) {
[17:02:31.833]                             name <- restart$name
[17:02:31.833]                             if (is.null(name)) 
[17:02:31.833]                               next
[17:02:31.833]                             if (!grepl(pattern, name)) 
[17:02:31.833]                               next
[17:02:31.833]                             invokeRestart(restart)
[17:02:31.833]                             muffled <- TRUE
[17:02:31.833]                             break
[17:02:31.833]                           }
[17:02:31.833]                         }
[17:02:31.833]                       }
[17:02:31.833]                       invisible(muffled)
[17:02:31.833]                     }
[17:02:31.833]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.833]                   }
[17:02:31.833]                 }
[17:02:31.833]             }
[17:02:31.833]         }))
[17:02:31.833]     }, error = function(ex) {
[17:02:31.833]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.833]                 ...future.rng), started = ...future.startTime, 
[17:02:31.833]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.833]             version = "1.8"), class = "FutureResult")
[17:02:31.833]     }, finally = {
[17:02:31.833]         if (!identical(...future.workdir, getwd())) 
[17:02:31.833]             setwd(...future.workdir)
[17:02:31.833]         {
[17:02:31.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.833]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.833]             }
[17:02:31.833]             base::options(...future.oldOptions)
[17:02:31.833]             if (.Platform$OS.type == "windows") {
[17:02:31.833]                 old_names <- names(...future.oldEnvVars)
[17:02:31.833]                 envs <- base::Sys.getenv()
[17:02:31.833]                 names <- names(envs)
[17:02:31.833]                 common <- intersect(names, old_names)
[17:02:31.833]                 added <- setdiff(names, old_names)
[17:02:31.833]                 removed <- setdiff(old_names, names)
[17:02:31.833]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.833]                   envs[common]]
[17:02:31.833]                 NAMES <- toupper(changed)
[17:02:31.833]                 args <- list()
[17:02:31.833]                 for (kk in seq_along(NAMES)) {
[17:02:31.833]                   name <- changed[[kk]]
[17:02:31.833]                   NAME <- NAMES[[kk]]
[17:02:31.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.833]                     next
[17:02:31.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.833]                 }
[17:02:31.833]                 NAMES <- toupper(added)
[17:02:31.833]                 for (kk in seq_along(NAMES)) {
[17:02:31.833]                   name <- added[[kk]]
[17:02:31.833]                   NAME <- NAMES[[kk]]
[17:02:31.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.833]                     next
[17:02:31.833]                   args[[name]] <- ""
[17:02:31.833]                 }
[17:02:31.833]                 NAMES <- toupper(removed)
[17:02:31.833]                 for (kk in seq_along(NAMES)) {
[17:02:31.833]                   name <- removed[[kk]]
[17:02:31.833]                   NAME <- NAMES[[kk]]
[17:02:31.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.833]                     next
[17:02:31.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.833]                 }
[17:02:31.833]                 if (length(args) > 0) 
[17:02:31.833]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.833]             }
[17:02:31.833]             else {
[17:02:31.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.833]             }
[17:02:31.833]             {
[17:02:31.833]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.833]                   0L) {
[17:02:31.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.833]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.833]                   base::options(opts)
[17:02:31.833]                 }
[17:02:31.833]                 {
[17:02:31.833]                   {
[17:02:31.833]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.833]                     NULL
[17:02:31.833]                   }
[17:02:31.833]                   options(future.plan = NULL)
[17:02:31.833]                   if (is.na(NA_character_)) 
[17:02:31.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.833]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.833]                     .init = FALSE)
[17:02:31.833]                 }
[17:02:31.833]             }
[17:02:31.833]         }
[17:02:31.833]     })
[17:02:31.833]     if (TRUE) {
[17:02:31.833]         base::sink(type = "output", split = FALSE)
[17:02:31.833]         if (TRUE) {
[17:02:31.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.833]         }
[17:02:31.833]         else {
[17:02:31.833]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.833]         }
[17:02:31.833]         base::close(...future.stdout)
[17:02:31.833]         ...future.stdout <- NULL
[17:02:31.833]     }
[17:02:31.833]     ...future.result$conditions <- ...future.conditions
[17:02:31.833]     ...future.result$finished <- base::Sys.time()
[17:02:31.833]     ...future.result
[17:02:31.833] }
[17:02:31.836] MultisessionFuture started
[17:02:31.836] - Launch lazy future ... done
[17:02:31.836] run() for ‘MultisessionFuture’ ... done
[17:02:31.836] getGlobalsAndPackages() ...
[17:02:31.836] Searching for globals...
[17:02:31.836] 
[17:02:31.837] Searching for globals ... DONE
[17:02:31.837] - globals: [0] <none>
[17:02:31.837] getGlobalsAndPackages() ... DONE
[17:02:31.837] run() for ‘Future’ ...
[17:02:31.837] - state: ‘created’
[17:02:31.837] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.851] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.852] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:31.852]   - Field: ‘node’
[17:02:31.852]   - Field: ‘label’
[17:02:31.852]   - Field: ‘local’
[17:02:31.852]   - Field: ‘owner’
[17:02:31.852]   - Field: ‘envir’
[17:02:31.852]   - Field: ‘workers’
[17:02:31.852]   - Field: ‘packages’
[17:02:31.852]   - Field: ‘gc’
[17:02:31.853]   - Field: ‘conditions’
[17:02:31.853]   - Field: ‘persistent’
[17:02:31.853]   - Field: ‘expr’
[17:02:31.853]   - Field: ‘uuid’
[17:02:31.853]   - Field: ‘seed’
[17:02:31.853]   - Field: ‘version’
[17:02:31.853]   - Field: ‘result’
[17:02:31.853]   - Field: ‘asynchronous’
[17:02:31.853]   - Field: ‘calls’
[17:02:31.853]   - Field: ‘globals’
[17:02:31.853]   - Field: ‘stdout’
[17:02:31.854]   - Field: ‘earlySignal’
[17:02:31.854]   - Field: ‘lazy’
[17:02:31.854]   - Field: ‘state’
[17:02:31.854] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:31.854] - Launch lazy future ...
[17:02:31.854] Packages needed by the future expression (n = 0): <none>
[17:02:31.854] Packages needed by future strategies (n = 0): <none>
[17:02:31.855] {
[17:02:31.855]     {
[17:02:31.855]         {
[17:02:31.855]             ...future.startTime <- base::Sys.time()
[17:02:31.855]             {
[17:02:31.855]                 {
[17:02:31.855]                   {
[17:02:31.855]                     {
[17:02:31.855]                       base::local({
[17:02:31.855]                         has_future <- base::requireNamespace("future", 
[17:02:31.855]                           quietly = TRUE)
[17:02:31.855]                         if (has_future) {
[17:02:31.855]                           ns <- base::getNamespace("future")
[17:02:31.855]                           version <- ns[[".package"]][["version"]]
[17:02:31.855]                           if (is.null(version)) 
[17:02:31.855]                             version <- utils::packageVersion("future")
[17:02:31.855]                         }
[17:02:31.855]                         else {
[17:02:31.855]                           version <- NULL
[17:02:31.855]                         }
[17:02:31.855]                         if (!has_future || version < "1.8.0") {
[17:02:31.855]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.855]                             "", base::R.version$version.string), 
[17:02:31.855]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.855]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.855]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.855]                               "release", "version")], collapse = " "), 
[17:02:31.855]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.855]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.855]                             info)
[17:02:31.855]                           info <- base::paste(info, collapse = "; ")
[17:02:31.855]                           if (!has_future) {
[17:02:31.855]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.855]                               info)
[17:02:31.855]                           }
[17:02:31.855]                           else {
[17:02:31.855]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.855]                               info, version)
[17:02:31.855]                           }
[17:02:31.855]                           base::stop(msg)
[17:02:31.855]                         }
[17:02:31.855]                       })
[17:02:31.855]                     }
[17:02:31.855]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.855]                     base::options(mc.cores = 1L)
[17:02:31.855]                   }
[17:02:31.855]                   ...future.strategy.old <- future::plan("list")
[17:02:31.855]                   options(future.plan = NULL)
[17:02:31.855]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.855]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.855]                 }
[17:02:31.855]                 ...future.workdir <- getwd()
[17:02:31.855]             }
[17:02:31.855]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.855]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.855]         }
[17:02:31.855]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.855]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.855]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.855]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.855]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.855]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.855]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.855]             base::names(...future.oldOptions))
[17:02:31.855]     }
[17:02:31.855]     if (FALSE) {
[17:02:31.855]     }
[17:02:31.855]     else {
[17:02:31.855]         if (TRUE) {
[17:02:31.855]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.855]                 open = "w")
[17:02:31.855]         }
[17:02:31.855]         else {
[17:02:31.855]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.855]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.855]         }
[17:02:31.855]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.855]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.855]             base::sink(type = "output", split = FALSE)
[17:02:31.855]             base::close(...future.stdout)
[17:02:31.855]         }, add = TRUE)
[17:02:31.855]     }
[17:02:31.855]     ...future.frame <- base::sys.nframe()
[17:02:31.855]     ...future.conditions <- base::list()
[17:02:31.855]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.855]     if (FALSE) {
[17:02:31.855]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.855]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.855]     }
[17:02:31.855]     ...future.result <- base::tryCatch({
[17:02:31.855]         base::withCallingHandlers({
[17:02:31.855]             ...future.value <- base::withVisible(base::local({
[17:02:31.855]                 ...future.makeSendCondition <- base::local({
[17:02:31.855]                   sendCondition <- NULL
[17:02:31.855]                   function(frame = 1L) {
[17:02:31.855]                     if (is.function(sendCondition)) 
[17:02:31.855]                       return(sendCondition)
[17:02:31.855]                     ns <- getNamespace("parallel")
[17:02:31.855]                     if (exists("sendData", mode = "function", 
[17:02:31.855]                       envir = ns)) {
[17:02:31.855]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:31.855]                         envir = ns)
[17:02:31.855]                       envir <- sys.frame(frame)
[17:02:31.855]                       master <- NULL
[17:02:31.855]                       while (!identical(envir, .GlobalEnv) && 
[17:02:31.855]                         !identical(envir, emptyenv())) {
[17:02:31.855]                         if (exists("master", mode = "list", envir = envir, 
[17:02:31.855]                           inherits = FALSE)) {
[17:02:31.855]                           master <- get("master", mode = "list", 
[17:02:31.855]                             envir = envir, inherits = FALSE)
[17:02:31.855]                           if (inherits(master, c("SOCKnode", 
[17:02:31.855]                             "SOCK0node"))) {
[17:02:31.855]                             sendCondition <<- function(cond) {
[17:02:31.855]                               data <- list(type = "VALUE", value = cond, 
[17:02:31.855]                                 success = TRUE)
[17:02:31.855]                               parallel_sendData(master, data)
[17:02:31.855]                             }
[17:02:31.855]                             return(sendCondition)
[17:02:31.855]                           }
[17:02:31.855]                         }
[17:02:31.855]                         frame <- frame + 1L
[17:02:31.855]                         envir <- sys.frame(frame)
[17:02:31.855]                       }
[17:02:31.855]                     }
[17:02:31.855]                     sendCondition <<- function(cond) NULL
[17:02:31.855]                   }
[17:02:31.855]                 })
[17:02:31.855]                 withCallingHandlers({
[17:02:31.855]                   NULL
[17:02:31.855]                 }, immediateCondition = function(cond) {
[17:02:31.855]                   sendCondition <- ...future.makeSendCondition()
[17:02:31.855]                   sendCondition(cond)
[17:02:31.855]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.855]                   {
[17:02:31.855]                     inherits <- base::inherits
[17:02:31.855]                     invokeRestart <- base::invokeRestart
[17:02:31.855]                     is.null <- base::is.null
[17:02:31.855]                     muffled <- FALSE
[17:02:31.855]                     if (inherits(cond, "message")) {
[17:02:31.855]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.855]                       if (muffled) 
[17:02:31.855]                         invokeRestart("muffleMessage")
[17:02:31.855]                     }
[17:02:31.855]                     else if (inherits(cond, "warning")) {
[17:02:31.855]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.855]                       if (muffled) 
[17:02:31.855]                         invokeRestart("muffleWarning")
[17:02:31.855]                     }
[17:02:31.855]                     else if (inherits(cond, "condition")) {
[17:02:31.855]                       if (!is.null(pattern)) {
[17:02:31.855]                         computeRestarts <- base::computeRestarts
[17:02:31.855]                         grepl <- base::grepl
[17:02:31.855]                         restarts <- computeRestarts(cond)
[17:02:31.855]                         for (restart in restarts) {
[17:02:31.855]                           name <- restart$name
[17:02:31.855]                           if (is.null(name)) 
[17:02:31.855]                             next
[17:02:31.855]                           if (!grepl(pattern, name)) 
[17:02:31.855]                             next
[17:02:31.855]                           invokeRestart(restart)
[17:02:31.855]                           muffled <- TRUE
[17:02:31.855]                           break
[17:02:31.855]                         }
[17:02:31.855]                       }
[17:02:31.855]                     }
[17:02:31.855]                     invisible(muffled)
[17:02:31.855]                   }
[17:02:31.855]                   muffleCondition(cond)
[17:02:31.855]                 })
[17:02:31.855]             }))
[17:02:31.855]             future::FutureResult(value = ...future.value$value, 
[17:02:31.855]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.855]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.855]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.855]                     ...future.globalenv.names))
[17:02:31.855]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.855]         }, condition = base::local({
[17:02:31.855]             c <- base::c
[17:02:31.855]             inherits <- base::inherits
[17:02:31.855]             invokeRestart <- base::invokeRestart
[17:02:31.855]             length <- base::length
[17:02:31.855]             list <- base::list
[17:02:31.855]             seq.int <- base::seq.int
[17:02:31.855]             signalCondition <- base::signalCondition
[17:02:31.855]             sys.calls <- base::sys.calls
[17:02:31.855]             `[[` <- base::`[[`
[17:02:31.855]             `+` <- base::`+`
[17:02:31.855]             `<<-` <- base::`<<-`
[17:02:31.855]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.855]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.855]                   3L)]
[17:02:31.855]             }
[17:02:31.855]             function(cond) {
[17:02:31.855]                 is_error <- inherits(cond, "error")
[17:02:31.855]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.855]                   NULL)
[17:02:31.855]                 if (is_error) {
[17:02:31.855]                   sessionInformation <- function() {
[17:02:31.855]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.855]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.855]                       search = base::search(), system = base::Sys.info())
[17:02:31.855]                   }
[17:02:31.855]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.855]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.855]                     cond$call), session = sessionInformation(), 
[17:02:31.855]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.855]                   signalCondition(cond)
[17:02:31.855]                 }
[17:02:31.855]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.855]                 "immediateCondition"))) {
[17:02:31.855]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.855]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.855]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.855]                   if (TRUE && !signal) {
[17:02:31.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.855]                     {
[17:02:31.855]                       inherits <- base::inherits
[17:02:31.855]                       invokeRestart <- base::invokeRestart
[17:02:31.855]                       is.null <- base::is.null
[17:02:31.855]                       muffled <- FALSE
[17:02:31.855]                       if (inherits(cond, "message")) {
[17:02:31.855]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.855]                         if (muffled) 
[17:02:31.855]                           invokeRestart("muffleMessage")
[17:02:31.855]                       }
[17:02:31.855]                       else if (inherits(cond, "warning")) {
[17:02:31.855]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.855]                         if (muffled) 
[17:02:31.855]                           invokeRestart("muffleWarning")
[17:02:31.855]                       }
[17:02:31.855]                       else if (inherits(cond, "condition")) {
[17:02:31.855]                         if (!is.null(pattern)) {
[17:02:31.855]                           computeRestarts <- base::computeRestarts
[17:02:31.855]                           grepl <- base::grepl
[17:02:31.855]                           restarts <- computeRestarts(cond)
[17:02:31.855]                           for (restart in restarts) {
[17:02:31.855]                             name <- restart$name
[17:02:31.855]                             if (is.null(name)) 
[17:02:31.855]                               next
[17:02:31.855]                             if (!grepl(pattern, name)) 
[17:02:31.855]                               next
[17:02:31.855]                             invokeRestart(restart)
[17:02:31.855]                             muffled <- TRUE
[17:02:31.855]                             break
[17:02:31.855]                           }
[17:02:31.855]                         }
[17:02:31.855]                       }
[17:02:31.855]                       invisible(muffled)
[17:02:31.855]                     }
[17:02:31.855]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.855]                   }
[17:02:31.855]                 }
[17:02:31.855]                 else {
[17:02:31.855]                   if (TRUE) {
[17:02:31.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.855]                     {
[17:02:31.855]                       inherits <- base::inherits
[17:02:31.855]                       invokeRestart <- base::invokeRestart
[17:02:31.855]                       is.null <- base::is.null
[17:02:31.855]                       muffled <- FALSE
[17:02:31.855]                       if (inherits(cond, "message")) {
[17:02:31.855]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.855]                         if (muffled) 
[17:02:31.855]                           invokeRestart("muffleMessage")
[17:02:31.855]                       }
[17:02:31.855]                       else if (inherits(cond, "warning")) {
[17:02:31.855]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.855]                         if (muffled) 
[17:02:31.855]                           invokeRestart("muffleWarning")
[17:02:31.855]                       }
[17:02:31.855]                       else if (inherits(cond, "condition")) {
[17:02:31.855]                         if (!is.null(pattern)) {
[17:02:31.855]                           computeRestarts <- base::computeRestarts
[17:02:31.855]                           grepl <- base::grepl
[17:02:31.855]                           restarts <- computeRestarts(cond)
[17:02:31.855]                           for (restart in restarts) {
[17:02:31.855]                             name <- restart$name
[17:02:31.855]                             if (is.null(name)) 
[17:02:31.855]                               next
[17:02:31.855]                             if (!grepl(pattern, name)) 
[17:02:31.855]                               next
[17:02:31.855]                             invokeRestart(restart)
[17:02:31.855]                             muffled <- TRUE
[17:02:31.855]                             break
[17:02:31.855]                           }
[17:02:31.855]                         }
[17:02:31.855]                       }
[17:02:31.855]                       invisible(muffled)
[17:02:31.855]                     }
[17:02:31.855]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.855]                   }
[17:02:31.855]                 }
[17:02:31.855]             }
[17:02:31.855]         }))
[17:02:31.855]     }, error = function(ex) {
[17:02:31.855]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.855]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.855]                 ...future.rng), started = ...future.startTime, 
[17:02:31.855]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.855]             version = "1.8"), class = "FutureResult")
[17:02:31.855]     }, finally = {
[17:02:31.855]         if (!identical(...future.workdir, getwd())) 
[17:02:31.855]             setwd(...future.workdir)
[17:02:31.855]         {
[17:02:31.855]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.855]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.855]             }
[17:02:31.855]             base::options(...future.oldOptions)
[17:02:31.855]             if (.Platform$OS.type == "windows") {
[17:02:31.855]                 old_names <- names(...future.oldEnvVars)
[17:02:31.855]                 envs <- base::Sys.getenv()
[17:02:31.855]                 names <- names(envs)
[17:02:31.855]                 common <- intersect(names, old_names)
[17:02:31.855]                 added <- setdiff(names, old_names)
[17:02:31.855]                 removed <- setdiff(old_names, names)
[17:02:31.855]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.855]                   envs[common]]
[17:02:31.855]                 NAMES <- toupper(changed)
[17:02:31.855]                 args <- list()
[17:02:31.855]                 for (kk in seq_along(NAMES)) {
[17:02:31.855]                   name <- changed[[kk]]
[17:02:31.855]                   NAME <- NAMES[[kk]]
[17:02:31.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.855]                     next
[17:02:31.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.855]                 }
[17:02:31.855]                 NAMES <- toupper(added)
[17:02:31.855]                 for (kk in seq_along(NAMES)) {
[17:02:31.855]                   name <- added[[kk]]
[17:02:31.855]                   NAME <- NAMES[[kk]]
[17:02:31.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.855]                     next
[17:02:31.855]                   args[[name]] <- ""
[17:02:31.855]                 }
[17:02:31.855]                 NAMES <- toupper(removed)
[17:02:31.855]                 for (kk in seq_along(NAMES)) {
[17:02:31.855]                   name <- removed[[kk]]
[17:02:31.855]                   NAME <- NAMES[[kk]]
[17:02:31.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.855]                     next
[17:02:31.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.855]                 }
[17:02:31.855]                 if (length(args) > 0) 
[17:02:31.855]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.855]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.855]             }
[17:02:31.855]             else {
[17:02:31.855]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.855]             }
[17:02:31.855]             {
[17:02:31.855]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.855]                   0L) {
[17:02:31.855]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.855]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.855]                   base::options(opts)
[17:02:31.855]                 }
[17:02:31.855]                 {
[17:02:31.855]                   {
[17:02:31.855]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.855]                     NULL
[17:02:31.855]                   }
[17:02:31.855]                   options(future.plan = NULL)
[17:02:31.855]                   if (is.na(NA_character_)) 
[17:02:31.855]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.855]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.855]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.855]                     .init = FALSE)
[17:02:31.855]                 }
[17:02:31.855]             }
[17:02:31.855]         }
[17:02:31.855]     })
[17:02:31.855]     if (TRUE) {
[17:02:31.855]         base::sink(type = "output", split = FALSE)
[17:02:31.855]         if (TRUE) {
[17:02:31.855]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.855]         }
[17:02:31.855]         else {
[17:02:31.855]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.855]         }
[17:02:31.855]         base::close(...future.stdout)
[17:02:31.855]         ...future.stdout <- NULL
[17:02:31.855]     }
[17:02:31.855]     ...future.result$conditions <- ...future.conditions
[17:02:31.855]     ...future.result$finished <- base::Sys.time()
[17:02:31.855]     ...future.result
[17:02:31.855] }
[17:02:31.858] MultisessionFuture started
[17:02:31.858] - Launch lazy future ... done
[17:02:31.858] run() for ‘MultisessionFuture’ ... done
[17:02:31.859] getGlobalsAndPackages() ...
[17:02:31.859] Searching for globals...
[17:02:31.860] - globals found: [1] ‘{’
[17:02:31.860] Searching for globals ... DONE
[17:02:31.860] Resolving globals: FALSE
[17:02:31.861] 
[17:02:31.861] 
[17:02:31.861] getGlobalsAndPackages() ... DONE
[17:02:31.861] run() for ‘Future’ ...
[17:02:31.861] - state: ‘created’
[17:02:31.862] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.876] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:31.876]   - Field: ‘node’
[17:02:31.877]   - Field: ‘label’
[17:02:31.877]   - Field: ‘local’
[17:02:31.877]   - Field: ‘owner’
[17:02:31.877]   - Field: ‘envir’
[17:02:31.877]   - Field: ‘workers’
[17:02:31.877]   - Field: ‘packages’
[17:02:31.877]   - Field: ‘gc’
[17:02:31.877]   - Field: ‘conditions’
[17:02:31.877]   - Field: ‘persistent’
[17:02:31.877]   - Field: ‘expr’
[17:02:31.877]   - Field: ‘uuid’
[17:02:31.878]   - Field: ‘seed’
[17:02:31.878]   - Field: ‘version’
[17:02:31.878]   - Field: ‘result’
[17:02:31.878]   - Field: ‘asynchronous’
[17:02:31.878]   - Field: ‘calls’
[17:02:31.878]   - Field: ‘globals’
[17:02:31.878]   - Field: ‘stdout’
[17:02:31.878]   - Field: ‘earlySignal’
[17:02:31.878]   - Field: ‘lazy’
[17:02:31.878]   - Field: ‘state’
[17:02:31.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:31.879] - Launch lazy future ...
[17:02:31.879] Packages needed by the future expression (n = 0): <none>
[17:02:31.879] Packages needed by future strategies (n = 0): <none>
[17:02:31.879] {
[17:02:31.879]     {
[17:02:31.879]         {
[17:02:31.879]             ...future.startTime <- base::Sys.time()
[17:02:31.879]             {
[17:02:31.879]                 {
[17:02:31.879]                   {
[17:02:31.879]                     {
[17:02:31.879]                       base::local({
[17:02:31.879]                         has_future <- base::requireNamespace("future", 
[17:02:31.879]                           quietly = TRUE)
[17:02:31.879]                         if (has_future) {
[17:02:31.879]                           ns <- base::getNamespace("future")
[17:02:31.879]                           version <- ns[[".package"]][["version"]]
[17:02:31.879]                           if (is.null(version)) 
[17:02:31.879]                             version <- utils::packageVersion("future")
[17:02:31.879]                         }
[17:02:31.879]                         else {
[17:02:31.879]                           version <- NULL
[17:02:31.879]                         }
[17:02:31.879]                         if (!has_future || version < "1.8.0") {
[17:02:31.879]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.879]                             "", base::R.version$version.string), 
[17:02:31.879]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.879]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.879]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.879]                               "release", "version")], collapse = " "), 
[17:02:31.879]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.879]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.879]                             info)
[17:02:31.879]                           info <- base::paste(info, collapse = "; ")
[17:02:31.879]                           if (!has_future) {
[17:02:31.879]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.879]                               info)
[17:02:31.879]                           }
[17:02:31.879]                           else {
[17:02:31.879]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.879]                               info, version)
[17:02:31.879]                           }
[17:02:31.879]                           base::stop(msg)
[17:02:31.879]                         }
[17:02:31.879]                       })
[17:02:31.879]                     }
[17:02:31.879]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.879]                     base::options(mc.cores = 1L)
[17:02:31.879]                   }
[17:02:31.879]                   ...future.strategy.old <- future::plan("list")
[17:02:31.879]                   options(future.plan = NULL)
[17:02:31.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.879]                 }
[17:02:31.879]                 ...future.workdir <- getwd()
[17:02:31.879]             }
[17:02:31.879]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.879]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.879]         }
[17:02:31.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.879]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.879]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.879]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.879]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.879]             base::names(...future.oldOptions))
[17:02:31.879]     }
[17:02:31.879]     if (FALSE) {
[17:02:31.879]     }
[17:02:31.879]     else {
[17:02:31.879]         if (TRUE) {
[17:02:31.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.879]                 open = "w")
[17:02:31.879]         }
[17:02:31.879]         else {
[17:02:31.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.879]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.879]         }
[17:02:31.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.879]             base::sink(type = "output", split = FALSE)
[17:02:31.879]             base::close(...future.stdout)
[17:02:31.879]         }, add = TRUE)
[17:02:31.879]     }
[17:02:31.879]     ...future.frame <- base::sys.nframe()
[17:02:31.879]     ...future.conditions <- base::list()
[17:02:31.879]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.879]     if (FALSE) {
[17:02:31.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.879]     }
[17:02:31.879]     ...future.result <- base::tryCatch({
[17:02:31.879]         base::withCallingHandlers({
[17:02:31.879]             ...future.value <- base::withVisible(base::local({
[17:02:31.879]                 ...future.makeSendCondition <- base::local({
[17:02:31.879]                   sendCondition <- NULL
[17:02:31.879]                   function(frame = 1L) {
[17:02:31.879]                     if (is.function(sendCondition)) 
[17:02:31.879]                       return(sendCondition)
[17:02:31.879]                     ns <- getNamespace("parallel")
[17:02:31.879]                     if (exists("sendData", mode = "function", 
[17:02:31.879]                       envir = ns)) {
[17:02:31.879]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:31.879]                         envir = ns)
[17:02:31.879]                       envir <- sys.frame(frame)
[17:02:31.879]                       master <- NULL
[17:02:31.879]                       while (!identical(envir, .GlobalEnv) && 
[17:02:31.879]                         !identical(envir, emptyenv())) {
[17:02:31.879]                         if (exists("master", mode = "list", envir = envir, 
[17:02:31.879]                           inherits = FALSE)) {
[17:02:31.879]                           master <- get("master", mode = "list", 
[17:02:31.879]                             envir = envir, inherits = FALSE)
[17:02:31.879]                           if (inherits(master, c("SOCKnode", 
[17:02:31.879]                             "SOCK0node"))) {
[17:02:31.879]                             sendCondition <<- function(cond) {
[17:02:31.879]                               data <- list(type = "VALUE", value = cond, 
[17:02:31.879]                                 success = TRUE)
[17:02:31.879]                               parallel_sendData(master, data)
[17:02:31.879]                             }
[17:02:31.879]                             return(sendCondition)
[17:02:31.879]                           }
[17:02:31.879]                         }
[17:02:31.879]                         frame <- frame + 1L
[17:02:31.879]                         envir <- sys.frame(frame)
[17:02:31.879]                       }
[17:02:31.879]                     }
[17:02:31.879]                     sendCondition <<- function(cond) NULL
[17:02:31.879]                   }
[17:02:31.879]                 })
[17:02:31.879]                 withCallingHandlers({
[17:02:31.879]                   {
[17:02:31.879]                     4
[17:02:31.879]                   }
[17:02:31.879]                 }, immediateCondition = function(cond) {
[17:02:31.879]                   sendCondition <- ...future.makeSendCondition()
[17:02:31.879]                   sendCondition(cond)
[17:02:31.879]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.879]                   {
[17:02:31.879]                     inherits <- base::inherits
[17:02:31.879]                     invokeRestart <- base::invokeRestart
[17:02:31.879]                     is.null <- base::is.null
[17:02:31.879]                     muffled <- FALSE
[17:02:31.879]                     if (inherits(cond, "message")) {
[17:02:31.879]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.879]                       if (muffled) 
[17:02:31.879]                         invokeRestart("muffleMessage")
[17:02:31.879]                     }
[17:02:31.879]                     else if (inherits(cond, "warning")) {
[17:02:31.879]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.879]                       if (muffled) 
[17:02:31.879]                         invokeRestart("muffleWarning")
[17:02:31.879]                     }
[17:02:31.879]                     else if (inherits(cond, "condition")) {
[17:02:31.879]                       if (!is.null(pattern)) {
[17:02:31.879]                         computeRestarts <- base::computeRestarts
[17:02:31.879]                         grepl <- base::grepl
[17:02:31.879]                         restarts <- computeRestarts(cond)
[17:02:31.879]                         for (restart in restarts) {
[17:02:31.879]                           name <- restart$name
[17:02:31.879]                           if (is.null(name)) 
[17:02:31.879]                             next
[17:02:31.879]                           if (!grepl(pattern, name)) 
[17:02:31.879]                             next
[17:02:31.879]                           invokeRestart(restart)
[17:02:31.879]                           muffled <- TRUE
[17:02:31.879]                           break
[17:02:31.879]                         }
[17:02:31.879]                       }
[17:02:31.879]                     }
[17:02:31.879]                     invisible(muffled)
[17:02:31.879]                   }
[17:02:31.879]                   muffleCondition(cond)
[17:02:31.879]                 })
[17:02:31.879]             }))
[17:02:31.879]             future::FutureResult(value = ...future.value$value, 
[17:02:31.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.879]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.879]                     ...future.globalenv.names))
[17:02:31.879]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.879]         }, condition = base::local({
[17:02:31.879]             c <- base::c
[17:02:31.879]             inherits <- base::inherits
[17:02:31.879]             invokeRestart <- base::invokeRestart
[17:02:31.879]             length <- base::length
[17:02:31.879]             list <- base::list
[17:02:31.879]             seq.int <- base::seq.int
[17:02:31.879]             signalCondition <- base::signalCondition
[17:02:31.879]             sys.calls <- base::sys.calls
[17:02:31.879]             `[[` <- base::`[[`
[17:02:31.879]             `+` <- base::`+`
[17:02:31.879]             `<<-` <- base::`<<-`
[17:02:31.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.879]                   3L)]
[17:02:31.879]             }
[17:02:31.879]             function(cond) {
[17:02:31.879]                 is_error <- inherits(cond, "error")
[17:02:31.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.879]                   NULL)
[17:02:31.879]                 if (is_error) {
[17:02:31.879]                   sessionInformation <- function() {
[17:02:31.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.879]                       search = base::search(), system = base::Sys.info())
[17:02:31.879]                   }
[17:02:31.879]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.879]                     cond$call), session = sessionInformation(), 
[17:02:31.879]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.879]                   signalCondition(cond)
[17:02:31.879]                 }
[17:02:31.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.879]                 "immediateCondition"))) {
[17:02:31.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.879]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.879]                   if (TRUE && !signal) {
[17:02:31.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.879]                     {
[17:02:31.879]                       inherits <- base::inherits
[17:02:31.879]                       invokeRestart <- base::invokeRestart
[17:02:31.879]                       is.null <- base::is.null
[17:02:31.879]                       muffled <- FALSE
[17:02:31.879]                       if (inherits(cond, "message")) {
[17:02:31.879]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.879]                         if (muffled) 
[17:02:31.879]                           invokeRestart("muffleMessage")
[17:02:31.879]                       }
[17:02:31.879]                       else if (inherits(cond, "warning")) {
[17:02:31.879]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.879]                         if (muffled) 
[17:02:31.879]                           invokeRestart("muffleWarning")
[17:02:31.879]                       }
[17:02:31.879]                       else if (inherits(cond, "condition")) {
[17:02:31.879]                         if (!is.null(pattern)) {
[17:02:31.879]                           computeRestarts <- base::computeRestarts
[17:02:31.879]                           grepl <- base::grepl
[17:02:31.879]                           restarts <- computeRestarts(cond)
[17:02:31.879]                           for (restart in restarts) {
[17:02:31.879]                             name <- restart$name
[17:02:31.879]                             if (is.null(name)) 
[17:02:31.879]                               next
[17:02:31.879]                             if (!grepl(pattern, name)) 
[17:02:31.879]                               next
[17:02:31.879]                             invokeRestart(restart)
[17:02:31.879]                             muffled <- TRUE
[17:02:31.879]                             break
[17:02:31.879]                           }
[17:02:31.879]                         }
[17:02:31.879]                       }
[17:02:31.879]                       invisible(muffled)
[17:02:31.879]                     }
[17:02:31.879]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.879]                   }
[17:02:31.879]                 }
[17:02:31.879]                 else {
[17:02:31.879]                   if (TRUE) {
[17:02:31.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.879]                     {
[17:02:31.879]                       inherits <- base::inherits
[17:02:31.879]                       invokeRestart <- base::invokeRestart
[17:02:31.879]                       is.null <- base::is.null
[17:02:31.879]                       muffled <- FALSE
[17:02:31.879]                       if (inherits(cond, "message")) {
[17:02:31.879]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.879]                         if (muffled) 
[17:02:31.879]                           invokeRestart("muffleMessage")
[17:02:31.879]                       }
[17:02:31.879]                       else if (inherits(cond, "warning")) {
[17:02:31.879]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.879]                         if (muffled) 
[17:02:31.879]                           invokeRestart("muffleWarning")
[17:02:31.879]                       }
[17:02:31.879]                       else if (inherits(cond, "condition")) {
[17:02:31.879]                         if (!is.null(pattern)) {
[17:02:31.879]                           computeRestarts <- base::computeRestarts
[17:02:31.879]                           grepl <- base::grepl
[17:02:31.879]                           restarts <- computeRestarts(cond)
[17:02:31.879]                           for (restart in restarts) {
[17:02:31.879]                             name <- restart$name
[17:02:31.879]                             if (is.null(name)) 
[17:02:31.879]                               next
[17:02:31.879]                             if (!grepl(pattern, name)) 
[17:02:31.879]                               next
[17:02:31.879]                             invokeRestart(restart)
[17:02:31.879]                             muffled <- TRUE
[17:02:31.879]                             break
[17:02:31.879]                           }
[17:02:31.879]                         }
[17:02:31.879]                       }
[17:02:31.879]                       invisible(muffled)
[17:02:31.879]                     }
[17:02:31.879]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.879]                   }
[17:02:31.879]                 }
[17:02:31.879]             }
[17:02:31.879]         }))
[17:02:31.879]     }, error = function(ex) {
[17:02:31.879]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.879]                 ...future.rng), started = ...future.startTime, 
[17:02:31.879]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.879]             version = "1.8"), class = "FutureResult")
[17:02:31.879]     }, finally = {
[17:02:31.879]         if (!identical(...future.workdir, getwd())) 
[17:02:31.879]             setwd(...future.workdir)
[17:02:31.879]         {
[17:02:31.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.879]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.879]             }
[17:02:31.879]             base::options(...future.oldOptions)
[17:02:31.879]             if (.Platform$OS.type == "windows") {
[17:02:31.879]                 old_names <- names(...future.oldEnvVars)
[17:02:31.879]                 envs <- base::Sys.getenv()
[17:02:31.879]                 names <- names(envs)
[17:02:31.879]                 common <- intersect(names, old_names)
[17:02:31.879]                 added <- setdiff(names, old_names)
[17:02:31.879]                 removed <- setdiff(old_names, names)
[17:02:31.879]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.879]                   envs[common]]
[17:02:31.879]                 NAMES <- toupper(changed)
[17:02:31.879]                 args <- list()
[17:02:31.879]                 for (kk in seq_along(NAMES)) {
[17:02:31.879]                   name <- changed[[kk]]
[17:02:31.879]                   NAME <- NAMES[[kk]]
[17:02:31.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.879]                     next
[17:02:31.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.879]                 }
[17:02:31.879]                 NAMES <- toupper(added)
[17:02:31.879]                 for (kk in seq_along(NAMES)) {
[17:02:31.879]                   name <- added[[kk]]
[17:02:31.879]                   NAME <- NAMES[[kk]]
[17:02:31.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.879]                     next
[17:02:31.879]                   args[[name]] <- ""
[17:02:31.879]                 }
[17:02:31.879]                 NAMES <- toupper(removed)
[17:02:31.879]                 for (kk in seq_along(NAMES)) {
[17:02:31.879]                   name <- removed[[kk]]
[17:02:31.879]                   NAME <- NAMES[[kk]]
[17:02:31.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.879]                     next
[17:02:31.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.879]                 }
[17:02:31.879]                 if (length(args) > 0) 
[17:02:31.879]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.879]             }
[17:02:31.879]             else {
[17:02:31.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.879]             }
[17:02:31.879]             {
[17:02:31.879]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.879]                   0L) {
[17:02:31.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.879]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.879]                   base::options(opts)
[17:02:31.879]                 }
[17:02:31.879]                 {
[17:02:31.879]                   {
[17:02:31.879]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.879]                     NULL
[17:02:31.879]                   }
[17:02:31.879]                   options(future.plan = NULL)
[17:02:31.879]                   if (is.na(NA_character_)) 
[17:02:31.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.879]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.879]                     .init = FALSE)
[17:02:31.879]                 }
[17:02:31.879]             }
[17:02:31.879]         }
[17:02:31.879]     })
[17:02:31.879]     if (TRUE) {
[17:02:31.879]         base::sink(type = "output", split = FALSE)
[17:02:31.879]         if (TRUE) {
[17:02:31.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.879]         }
[17:02:31.879]         else {
[17:02:31.879]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.879]         }
[17:02:31.879]         base::close(...future.stdout)
[17:02:31.879]         ...future.stdout <- NULL
[17:02:31.879]     }
[17:02:31.879]     ...future.result$conditions <- ...future.conditions
[17:02:31.879]     ...future.result$finished <- base::Sys.time()
[17:02:31.879]     ...future.result
[17:02:31.879] }
[17:02:31.882] Poll #1 (0): usedNodes() = 2, workers = 2
[17:02:31.892] receiveMessageFromWorker() for ClusterFuture ...
[17:02:31.893] - Validating connection of MultisessionFuture
[17:02:31.893] - received message: FutureResult
[17:02:31.893] - Received FutureResult
[17:02:31.893] - Erased future from FutureRegistry
[17:02:31.893] result() for ClusterFuture ...
[17:02:31.893] - result already collected: FutureResult
[17:02:31.893] result() for ClusterFuture ... done
[17:02:31.893] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:31.894] result() for ClusterFuture ...
[17:02:31.894] - result already collected: FutureResult
[17:02:31.894] result() for ClusterFuture ... done
[17:02:31.894] result() for ClusterFuture ...
[17:02:31.894] - result already collected: FutureResult
[17:02:31.894] result() for ClusterFuture ... done
[17:02:31.895] MultisessionFuture started
[17:02:31.895] - Launch lazy future ... done
[17:02:31.895] run() for ‘MultisessionFuture’ ... done
<environment: 0x55c74a51d7c0> 
<environment: 0x55c74b3cc868> 
[17:02:31.897] receiveMessageFromWorker() for ClusterFuture ...
[17:02:31.897] - Validating connection of MultisessionFuture
[17:02:31.897] - received message: FutureResult
[17:02:31.897] - Received FutureResult
[17:02:31.898] - Erased future from FutureRegistry
[17:02:31.898] result() for ClusterFuture ...
[17:02:31.898] - result already collected: FutureResult
[17:02:31.898] result() for ClusterFuture ... done
[17:02:31.898] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:31.898] receiveMessageFromWorker() for ClusterFuture ...
[17:02:31.898] - Validating connection of MultisessionFuture
[17:02:31.899] - received message: FutureResult
[17:02:31.899] - Received FutureResult
[17:02:31.899] - Erased future from FutureRegistry
[17:02:31.899] result() for ClusterFuture ...
[17:02:31.899] - result already collected: FutureResult
[17:02:31.899] result() for ClusterFuture ... done
[17:02:31.899] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:31.900] resolve() on environment ...
[17:02:31.900]  recursive: 0
[17:02:31.901]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:31.901] signalConditionsASAP(numeric, pos=1) ...
[17:02:31.901] - nx: 4
[17:02:31.901] - relay: TRUE
[17:02:31.901] - stdout: TRUE
[17:02:31.901] - signal: TRUE
[17:02:31.901] - resignal: FALSE
[17:02:31.902] - force: TRUE
[17:02:31.902] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.902] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.902]  - until=2
[17:02:31.902]  - relaying element #2
[17:02:31.902] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:31.902] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.902] signalConditionsASAP(NULL, pos=1) ... done
[17:02:31.902]  length: 3 (resolved future 1)
[17:02:31.902] Future #2
[17:02:31.902] result() for ClusterFuture ...
[17:02:31.903] - result already collected: FutureResult
[17:02:31.903] result() for ClusterFuture ... done
[17:02:31.903] result() for ClusterFuture ...
[17:02:31.903] - result already collected: FutureResult
[17:02:31.903] result() for ClusterFuture ... done
[17:02:31.903] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:31.903] - nx: 4
[17:02:31.903] - relay: TRUE
[17:02:31.903] - stdout: TRUE
[17:02:31.903] - signal: TRUE
[17:02:31.903] - resignal: FALSE
[17:02:31.904] - force: TRUE
[17:02:31.904] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:31.904] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:31.904]  - until=2
[17:02:31.904]  - relaying element #2
[17:02:31.904] result() for ClusterFuture ...
[17:02:31.904] - result already collected: FutureResult
[17:02:31.904] result() for ClusterFuture ... done
[17:02:31.904] result() for ClusterFuture ...
[17:02:31.904] - result already collected: FutureResult
[17:02:31.904] result() for ClusterFuture ... done
[17:02:31.904] result() for ClusterFuture ...
[17:02:31.905] - result already collected: FutureResult
[17:02:31.905] result() for ClusterFuture ... done
[17:02:31.905] result() for ClusterFuture ...
[17:02:31.905] - result already collected: FutureResult
[17:02:31.905] result() for ClusterFuture ... done
[17:02:31.905] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:31.905] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:31.905] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:31.905]  length: 2 (resolved future 2)
[17:02:31.905] Future #3
[17:02:31.905] result() for ClusterFuture ...
[17:02:31.906] - result already collected: FutureResult
[17:02:31.906] result() for ClusterFuture ... done
[17:02:31.906] result() for ClusterFuture ...
[17:02:31.906] - result already collected: FutureResult
[17:02:31.906] result() for ClusterFuture ... done
[17:02:31.906] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:31.906] - nx: 4
[17:02:31.906] - relay: TRUE
[17:02:31.909] - stdout: TRUE
[17:02:31.909] - signal: TRUE
[17:02:31.909] - resignal: FALSE
[17:02:31.909] - force: TRUE
[17:02:31.909] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:31.909] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:31.910]  - until=3
[17:02:31.910]  - relaying element #3
[17:02:31.910] result() for ClusterFuture ...
[17:02:31.910] - result already collected: FutureResult
[17:02:31.910] result() for ClusterFuture ... done
[17:02:31.910] result() for ClusterFuture ...
[17:02:31.910] - result already collected: FutureResult
[17:02:31.910] result() for ClusterFuture ... done
[17:02:31.910] result() for ClusterFuture ...
[17:02:31.910] - result already collected: FutureResult
[17:02:31.910] result() for ClusterFuture ... done
[17:02:31.911] result() for ClusterFuture ...
[17:02:31.911] - result already collected: FutureResult
[17:02:31.911] result() for ClusterFuture ... done
[17:02:31.911] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:31.911] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:31.911] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:31.911]  length: 1 (resolved future 3)
[17:02:31.911] Future #4
[17:02:31.911] result() for ClusterFuture ...
[17:02:31.911] - result already collected: FutureResult
[17:02:31.911] result() for ClusterFuture ... done
[17:02:31.912] result() for ClusterFuture ...
[17:02:31.912] - result already collected: FutureResult
[17:02:31.912] result() for ClusterFuture ... done
[17:02:31.912] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:02:31.912] - nx: 4
[17:02:31.912] - relay: TRUE
[17:02:31.912] - stdout: TRUE
[17:02:31.912] - signal: TRUE
[17:02:31.912] - resignal: FALSE
[17:02:31.912] - force: TRUE
[17:02:31.912] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:31.912] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:31.913]  - until=4
[17:02:31.913]  - relaying element #4
[17:02:31.913] result() for ClusterFuture ...
[17:02:31.913] - result already collected: FutureResult
[17:02:31.913] result() for ClusterFuture ... done
[17:02:31.913] result() for ClusterFuture ...
[17:02:31.913] - result already collected: FutureResult
[17:02:31.913] result() for ClusterFuture ... done
[17:02:31.913] result() for ClusterFuture ...
[17:02:31.913] - result already collected: FutureResult
[17:02:31.913] result() for ClusterFuture ... done
[17:02:31.914] result() for ClusterFuture ...
[17:02:31.914] - result already collected: FutureResult
[17:02:31.914] result() for ClusterFuture ... done
[17:02:31.914] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.914] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:31.914] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:02:31.914]  length: 0 (resolved future 4)
[17:02:31.914] Relaying remaining futures
[17:02:31.914] signalConditionsASAP(NULL, pos=0) ...
[17:02:31.914] - nx: 4
[17:02:31.914] - relay: TRUE
[17:02:31.914] - stdout: TRUE
[17:02:31.915] - signal: TRUE
[17:02:31.915] - resignal: FALSE
[17:02:31.915] - force: TRUE
[17:02:31.915] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.915] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:31.915] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:31.915] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:31.915] signalConditionsASAP(NULL, pos=0) ... done
[17:02:31.915] resolve() on environment ... DONE
[17:02:31.915] result() for ClusterFuture ...
[17:02:31.915] - result already collected: FutureResult
[17:02:31.916] result() for ClusterFuture ... done
[17:02:31.916] result() for ClusterFuture ...
[17:02:31.916] - result already collected: FutureResult
[17:02:31.916] result() for ClusterFuture ... done
[17:02:31.916] result() for ClusterFuture ...
[17:02:31.916] - result already collected: FutureResult
[17:02:31.916] result() for ClusterFuture ... done
[17:02:31.916] result() for ClusterFuture ...
[17:02:31.916] - result already collected: FutureResult
[17:02:31.916] result() for ClusterFuture ... done
[17:02:31.916] result() for ClusterFuture ...
[17:02:31.916] - result already collected: FutureResult
[17:02:31.917] result() for ClusterFuture ... done
[17:02:31.917] result() for ClusterFuture ...
[17:02:31.917] - result already collected: FutureResult
[17:02:31.917] result() for ClusterFuture ... done
<environment: 0x55c74b5764a0> 
Dimensions: c(2, 3, 1)
[17:02:31.917] getGlobalsAndPackages() ...
[17:02:31.917] Searching for globals...
[17:02:31.918] 
[17:02:31.918] Searching for globals ... DONE
[17:02:31.918] - globals: [0] <none>
[17:02:31.918] getGlobalsAndPackages() ... DONE
[17:02:31.918] run() for ‘Future’ ...
[17:02:31.918] - state: ‘created’
[17:02:31.919] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.933] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:31.933]   - Field: ‘node’
[17:02:31.934]   - Field: ‘label’
[17:02:31.934]   - Field: ‘local’
[17:02:31.934]   - Field: ‘owner’
[17:02:31.934]   - Field: ‘envir’
[17:02:31.934]   - Field: ‘workers’
[17:02:31.934]   - Field: ‘packages’
[17:02:31.934]   - Field: ‘gc’
[17:02:31.934]   - Field: ‘conditions’
[17:02:31.934]   - Field: ‘persistent’
[17:02:31.934]   - Field: ‘expr’
[17:02:31.935]   - Field: ‘uuid’
[17:02:31.935]   - Field: ‘seed’
[17:02:31.935]   - Field: ‘version’
[17:02:31.935]   - Field: ‘result’
[17:02:31.935]   - Field: ‘asynchronous’
[17:02:31.935]   - Field: ‘calls’
[17:02:31.935]   - Field: ‘globals’
[17:02:31.935]   - Field: ‘stdout’
[17:02:31.935]   - Field: ‘earlySignal’
[17:02:31.935]   - Field: ‘lazy’
[17:02:31.935]   - Field: ‘state’
[17:02:31.936] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:31.936] - Launch lazy future ...
[17:02:31.936] Packages needed by the future expression (n = 0): <none>
[17:02:31.936] Packages needed by future strategies (n = 0): <none>
[17:02:31.936] {
[17:02:31.936]     {
[17:02:31.936]         {
[17:02:31.936]             ...future.startTime <- base::Sys.time()
[17:02:31.936]             {
[17:02:31.936]                 {
[17:02:31.936]                   {
[17:02:31.936]                     {
[17:02:31.936]                       base::local({
[17:02:31.936]                         has_future <- base::requireNamespace("future", 
[17:02:31.936]                           quietly = TRUE)
[17:02:31.936]                         if (has_future) {
[17:02:31.936]                           ns <- base::getNamespace("future")
[17:02:31.936]                           version <- ns[[".package"]][["version"]]
[17:02:31.936]                           if (is.null(version)) 
[17:02:31.936]                             version <- utils::packageVersion("future")
[17:02:31.936]                         }
[17:02:31.936]                         else {
[17:02:31.936]                           version <- NULL
[17:02:31.936]                         }
[17:02:31.936]                         if (!has_future || version < "1.8.0") {
[17:02:31.936]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.936]                             "", base::R.version$version.string), 
[17:02:31.936]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.936]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.936]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.936]                               "release", "version")], collapse = " "), 
[17:02:31.936]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.936]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.936]                             info)
[17:02:31.936]                           info <- base::paste(info, collapse = "; ")
[17:02:31.936]                           if (!has_future) {
[17:02:31.936]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.936]                               info)
[17:02:31.936]                           }
[17:02:31.936]                           else {
[17:02:31.936]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.936]                               info, version)
[17:02:31.936]                           }
[17:02:31.936]                           base::stop(msg)
[17:02:31.936]                         }
[17:02:31.936]                       })
[17:02:31.936]                     }
[17:02:31.936]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.936]                     base::options(mc.cores = 1L)
[17:02:31.936]                   }
[17:02:31.936]                   ...future.strategy.old <- future::plan("list")
[17:02:31.936]                   options(future.plan = NULL)
[17:02:31.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.936]                 }
[17:02:31.936]                 ...future.workdir <- getwd()
[17:02:31.936]             }
[17:02:31.936]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.936]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.936]         }
[17:02:31.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.936]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.936]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.936]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.936]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.936]             base::names(...future.oldOptions))
[17:02:31.936]     }
[17:02:31.936]     if (FALSE) {
[17:02:31.936]     }
[17:02:31.936]     else {
[17:02:31.936]         if (TRUE) {
[17:02:31.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.936]                 open = "w")
[17:02:31.936]         }
[17:02:31.936]         else {
[17:02:31.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.936]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.936]         }
[17:02:31.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.936]             base::sink(type = "output", split = FALSE)
[17:02:31.936]             base::close(...future.stdout)
[17:02:31.936]         }, add = TRUE)
[17:02:31.936]     }
[17:02:31.936]     ...future.frame <- base::sys.nframe()
[17:02:31.936]     ...future.conditions <- base::list()
[17:02:31.936]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.936]     if (FALSE) {
[17:02:31.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.936]     }
[17:02:31.936]     ...future.result <- base::tryCatch({
[17:02:31.936]         base::withCallingHandlers({
[17:02:31.936]             ...future.value <- base::withVisible(base::local({
[17:02:31.936]                 ...future.makeSendCondition <- base::local({
[17:02:31.936]                   sendCondition <- NULL
[17:02:31.936]                   function(frame = 1L) {
[17:02:31.936]                     if (is.function(sendCondition)) 
[17:02:31.936]                       return(sendCondition)
[17:02:31.936]                     ns <- getNamespace("parallel")
[17:02:31.936]                     if (exists("sendData", mode = "function", 
[17:02:31.936]                       envir = ns)) {
[17:02:31.936]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:31.936]                         envir = ns)
[17:02:31.936]                       envir <- sys.frame(frame)
[17:02:31.936]                       master <- NULL
[17:02:31.936]                       while (!identical(envir, .GlobalEnv) && 
[17:02:31.936]                         !identical(envir, emptyenv())) {
[17:02:31.936]                         if (exists("master", mode = "list", envir = envir, 
[17:02:31.936]                           inherits = FALSE)) {
[17:02:31.936]                           master <- get("master", mode = "list", 
[17:02:31.936]                             envir = envir, inherits = FALSE)
[17:02:31.936]                           if (inherits(master, c("SOCKnode", 
[17:02:31.936]                             "SOCK0node"))) {
[17:02:31.936]                             sendCondition <<- function(cond) {
[17:02:31.936]                               data <- list(type = "VALUE", value = cond, 
[17:02:31.936]                                 success = TRUE)
[17:02:31.936]                               parallel_sendData(master, data)
[17:02:31.936]                             }
[17:02:31.936]                             return(sendCondition)
[17:02:31.936]                           }
[17:02:31.936]                         }
[17:02:31.936]                         frame <- frame + 1L
[17:02:31.936]                         envir <- sys.frame(frame)
[17:02:31.936]                       }
[17:02:31.936]                     }
[17:02:31.936]                     sendCondition <<- function(cond) NULL
[17:02:31.936]                   }
[17:02:31.936]                 })
[17:02:31.936]                 withCallingHandlers({
[17:02:31.936]                   2
[17:02:31.936]                 }, immediateCondition = function(cond) {
[17:02:31.936]                   sendCondition <- ...future.makeSendCondition()
[17:02:31.936]                   sendCondition(cond)
[17:02:31.936]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.936]                   {
[17:02:31.936]                     inherits <- base::inherits
[17:02:31.936]                     invokeRestart <- base::invokeRestart
[17:02:31.936]                     is.null <- base::is.null
[17:02:31.936]                     muffled <- FALSE
[17:02:31.936]                     if (inherits(cond, "message")) {
[17:02:31.936]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.936]                       if (muffled) 
[17:02:31.936]                         invokeRestart("muffleMessage")
[17:02:31.936]                     }
[17:02:31.936]                     else if (inherits(cond, "warning")) {
[17:02:31.936]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.936]                       if (muffled) 
[17:02:31.936]                         invokeRestart("muffleWarning")
[17:02:31.936]                     }
[17:02:31.936]                     else if (inherits(cond, "condition")) {
[17:02:31.936]                       if (!is.null(pattern)) {
[17:02:31.936]                         computeRestarts <- base::computeRestarts
[17:02:31.936]                         grepl <- base::grepl
[17:02:31.936]                         restarts <- computeRestarts(cond)
[17:02:31.936]                         for (restart in restarts) {
[17:02:31.936]                           name <- restart$name
[17:02:31.936]                           if (is.null(name)) 
[17:02:31.936]                             next
[17:02:31.936]                           if (!grepl(pattern, name)) 
[17:02:31.936]                             next
[17:02:31.936]                           invokeRestart(restart)
[17:02:31.936]                           muffled <- TRUE
[17:02:31.936]                           break
[17:02:31.936]                         }
[17:02:31.936]                       }
[17:02:31.936]                     }
[17:02:31.936]                     invisible(muffled)
[17:02:31.936]                   }
[17:02:31.936]                   muffleCondition(cond)
[17:02:31.936]                 })
[17:02:31.936]             }))
[17:02:31.936]             future::FutureResult(value = ...future.value$value, 
[17:02:31.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.936]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.936]                     ...future.globalenv.names))
[17:02:31.936]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.936]         }, condition = base::local({
[17:02:31.936]             c <- base::c
[17:02:31.936]             inherits <- base::inherits
[17:02:31.936]             invokeRestart <- base::invokeRestart
[17:02:31.936]             length <- base::length
[17:02:31.936]             list <- base::list
[17:02:31.936]             seq.int <- base::seq.int
[17:02:31.936]             signalCondition <- base::signalCondition
[17:02:31.936]             sys.calls <- base::sys.calls
[17:02:31.936]             `[[` <- base::`[[`
[17:02:31.936]             `+` <- base::`+`
[17:02:31.936]             `<<-` <- base::`<<-`
[17:02:31.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.936]                   3L)]
[17:02:31.936]             }
[17:02:31.936]             function(cond) {
[17:02:31.936]                 is_error <- inherits(cond, "error")
[17:02:31.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.936]                   NULL)
[17:02:31.936]                 if (is_error) {
[17:02:31.936]                   sessionInformation <- function() {
[17:02:31.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.936]                       search = base::search(), system = base::Sys.info())
[17:02:31.936]                   }
[17:02:31.936]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.936]                     cond$call), session = sessionInformation(), 
[17:02:31.936]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.936]                   signalCondition(cond)
[17:02:31.936]                 }
[17:02:31.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.936]                 "immediateCondition"))) {
[17:02:31.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.936]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.936]                   if (TRUE && !signal) {
[17:02:31.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.936]                     {
[17:02:31.936]                       inherits <- base::inherits
[17:02:31.936]                       invokeRestart <- base::invokeRestart
[17:02:31.936]                       is.null <- base::is.null
[17:02:31.936]                       muffled <- FALSE
[17:02:31.936]                       if (inherits(cond, "message")) {
[17:02:31.936]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.936]                         if (muffled) 
[17:02:31.936]                           invokeRestart("muffleMessage")
[17:02:31.936]                       }
[17:02:31.936]                       else if (inherits(cond, "warning")) {
[17:02:31.936]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.936]                         if (muffled) 
[17:02:31.936]                           invokeRestart("muffleWarning")
[17:02:31.936]                       }
[17:02:31.936]                       else if (inherits(cond, "condition")) {
[17:02:31.936]                         if (!is.null(pattern)) {
[17:02:31.936]                           computeRestarts <- base::computeRestarts
[17:02:31.936]                           grepl <- base::grepl
[17:02:31.936]                           restarts <- computeRestarts(cond)
[17:02:31.936]                           for (restart in restarts) {
[17:02:31.936]                             name <- restart$name
[17:02:31.936]                             if (is.null(name)) 
[17:02:31.936]                               next
[17:02:31.936]                             if (!grepl(pattern, name)) 
[17:02:31.936]                               next
[17:02:31.936]                             invokeRestart(restart)
[17:02:31.936]                             muffled <- TRUE
[17:02:31.936]                             break
[17:02:31.936]                           }
[17:02:31.936]                         }
[17:02:31.936]                       }
[17:02:31.936]                       invisible(muffled)
[17:02:31.936]                     }
[17:02:31.936]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.936]                   }
[17:02:31.936]                 }
[17:02:31.936]                 else {
[17:02:31.936]                   if (TRUE) {
[17:02:31.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.936]                     {
[17:02:31.936]                       inherits <- base::inherits
[17:02:31.936]                       invokeRestart <- base::invokeRestart
[17:02:31.936]                       is.null <- base::is.null
[17:02:31.936]                       muffled <- FALSE
[17:02:31.936]                       if (inherits(cond, "message")) {
[17:02:31.936]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.936]                         if (muffled) 
[17:02:31.936]                           invokeRestart("muffleMessage")
[17:02:31.936]                       }
[17:02:31.936]                       else if (inherits(cond, "warning")) {
[17:02:31.936]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.936]                         if (muffled) 
[17:02:31.936]                           invokeRestart("muffleWarning")
[17:02:31.936]                       }
[17:02:31.936]                       else if (inherits(cond, "condition")) {
[17:02:31.936]                         if (!is.null(pattern)) {
[17:02:31.936]                           computeRestarts <- base::computeRestarts
[17:02:31.936]                           grepl <- base::grepl
[17:02:31.936]                           restarts <- computeRestarts(cond)
[17:02:31.936]                           for (restart in restarts) {
[17:02:31.936]                             name <- restart$name
[17:02:31.936]                             if (is.null(name)) 
[17:02:31.936]                               next
[17:02:31.936]                             if (!grepl(pattern, name)) 
[17:02:31.936]                               next
[17:02:31.936]                             invokeRestart(restart)
[17:02:31.936]                             muffled <- TRUE
[17:02:31.936]                             break
[17:02:31.936]                           }
[17:02:31.936]                         }
[17:02:31.936]                       }
[17:02:31.936]                       invisible(muffled)
[17:02:31.936]                     }
[17:02:31.936]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.936]                   }
[17:02:31.936]                 }
[17:02:31.936]             }
[17:02:31.936]         }))
[17:02:31.936]     }, error = function(ex) {
[17:02:31.936]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.936]                 ...future.rng), started = ...future.startTime, 
[17:02:31.936]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.936]             version = "1.8"), class = "FutureResult")
[17:02:31.936]     }, finally = {
[17:02:31.936]         if (!identical(...future.workdir, getwd())) 
[17:02:31.936]             setwd(...future.workdir)
[17:02:31.936]         {
[17:02:31.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.936]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.936]             }
[17:02:31.936]             base::options(...future.oldOptions)
[17:02:31.936]             if (.Platform$OS.type == "windows") {
[17:02:31.936]                 old_names <- names(...future.oldEnvVars)
[17:02:31.936]                 envs <- base::Sys.getenv()
[17:02:31.936]                 names <- names(envs)
[17:02:31.936]                 common <- intersect(names, old_names)
[17:02:31.936]                 added <- setdiff(names, old_names)
[17:02:31.936]                 removed <- setdiff(old_names, names)
[17:02:31.936]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.936]                   envs[common]]
[17:02:31.936]                 NAMES <- toupper(changed)
[17:02:31.936]                 args <- list()
[17:02:31.936]                 for (kk in seq_along(NAMES)) {
[17:02:31.936]                   name <- changed[[kk]]
[17:02:31.936]                   NAME <- NAMES[[kk]]
[17:02:31.936]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.936]                     next
[17:02:31.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.936]                 }
[17:02:31.936]                 NAMES <- toupper(added)
[17:02:31.936]                 for (kk in seq_along(NAMES)) {
[17:02:31.936]                   name <- added[[kk]]
[17:02:31.936]                   NAME <- NAMES[[kk]]
[17:02:31.936]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.936]                     next
[17:02:31.936]                   args[[name]] <- ""
[17:02:31.936]                 }
[17:02:31.936]                 NAMES <- toupper(removed)
[17:02:31.936]                 for (kk in seq_along(NAMES)) {
[17:02:31.936]                   name <- removed[[kk]]
[17:02:31.936]                   NAME <- NAMES[[kk]]
[17:02:31.936]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.936]                     next
[17:02:31.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.936]                 }
[17:02:31.936]                 if (length(args) > 0) 
[17:02:31.936]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.936]             }
[17:02:31.936]             else {
[17:02:31.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.936]             }
[17:02:31.936]             {
[17:02:31.936]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.936]                   0L) {
[17:02:31.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.936]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.936]                   base::options(opts)
[17:02:31.936]                 }
[17:02:31.936]                 {
[17:02:31.936]                   {
[17:02:31.936]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.936]                     NULL
[17:02:31.936]                   }
[17:02:31.936]                   options(future.plan = NULL)
[17:02:31.936]                   if (is.na(NA_character_)) 
[17:02:31.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.936]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.936]                     .init = FALSE)
[17:02:31.936]                 }
[17:02:31.936]             }
[17:02:31.936]         }
[17:02:31.936]     })
[17:02:31.936]     if (TRUE) {
[17:02:31.936]         base::sink(type = "output", split = FALSE)
[17:02:31.936]         if (TRUE) {
[17:02:31.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.936]         }
[17:02:31.936]         else {
[17:02:31.936]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.936]         }
[17:02:31.936]         base::close(...future.stdout)
[17:02:31.936]         ...future.stdout <- NULL
[17:02:31.936]     }
[17:02:31.936]     ...future.result$conditions <- ...future.conditions
[17:02:31.936]     ...future.result$finished <- base::Sys.time()
[17:02:31.936]     ...future.result
[17:02:31.936] }
[17:02:31.939] MultisessionFuture started
[17:02:31.940] - Launch lazy future ... done
[17:02:31.940] run() for ‘MultisessionFuture’ ... done
[17:02:31.940] getGlobalsAndPackages() ...
[17:02:31.940] Searching for globals...
[17:02:31.940] 
[17:02:31.940] Searching for globals ... DONE
[17:02:31.940] - globals: [0] <none>
[17:02:31.941] getGlobalsAndPackages() ... DONE
[17:02:31.941] run() for ‘Future’ ...
[17:02:31.941] - state: ‘created’
[17:02:31.941] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.955] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:31.955]   - Field: ‘node’
[17:02:31.955]   - Field: ‘label’
[17:02:31.955]   - Field: ‘local’
[17:02:31.955]   - Field: ‘owner’
[17:02:31.955]   - Field: ‘envir’
[17:02:31.955]   - Field: ‘workers’
[17:02:31.955]   - Field: ‘packages’
[17:02:31.956]   - Field: ‘gc’
[17:02:31.956]   - Field: ‘conditions’
[17:02:31.956]   - Field: ‘persistent’
[17:02:31.956]   - Field: ‘expr’
[17:02:31.956]   - Field: ‘uuid’
[17:02:31.956]   - Field: ‘seed’
[17:02:31.956]   - Field: ‘version’
[17:02:31.956]   - Field: ‘result’
[17:02:31.956]   - Field: ‘asynchronous’
[17:02:31.956]   - Field: ‘calls’
[17:02:31.956]   - Field: ‘globals’
[17:02:31.957]   - Field: ‘stdout’
[17:02:31.957]   - Field: ‘earlySignal’
[17:02:31.957]   - Field: ‘lazy’
[17:02:31.957]   - Field: ‘state’
[17:02:31.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:31.957] - Launch lazy future ...
[17:02:31.957] Packages needed by the future expression (n = 0): <none>
[17:02:31.957] Packages needed by future strategies (n = 0): <none>
[17:02:31.958] {
[17:02:31.958]     {
[17:02:31.958]         {
[17:02:31.958]             ...future.startTime <- base::Sys.time()
[17:02:31.958]             {
[17:02:31.958]                 {
[17:02:31.958]                   {
[17:02:31.958]                     {
[17:02:31.958]                       base::local({
[17:02:31.958]                         has_future <- base::requireNamespace("future", 
[17:02:31.958]                           quietly = TRUE)
[17:02:31.958]                         if (has_future) {
[17:02:31.958]                           ns <- base::getNamespace("future")
[17:02:31.958]                           version <- ns[[".package"]][["version"]]
[17:02:31.958]                           if (is.null(version)) 
[17:02:31.958]                             version <- utils::packageVersion("future")
[17:02:31.958]                         }
[17:02:31.958]                         else {
[17:02:31.958]                           version <- NULL
[17:02:31.958]                         }
[17:02:31.958]                         if (!has_future || version < "1.8.0") {
[17:02:31.958]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.958]                             "", base::R.version$version.string), 
[17:02:31.958]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.958]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.958]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.958]                               "release", "version")], collapse = " "), 
[17:02:31.958]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.958]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.958]                             info)
[17:02:31.958]                           info <- base::paste(info, collapse = "; ")
[17:02:31.958]                           if (!has_future) {
[17:02:31.958]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.958]                               info)
[17:02:31.958]                           }
[17:02:31.958]                           else {
[17:02:31.958]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.958]                               info, version)
[17:02:31.958]                           }
[17:02:31.958]                           base::stop(msg)
[17:02:31.958]                         }
[17:02:31.958]                       })
[17:02:31.958]                     }
[17:02:31.958]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.958]                     base::options(mc.cores = 1L)
[17:02:31.958]                   }
[17:02:31.958]                   ...future.strategy.old <- future::plan("list")
[17:02:31.958]                   options(future.plan = NULL)
[17:02:31.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.958]                 }
[17:02:31.958]                 ...future.workdir <- getwd()
[17:02:31.958]             }
[17:02:31.958]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.958]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.958]         }
[17:02:31.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.958]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.958]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.958]             base::names(...future.oldOptions))
[17:02:31.958]     }
[17:02:31.958]     if (FALSE) {
[17:02:31.958]     }
[17:02:31.958]     else {
[17:02:31.958]         if (TRUE) {
[17:02:31.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.958]                 open = "w")
[17:02:31.958]         }
[17:02:31.958]         else {
[17:02:31.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.958]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.958]         }
[17:02:31.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.958]             base::sink(type = "output", split = FALSE)
[17:02:31.958]             base::close(...future.stdout)
[17:02:31.958]         }, add = TRUE)
[17:02:31.958]     }
[17:02:31.958]     ...future.frame <- base::sys.nframe()
[17:02:31.958]     ...future.conditions <- base::list()
[17:02:31.958]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.958]     if (FALSE) {
[17:02:31.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.958]     }
[17:02:31.958]     ...future.result <- base::tryCatch({
[17:02:31.958]         base::withCallingHandlers({
[17:02:31.958]             ...future.value <- base::withVisible(base::local({
[17:02:31.958]                 ...future.makeSendCondition <- base::local({
[17:02:31.958]                   sendCondition <- NULL
[17:02:31.958]                   function(frame = 1L) {
[17:02:31.958]                     if (is.function(sendCondition)) 
[17:02:31.958]                       return(sendCondition)
[17:02:31.958]                     ns <- getNamespace("parallel")
[17:02:31.958]                     if (exists("sendData", mode = "function", 
[17:02:31.958]                       envir = ns)) {
[17:02:31.958]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:31.958]                         envir = ns)
[17:02:31.958]                       envir <- sys.frame(frame)
[17:02:31.958]                       master <- NULL
[17:02:31.958]                       while (!identical(envir, .GlobalEnv) && 
[17:02:31.958]                         !identical(envir, emptyenv())) {
[17:02:31.958]                         if (exists("master", mode = "list", envir = envir, 
[17:02:31.958]                           inherits = FALSE)) {
[17:02:31.958]                           master <- get("master", mode = "list", 
[17:02:31.958]                             envir = envir, inherits = FALSE)
[17:02:31.958]                           if (inherits(master, c("SOCKnode", 
[17:02:31.958]                             "SOCK0node"))) {
[17:02:31.958]                             sendCondition <<- function(cond) {
[17:02:31.958]                               data <- list(type = "VALUE", value = cond, 
[17:02:31.958]                                 success = TRUE)
[17:02:31.958]                               parallel_sendData(master, data)
[17:02:31.958]                             }
[17:02:31.958]                             return(sendCondition)
[17:02:31.958]                           }
[17:02:31.958]                         }
[17:02:31.958]                         frame <- frame + 1L
[17:02:31.958]                         envir <- sys.frame(frame)
[17:02:31.958]                       }
[17:02:31.958]                     }
[17:02:31.958]                     sendCondition <<- function(cond) NULL
[17:02:31.958]                   }
[17:02:31.958]                 })
[17:02:31.958]                 withCallingHandlers({
[17:02:31.958]                   NULL
[17:02:31.958]                 }, immediateCondition = function(cond) {
[17:02:31.958]                   sendCondition <- ...future.makeSendCondition()
[17:02:31.958]                   sendCondition(cond)
[17:02:31.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.958]                   {
[17:02:31.958]                     inherits <- base::inherits
[17:02:31.958]                     invokeRestart <- base::invokeRestart
[17:02:31.958]                     is.null <- base::is.null
[17:02:31.958]                     muffled <- FALSE
[17:02:31.958]                     if (inherits(cond, "message")) {
[17:02:31.958]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.958]                       if (muffled) 
[17:02:31.958]                         invokeRestart("muffleMessage")
[17:02:31.958]                     }
[17:02:31.958]                     else if (inherits(cond, "warning")) {
[17:02:31.958]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.958]                       if (muffled) 
[17:02:31.958]                         invokeRestart("muffleWarning")
[17:02:31.958]                     }
[17:02:31.958]                     else if (inherits(cond, "condition")) {
[17:02:31.958]                       if (!is.null(pattern)) {
[17:02:31.958]                         computeRestarts <- base::computeRestarts
[17:02:31.958]                         grepl <- base::grepl
[17:02:31.958]                         restarts <- computeRestarts(cond)
[17:02:31.958]                         for (restart in restarts) {
[17:02:31.958]                           name <- restart$name
[17:02:31.958]                           if (is.null(name)) 
[17:02:31.958]                             next
[17:02:31.958]                           if (!grepl(pattern, name)) 
[17:02:31.958]                             next
[17:02:31.958]                           invokeRestart(restart)
[17:02:31.958]                           muffled <- TRUE
[17:02:31.958]                           break
[17:02:31.958]                         }
[17:02:31.958]                       }
[17:02:31.958]                     }
[17:02:31.958]                     invisible(muffled)
[17:02:31.958]                   }
[17:02:31.958]                   muffleCondition(cond)
[17:02:31.958]                 })
[17:02:31.958]             }))
[17:02:31.958]             future::FutureResult(value = ...future.value$value, 
[17:02:31.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.958]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.958]                     ...future.globalenv.names))
[17:02:31.958]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.958]         }, condition = base::local({
[17:02:31.958]             c <- base::c
[17:02:31.958]             inherits <- base::inherits
[17:02:31.958]             invokeRestart <- base::invokeRestart
[17:02:31.958]             length <- base::length
[17:02:31.958]             list <- base::list
[17:02:31.958]             seq.int <- base::seq.int
[17:02:31.958]             signalCondition <- base::signalCondition
[17:02:31.958]             sys.calls <- base::sys.calls
[17:02:31.958]             `[[` <- base::`[[`
[17:02:31.958]             `+` <- base::`+`
[17:02:31.958]             `<<-` <- base::`<<-`
[17:02:31.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.958]                   3L)]
[17:02:31.958]             }
[17:02:31.958]             function(cond) {
[17:02:31.958]                 is_error <- inherits(cond, "error")
[17:02:31.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.958]                   NULL)
[17:02:31.958]                 if (is_error) {
[17:02:31.958]                   sessionInformation <- function() {
[17:02:31.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.958]                       search = base::search(), system = base::Sys.info())
[17:02:31.958]                   }
[17:02:31.958]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.958]                     cond$call), session = sessionInformation(), 
[17:02:31.958]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.958]                   signalCondition(cond)
[17:02:31.958]                 }
[17:02:31.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.958]                 "immediateCondition"))) {
[17:02:31.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.958]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.958]                   if (TRUE && !signal) {
[17:02:31.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.958]                     {
[17:02:31.958]                       inherits <- base::inherits
[17:02:31.958]                       invokeRestart <- base::invokeRestart
[17:02:31.958]                       is.null <- base::is.null
[17:02:31.958]                       muffled <- FALSE
[17:02:31.958]                       if (inherits(cond, "message")) {
[17:02:31.958]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.958]                         if (muffled) 
[17:02:31.958]                           invokeRestart("muffleMessage")
[17:02:31.958]                       }
[17:02:31.958]                       else if (inherits(cond, "warning")) {
[17:02:31.958]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.958]                         if (muffled) 
[17:02:31.958]                           invokeRestart("muffleWarning")
[17:02:31.958]                       }
[17:02:31.958]                       else if (inherits(cond, "condition")) {
[17:02:31.958]                         if (!is.null(pattern)) {
[17:02:31.958]                           computeRestarts <- base::computeRestarts
[17:02:31.958]                           grepl <- base::grepl
[17:02:31.958]                           restarts <- computeRestarts(cond)
[17:02:31.958]                           for (restart in restarts) {
[17:02:31.958]                             name <- restart$name
[17:02:31.958]                             if (is.null(name)) 
[17:02:31.958]                               next
[17:02:31.958]                             if (!grepl(pattern, name)) 
[17:02:31.958]                               next
[17:02:31.958]                             invokeRestart(restart)
[17:02:31.958]                             muffled <- TRUE
[17:02:31.958]                             break
[17:02:31.958]                           }
[17:02:31.958]                         }
[17:02:31.958]                       }
[17:02:31.958]                       invisible(muffled)
[17:02:31.958]                     }
[17:02:31.958]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.958]                   }
[17:02:31.958]                 }
[17:02:31.958]                 else {
[17:02:31.958]                   if (TRUE) {
[17:02:31.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.958]                     {
[17:02:31.958]                       inherits <- base::inherits
[17:02:31.958]                       invokeRestart <- base::invokeRestart
[17:02:31.958]                       is.null <- base::is.null
[17:02:31.958]                       muffled <- FALSE
[17:02:31.958]                       if (inherits(cond, "message")) {
[17:02:31.958]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.958]                         if (muffled) 
[17:02:31.958]                           invokeRestart("muffleMessage")
[17:02:31.958]                       }
[17:02:31.958]                       else if (inherits(cond, "warning")) {
[17:02:31.958]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.958]                         if (muffled) 
[17:02:31.958]                           invokeRestart("muffleWarning")
[17:02:31.958]                       }
[17:02:31.958]                       else if (inherits(cond, "condition")) {
[17:02:31.958]                         if (!is.null(pattern)) {
[17:02:31.958]                           computeRestarts <- base::computeRestarts
[17:02:31.958]                           grepl <- base::grepl
[17:02:31.958]                           restarts <- computeRestarts(cond)
[17:02:31.958]                           for (restart in restarts) {
[17:02:31.958]                             name <- restart$name
[17:02:31.958]                             if (is.null(name)) 
[17:02:31.958]                               next
[17:02:31.958]                             if (!grepl(pattern, name)) 
[17:02:31.958]                               next
[17:02:31.958]                             invokeRestart(restart)
[17:02:31.958]                             muffled <- TRUE
[17:02:31.958]                             break
[17:02:31.958]                           }
[17:02:31.958]                         }
[17:02:31.958]                       }
[17:02:31.958]                       invisible(muffled)
[17:02:31.958]                     }
[17:02:31.958]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.958]                   }
[17:02:31.958]                 }
[17:02:31.958]             }
[17:02:31.958]         }))
[17:02:31.958]     }, error = function(ex) {
[17:02:31.958]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.958]                 ...future.rng), started = ...future.startTime, 
[17:02:31.958]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.958]             version = "1.8"), class = "FutureResult")
[17:02:31.958]     }, finally = {
[17:02:31.958]         if (!identical(...future.workdir, getwd())) 
[17:02:31.958]             setwd(...future.workdir)
[17:02:31.958]         {
[17:02:31.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.958]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.958]             }
[17:02:31.958]             base::options(...future.oldOptions)
[17:02:31.958]             if (.Platform$OS.type == "windows") {
[17:02:31.958]                 old_names <- names(...future.oldEnvVars)
[17:02:31.958]                 envs <- base::Sys.getenv()
[17:02:31.958]                 names <- names(envs)
[17:02:31.958]                 common <- intersect(names, old_names)
[17:02:31.958]                 added <- setdiff(names, old_names)
[17:02:31.958]                 removed <- setdiff(old_names, names)
[17:02:31.958]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.958]                   envs[common]]
[17:02:31.958]                 NAMES <- toupper(changed)
[17:02:31.958]                 args <- list()
[17:02:31.958]                 for (kk in seq_along(NAMES)) {
[17:02:31.958]                   name <- changed[[kk]]
[17:02:31.958]                   NAME <- NAMES[[kk]]
[17:02:31.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.958]                     next
[17:02:31.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.958]                 }
[17:02:31.958]                 NAMES <- toupper(added)
[17:02:31.958]                 for (kk in seq_along(NAMES)) {
[17:02:31.958]                   name <- added[[kk]]
[17:02:31.958]                   NAME <- NAMES[[kk]]
[17:02:31.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.958]                     next
[17:02:31.958]                   args[[name]] <- ""
[17:02:31.958]                 }
[17:02:31.958]                 NAMES <- toupper(removed)
[17:02:31.958]                 for (kk in seq_along(NAMES)) {
[17:02:31.958]                   name <- removed[[kk]]
[17:02:31.958]                   NAME <- NAMES[[kk]]
[17:02:31.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.958]                     next
[17:02:31.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.958]                 }
[17:02:31.958]                 if (length(args) > 0) 
[17:02:31.958]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.958]             }
[17:02:31.958]             else {
[17:02:31.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.958]             }
[17:02:31.958]             {
[17:02:31.958]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.958]                   0L) {
[17:02:31.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.958]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.958]                   base::options(opts)
[17:02:31.958]                 }
[17:02:31.958]                 {
[17:02:31.958]                   {
[17:02:31.958]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.958]                     NULL
[17:02:31.958]                   }
[17:02:31.958]                   options(future.plan = NULL)
[17:02:31.958]                   if (is.na(NA_character_)) 
[17:02:31.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.958]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.958]                     .init = FALSE)
[17:02:31.958]                 }
[17:02:31.958]             }
[17:02:31.958]         }
[17:02:31.958]     })
[17:02:31.958]     if (TRUE) {
[17:02:31.958]         base::sink(type = "output", split = FALSE)
[17:02:31.958]         if (TRUE) {
[17:02:31.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.958]         }
[17:02:31.958]         else {
[17:02:31.958]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.958]         }
[17:02:31.958]         base::close(...future.stdout)
[17:02:31.958]         ...future.stdout <- NULL
[17:02:31.958]     }
[17:02:31.958]     ...future.result$conditions <- ...future.conditions
[17:02:31.958]     ...future.result$finished <- base::Sys.time()
[17:02:31.958]     ...future.result
[17:02:31.958] }
[17:02:31.961] MultisessionFuture started
[17:02:31.961] - Launch lazy future ... done
[17:02:31.961] run() for ‘MultisessionFuture’ ... done
[17:02:31.961] getGlobalsAndPackages() ...
[17:02:31.962] Searching for globals...
[17:02:31.962] - globals found: [1] ‘{’
[17:02:31.962] Searching for globals ... DONE
[17:02:31.962] Resolving globals: FALSE
[17:02:31.963] 
[17:02:31.963] 
[17:02:31.963] getGlobalsAndPackages() ... DONE
[17:02:31.963] run() for ‘Future’ ...
[17:02:31.963] - state: ‘created’
[17:02:31.963] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:31.977] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:31.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:31.977]   - Field: ‘node’
[17:02:31.977]   - Field: ‘label’
[17:02:31.977]   - Field: ‘local’
[17:02:31.977]   - Field: ‘owner’
[17:02:31.978]   - Field: ‘envir’
[17:02:31.978]   - Field: ‘workers’
[17:02:31.978]   - Field: ‘packages’
[17:02:31.978]   - Field: ‘gc’
[17:02:31.978]   - Field: ‘conditions’
[17:02:31.978]   - Field: ‘persistent’
[17:02:31.978]   - Field: ‘expr’
[17:02:31.978]   - Field: ‘uuid’
[17:02:31.978]   - Field: ‘seed’
[17:02:31.978]   - Field: ‘version’
[17:02:31.978]   - Field: ‘result’
[17:02:31.979]   - Field: ‘asynchronous’
[17:02:31.979]   - Field: ‘calls’
[17:02:31.979]   - Field: ‘globals’
[17:02:31.979]   - Field: ‘stdout’
[17:02:31.979]   - Field: ‘earlySignal’
[17:02:31.979]   - Field: ‘lazy’
[17:02:31.979]   - Field: ‘state’
[17:02:31.979] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:31.979] - Launch lazy future ...
[17:02:31.980] Packages needed by the future expression (n = 0): <none>
[17:02:31.980] Packages needed by future strategies (n = 0): <none>
[17:02:31.980] {
[17:02:31.980]     {
[17:02:31.980]         {
[17:02:31.980]             ...future.startTime <- base::Sys.time()
[17:02:31.980]             {
[17:02:31.980]                 {
[17:02:31.980]                   {
[17:02:31.980]                     {
[17:02:31.980]                       base::local({
[17:02:31.980]                         has_future <- base::requireNamespace("future", 
[17:02:31.980]                           quietly = TRUE)
[17:02:31.980]                         if (has_future) {
[17:02:31.980]                           ns <- base::getNamespace("future")
[17:02:31.980]                           version <- ns[[".package"]][["version"]]
[17:02:31.980]                           if (is.null(version)) 
[17:02:31.980]                             version <- utils::packageVersion("future")
[17:02:31.980]                         }
[17:02:31.980]                         else {
[17:02:31.980]                           version <- NULL
[17:02:31.980]                         }
[17:02:31.980]                         if (!has_future || version < "1.8.0") {
[17:02:31.980]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:31.980]                             "", base::R.version$version.string), 
[17:02:31.980]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:31.980]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:31.980]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:31.980]                               "release", "version")], collapse = " "), 
[17:02:31.980]                             hostname = base::Sys.info()[["nodename"]])
[17:02:31.980]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:31.980]                             info)
[17:02:31.980]                           info <- base::paste(info, collapse = "; ")
[17:02:31.980]                           if (!has_future) {
[17:02:31.980]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:31.980]                               info)
[17:02:31.980]                           }
[17:02:31.980]                           else {
[17:02:31.980]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:31.980]                               info, version)
[17:02:31.980]                           }
[17:02:31.980]                           base::stop(msg)
[17:02:31.980]                         }
[17:02:31.980]                       })
[17:02:31.980]                     }
[17:02:31.980]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:31.980]                     base::options(mc.cores = 1L)
[17:02:31.980]                   }
[17:02:31.980]                   ...future.strategy.old <- future::plan("list")
[17:02:31.980]                   options(future.plan = NULL)
[17:02:31.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:31.980]                 }
[17:02:31.980]                 ...future.workdir <- getwd()
[17:02:31.980]             }
[17:02:31.980]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:31.980]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:31.980]         }
[17:02:31.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:31.980]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:31.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:31.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:31.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:31.980]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:31.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:31.980]             base::names(...future.oldOptions))
[17:02:31.980]     }
[17:02:31.980]     if (FALSE) {
[17:02:31.980]     }
[17:02:31.980]     else {
[17:02:31.980]         if (TRUE) {
[17:02:31.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:31.980]                 open = "w")
[17:02:31.980]         }
[17:02:31.980]         else {
[17:02:31.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:31.980]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:31.980]         }
[17:02:31.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:31.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:31.980]             base::sink(type = "output", split = FALSE)
[17:02:31.980]             base::close(...future.stdout)
[17:02:31.980]         }, add = TRUE)
[17:02:31.980]     }
[17:02:31.980]     ...future.frame <- base::sys.nframe()
[17:02:31.980]     ...future.conditions <- base::list()
[17:02:31.980]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:31.980]     if (FALSE) {
[17:02:31.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:31.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:31.980]     }
[17:02:31.980]     ...future.result <- base::tryCatch({
[17:02:31.980]         base::withCallingHandlers({
[17:02:31.980]             ...future.value <- base::withVisible(base::local({
[17:02:31.980]                 ...future.makeSendCondition <- base::local({
[17:02:31.980]                   sendCondition <- NULL
[17:02:31.980]                   function(frame = 1L) {
[17:02:31.980]                     if (is.function(sendCondition)) 
[17:02:31.980]                       return(sendCondition)
[17:02:31.980]                     ns <- getNamespace("parallel")
[17:02:31.980]                     if (exists("sendData", mode = "function", 
[17:02:31.980]                       envir = ns)) {
[17:02:31.980]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:31.980]                         envir = ns)
[17:02:31.980]                       envir <- sys.frame(frame)
[17:02:31.980]                       master <- NULL
[17:02:31.980]                       while (!identical(envir, .GlobalEnv) && 
[17:02:31.980]                         !identical(envir, emptyenv())) {
[17:02:31.980]                         if (exists("master", mode = "list", envir = envir, 
[17:02:31.980]                           inherits = FALSE)) {
[17:02:31.980]                           master <- get("master", mode = "list", 
[17:02:31.980]                             envir = envir, inherits = FALSE)
[17:02:31.980]                           if (inherits(master, c("SOCKnode", 
[17:02:31.980]                             "SOCK0node"))) {
[17:02:31.980]                             sendCondition <<- function(cond) {
[17:02:31.980]                               data <- list(type = "VALUE", value = cond, 
[17:02:31.980]                                 success = TRUE)
[17:02:31.980]                               parallel_sendData(master, data)
[17:02:31.980]                             }
[17:02:31.980]                             return(sendCondition)
[17:02:31.980]                           }
[17:02:31.980]                         }
[17:02:31.980]                         frame <- frame + 1L
[17:02:31.980]                         envir <- sys.frame(frame)
[17:02:31.980]                       }
[17:02:31.980]                     }
[17:02:31.980]                     sendCondition <<- function(cond) NULL
[17:02:31.980]                   }
[17:02:31.980]                 })
[17:02:31.980]                 withCallingHandlers({
[17:02:31.980]                   {
[17:02:31.980]                     4
[17:02:31.980]                   }
[17:02:31.980]                 }, immediateCondition = function(cond) {
[17:02:31.980]                   sendCondition <- ...future.makeSendCondition()
[17:02:31.980]                   sendCondition(cond)
[17:02:31.980]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.980]                   {
[17:02:31.980]                     inherits <- base::inherits
[17:02:31.980]                     invokeRestart <- base::invokeRestart
[17:02:31.980]                     is.null <- base::is.null
[17:02:31.980]                     muffled <- FALSE
[17:02:31.980]                     if (inherits(cond, "message")) {
[17:02:31.980]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:31.980]                       if (muffled) 
[17:02:31.980]                         invokeRestart("muffleMessage")
[17:02:31.980]                     }
[17:02:31.980]                     else if (inherits(cond, "warning")) {
[17:02:31.980]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:31.980]                       if (muffled) 
[17:02:31.980]                         invokeRestart("muffleWarning")
[17:02:31.980]                     }
[17:02:31.980]                     else if (inherits(cond, "condition")) {
[17:02:31.980]                       if (!is.null(pattern)) {
[17:02:31.980]                         computeRestarts <- base::computeRestarts
[17:02:31.980]                         grepl <- base::grepl
[17:02:31.980]                         restarts <- computeRestarts(cond)
[17:02:31.980]                         for (restart in restarts) {
[17:02:31.980]                           name <- restart$name
[17:02:31.980]                           if (is.null(name)) 
[17:02:31.980]                             next
[17:02:31.980]                           if (!grepl(pattern, name)) 
[17:02:31.980]                             next
[17:02:31.980]                           invokeRestart(restart)
[17:02:31.980]                           muffled <- TRUE
[17:02:31.980]                           break
[17:02:31.980]                         }
[17:02:31.980]                       }
[17:02:31.980]                     }
[17:02:31.980]                     invisible(muffled)
[17:02:31.980]                   }
[17:02:31.980]                   muffleCondition(cond)
[17:02:31.980]                 })
[17:02:31.980]             }))
[17:02:31.980]             future::FutureResult(value = ...future.value$value, 
[17:02:31.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.980]                   ...future.rng), globalenv = if (FALSE) 
[17:02:31.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:31.980]                     ...future.globalenv.names))
[17:02:31.980]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:31.980]         }, condition = base::local({
[17:02:31.980]             c <- base::c
[17:02:31.980]             inherits <- base::inherits
[17:02:31.980]             invokeRestart <- base::invokeRestart
[17:02:31.980]             length <- base::length
[17:02:31.980]             list <- base::list
[17:02:31.980]             seq.int <- base::seq.int
[17:02:31.980]             signalCondition <- base::signalCondition
[17:02:31.980]             sys.calls <- base::sys.calls
[17:02:31.980]             `[[` <- base::`[[`
[17:02:31.980]             `+` <- base::`+`
[17:02:31.980]             `<<-` <- base::`<<-`
[17:02:31.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:31.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:31.980]                   3L)]
[17:02:31.980]             }
[17:02:31.980]             function(cond) {
[17:02:31.980]                 is_error <- inherits(cond, "error")
[17:02:31.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:31.980]                   NULL)
[17:02:31.980]                 if (is_error) {
[17:02:31.980]                   sessionInformation <- function() {
[17:02:31.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:31.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:31.980]                       search = base::search(), system = base::Sys.info())
[17:02:31.980]                   }
[17:02:31.980]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:31.980]                     cond$call), session = sessionInformation(), 
[17:02:31.980]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:31.980]                   signalCondition(cond)
[17:02:31.980]                 }
[17:02:31.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:31.980]                 "immediateCondition"))) {
[17:02:31.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:31.980]                   ...future.conditions[[length(...future.conditions) + 
[17:02:31.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:31.980]                   if (TRUE && !signal) {
[17:02:31.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.980]                     {
[17:02:31.980]                       inherits <- base::inherits
[17:02:31.980]                       invokeRestart <- base::invokeRestart
[17:02:31.980]                       is.null <- base::is.null
[17:02:31.980]                       muffled <- FALSE
[17:02:31.980]                       if (inherits(cond, "message")) {
[17:02:31.980]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.980]                         if (muffled) 
[17:02:31.980]                           invokeRestart("muffleMessage")
[17:02:31.980]                       }
[17:02:31.980]                       else if (inherits(cond, "warning")) {
[17:02:31.980]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.980]                         if (muffled) 
[17:02:31.980]                           invokeRestart("muffleWarning")
[17:02:31.980]                       }
[17:02:31.980]                       else if (inherits(cond, "condition")) {
[17:02:31.980]                         if (!is.null(pattern)) {
[17:02:31.980]                           computeRestarts <- base::computeRestarts
[17:02:31.980]                           grepl <- base::grepl
[17:02:31.980]                           restarts <- computeRestarts(cond)
[17:02:31.980]                           for (restart in restarts) {
[17:02:31.980]                             name <- restart$name
[17:02:31.980]                             if (is.null(name)) 
[17:02:31.980]                               next
[17:02:31.980]                             if (!grepl(pattern, name)) 
[17:02:31.980]                               next
[17:02:31.980]                             invokeRestart(restart)
[17:02:31.980]                             muffled <- TRUE
[17:02:31.980]                             break
[17:02:31.980]                           }
[17:02:31.980]                         }
[17:02:31.980]                       }
[17:02:31.980]                       invisible(muffled)
[17:02:31.980]                     }
[17:02:31.980]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.980]                   }
[17:02:31.980]                 }
[17:02:31.980]                 else {
[17:02:31.980]                   if (TRUE) {
[17:02:31.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:31.980]                     {
[17:02:31.980]                       inherits <- base::inherits
[17:02:31.980]                       invokeRestart <- base::invokeRestart
[17:02:31.980]                       is.null <- base::is.null
[17:02:31.980]                       muffled <- FALSE
[17:02:31.980]                       if (inherits(cond, "message")) {
[17:02:31.980]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:31.980]                         if (muffled) 
[17:02:31.980]                           invokeRestart("muffleMessage")
[17:02:31.980]                       }
[17:02:31.980]                       else if (inherits(cond, "warning")) {
[17:02:31.980]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:31.980]                         if (muffled) 
[17:02:31.980]                           invokeRestart("muffleWarning")
[17:02:31.980]                       }
[17:02:31.980]                       else if (inherits(cond, "condition")) {
[17:02:31.980]                         if (!is.null(pattern)) {
[17:02:31.980]                           computeRestarts <- base::computeRestarts
[17:02:31.980]                           grepl <- base::grepl
[17:02:31.980]                           restarts <- computeRestarts(cond)
[17:02:31.980]                           for (restart in restarts) {
[17:02:31.980]                             name <- restart$name
[17:02:31.980]                             if (is.null(name)) 
[17:02:31.980]                               next
[17:02:31.980]                             if (!grepl(pattern, name)) 
[17:02:31.980]                               next
[17:02:31.980]                             invokeRestart(restart)
[17:02:31.980]                             muffled <- TRUE
[17:02:31.980]                             break
[17:02:31.980]                           }
[17:02:31.980]                         }
[17:02:31.980]                       }
[17:02:31.980]                       invisible(muffled)
[17:02:31.980]                     }
[17:02:31.980]                     muffleCondition(cond, pattern = "^muffle")
[17:02:31.980]                   }
[17:02:31.980]                 }
[17:02:31.980]             }
[17:02:31.980]         }))
[17:02:31.980]     }, error = function(ex) {
[17:02:31.980]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:31.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:31.980]                 ...future.rng), started = ...future.startTime, 
[17:02:31.980]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:31.980]             version = "1.8"), class = "FutureResult")
[17:02:31.980]     }, finally = {
[17:02:31.980]         if (!identical(...future.workdir, getwd())) 
[17:02:31.980]             setwd(...future.workdir)
[17:02:31.980]         {
[17:02:31.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:31.980]                 ...future.oldOptions$nwarnings <- NULL
[17:02:31.980]             }
[17:02:31.980]             base::options(...future.oldOptions)
[17:02:31.980]             if (.Platform$OS.type == "windows") {
[17:02:31.980]                 old_names <- names(...future.oldEnvVars)
[17:02:31.980]                 envs <- base::Sys.getenv()
[17:02:31.980]                 names <- names(envs)
[17:02:31.980]                 common <- intersect(names, old_names)
[17:02:31.980]                 added <- setdiff(names, old_names)
[17:02:31.980]                 removed <- setdiff(old_names, names)
[17:02:31.980]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:31.980]                   envs[common]]
[17:02:31.980]                 NAMES <- toupper(changed)
[17:02:31.980]                 args <- list()
[17:02:31.980]                 for (kk in seq_along(NAMES)) {
[17:02:31.980]                   name <- changed[[kk]]
[17:02:31.980]                   NAME <- NAMES[[kk]]
[17:02:31.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.980]                     next
[17:02:31.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.980]                 }
[17:02:31.980]                 NAMES <- toupper(added)
[17:02:31.980]                 for (kk in seq_along(NAMES)) {
[17:02:31.980]                   name <- added[[kk]]
[17:02:31.980]                   NAME <- NAMES[[kk]]
[17:02:31.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.980]                     next
[17:02:31.980]                   args[[name]] <- ""
[17:02:31.980]                 }
[17:02:31.980]                 NAMES <- toupper(removed)
[17:02:31.980]                 for (kk in seq_along(NAMES)) {
[17:02:31.980]                   name <- removed[[kk]]
[17:02:31.980]                   NAME <- NAMES[[kk]]
[17:02:31.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:31.980]                     next
[17:02:31.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:31.980]                 }
[17:02:31.980]                 if (length(args) > 0) 
[17:02:31.980]                   base::do.call(base::Sys.setenv, args = args)
[17:02:31.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:31.980]             }
[17:02:31.980]             else {
[17:02:31.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:31.980]             }
[17:02:31.980]             {
[17:02:31.980]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:31.980]                   0L) {
[17:02:31.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:31.980]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:31.980]                   base::options(opts)
[17:02:31.980]                 }
[17:02:31.980]                 {
[17:02:31.980]                   {
[17:02:31.980]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:31.980]                     NULL
[17:02:31.980]                   }
[17:02:31.980]                   options(future.plan = NULL)
[17:02:31.980]                   if (is.na(NA_character_)) 
[17:02:31.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:31.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:31.980]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:31.980]                     .init = FALSE)
[17:02:31.980]                 }
[17:02:31.980]             }
[17:02:31.980]         }
[17:02:31.980]     })
[17:02:31.980]     if (TRUE) {
[17:02:31.980]         base::sink(type = "output", split = FALSE)
[17:02:31.980]         if (TRUE) {
[17:02:31.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:31.980]         }
[17:02:31.980]         else {
[17:02:31.980]             ...future.result["stdout"] <- base::list(NULL)
[17:02:31.980]         }
[17:02:31.980]         base::close(...future.stdout)
[17:02:31.980]         ...future.stdout <- NULL
[17:02:31.980]     }
[17:02:31.980]     ...future.result$conditions <- ...future.conditions
[17:02:31.980]     ...future.result$finished <- base::Sys.time()
[17:02:31.980]     ...future.result
[17:02:31.980] }
[17:02:31.982] Poll #1 (0): usedNodes() = 2, workers = 2
[17:02:31.993] receiveMessageFromWorker() for ClusterFuture ...
[17:02:31.993] - Validating connection of MultisessionFuture
[17:02:31.993] - received message: FutureResult
[17:02:31.993] - Received FutureResult
[17:02:31.994] - Erased future from FutureRegistry
[17:02:31.994] result() for ClusterFuture ...
[17:02:31.994] - result already collected: FutureResult
[17:02:31.994] result() for ClusterFuture ... done
[17:02:31.994] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:31.994] result() for ClusterFuture ...
[17:02:31.994] - result already collected: FutureResult
[17:02:31.994] result() for ClusterFuture ... done
[17:02:31.994] result() for ClusterFuture ...
[17:02:31.994] - result already collected: FutureResult
[17:02:31.994] result() for ClusterFuture ... done
[17:02:31.996] MultisessionFuture started
[17:02:31.996] - Launch lazy future ... done
[17:02:31.996] run() for ‘MultisessionFuture’ ... done
<environment: 0x55c74975ec90> 
<environment: 0x55c74a88aae0> 
[17:02:31.997] receiveMessageFromWorker() for ClusterFuture ...
[17:02:31.998] - Validating connection of MultisessionFuture
[17:02:31.998] - received message: FutureResult
[17:02:31.998] - Received FutureResult
[17:02:31.998] - Erased future from FutureRegistry
[17:02:31.998] result() for ClusterFuture ...
[17:02:31.998] - result already collected: FutureResult
[17:02:31.998] result() for ClusterFuture ... done
[17:02:31.998] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:31.999] receiveMessageFromWorker() for ClusterFuture ...
[17:02:31.999] - Validating connection of MultisessionFuture
[17:02:31.999] - received message: FutureResult
[17:02:31.999] - Received FutureResult
[17:02:31.999] - Erased future from FutureRegistry
[17:02:31.999] result() for ClusterFuture ...
[17:02:32.000] - result already collected: FutureResult
[17:02:32.000] result() for ClusterFuture ... done
[17:02:32.000] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:32.001] resolve() on environment ...
[17:02:32.001]  recursive: 0
[17:02:32.001]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:32.002] signalConditionsASAP(numeric, pos=1) ...
[17:02:32.002] - nx: 4
[17:02:32.002] - relay: TRUE
[17:02:32.002] - stdout: TRUE
[17:02:32.002] - signal: TRUE
[17:02:32.002] - resignal: FALSE
[17:02:32.002] - force: TRUE
[17:02:32.002] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:32.002] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:32.002]  - until=2
[17:02:32.002]  - relaying element #2
[17:02:32.002] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:32.003] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:32.003] signalConditionsASAP(NULL, pos=1) ... done
[17:02:32.003]  length: 3 (resolved future 1)
[17:02:32.003] Future #2
[17:02:32.003] result() for ClusterFuture ...
[17:02:32.003] - result already collected: FutureResult
[17:02:32.003] result() for ClusterFuture ... done
[17:02:32.003] result() for ClusterFuture ...
[17:02:32.003] - result already collected: FutureResult
[17:02:32.003] result() for ClusterFuture ... done
[17:02:32.004] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:32.004] - nx: 4
[17:02:32.004] - relay: TRUE
[17:02:32.004] - stdout: TRUE
[17:02:32.004] - signal: TRUE
[17:02:32.004] - resignal: FALSE
[17:02:32.004] - force: TRUE
[17:02:32.004] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:32.004] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:32.004]  - until=2
[17:02:32.004]  - relaying element #2
[17:02:32.005] result() for ClusterFuture ...
[17:02:32.005] - result already collected: FutureResult
[17:02:32.005] result() for ClusterFuture ... done
[17:02:32.005] result() for ClusterFuture ...
[17:02:32.005] - result already collected: FutureResult
[17:02:32.005] result() for ClusterFuture ... done
[17:02:32.005] result() for ClusterFuture ...
[17:02:32.005] - result already collected: FutureResult
[17:02:32.005] result() for ClusterFuture ... done
[17:02:32.005] result() for ClusterFuture ...
[17:02:32.005] - result already collected: FutureResult
[17:02:32.005] result() for ClusterFuture ... done
[17:02:32.006] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:32.006] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:32.006] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:32.006]  length: 2 (resolved future 2)
[17:02:32.006] Future #3
[17:02:32.006] result() for ClusterFuture ...
[17:02:32.006] - result already collected: FutureResult
[17:02:32.006] result() for ClusterFuture ... done
[17:02:32.006] result() for ClusterFuture ...
[17:02:32.006] - result already collected: FutureResult
[17:02:32.006] result() for ClusterFuture ... done
[17:02:32.007] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:32.007] - nx: 4
[17:02:32.007] - relay: TRUE
[17:02:32.007] - stdout: TRUE
[17:02:32.007] - signal: TRUE
[17:02:32.007] - resignal: FALSE
[17:02:32.007] - force: TRUE
[17:02:32.007] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:32.007] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:32.007]  - until=3
[17:02:32.007]  - relaying element #3
[17:02:32.008] result() for ClusterFuture ...
[17:02:32.008] - result already collected: FutureResult
[17:02:32.008] result() for ClusterFuture ... done
[17:02:32.008] result() for ClusterFuture ...
[17:02:32.008] - result already collected: FutureResult
[17:02:32.008] result() for ClusterFuture ... done
[17:02:32.008] result() for ClusterFuture ...
[17:02:32.008] - result already collected: FutureResult
[17:02:32.008] result() for ClusterFuture ... done
[17:02:32.008] result() for ClusterFuture ...
[17:02:32.008] - result already collected: FutureResult
[17:02:32.008] result() for ClusterFuture ... done
[17:02:32.009] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:32.009] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:32.009] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:32.009]  length: 1 (resolved future 3)
[17:02:32.009] Future #4
[17:02:32.009] result() for ClusterFuture ...
[17:02:32.009] - result already collected: FutureResult
[17:02:32.009] result() for ClusterFuture ... done
[17:02:32.009] result() for ClusterFuture ...
[17:02:32.009] - result already collected: FutureResult
[17:02:32.009] result() for ClusterFuture ... done
[17:02:32.010] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:02:32.010] - nx: 4
[17:02:32.010] - relay: TRUE
[17:02:32.010] - stdout: TRUE
[17:02:32.010] - signal: TRUE
[17:02:32.010] - resignal: FALSE
[17:02:32.010] - force: TRUE
[17:02:32.010] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:32.010] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:32.010]  - until=4
[17:02:32.010]  - relaying element #4
[17:02:32.010] result() for ClusterFuture ...
[17:02:32.011] - result already collected: FutureResult
[17:02:32.011] result() for ClusterFuture ... done
[17:02:32.011] result() for ClusterFuture ...
[17:02:32.011] - result already collected: FutureResult
[17:02:32.011] result() for ClusterFuture ... done
[17:02:32.011] result() for ClusterFuture ...
[17:02:32.011] - result already collected: FutureResult
[17:02:32.011] result() for ClusterFuture ... done
[17:02:32.011] result() for ClusterFuture ...
[17:02:32.011] - result already collected: FutureResult
[17:02:32.011] result() for ClusterFuture ... done
[17:02:32.012] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:32.012] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:32.012] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:02:32.012]  length: 0 (resolved future 4)
[17:02:32.012] Relaying remaining futures
[17:02:32.012] signalConditionsASAP(NULL, pos=0) ...
[17:02:32.012] - nx: 4
[17:02:32.012] - relay: TRUE
[17:02:32.012] - stdout: TRUE
[17:02:32.012] - signal: TRUE
[17:02:32.012] - resignal: FALSE
[17:02:32.012] - force: TRUE
[17:02:32.013] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:32.013] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:32.013] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:32.013] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:32.013] signalConditionsASAP(NULL, pos=0) ... done
[17:02:32.013] resolve() on environment ... DONE
[17:02:32.013] result() for ClusterFuture ...
[17:02:32.013] - result already collected: FutureResult
[17:02:32.013] result() for ClusterFuture ... done
[17:02:32.013] result() for ClusterFuture ...
[17:02:32.013] - result already collected: FutureResult
[17:02:32.014] result() for ClusterFuture ... done
[17:02:32.014] result() for ClusterFuture ...
[17:02:32.014] - result already collected: FutureResult
[17:02:32.014] result() for ClusterFuture ... done
[17:02:32.014] result() for ClusterFuture ...
[17:02:32.014] - result already collected: FutureResult
[17:02:32.014] result() for ClusterFuture ... done
[17:02:32.014] result() for ClusterFuture ...
[17:02:32.014] - result already collected: FutureResult
[17:02:32.014] result() for ClusterFuture ... done
[17:02:32.014] result() for ClusterFuture ...
[17:02:32.015] - result already collected: FutureResult
[17:02:32.015] result() for ClusterFuture ... done
<environment: 0x55c74aab0648> 
Dimensions: c(2, 1, 3, 1)
[17:02:32.015] getGlobalsAndPackages() ...
[17:02:32.015] Searching for globals...
[17:02:32.015] 
[17:02:32.016] Searching for globals ... DONE
[17:02:32.016] - globals: [0] <none>
[17:02:32.016] getGlobalsAndPackages() ... DONE
[17:02:32.016] run() for ‘Future’ ...
[17:02:32.016] - state: ‘created’
[17:02:32.016] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.030] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.031] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:32.031]   - Field: ‘node’
[17:02:32.031]   - Field: ‘label’
[17:02:32.031]   - Field: ‘local’
[17:02:32.031]   - Field: ‘owner’
[17:02:32.031]   - Field: ‘envir’
[17:02:32.031]   - Field: ‘workers’
[17:02:32.031]   - Field: ‘packages’
[17:02:32.032]   - Field: ‘gc’
[17:02:32.032]   - Field: ‘conditions’
[17:02:32.032]   - Field: ‘persistent’
[17:02:32.032]   - Field: ‘expr’
[17:02:32.032]   - Field: ‘uuid’
[17:02:32.032]   - Field: ‘seed’
[17:02:32.032]   - Field: ‘version’
[17:02:32.032]   - Field: ‘result’
[17:02:32.032]   - Field: ‘asynchronous’
[17:02:32.032]   - Field: ‘calls’
[17:02:32.032]   - Field: ‘globals’
[17:02:32.033]   - Field: ‘stdout’
[17:02:32.033]   - Field: ‘earlySignal’
[17:02:32.033]   - Field: ‘lazy’
[17:02:32.033]   - Field: ‘state’
[17:02:32.033] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:32.033] - Launch lazy future ...
[17:02:32.033] Packages needed by the future expression (n = 0): <none>
[17:02:32.033] Packages needed by future strategies (n = 0): <none>
[17:02:32.034] {
[17:02:32.034]     {
[17:02:32.034]         {
[17:02:32.034]             ...future.startTime <- base::Sys.time()
[17:02:32.034]             {
[17:02:32.034]                 {
[17:02:32.034]                   {
[17:02:32.034]                     {
[17:02:32.034]                       base::local({
[17:02:32.034]                         has_future <- base::requireNamespace("future", 
[17:02:32.034]                           quietly = TRUE)
[17:02:32.034]                         if (has_future) {
[17:02:32.034]                           ns <- base::getNamespace("future")
[17:02:32.034]                           version <- ns[[".package"]][["version"]]
[17:02:32.034]                           if (is.null(version)) 
[17:02:32.034]                             version <- utils::packageVersion("future")
[17:02:32.034]                         }
[17:02:32.034]                         else {
[17:02:32.034]                           version <- NULL
[17:02:32.034]                         }
[17:02:32.034]                         if (!has_future || version < "1.8.0") {
[17:02:32.034]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.034]                             "", base::R.version$version.string), 
[17:02:32.034]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.034]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.034]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.034]                               "release", "version")], collapse = " "), 
[17:02:32.034]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.034]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.034]                             info)
[17:02:32.034]                           info <- base::paste(info, collapse = "; ")
[17:02:32.034]                           if (!has_future) {
[17:02:32.034]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.034]                               info)
[17:02:32.034]                           }
[17:02:32.034]                           else {
[17:02:32.034]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.034]                               info, version)
[17:02:32.034]                           }
[17:02:32.034]                           base::stop(msg)
[17:02:32.034]                         }
[17:02:32.034]                       })
[17:02:32.034]                     }
[17:02:32.034]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.034]                     base::options(mc.cores = 1L)
[17:02:32.034]                   }
[17:02:32.034]                   ...future.strategy.old <- future::plan("list")
[17:02:32.034]                   options(future.plan = NULL)
[17:02:32.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.034]                 }
[17:02:32.034]                 ...future.workdir <- getwd()
[17:02:32.034]             }
[17:02:32.034]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.034]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.034]         }
[17:02:32.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.034]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.034]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.034]             base::names(...future.oldOptions))
[17:02:32.034]     }
[17:02:32.034]     if (FALSE) {
[17:02:32.034]     }
[17:02:32.034]     else {
[17:02:32.034]         if (TRUE) {
[17:02:32.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.034]                 open = "w")
[17:02:32.034]         }
[17:02:32.034]         else {
[17:02:32.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.034]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.034]         }
[17:02:32.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.034]             base::sink(type = "output", split = FALSE)
[17:02:32.034]             base::close(...future.stdout)
[17:02:32.034]         }, add = TRUE)
[17:02:32.034]     }
[17:02:32.034]     ...future.frame <- base::sys.nframe()
[17:02:32.034]     ...future.conditions <- base::list()
[17:02:32.034]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.034]     if (FALSE) {
[17:02:32.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.034]     }
[17:02:32.034]     ...future.result <- base::tryCatch({
[17:02:32.034]         base::withCallingHandlers({
[17:02:32.034]             ...future.value <- base::withVisible(base::local({
[17:02:32.034]                 ...future.makeSendCondition <- base::local({
[17:02:32.034]                   sendCondition <- NULL
[17:02:32.034]                   function(frame = 1L) {
[17:02:32.034]                     if (is.function(sendCondition)) 
[17:02:32.034]                       return(sendCondition)
[17:02:32.034]                     ns <- getNamespace("parallel")
[17:02:32.034]                     if (exists("sendData", mode = "function", 
[17:02:32.034]                       envir = ns)) {
[17:02:32.034]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:32.034]                         envir = ns)
[17:02:32.034]                       envir <- sys.frame(frame)
[17:02:32.034]                       master <- NULL
[17:02:32.034]                       while (!identical(envir, .GlobalEnv) && 
[17:02:32.034]                         !identical(envir, emptyenv())) {
[17:02:32.034]                         if (exists("master", mode = "list", envir = envir, 
[17:02:32.034]                           inherits = FALSE)) {
[17:02:32.034]                           master <- get("master", mode = "list", 
[17:02:32.034]                             envir = envir, inherits = FALSE)
[17:02:32.034]                           if (inherits(master, c("SOCKnode", 
[17:02:32.034]                             "SOCK0node"))) {
[17:02:32.034]                             sendCondition <<- function(cond) {
[17:02:32.034]                               data <- list(type = "VALUE", value = cond, 
[17:02:32.034]                                 success = TRUE)
[17:02:32.034]                               parallel_sendData(master, data)
[17:02:32.034]                             }
[17:02:32.034]                             return(sendCondition)
[17:02:32.034]                           }
[17:02:32.034]                         }
[17:02:32.034]                         frame <- frame + 1L
[17:02:32.034]                         envir <- sys.frame(frame)
[17:02:32.034]                       }
[17:02:32.034]                     }
[17:02:32.034]                     sendCondition <<- function(cond) NULL
[17:02:32.034]                   }
[17:02:32.034]                 })
[17:02:32.034]                 withCallingHandlers({
[17:02:32.034]                   2
[17:02:32.034]                 }, immediateCondition = function(cond) {
[17:02:32.034]                   sendCondition <- ...future.makeSendCondition()
[17:02:32.034]                   sendCondition(cond)
[17:02:32.034]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.034]                   {
[17:02:32.034]                     inherits <- base::inherits
[17:02:32.034]                     invokeRestart <- base::invokeRestart
[17:02:32.034]                     is.null <- base::is.null
[17:02:32.034]                     muffled <- FALSE
[17:02:32.034]                     if (inherits(cond, "message")) {
[17:02:32.034]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.034]                       if (muffled) 
[17:02:32.034]                         invokeRestart("muffleMessage")
[17:02:32.034]                     }
[17:02:32.034]                     else if (inherits(cond, "warning")) {
[17:02:32.034]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.034]                       if (muffled) 
[17:02:32.034]                         invokeRestart("muffleWarning")
[17:02:32.034]                     }
[17:02:32.034]                     else if (inherits(cond, "condition")) {
[17:02:32.034]                       if (!is.null(pattern)) {
[17:02:32.034]                         computeRestarts <- base::computeRestarts
[17:02:32.034]                         grepl <- base::grepl
[17:02:32.034]                         restarts <- computeRestarts(cond)
[17:02:32.034]                         for (restart in restarts) {
[17:02:32.034]                           name <- restart$name
[17:02:32.034]                           if (is.null(name)) 
[17:02:32.034]                             next
[17:02:32.034]                           if (!grepl(pattern, name)) 
[17:02:32.034]                             next
[17:02:32.034]                           invokeRestart(restart)
[17:02:32.034]                           muffled <- TRUE
[17:02:32.034]                           break
[17:02:32.034]                         }
[17:02:32.034]                       }
[17:02:32.034]                     }
[17:02:32.034]                     invisible(muffled)
[17:02:32.034]                   }
[17:02:32.034]                   muffleCondition(cond)
[17:02:32.034]                 })
[17:02:32.034]             }))
[17:02:32.034]             future::FutureResult(value = ...future.value$value, 
[17:02:32.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.034]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.034]                     ...future.globalenv.names))
[17:02:32.034]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.034]         }, condition = base::local({
[17:02:32.034]             c <- base::c
[17:02:32.034]             inherits <- base::inherits
[17:02:32.034]             invokeRestart <- base::invokeRestart
[17:02:32.034]             length <- base::length
[17:02:32.034]             list <- base::list
[17:02:32.034]             seq.int <- base::seq.int
[17:02:32.034]             signalCondition <- base::signalCondition
[17:02:32.034]             sys.calls <- base::sys.calls
[17:02:32.034]             `[[` <- base::`[[`
[17:02:32.034]             `+` <- base::`+`
[17:02:32.034]             `<<-` <- base::`<<-`
[17:02:32.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.034]                   3L)]
[17:02:32.034]             }
[17:02:32.034]             function(cond) {
[17:02:32.034]                 is_error <- inherits(cond, "error")
[17:02:32.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.034]                   NULL)
[17:02:32.034]                 if (is_error) {
[17:02:32.034]                   sessionInformation <- function() {
[17:02:32.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.034]                       search = base::search(), system = base::Sys.info())
[17:02:32.034]                   }
[17:02:32.034]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.034]                     cond$call), session = sessionInformation(), 
[17:02:32.034]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.034]                   signalCondition(cond)
[17:02:32.034]                 }
[17:02:32.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.034]                 "immediateCondition"))) {
[17:02:32.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.034]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.034]                   if (TRUE && !signal) {
[17:02:32.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.034]                     {
[17:02:32.034]                       inherits <- base::inherits
[17:02:32.034]                       invokeRestart <- base::invokeRestart
[17:02:32.034]                       is.null <- base::is.null
[17:02:32.034]                       muffled <- FALSE
[17:02:32.034]                       if (inherits(cond, "message")) {
[17:02:32.034]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.034]                         if (muffled) 
[17:02:32.034]                           invokeRestart("muffleMessage")
[17:02:32.034]                       }
[17:02:32.034]                       else if (inherits(cond, "warning")) {
[17:02:32.034]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.034]                         if (muffled) 
[17:02:32.034]                           invokeRestart("muffleWarning")
[17:02:32.034]                       }
[17:02:32.034]                       else if (inherits(cond, "condition")) {
[17:02:32.034]                         if (!is.null(pattern)) {
[17:02:32.034]                           computeRestarts <- base::computeRestarts
[17:02:32.034]                           grepl <- base::grepl
[17:02:32.034]                           restarts <- computeRestarts(cond)
[17:02:32.034]                           for (restart in restarts) {
[17:02:32.034]                             name <- restart$name
[17:02:32.034]                             if (is.null(name)) 
[17:02:32.034]                               next
[17:02:32.034]                             if (!grepl(pattern, name)) 
[17:02:32.034]                               next
[17:02:32.034]                             invokeRestart(restart)
[17:02:32.034]                             muffled <- TRUE
[17:02:32.034]                             break
[17:02:32.034]                           }
[17:02:32.034]                         }
[17:02:32.034]                       }
[17:02:32.034]                       invisible(muffled)
[17:02:32.034]                     }
[17:02:32.034]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.034]                   }
[17:02:32.034]                 }
[17:02:32.034]                 else {
[17:02:32.034]                   if (TRUE) {
[17:02:32.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.034]                     {
[17:02:32.034]                       inherits <- base::inherits
[17:02:32.034]                       invokeRestart <- base::invokeRestart
[17:02:32.034]                       is.null <- base::is.null
[17:02:32.034]                       muffled <- FALSE
[17:02:32.034]                       if (inherits(cond, "message")) {
[17:02:32.034]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.034]                         if (muffled) 
[17:02:32.034]                           invokeRestart("muffleMessage")
[17:02:32.034]                       }
[17:02:32.034]                       else if (inherits(cond, "warning")) {
[17:02:32.034]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.034]                         if (muffled) 
[17:02:32.034]                           invokeRestart("muffleWarning")
[17:02:32.034]                       }
[17:02:32.034]                       else if (inherits(cond, "condition")) {
[17:02:32.034]                         if (!is.null(pattern)) {
[17:02:32.034]                           computeRestarts <- base::computeRestarts
[17:02:32.034]                           grepl <- base::grepl
[17:02:32.034]                           restarts <- computeRestarts(cond)
[17:02:32.034]                           for (restart in restarts) {
[17:02:32.034]                             name <- restart$name
[17:02:32.034]                             if (is.null(name)) 
[17:02:32.034]                               next
[17:02:32.034]                             if (!grepl(pattern, name)) 
[17:02:32.034]                               next
[17:02:32.034]                             invokeRestart(restart)
[17:02:32.034]                             muffled <- TRUE
[17:02:32.034]                             break
[17:02:32.034]                           }
[17:02:32.034]                         }
[17:02:32.034]                       }
[17:02:32.034]                       invisible(muffled)
[17:02:32.034]                     }
[17:02:32.034]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.034]                   }
[17:02:32.034]                 }
[17:02:32.034]             }
[17:02:32.034]         }))
[17:02:32.034]     }, error = function(ex) {
[17:02:32.034]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.034]                 ...future.rng), started = ...future.startTime, 
[17:02:32.034]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.034]             version = "1.8"), class = "FutureResult")
[17:02:32.034]     }, finally = {
[17:02:32.034]         if (!identical(...future.workdir, getwd())) 
[17:02:32.034]             setwd(...future.workdir)
[17:02:32.034]         {
[17:02:32.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.034]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.034]             }
[17:02:32.034]             base::options(...future.oldOptions)
[17:02:32.034]             if (.Platform$OS.type == "windows") {
[17:02:32.034]                 old_names <- names(...future.oldEnvVars)
[17:02:32.034]                 envs <- base::Sys.getenv()
[17:02:32.034]                 names <- names(envs)
[17:02:32.034]                 common <- intersect(names, old_names)
[17:02:32.034]                 added <- setdiff(names, old_names)
[17:02:32.034]                 removed <- setdiff(old_names, names)
[17:02:32.034]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.034]                   envs[common]]
[17:02:32.034]                 NAMES <- toupper(changed)
[17:02:32.034]                 args <- list()
[17:02:32.034]                 for (kk in seq_along(NAMES)) {
[17:02:32.034]                   name <- changed[[kk]]
[17:02:32.034]                   NAME <- NAMES[[kk]]
[17:02:32.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.034]                     next
[17:02:32.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.034]                 }
[17:02:32.034]                 NAMES <- toupper(added)
[17:02:32.034]                 for (kk in seq_along(NAMES)) {
[17:02:32.034]                   name <- added[[kk]]
[17:02:32.034]                   NAME <- NAMES[[kk]]
[17:02:32.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.034]                     next
[17:02:32.034]                   args[[name]] <- ""
[17:02:32.034]                 }
[17:02:32.034]                 NAMES <- toupper(removed)
[17:02:32.034]                 for (kk in seq_along(NAMES)) {
[17:02:32.034]                   name <- removed[[kk]]
[17:02:32.034]                   NAME <- NAMES[[kk]]
[17:02:32.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.034]                     next
[17:02:32.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.034]                 }
[17:02:32.034]                 if (length(args) > 0) 
[17:02:32.034]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.034]             }
[17:02:32.034]             else {
[17:02:32.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.034]             }
[17:02:32.034]             {
[17:02:32.034]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.034]                   0L) {
[17:02:32.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.034]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.034]                   base::options(opts)
[17:02:32.034]                 }
[17:02:32.034]                 {
[17:02:32.034]                   {
[17:02:32.034]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.034]                     NULL
[17:02:32.034]                   }
[17:02:32.034]                   options(future.plan = NULL)
[17:02:32.034]                   if (is.na(NA_character_)) 
[17:02:32.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.034]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.034]                     .init = FALSE)
[17:02:32.034]                 }
[17:02:32.034]             }
[17:02:32.034]         }
[17:02:32.034]     })
[17:02:32.034]     if (TRUE) {
[17:02:32.034]         base::sink(type = "output", split = FALSE)
[17:02:32.034]         if (TRUE) {
[17:02:32.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.034]         }
[17:02:32.034]         else {
[17:02:32.034]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.034]         }
[17:02:32.034]         base::close(...future.stdout)
[17:02:32.034]         ...future.stdout <- NULL
[17:02:32.034]     }
[17:02:32.034]     ...future.result$conditions <- ...future.conditions
[17:02:32.034]     ...future.result$finished <- base::Sys.time()
[17:02:32.034]     ...future.result
[17:02:32.034] }
[17:02:32.037] MultisessionFuture started
[17:02:32.037] - Launch lazy future ... done
[17:02:32.037] run() for ‘MultisessionFuture’ ... done
[17:02:32.037] getGlobalsAndPackages() ...
[17:02:32.038] Searching for globals...
[17:02:32.038] 
[17:02:32.038] Searching for globals ... DONE
[17:02:32.038] - globals: [0] <none>
[17:02:32.039] getGlobalsAndPackages() ... DONE
[17:02:32.039] run() for ‘Future’ ...
[17:02:32.039] - state: ‘created’
[17:02:32.039] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.053] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.056] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:32.056]   - Field: ‘node’
[17:02:32.056]   - Field: ‘label’
[17:02:32.056]   - Field: ‘local’
[17:02:32.056]   - Field: ‘owner’
[17:02:32.056]   - Field: ‘envir’
[17:02:32.057]   - Field: ‘workers’
[17:02:32.057]   - Field: ‘packages’
[17:02:32.057]   - Field: ‘gc’
[17:02:32.057]   - Field: ‘conditions’
[17:02:32.057]   - Field: ‘persistent’
[17:02:32.057]   - Field: ‘expr’
[17:02:32.057]   - Field: ‘uuid’
[17:02:32.057]   - Field: ‘seed’
[17:02:32.057]   - Field: ‘version’
[17:02:32.057]   - Field: ‘result’
[17:02:32.057]   - Field: ‘asynchronous’
[17:02:32.058]   - Field: ‘calls’
[17:02:32.058]   - Field: ‘globals’
[17:02:32.058]   - Field: ‘stdout’
[17:02:32.058]   - Field: ‘earlySignal’
[17:02:32.058]   - Field: ‘lazy’
[17:02:32.058]   - Field: ‘state’
[17:02:32.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:32.058] - Launch lazy future ...
[17:02:32.058] Packages needed by the future expression (n = 0): <none>
[17:02:32.059] Packages needed by future strategies (n = 0): <none>
[17:02:32.059] {
[17:02:32.059]     {
[17:02:32.059]         {
[17:02:32.059]             ...future.startTime <- base::Sys.time()
[17:02:32.059]             {
[17:02:32.059]                 {
[17:02:32.059]                   {
[17:02:32.059]                     {
[17:02:32.059]                       base::local({
[17:02:32.059]                         has_future <- base::requireNamespace("future", 
[17:02:32.059]                           quietly = TRUE)
[17:02:32.059]                         if (has_future) {
[17:02:32.059]                           ns <- base::getNamespace("future")
[17:02:32.059]                           version <- ns[[".package"]][["version"]]
[17:02:32.059]                           if (is.null(version)) 
[17:02:32.059]                             version <- utils::packageVersion("future")
[17:02:32.059]                         }
[17:02:32.059]                         else {
[17:02:32.059]                           version <- NULL
[17:02:32.059]                         }
[17:02:32.059]                         if (!has_future || version < "1.8.0") {
[17:02:32.059]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.059]                             "", base::R.version$version.string), 
[17:02:32.059]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.059]                               "release", "version")], collapse = " "), 
[17:02:32.059]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.059]                             info)
[17:02:32.059]                           info <- base::paste(info, collapse = "; ")
[17:02:32.059]                           if (!has_future) {
[17:02:32.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.059]                               info)
[17:02:32.059]                           }
[17:02:32.059]                           else {
[17:02:32.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.059]                               info, version)
[17:02:32.059]                           }
[17:02:32.059]                           base::stop(msg)
[17:02:32.059]                         }
[17:02:32.059]                       })
[17:02:32.059]                     }
[17:02:32.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.059]                     base::options(mc.cores = 1L)
[17:02:32.059]                   }
[17:02:32.059]                   ...future.strategy.old <- future::plan("list")
[17:02:32.059]                   options(future.plan = NULL)
[17:02:32.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.059]                 }
[17:02:32.059]                 ...future.workdir <- getwd()
[17:02:32.059]             }
[17:02:32.059]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.059]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.059]         }
[17:02:32.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.059]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.059]             base::names(...future.oldOptions))
[17:02:32.059]     }
[17:02:32.059]     if (FALSE) {
[17:02:32.059]     }
[17:02:32.059]     else {
[17:02:32.059]         if (TRUE) {
[17:02:32.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.059]                 open = "w")
[17:02:32.059]         }
[17:02:32.059]         else {
[17:02:32.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.059]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.059]         }
[17:02:32.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.059]             base::sink(type = "output", split = FALSE)
[17:02:32.059]             base::close(...future.stdout)
[17:02:32.059]         }, add = TRUE)
[17:02:32.059]     }
[17:02:32.059]     ...future.frame <- base::sys.nframe()
[17:02:32.059]     ...future.conditions <- base::list()
[17:02:32.059]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.059]     if (FALSE) {
[17:02:32.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.059]     }
[17:02:32.059]     ...future.result <- base::tryCatch({
[17:02:32.059]         base::withCallingHandlers({
[17:02:32.059]             ...future.value <- base::withVisible(base::local({
[17:02:32.059]                 ...future.makeSendCondition <- base::local({
[17:02:32.059]                   sendCondition <- NULL
[17:02:32.059]                   function(frame = 1L) {
[17:02:32.059]                     if (is.function(sendCondition)) 
[17:02:32.059]                       return(sendCondition)
[17:02:32.059]                     ns <- getNamespace("parallel")
[17:02:32.059]                     if (exists("sendData", mode = "function", 
[17:02:32.059]                       envir = ns)) {
[17:02:32.059]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:32.059]                         envir = ns)
[17:02:32.059]                       envir <- sys.frame(frame)
[17:02:32.059]                       master <- NULL
[17:02:32.059]                       while (!identical(envir, .GlobalEnv) && 
[17:02:32.059]                         !identical(envir, emptyenv())) {
[17:02:32.059]                         if (exists("master", mode = "list", envir = envir, 
[17:02:32.059]                           inherits = FALSE)) {
[17:02:32.059]                           master <- get("master", mode = "list", 
[17:02:32.059]                             envir = envir, inherits = FALSE)
[17:02:32.059]                           if (inherits(master, c("SOCKnode", 
[17:02:32.059]                             "SOCK0node"))) {
[17:02:32.059]                             sendCondition <<- function(cond) {
[17:02:32.059]                               data <- list(type = "VALUE", value = cond, 
[17:02:32.059]                                 success = TRUE)
[17:02:32.059]                               parallel_sendData(master, data)
[17:02:32.059]                             }
[17:02:32.059]                             return(sendCondition)
[17:02:32.059]                           }
[17:02:32.059]                         }
[17:02:32.059]                         frame <- frame + 1L
[17:02:32.059]                         envir <- sys.frame(frame)
[17:02:32.059]                       }
[17:02:32.059]                     }
[17:02:32.059]                     sendCondition <<- function(cond) NULL
[17:02:32.059]                   }
[17:02:32.059]                 })
[17:02:32.059]                 withCallingHandlers({
[17:02:32.059]                   NULL
[17:02:32.059]                 }, immediateCondition = function(cond) {
[17:02:32.059]                   sendCondition <- ...future.makeSendCondition()
[17:02:32.059]                   sendCondition(cond)
[17:02:32.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.059]                   {
[17:02:32.059]                     inherits <- base::inherits
[17:02:32.059]                     invokeRestart <- base::invokeRestart
[17:02:32.059]                     is.null <- base::is.null
[17:02:32.059]                     muffled <- FALSE
[17:02:32.059]                     if (inherits(cond, "message")) {
[17:02:32.059]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.059]                       if (muffled) 
[17:02:32.059]                         invokeRestart("muffleMessage")
[17:02:32.059]                     }
[17:02:32.059]                     else if (inherits(cond, "warning")) {
[17:02:32.059]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.059]                       if (muffled) 
[17:02:32.059]                         invokeRestart("muffleWarning")
[17:02:32.059]                     }
[17:02:32.059]                     else if (inherits(cond, "condition")) {
[17:02:32.059]                       if (!is.null(pattern)) {
[17:02:32.059]                         computeRestarts <- base::computeRestarts
[17:02:32.059]                         grepl <- base::grepl
[17:02:32.059]                         restarts <- computeRestarts(cond)
[17:02:32.059]                         for (restart in restarts) {
[17:02:32.059]                           name <- restart$name
[17:02:32.059]                           if (is.null(name)) 
[17:02:32.059]                             next
[17:02:32.059]                           if (!grepl(pattern, name)) 
[17:02:32.059]                             next
[17:02:32.059]                           invokeRestart(restart)
[17:02:32.059]                           muffled <- TRUE
[17:02:32.059]                           break
[17:02:32.059]                         }
[17:02:32.059]                       }
[17:02:32.059]                     }
[17:02:32.059]                     invisible(muffled)
[17:02:32.059]                   }
[17:02:32.059]                   muffleCondition(cond)
[17:02:32.059]                 })
[17:02:32.059]             }))
[17:02:32.059]             future::FutureResult(value = ...future.value$value, 
[17:02:32.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.059]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.059]                     ...future.globalenv.names))
[17:02:32.059]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.059]         }, condition = base::local({
[17:02:32.059]             c <- base::c
[17:02:32.059]             inherits <- base::inherits
[17:02:32.059]             invokeRestart <- base::invokeRestart
[17:02:32.059]             length <- base::length
[17:02:32.059]             list <- base::list
[17:02:32.059]             seq.int <- base::seq.int
[17:02:32.059]             signalCondition <- base::signalCondition
[17:02:32.059]             sys.calls <- base::sys.calls
[17:02:32.059]             `[[` <- base::`[[`
[17:02:32.059]             `+` <- base::`+`
[17:02:32.059]             `<<-` <- base::`<<-`
[17:02:32.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.059]                   3L)]
[17:02:32.059]             }
[17:02:32.059]             function(cond) {
[17:02:32.059]                 is_error <- inherits(cond, "error")
[17:02:32.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.059]                   NULL)
[17:02:32.059]                 if (is_error) {
[17:02:32.059]                   sessionInformation <- function() {
[17:02:32.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.059]                       search = base::search(), system = base::Sys.info())
[17:02:32.059]                   }
[17:02:32.059]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.059]                     cond$call), session = sessionInformation(), 
[17:02:32.059]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.059]                   signalCondition(cond)
[17:02:32.059]                 }
[17:02:32.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.059]                 "immediateCondition"))) {
[17:02:32.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.059]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.059]                   if (TRUE && !signal) {
[17:02:32.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.059]                     {
[17:02:32.059]                       inherits <- base::inherits
[17:02:32.059]                       invokeRestart <- base::invokeRestart
[17:02:32.059]                       is.null <- base::is.null
[17:02:32.059]                       muffled <- FALSE
[17:02:32.059]                       if (inherits(cond, "message")) {
[17:02:32.059]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.059]                         if (muffled) 
[17:02:32.059]                           invokeRestart("muffleMessage")
[17:02:32.059]                       }
[17:02:32.059]                       else if (inherits(cond, "warning")) {
[17:02:32.059]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.059]                         if (muffled) 
[17:02:32.059]                           invokeRestart("muffleWarning")
[17:02:32.059]                       }
[17:02:32.059]                       else if (inherits(cond, "condition")) {
[17:02:32.059]                         if (!is.null(pattern)) {
[17:02:32.059]                           computeRestarts <- base::computeRestarts
[17:02:32.059]                           grepl <- base::grepl
[17:02:32.059]                           restarts <- computeRestarts(cond)
[17:02:32.059]                           for (restart in restarts) {
[17:02:32.059]                             name <- restart$name
[17:02:32.059]                             if (is.null(name)) 
[17:02:32.059]                               next
[17:02:32.059]                             if (!grepl(pattern, name)) 
[17:02:32.059]                               next
[17:02:32.059]                             invokeRestart(restart)
[17:02:32.059]                             muffled <- TRUE
[17:02:32.059]                             break
[17:02:32.059]                           }
[17:02:32.059]                         }
[17:02:32.059]                       }
[17:02:32.059]                       invisible(muffled)
[17:02:32.059]                     }
[17:02:32.059]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.059]                   }
[17:02:32.059]                 }
[17:02:32.059]                 else {
[17:02:32.059]                   if (TRUE) {
[17:02:32.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.059]                     {
[17:02:32.059]                       inherits <- base::inherits
[17:02:32.059]                       invokeRestart <- base::invokeRestart
[17:02:32.059]                       is.null <- base::is.null
[17:02:32.059]                       muffled <- FALSE
[17:02:32.059]                       if (inherits(cond, "message")) {
[17:02:32.059]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.059]                         if (muffled) 
[17:02:32.059]                           invokeRestart("muffleMessage")
[17:02:32.059]                       }
[17:02:32.059]                       else if (inherits(cond, "warning")) {
[17:02:32.059]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.059]                         if (muffled) 
[17:02:32.059]                           invokeRestart("muffleWarning")
[17:02:32.059]                       }
[17:02:32.059]                       else if (inherits(cond, "condition")) {
[17:02:32.059]                         if (!is.null(pattern)) {
[17:02:32.059]                           computeRestarts <- base::computeRestarts
[17:02:32.059]                           grepl <- base::grepl
[17:02:32.059]                           restarts <- computeRestarts(cond)
[17:02:32.059]                           for (restart in restarts) {
[17:02:32.059]                             name <- restart$name
[17:02:32.059]                             if (is.null(name)) 
[17:02:32.059]                               next
[17:02:32.059]                             if (!grepl(pattern, name)) 
[17:02:32.059]                               next
[17:02:32.059]                             invokeRestart(restart)
[17:02:32.059]                             muffled <- TRUE
[17:02:32.059]                             break
[17:02:32.059]                           }
[17:02:32.059]                         }
[17:02:32.059]                       }
[17:02:32.059]                       invisible(muffled)
[17:02:32.059]                     }
[17:02:32.059]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.059]                   }
[17:02:32.059]                 }
[17:02:32.059]             }
[17:02:32.059]         }))
[17:02:32.059]     }, error = function(ex) {
[17:02:32.059]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.059]                 ...future.rng), started = ...future.startTime, 
[17:02:32.059]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.059]             version = "1.8"), class = "FutureResult")
[17:02:32.059]     }, finally = {
[17:02:32.059]         if (!identical(...future.workdir, getwd())) 
[17:02:32.059]             setwd(...future.workdir)
[17:02:32.059]         {
[17:02:32.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.059]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.059]             }
[17:02:32.059]             base::options(...future.oldOptions)
[17:02:32.059]             if (.Platform$OS.type == "windows") {
[17:02:32.059]                 old_names <- names(...future.oldEnvVars)
[17:02:32.059]                 envs <- base::Sys.getenv()
[17:02:32.059]                 names <- names(envs)
[17:02:32.059]                 common <- intersect(names, old_names)
[17:02:32.059]                 added <- setdiff(names, old_names)
[17:02:32.059]                 removed <- setdiff(old_names, names)
[17:02:32.059]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.059]                   envs[common]]
[17:02:32.059]                 NAMES <- toupper(changed)
[17:02:32.059]                 args <- list()
[17:02:32.059]                 for (kk in seq_along(NAMES)) {
[17:02:32.059]                   name <- changed[[kk]]
[17:02:32.059]                   NAME <- NAMES[[kk]]
[17:02:32.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.059]                     next
[17:02:32.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.059]                 }
[17:02:32.059]                 NAMES <- toupper(added)
[17:02:32.059]                 for (kk in seq_along(NAMES)) {
[17:02:32.059]                   name <- added[[kk]]
[17:02:32.059]                   NAME <- NAMES[[kk]]
[17:02:32.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.059]                     next
[17:02:32.059]                   args[[name]] <- ""
[17:02:32.059]                 }
[17:02:32.059]                 NAMES <- toupper(removed)
[17:02:32.059]                 for (kk in seq_along(NAMES)) {
[17:02:32.059]                   name <- removed[[kk]]
[17:02:32.059]                   NAME <- NAMES[[kk]]
[17:02:32.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.059]                     next
[17:02:32.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.059]                 }
[17:02:32.059]                 if (length(args) > 0) 
[17:02:32.059]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.059]             }
[17:02:32.059]             else {
[17:02:32.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.059]             }
[17:02:32.059]             {
[17:02:32.059]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.059]                   0L) {
[17:02:32.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.059]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.059]                   base::options(opts)
[17:02:32.059]                 }
[17:02:32.059]                 {
[17:02:32.059]                   {
[17:02:32.059]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.059]                     NULL
[17:02:32.059]                   }
[17:02:32.059]                   options(future.plan = NULL)
[17:02:32.059]                   if (is.na(NA_character_)) 
[17:02:32.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.059]                     .init = FALSE)
[17:02:32.059]                 }
[17:02:32.059]             }
[17:02:32.059]         }
[17:02:32.059]     })
[17:02:32.059]     if (TRUE) {
[17:02:32.059]         base::sink(type = "output", split = FALSE)
[17:02:32.059]         if (TRUE) {
[17:02:32.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.059]         }
[17:02:32.059]         else {
[17:02:32.059]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.059]         }
[17:02:32.059]         base::close(...future.stdout)
[17:02:32.059]         ...future.stdout <- NULL
[17:02:32.059]     }
[17:02:32.059]     ...future.result$conditions <- ...future.conditions
[17:02:32.059]     ...future.result$finished <- base::Sys.time()
[17:02:32.059]     ...future.result
[17:02:32.059] }
[17:02:32.062] MultisessionFuture started
[17:02:32.062] - Launch lazy future ... done
[17:02:32.062] run() for ‘MultisessionFuture’ ... done
[17:02:32.063] getGlobalsAndPackages() ...
[17:02:32.063] Searching for globals...
[17:02:32.063] - globals found: [1] ‘{’
[17:02:32.064] Searching for globals ... DONE
[17:02:32.064] Resolving globals: FALSE
[17:02:32.064] 
[17:02:32.064] 
[17:02:32.064] getGlobalsAndPackages() ... DONE
[17:02:32.064] run() for ‘Future’ ...
[17:02:32.064] - state: ‘created’
[17:02:32.065] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.078] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.078] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:32.079]   - Field: ‘node’
[17:02:32.079]   - Field: ‘label’
[17:02:32.079]   - Field: ‘local’
[17:02:32.079]   - Field: ‘owner’
[17:02:32.079]   - Field: ‘envir’
[17:02:32.079]   - Field: ‘workers’
[17:02:32.079]   - Field: ‘packages’
[17:02:32.079]   - Field: ‘gc’
[17:02:32.079]   - Field: ‘conditions’
[17:02:32.079]   - Field: ‘persistent’
[17:02:32.080]   - Field: ‘expr’
[17:02:32.080]   - Field: ‘uuid’
[17:02:32.080]   - Field: ‘seed’
[17:02:32.080]   - Field: ‘version’
[17:02:32.080]   - Field: ‘result’
[17:02:32.080]   - Field: ‘asynchronous’
[17:02:32.080]   - Field: ‘calls’
[17:02:32.080]   - Field: ‘globals’
[17:02:32.080]   - Field: ‘stdout’
[17:02:32.080]   - Field: ‘earlySignal’
[17:02:32.080]   - Field: ‘lazy’
[17:02:32.080]   - Field: ‘state’
[17:02:32.081] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:32.081] - Launch lazy future ...
[17:02:32.081] Packages needed by the future expression (n = 0): <none>
[17:02:32.081] Packages needed by future strategies (n = 0): <none>
[17:02:32.081] {
[17:02:32.081]     {
[17:02:32.081]         {
[17:02:32.081]             ...future.startTime <- base::Sys.time()
[17:02:32.081]             {
[17:02:32.081]                 {
[17:02:32.081]                   {
[17:02:32.081]                     {
[17:02:32.081]                       base::local({
[17:02:32.081]                         has_future <- base::requireNamespace("future", 
[17:02:32.081]                           quietly = TRUE)
[17:02:32.081]                         if (has_future) {
[17:02:32.081]                           ns <- base::getNamespace("future")
[17:02:32.081]                           version <- ns[[".package"]][["version"]]
[17:02:32.081]                           if (is.null(version)) 
[17:02:32.081]                             version <- utils::packageVersion("future")
[17:02:32.081]                         }
[17:02:32.081]                         else {
[17:02:32.081]                           version <- NULL
[17:02:32.081]                         }
[17:02:32.081]                         if (!has_future || version < "1.8.0") {
[17:02:32.081]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.081]                             "", base::R.version$version.string), 
[17:02:32.081]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.081]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.081]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.081]                               "release", "version")], collapse = " "), 
[17:02:32.081]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.081]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.081]                             info)
[17:02:32.081]                           info <- base::paste(info, collapse = "; ")
[17:02:32.081]                           if (!has_future) {
[17:02:32.081]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.081]                               info)
[17:02:32.081]                           }
[17:02:32.081]                           else {
[17:02:32.081]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.081]                               info, version)
[17:02:32.081]                           }
[17:02:32.081]                           base::stop(msg)
[17:02:32.081]                         }
[17:02:32.081]                       })
[17:02:32.081]                     }
[17:02:32.081]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.081]                     base::options(mc.cores = 1L)
[17:02:32.081]                   }
[17:02:32.081]                   ...future.strategy.old <- future::plan("list")
[17:02:32.081]                   options(future.plan = NULL)
[17:02:32.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.081]                 }
[17:02:32.081]                 ...future.workdir <- getwd()
[17:02:32.081]             }
[17:02:32.081]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.081]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.081]         }
[17:02:32.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.081]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.081]             base::names(...future.oldOptions))
[17:02:32.081]     }
[17:02:32.081]     if (FALSE) {
[17:02:32.081]     }
[17:02:32.081]     else {
[17:02:32.081]         if (TRUE) {
[17:02:32.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.081]                 open = "w")
[17:02:32.081]         }
[17:02:32.081]         else {
[17:02:32.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.081]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.081]         }
[17:02:32.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.081]             base::sink(type = "output", split = FALSE)
[17:02:32.081]             base::close(...future.stdout)
[17:02:32.081]         }, add = TRUE)
[17:02:32.081]     }
[17:02:32.081]     ...future.frame <- base::sys.nframe()
[17:02:32.081]     ...future.conditions <- base::list()
[17:02:32.081]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.081]     if (FALSE) {
[17:02:32.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.081]     }
[17:02:32.081]     ...future.result <- base::tryCatch({
[17:02:32.081]         base::withCallingHandlers({
[17:02:32.081]             ...future.value <- base::withVisible(base::local({
[17:02:32.081]                 ...future.makeSendCondition <- base::local({
[17:02:32.081]                   sendCondition <- NULL
[17:02:32.081]                   function(frame = 1L) {
[17:02:32.081]                     if (is.function(sendCondition)) 
[17:02:32.081]                       return(sendCondition)
[17:02:32.081]                     ns <- getNamespace("parallel")
[17:02:32.081]                     if (exists("sendData", mode = "function", 
[17:02:32.081]                       envir = ns)) {
[17:02:32.081]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:32.081]                         envir = ns)
[17:02:32.081]                       envir <- sys.frame(frame)
[17:02:32.081]                       master <- NULL
[17:02:32.081]                       while (!identical(envir, .GlobalEnv) && 
[17:02:32.081]                         !identical(envir, emptyenv())) {
[17:02:32.081]                         if (exists("master", mode = "list", envir = envir, 
[17:02:32.081]                           inherits = FALSE)) {
[17:02:32.081]                           master <- get("master", mode = "list", 
[17:02:32.081]                             envir = envir, inherits = FALSE)
[17:02:32.081]                           if (inherits(master, c("SOCKnode", 
[17:02:32.081]                             "SOCK0node"))) {
[17:02:32.081]                             sendCondition <<- function(cond) {
[17:02:32.081]                               data <- list(type = "VALUE", value = cond, 
[17:02:32.081]                                 success = TRUE)
[17:02:32.081]                               parallel_sendData(master, data)
[17:02:32.081]                             }
[17:02:32.081]                             return(sendCondition)
[17:02:32.081]                           }
[17:02:32.081]                         }
[17:02:32.081]                         frame <- frame + 1L
[17:02:32.081]                         envir <- sys.frame(frame)
[17:02:32.081]                       }
[17:02:32.081]                     }
[17:02:32.081]                     sendCondition <<- function(cond) NULL
[17:02:32.081]                   }
[17:02:32.081]                 })
[17:02:32.081]                 withCallingHandlers({
[17:02:32.081]                   {
[17:02:32.081]                     4
[17:02:32.081]                   }
[17:02:32.081]                 }, immediateCondition = function(cond) {
[17:02:32.081]                   sendCondition <- ...future.makeSendCondition()
[17:02:32.081]                   sendCondition(cond)
[17:02:32.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.081]                   {
[17:02:32.081]                     inherits <- base::inherits
[17:02:32.081]                     invokeRestart <- base::invokeRestart
[17:02:32.081]                     is.null <- base::is.null
[17:02:32.081]                     muffled <- FALSE
[17:02:32.081]                     if (inherits(cond, "message")) {
[17:02:32.081]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.081]                       if (muffled) 
[17:02:32.081]                         invokeRestart("muffleMessage")
[17:02:32.081]                     }
[17:02:32.081]                     else if (inherits(cond, "warning")) {
[17:02:32.081]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.081]                       if (muffled) 
[17:02:32.081]                         invokeRestart("muffleWarning")
[17:02:32.081]                     }
[17:02:32.081]                     else if (inherits(cond, "condition")) {
[17:02:32.081]                       if (!is.null(pattern)) {
[17:02:32.081]                         computeRestarts <- base::computeRestarts
[17:02:32.081]                         grepl <- base::grepl
[17:02:32.081]                         restarts <- computeRestarts(cond)
[17:02:32.081]                         for (restart in restarts) {
[17:02:32.081]                           name <- restart$name
[17:02:32.081]                           if (is.null(name)) 
[17:02:32.081]                             next
[17:02:32.081]                           if (!grepl(pattern, name)) 
[17:02:32.081]                             next
[17:02:32.081]                           invokeRestart(restart)
[17:02:32.081]                           muffled <- TRUE
[17:02:32.081]                           break
[17:02:32.081]                         }
[17:02:32.081]                       }
[17:02:32.081]                     }
[17:02:32.081]                     invisible(muffled)
[17:02:32.081]                   }
[17:02:32.081]                   muffleCondition(cond)
[17:02:32.081]                 })
[17:02:32.081]             }))
[17:02:32.081]             future::FutureResult(value = ...future.value$value, 
[17:02:32.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.081]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.081]                     ...future.globalenv.names))
[17:02:32.081]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.081]         }, condition = base::local({
[17:02:32.081]             c <- base::c
[17:02:32.081]             inherits <- base::inherits
[17:02:32.081]             invokeRestart <- base::invokeRestart
[17:02:32.081]             length <- base::length
[17:02:32.081]             list <- base::list
[17:02:32.081]             seq.int <- base::seq.int
[17:02:32.081]             signalCondition <- base::signalCondition
[17:02:32.081]             sys.calls <- base::sys.calls
[17:02:32.081]             `[[` <- base::`[[`
[17:02:32.081]             `+` <- base::`+`
[17:02:32.081]             `<<-` <- base::`<<-`
[17:02:32.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.081]                   3L)]
[17:02:32.081]             }
[17:02:32.081]             function(cond) {
[17:02:32.081]                 is_error <- inherits(cond, "error")
[17:02:32.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.081]                   NULL)
[17:02:32.081]                 if (is_error) {
[17:02:32.081]                   sessionInformation <- function() {
[17:02:32.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.081]                       search = base::search(), system = base::Sys.info())
[17:02:32.081]                   }
[17:02:32.081]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.081]                     cond$call), session = sessionInformation(), 
[17:02:32.081]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.081]                   signalCondition(cond)
[17:02:32.081]                 }
[17:02:32.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.081]                 "immediateCondition"))) {
[17:02:32.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.081]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.081]                   if (TRUE && !signal) {
[17:02:32.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.081]                     {
[17:02:32.081]                       inherits <- base::inherits
[17:02:32.081]                       invokeRestart <- base::invokeRestart
[17:02:32.081]                       is.null <- base::is.null
[17:02:32.081]                       muffled <- FALSE
[17:02:32.081]                       if (inherits(cond, "message")) {
[17:02:32.081]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.081]                         if (muffled) 
[17:02:32.081]                           invokeRestart("muffleMessage")
[17:02:32.081]                       }
[17:02:32.081]                       else if (inherits(cond, "warning")) {
[17:02:32.081]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.081]                         if (muffled) 
[17:02:32.081]                           invokeRestart("muffleWarning")
[17:02:32.081]                       }
[17:02:32.081]                       else if (inherits(cond, "condition")) {
[17:02:32.081]                         if (!is.null(pattern)) {
[17:02:32.081]                           computeRestarts <- base::computeRestarts
[17:02:32.081]                           grepl <- base::grepl
[17:02:32.081]                           restarts <- computeRestarts(cond)
[17:02:32.081]                           for (restart in restarts) {
[17:02:32.081]                             name <- restart$name
[17:02:32.081]                             if (is.null(name)) 
[17:02:32.081]                               next
[17:02:32.081]                             if (!grepl(pattern, name)) 
[17:02:32.081]                               next
[17:02:32.081]                             invokeRestart(restart)
[17:02:32.081]                             muffled <- TRUE
[17:02:32.081]                             break
[17:02:32.081]                           }
[17:02:32.081]                         }
[17:02:32.081]                       }
[17:02:32.081]                       invisible(muffled)
[17:02:32.081]                     }
[17:02:32.081]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.081]                   }
[17:02:32.081]                 }
[17:02:32.081]                 else {
[17:02:32.081]                   if (TRUE) {
[17:02:32.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.081]                     {
[17:02:32.081]                       inherits <- base::inherits
[17:02:32.081]                       invokeRestart <- base::invokeRestart
[17:02:32.081]                       is.null <- base::is.null
[17:02:32.081]                       muffled <- FALSE
[17:02:32.081]                       if (inherits(cond, "message")) {
[17:02:32.081]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.081]                         if (muffled) 
[17:02:32.081]                           invokeRestart("muffleMessage")
[17:02:32.081]                       }
[17:02:32.081]                       else if (inherits(cond, "warning")) {
[17:02:32.081]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.081]                         if (muffled) 
[17:02:32.081]                           invokeRestart("muffleWarning")
[17:02:32.081]                       }
[17:02:32.081]                       else if (inherits(cond, "condition")) {
[17:02:32.081]                         if (!is.null(pattern)) {
[17:02:32.081]                           computeRestarts <- base::computeRestarts
[17:02:32.081]                           grepl <- base::grepl
[17:02:32.081]                           restarts <- computeRestarts(cond)
[17:02:32.081]                           for (restart in restarts) {
[17:02:32.081]                             name <- restart$name
[17:02:32.081]                             if (is.null(name)) 
[17:02:32.081]                               next
[17:02:32.081]                             if (!grepl(pattern, name)) 
[17:02:32.081]                               next
[17:02:32.081]                             invokeRestart(restart)
[17:02:32.081]                             muffled <- TRUE
[17:02:32.081]                             break
[17:02:32.081]                           }
[17:02:32.081]                         }
[17:02:32.081]                       }
[17:02:32.081]                       invisible(muffled)
[17:02:32.081]                     }
[17:02:32.081]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.081]                   }
[17:02:32.081]                 }
[17:02:32.081]             }
[17:02:32.081]         }))
[17:02:32.081]     }, error = function(ex) {
[17:02:32.081]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.081]                 ...future.rng), started = ...future.startTime, 
[17:02:32.081]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.081]             version = "1.8"), class = "FutureResult")
[17:02:32.081]     }, finally = {
[17:02:32.081]         if (!identical(...future.workdir, getwd())) 
[17:02:32.081]             setwd(...future.workdir)
[17:02:32.081]         {
[17:02:32.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.081]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.081]             }
[17:02:32.081]             base::options(...future.oldOptions)
[17:02:32.081]             if (.Platform$OS.type == "windows") {
[17:02:32.081]                 old_names <- names(...future.oldEnvVars)
[17:02:32.081]                 envs <- base::Sys.getenv()
[17:02:32.081]                 names <- names(envs)
[17:02:32.081]                 common <- intersect(names, old_names)
[17:02:32.081]                 added <- setdiff(names, old_names)
[17:02:32.081]                 removed <- setdiff(old_names, names)
[17:02:32.081]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.081]                   envs[common]]
[17:02:32.081]                 NAMES <- toupper(changed)
[17:02:32.081]                 args <- list()
[17:02:32.081]                 for (kk in seq_along(NAMES)) {
[17:02:32.081]                   name <- changed[[kk]]
[17:02:32.081]                   NAME <- NAMES[[kk]]
[17:02:32.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.081]                     next
[17:02:32.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.081]                 }
[17:02:32.081]                 NAMES <- toupper(added)
[17:02:32.081]                 for (kk in seq_along(NAMES)) {
[17:02:32.081]                   name <- added[[kk]]
[17:02:32.081]                   NAME <- NAMES[[kk]]
[17:02:32.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.081]                     next
[17:02:32.081]                   args[[name]] <- ""
[17:02:32.081]                 }
[17:02:32.081]                 NAMES <- toupper(removed)
[17:02:32.081]                 for (kk in seq_along(NAMES)) {
[17:02:32.081]                   name <- removed[[kk]]
[17:02:32.081]                   NAME <- NAMES[[kk]]
[17:02:32.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.081]                     next
[17:02:32.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.081]                 }
[17:02:32.081]                 if (length(args) > 0) 
[17:02:32.081]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.081]             }
[17:02:32.081]             else {
[17:02:32.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.081]             }
[17:02:32.081]             {
[17:02:32.081]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.081]                   0L) {
[17:02:32.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.081]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.081]                   base::options(opts)
[17:02:32.081]                 }
[17:02:32.081]                 {
[17:02:32.081]                   {
[17:02:32.081]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.081]                     NULL
[17:02:32.081]                   }
[17:02:32.081]                   options(future.plan = NULL)
[17:02:32.081]                   if (is.na(NA_character_)) 
[17:02:32.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.081]                     .init = FALSE)
[17:02:32.081]                 }
[17:02:32.081]             }
[17:02:32.081]         }
[17:02:32.081]     })
[17:02:32.081]     if (TRUE) {
[17:02:32.081]         base::sink(type = "output", split = FALSE)
[17:02:32.081]         if (TRUE) {
[17:02:32.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.081]         }
[17:02:32.081]         else {
[17:02:32.081]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.081]         }
[17:02:32.081]         base::close(...future.stdout)
[17:02:32.081]         ...future.stdout <- NULL
[17:02:32.081]     }
[17:02:32.081]     ...future.result$conditions <- ...future.conditions
[17:02:32.081]     ...future.result$finished <- base::Sys.time()
[17:02:32.081]     ...future.result
[17:02:32.081] }
[17:02:32.084] Poll #1 (0): usedNodes() = 2, workers = 2
[17:02:32.094] receiveMessageFromWorker() for ClusterFuture ...
[17:02:32.094] - Validating connection of MultisessionFuture
[17:02:32.095] - received message: FutureResult
[17:02:32.095] - Received FutureResult
[17:02:32.095] - Erased future from FutureRegistry
[17:02:32.095] result() for ClusterFuture ...
[17:02:32.095] - result already collected: FutureResult
[17:02:32.095] result() for ClusterFuture ... done
[17:02:32.095] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:32.095] result() for ClusterFuture ...
[17:02:32.096] - result already collected: FutureResult
[17:02:32.096] result() for ClusterFuture ... done
[17:02:32.096] result() for ClusterFuture ...
[17:02:32.096] - result already collected: FutureResult
[17:02:32.096] result() for ClusterFuture ... done
[17:02:32.097] MultisessionFuture started
[17:02:32.097] - Launch lazy future ... done
[17:02:32.097] run() for ‘MultisessionFuture’ ... done
<environment: 0x55c74b33a8f0> 
<environment: 0x55c74918ced8> 
[17:02:32.100] receiveMessageFromWorker() for ClusterFuture ...
[17:02:32.100] - Validating connection of MultisessionFuture
[17:02:32.100] - received message: FutureResult
[17:02:32.100] - Received FutureResult
[17:02:32.100] - Erased future from FutureRegistry
[17:02:32.100] result() for ClusterFuture ...
[17:02:32.100] - result already collected: FutureResult
[17:02:32.101] result() for ClusterFuture ... done
[17:02:32.101] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:32.101] receiveMessageFromWorker() for ClusterFuture ...
[17:02:32.101] - Validating connection of MultisessionFuture
[17:02:32.101] - received message: FutureResult
[17:02:32.101] - Received FutureResult
[17:02:32.101] - Erased future from FutureRegistry
[17:02:32.102] result() for ClusterFuture ...
[17:02:32.102] - result already collected: FutureResult
[17:02:32.102] result() for ClusterFuture ... done
[17:02:32.102] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:02:32.103] resolve() on environment ...
[17:02:32.103]  recursive: 0
[17:02:32.104]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:02:32.104] signalConditionsASAP(numeric, pos=1) ...
[17:02:32.104] - nx: 4
[17:02:32.104] - relay: TRUE
[17:02:32.104] - stdout: TRUE
[17:02:32.104] - signal: TRUE
[17:02:32.104] - resignal: FALSE
[17:02:32.104] - force: TRUE
[17:02:32.104] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:32.104] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:32.104]  - until=2
[17:02:32.105]  - relaying element #2
[17:02:32.105] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:32.105] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:32.105] signalConditionsASAP(NULL, pos=1) ... done
[17:02:32.105]  length: 3 (resolved future 1)
[17:02:32.105] Future #2
[17:02:32.105] result() for ClusterFuture ...
[17:02:32.105] - result already collected: FutureResult
[17:02:32.105] result() for ClusterFuture ... done
[17:02:32.105] result() for ClusterFuture ...
[17:02:32.105] - result already collected: FutureResult
[17:02:32.105] result() for ClusterFuture ... done
[17:02:32.106] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:32.106] - nx: 4
[17:02:32.106] - relay: TRUE
[17:02:32.106] - stdout: TRUE
[17:02:32.106] - signal: TRUE
[17:02:32.106] - resignal: FALSE
[17:02:32.106] - force: TRUE
[17:02:32.106] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:02:32.106] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:02:32.106]  - until=2
[17:02:32.106]  - relaying element #2
[17:02:32.107] result() for ClusterFuture ...
[17:02:32.107] - result already collected: FutureResult
[17:02:32.107] result() for ClusterFuture ... done
[17:02:32.107] result() for ClusterFuture ...
[17:02:32.107] - result already collected: FutureResult
[17:02:32.107] result() for ClusterFuture ... done
[17:02:32.107] result() for ClusterFuture ...
[17:02:32.107] - result already collected: FutureResult
[17:02:32.107] result() for ClusterFuture ... done
[17:02:32.107] result() for ClusterFuture ...
[17:02:32.107] - result already collected: FutureResult
[17:02:32.108] result() for ClusterFuture ... done
[17:02:32.108] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:32.108] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:32.108] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:32.108]  length: 2 (resolved future 2)
[17:02:32.108] Future #3
[17:02:32.108] result() for ClusterFuture ...
[17:02:32.108] - result already collected: FutureResult
[17:02:32.108] result() for ClusterFuture ... done
[17:02:32.108] result() for ClusterFuture ...
[17:02:32.108] - result already collected: FutureResult
[17:02:32.109] result() for ClusterFuture ... done
[17:02:32.109] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:32.109] - nx: 4
[17:02:32.109] - relay: TRUE
[17:02:32.109] - stdout: TRUE
[17:02:32.109] - signal: TRUE
[17:02:32.109] - resignal: FALSE
[17:02:32.109] - force: TRUE
[17:02:32.109] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:02:32.109] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:02:32.109]  - until=3
[17:02:32.110]  - relaying element #3
[17:02:32.110] result() for ClusterFuture ...
[17:02:32.110] - result already collected: FutureResult
[17:02:32.110] result() for ClusterFuture ... done
[17:02:32.110] result() for ClusterFuture ...
[17:02:32.110] - result already collected: FutureResult
[17:02:32.110] result() for ClusterFuture ... done
[17:02:32.110] result() for ClusterFuture ...
[17:02:32.110] - result already collected: FutureResult
[17:02:32.110] result() for ClusterFuture ... done
[17:02:32.110] result() for ClusterFuture ...
[17:02:32.110] - result already collected: FutureResult
[17:02:32.111] result() for ClusterFuture ... done
[17:02:32.111] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:32.111] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:32.111] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:32.111]  length: 1 (resolved future 3)
[17:02:32.111] Future #4
[17:02:32.111] result() for ClusterFuture ...
[17:02:32.111] - result already collected: FutureResult
[17:02:32.111] result() for ClusterFuture ... done
[17:02:32.111] result() for ClusterFuture ...
[17:02:32.111] - result already collected: FutureResult
[17:02:32.112] result() for ClusterFuture ... done
[17:02:32.112] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:02:32.112] - nx: 4
[17:02:32.112] - relay: TRUE
[17:02:32.112] - stdout: TRUE
[17:02:32.112] - signal: TRUE
[17:02:32.112] - resignal: FALSE
[17:02:32.112] - force: TRUE
[17:02:32.112] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:02:32.112] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:02:32.112]  - until=4
[17:02:32.112]  - relaying element #4
[17:02:32.113] result() for ClusterFuture ...
[17:02:32.113] - result already collected: FutureResult
[17:02:32.113] result() for ClusterFuture ... done
[17:02:32.113] result() for ClusterFuture ...
[17:02:32.113] - result already collected: FutureResult
[17:02:32.113] result() for ClusterFuture ... done
[17:02:32.113] result() for ClusterFuture ...
[17:02:32.113] - result already collected: FutureResult
[17:02:32.113] result() for ClusterFuture ... done
[17:02:32.113] result() for ClusterFuture ...
[17:02:32.113] - result already collected: FutureResult
[17:02:32.113] result() for ClusterFuture ... done
[17:02:32.114] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:32.114] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:32.114] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:02:32.114]  length: 0 (resolved future 4)
[17:02:32.114] Relaying remaining futures
[17:02:32.114] signalConditionsASAP(NULL, pos=0) ...
[17:02:32.114] - nx: 4
[17:02:32.114] - relay: TRUE
[17:02:32.114] - stdout: TRUE
[17:02:32.114] - signal: TRUE
[17:02:32.114] - resignal: FALSE
[17:02:32.114] - force: TRUE
[17:02:32.115] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:32.115] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:02:32.115] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:02:32.115] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:02:32.115] signalConditionsASAP(NULL, pos=0) ... done
[17:02:32.115] resolve() on environment ... DONE
[17:02:32.115] result() for ClusterFuture ...
[17:02:32.115] - result already collected: FutureResult
[17:02:32.115] result() for ClusterFuture ... done
[17:02:32.115] result() for ClusterFuture ...
[17:02:32.116] - result already collected: FutureResult
[17:02:32.116] result() for ClusterFuture ... done
[17:02:32.116] result() for ClusterFuture ...
[17:02:32.116] - result already collected: FutureResult
[17:02:32.116] result() for ClusterFuture ... done
[17:02:32.116] result() for ClusterFuture ...
[17:02:32.116] - result already collected: FutureResult
[17:02:32.116] result() for ClusterFuture ... done
[17:02:32.116] result() for ClusterFuture ...
[17:02:32.116] - result already collected: FutureResult
[17:02:32.116] result() for ClusterFuture ... done
[17:02:32.117] result() for ClusterFuture ...
[17:02:32.117] - result already collected: FutureResult
[17:02:32.117] result() for ClusterFuture ... done
<environment: 0x55c748ce8ce8> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[17:02:32.117] plan(): Setting new future strategy stack:
[17:02:32.117] List of future strategies:
[17:02:32.117] 1. multicore:
[17:02:32.117]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.117]    - tweaked: FALSE
[17:02:32.117]    - call: plan(strategy)
[17:02:32.122] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:02:32.122] getGlobalsAndPackages() ...
[17:02:32.122] Searching for globals...
[17:02:32.123] 
[17:02:32.123] Searching for globals ... DONE
[17:02:32.123] - globals: [0] <none>
[17:02:32.123] getGlobalsAndPackages() ... DONE
[17:02:32.123] run() for ‘Future’ ...
[17:02:32.123] - state: ‘created’
[17:02:32.124] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.127] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.127] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.127]   - Field: ‘label’
[17:02:32.127]   - Field: ‘local’
[17:02:32.128]   - Field: ‘owner’
[17:02:32.128]   - Field: ‘envir’
[17:02:32.128]   - Field: ‘workers’
[17:02:32.128]   - Field: ‘packages’
[17:02:32.128]   - Field: ‘gc’
[17:02:32.128]   - Field: ‘job’
[17:02:32.128]   - Field: ‘conditions’
[17:02:32.128]   - Field: ‘expr’
[17:02:32.128]   - Field: ‘uuid’
[17:02:32.128]   - Field: ‘seed’
[17:02:32.128]   - Field: ‘version’
[17:02:32.129]   - Field: ‘result’
[17:02:32.129]   - Field: ‘asynchronous’
[17:02:32.129]   - Field: ‘calls’
[17:02:32.129]   - Field: ‘globals’
[17:02:32.129]   - Field: ‘stdout’
[17:02:32.129]   - Field: ‘earlySignal’
[17:02:32.129]   - Field: ‘lazy’
[17:02:32.129]   - Field: ‘state’
[17:02:32.129] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.129] - Launch lazy future ...
[17:02:32.130] Packages needed by the future expression (n = 0): <none>
[17:02:32.130] Packages needed by future strategies (n = 0): <none>
[17:02:32.130] {
[17:02:32.130]     {
[17:02:32.130]         {
[17:02:32.130]             ...future.startTime <- base::Sys.time()
[17:02:32.130]             {
[17:02:32.130]                 {
[17:02:32.130]                   {
[17:02:32.130]                     {
[17:02:32.130]                       base::local({
[17:02:32.130]                         has_future <- base::requireNamespace("future", 
[17:02:32.130]                           quietly = TRUE)
[17:02:32.130]                         if (has_future) {
[17:02:32.130]                           ns <- base::getNamespace("future")
[17:02:32.130]                           version <- ns[[".package"]][["version"]]
[17:02:32.130]                           if (is.null(version)) 
[17:02:32.130]                             version <- utils::packageVersion("future")
[17:02:32.130]                         }
[17:02:32.130]                         else {
[17:02:32.130]                           version <- NULL
[17:02:32.130]                         }
[17:02:32.130]                         if (!has_future || version < "1.8.0") {
[17:02:32.130]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.130]                             "", base::R.version$version.string), 
[17:02:32.130]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.130]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.130]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.130]                               "release", "version")], collapse = " "), 
[17:02:32.130]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.130]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.130]                             info)
[17:02:32.130]                           info <- base::paste(info, collapse = "; ")
[17:02:32.130]                           if (!has_future) {
[17:02:32.130]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.130]                               info)
[17:02:32.130]                           }
[17:02:32.130]                           else {
[17:02:32.130]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.130]                               info, version)
[17:02:32.130]                           }
[17:02:32.130]                           base::stop(msg)
[17:02:32.130]                         }
[17:02:32.130]                       })
[17:02:32.130]                     }
[17:02:32.130]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.130]                     base::options(mc.cores = 1L)
[17:02:32.130]                   }
[17:02:32.130]                   ...future.strategy.old <- future::plan("list")
[17:02:32.130]                   options(future.plan = NULL)
[17:02:32.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.130]                 }
[17:02:32.130]                 ...future.workdir <- getwd()
[17:02:32.130]             }
[17:02:32.130]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.130]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.130]         }
[17:02:32.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.130]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.130]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.130]             base::names(...future.oldOptions))
[17:02:32.130]     }
[17:02:32.130]     if (FALSE) {
[17:02:32.130]     }
[17:02:32.130]     else {
[17:02:32.130]         if (TRUE) {
[17:02:32.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.130]                 open = "w")
[17:02:32.130]         }
[17:02:32.130]         else {
[17:02:32.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.130]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.130]         }
[17:02:32.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.130]             base::sink(type = "output", split = FALSE)
[17:02:32.130]             base::close(...future.stdout)
[17:02:32.130]         }, add = TRUE)
[17:02:32.130]     }
[17:02:32.130]     ...future.frame <- base::sys.nframe()
[17:02:32.130]     ...future.conditions <- base::list()
[17:02:32.130]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.130]     if (FALSE) {
[17:02:32.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.130]     }
[17:02:32.130]     ...future.result <- base::tryCatch({
[17:02:32.130]         base::withCallingHandlers({
[17:02:32.130]             ...future.value <- base::withVisible(base::local({
[17:02:32.130]                 withCallingHandlers({
[17:02:32.130]                   2
[17:02:32.130]                 }, immediateCondition = function(cond) {
[17:02:32.130]                   save_rds <- function (object, pathname, ...) 
[17:02:32.130]                   {
[17:02:32.130]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.130]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.130]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.130]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.130]                         fi_tmp[["mtime"]])
[17:02:32.130]                     }
[17:02:32.130]                     tryCatch({
[17:02:32.130]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.130]                     }, error = function(ex) {
[17:02:32.130]                       msg <- conditionMessage(ex)
[17:02:32.130]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.130]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.130]                         fi_tmp[["mtime"]], msg)
[17:02:32.130]                       ex$message <- msg
[17:02:32.130]                       stop(ex)
[17:02:32.130]                     })
[17:02:32.130]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.130]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.130]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.130]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.130]                       fi <- file.info(pathname)
[17:02:32.130]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.130]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.130]                         fi[["size"]], fi[["mtime"]])
[17:02:32.130]                       stop(msg)
[17:02:32.130]                     }
[17:02:32.130]                     invisible(pathname)
[17:02:32.130]                   }
[17:02:32.130]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.130]                     rootPath = tempdir()) 
[17:02:32.130]                   {
[17:02:32.130]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.130]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.130]                       tmpdir = path, fileext = ".rds")
[17:02:32.130]                     save_rds(obj, file)
[17:02:32.130]                   }
[17:02:32.130]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.130]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.130]                   {
[17:02:32.130]                     inherits <- base::inherits
[17:02:32.130]                     invokeRestart <- base::invokeRestart
[17:02:32.130]                     is.null <- base::is.null
[17:02:32.130]                     muffled <- FALSE
[17:02:32.130]                     if (inherits(cond, "message")) {
[17:02:32.130]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.130]                       if (muffled) 
[17:02:32.130]                         invokeRestart("muffleMessage")
[17:02:32.130]                     }
[17:02:32.130]                     else if (inherits(cond, "warning")) {
[17:02:32.130]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.130]                       if (muffled) 
[17:02:32.130]                         invokeRestart("muffleWarning")
[17:02:32.130]                     }
[17:02:32.130]                     else if (inherits(cond, "condition")) {
[17:02:32.130]                       if (!is.null(pattern)) {
[17:02:32.130]                         computeRestarts <- base::computeRestarts
[17:02:32.130]                         grepl <- base::grepl
[17:02:32.130]                         restarts <- computeRestarts(cond)
[17:02:32.130]                         for (restart in restarts) {
[17:02:32.130]                           name <- restart$name
[17:02:32.130]                           if (is.null(name)) 
[17:02:32.130]                             next
[17:02:32.130]                           if (!grepl(pattern, name)) 
[17:02:32.130]                             next
[17:02:32.130]                           invokeRestart(restart)
[17:02:32.130]                           muffled <- TRUE
[17:02:32.130]                           break
[17:02:32.130]                         }
[17:02:32.130]                       }
[17:02:32.130]                     }
[17:02:32.130]                     invisible(muffled)
[17:02:32.130]                   }
[17:02:32.130]                   muffleCondition(cond)
[17:02:32.130]                 })
[17:02:32.130]             }))
[17:02:32.130]             future::FutureResult(value = ...future.value$value, 
[17:02:32.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.130]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.130]                     ...future.globalenv.names))
[17:02:32.130]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.130]         }, condition = base::local({
[17:02:32.130]             c <- base::c
[17:02:32.130]             inherits <- base::inherits
[17:02:32.130]             invokeRestart <- base::invokeRestart
[17:02:32.130]             length <- base::length
[17:02:32.130]             list <- base::list
[17:02:32.130]             seq.int <- base::seq.int
[17:02:32.130]             signalCondition <- base::signalCondition
[17:02:32.130]             sys.calls <- base::sys.calls
[17:02:32.130]             `[[` <- base::`[[`
[17:02:32.130]             `+` <- base::`+`
[17:02:32.130]             `<<-` <- base::`<<-`
[17:02:32.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.130]                   3L)]
[17:02:32.130]             }
[17:02:32.130]             function(cond) {
[17:02:32.130]                 is_error <- inherits(cond, "error")
[17:02:32.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.130]                   NULL)
[17:02:32.130]                 if (is_error) {
[17:02:32.130]                   sessionInformation <- function() {
[17:02:32.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.130]                       search = base::search(), system = base::Sys.info())
[17:02:32.130]                   }
[17:02:32.130]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.130]                     cond$call), session = sessionInformation(), 
[17:02:32.130]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.130]                   signalCondition(cond)
[17:02:32.130]                 }
[17:02:32.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.130]                 "immediateCondition"))) {
[17:02:32.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.130]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.130]                   if (TRUE && !signal) {
[17:02:32.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.130]                     {
[17:02:32.130]                       inherits <- base::inherits
[17:02:32.130]                       invokeRestart <- base::invokeRestart
[17:02:32.130]                       is.null <- base::is.null
[17:02:32.130]                       muffled <- FALSE
[17:02:32.130]                       if (inherits(cond, "message")) {
[17:02:32.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.130]                         if (muffled) 
[17:02:32.130]                           invokeRestart("muffleMessage")
[17:02:32.130]                       }
[17:02:32.130]                       else if (inherits(cond, "warning")) {
[17:02:32.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.130]                         if (muffled) 
[17:02:32.130]                           invokeRestart("muffleWarning")
[17:02:32.130]                       }
[17:02:32.130]                       else if (inherits(cond, "condition")) {
[17:02:32.130]                         if (!is.null(pattern)) {
[17:02:32.130]                           computeRestarts <- base::computeRestarts
[17:02:32.130]                           grepl <- base::grepl
[17:02:32.130]                           restarts <- computeRestarts(cond)
[17:02:32.130]                           for (restart in restarts) {
[17:02:32.130]                             name <- restart$name
[17:02:32.130]                             if (is.null(name)) 
[17:02:32.130]                               next
[17:02:32.130]                             if (!grepl(pattern, name)) 
[17:02:32.130]                               next
[17:02:32.130]                             invokeRestart(restart)
[17:02:32.130]                             muffled <- TRUE
[17:02:32.130]                             break
[17:02:32.130]                           }
[17:02:32.130]                         }
[17:02:32.130]                       }
[17:02:32.130]                       invisible(muffled)
[17:02:32.130]                     }
[17:02:32.130]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.130]                   }
[17:02:32.130]                 }
[17:02:32.130]                 else {
[17:02:32.130]                   if (TRUE) {
[17:02:32.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.130]                     {
[17:02:32.130]                       inherits <- base::inherits
[17:02:32.130]                       invokeRestart <- base::invokeRestart
[17:02:32.130]                       is.null <- base::is.null
[17:02:32.130]                       muffled <- FALSE
[17:02:32.130]                       if (inherits(cond, "message")) {
[17:02:32.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.130]                         if (muffled) 
[17:02:32.130]                           invokeRestart("muffleMessage")
[17:02:32.130]                       }
[17:02:32.130]                       else if (inherits(cond, "warning")) {
[17:02:32.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.130]                         if (muffled) 
[17:02:32.130]                           invokeRestart("muffleWarning")
[17:02:32.130]                       }
[17:02:32.130]                       else if (inherits(cond, "condition")) {
[17:02:32.130]                         if (!is.null(pattern)) {
[17:02:32.130]                           computeRestarts <- base::computeRestarts
[17:02:32.130]                           grepl <- base::grepl
[17:02:32.130]                           restarts <- computeRestarts(cond)
[17:02:32.130]                           for (restart in restarts) {
[17:02:32.130]                             name <- restart$name
[17:02:32.130]                             if (is.null(name)) 
[17:02:32.130]                               next
[17:02:32.130]                             if (!grepl(pattern, name)) 
[17:02:32.130]                               next
[17:02:32.130]                             invokeRestart(restart)
[17:02:32.130]                             muffled <- TRUE
[17:02:32.130]                             break
[17:02:32.130]                           }
[17:02:32.130]                         }
[17:02:32.130]                       }
[17:02:32.130]                       invisible(muffled)
[17:02:32.130]                     }
[17:02:32.130]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.130]                   }
[17:02:32.130]                 }
[17:02:32.130]             }
[17:02:32.130]         }))
[17:02:32.130]     }, error = function(ex) {
[17:02:32.130]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.130]                 ...future.rng), started = ...future.startTime, 
[17:02:32.130]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.130]             version = "1.8"), class = "FutureResult")
[17:02:32.130]     }, finally = {
[17:02:32.130]         if (!identical(...future.workdir, getwd())) 
[17:02:32.130]             setwd(...future.workdir)
[17:02:32.130]         {
[17:02:32.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.130]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.130]             }
[17:02:32.130]             base::options(...future.oldOptions)
[17:02:32.130]             if (.Platform$OS.type == "windows") {
[17:02:32.130]                 old_names <- names(...future.oldEnvVars)
[17:02:32.130]                 envs <- base::Sys.getenv()
[17:02:32.130]                 names <- names(envs)
[17:02:32.130]                 common <- intersect(names, old_names)
[17:02:32.130]                 added <- setdiff(names, old_names)
[17:02:32.130]                 removed <- setdiff(old_names, names)
[17:02:32.130]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.130]                   envs[common]]
[17:02:32.130]                 NAMES <- toupper(changed)
[17:02:32.130]                 args <- list()
[17:02:32.130]                 for (kk in seq_along(NAMES)) {
[17:02:32.130]                   name <- changed[[kk]]
[17:02:32.130]                   NAME <- NAMES[[kk]]
[17:02:32.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.130]                     next
[17:02:32.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.130]                 }
[17:02:32.130]                 NAMES <- toupper(added)
[17:02:32.130]                 for (kk in seq_along(NAMES)) {
[17:02:32.130]                   name <- added[[kk]]
[17:02:32.130]                   NAME <- NAMES[[kk]]
[17:02:32.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.130]                     next
[17:02:32.130]                   args[[name]] <- ""
[17:02:32.130]                 }
[17:02:32.130]                 NAMES <- toupper(removed)
[17:02:32.130]                 for (kk in seq_along(NAMES)) {
[17:02:32.130]                   name <- removed[[kk]]
[17:02:32.130]                   NAME <- NAMES[[kk]]
[17:02:32.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.130]                     next
[17:02:32.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.130]                 }
[17:02:32.130]                 if (length(args) > 0) 
[17:02:32.130]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.130]             }
[17:02:32.130]             else {
[17:02:32.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.130]             }
[17:02:32.130]             {
[17:02:32.130]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.130]                   0L) {
[17:02:32.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.130]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.130]                   base::options(opts)
[17:02:32.130]                 }
[17:02:32.130]                 {
[17:02:32.130]                   {
[17:02:32.130]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.130]                     NULL
[17:02:32.130]                   }
[17:02:32.130]                   options(future.plan = NULL)
[17:02:32.130]                   if (is.na(NA_character_)) 
[17:02:32.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.130]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.130]                     .init = FALSE)
[17:02:32.130]                 }
[17:02:32.130]             }
[17:02:32.130]         }
[17:02:32.130]     })
[17:02:32.130]     if (TRUE) {
[17:02:32.130]         base::sink(type = "output", split = FALSE)
[17:02:32.130]         if (TRUE) {
[17:02:32.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.130]         }
[17:02:32.130]         else {
[17:02:32.130]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.130]         }
[17:02:32.130]         base::close(...future.stdout)
[17:02:32.130]         ...future.stdout <- NULL
[17:02:32.130]     }
[17:02:32.130]     ...future.result$conditions <- ...future.conditions
[17:02:32.130]     ...future.result$finished <- base::Sys.time()
[17:02:32.130]     ...future.result
[17:02:32.130] }
[17:02:32.132] requestCore(): workers = 2
[17:02:32.135] MulticoreFuture started
[17:02:32.135] - Launch lazy future ... done
[17:02:32.135] run() for ‘MulticoreFuture’ ... done
[17:02:32.136] getGlobalsAndPackages() ...
[17:02:32.136] Searching for globals...
[17:02:32.136] plan(): Setting new future strategy stack:
[17:02:32.137] 
[17:02:32.137] Searching for globals ... DONE
[17:02:32.136] List of future strategies:
[17:02:32.136] 1. sequential:
[17:02:32.136]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.136]    - tweaked: FALSE
[17:02:32.136]    - call: NULL
[17:02:32.137] - globals: [0] <none>
[17:02:32.137] getGlobalsAndPackages() ... DONE
[17:02:32.137] plan(): nbrOfWorkers() = 1
[17:02:32.138] run() for ‘Future’ ...
[17:02:32.138] - state: ‘created’
[17:02:32.138] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.139] plan(): Setting new future strategy stack:
[17:02:32.140] List of future strategies:
[17:02:32.140] 1. multicore:
[17:02:32.140]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.140]    - tweaked: FALSE
[17:02:32.140]    - call: plan(strategy)
[17:02:32.144] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.145] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.145] plan(): nbrOfWorkers() = 2
[17:02:32.145]   - Field: ‘label’
[17:02:32.145]   - Field: ‘local’
[17:02:32.145]   - Field: ‘owner’
[17:02:32.145]   - Field: ‘envir’
[17:02:32.146]   - Field: ‘workers’
[17:02:32.146]   - Field: ‘packages’
[17:02:32.146]   - Field: ‘gc’
[17:02:32.146]   - Field: ‘job’
[17:02:32.146]   - Field: ‘conditions’
[17:02:32.146]   - Field: ‘expr’
[17:02:32.146]   - Field: ‘uuid’
[17:02:32.147]   - Field: ‘seed’
[17:02:32.147]   - Field: ‘version’
[17:02:32.147]   - Field: ‘result’
[17:02:32.147]   - Field: ‘asynchronous’
[17:02:32.147]   - Field: ‘calls’
[17:02:32.147]   - Field: ‘globals’
[17:02:32.147]   - Field: ‘stdout’
[17:02:32.148]   - Field: ‘earlySignal’
[17:02:32.148]   - Field: ‘lazy’
[17:02:32.148]   - Field: ‘state’
[17:02:32.148] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.148] - Launch lazy future ...
[17:02:32.149] Packages needed by the future expression (n = 0): <none>
[17:02:32.149] Packages needed by future strategies (n = 0): <none>
[17:02:32.150] {
[17:02:32.150]     {
[17:02:32.150]         {
[17:02:32.150]             ...future.startTime <- base::Sys.time()
[17:02:32.150]             {
[17:02:32.150]                 {
[17:02:32.150]                   {
[17:02:32.150]                     {
[17:02:32.150]                       base::local({
[17:02:32.150]                         has_future <- base::requireNamespace("future", 
[17:02:32.150]                           quietly = TRUE)
[17:02:32.150]                         if (has_future) {
[17:02:32.150]                           ns <- base::getNamespace("future")
[17:02:32.150]                           version <- ns[[".package"]][["version"]]
[17:02:32.150]                           if (is.null(version)) 
[17:02:32.150]                             version <- utils::packageVersion("future")
[17:02:32.150]                         }
[17:02:32.150]                         else {
[17:02:32.150]                           version <- NULL
[17:02:32.150]                         }
[17:02:32.150]                         if (!has_future || version < "1.8.0") {
[17:02:32.150]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.150]                             "", base::R.version$version.string), 
[17:02:32.150]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.150]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.150]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.150]                               "release", "version")], collapse = " "), 
[17:02:32.150]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.150]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.150]                             info)
[17:02:32.150]                           info <- base::paste(info, collapse = "; ")
[17:02:32.150]                           if (!has_future) {
[17:02:32.150]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.150]                               info)
[17:02:32.150]                           }
[17:02:32.150]                           else {
[17:02:32.150]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.150]                               info, version)
[17:02:32.150]                           }
[17:02:32.150]                           base::stop(msg)
[17:02:32.150]                         }
[17:02:32.150]                       })
[17:02:32.150]                     }
[17:02:32.150]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.150]                     base::options(mc.cores = 1L)
[17:02:32.150]                   }
[17:02:32.150]                   ...future.strategy.old <- future::plan("list")
[17:02:32.150]                   options(future.plan = NULL)
[17:02:32.150]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.150]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.150]                 }
[17:02:32.150]                 ...future.workdir <- getwd()
[17:02:32.150]             }
[17:02:32.150]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.150]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.150]         }
[17:02:32.150]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.150]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.150]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.150]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.150]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.150]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.150]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.150]             base::names(...future.oldOptions))
[17:02:32.150]     }
[17:02:32.150]     if (FALSE) {
[17:02:32.150]     }
[17:02:32.150]     else {
[17:02:32.150]         if (TRUE) {
[17:02:32.150]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.150]                 open = "w")
[17:02:32.150]         }
[17:02:32.150]         else {
[17:02:32.150]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.150]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.150]         }
[17:02:32.150]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.150]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.150]             base::sink(type = "output", split = FALSE)
[17:02:32.150]             base::close(...future.stdout)
[17:02:32.150]         }, add = TRUE)
[17:02:32.150]     }
[17:02:32.150]     ...future.frame <- base::sys.nframe()
[17:02:32.150]     ...future.conditions <- base::list()
[17:02:32.150]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.150]     if (FALSE) {
[17:02:32.150]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.150]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.150]     }
[17:02:32.150]     ...future.result <- base::tryCatch({
[17:02:32.150]         base::withCallingHandlers({
[17:02:32.150]             ...future.value <- base::withVisible(base::local({
[17:02:32.150]                 withCallingHandlers({
[17:02:32.150]                   NULL
[17:02:32.150]                 }, immediateCondition = function(cond) {
[17:02:32.150]                   save_rds <- function (object, pathname, ...) 
[17:02:32.150]                   {
[17:02:32.150]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.150]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.150]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.150]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.150]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.150]                         fi_tmp[["mtime"]])
[17:02:32.150]                     }
[17:02:32.150]                     tryCatch({
[17:02:32.150]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.150]                     }, error = function(ex) {
[17:02:32.150]                       msg <- conditionMessage(ex)
[17:02:32.150]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.150]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.150]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.150]                         fi_tmp[["mtime"]], msg)
[17:02:32.150]                       ex$message <- msg
[17:02:32.150]                       stop(ex)
[17:02:32.150]                     })
[17:02:32.150]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.150]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.150]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.150]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.150]                       fi <- file.info(pathname)
[17:02:32.150]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.150]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.150]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.150]                         fi[["size"]], fi[["mtime"]])
[17:02:32.150]                       stop(msg)
[17:02:32.150]                     }
[17:02:32.150]                     invisible(pathname)
[17:02:32.150]                   }
[17:02:32.150]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.150]                     rootPath = tempdir()) 
[17:02:32.150]                   {
[17:02:32.150]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.150]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.150]                       tmpdir = path, fileext = ".rds")
[17:02:32.150]                     save_rds(obj, file)
[17:02:32.150]                   }
[17:02:32.150]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.150]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.150]                   {
[17:02:32.150]                     inherits <- base::inherits
[17:02:32.150]                     invokeRestart <- base::invokeRestart
[17:02:32.150]                     is.null <- base::is.null
[17:02:32.150]                     muffled <- FALSE
[17:02:32.150]                     if (inherits(cond, "message")) {
[17:02:32.150]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.150]                       if (muffled) 
[17:02:32.150]                         invokeRestart("muffleMessage")
[17:02:32.150]                     }
[17:02:32.150]                     else if (inherits(cond, "warning")) {
[17:02:32.150]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.150]                       if (muffled) 
[17:02:32.150]                         invokeRestart("muffleWarning")
[17:02:32.150]                     }
[17:02:32.150]                     else if (inherits(cond, "condition")) {
[17:02:32.150]                       if (!is.null(pattern)) {
[17:02:32.150]                         computeRestarts <- base::computeRestarts
[17:02:32.150]                         grepl <- base::grepl
[17:02:32.150]                         restarts <- computeRestarts(cond)
[17:02:32.150]                         for (restart in restarts) {
[17:02:32.150]                           name <- restart$name
[17:02:32.150]                           if (is.null(name)) 
[17:02:32.150]                             next
[17:02:32.150]                           if (!grepl(pattern, name)) 
[17:02:32.150]                             next
[17:02:32.150]                           invokeRestart(restart)
[17:02:32.150]                           muffled <- TRUE
[17:02:32.150]                           break
[17:02:32.150]                         }
[17:02:32.150]                       }
[17:02:32.150]                     }
[17:02:32.150]                     invisible(muffled)
[17:02:32.150]                   }
[17:02:32.150]                   muffleCondition(cond)
[17:02:32.150]                 })
[17:02:32.150]             }))
[17:02:32.150]             future::FutureResult(value = ...future.value$value, 
[17:02:32.150]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.150]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.150]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.150]                     ...future.globalenv.names))
[17:02:32.150]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.150]         }, condition = base::local({
[17:02:32.150]             c <- base::c
[17:02:32.150]             inherits <- base::inherits
[17:02:32.150]             invokeRestart <- base::invokeRestart
[17:02:32.150]             length <- base::length
[17:02:32.150]             list <- base::list
[17:02:32.150]             seq.int <- base::seq.int
[17:02:32.150]             signalCondition <- base::signalCondition
[17:02:32.150]             sys.calls <- base::sys.calls
[17:02:32.150]             `[[` <- base::`[[`
[17:02:32.150]             `+` <- base::`+`
[17:02:32.150]             `<<-` <- base::`<<-`
[17:02:32.150]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.150]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.150]                   3L)]
[17:02:32.150]             }
[17:02:32.150]             function(cond) {
[17:02:32.150]                 is_error <- inherits(cond, "error")
[17:02:32.150]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.150]                   NULL)
[17:02:32.150]                 if (is_error) {
[17:02:32.150]                   sessionInformation <- function() {
[17:02:32.150]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.150]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.150]                       search = base::search(), system = base::Sys.info())
[17:02:32.150]                   }
[17:02:32.150]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.150]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.150]                     cond$call), session = sessionInformation(), 
[17:02:32.150]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.150]                   signalCondition(cond)
[17:02:32.150]                 }
[17:02:32.150]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.150]                 "immediateCondition"))) {
[17:02:32.150]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.150]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.150]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.150]                   if (TRUE && !signal) {
[17:02:32.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.150]                     {
[17:02:32.150]                       inherits <- base::inherits
[17:02:32.150]                       invokeRestart <- base::invokeRestart
[17:02:32.150]                       is.null <- base::is.null
[17:02:32.150]                       muffled <- FALSE
[17:02:32.150]                       if (inherits(cond, "message")) {
[17:02:32.150]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.150]                         if (muffled) 
[17:02:32.150]                           invokeRestart("muffleMessage")
[17:02:32.150]                       }
[17:02:32.150]                       else if (inherits(cond, "warning")) {
[17:02:32.150]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.150]                         if (muffled) 
[17:02:32.150]                           invokeRestart("muffleWarning")
[17:02:32.150]                       }
[17:02:32.150]                       else if (inherits(cond, "condition")) {
[17:02:32.150]                         if (!is.null(pattern)) {
[17:02:32.150]                           computeRestarts <- base::computeRestarts
[17:02:32.150]                           grepl <- base::grepl
[17:02:32.150]                           restarts <- computeRestarts(cond)
[17:02:32.150]                           for (restart in restarts) {
[17:02:32.150]                             name <- restart$name
[17:02:32.150]                             if (is.null(name)) 
[17:02:32.150]                               next
[17:02:32.150]                             if (!grepl(pattern, name)) 
[17:02:32.150]                               next
[17:02:32.150]                             invokeRestart(restart)
[17:02:32.150]                             muffled <- TRUE
[17:02:32.150]                             break
[17:02:32.150]                           }
[17:02:32.150]                         }
[17:02:32.150]                       }
[17:02:32.150]                       invisible(muffled)
[17:02:32.150]                     }
[17:02:32.150]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.150]                   }
[17:02:32.150]                 }
[17:02:32.150]                 else {
[17:02:32.150]                   if (TRUE) {
[17:02:32.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.150]                     {
[17:02:32.150]                       inherits <- base::inherits
[17:02:32.150]                       invokeRestart <- base::invokeRestart
[17:02:32.150]                       is.null <- base::is.null
[17:02:32.150]                       muffled <- FALSE
[17:02:32.150]                       if (inherits(cond, "message")) {
[17:02:32.150]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.150]                         if (muffled) 
[17:02:32.150]                           invokeRestart("muffleMessage")
[17:02:32.150]                       }
[17:02:32.150]                       else if (inherits(cond, "warning")) {
[17:02:32.150]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.150]                         if (muffled) 
[17:02:32.150]                           invokeRestart("muffleWarning")
[17:02:32.150]                       }
[17:02:32.150]                       else if (inherits(cond, "condition")) {
[17:02:32.150]                         if (!is.null(pattern)) {
[17:02:32.150]                           computeRestarts <- base::computeRestarts
[17:02:32.150]                           grepl <- base::grepl
[17:02:32.150]                           restarts <- computeRestarts(cond)
[17:02:32.150]                           for (restart in restarts) {
[17:02:32.150]                             name <- restart$name
[17:02:32.150]                             if (is.null(name)) 
[17:02:32.150]                               next
[17:02:32.150]                             if (!grepl(pattern, name)) 
[17:02:32.150]                               next
[17:02:32.150]                             invokeRestart(restart)
[17:02:32.150]                             muffled <- TRUE
[17:02:32.150]                             break
[17:02:32.150]                           }
[17:02:32.150]                         }
[17:02:32.150]                       }
[17:02:32.150]                       invisible(muffled)
[17:02:32.150]                     }
[17:02:32.150]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.150]                   }
[17:02:32.150]                 }
[17:02:32.150]             }
[17:02:32.150]         }))
[17:02:32.150]     }, error = function(ex) {
[17:02:32.150]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.150]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.150]                 ...future.rng), started = ...future.startTime, 
[17:02:32.150]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.150]             version = "1.8"), class = "FutureResult")
[17:02:32.150]     }, finally = {
[17:02:32.150]         if (!identical(...future.workdir, getwd())) 
[17:02:32.150]             setwd(...future.workdir)
[17:02:32.150]         {
[17:02:32.150]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.150]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.150]             }
[17:02:32.150]             base::options(...future.oldOptions)
[17:02:32.150]             if (.Platform$OS.type == "windows") {
[17:02:32.150]                 old_names <- names(...future.oldEnvVars)
[17:02:32.150]                 envs <- base::Sys.getenv()
[17:02:32.150]                 names <- names(envs)
[17:02:32.150]                 common <- intersect(names, old_names)
[17:02:32.150]                 added <- setdiff(names, old_names)
[17:02:32.150]                 removed <- setdiff(old_names, names)
[17:02:32.150]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.150]                   envs[common]]
[17:02:32.150]                 NAMES <- toupper(changed)
[17:02:32.150]                 args <- list()
[17:02:32.150]                 for (kk in seq_along(NAMES)) {
[17:02:32.150]                   name <- changed[[kk]]
[17:02:32.150]                   NAME <- NAMES[[kk]]
[17:02:32.150]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.150]                     next
[17:02:32.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.150]                 }
[17:02:32.150]                 NAMES <- toupper(added)
[17:02:32.150]                 for (kk in seq_along(NAMES)) {
[17:02:32.150]                   name <- added[[kk]]
[17:02:32.150]                   NAME <- NAMES[[kk]]
[17:02:32.150]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.150]                     next
[17:02:32.150]                   args[[name]] <- ""
[17:02:32.150]                 }
[17:02:32.150]                 NAMES <- toupper(removed)
[17:02:32.150]                 for (kk in seq_along(NAMES)) {
[17:02:32.150]                   name <- removed[[kk]]
[17:02:32.150]                   NAME <- NAMES[[kk]]
[17:02:32.150]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.150]                     next
[17:02:32.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.150]                 }
[17:02:32.150]                 if (length(args) > 0) 
[17:02:32.150]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.150]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.150]             }
[17:02:32.150]             else {
[17:02:32.150]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.150]             }
[17:02:32.150]             {
[17:02:32.150]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.150]                   0L) {
[17:02:32.150]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.150]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.150]                   base::options(opts)
[17:02:32.150]                 }
[17:02:32.150]                 {
[17:02:32.150]                   {
[17:02:32.150]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.150]                     NULL
[17:02:32.150]                   }
[17:02:32.150]                   options(future.plan = NULL)
[17:02:32.150]                   if (is.na(NA_character_)) 
[17:02:32.150]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.150]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.150]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.150]                     .init = FALSE)
[17:02:32.150]                 }
[17:02:32.150]             }
[17:02:32.150]         }
[17:02:32.150]     })
[17:02:32.150]     if (TRUE) {
[17:02:32.150]         base::sink(type = "output", split = FALSE)
[17:02:32.150]         if (TRUE) {
[17:02:32.150]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.150]         }
[17:02:32.150]         else {
[17:02:32.150]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.150]         }
[17:02:32.150]         base::close(...future.stdout)
[17:02:32.150]         ...future.stdout <- NULL
[17:02:32.150]     }
[17:02:32.150]     ...future.result$conditions <- ...future.conditions
[17:02:32.150]     ...future.result$finished <- base::Sys.time()
[17:02:32.150]     ...future.result
[17:02:32.150] }
[17:02:32.154] requestCore(): workers = 2
[17:02:32.158] MulticoreFuture started
[17:02:32.158] - Launch lazy future ... done
[17:02:32.159] run() for ‘MulticoreFuture’ ... done
[17:02:32.159] plan(): Setting new future strategy stack:
[17:02:32.160] getGlobalsAndPackages() ...
[17:02:32.159] List of future strategies:
[17:02:32.159] 1. sequential:
[17:02:32.159]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.159]    - tweaked: FALSE
[17:02:32.159]    - call: NULL
[17:02:32.160] Searching for globals...
[17:02:32.160] plan(): nbrOfWorkers() = 1
[17:02:32.162] - globals found: [1] ‘{’
[17:02:32.162] Searching for globals ... DONE
[17:02:32.162] plan(): Setting new future strategy stack:
[17:02:32.163] Resolving globals: FALSE
[17:02:32.163] List of future strategies:
[17:02:32.163] 1. multicore:
[17:02:32.163]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.163]    - tweaked: FALSE
[17:02:32.163]    - call: plan(strategy)
[17:02:32.163] 
[17:02:32.163] 
[17:02:32.164] getGlobalsAndPackages() ... DONE
[17:02:32.164] run() for ‘Future’ ...
[17:02:32.164] - state: ‘created’
[17:02:32.165] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.168] plan(): nbrOfWorkers() = 2
[17:02:32.170] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.170] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.170]   - Field: ‘label’
[17:02:32.170]   - Field: ‘local’
[17:02:32.170]   - Field: ‘owner’
[17:02:32.170]   - Field: ‘envir’
[17:02:32.170]   - Field: ‘workers’
[17:02:32.171]   - Field: ‘packages’
[17:02:32.171]   - Field: ‘gc’
[17:02:32.171]   - Field: ‘job’
[17:02:32.171]   - Field: ‘conditions’
[17:02:32.171]   - Field: ‘expr’
[17:02:32.171]   - Field: ‘uuid’
[17:02:32.171]   - Field: ‘seed’
[17:02:32.172]   - Field: ‘version’
[17:02:32.172]   - Field: ‘result’
[17:02:32.172]   - Field: ‘asynchronous’
[17:02:32.172]   - Field: ‘calls’
[17:02:32.172]   - Field: ‘globals’
[17:02:32.172]   - Field: ‘stdout’
[17:02:32.172]   - Field: ‘earlySignal’
[17:02:32.173]   - Field: ‘lazy’
[17:02:32.173]   - Field: ‘state’
[17:02:32.173] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.173] - Launch lazy future ...
[17:02:32.173] Packages needed by the future expression (n = 0): <none>
[17:02:32.174] Packages needed by future strategies (n = 0): <none>
[17:02:32.174] {
[17:02:32.174]     {
[17:02:32.174]         {
[17:02:32.174]             ...future.startTime <- base::Sys.time()
[17:02:32.174]             {
[17:02:32.174]                 {
[17:02:32.174]                   {
[17:02:32.174]                     {
[17:02:32.174]                       base::local({
[17:02:32.174]                         has_future <- base::requireNamespace("future", 
[17:02:32.174]                           quietly = TRUE)
[17:02:32.174]                         if (has_future) {
[17:02:32.174]                           ns <- base::getNamespace("future")
[17:02:32.174]                           version <- ns[[".package"]][["version"]]
[17:02:32.174]                           if (is.null(version)) 
[17:02:32.174]                             version <- utils::packageVersion("future")
[17:02:32.174]                         }
[17:02:32.174]                         else {
[17:02:32.174]                           version <- NULL
[17:02:32.174]                         }
[17:02:32.174]                         if (!has_future || version < "1.8.0") {
[17:02:32.174]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.174]                             "", base::R.version$version.string), 
[17:02:32.174]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.174]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.174]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.174]                               "release", "version")], collapse = " "), 
[17:02:32.174]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.174]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.174]                             info)
[17:02:32.174]                           info <- base::paste(info, collapse = "; ")
[17:02:32.174]                           if (!has_future) {
[17:02:32.174]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.174]                               info)
[17:02:32.174]                           }
[17:02:32.174]                           else {
[17:02:32.174]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.174]                               info, version)
[17:02:32.174]                           }
[17:02:32.174]                           base::stop(msg)
[17:02:32.174]                         }
[17:02:32.174]                       })
[17:02:32.174]                     }
[17:02:32.174]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.174]                     base::options(mc.cores = 1L)
[17:02:32.174]                   }
[17:02:32.174]                   ...future.strategy.old <- future::plan("list")
[17:02:32.174]                   options(future.plan = NULL)
[17:02:32.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.174]                 }
[17:02:32.174]                 ...future.workdir <- getwd()
[17:02:32.174]             }
[17:02:32.174]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.174]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.174]         }
[17:02:32.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.174]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.174]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.174]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.174]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.174]             base::names(...future.oldOptions))
[17:02:32.174]     }
[17:02:32.174]     if (FALSE) {
[17:02:32.174]     }
[17:02:32.174]     else {
[17:02:32.174]         if (TRUE) {
[17:02:32.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.174]                 open = "w")
[17:02:32.174]         }
[17:02:32.174]         else {
[17:02:32.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.174]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.174]         }
[17:02:32.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.174]             base::sink(type = "output", split = FALSE)
[17:02:32.174]             base::close(...future.stdout)
[17:02:32.174]         }, add = TRUE)
[17:02:32.174]     }
[17:02:32.174]     ...future.frame <- base::sys.nframe()
[17:02:32.174]     ...future.conditions <- base::list()
[17:02:32.174]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.174]     if (FALSE) {
[17:02:32.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.174]     }
[17:02:32.174]     ...future.result <- base::tryCatch({
[17:02:32.174]         base::withCallingHandlers({
[17:02:32.174]             ...future.value <- base::withVisible(base::local({
[17:02:32.174]                 withCallingHandlers({
[17:02:32.174]                   {
[17:02:32.174]                     4
[17:02:32.174]                   }
[17:02:32.174]                 }, immediateCondition = function(cond) {
[17:02:32.174]                   save_rds <- function (object, pathname, ...) 
[17:02:32.174]                   {
[17:02:32.174]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.174]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.174]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.174]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.174]                         fi_tmp[["mtime"]])
[17:02:32.174]                     }
[17:02:32.174]                     tryCatch({
[17:02:32.174]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.174]                     }, error = function(ex) {
[17:02:32.174]                       msg <- conditionMessage(ex)
[17:02:32.174]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.174]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.174]                         fi_tmp[["mtime"]], msg)
[17:02:32.174]                       ex$message <- msg
[17:02:32.174]                       stop(ex)
[17:02:32.174]                     })
[17:02:32.174]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.174]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.174]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.174]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.174]                       fi <- file.info(pathname)
[17:02:32.174]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.174]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.174]                         fi[["size"]], fi[["mtime"]])
[17:02:32.174]                       stop(msg)
[17:02:32.174]                     }
[17:02:32.174]                     invisible(pathname)
[17:02:32.174]                   }
[17:02:32.174]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.174]                     rootPath = tempdir()) 
[17:02:32.174]                   {
[17:02:32.174]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.174]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.174]                       tmpdir = path, fileext = ".rds")
[17:02:32.174]                     save_rds(obj, file)
[17:02:32.174]                   }
[17:02:32.174]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.174]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.174]                   {
[17:02:32.174]                     inherits <- base::inherits
[17:02:32.174]                     invokeRestart <- base::invokeRestart
[17:02:32.174]                     is.null <- base::is.null
[17:02:32.174]                     muffled <- FALSE
[17:02:32.174]                     if (inherits(cond, "message")) {
[17:02:32.174]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.174]                       if (muffled) 
[17:02:32.174]                         invokeRestart("muffleMessage")
[17:02:32.174]                     }
[17:02:32.174]                     else if (inherits(cond, "warning")) {
[17:02:32.174]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.174]                       if (muffled) 
[17:02:32.174]                         invokeRestart("muffleWarning")
[17:02:32.174]                     }
[17:02:32.174]                     else if (inherits(cond, "condition")) {
[17:02:32.174]                       if (!is.null(pattern)) {
[17:02:32.174]                         computeRestarts <- base::computeRestarts
[17:02:32.174]                         grepl <- base::grepl
[17:02:32.174]                         restarts <- computeRestarts(cond)
[17:02:32.174]                         for (restart in restarts) {
[17:02:32.174]                           name <- restart$name
[17:02:32.174]                           if (is.null(name)) 
[17:02:32.174]                             next
[17:02:32.174]                           if (!grepl(pattern, name)) 
[17:02:32.174]                             next
[17:02:32.174]                           invokeRestart(restart)
[17:02:32.174]                           muffled <- TRUE
[17:02:32.174]                           break
[17:02:32.174]                         }
[17:02:32.174]                       }
[17:02:32.174]                     }
[17:02:32.174]                     invisible(muffled)
[17:02:32.174]                   }
[17:02:32.174]                   muffleCondition(cond)
[17:02:32.174]                 })
[17:02:32.174]             }))
[17:02:32.174]             future::FutureResult(value = ...future.value$value, 
[17:02:32.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.174]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.174]                     ...future.globalenv.names))
[17:02:32.174]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.174]         }, condition = base::local({
[17:02:32.174]             c <- base::c
[17:02:32.174]             inherits <- base::inherits
[17:02:32.174]             invokeRestart <- base::invokeRestart
[17:02:32.174]             length <- base::length
[17:02:32.174]             list <- base::list
[17:02:32.174]             seq.int <- base::seq.int
[17:02:32.174]             signalCondition <- base::signalCondition
[17:02:32.174]             sys.calls <- base::sys.calls
[17:02:32.174]             `[[` <- base::`[[`
[17:02:32.174]             `+` <- base::`+`
[17:02:32.174]             `<<-` <- base::`<<-`
[17:02:32.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.174]                   3L)]
[17:02:32.174]             }
[17:02:32.174]             function(cond) {
[17:02:32.174]                 is_error <- inherits(cond, "error")
[17:02:32.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.174]                   NULL)
[17:02:32.174]                 if (is_error) {
[17:02:32.174]                   sessionInformation <- function() {
[17:02:32.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.174]                       search = base::search(), system = base::Sys.info())
[17:02:32.174]                   }
[17:02:32.174]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.174]                     cond$call), session = sessionInformation(), 
[17:02:32.174]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.174]                   signalCondition(cond)
[17:02:32.174]                 }
[17:02:32.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.174]                 "immediateCondition"))) {
[17:02:32.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.174]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.174]                   if (TRUE && !signal) {
[17:02:32.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.174]                     {
[17:02:32.174]                       inherits <- base::inherits
[17:02:32.174]                       invokeRestart <- base::invokeRestart
[17:02:32.174]                       is.null <- base::is.null
[17:02:32.174]                       muffled <- FALSE
[17:02:32.174]                       if (inherits(cond, "message")) {
[17:02:32.174]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.174]                         if (muffled) 
[17:02:32.174]                           invokeRestart("muffleMessage")
[17:02:32.174]                       }
[17:02:32.174]                       else if (inherits(cond, "warning")) {
[17:02:32.174]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.174]                         if (muffled) 
[17:02:32.174]                           invokeRestart("muffleWarning")
[17:02:32.174]                       }
[17:02:32.174]                       else if (inherits(cond, "condition")) {
[17:02:32.174]                         if (!is.null(pattern)) {
[17:02:32.174]                           computeRestarts <- base::computeRestarts
[17:02:32.174]                           grepl <- base::grepl
[17:02:32.174]                           restarts <- computeRestarts(cond)
[17:02:32.174]                           for (restart in restarts) {
[17:02:32.174]                             name <- restart$name
[17:02:32.174]                             if (is.null(name)) 
[17:02:32.174]                               next
[17:02:32.174]                             if (!grepl(pattern, name)) 
[17:02:32.174]                               next
[17:02:32.174]                             invokeRestart(restart)
[17:02:32.174]                             muffled <- TRUE
[17:02:32.174]                             break
[17:02:32.174]                           }
[17:02:32.174]                         }
[17:02:32.174]                       }
[17:02:32.174]                       invisible(muffled)
[17:02:32.174]                     }
[17:02:32.174]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.174]                   }
[17:02:32.174]                 }
[17:02:32.174]                 else {
[17:02:32.174]                   if (TRUE) {
[17:02:32.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.174]                     {
[17:02:32.174]                       inherits <- base::inherits
[17:02:32.174]                       invokeRestart <- base::invokeRestart
[17:02:32.174]                       is.null <- base::is.null
[17:02:32.174]                       muffled <- FALSE
[17:02:32.174]                       if (inherits(cond, "message")) {
[17:02:32.174]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.174]                         if (muffled) 
[17:02:32.174]                           invokeRestart("muffleMessage")
[17:02:32.174]                       }
[17:02:32.174]                       else if (inherits(cond, "warning")) {
[17:02:32.174]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.174]                         if (muffled) 
[17:02:32.174]                           invokeRestart("muffleWarning")
[17:02:32.174]                       }
[17:02:32.174]                       else if (inherits(cond, "condition")) {
[17:02:32.174]                         if (!is.null(pattern)) {
[17:02:32.174]                           computeRestarts <- base::computeRestarts
[17:02:32.174]                           grepl <- base::grepl
[17:02:32.174]                           restarts <- computeRestarts(cond)
[17:02:32.174]                           for (restart in restarts) {
[17:02:32.174]                             name <- restart$name
[17:02:32.174]                             if (is.null(name)) 
[17:02:32.174]                               next
[17:02:32.174]                             if (!grepl(pattern, name)) 
[17:02:32.174]                               next
[17:02:32.174]                             invokeRestart(restart)
[17:02:32.174]                             muffled <- TRUE
[17:02:32.174]                             break
[17:02:32.174]                           }
[17:02:32.174]                         }
[17:02:32.174]                       }
[17:02:32.174]                       invisible(muffled)
[17:02:32.174]                     }
[17:02:32.174]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.174]                   }
[17:02:32.174]                 }
[17:02:32.174]             }
[17:02:32.174]         }))
[17:02:32.174]     }, error = function(ex) {
[17:02:32.174]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.174]                 ...future.rng), started = ...future.startTime, 
[17:02:32.174]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.174]             version = "1.8"), class = "FutureResult")
[17:02:32.174]     }, finally = {
[17:02:32.174]         if (!identical(...future.workdir, getwd())) 
[17:02:32.174]             setwd(...future.workdir)
[17:02:32.174]         {
[17:02:32.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.174]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.174]             }
[17:02:32.174]             base::options(...future.oldOptions)
[17:02:32.174]             if (.Platform$OS.type == "windows") {
[17:02:32.174]                 old_names <- names(...future.oldEnvVars)
[17:02:32.174]                 envs <- base::Sys.getenv()
[17:02:32.174]                 names <- names(envs)
[17:02:32.174]                 common <- intersect(names, old_names)
[17:02:32.174]                 added <- setdiff(names, old_names)
[17:02:32.174]                 removed <- setdiff(old_names, names)
[17:02:32.174]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.174]                   envs[common]]
[17:02:32.174]                 NAMES <- toupper(changed)
[17:02:32.174]                 args <- list()
[17:02:32.174]                 for (kk in seq_along(NAMES)) {
[17:02:32.174]                   name <- changed[[kk]]
[17:02:32.174]                   NAME <- NAMES[[kk]]
[17:02:32.174]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.174]                     next
[17:02:32.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.174]                 }
[17:02:32.174]                 NAMES <- toupper(added)
[17:02:32.174]                 for (kk in seq_along(NAMES)) {
[17:02:32.174]                   name <- added[[kk]]
[17:02:32.174]                   NAME <- NAMES[[kk]]
[17:02:32.174]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.174]                     next
[17:02:32.174]                   args[[name]] <- ""
[17:02:32.174]                 }
[17:02:32.174]                 NAMES <- toupper(removed)
[17:02:32.174]                 for (kk in seq_along(NAMES)) {
[17:02:32.174]                   name <- removed[[kk]]
[17:02:32.174]                   NAME <- NAMES[[kk]]
[17:02:32.174]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.174]                     next
[17:02:32.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.174]                 }
[17:02:32.174]                 if (length(args) > 0) 
[17:02:32.174]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.174]             }
[17:02:32.174]             else {
[17:02:32.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.174]             }
[17:02:32.174]             {
[17:02:32.174]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.174]                   0L) {
[17:02:32.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.174]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.174]                   base::options(opts)
[17:02:32.174]                 }
[17:02:32.174]                 {
[17:02:32.174]                   {
[17:02:32.174]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.174]                     NULL
[17:02:32.174]                   }
[17:02:32.174]                   options(future.plan = NULL)
[17:02:32.174]                   if (is.na(NA_character_)) 
[17:02:32.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.174]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.174]                     .init = FALSE)
[17:02:32.174]                 }
[17:02:32.174]             }
[17:02:32.174]         }
[17:02:32.174]     })
[17:02:32.174]     if (TRUE) {
[17:02:32.174]         base::sink(type = "output", split = FALSE)
[17:02:32.174]         if (TRUE) {
[17:02:32.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.174]         }
[17:02:32.174]         else {
[17:02:32.174]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.174]         }
[17:02:32.174]         base::close(...future.stdout)
[17:02:32.174]         ...future.stdout <- NULL
[17:02:32.174]     }
[17:02:32.174]     ...future.result$conditions <- ...future.conditions
[17:02:32.174]     ...future.result$finished <- base::Sys.time()
[17:02:32.174]     ...future.result
[17:02:32.174] }
[17:02:32.178] requestCore(): workers = 2
[17:02:32.178] Poll #1 (0): usedCores() = 2, workers = 2
[17:02:32.189] result() for MulticoreFuture ...
[17:02:32.190] result() for MulticoreFuture ...
[17:02:32.190] result() for MulticoreFuture ... done
[17:02:32.190] result() for MulticoreFuture ... done
[17:02:32.190] result() for MulticoreFuture ...
[17:02:32.190] result() for MulticoreFuture ... done
[17:02:32.193] MulticoreFuture started
[17:02:32.193] - Launch lazy future ... done
[17:02:32.194] run() for ‘MulticoreFuture’ ... done
[17:02:32.194] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55c74a8f4728> 
[17:02:32.195] List of future strategies:
[17:02:32.195] 1. sequential:
[17:02:32.195]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.195]    - tweaked: FALSE
[17:02:32.195]    - call: NULL
[17:02:32.196] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55c74b4f0998> 
[17:02:32.199] plan(): Setting new future strategy stack:
[17:02:32.199] List of future strategies:
[17:02:32.199] 1. multicore:
[17:02:32.199]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.199]    - tweaked: FALSE
[17:02:32.199]    - call: plan(strategy)
[17:02:32.205] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:32.207] resolve() on list environment ...
[17:02:32.208]  recursive: 0
[17:02:32.209]  length: 6
[17:02:32.209]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:32.209] signalConditionsASAP(numeric, pos=1) ...
[17:02:32.209] - nx: 6
[17:02:32.210] - relay: TRUE
[17:02:32.210] - stdout: TRUE
[17:02:32.210] - signal: TRUE
[17:02:32.210] - resignal: FALSE
[17:02:32.210] - force: TRUE
[17:02:32.210] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.210] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.210]  - until=2
[17:02:32.211]  - relaying element #2
[17:02:32.211] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.211] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.211] signalConditionsASAP(NULL, pos=1) ... done
[17:02:32.211]  length: 5 (resolved future 1)
[17:02:32.211] Future #2
[17:02:32.211] result() for MulticoreFuture ...
[17:02:32.212] result() for MulticoreFuture ... done
[17:02:32.212] result() for MulticoreFuture ...
[17:02:32.212] result() for MulticoreFuture ... done
[17:02:32.212] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:32.212] - nx: 6
[17:02:32.212] - relay: TRUE
[17:02:32.212] - stdout: TRUE
[17:02:32.213] - signal: TRUE
[17:02:32.213] - resignal: FALSE
[17:02:32.220] - force: TRUE
[17:02:32.220] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.221] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.221]  - until=2
[17:02:32.222]  - relaying element #2
[17:02:32.222] result() for MulticoreFuture ...
[17:02:32.223] result() for MulticoreFuture ... done
[17:02:32.223] result() for MulticoreFuture ...
[17:02:32.223] result() for MulticoreFuture ... done
[17:02:32.223] result() for MulticoreFuture ...
[17:02:32.224] result() for MulticoreFuture ... done
[17:02:32.224] result() for MulticoreFuture ...
[17:02:32.224] result() for MulticoreFuture ... done
[17:02:32.224] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.224] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.224] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:32.225]  length: 4 (resolved future 2)
[17:02:32.225] Future #3
[17:02:32.225] result() for MulticoreFuture ...
[17:02:32.226] result() for MulticoreFuture ...
[17:02:32.226] result() for MulticoreFuture ... done
[17:02:32.226] result() for MulticoreFuture ... done
[17:02:32.226] result() for MulticoreFuture ...
[17:02:32.227] result() for MulticoreFuture ... done
[17:02:32.227] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:32.227] - nx: 6
[17:02:32.227] - relay: TRUE
[17:02:32.227] - stdout: TRUE
[17:02:32.227] - signal: TRUE
[17:02:32.227] - resignal: FALSE
[17:02:32.228] - force: TRUE
[17:02:32.228] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.228] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.228]  - until=3
[17:02:32.228]  - relaying element #3
[17:02:32.228] result() for MulticoreFuture ...
[17:02:32.228] result() for MulticoreFuture ... done
[17:02:32.229] result() for MulticoreFuture ...
[17:02:32.229] result() for MulticoreFuture ... done
[17:02:32.229] result() for MulticoreFuture ...
[17:02:32.229] result() for MulticoreFuture ... done
[17:02:32.229] result() for MulticoreFuture ...
[17:02:32.229] result() for MulticoreFuture ... done
[17:02:32.229] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.229] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.230] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:32.230]  length: 3 (resolved future 3)
[17:02:32.230] Future #4
[17:02:32.230] result() for MulticoreFuture ...
[17:02:32.231] result() for MulticoreFuture ...
[17:02:32.231] result() for MulticoreFuture ... done
[17:02:32.231] result() for MulticoreFuture ... done
[17:02:32.232] result() for MulticoreFuture ...
[17:02:32.232] result() for MulticoreFuture ... done
[17:02:32.232] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:02:32.232] - nx: 6
[17:02:32.232] - relay: TRUE
[17:02:32.233] - stdout: TRUE
[17:02:32.233] - signal: TRUE
[17:02:32.233] - resignal: FALSE
[17:02:32.233] - force: TRUE
[17:02:32.233] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.233] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.233]  - until=4
[17:02:32.234]  - relaying element #4
[17:02:32.234] result() for MulticoreFuture ...
[17:02:32.234] result() for MulticoreFuture ... done
[17:02:32.234] result() for MulticoreFuture ...
[17:02:32.234] result() for MulticoreFuture ... done
[17:02:32.234] result() for MulticoreFuture ...
[17:02:32.235] result() for MulticoreFuture ... done
[17:02:32.235] result() for MulticoreFuture ...
[17:02:32.235] result() for MulticoreFuture ... done
[17:02:32.235] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.235] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.235] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:02:32.236]  length: 2 (resolved future 4)
[17:02:32.236] signalConditionsASAP(NULL, pos=5) ...
[17:02:32.236] - nx: 6
[17:02:32.236] - relay: TRUE
[17:02:32.236] - stdout: TRUE
[17:02:32.236] - signal: TRUE
[17:02:32.236] - resignal: FALSE
[17:02:32.236] - force: TRUE
[17:02:32.237] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.237] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.237]  - until=6
[17:02:32.237]  - relaying element #6
[17:02:32.237] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:32.237] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.237] signalConditionsASAP(NULL, pos=5) ... done
[17:02:32.237]  length: 1 (resolved future 5)
[17:02:32.237] signalConditionsASAP(numeric, pos=6) ...
[17:02:32.238] - nx: 6
[17:02:32.238] - relay: TRUE
[17:02:32.238] - stdout: TRUE
[17:02:32.238] - signal: TRUE
[17:02:32.238] - resignal: FALSE
[17:02:32.238] - force: TRUE
[17:02:32.238] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:32.238] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.238]  - until=6
[17:02:32.238] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.238] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.239] signalConditionsASAP(numeric, pos=6) ... done
[17:02:32.239]  length: 0 (resolved future 6)
[17:02:32.239] Relaying remaining futures
[17:02:32.239] signalConditionsASAP(NULL, pos=0) ...
[17:02:32.239] - nx: 6
[17:02:32.239] - relay: TRUE
[17:02:32.239] - stdout: TRUE
[17:02:32.239] - signal: TRUE
[17:02:32.239] - resignal: FALSE
[17:02:32.239] - force: TRUE
[17:02:32.240] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.240] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:32.240] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.240] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.240] signalConditionsASAP(NULL, pos=0) ... done
[17:02:32.240] resolve() on list environment ... DONE
[17:02:32.240] result() for MulticoreFuture ...
[17:02:32.240] result() for MulticoreFuture ... done
[17:02:32.240] result() for MulticoreFuture ...
[17:02:32.241] result() for MulticoreFuture ... done
[17:02:32.241] result() for MulticoreFuture ...
[17:02:32.241] result() for MulticoreFuture ... done
[17:02:32.241] result() for MulticoreFuture ...
[17:02:32.241] result() for MulticoreFuture ... done
[17:02:32.241] result() for MulticoreFuture ...
[17:02:32.241] result() for MulticoreFuture ... done
[17:02:32.242] result() for MulticoreFuture ...
[17:02:32.242] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c74b642c30> 
Dimensions: c(1, 6)
[17:02:32.242] getGlobalsAndPackages() ...
[17:02:32.242] Searching for globals...
[17:02:32.243] 
[17:02:32.243] Searching for globals ... DONE
[17:02:32.243] - globals: [0] <none>
[17:02:32.243] getGlobalsAndPackages() ... DONE
[17:02:32.244] run() for ‘Future’ ...
[17:02:32.244] - state: ‘created’
[17:02:32.244] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.248] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.248] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.248]   - Field: ‘label’
[17:02:32.248]   - Field: ‘local’
[17:02:32.248]   - Field: ‘owner’
[17:02:32.248]   - Field: ‘envir’
[17:02:32.249]   - Field: ‘workers’
[17:02:32.249]   - Field: ‘packages’
[17:02:32.249]   - Field: ‘gc’
[17:02:32.249]   - Field: ‘job’
[17:02:32.249]   - Field: ‘conditions’
[17:02:32.249]   - Field: ‘expr’
[17:02:32.249]   - Field: ‘uuid’
[17:02:32.249]   - Field: ‘seed’
[17:02:32.249]   - Field: ‘version’
[17:02:32.249]   - Field: ‘result’
[17:02:32.250]   - Field: ‘asynchronous’
[17:02:32.250]   - Field: ‘calls’
[17:02:32.250]   - Field: ‘globals’
[17:02:32.250]   - Field: ‘stdout’
[17:02:32.250]   - Field: ‘earlySignal’
[17:02:32.250]   - Field: ‘lazy’
[17:02:32.250]   - Field: ‘state’
[17:02:32.250] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.250] - Launch lazy future ...
[17:02:32.251] Packages needed by the future expression (n = 0): <none>
[17:02:32.251] Packages needed by future strategies (n = 0): <none>
[17:02:32.251] {
[17:02:32.251]     {
[17:02:32.251]         {
[17:02:32.251]             ...future.startTime <- base::Sys.time()
[17:02:32.251]             {
[17:02:32.251]                 {
[17:02:32.251]                   {
[17:02:32.251]                     {
[17:02:32.251]                       base::local({
[17:02:32.251]                         has_future <- base::requireNamespace("future", 
[17:02:32.251]                           quietly = TRUE)
[17:02:32.251]                         if (has_future) {
[17:02:32.251]                           ns <- base::getNamespace("future")
[17:02:32.251]                           version <- ns[[".package"]][["version"]]
[17:02:32.251]                           if (is.null(version)) 
[17:02:32.251]                             version <- utils::packageVersion("future")
[17:02:32.251]                         }
[17:02:32.251]                         else {
[17:02:32.251]                           version <- NULL
[17:02:32.251]                         }
[17:02:32.251]                         if (!has_future || version < "1.8.0") {
[17:02:32.251]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.251]                             "", base::R.version$version.string), 
[17:02:32.251]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.251]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.251]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.251]                               "release", "version")], collapse = " "), 
[17:02:32.251]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.251]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.251]                             info)
[17:02:32.251]                           info <- base::paste(info, collapse = "; ")
[17:02:32.251]                           if (!has_future) {
[17:02:32.251]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.251]                               info)
[17:02:32.251]                           }
[17:02:32.251]                           else {
[17:02:32.251]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.251]                               info, version)
[17:02:32.251]                           }
[17:02:32.251]                           base::stop(msg)
[17:02:32.251]                         }
[17:02:32.251]                       })
[17:02:32.251]                     }
[17:02:32.251]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.251]                     base::options(mc.cores = 1L)
[17:02:32.251]                   }
[17:02:32.251]                   ...future.strategy.old <- future::plan("list")
[17:02:32.251]                   options(future.plan = NULL)
[17:02:32.251]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.251]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.251]                 }
[17:02:32.251]                 ...future.workdir <- getwd()
[17:02:32.251]             }
[17:02:32.251]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.251]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.251]         }
[17:02:32.251]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.251]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.251]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.251]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.251]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.251]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.251]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.251]             base::names(...future.oldOptions))
[17:02:32.251]     }
[17:02:32.251]     if (FALSE) {
[17:02:32.251]     }
[17:02:32.251]     else {
[17:02:32.251]         if (TRUE) {
[17:02:32.251]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.251]                 open = "w")
[17:02:32.251]         }
[17:02:32.251]         else {
[17:02:32.251]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.251]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.251]         }
[17:02:32.251]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.251]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.251]             base::sink(type = "output", split = FALSE)
[17:02:32.251]             base::close(...future.stdout)
[17:02:32.251]         }, add = TRUE)
[17:02:32.251]     }
[17:02:32.251]     ...future.frame <- base::sys.nframe()
[17:02:32.251]     ...future.conditions <- base::list()
[17:02:32.251]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.251]     if (FALSE) {
[17:02:32.251]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.251]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.251]     }
[17:02:32.251]     ...future.result <- base::tryCatch({
[17:02:32.251]         base::withCallingHandlers({
[17:02:32.251]             ...future.value <- base::withVisible(base::local({
[17:02:32.251]                 withCallingHandlers({
[17:02:32.251]                   2
[17:02:32.251]                 }, immediateCondition = function(cond) {
[17:02:32.251]                   save_rds <- function (object, pathname, ...) 
[17:02:32.251]                   {
[17:02:32.251]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.251]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.251]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.251]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.251]                         fi_tmp[["mtime"]])
[17:02:32.251]                     }
[17:02:32.251]                     tryCatch({
[17:02:32.251]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.251]                     }, error = function(ex) {
[17:02:32.251]                       msg <- conditionMessage(ex)
[17:02:32.251]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.251]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.251]                         fi_tmp[["mtime"]], msg)
[17:02:32.251]                       ex$message <- msg
[17:02:32.251]                       stop(ex)
[17:02:32.251]                     })
[17:02:32.251]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.251]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.251]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.251]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.251]                       fi <- file.info(pathname)
[17:02:32.251]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.251]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.251]                         fi[["size"]], fi[["mtime"]])
[17:02:32.251]                       stop(msg)
[17:02:32.251]                     }
[17:02:32.251]                     invisible(pathname)
[17:02:32.251]                   }
[17:02:32.251]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.251]                     rootPath = tempdir()) 
[17:02:32.251]                   {
[17:02:32.251]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.251]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.251]                       tmpdir = path, fileext = ".rds")
[17:02:32.251]                     save_rds(obj, file)
[17:02:32.251]                   }
[17:02:32.251]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.251]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.251]                   {
[17:02:32.251]                     inherits <- base::inherits
[17:02:32.251]                     invokeRestart <- base::invokeRestart
[17:02:32.251]                     is.null <- base::is.null
[17:02:32.251]                     muffled <- FALSE
[17:02:32.251]                     if (inherits(cond, "message")) {
[17:02:32.251]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.251]                       if (muffled) 
[17:02:32.251]                         invokeRestart("muffleMessage")
[17:02:32.251]                     }
[17:02:32.251]                     else if (inherits(cond, "warning")) {
[17:02:32.251]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.251]                       if (muffled) 
[17:02:32.251]                         invokeRestart("muffleWarning")
[17:02:32.251]                     }
[17:02:32.251]                     else if (inherits(cond, "condition")) {
[17:02:32.251]                       if (!is.null(pattern)) {
[17:02:32.251]                         computeRestarts <- base::computeRestarts
[17:02:32.251]                         grepl <- base::grepl
[17:02:32.251]                         restarts <- computeRestarts(cond)
[17:02:32.251]                         for (restart in restarts) {
[17:02:32.251]                           name <- restart$name
[17:02:32.251]                           if (is.null(name)) 
[17:02:32.251]                             next
[17:02:32.251]                           if (!grepl(pattern, name)) 
[17:02:32.251]                             next
[17:02:32.251]                           invokeRestart(restart)
[17:02:32.251]                           muffled <- TRUE
[17:02:32.251]                           break
[17:02:32.251]                         }
[17:02:32.251]                       }
[17:02:32.251]                     }
[17:02:32.251]                     invisible(muffled)
[17:02:32.251]                   }
[17:02:32.251]                   muffleCondition(cond)
[17:02:32.251]                 })
[17:02:32.251]             }))
[17:02:32.251]             future::FutureResult(value = ...future.value$value, 
[17:02:32.251]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.251]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.251]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.251]                     ...future.globalenv.names))
[17:02:32.251]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.251]         }, condition = base::local({
[17:02:32.251]             c <- base::c
[17:02:32.251]             inherits <- base::inherits
[17:02:32.251]             invokeRestart <- base::invokeRestart
[17:02:32.251]             length <- base::length
[17:02:32.251]             list <- base::list
[17:02:32.251]             seq.int <- base::seq.int
[17:02:32.251]             signalCondition <- base::signalCondition
[17:02:32.251]             sys.calls <- base::sys.calls
[17:02:32.251]             `[[` <- base::`[[`
[17:02:32.251]             `+` <- base::`+`
[17:02:32.251]             `<<-` <- base::`<<-`
[17:02:32.251]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.251]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.251]                   3L)]
[17:02:32.251]             }
[17:02:32.251]             function(cond) {
[17:02:32.251]                 is_error <- inherits(cond, "error")
[17:02:32.251]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.251]                   NULL)
[17:02:32.251]                 if (is_error) {
[17:02:32.251]                   sessionInformation <- function() {
[17:02:32.251]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.251]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.251]                       search = base::search(), system = base::Sys.info())
[17:02:32.251]                   }
[17:02:32.251]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.251]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.251]                     cond$call), session = sessionInformation(), 
[17:02:32.251]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.251]                   signalCondition(cond)
[17:02:32.251]                 }
[17:02:32.251]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.251]                 "immediateCondition"))) {
[17:02:32.251]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.251]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.251]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.251]                   if (TRUE && !signal) {
[17:02:32.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.251]                     {
[17:02:32.251]                       inherits <- base::inherits
[17:02:32.251]                       invokeRestart <- base::invokeRestart
[17:02:32.251]                       is.null <- base::is.null
[17:02:32.251]                       muffled <- FALSE
[17:02:32.251]                       if (inherits(cond, "message")) {
[17:02:32.251]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.251]                         if (muffled) 
[17:02:32.251]                           invokeRestart("muffleMessage")
[17:02:32.251]                       }
[17:02:32.251]                       else if (inherits(cond, "warning")) {
[17:02:32.251]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.251]                         if (muffled) 
[17:02:32.251]                           invokeRestart("muffleWarning")
[17:02:32.251]                       }
[17:02:32.251]                       else if (inherits(cond, "condition")) {
[17:02:32.251]                         if (!is.null(pattern)) {
[17:02:32.251]                           computeRestarts <- base::computeRestarts
[17:02:32.251]                           grepl <- base::grepl
[17:02:32.251]                           restarts <- computeRestarts(cond)
[17:02:32.251]                           for (restart in restarts) {
[17:02:32.251]                             name <- restart$name
[17:02:32.251]                             if (is.null(name)) 
[17:02:32.251]                               next
[17:02:32.251]                             if (!grepl(pattern, name)) 
[17:02:32.251]                               next
[17:02:32.251]                             invokeRestart(restart)
[17:02:32.251]                             muffled <- TRUE
[17:02:32.251]                             break
[17:02:32.251]                           }
[17:02:32.251]                         }
[17:02:32.251]                       }
[17:02:32.251]                       invisible(muffled)
[17:02:32.251]                     }
[17:02:32.251]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.251]                   }
[17:02:32.251]                 }
[17:02:32.251]                 else {
[17:02:32.251]                   if (TRUE) {
[17:02:32.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.251]                     {
[17:02:32.251]                       inherits <- base::inherits
[17:02:32.251]                       invokeRestart <- base::invokeRestart
[17:02:32.251]                       is.null <- base::is.null
[17:02:32.251]                       muffled <- FALSE
[17:02:32.251]                       if (inherits(cond, "message")) {
[17:02:32.251]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.251]                         if (muffled) 
[17:02:32.251]                           invokeRestart("muffleMessage")
[17:02:32.251]                       }
[17:02:32.251]                       else if (inherits(cond, "warning")) {
[17:02:32.251]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.251]                         if (muffled) 
[17:02:32.251]                           invokeRestart("muffleWarning")
[17:02:32.251]                       }
[17:02:32.251]                       else if (inherits(cond, "condition")) {
[17:02:32.251]                         if (!is.null(pattern)) {
[17:02:32.251]                           computeRestarts <- base::computeRestarts
[17:02:32.251]                           grepl <- base::grepl
[17:02:32.251]                           restarts <- computeRestarts(cond)
[17:02:32.251]                           for (restart in restarts) {
[17:02:32.251]                             name <- restart$name
[17:02:32.251]                             if (is.null(name)) 
[17:02:32.251]                               next
[17:02:32.251]                             if (!grepl(pattern, name)) 
[17:02:32.251]                               next
[17:02:32.251]                             invokeRestart(restart)
[17:02:32.251]                             muffled <- TRUE
[17:02:32.251]                             break
[17:02:32.251]                           }
[17:02:32.251]                         }
[17:02:32.251]                       }
[17:02:32.251]                       invisible(muffled)
[17:02:32.251]                     }
[17:02:32.251]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.251]                   }
[17:02:32.251]                 }
[17:02:32.251]             }
[17:02:32.251]         }))
[17:02:32.251]     }, error = function(ex) {
[17:02:32.251]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.251]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.251]                 ...future.rng), started = ...future.startTime, 
[17:02:32.251]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.251]             version = "1.8"), class = "FutureResult")
[17:02:32.251]     }, finally = {
[17:02:32.251]         if (!identical(...future.workdir, getwd())) 
[17:02:32.251]             setwd(...future.workdir)
[17:02:32.251]         {
[17:02:32.251]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.251]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.251]             }
[17:02:32.251]             base::options(...future.oldOptions)
[17:02:32.251]             if (.Platform$OS.type == "windows") {
[17:02:32.251]                 old_names <- names(...future.oldEnvVars)
[17:02:32.251]                 envs <- base::Sys.getenv()
[17:02:32.251]                 names <- names(envs)
[17:02:32.251]                 common <- intersect(names, old_names)
[17:02:32.251]                 added <- setdiff(names, old_names)
[17:02:32.251]                 removed <- setdiff(old_names, names)
[17:02:32.251]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.251]                   envs[common]]
[17:02:32.251]                 NAMES <- toupper(changed)
[17:02:32.251]                 args <- list()
[17:02:32.251]                 for (kk in seq_along(NAMES)) {
[17:02:32.251]                   name <- changed[[kk]]
[17:02:32.251]                   NAME <- NAMES[[kk]]
[17:02:32.251]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.251]                     next
[17:02:32.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.251]                 }
[17:02:32.251]                 NAMES <- toupper(added)
[17:02:32.251]                 for (kk in seq_along(NAMES)) {
[17:02:32.251]                   name <- added[[kk]]
[17:02:32.251]                   NAME <- NAMES[[kk]]
[17:02:32.251]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.251]                     next
[17:02:32.251]                   args[[name]] <- ""
[17:02:32.251]                 }
[17:02:32.251]                 NAMES <- toupper(removed)
[17:02:32.251]                 for (kk in seq_along(NAMES)) {
[17:02:32.251]                   name <- removed[[kk]]
[17:02:32.251]                   NAME <- NAMES[[kk]]
[17:02:32.251]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.251]                     next
[17:02:32.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.251]                 }
[17:02:32.251]                 if (length(args) > 0) 
[17:02:32.251]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.251]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.251]             }
[17:02:32.251]             else {
[17:02:32.251]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.251]             }
[17:02:32.251]             {
[17:02:32.251]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.251]                   0L) {
[17:02:32.251]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.251]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.251]                   base::options(opts)
[17:02:32.251]                 }
[17:02:32.251]                 {
[17:02:32.251]                   {
[17:02:32.251]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.251]                     NULL
[17:02:32.251]                   }
[17:02:32.251]                   options(future.plan = NULL)
[17:02:32.251]                   if (is.na(NA_character_)) 
[17:02:32.251]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.251]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.251]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.251]                     .init = FALSE)
[17:02:32.251]                 }
[17:02:32.251]             }
[17:02:32.251]         }
[17:02:32.251]     })
[17:02:32.251]     if (TRUE) {
[17:02:32.251]         base::sink(type = "output", split = FALSE)
[17:02:32.251]         if (TRUE) {
[17:02:32.251]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.251]         }
[17:02:32.251]         else {
[17:02:32.251]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.251]         }
[17:02:32.251]         base::close(...future.stdout)
[17:02:32.251]         ...future.stdout <- NULL
[17:02:32.251]     }
[17:02:32.251]     ...future.result$conditions <- ...future.conditions
[17:02:32.251]     ...future.result$finished <- base::Sys.time()
[17:02:32.251]     ...future.result
[17:02:32.251] }
[17:02:32.254] requestCore(): workers = 2
[17:02:32.256] MulticoreFuture started
[17:02:32.257] - Launch lazy future ... done
[17:02:32.257] run() for ‘MulticoreFuture’ ... done
[17:02:32.257] getGlobalsAndPackages() ...
[17:02:32.257] plan(): Setting new future strategy stack:
[17:02:32.257] Searching for globals...
[17:02:32.258] List of future strategies:
[17:02:32.258] 1. sequential:
[17:02:32.258]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.258]    - tweaked: FALSE
[17:02:32.258]    - call: NULL
[17:02:32.258] 
[17:02:32.258] Searching for globals ... DONE
[17:02:32.259] plan(): nbrOfWorkers() = 1
[17:02:32.259] - globals: [0] <none>
[17:02:32.259] getGlobalsAndPackages() ... DONE
[17:02:32.259] run() for ‘Future’ ...
[17:02:32.260] - state: ‘created’
[17:02:32.260] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.261] plan(): Setting new future strategy stack:
[17:02:32.261] List of future strategies:
[17:02:32.261] 1. multicore:
[17:02:32.261]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.261]    - tweaked: FALSE
[17:02:32.261]    - call: plan(strategy)
[17:02:32.266] plan(): nbrOfWorkers() = 2
[17:02:32.266] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.266] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.267]   - Field: ‘label’
[17:02:32.267]   - Field: ‘local’
[17:02:32.267]   - Field: ‘owner’
[17:02:32.267]   - Field: ‘envir’
[17:02:32.267]   - Field: ‘workers’
[17:02:32.268]   - Field: ‘packages’
[17:02:32.268]   - Field: ‘gc’
[17:02:32.268]   - Field: ‘job’
[17:02:32.268]   - Field: ‘conditions’
[17:02:32.268]   - Field: ‘expr’
[17:02:32.269]   - Field: ‘uuid’
[17:02:32.269]   - Field: ‘seed’
[17:02:32.269]   - Field: ‘version’
[17:02:32.269]   - Field: ‘result’
[17:02:32.269]   - Field: ‘asynchronous’
[17:02:32.269]   - Field: ‘calls’
[17:02:32.270]   - Field: ‘globals’
[17:02:32.270]   - Field: ‘stdout’
[17:02:32.270]   - Field: ‘earlySignal’
[17:02:32.270]   - Field: ‘lazy’
[17:02:32.270]   - Field: ‘state’
[17:02:32.270] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.271] - Launch lazy future ...
[17:02:32.271] Packages needed by the future expression (n = 0): <none>
[17:02:32.271] Packages needed by future strategies (n = 0): <none>
[17:02:32.272] {
[17:02:32.272]     {
[17:02:32.272]         {
[17:02:32.272]             ...future.startTime <- base::Sys.time()
[17:02:32.272]             {
[17:02:32.272]                 {
[17:02:32.272]                   {
[17:02:32.272]                     {
[17:02:32.272]                       base::local({
[17:02:32.272]                         has_future <- base::requireNamespace("future", 
[17:02:32.272]                           quietly = TRUE)
[17:02:32.272]                         if (has_future) {
[17:02:32.272]                           ns <- base::getNamespace("future")
[17:02:32.272]                           version <- ns[[".package"]][["version"]]
[17:02:32.272]                           if (is.null(version)) 
[17:02:32.272]                             version <- utils::packageVersion("future")
[17:02:32.272]                         }
[17:02:32.272]                         else {
[17:02:32.272]                           version <- NULL
[17:02:32.272]                         }
[17:02:32.272]                         if (!has_future || version < "1.8.0") {
[17:02:32.272]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.272]                             "", base::R.version$version.string), 
[17:02:32.272]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.272]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.272]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.272]                               "release", "version")], collapse = " "), 
[17:02:32.272]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.272]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.272]                             info)
[17:02:32.272]                           info <- base::paste(info, collapse = "; ")
[17:02:32.272]                           if (!has_future) {
[17:02:32.272]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.272]                               info)
[17:02:32.272]                           }
[17:02:32.272]                           else {
[17:02:32.272]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.272]                               info, version)
[17:02:32.272]                           }
[17:02:32.272]                           base::stop(msg)
[17:02:32.272]                         }
[17:02:32.272]                       })
[17:02:32.272]                     }
[17:02:32.272]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.272]                     base::options(mc.cores = 1L)
[17:02:32.272]                   }
[17:02:32.272]                   ...future.strategy.old <- future::plan("list")
[17:02:32.272]                   options(future.plan = NULL)
[17:02:32.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.272]                 }
[17:02:32.272]                 ...future.workdir <- getwd()
[17:02:32.272]             }
[17:02:32.272]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.272]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.272]         }
[17:02:32.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.272]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.272]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.272]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.272]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.272]             base::names(...future.oldOptions))
[17:02:32.272]     }
[17:02:32.272]     if (FALSE) {
[17:02:32.272]     }
[17:02:32.272]     else {
[17:02:32.272]         if (TRUE) {
[17:02:32.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.272]                 open = "w")
[17:02:32.272]         }
[17:02:32.272]         else {
[17:02:32.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.272]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.272]         }
[17:02:32.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.272]             base::sink(type = "output", split = FALSE)
[17:02:32.272]             base::close(...future.stdout)
[17:02:32.272]         }, add = TRUE)
[17:02:32.272]     }
[17:02:32.272]     ...future.frame <- base::sys.nframe()
[17:02:32.272]     ...future.conditions <- base::list()
[17:02:32.272]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.272]     if (FALSE) {
[17:02:32.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.272]     }
[17:02:32.272]     ...future.result <- base::tryCatch({
[17:02:32.272]         base::withCallingHandlers({
[17:02:32.272]             ...future.value <- base::withVisible(base::local({
[17:02:32.272]                 withCallingHandlers({
[17:02:32.272]                   NULL
[17:02:32.272]                 }, immediateCondition = function(cond) {
[17:02:32.272]                   save_rds <- function (object, pathname, ...) 
[17:02:32.272]                   {
[17:02:32.272]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.272]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.272]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.272]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.272]                         fi_tmp[["mtime"]])
[17:02:32.272]                     }
[17:02:32.272]                     tryCatch({
[17:02:32.272]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.272]                     }, error = function(ex) {
[17:02:32.272]                       msg <- conditionMessage(ex)
[17:02:32.272]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.272]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.272]                         fi_tmp[["mtime"]], msg)
[17:02:32.272]                       ex$message <- msg
[17:02:32.272]                       stop(ex)
[17:02:32.272]                     })
[17:02:32.272]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.272]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.272]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.272]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.272]                       fi <- file.info(pathname)
[17:02:32.272]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.272]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.272]                         fi[["size"]], fi[["mtime"]])
[17:02:32.272]                       stop(msg)
[17:02:32.272]                     }
[17:02:32.272]                     invisible(pathname)
[17:02:32.272]                   }
[17:02:32.272]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.272]                     rootPath = tempdir()) 
[17:02:32.272]                   {
[17:02:32.272]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.272]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.272]                       tmpdir = path, fileext = ".rds")
[17:02:32.272]                     save_rds(obj, file)
[17:02:32.272]                   }
[17:02:32.272]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.272]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.272]                   {
[17:02:32.272]                     inherits <- base::inherits
[17:02:32.272]                     invokeRestart <- base::invokeRestart
[17:02:32.272]                     is.null <- base::is.null
[17:02:32.272]                     muffled <- FALSE
[17:02:32.272]                     if (inherits(cond, "message")) {
[17:02:32.272]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.272]                       if (muffled) 
[17:02:32.272]                         invokeRestart("muffleMessage")
[17:02:32.272]                     }
[17:02:32.272]                     else if (inherits(cond, "warning")) {
[17:02:32.272]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.272]                       if (muffled) 
[17:02:32.272]                         invokeRestart("muffleWarning")
[17:02:32.272]                     }
[17:02:32.272]                     else if (inherits(cond, "condition")) {
[17:02:32.272]                       if (!is.null(pattern)) {
[17:02:32.272]                         computeRestarts <- base::computeRestarts
[17:02:32.272]                         grepl <- base::grepl
[17:02:32.272]                         restarts <- computeRestarts(cond)
[17:02:32.272]                         for (restart in restarts) {
[17:02:32.272]                           name <- restart$name
[17:02:32.272]                           if (is.null(name)) 
[17:02:32.272]                             next
[17:02:32.272]                           if (!grepl(pattern, name)) 
[17:02:32.272]                             next
[17:02:32.272]                           invokeRestart(restart)
[17:02:32.272]                           muffled <- TRUE
[17:02:32.272]                           break
[17:02:32.272]                         }
[17:02:32.272]                       }
[17:02:32.272]                     }
[17:02:32.272]                     invisible(muffled)
[17:02:32.272]                   }
[17:02:32.272]                   muffleCondition(cond)
[17:02:32.272]                 })
[17:02:32.272]             }))
[17:02:32.272]             future::FutureResult(value = ...future.value$value, 
[17:02:32.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.272]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.272]                     ...future.globalenv.names))
[17:02:32.272]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.272]         }, condition = base::local({
[17:02:32.272]             c <- base::c
[17:02:32.272]             inherits <- base::inherits
[17:02:32.272]             invokeRestart <- base::invokeRestart
[17:02:32.272]             length <- base::length
[17:02:32.272]             list <- base::list
[17:02:32.272]             seq.int <- base::seq.int
[17:02:32.272]             signalCondition <- base::signalCondition
[17:02:32.272]             sys.calls <- base::sys.calls
[17:02:32.272]             `[[` <- base::`[[`
[17:02:32.272]             `+` <- base::`+`
[17:02:32.272]             `<<-` <- base::`<<-`
[17:02:32.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.272]                   3L)]
[17:02:32.272]             }
[17:02:32.272]             function(cond) {
[17:02:32.272]                 is_error <- inherits(cond, "error")
[17:02:32.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.272]                   NULL)
[17:02:32.272]                 if (is_error) {
[17:02:32.272]                   sessionInformation <- function() {
[17:02:32.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.272]                       search = base::search(), system = base::Sys.info())
[17:02:32.272]                   }
[17:02:32.272]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.272]                     cond$call), session = sessionInformation(), 
[17:02:32.272]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.272]                   signalCondition(cond)
[17:02:32.272]                 }
[17:02:32.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.272]                 "immediateCondition"))) {
[17:02:32.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.272]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.272]                   if (TRUE && !signal) {
[17:02:32.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.272]                     {
[17:02:32.272]                       inherits <- base::inherits
[17:02:32.272]                       invokeRestart <- base::invokeRestart
[17:02:32.272]                       is.null <- base::is.null
[17:02:32.272]                       muffled <- FALSE
[17:02:32.272]                       if (inherits(cond, "message")) {
[17:02:32.272]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.272]                         if (muffled) 
[17:02:32.272]                           invokeRestart("muffleMessage")
[17:02:32.272]                       }
[17:02:32.272]                       else if (inherits(cond, "warning")) {
[17:02:32.272]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.272]                         if (muffled) 
[17:02:32.272]                           invokeRestart("muffleWarning")
[17:02:32.272]                       }
[17:02:32.272]                       else if (inherits(cond, "condition")) {
[17:02:32.272]                         if (!is.null(pattern)) {
[17:02:32.272]                           computeRestarts <- base::computeRestarts
[17:02:32.272]                           grepl <- base::grepl
[17:02:32.272]                           restarts <- computeRestarts(cond)
[17:02:32.272]                           for (restart in restarts) {
[17:02:32.272]                             name <- restart$name
[17:02:32.272]                             if (is.null(name)) 
[17:02:32.272]                               next
[17:02:32.272]                             if (!grepl(pattern, name)) 
[17:02:32.272]                               next
[17:02:32.272]                             invokeRestart(restart)
[17:02:32.272]                             muffled <- TRUE
[17:02:32.272]                             break
[17:02:32.272]                           }
[17:02:32.272]                         }
[17:02:32.272]                       }
[17:02:32.272]                       invisible(muffled)
[17:02:32.272]                     }
[17:02:32.272]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.272]                   }
[17:02:32.272]                 }
[17:02:32.272]                 else {
[17:02:32.272]                   if (TRUE) {
[17:02:32.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.272]                     {
[17:02:32.272]                       inherits <- base::inherits
[17:02:32.272]                       invokeRestart <- base::invokeRestart
[17:02:32.272]                       is.null <- base::is.null
[17:02:32.272]                       muffled <- FALSE
[17:02:32.272]                       if (inherits(cond, "message")) {
[17:02:32.272]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.272]                         if (muffled) 
[17:02:32.272]                           invokeRestart("muffleMessage")
[17:02:32.272]                       }
[17:02:32.272]                       else if (inherits(cond, "warning")) {
[17:02:32.272]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.272]                         if (muffled) 
[17:02:32.272]                           invokeRestart("muffleWarning")
[17:02:32.272]                       }
[17:02:32.272]                       else if (inherits(cond, "condition")) {
[17:02:32.272]                         if (!is.null(pattern)) {
[17:02:32.272]                           computeRestarts <- base::computeRestarts
[17:02:32.272]                           grepl <- base::grepl
[17:02:32.272]                           restarts <- computeRestarts(cond)
[17:02:32.272]                           for (restart in restarts) {
[17:02:32.272]                             name <- restart$name
[17:02:32.272]                             if (is.null(name)) 
[17:02:32.272]                               next
[17:02:32.272]                             if (!grepl(pattern, name)) 
[17:02:32.272]                               next
[17:02:32.272]                             invokeRestart(restart)
[17:02:32.272]                             muffled <- TRUE
[17:02:32.272]                             break
[17:02:32.272]                           }
[17:02:32.272]                         }
[17:02:32.272]                       }
[17:02:32.272]                       invisible(muffled)
[17:02:32.272]                     }
[17:02:32.272]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.272]                   }
[17:02:32.272]                 }
[17:02:32.272]             }
[17:02:32.272]         }))
[17:02:32.272]     }, error = function(ex) {
[17:02:32.272]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.272]                 ...future.rng), started = ...future.startTime, 
[17:02:32.272]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.272]             version = "1.8"), class = "FutureResult")
[17:02:32.272]     }, finally = {
[17:02:32.272]         if (!identical(...future.workdir, getwd())) 
[17:02:32.272]             setwd(...future.workdir)
[17:02:32.272]         {
[17:02:32.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.272]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.272]             }
[17:02:32.272]             base::options(...future.oldOptions)
[17:02:32.272]             if (.Platform$OS.type == "windows") {
[17:02:32.272]                 old_names <- names(...future.oldEnvVars)
[17:02:32.272]                 envs <- base::Sys.getenv()
[17:02:32.272]                 names <- names(envs)
[17:02:32.272]                 common <- intersect(names, old_names)
[17:02:32.272]                 added <- setdiff(names, old_names)
[17:02:32.272]                 removed <- setdiff(old_names, names)
[17:02:32.272]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.272]                   envs[common]]
[17:02:32.272]                 NAMES <- toupper(changed)
[17:02:32.272]                 args <- list()
[17:02:32.272]                 for (kk in seq_along(NAMES)) {
[17:02:32.272]                   name <- changed[[kk]]
[17:02:32.272]                   NAME <- NAMES[[kk]]
[17:02:32.272]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.272]                     next
[17:02:32.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.272]                 }
[17:02:32.272]                 NAMES <- toupper(added)
[17:02:32.272]                 for (kk in seq_along(NAMES)) {
[17:02:32.272]                   name <- added[[kk]]
[17:02:32.272]                   NAME <- NAMES[[kk]]
[17:02:32.272]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.272]                     next
[17:02:32.272]                   args[[name]] <- ""
[17:02:32.272]                 }
[17:02:32.272]                 NAMES <- toupper(removed)
[17:02:32.272]                 for (kk in seq_along(NAMES)) {
[17:02:32.272]                   name <- removed[[kk]]
[17:02:32.272]                   NAME <- NAMES[[kk]]
[17:02:32.272]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.272]                     next
[17:02:32.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.272]                 }
[17:02:32.272]                 if (length(args) > 0) 
[17:02:32.272]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.272]             }
[17:02:32.272]             else {
[17:02:32.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.272]             }
[17:02:32.272]             {
[17:02:32.272]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.272]                   0L) {
[17:02:32.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.272]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.272]                   base::options(opts)
[17:02:32.272]                 }
[17:02:32.272]                 {
[17:02:32.272]                   {
[17:02:32.272]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.272]                     NULL
[17:02:32.272]                   }
[17:02:32.272]                   options(future.plan = NULL)
[17:02:32.272]                   if (is.na(NA_character_)) 
[17:02:32.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.272]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.272]                     .init = FALSE)
[17:02:32.272]                 }
[17:02:32.272]             }
[17:02:32.272]         }
[17:02:32.272]     })
[17:02:32.272]     if (TRUE) {
[17:02:32.272]         base::sink(type = "output", split = FALSE)
[17:02:32.272]         if (TRUE) {
[17:02:32.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.272]         }
[17:02:32.272]         else {
[17:02:32.272]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.272]         }
[17:02:32.272]         base::close(...future.stdout)
[17:02:32.272]         ...future.stdout <- NULL
[17:02:32.272]     }
[17:02:32.272]     ...future.result$conditions <- ...future.conditions
[17:02:32.272]     ...future.result$finished <- base::Sys.time()
[17:02:32.272]     ...future.result
[17:02:32.272] }
[17:02:32.276] requestCore(): workers = 2
[17:02:32.279] MulticoreFuture started
[17:02:32.279] - Launch lazy future ... done
[17:02:32.279] run() for ‘MulticoreFuture’ ... done
[17:02:32.280] plan(): Setting new future strategy stack:
[17:02:32.281] getGlobalsAndPackages() ...
[17:02:32.281] Searching for globals...
[17:02:32.280] List of future strategies:
[17:02:32.280] 1. sequential:
[17:02:32.280]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.280]    - tweaked: FALSE
[17:02:32.280]    - call: NULL
[17:02:32.281] plan(): nbrOfWorkers() = 1
[17:02:32.282] - globals found: [1] ‘{’
[17:02:32.282] Searching for globals ... DONE
[17:02:32.283] Resolving globals: FALSE
[17:02:32.283] 
[17:02:32.283] 
[17:02:32.283] plan(): Setting new future strategy stack:
[17:02:32.283] getGlobalsAndPackages() ... DONE
[17:02:32.284] run() for ‘Future’ ...
[17:02:32.284] List of future strategies:
[17:02:32.284] 1. multicore:
[17:02:32.284]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.284]    - tweaked: FALSE
[17:02:32.284]    - call: plan(strategy)
[17:02:32.284] - state: ‘created’
[17:02:32.284] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.289] plan(): nbrOfWorkers() = 2
[17:02:32.290] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.290] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.290]   - Field: ‘label’
[17:02:32.290]   - Field: ‘local’
[17:02:32.291]   - Field: ‘owner’
[17:02:32.291]   - Field: ‘envir’
[17:02:32.291]   - Field: ‘workers’
[17:02:32.291]   - Field: ‘packages’
[17:02:32.291]   - Field: ‘gc’
[17:02:32.291]   - Field: ‘job’
[17:02:32.291]   - Field: ‘conditions’
[17:02:32.292]   - Field: ‘expr’
[17:02:32.292]   - Field: ‘uuid’
[17:02:32.292]   - Field: ‘seed’
[17:02:32.292]   - Field: ‘version’
[17:02:32.292]   - Field: ‘result’
[17:02:32.292]   - Field: ‘asynchronous’
[17:02:32.292]   - Field: ‘calls’
[17:02:32.293]   - Field: ‘globals’
[17:02:32.293]   - Field: ‘stdout’
[17:02:32.293]   - Field: ‘earlySignal’
[17:02:32.293]   - Field: ‘lazy’
[17:02:32.293]   - Field: ‘state’
[17:02:32.293] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.293] - Launch lazy future ...
[17:02:32.294] Packages needed by the future expression (n = 0): <none>
[17:02:32.294] Packages needed by future strategies (n = 0): <none>
[17:02:32.295] {
[17:02:32.295]     {
[17:02:32.295]         {
[17:02:32.295]             ...future.startTime <- base::Sys.time()
[17:02:32.295]             {
[17:02:32.295]                 {
[17:02:32.295]                   {
[17:02:32.295]                     {
[17:02:32.295]                       base::local({
[17:02:32.295]                         has_future <- base::requireNamespace("future", 
[17:02:32.295]                           quietly = TRUE)
[17:02:32.295]                         if (has_future) {
[17:02:32.295]                           ns <- base::getNamespace("future")
[17:02:32.295]                           version <- ns[[".package"]][["version"]]
[17:02:32.295]                           if (is.null(version)) 
[17:02:32.295]                             version <- utils::packageVersion("future")
[17:02:32.295]                         }
[17:02:32.295]                         else {
[17:02:32.295]                           version <- NULL
[17:02:32.295]                         }
[17:02:32.295]                         if (!has_future || version < "1.8.0") {
[17:02:32.295]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.295]                             "", base::R.version$version.string), 
[17:02:32.295]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.295]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.295]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.295]                               "release", "version")], collapse = " "), 
[17:02:32.295]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.295]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.295]                             info)
[17:02:32.295]                           info <- base::paste(info, collapse = "; ")
[17:02:32.295]                           if (!has_future) {
[17:02:32.295]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.295]                               info)
[17:02:32.295]                           }
[17:02:32.295]                           else {
[17:02:32.295]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.295]                               info, version)
[17:02:32.295]                           }
[17:02:32.295]                           base::stop(msg)
[17:02:32.295]                         }
[17:02:32.295]                       })
[17:02:32.295]                     }
[17:02:32.295]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.295]                     base::options(mc.cores = 1L)
[17:02:32.295]                   }
[17:02:32.295]                   ...future.strategy.old <- future::plan("list")
[17:02:32.295]                   options(future.plan = NULL)
[17:02:32.295]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.295]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.295]                 }
[17:02:32.295]                 ...future.workdir <- getwd()
[17:02:32.295]             }
[17:02:32.295]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.295]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.295]         }
[17:02:32.295]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.295]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.295]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.295]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.295]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.295]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.295]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.295]             base::names(...future.oldOptions))
[17:02:32.295]     }
[17:02:32.295]     if (FALSE) {
[17:02:32.295]     }
[17:02:32.295]     else {
[17:02:32.295]         if (TRUE) {
[17:02:32.295]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.295]                 open = "w")
[17:02:32.295]         }
[17:02:32.295]         else {
[17:02:32.295]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.295]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.295]         }
[17:02:32.295]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.295]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.295]             base::sink(type = "output", split = FALSE)
[17:02:32.295]             base::close(...future.stdout)
[17:02:32.295]         }, add = TRUE)
[17:02:32.295]     }
[17:02:32.295]     ...future.frame <- base::sys.nframe()
[17:02:32.295]     ...future.conditions <- base::list()
[17:02:32.295]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.295]     if (FALSE) {
[17:02:32.295]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.295]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.295]     }
[17:02:32.295]     ...future.result <- base::tryCatch({
[17:02:32.295]         base::withCallingHandlers({
[17:02:32.295]             ...future.value <- base::withVisible(base::local({
[17:02:32.295]                 withCallingHandlers({
[17:02:32.295]                   {
[17:02:32.295]                     4
[17:02:32.295]                   }
[17:02:32.295]                 }, immediateCondition = function(cond) {
[17:02:32.295]                   save_rds <- function (object, pathname, ...) 
[17:02:32.295]                   {
[17:02:32.295]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.295]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.295]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.295]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.295]                         fi_tmp[["mtime"]])
[17:02:32.295]                     }
[17:02:32.295]                     tryCatch({
[17:02:32.295]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.295]                     }, error = function(ex) {
[17:02:32.295]                       msg <- conditionMessage(ex)
[17:02:32.295]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.295]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.295]                         fi_tmp[["mtime"]], msg)
[17:02:32.295]                       ex$message <- msg
[17:02:32.295]                       stop(ex)
[17:02:32.295]                     })
[17:02:32.295]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.295]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.295]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.295]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.295]                       fi <- file.info(pathname)
[17:02:32.295]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.295]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.295]                         fi[["size"]], fi[["mtime"]])
[17:02:32.295]                       stop(msg)
[17:02:32.295]                     }
[17:02:32.295]                     invisible(pathname)
[17:02:32.295]                   }
[17:02:32.295]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.295]                     rootPath = tempdir()) 
[17:02:32.295]                   {
[17:02:32.295]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.295]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.295]                       tmpdir = path, fileext = ".rds")
[17:02:32.295]                     save_rds(obj, file)
[17:02:32.295]                   }
[17:02:32.295]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.295]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.295]                   {
[17:02:32.295]                     inherits <- base::inherits
[17:02:32.295]                     invokeRestart <- base::invokeRestart
[17:02:32.295]                     is.null <- base::is.null
[17:02:32.295]                     muffled <- FALSE
[17:02:32.295]                     if (inherits(cond, "message")) {
[17:02:32.295]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.295]                       if (muffled) 
[17:02:32.295]                         invokeRestart("muffleMessage")
[17:02:32.295]                     }
[17:02:32.295]                     else if (inherits(cond, "warning")) {
[17:02:32.295]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.295]                       if (muffled) 
[17:02:32.295]                         invokeRestart("muffleWarning")
[17:02:32.295]                     }
[17:02:32.295]                     else if (inherits(cond, "condition")) {
[17:02:32.295]                       if (!is.null(pattern)) {
[17:02:32.295]                         computeRestarts <- base::computeRestarts
[17:02:32.295]                         grepl <- base::grepl
[17:02:32.295]                         restarts <- computeRestarts(cond)
[17:02:32.295]                         for (restart in restarts) {
[17:02:32.295]                           name <- restart$name
[17:02:32.295]                           if (is.null(name)) 
[17:02:32.295]                             next
[17:02:32.295]                           if (!grepl(pattern, name)) 
[17:02:32.295]                             next
[17:02:32.295]                           invokeRestart(restart)
[17:02:32.295]                           muffled <- TRUE
[17:02:32.295]                           break
[17:02:32.295]                         }
[17:02:32.295]                       }
[17:02:32.295]                     }
[17:02:32.295]                     invisible(muffled)
[17:02:32.295]                   }
[17:02:32.295]                   muffleCondition(cond)
[17:02:32.295]                 })
[17:02:32.295]             }))
[17:02:32.295]             future::FutureResult(value = ...future.value$value, 
[17:02:32.295]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.295]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.295]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.295]                     ...future.globalenv.names))
[17:02:32.295]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.295]         }, condition = base::local({
[17:02:32.295]             c <- base::c
[17:02:32.295]             inherits <- base::inherits
[17:02:32.295]             invokeRestart <- base::invokeRestart
[17:02:32.295]             length <- base::length
[17:02:32.295]             list <- base::list
[17:02:32.295]             seq.int <- base::seq.int
[17:02:32.295]             signalCondition <- base::signalCondition
[17:02:32.295]             sys.calls <- base::sys.calls
[17:02:32.295]             `[[` <- base::`[[`
[17:02:32.295]             `+` <- base::`+`
[17:02:32.295]             `<<-` <- base::`<<-`
[17:02:32.295]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.295]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.295]                   3L)]
[17:02:32.295]             }
[17:02:32.295]             function(cond) {
[17:02:32.295]                 is_error <- inherits(cond, "error")
[17:02:32.295]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.295]                   NULL)
[17:02:32.295]                 if (is_error) {
[17:02:32.295]                   sessionInformation <- function() {
[17:02:32.295]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.295]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.295]                       search = base::search(), system = base::Sys.info())
[17:02:32.295]                   }
[17:02:32.295]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.295]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.295]                     cond$call), session = sessionInformation(), 
[17:02:32.295]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.295]                   signalCondition(cond)
[17:02:32.295]                 }
[17:02:32.295]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.295]                 "immediateCondition"))) {
[17:02:32.295]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.295]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.295]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.295]                   if (TRUE && !signal) {
[17:02:32.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.295]                     {
[17:02:32.295]                       inherits <- base::inherits
[17:02:32.295]                       invokeRestart <- base::invokeRestart
[17:02:32.295]                       is.null <- base::is.null
[17:02:32.295]                       muffled <- FALSE
[17:02:32.295]                       if (inherits(cond, "message")) {
[17:02:32.295]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.295]                         if (muffled) 
[17:02:32.295]                           invokeRestart("muffleMessage")
[17:02:32.295]                       }
[17:02:32.295]                       else if (inherits(cond, "warning")) {
[17:02:32.295]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.295]                         if (muffled) 
[17:02:32.295]                           invokeRestart("muffleWarning")
[17:02:32.295]                       }
[17:02:32.295]                       else if (inherits(cond, "condition")) {
[17:02:32.295]                         if (!is.null(pattern)) {
[17:02:32.295]                           computeRestarts <- base::computeRestarts
[17:02:32.295]                           grepl <- base::grepl
[17:02:32.295]                           restarts <- computeRestarts(cond)
[17:02:32.295]                           for (restart in restarts) {
[17:02:32.295]                             name <- restart$name
[17:02:32.295]                             if (is.null(name)) 
[17:02:32.295]                               next
[17:02:32.295]                             if (!grepl(pattern, name)) 
[17:02:32.295]                               next
[17:02:32.295]                             invokeRestart(restart)
[17:02:32.295]                             muffled <- TRUE
[17:02:32.295]                             break
[17:02:32.295]                           }
[17:02:32.295]                         }
[17:02:32.295]                       }
[17:02:32.295]                       invisible(muffled)
[17:02:32.295]                     }
[17:02:32.295]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.295]                   }
[17:02:32.295]                 }
[17:02:32.295]                 else {
[17:02:32.295]                   if (TRUE) {
[17:02:32.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.295]                     {
[17:02:32.295]                       inherits <- base::inherits
[17:02:32.295]                       invokeRestart <- base::invokeRestart
[17:02:32.295]                       is.null <- base::is.null
[17:02:32.295]                       muffled <- FALSE
[17:02:32.295]                       if (inherits(cond, "message")) {
[17:02:32.295]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.295]                         if (muffled) 
[17:02:32.295]                           invokeRestart("muffleMessage")
[17:02:32.295]                       }
[17:02:32.295]                       else if (inherits(cond, "warning")) {
[17:02:32.295]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.295]                         if (muffled) 
[17:02:32.295]                           invokeRestart("muffleWarning")
[17:02:32.295]                       }
[17:02:32.295]                       else if (inherits(cond, "condition")) {
[17:02:32.295]                         if (!is.null(pattern)) {
[17:02:32.295]                           computeRestarts <- base::computeRestarts
[17:02:32.295]                           grepl <- base::grepl
[17:02:32.295]                           restarts <- computeRestarts(cond)
[17:02:32.295]                           for (restart in restarts) {
[17:02:32.295]                             name <- restart$name
[17:02:32.295]                             if (is.null(name)) 
[17:02:32.295]                               next
[17:02:32.295]                             if (!grepl(pattern, name)) 
[17:02:32.295]                               next
[17:02:32.295]                             invokeRestart(restart)
[17:02:32.295]                             muffled <- TRUE
[17:02:32.295]                             break
[17:02:32.295]                           }
[17:02:32.295]                         }
[17:02:32.295]                       }
[17:02:32.295]                       invisible(muffled)
[17:02:32.295]                     }
[17:02:32.295]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.295]                   }
[17:02:32.295]                 }
[17:02:32.295]             }
[17:02:32.295]         }))
[17:02:32.295]     }, error = function(ex) {
[17:02:32.295]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.295]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.295]                 ...future.rng), started = ...future.startTime, 
[17:02:32.295]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.295]             version = "1.8"), class = "FutureResult")
[17:02:32.295]     }, finally = {
[17:02:32.295]         if (!identical(...future.workdir, getwd())) 
[17:02:32.295]             setwd(...future.workdir)
[17:02:32.295]         {
[17:02:32.295]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.295]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.295]             }
[17:02:32.295]             base::options(...future.oldOptions)
[17:02:32.295]             if (.Platform$OS.type == "windows") {
[17:02:32.295]                 old_names <- names(...future.oldEnvVars)
[17:02:32.295]                 envs <- base::Sys.getenv()
[17:02:32.295]                 names <- names(envs)
[17:02:32.295]                 common <- intersect(names, old_names)
[17:02:32.295]                 added <- setdiff(names, old_names)
[17:02:32.295]                 removed <- setdiff(old_names, names)
[17:02:32.295]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.295]                   envs[common]]
[17:02:32.295]                 NAMES <- toupper(changed)
[17:02:32.295]                 args <- list()
[17:02:32.295]                 for (kk in seq_along(NAMES)) {
[17:02:32.295]                   name <- changed[[kk]]
[17:02:32.295]                   NAME <- NAMES[[kk]]
[17:02:32.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.295]                     next
[17:02:32.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.295]                 }
[17:02:32.295]                 NAMES <- toupper(added)
[17:02:32.295]                 for (kk in seq_along(NAMES)) {
[17:02:32.295]                   name <- added[[kk]]
[17:02:32.295]                   NAME <- NAMES[[kk]]
[17:02:32.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.295]                     next
[17:02:32.295]                   args[[name]] <- ""
[17:02:32.295]                 }
[17:02:32.295]                 NAMES <- toupper(removed)
[17:02:32.295]                 for (kk in seq_along(NAMES)) {
[17:02:32.295]                   name <- removed[[kk]]
[17:02:32.295]                   NAME <- NAMES[[kk]]
[17:02:32.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.295]                     next
[17:02:32.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.295]                 }
[17:02:32.295]                 if (length(args) > 0) 
[17:02:32.295]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.295]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.295]             }
[17:02:32.295]             else {
[17:02:32.295]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.295]             }
[17:02:32.295]             {
[17:02:32.295]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.295]                   0L) {
[17:02:32.295]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.295]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.295]                   base::options(opts)
[17:02:32.295]                 }
[17:02:32.295]                 {
[17:02:32.295]                   {
[17:02:32.295]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.295]                     NULL
[17:02:32.295]                   }
[17:02:32.295]                   options(future.plan = NULL)
[17:02:32.295]                   if (is.na(NA_character_)) 
[17:02:32.295]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.295]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.295]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.295]                     .init = FALSE)
[17:02:32.295]                 }
[17:02:32.295]             }
[17:02:32.295]         }
[17:02:32.295]     })
[17:02:32.295]     if (TRUE) {
[17:02:32.295]         base::sink(type = "output", split = FALSE)
[17:02:32.295]         if (TRUE) {
[17:02:32.295]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.295]         }
[17:02:32.295]         else {
[17:02:32.295]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.295]         }
[17:02:32.295]         base::close(...future.stdout)
[17:02:32.295]         ...future.stdout <- NULL
[17:02:32.295]     }
[17:02:32.295]     ...future.result$conditions <- ...future.conditions
[17:02:32.295]     ...future.result$finished <- base::Sys.time()
[17:02:32.295]     ...future.result
[17:02:32.295] }
[17:02:32.298] requestCore(): workers = 2
[17:02:32.299] Poll #1 (0): usedCores() = 2, workers = 2
[17:02:32.310] result() for MulticoreFuture ...
[17:02:32.310] result() for MulticoreFuture ...
[17:02:32.311] result() for MulticoreFuture ... done
[17:02:32.311] result() for MulticoreFuture ... done
[17:02:32.311] result() for MulticoreFuture ...
[17:02:32.311] result() for MulticoreFuture ... done
[17:02:32.314] MulticoreFuture started
[17:02:32.314] - Launch lazy future ... done
[17:02:32.315] run() for ‘MulticoreFuture’ ... done
[17:02:32.315] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55c7493cef60> 
[17:02:32.316] List of future strategies:
[17:02:32.316] 1. sequential:
[17:02:32.316]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.316]    - tweaked: FALSE
[17:02:32.316]    - call: NULL
[17:02:32.317] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55c74a906ed8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=[17:02:32.320] plan(): Setting new future strategy stack:
List of 2
  ..$ :[17:02:32.320] List of future strategies:
[17:02:32.320] 1. multicore:
[17:02:32.320]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.320]    - tweaked: FALSE
[17:02:32.320]    - call: plan(strategy)
 chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:02:32.326] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:32.330] resolve() on list environment ...
[17:02:32.330]  recursive: 0
[17:02:32.331]  length: 6
[17:02:32.332]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:32.332] signalConditionsASAP(numeric, pos=1) ...
[17:02:32.332] - nx: 6
[17:02:32.332] - relay: TRUE
[17:02:32.332] - stdout: TRUE
[17:02:32.332] - signal: TRUE
[17:02:32.332] - resignal: FALSE
[17:02:32.333] - force: TRUE
[17:02:32.333] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.333] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.333]  - until=2
[17:02:32.333]  - relaying element #2
[17:02:32.333] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.333] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.333] signalConditionsASAP(NULL, pos=1) ... done
[17:02:32.334]  length: 5 (resolved future 1)
[17:02:32.334] Future #2
[17:02:32.334] result() for MulticoreFuture ...
[17:02:32.334] result() for MulticoreFuture ... done
[17:02:32.334] result() for MulticoreFuture ...
[17:02:32.334] result() for MulticoreFuture ... done
[17:02:32.335] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:32.335] - nx: 6
[17:02:32.335] - relay: TRUE
[17:02:32.335] - stdout: TRUE
[17:02:32.335] - signal: TRUE
[17:02:32.335] - resignal: FALSE
[17:02:32.335] - force: TRUE
[17:02:32.335] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.335] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.336]  - until=2
[17:02:32.336]  - relaying element #2
[17:02:32.336] result() for MulticoreFuture ...
[17:02:32.336] result() for MulticoreFuture ... done
[17:02:32.336] result() for MulticoreFuture ...
[17:02:32.336] result() for MulticoreFuture ... done
[17:02:32.336] result() for MulticoreFuture ...
[17:02:32.337] result() for MulticoreFuture ... done
[17:02:32.337] result() for MulticoreFuture ...
[17:02:32.337] result() for MulticoreFuture ... done
[17:02:32.337] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.337] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.337] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:32.337]  length: 4 (resolved future 2)
[17:02:32.338] Future #3
[17:02:32.338] result() for MulticoreFuture ...
[17:02:32.339] result() for MulticoreFuture ...
[17:02:32.339] result() for MulticoreFuture ... done
[17:02:32.339] result() for MulticoreFuture ... done
[17:02:32.339] result() for MulticoreFuture ...
[17:02:32.339] result() for MulticoreFuture ... done
[17:02:32.340] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:32.340] - nx: 6
[17:02:32.340] - relay: TRUE
[17:02:32.340] - stdout: TRUE
[17:02:32.340] - signal: TRUE
[17:02:32.340] - resignal: FALSE
[17:02:32.341] - force: TRUE
[17:02:32.341] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.341] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.341]  - until=3
[17:02:32.341]  - relaying element #3
[17:02:32.341] result() for MulticoreFuture ...
[17:02:32.342] result() for MulticoreFuture ... done
[17:02:32.342] result() for MulticoreFuture ...
[17:02:32.342] result() for MulticoreFuture ... done
[17:02:32.342] result() for MulticoreFuture ...
[17:02:32.342] result() for MulticoreFuture ... done
[17:02:32.342] result() for MulticoreFuture ...
[17:02:32.343] result() for MulticoreFuture ... done
[17:02:32.343] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.343] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.343] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:32.343]  length: 3 (resolved future 3)
[17:02:32.344] Future #4
[17:02:32.344] result() for MulticoreFuture ...
[17:02:32.345] result() for MulticoreFuture ...
[17:02:32.345] result() for MulticoreFuture ... done
[17:02:32.345] result() for MulticoreFuture ... done
[17:02:32.345] result() for MulticoreFuture ...
[17:02:32.345] result() for MulticoreFuture ... done
[17:02:32.346] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:02:32.346] - nx: 6
[17:02:32.346] - relay: TRUE
[17:02:32.346] - stdout: TRUE
[17:02:32.346] - signal: TRUE
[17:02:32.346] - resignal: FALSE
[17:02:32.346] - force: TRUE
[17:02:32.347] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.347] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.347]  - until=4
[17:02:32.347]  - relaying element #4
[17:02:32.347] result() for MulticoreFuture ...
[17:02:32.348] result() for MulticoreFuture ... done
[17:02:32.348] result() for MulticoreFuture ...
[17:02:32.348] result() for MulticoreFuture ... done
[17:02:32.348] result() for MulticoreFuture ...
[17:02:32.348] result() for MulticoreFuture ... done
[17:02:32.348] result() for MulticoreFuture ...
[17:02:32.348] result() for MulticoreFuture ... done
[17:02:32.349] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.349] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.349] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:02:32.349]  length: 2 (resolved future 4)
[17:02:32.349] signalConditionsASAP(NULL, pos=5) ...
[17:02:32.349] - nx: 6
[17:02:32.349] - relay: TRUE
[17:02:32.349] - stdout: TRUE
[17:02:32.350] - signal: TRUE
[17:02:32.350] - resignal: FALSE
[17:02:32.350] - force: TRUE
[17:02:32.350] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.350] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.350]  - until=6
[17:02:32.350]  - relaying element #6
[17:02:32.350] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:32.350] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.350] signalConditionsASAP(NULL, pos=5) ... done
[17:02:32.351]  length: 1 (resolved future 5)
[17:02:32.351] signalConditionsASAP(numeric, pos=6) ...
[17:02:32.351] - nx: 6
[17:02:32.351] - relay: TRUE
[17:02:32.351] - stdout: TRUE
[17:02:32.351] - signal: TRUE
[17:02:32.351] - resignal: FALSE
[17:02:32.351] - force: TRUE
[17:02:32.351] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:32.351] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.352]  - until=6
[17:02:32.352] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.352] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.352] signalConditionsASAP(numeric, pos=6) ... done
[17:02:32.352]  length: 0 (resolved future 6)
[17:02:32.352] Relaying remaining futures
[17:02:32.352] signalConditionsASAP(NULL, pos=0) ...
[17:02:32.352] - nx: 6
[17:02:32.352] - relay: TRUE
[17:02:32.352] - stdout: TRUE
[17:02:32.353] - signal: TRUE
[17:02:32.353] - resignal: FALSE
[17:02:32.353] - force: TRUE
[17:02:32.353] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.353] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:32.353] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.353] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.353] signalConditionsASAP(NULL, pos=0) ... done
[17:02:32.353] resolve() on list environment ... DONE
[17:02:32.354] result() for MulticoreFuture ...
[17:02:32.354] result() for MulticoreFuture ... done
[17:02:32.354] result() for MulticoreFuture ...
[17:02:32.354] result() for MulticoreFuture ... done
[17:02:32.354] result() for MulticoreFuture ...
[17:02:32.354] result() for MulticoreFuture ... done
[17:02:32.354] result() for MulticoreFuture ...
[17:02:32.354] result() for MulticoreFuture ... done
[17:02:32.355] result() for MulticoreFuture ...
[17:02:32.355] result() for MulticoreFuture ... done
[17:02:32.355] result() for MulticoreFuture ...
[17:02:32.355] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c74ac53ea0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:02:32.357] getGlobalsAndPackages() ...
[17:02:32.357] Searching for globals...
[17:02:32.358] 
[17:02:32.358] Searching for globals ... DONE
[17:02:32.358] - globals: [0] <none>
[17:02:32.358] getGlobalsAndPackages() ... DONE
[17:02:32.358] run() for ‘Future’ ...
[17:02:32.358] - state: ‘created’
[17:02:32.359] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.363] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.363] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.364]   - Field: ‘label’
[17:02:32.364]   - Field: ‘local’
[17:02:32.364]   - Field: ‘owner’
[17:02:32.364]   - Field: ‘envir’
[17:02:32.364]   - Field: ‘workers’
[17:02:32.364]   - Field: ‘packages’
[17:02:32.364]   - Field: ‘gc’
[17:02:32.365]   - Field: ‘job’
[17:02:32.365]   - Field: ‘conditions’
[17:02:32.365]   - Field: ‘expr’
[17:02:32.365]   - Field: ‘uuid’
[17:02:32.365]   - Field: ‘seed’
[17:02:32.365]   - Field: ‘version’
[17:02:32.365]   - Field: ‘result’
[17:02:32.365]   - Field: ‘asynchronous’
[17:02:32.366]   - Field: ‘calls’
[17:02:32.366]   - Field: ‘globals’
[17:02:32.366]   - Field: ‘stdout’
[17:02:32.366]   - Field: ‘earlySignal’
[17:02:32.366]   - Field: ‘lazy’
[17:02:32.366]   - Field: ‘state’
[17:02:32.370] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.370] - Launch lazy future ...
[17:02:32.371] Packages needed by the future expression (n = 0): <none>
[17:02:32.371] Packages needed by future strategies (n = 0): <none>
[17:02:32.372] {
[17:02:32.372]     {
[17:02:32.372]         {
[17:02:32.372]             ...future.startTime <- base::Sys.time()
[17:02:32.372]             {
[17:02:32.372]                 {
[17:02:32.372]                   {
[17:02:32.372]                     {
[17:02:32.372]                       base::local({
[17:02:32.372]                         has_future <- base::requireNamespace("future", 
[17:02:32.372]                           quietly = TRUE)
[17:02:32.372]                         if (has_future) {
[17:02:32.372]                           ns <- base::getNamespace("future")
[17:02:32.372]                           version <- ns[[".package"]][["version"]]
[17:02:32.372]                           if (is.null(version)) 
[17:02:32.372]                             version <- utils::packageVersion("future")
[17:02:32.372]                         }
[17:02:32.372]                         else {
[17:02:32.372]                           version <- NULL
[17:02:32.372]                         }
[17:02:32.372]                         if (!has_future || version < "1.8.0") {
[17:02:32.372]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.372]                             "", base::R.version$version.string), 
[17:02:32.372]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.372]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.372]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.372]                               "release", "version")], collapse = " "), 
[17:02:32.372]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.372]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.372]                             info)
[17:02:32.372]                           info <- base::paste(info, collapse = "; ")
[17:02:32.372]                           if (!has_future) {
[17:02:32.372]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.372]                               info)
[17:02:32.372]                           }
[17:02:32.372]                           else {
[17:02:32.372]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.372]                               info, version)
[17:02:32.372]                           }
[17:02:32.372]                           base::stop(msg)
[17:02:32.372]                         }
[17:02:32.372]                       })
[17:02:32.372]                     }
[17:02:32.372]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.372]                     base::options(mc.cores = 1L)
[17:02:32.372]                   }
[17:02:32.372]                   ...future.strategy.old <- future::plan("list")
[17:02:32.372]                   options(future.plan = NULL)
[17:02:32.372]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.372]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.372]                 }
[17:02:32.372]                 ...future.workdir <- getwd()
[17:02:32.372]             }
[17:02:32.372]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.372]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.372]         }
[17:02:32.372]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.372]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.372]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.372]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.372]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.372]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.372]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.372]             base::names(...future.oldOptions))
[17:02:32.372]     }
[17:02:32.372]     if (FALSE) {
[17:02:32.372]     }
[17:02:32.372]     else {
[17:02:32.372]         if (TRUE) {
[17:02:32.372]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.372]                 open = "w")
[17:02:32.372]         }
[17:02:32.372]         else {
[17:02:32.372]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.372]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.372]         }
[17:02:32.372]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.372]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.372]             base::sink(type = "output", split = FALSE)
[17:02:32.372]             base::close(...future.stdout)
[17:02:32.372]         }, add = TRUE)
[17:02:32.372]     }
[17:02:32.372]     ...future.frame <- base::sys.nframe()
[17:02:32.372]     ...future.conditions <- base::list()
[17:02:32.372]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.372]     if (FALSE) {
[17:02:32.372]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.372]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.372]     }
[17:02:32.372]     ...future.result <- base::tryCatch({
[17:02:32.372]         base::withCallingHandlers({
[17:02:32.372]             ...future.value <- base::withVisible(base::local({
[17:02:32.372]                 withCallingHandlers({
[17:02:32.372]                   2
[17:02:32.372]                 }, immediateCondition = function(cond) {
[17:02:32.372]                   save_rds <- function (object, pathname, ...) 
[17:02:32.372]                   {
[17:02:32.372]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.372]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.372]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.372]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.372]                         fi_tmp[["mtime"]])
[17:02:32.372]                     }
[17:02:32.372]                     tryCatch({
[17:02:32.372]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.372]                     }, error = function(ex) {
[17:02:32.372]                       msg <- conditionMessage(ex)
[17:02:32.372]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.372]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.372]                         fi_tmp[["mtime"]], msg)
[17:02:32.372]                       ex$message <- msg
[17:02:32.372]                       stop(ex)
[17:02:32.372]                     })
[17:02:32.372]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.372]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.372]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.372]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.372]                       fi <- file.info(pathname)
[17:02:32.372]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.372]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.372]                         fi[["size"]], fi[["mtime"]])
[17:02:32.372]                       stop(msg)
[17:02:32.372]                     }
[17:02:32.372]                     invisible(pathname)
[17:02:32.372]                   }
[17:02:32.372]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.372]                     rootPath = tempdir()) 
[17:02:32.372]                   {
[17:02:32.372]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.372]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.372]                       tmpdir = path, fileext = ".rds")
[17:02:32.372]                     save_rds(obj, file)
[17:02:32.372]                   }
[17:02:32.372]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.372]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.372]                   {
[17:02:32.372]                     inherits <- base::inherits
[17:02:32.372]                     invokeRestart <- base::invokeRestart
[17:02:32.372]                     is.null <- base::is.null
[17:02:32.372]                     muffled <- FALSE
[17:02:32.372]                     if (inherits(cond, "message")) {
[17:02:32.372]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.372]                       if (muffled) 
[17:02:32.372]                         invokeRestart("muffleMessage")
[17:02:32.372]                     }
[17:02:32.372]                     else if (inherits(cond, "warning")) {
[17:02:32.372]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.372]                       if (muffled) 
[17:02:32.372]                         invokeRestart("muffleWarning")
[17:02:32.372]                     }
[17:02:32.372]                     else if (inherits(cond, "condition")) {
[17:02:32.372]                       if (!is.null(pattern)) {
[17:02:32.372]                         computeRestarts <- base::computeRestarts
[17:02:32.372]                         grepl <- base::grepl
[17:02:32.372]                         restarts <- computeRestarts(cond)
[17:02:32.372]                         for (restart in restarts) {
[17:02:32.372]                           name <- restart$name
[17:02:32.372]                           if (is.null(name)) 
[17:02:32.372]                             next
[17:02:32.372]                           if (!grepl(pattern, name)) 
[17:02:32.372]                             next
[17:02:32.372]                           invokeRestart(restart)
[17:02:32.372]                           muffled <- TRUE
[17:02:32.372]                           break
[17:02:32.372]                         }
[17:02:32.372]                       }
[17:02:32.372]                     }
[17:02:32.372]                     invisible(muffled)
[17:02:32.372]                   }
[17:02:32.372]                   muffleCondition(cond)
[17:02:32.372]                 })
[17:02:32.372]             }))
[17:02:32.372]             future::FutureResult(value = ...future.value$value, 
[17:02:32.372]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.372]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.372]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.372]                     ...future.globalenv.names))
[17:02:32.372]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.372]         }, condition = base::local({
[17:02:32.372]             c <- base::c
[17:02:32.372]             inherits <- base::inherits
[17:02:32.372]             invokeRestart <- base::invokeRestart
[17:02:32.372]             length <- base::length
[17:02:32.372]             list <- base::list
[17:02:32.372]             seq.int <- base::seq.int
[17:02:32.372]             signalCondition <- base::signalCondition
[17:02:32.372]             sys.calls <- base::sys.calls
[17:02:32.372]             `[[` <- base::`[[`
[17:02:32.372]             `+` <- base::`+`
[17:02:32.372]             `<<-` <- base::`<<-`
[17:02:32.372]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.372]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.372]                   3L)]
[17:02:32.372]             }
[17:02:32.372]             function(cond) {
[17:02:32.372]                 is_error <- inherits(cond, "error")
[17:02:32.372]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.372]                   NULL)
[17:02:32.372]                 if (is_error) {
[17:02:32.372]                   sessionInformation <- function() {
[17:02:32.372]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.372]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.372]                       search = base::search(), system = base::Sys.info())
[17:02:32.372]                   }
[17:02:32.372]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.372]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.372]                     cond$call), session = sessionInformation(), 
[17:02:32.372]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.372]                   signalCondition(cond)
[17:02:32.372]                 }
[17:02:32.372]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.372]                 "immediateCondition"))) {
[17:02:32.372]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.372]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.372]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.372]                   if (TRUE && !signal) {
[17:02:32.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.372]                     {
[17:02:32.372]                       inherits <- base::inherits
[17:02:32.372]                       invokeRestart <- base::invokeRestart
[17:02:32.372]                       is.null <- base::is.null
[17:02:32.372]                       muffled <- FALSE
[17:02:32.372]                       if (inherits(cond, "message")) {
[17:02:32.372]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.372]                         if (muffled) 
[17:02:32.372]                           invokeRestart("muffleMessage")
[17:02:32.372]                       }
[17:02:32.372]                       else if (inherits(cond, "warning")) {
[17:02:32.372]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.372]                         if (muffled) 
[17:02:32.372]                           invokeRestart("muffleWarning")
[17:02:32.372]                       }
[17:02:32.372]                       else if (inherits(cond, "condition")) {
[17:02:32.372]                         if (!is.null(pattern)) {
[17:02:32.372]                           computeRestarts <- base::computeRestarts
[17:02:32.372]                           grepl <- base::grepl
[17:02:32.372]                           restarts <- computeRestarts(cond)
[17:02:32.372]                           for (restart in restarts) {
[17:02:32.372]                             name <- restart$name
[17:02:32.372]                             if (is.null(name)) 
[17:02:32.372]                               next
[17:02:32.372]                             if (!grepl(pattern, name)) 
[17:02:32.372]                               next
[17:02:32.372]                             invokeRestart(restart)
[17:02:32.372]                             muffled <- TRUE
[17:02:32.372]                             break
[17:02:32.372]                           }
[17:02:32.372]                         }
[17:02:32.372]                       }
[17:02:32.372]                       invisible(muffled)
[17:02:32.372]                     }
[17:02:32.372]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.372]                   }
[17:02:32.372]                 }
[17:02:32.372]                 else {
[17:02:32.372]                   if (TRUE) {
[17:02:32.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.372]                     {
[17:02:32.372]                       inherits <- base::inherits
[17:02:32.372]                       invokeRestart <- base::invokeRestart
[17:02:32.372]                       is.null <- base::is.null
[17:02:32.372]                       muffled <- FALSE
[17:02:32.372]                       if (inherits(cond, "message")) {
[17:02:32.372]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.372]                         if (muffled) 
[17:02:32.372]                           invokeRestart("muffleMessage")
[17:02:32.372]                       }
[17:02:32.372]                       else if (inherits(cond, "warning")) {
[17:02:32.372]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.372]                         if (muffled) 
[17:02:32.372]                           invokeRestart("muffleWarning")
[17:02:32.372]                       }
[17:02:32.372]                       else if (inherits(cond, "condition")) {
[17:02:32.372]                         if (!is.null(pattern)) {
[17:02:32.372]                           computeRestarts <- base::computeRestarts
[17:02:32.372]                           grepl <- base::grepl
[17:02:32.372]                           restarts <- computeRestarts(cond)
[17:02:32.372]                           for (restart in restarts) {
[17:02:32.372]                             name <- restart$name
[17:02:32.372]                             if (is.null(name)) 
[17:02:32.372]                               next
[17:02:32.372]                             if (!grepl(pattern, name)) 
[17:02:32.372]                               next
[17:02:32.372]                             invokeRestart(restart)
[17:02:32.372]                             muffled <- TRUE
[17:02:32.372]                             break
[17:02:32.372]                           }
[17:02:32.372]                         }
[17:02:32.372]                       }
[17:02:32.372]                       invisible(muffled)
[17:02:32.372]                     }
[17:02:32.372]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.372]                   }
[17:02:32.372]                 }
[17:02:32.372]             }
[17:02:32.372]         }))
[17:02:32.372]     }, error = function(ex) {
[17:02:32.372]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.372]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.372]                 ...future.rng), started = ...future.startTime, 
[17:02:32.372]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.372]             version = "1.8"), class = "FutureResult")
[17:02:32.372]     }, finally = {
[17:02:32.372]         if (!identical(...future.workdir, getwd())) 
[17:02:32.372]             setwd(...future.workdir)
[17:02:32.372]         {
[17:02:32.372]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.372]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.372]             }
[17:02:32.372]             base::options(...future.oldOptions)
[17:02:32.372]             if (.Platform$OS.type == "windows") {
[17:02:32.372]                 old_names <- names(...future.oldEnvVars)
[17:02:32.372]                 envs <- base::Sys.getenv()
[17:02:32.372]                 names <- names(envs)
[17:02:32.372]                 common <- intersect(names, old_names)
[17:02:32.372]                 added <- setdiff(names, old_names)
[17:02:32.372]                 removed <- setdiff(old_names, names)
[17:02:32.372]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.372]                   envs[common]]
[17:02:32.372]                 NAMES <- toupper(changed)
[17:02:32.372]                 args <- list()
[17:02:32.372]                 for (kk in seq_along(NAMES)) {
[17:02:32.372]                   name <- changed[[kk]]
[17:02:32.372]                   NAME <- NAMES[[kk]]
[17:02:32.372]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.372]                     next
[17:02:32.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.372]                 }
[17:02:32.372]                 NAMES <- toupper(added)
[17:02:32.372]                 for (kk in seq_along(NAMES)) {
[17:02:32.372]                   name <- added[[kk]]
[17:02:32.372]                   NAME <- NAMES[[kk]]
[17:02:32.372]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.372]                     next
[17:02:32.372]                   args[[name]] <- ""
[17:02:32.372]                 }
[17:02:32.372]                 NAMES <- toupper(removed)
[17:02:32.372]                 for (kk in seq_along(NAMES)) {
[17:02:32.372]                   name <- removed[[kk]]
[17:02:32.372]                   NAME <- NAMES[[kk]]
[17:02:32.372]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.372]                     next
[17:02:32.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.372]                 }
[17:02:32.372]                 if (length(args) > 0) 
[17:02:32.372]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.372]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.372]             }
[17:02:32.372]             else {
[17:02:32.372]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.372]             }
[17:02:32.372]             {
[17:02:32.372]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.372]                   0L) {
[17:02:32.372]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.372]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.372]                   base::options(opts)
[17:02:32.372]                 }
[17:02:32.372]                 {
[17:02:32.372]                   {
[17:02:32.372]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.372]                     NULL
[17:02:32.372]                   }
[17:02:32.372]                   options(future.plan = NULL)
[17:02:32.372]                   if (is.na(NA_character_)) 
[17:02:32.372]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.372]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.372]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.372]                     .init = FALSE)
[17:02:32.372]                 }
[17:02:32.372]             }
[17:02:32.372]         }
[17:02:32.372]     })
[17:02:32.372]     if (TRUE) {
[17:02:32.372]         base::sink(type = "output", split = FALSE)
[17:02:32.372]         if (TRUE) {
[17:02:32.372]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.372]         }
[17:02:32.372]         else {
[17:02:32.372]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.372]         }
[17:02:32.372]         base::close(...future.stdout)
[17:02:32.372]         ...future.stdout <- NULL
[17:02:32.372]     }
[17:02:32.372]     ...future.result$conditions <- ...future.conditions
[17:02:32.372]     ...future.result$finished <- base::Sys.time()
[17:02:32.372]     ...future.result
[17:02:32.372] }
[17:02:32.374] requestCore(): workers = 2
[17:02:32.377] MulticoreFuture started
[17:02:32.377] - Launch lazy future ... done
[17:02:32.377] run() for ‘MulticoreFuture’ ... done
[17:02:32.378] getGlobalsAndPackages() ...
[17:02:32.378] plan(): Setting new future strategy stack:
[17:02:32.378] Searching for globals...
[17:02:32.378] List of future strategies:
[17:02:32.378] 1. sequential:
[17:02:32.378]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.378]    - tweaked: FALSE
[17:02:32.378]    - call: NULL
[17:02:32.379] 
[17:02:32.379] Searching for globals ... DONE
[17:02:32.379] plan(): nbrOfWorkers() = 1
[17:02:32.380] - globals: [0] <none>
[17:02:32.380] getGlobalsAndPackages() ... DONE
[17:02:32.380] run() for ‘Future’ ...
[17:02:32.380] - state: ‘created’
[17:02:32.381] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.381] plan(): Setting new future strategy stack:
[17:02:32.382] List of future strategies:
[17:02:32.382] 1. multicore:
[17:02:32.382]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.382]    - tweaked: FALSE
[17:02:32.382]    - call: plan(strategy)
[17:02:32.386] plan(): nbrOfWorkers() = 2
[17:02:32.386] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.387] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.387]   - Field: ‘label’
[17:02:32.387]   - Field: ‘local’
[17:02:32.387]   - Field: ‘owner’
[17:02:32.387]   - Field: ‘envir’
[17:02:32.388]   - Field: ‘workers’
[17:02:32.388]   - Field: ‘packages’
[17:02:32.388]   - Field: ‘gc’
[17:02:32.388]   - Field: ‘job’
[17:02:32.388]   - Field: ‘conditions’
[17:02:32.388]   - Field: ‘expr’
[17:02:32.389]   - Field: ‘uuid’
[17:02:32.389]   - Field: ‘seed’
[17:02:32.389]   - Field: ‘version’
[17:02:32.389]   - Field: ‘result’
[17:02:32.389]   - Field: ‘asynchronous’
[17:02:32.389]   - Field: ‘calls’
[17:02:32.389]   - Field: ‘globals’
[17:02:32.390]   - Field: ‘stdout’
[17:02:32.390]   - Field: ‘earlySignal’
[17:02:32.390]   - Field: ‘lazy’
[17:02:32.390]   - Field: ‘state’
[17:02:32.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.390] - Launch lazy future ...
[17:02:32.391] Packages needed by the future expression (n = 0): <none>
[17:02:32.391] Packages needed by future strategies (n = 0): <none>
[17:02:32.392] {
[17:02:32.392]     {
[17:02:32.392]         {
[17:02:32.392]             ...future.startTime <- base::Sys.time()
[17:02:32.392]             {
[17:02:32.392]                 {
[17:02:32.392]                   {
[17:02:32.392]                     {
[17:02:32.392]                       base::local({
[17:02:32.392]                         has_future <- base::requireNamespace("future", 
[17:02:32.392]                           quietly = TRUE)
[17:02:32.392]                         if (has_future) {
[17:02:32.392]                           ns <- base::getNamespace("future")
[17:02:32.392]                           version <- ns[[".package"]][["version"]]
[17:02:32.392]                           if (is.null(version)) 
[17:02:32.392]                             version <- utils::packageVersion("future")
[17:02:32.392]                         }
[17:02:32.392]                         else {
[17:02:32.392]                           version <- NULL
[17:02:32.392]                         }
[17:02:32.392]                         if (!has_future || version < "1.8.0") {
[17:02:32.392]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.392]                             "", base::R.version$version.string), 
[17:02:32.392]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.392]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.392]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.392]                               "release", "version")], collapse = " "), 
[17:02:32.392]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.392]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.392]                             info)
[17:02:32.392]                           info <- base::paste(info, collapse = "; ")
[17:02:32.392]                           if (!has_future) {
[17:02:32.392]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.392]                               info)
[17:02:32.392]                           }
[17:02:32.392]                           else {
[17:02:32.392]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.392]                               info, version)
[17:02:32.392]                           }
[17:02:32.392]                           base::stop(msg)
[17:02:32.392]                         }
[17:02:32.392]                       })
[17:02:32.392]                     }
[17:02:32.392]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.392]                     base::options(mc.cores = 1L)
[17:02:32.392]                   }
[17:02:32.392]                   ...future.strategy.old <- future::plan("list")
[17:02:32.392]                   options(future.plan = NULL)
[17:02:32.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.392]                 }
[17:02:32.392]                 ...future.workdir <- getwd()
[17:02:32.392]             }
[17:02:32.392]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.392]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.392]         }
[17:02:32.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.392]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.392]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.392]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.392]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.392]             base::names(...future.oldOptions))
[17:02:32.392]     }
[17:02:32.392]     if (FALSE) {
[17:02:32.392]     }
[17:02:32.392]     else {
[17:02:32.392]         if (TRUE) {
[17:02:32.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.392]                 open = "w")
[17:02:32.392]         }
[17:02:32.392]         else {
[17:02:32.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.392]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.392]         }
[17:02:32.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.392]             base::sink(type = "output", split = FALSE)
[17:02:32.392]             base::close(...future.stdout)
[17:02:32.392]         }, add = TRUE)
[17:02:32.392]     }
[17:02:32.392]     ...future.frame <- base::sys.nframe()
[17:02:32.392]     ...future.conditions <- base::list()
[17:02:32.392]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.392]     if (FALSE) {
[17:02:32.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.392]     }
[17:02:32.392]     ...future.result <- base::tryCatch({
[17:02:32.392]         base::withCallingHandlers({
[17:02:32.392]             ...future.value <- base::withVisible(base::local({
[17:02:32.392]                 withCallingHandlers({
[17:02:32.392]                   NULL
[17:02:32.392]                 }, immediateCondition = function(cond) {
[17:02:32.392]                   save_rds <- function (object, pathname, ...) 
[17:02:32.392]                   {
[17:02:32.392]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.392]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.392]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.392]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.392]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.392]                         fi_tmp[["mtime"]])
[17:02:32.392]                     }
[17:02:32.392]                     tryCatch({
[17:02:32.392]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.392]                     }, error = function(ex) {
[17:02:32.392]                       msg <- conditionMessage(ex)
[17:02:32.392]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.392]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.392]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.392]                         fi_tmp[["mtime"]], msg)
[17:02:32.392]                       ex$message <- msg
[17:02:32.392]                       stop(ex)
[17:02:32.392]                     })
[17:02:32.392]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.392]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.392]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.392]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.392]                       fi <- file.info(pathname)
[17:02:32.392]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.392]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.392]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.392]                         fi[["size"]], fi[["mtime"]])
[17:02:32.392]                       stop(msg)
[17:02:32.392]                     }
[17:02:32.392]                     invisible(pathname)
[17:02:32.392]                   }
[17:02:32.392]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.392]                     rootPath = tempdir()) 
[17:02:32.392]                   {
[17:02:32.392]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.392]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.392]                       tmpdir = path, fileext = ".rds")
[17:02:32.392]                     save_rds(obj, file)
[17:02:32.392]                   }
[17:02:32.392]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.392]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.392]                   {
[17:02:32.392]                     inherits <- base::inherits
[17:02:32.392]                     invokeRestart <- base::invokeRestart
[17:02:32.392]                     is.null <- base::is.null
[17:02:32.392]                     muffled <- FALSE
[17:02:32.392]                     if (inherits(cond, "message")) {
[17:02:32.392]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.392]                       if (muffled) 
[17:02:32.392]                         invokeRestart("muffleMessage")
[17:02:32.392]                     }
[17:02:32.392]                     else if (inherits(cond, "warning")) {
[17:02:32.392]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.392]                       if (muffled) 
[17:02:32.392]                         invokeRestart("muffleWarning")
[17:02:32.392]                     }
[17:02:32.392]                     else if (inherits(cond, "condition")) {
[17:02:32.392]                       if (!is.null(pattern)) {
[17:02:32.392]                         computeRestarts <- base::computeRestarts
[17:02:32.392]                         grepl <- base::grepl
[17:02:32.392]                         restarts <- computeRestarts(cond)
[17:02:32.392]                         for (restart in restarts) {
[17:02:32.392]                           name <- restart$name
[17:02:32.392]                           if (is.null(name)) 
[17:02:32.392]                             next
[17:02:32.392]                           if (!grepl(pattern, name)) 
[17:02:32.392]                             next
[17:02:32.392]                           invokeRestart(restart)
[17:02:32.392]                           muffled <- TRUE
[17:02:32.392]                           break
[17:02:32.392]                         }
[17:02:32.392]                       }
[17:02:32.392]                     }
[17:02:32.392]                     invisible(muffled)
[17:02:32.392]                   }
[17:02:32.392]                   muffleCondition(cond)
[17:02:32.392]                 })
[17:02:32.392]             }))
[17:02:32.392]             future::FutureResult(value = ...future.value$value, 
[17:02:32.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.392]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.392]                     ...future.globalenv.names))
[17:02:32.392]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.392]         }, condition = base::local({
[17:02:32.392]             c <- base::c
[17:02:32.392]             inherits <- base::inherits
[17:02:32.392]             invokeRestart <- base::invokeRestart
[17:02:32.392]             length <- base::length
[17:02:32.392]             list <- base::list
[17:02:32.392]             seq.int <- base::seq.int
[17:02:32.392]             signalCondition <- base::signalCondition
[17:02:32.392]             sys.calls <- base::sys.calls
[17:02:32.392]             `[[` <- base::`[[`
[17:02:32.392]             `+` <- base::`+`
[17:02:32.392]             `<<-` <- base::`<<-`
[17:02:32.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.392]                   3L)]
[17:02:32.392]             }
[17:02:32.392]             function(cond) {
[17:02:32.392]                 is_error <- inherits(cond, "error")
[17:02:32.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.392]                   NULL)
[17:02:32.392]                 if (is_error) {
[17:02:32.392]                   sessionInformation <- function() {
[17:02:32.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.392]                       search = base::search(), system = base::Sys.info())
[17:02:32.392]                   }
[17:02:32.392]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.392]                     cond$call), session = sessionInformation(), 
[17:02:32.392]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.392]                   signalCondition(cond)
[17:02:32.392]                 }
[17:02:32.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.392]                 "immediateCondition"))) {
[17:02:32.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.392]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.392]                   if (TRUE && !signal) {
[17:02:32.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.392]                     {
[17:02:32.392]                       inherits <- base::inherits
[17:02:32.392]                       invokeRestart <- base::invokeRestart
[17:02:32.392]                       is.null <- base::is.null
[17:02:32.392]                       muffled <- FALSE
[17:02:32.392]                       if (inherits(cond, "message")) {
[17:02:32.392]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.392]                         if (muffled) 
[17:02:32.392]                           invokeRestart("muffleMessage")
[17:02:32.392]                       }
[17:02:32.392]                       else if (inherits(cond, "warning")) {
[17:02:32.392]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.392]                         if (muffled) 
[17:02:32.392]                           invokeRestart("muffleWarning")
[17:02:32.392]                       }
[17:02:32.392]                       else if (inherits(cond, "condition")) {
[17:02:32.392]                         if (!is.null(pattern)) {
[17:02:32.392]                           computeRestarts <- base::computeRestarts
[17:02:32.392]                           grepl <- base::grepl
[17:02:32.392]                           restarts <- computeRestarts(cond)
[17:02:32.392]                           for (restart in restarts) {
[17:02:32.392]                             name <- restart$name
[17:02:32.392]                             if (is.null(name)) 
[17:02:32.392]                               next
[17:02:32.392]                             if (!grepl(pattern, name)) 
[17:02:32.392]                               next
[17:02:32.392]                             invokeRestart(restart)
[17:02:32.392]                             muffled <- TRUE
[17:02:32.392]                             break
[17:02:32.392]                           }
[17:02:32.392]                         }
[17:02:32.392]                       }
[17:02:32.392]                       invisible(muffled)
[17:02:32.392]                     }
[17:02:32.392]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.392]                   }
[17:02:32.392]                 }
[17:02:32.392]                 else {
[17:02:32.392]                   if (TRUE) {
[17:02:32.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.392]                     {
[17:02:32.392]                       inherits <- base::inherits
[17:02:32.392]                       invokeRestart <- base::invokeRestart
[17:02:32.392]                       is.null <- base::is.null
[17:02:32.392]                       muffled <- FALSE
[17:02:32.392]                       if (inherits(cond, "message")) {
[17:02:32.392]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.392]                         if (muffled) 
[17:02:32.392]                           invokeRestart("muffleMessage")
[17:02:32.392]                       }
[17:02:32.392]                       else if (inherits(cond, "warning")) {
[17:02:32.392]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.392]                         if (muffled) 
[17:02:32.392]                           invokeRestart("muffleWarning")
[17:02:32.392]                       }
[17:02:32.392]                       else if (inherits(cond, "condition")) {
[17:02:32.392]                         if (!is.null(pattern)) {
[17:02:32.392]                           computeRestarts <- base::computeRestarts
[17:02:32.392]                           grepl <- base::grepl
[17:02:32.392]                           restarts <- computeRestarts(cond)
[17:02:32.392]                           for (restart in restarts) {
[17:02:32.392]                             name <- restart$name
[17:02:32.392]                             if (is.null(name)) 
[17:02:32.392]                               next
[17:02:32.392]                             if (!grepl(pattern, name)) 
[17:02:32.392]                               next
[17:02:32.392]                             invokeRestart(restart)
[17:02:32.392]                             muffled <- TRUE
[17:02:32.392]                             break
[17:02:32.392]                           }
[17:02:32.392]                         }
[17:02:32.392]                       }
[17:02:32.392]                       invisible(muffled)
[17:02:32.392]                     }
[17:02:32.392]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.392]                   }
[17:02:32.392]                 }
[17:02:32.392]             }
[17:02:32.392]         }))
[17:02:32.392]     }, error = function(ex) {
[17:02:32.392]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.392]                 ...future.rng), started = ...future.startTime, 
[17:02:32.392]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.392]             version = "1.8"), class = "FutureResult")
[17:02:32.392]     }, finally = {
[17:02:32.392]         if (!identical(...future.workdir, getwd())) 
[17:02:32.392]             setwd(...future.workdir)
[17:02:32.392]         {
[17:02:32.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.392]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.392]             }
[17:02:32.392]             base::options(...future.oldOptions)
[17:02:32.392]             if (.Platform$OS.type == "windows") {
[17:02:32.392]                 old_names <- names(...future.oldEnvVars)
[17:02:32.392]                 envs <- base::Sys.getenv()
[17:02:32.392]                 names <- names(envs)
[17:02:32.392]                 common <- intersect(names, old_names)
[17:02:32.392]                 added <- setdiff(names, old_names)
[17:02:32.392]                 removed <- setdiff(old_names, names)
[17:02:32.392]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.392]                   envs[common]]
[17:02:32.392]                 NAMES <- toupper(changed)
[17:02:32.392]                 args <- list()
[17:02:32.392]                 for (kk in seq_along(NAMES)) {
[17:02:32.392]                   name <- changed[[kk]]
[17:02:32.392]                   NAME <- NAMES[[kk]]
[17:02:32.392]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.392]                     next
[17:02:32.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.392]                 }
[17:02:32.392]                 NAMES <- toupper(added)
[17:02:32.392]                 for (kk in seq_along(NAMES)) {
[17:02:32.392]                   name <- added[[kk]]
[17:02:32.392]                   NAME <- NAMES[[kk]]
[17:02:32.392]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.392]                     next
[17:02:32.392]                   args[[name]] <- ""
[17:02:32.392]                 }
[17:02:32.392]                 NAMES <- toupper(removed)
[17:02:32.392]                 for (kk in seq_along(NAMES)) {
[17:02:32.392]                   name <- removed[[kk]]
[17:02:32.392]                   NAME <- NAMES[[kk]]
[17:02:32.392]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.392]                     next
[17:02:32.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.392]                 }
[17:02:32.392]                 if (length(args) > 0) 
[17:02:32.392]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.392]             }
[17:02:32.392]             else {
[17:02:32.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.392]             }
[17:02:32.392]             {
[17:02:32.392]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.392]                   0L) {
[17:02:32.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.392]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.392]                   base::options(opts)
[17:02:32.392]                 }
[17:02:32.392]                 {
[17:02:32.392]                   {
[17:02:32.392]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.392]                     NULL
[17:02:32.392]                   }
[17:02:32.392]                   options(future.plan = NULL)
[17:02:32.392]                   if (is.na(NA_character_)) 
[17:02:32.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.392]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.392]                     .init = FALSE)
[17:02:32.392]                 }
[17:02:32.392]             }
[17:02:32.392]         }
[17:02:32.392]     })
[17:02:32.392]     if (TRUE) {
[17:02:32.392]         base::sink(type = "output", split = FALSE)
[17:02:32.392]         if (TRUE) {
[17:02:32.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.392]         }
[17:02:32.392]         else {
[17:02:32.392]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.392]         }
[17:02:32.392]         base::close(...future.stdout)
[17:02:32.392]         ...future.stdout <- NULL
[17:02:32.392]     }
[17:02:32.392]     ...future.result$conditions <- ...future.conditions
[17:02:32.392]     ...future.result$finished <- base::Sys.time()
[17:02:32.392]     ...future.result
[17:02:32.392] }
[17:02:32.396] requestCore(): workers = 2
[17:02:32.399] MulticoreFuture started
[17:02:32.399] - Launch lazy future ... done
[17:02:32.399] run() for ‘MulticoreFuture’ ... done
[17:02:32.400] plan(): Setting new future strategy stack:
[17:02:32.400] getGlobalsAndPackages() ...
[17:02:32.400] Searching for globals...
[17:02:32.400] List of future strategies:
[17:02:32.400] 1. sequential:
[17:02:32.400]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.400]    - tweaked: FALSE
[17:02:32.400]    - call: NULL
[17:02:32.401] plan(): nbrOfWorkers() = 1
[17:02:32.402] - globals found: [1] ‘{’
[17:02:32.402] Searching for globals ... DONE
[17:02:32.402] Resolving globals: FALSE
[17:02:32.403] 
[17:02:32.403] 
[17:02:32.403] getGlobalsAndPackages() ... DONE
[17:02:32.403] plan(): Setting new future strategy stack:
[17:02:32.403] run() for ‘Future’ ...
[17:02:32.403] - state: ‘created’
[17:02:32.403] List of future strategies:
[17:02:32.403] 1. multicore:
[17:02:32.403]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.403]    - tweaked: FALSE
[17:02:32.403]    - call: plan(strategy)
[17:02:32.404] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.409] plan(): nbrOfWorkers() = 2
[17:02:32.409] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.409] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.409]   - Field: ‘label’
[17:02:32.410]   - Field: ‘local’
[17:02:32.410]   - Field: ‘owner’
[17:02:32.410]   - Field: ‘envir’
[17:02:32.410]   - Field: ‘workers’
[17:02:32.410]   - Field: ‘packages’
[17:02:32.410]   - Field: ‘gc’
[17:02:32.410]   - Field: ‘job’
[17:02:32.411]   - Field: ‘conditions’
[17:02:32.411]   - Field: ‘expr’
[17:02:32.411]   - Field: ‘uuid’
[17:02:32.411]   - Field: ‘seed’
[17:02:32.411]   - Field: ‘version’
[17:02:32.411]   - Field: ‘result’
[17:02:32.411]   - Field: ‘asynchronous’
[17:02:32.412]   - Field: ‘calls’
[17:02:32.412]   - Field: ‘globals’
[17:02:32.412]   - Field: ‘stdout’
[17:02:32.412]   - Field: ‘earlySignal’
[17:02:32.412]   - Field: ‘lazy’
[17:02:32.412]   - Field: ‘state’
[17:02:32.412] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.413] - Launch lazy future ...
[17:02:32.413] Packages needed by the future expression (n = 0): <none>
[17:02:32.413] Packages needed by future strategies (n = 0): <none>
[17:02:32.414] {
[17:02:32.414]     {
[17:02:32.414]         {
[17:02:32.414]             ...future.startTime <- base::Sys.time()
[17:02:32.414]             {
[17:02:32.414]                 {
[17:02:32.414]                   {
[17:02:32.414]                     {
[17:02:32.414]                       base::local({
[17:02:32.414]                         has_future <- base::requireNamespace("future", 
[17:02:32.414]                           quietly = TRUE)
[17:02:32.414]                         if (has_future) {
[17:02:32.414]                           ns <- base::getNamespace("future")
[17:02:32.414]                           version <- ns[[".package"]][["version"]]
[17:02:32.414]                           if (is.null(version)) 
[17:02:32.414]                             version <- utils::packageVersion("future")
[17:02:32.414]                         }
[17:02:32.414]                         else {
[17:02:32.414]                           version <- NULL
[17:02:32.414]                         }
[17:02:32.414]                         if (!has_future || version < "1.8.0") {
[17:02:32.414]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.414]                             "", base::R.version$version.string), 
[17:02:32.414]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.414]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.414]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.414]                               "release", "version")], collapse = " "), 
[17:02:32.414]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.414]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.414]                             info)
[17:02:32.414]                           info <- base::paste(info, collapse = "; ")
[17:02:32.414]                           if (!has_future) {
[17:02:32.414]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.414]                               info)
[17:02:32.414]                           }
[17:02:32.414]                           else {
[17:02:32.414]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.414]                               info, version)
[17:02:32.414]                           }
[17:02:32.414]                           base::stop(msg)
[17:02:32.414]                         }
[17:02:32.414]                       })
[17:02:32.414]                     }
[17:02:32.414]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.414]                     base::options(mc.cores = 1L)
[17:02:32.414]                   }
[17:02:32.414]                   ...future.strategy.old <- future::plan("list")
[17:02:32.414]                   options(future.plan = NULL)
[17:02:32.414]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.414]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.414]                 }
[17:02:32.414]                 ...future.workdir <- getwd()
[17:02:32.414]             }
[17:02:32.414]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.414]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.414]         }
[17:02:32.414]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.414]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.414]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.414]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.414]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.414]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.414]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.414]             base::names(...future.oldOptions))
[17:02:32.414]     }
[17:02:32.414]     if (FALSE) {
[17:02:32.414]     }
[17:02:32.414]     else {
[17:02:32.414]         if (TRUE) {
[17:02:32.414]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.414]                 open = "w")
[17:02:32.414]         }
[17:02:32.414]         else {
[17:02:32.414]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.414]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.414]         }
[17:02:32.414]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.414]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.414]             base::sink(type = "output", split = FALSE)
[17:02:32.414]             base::close(...future.stdout)
[17:02:32.414]         }, add = TRUE)
[17:02:32.414]     }
[17:02:32.414]     ...future.frame <- base::sys.nframe()
[17:02:32.414]     ...future.conditions <- base::list()
[17:02:32.414]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.414]     if (FALSE) {
[17:02:32.414]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.414]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.414]     }
[17:02:32.414]     ...future.result <- base::tryCatch({
[17:02:32.414]         base::withCallingHandlers({
[17:02:32.414]             ...future.value <- base::withVisible(base::local({
[17:02:32.414]                 withCallingHandlers({
[17:02:32.414]                   {
[17:02:32.414]                     4
[17:02:32.414]                   }
[17:02:32.414]                 }, immediateCondition = function(cond) {
[17:02:32.414]                   save_rds <- function (object, pathname, ...) 
[17:02:32.414]                   {
[17:02:32.414]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.414]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.414]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.414]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.414]                         fi_tmp[["mtime"]])
[17:02:32.414]                     }
[17:02:32.414]                     tryCatch({
[17:02:32.414]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.414]                     }, error = function(ex) {
[17:02:32.414]                       msg <- conditionMessage(ex)
[17:02:32.414]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.414]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.414]                         fi_tmp[["mtime"]], msg)
[17:02:32.414]                       ex$message <- msg
[17:02:32.414]                       stop(ex)
[17:02:32.414]                     })
[17:02:32.414]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.414]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.414]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.414]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.414]                       fi <- file.info(pathname)
[17:02:32.414]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.414]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.414]                         fi[["size"]], fi[["mtime"]])
[17:02:32.414]                       stop(msg)
[17:02:32.414]                     }
[17:02:32.414]                     invisible(pathname)
[17:02:32.414]                   }
[17:02:32.414]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.414]                     rootPath = tempdir()) 
[17:02:32.414]                   {
[17:02:32.414]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.414]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.414]                       tmpdir = path, fileext = ".rds")
[17:02:32.414]                     save_rds(obj, file)
[17:02:32.414]                   }
[17:02:32.414]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.414]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.414]                   {
[17:02:32.414]                     inherits <- base::inherits
[17:02:32.414]                     invokeRestart <- base::invokeRestart
[17:02:32.414]                     is.null <- base::is.null
[17:02:32.414]                     muffled <- FALSE
[17:02:32.414]                     if (inherits(cond, "message")) {
[17:02:32.414]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.414]                       if (muffled) 
[17:02:32.414]                         invokeRestart("muffleMessage")
[17:02:32.414]                     }
[17:02:32.414]                     else if (inherits(cond, "warning")) {
[17:02:32.414]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.414]                       if (muffled) 
[17:02:32.414]                         invokeRestart("muffleWarning")
[17:02:32.414]                     }
[17:02:32.414]                     else if (inherits(cond, "condition")) {
[17:02:32.414]                       if (!is.null(pattern)) {
[17:02:32.414]                         computeRestarts <- base::computeRestarts
[17:02:32.414]                         grepl <- base::grepl
[17:02:32.414]                         restarts <- computeRestarts(cond)
[17:02:32.414]                         for (restart in restarts) {
[17:02:32.414]                           name <- restart$name
[17:02:32.414]                           if (is.null(name)) 
[17:02:32.414]                             next
[17:02:32.414]                           if (!grepl(pattern, name)) 
[17:02:32.414]                             next
[17:02:32.414]                           invokeRestart(restart)
[17:02:32.414]                           muffled <- TRUE
[17:02:32.414]                           break
[17:02:32.414]                         }
[17:02:32.414]                       }
[17:02:32.414]                     }
[17:02:32.414]                     invisible(muffled)
[17:02:32.414]                   }
[17:02:32.414]                   muffleCondition(cond)
[17:02:32.414]                 })
[17:02:32.414]             }))
[17:02:32.414]             future::FutureResult(value = ...future.value$value, 
[17:02:32.414]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.414]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.414]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.414]                     ...future.globalenv.names))
[17:02:32.414]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.414]         }, condition = base::local({
[17:02:32.414]             c <- base::c
[17:02:32.414]             inherits <- base::inherits
[17:02:32.414]             invokeRestart <- base::invokeRestart
[17:02:32.414]             length <- base::length
[17:02:32.414]             list <- base::list
[17:02:32.414]             seq.int <- base::seq.int
[17:02:32.414]             signalCondition <- base::signalCondition
[17:02:32.414]             sys.calls <- base::sys.calls
[17:02:32.414]             `[[` <- base::`[[`
[17:02:32.414]             `+` <- base::`+`
[17:02:32.414]             `<<-` <- base::`<<-`
[17:02:32.414]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.414]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.414]                   3L)]
[17:02:32.414]             }
[17:02:32.414]             function(cond) {
[17:02:32.414]                 is_error <- inherits(cond, "error")
[17:02:32.414]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.414]                   NULL)
[17:02:32.414]                 if (is_error) {
[17:02:32.414]                   sessionInformation <- function() {
[17:02:32.414]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.414]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.414]                       search = base::search(), system = base::Sys.info())
[17:02:32.414]                   }
[17:02:32.414]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.414]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.414]                     cond$call), session = sessionInformation(), 
[17:02:32.414]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.414]                   signalCondition(cond)
[17:02:32.414]                 }
[17:02:32.414]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.414]                 "immediateCondition"))) {
[17:02:32.414]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.414]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.414]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.414]                   if (TRUE && !signal) {
[17:02:32.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.414]                     {
[17:02:32.414]                       inherits <- base::inherits
[17:02:32.414]                       invokeRestart <- base::invokeRestart
[17:02:32.414]                       is.null <- base::is.null
[17:02:32.414]                       muffled <- FALSE
[17:02:32.414]                       if (inherits(cond, "message")) {
[17:02:32.414]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.414]                         if (muffled) 
[17:02:32.414]                           invokeRestart("muffleMessage")
[17:02:32.414]                       }
[17:02:32.414]                       else if (inherits(cond, "warning")) {
[17:02:32.414]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.414]                         if (muffled) 
[17:02:32.414]                           invokeRestart("muffleWarning")
[17:02:32.414]                       }
[17:02:32.414]                       else if (inherits(cond, "condition")) {
[17:02:32.414]                         if (!is.null(pattern)) {
[17:02:32.414]                           computeRestarts <- base::computeRestarts
[17:02:32.414]                           grepl <- base::grepl
[17:02:32.414]                           restarts <- computeRestarts(cond)
[17:02:32.414]                           for (restart in restarts) {
[17:02:32.414]                             name <- restart$name
[17:02:32.414]                             if (is.null(name)) 
[17:02:32.414]                               next
[17:02:32.414]                             if (!grepl(pattern, name)) 
[17:02:32.414]                               next
[17:02:32.414]                             invokeRestart(restart)
[17:02:32.414]                             muffled <- TRUE
[17:02:32.414]                             break
[17:02:32.414]                           }
[17:02:32.414]                         }
[17:02:32.414]                       }
[17:02:32.414]                       invisible(muffled)
[17:02:32.414]                     }
[17:02:32.414]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.414]                   }
[17:02:32.414]                 }
[17:02:32.414]                 else {
[17:02:32.414]                   if (TRUE) {
[17:02:32.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.414]                     {
[17:02:32.414]                       inherits <- base::inherits
[17:02:32.414]                       invokeRestart <- base::invokeRestart
[17:02:32.414]                       is.null <- base::is.null
[17:02:32.414]                       muffled <- FALSE
[17:02:32.414]                       if (inherits(cond, "message")) {
[17:02:32.414]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.414]                         if (muffled) 
[17:02:32.414]                           invokeRestart("muffleMessage")
[17:02:32.414]                       }
[17:02:32.414]                       else if (inherits(cond, "warning")) {
[17:02:32.414]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.414]                         if (muffled) 
[17:02:32.414]                           invokeRestart("muffleWarning")
[17:02:32.414]                       }
[17:02:32.414]                       else if (inherits(cond, "condition")) {
[17:02:32.414]                         if (!is.null(pattern)) {
[17:02:32.414]                           computeRestarts <- base::computeRestarts
[17:02:32.414]                           grepl <- base::grepl
[17:02:32.414]                           restarts <- computeRestarts(cond)
[17:02:32.414]                           for (restart in restarts) {
[17:02:32.414]                             name <- restart$name
[17:02:32.414]                             if (is.null(name)) 
[17:02:32.414]                               next
[17:02:32.414]                             if (!grepl(pattern, name)) 
[17:02:32.414]                               next
[17:02:32.414]                             invokeRestart(restart)
[17:02:32.414]                             muffled <- TRUE
[17:02:32.414]                             break
[17:02:32.414]                           }
[17:02:32.414]                         }
[17:02:32.414]                       }
[17:02:32.414]                       invisible(muffled)
[17:02:32.414]                     }
[17:02:32.414]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.414]                   }
[17:02:32.414]                 }
[17:02:32.414]             }
[17:02:32.414]         }))
[17:02:32.414]     }, error = function(ex) {
[17:02:32.414]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.414]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.414]                 ...future.rng), started = ...future.startTime, 
[17:02:32.414]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.414]             version = "1.8"), class = "FutureResult")
[17:02:32.414]     }, finally = {
[17:02:32.414]         if (!identical(...future.workdir, getwd())) 
[17:02:32.414]             setwd(...future.workdir)
[17:02:32.414]         {
[17:02:32.414]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.414]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.414]             }
[17:02:32.414]             base::options(...future.oldOptions)
[17:02:32.414]             if (.Platform$OS.type == "windows") {
[17:02:32.414]                 old_names <- names(...future.oldEnvVars)
[17:02:32.414]                 envs <- base::Sys.getenv()
[17:02:32.414]                 names <- names(envs)
[17:02:32.414]                 common <- intersect(names, old_names)
[17:02:32.414]                 added <- setdiff(names, old_names)
[17:02:32.414]                 removed <- setdiff(old_names, names)
[17:02:32.414]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.414]                   envs[common]]
[17:02:32.414]                 NAMES <- toupper(changed)
[17:02:32.414]                 args <- list()
[17:02:32.414]                 for (kk in seq_along(NAMES)) {
[17:02:32.414]                   name <- changed[[kk]]
[17:02:32.414]                   NAME <- NAMES[[kk]]
[17:02:32.414]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.414]                     next
[17:02:32.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.414]                 }
[17:02:32.414]                 NAMES <- toupper(added)
[17:02:32.414]                 for (kk in seq_along(NAMES)) {
[17:02:32.414]                   name <- added[[kk]]
[17:02:32.414]                   NAME <- NAMES[[kk]]
[17:02:32.414]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.414]                     next
[17:02:32.414]                   args[[name]] <- ""
[17:02:32.414]                 }
[17:02:32.414]                 NAMES <- toupper(removed)
[17:02:32.414]                 for (kk in seq_along(NAMES)) {
[17:02:32.414]                   name <- removed[[kk]]
[17:02:32.414]                   NAME <- NAMES[[kk]]
[17:02:32.414]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.414]                     next
[17:02:32.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.414]                 }
[17:02:32.414]                 if (length(args) > 0) 
[17:02:32.414]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.414]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.414]             }
[17:02:32.414]             else {
[17:02:32.414]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.414]             }
[17:02:32.414]             {
[17:02:32.414]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.414]                   0L) {
[17:02:32.414]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.414]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.414]                   base::options(opts)
[17:02:32.414]                 }
[17:02:32.414]                 {
[17:02:32.414]                   {
[17:02:32.414]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.414]                     NULL
[17:02:32.414]                   }
[17:02:32.414]                   options(future.plan = NULL)
[17:02:32.414]                   if (is.na(NA_character_)) 
[17:02:32.414]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.414]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.414]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.414]                     .init = FALSE)
[17:02:32.414]                 }
[17:02:32.414]             }
[17:02:32.414]         }
[17:02:32.414]     })
[17:02:32.414]     if (TRUE) {
[17:02:32.414]         base::sink(type = "output", split = FALSE)
[17:02:32.414]         if (TRUE) {
[17:02:32.414]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.414]         }
[17:02:32.414]         else {
[17:02:32.414]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.414]         }
[17:02:32.414]         base::close(...future.stdout)
[17:02:32.414]         ...future.stdout <- NULL
[17:02:32.414]     }
[17:02:32.414]     ...future.result$conditions <- ...future.conditions
[17:02:32.414]     ...future.result$finished <- base::Sys.time()
[17:02:32.414]     ...future.result
[17:02:32.414] }
[17:02:32.418] requestCore(): workers = 2
[17:02:32.418] Poll #1 (0): usedCores() = 2, workers = 2
[17:02:32.429] result() for MulticoreFuture ...
[17:02:32.430] result() for MulticoreFuture ...
[17:02:32.430] result() for MulticoreFuture ... done
[17:02:32.430] result() for MulticoreFuture ... done
[17:02:32.430] result() for MulticoreFuture ...
[17:02:32.431] result() for MulticoreFuture ... done
[17:02:32.433] MulticoreFuture started
[17:02:32.434] - Launch lazy future ... done
[17:02:32.434] run() for ‘MulticoreFuture’ ... done
[17:02:32.435] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55c74b636130> 
[17:02:32.435] List of future strategies:
[17:02:32.435] 1. sequential:
[17:02:32.435]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.435]    - tweaked: FALSE
[17:02:32.435]    - call: NULL
[17:02:32.437] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55c749026b00> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=[17:02:32.440] plan(): Setting new future strategy stack:
List of 2
  ..$ :[17:02:32.440] List of future strategies:
[17:02:32.440] 1. multicore:
[17:02:32.440]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.440]    - tweaked: FALSE
[17:02:32.440]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:02:32.446] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:32.450] resolve() on list environment ...
[17:02:32.450]  recursive: 0
[17:02:32.452]  length: 6
[17:02:32.453]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:32.453] signalConditionsASAP(numeric, pos=1) ...
[17:02:32.453] - nx: 6
[17:02:32.453] - relay: TRUE
[17:02:32.453] - stdout: TRUE
[17:02:32.453] - signal: TRUE
[17:02:32.453] - resignal: FALSE
[17:02:32.454] - force: TRUE
[17:02:32.454] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.454] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.454]  - until=2
[17:02:32.454]  - relaying element #2
[17:02:32.454] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.455] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.455] signalConditionsASAP(NULL, pos=1) ... done
[17:02:32.455]  length: 5 (resolved future 1)
[17:02:32.455] Future #2
[17:02:32.455] result() for MulticoreFuture ...
[17:02:32.455] result() for MulticoreFuture ... done
[17:02:32.456] result() for MulticoreFuture ...
[17:02:32.456] result() for MulticoreFuture ... done
[17:02:32.456] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:32.456] - nx: 6
[17:02:32.456] - relay: TRUE
[17:02:32.456] - stdout: TRUE
[17:02:32.456] - signal: TRUE
[17:02:32.457] - resignal: FALSE
[17:02:32.457] - force: TRUE
[17:02:32.457] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.457] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.457]  - until=2
[17:02:32.457]  - relaying element #2
[17:02:32.457] result() for MulticoreFuture ...
[17:02:32.458] result() for MulticoreFuture ... done
[17:02:32.458] result() for MulticoreFuture ...
[17:02:32.458] result() for MulticoreFuture ... done
[17:02:32.458] result() for MulticoreFuture ...
[17:02:32.458] result() for MulticoreFuture ... done
[17:02:32.458] result() for MulticoreFuture ...
[17:02:32.458] result() for MulticoreFuture ... done
[17:02:32.459] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.459] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.459] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:32.459]  length: 4 (resolved future 2)
[17:02:32.459] Future #3
[17:02:32.460] result() for MulticoreFuture ...
[17:02:32.460] result() for MulticoreFuture ...
[17:02:32.461] result() for MulticoreFuture ... done
[17:02:32.461] result() for MulticoreFuture ... done
[17:02:32.461] result() for MulticoreFuture ...
[17:02:32.461] result() for MulticoreFuture ... done
[17:02:32.461] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:32.461] - nx: 6
[17:02:32.461] - relay: TRUE
[17:02:32.462] - stdout: TRUE
[17:02:32.462] - signal: TRUE
[17:02:32.462] - resignal: FALSE
[17:02:32.462] - force: TRUE
[17:02:32.462] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.462] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.462]  - until=3
[17:02:32.462]  - relaying element #3
[17:02:32.463] result() for MulticoreFuture ...
[17:02:32.463] result() for MulticoreFuture ... done
[17:02:32.463] result() for MulticoreFuture ...
[17:02:32.463] result() for MulticoreFuture ... done
[17:02:32.463] result() for MulticoreFuture ...
[17:02:32.463] result() for MulticoreFuture ... done
[17:02:32.463] result() for MulticoreFuture ...
[17:02:32.464] result() for MulticoreFuture ... done
[17:02:32.464] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.464] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.464] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:32.464]  length: 3 (resolved future 3)
[17:02:32.464] Future #4
[17:02:32.465] result() for MulticoreFuture ...
[17:02:32.465] result() for MulticoreFuture ...
[17:02:32.466] result() for MulticoreFuture ... done
[17:02:32.466] result() for MulticoreFuture ... done
[17:02:32.466] result() for MulticoreFuture ...
[17:02:32.466] result() for MulticoreFuture ... done
[17:02:32.466] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:02:32.467] - nx: 6
[17:02:32.467] - relay: TRUE
[17:02:32.467] - stdout: TRUE
[17:02:32.467] - signal: TRUE
[17:02:32.467] - resignal: FALSE
[17:02:32.467] - force: TRUE
[17:02:32.468] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.468] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.468]  - until=4
[17:02:32.468]  - relaying element #4
[17:02:32.468] result() for MulticoreFuture ...
[17:02:32.468] result() for MulticoreFuture ... done
[17:02:32.469] result() for MulticoreFuture ...
[17:02:32.469] result() for MulticoreFuture ... done
[17:02:32.469] result() for MulticoreFuture ...
[17:02:32.469] result() for MulticoreFuture ... done
[17:02:32.469] result() for MulticoreFuture ...
[17:02:32.469] result() for MulticoreFuture ... done
[17:02:32.469] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.470] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.470] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:02:32.470]  length: 2 (resolved future 4)
[17:02:32.470] signalConditionsASAP(NULL, pos=5) ...
[17:02:32.470] - nx: 6
[17:02:32.470] - relay: TRUE
[17:02:32.470] - stdout: TRUE
[17:02:32.470] - signal: TRUE
[17:02:32.470] - resignal: FALSE
[17:02:32.471] - force: TRUE
[17:02:32.471] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.471] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.471]  - until=6
[17:02:32.471]  - relaying element #6
[17:02:32.471] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:32.471] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.471] signalConditionsASAP(NULL, pos=5) ... done
[17:02:32.471]  length: 1 (resolved future 5)
[17:02:32.472] signalConditionsASAP(numeric, pos=6) ...
[17:02:32.472] - nx: 6
[17:02:32.472] - relay: TRUE
[17:02:32.472] - stdout: TRUE
[17:02:32.472] - signal: TRUE
[17:02:32.472] - resignal: FALSE
[17:02:32.472] - force: TRUE
[17:02:32.472] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:32.472] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.472]  - until=6
[17:02:32.473] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.473] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.473] signalConditionsASAP(numeric, pos=6) ... done
[17:02:32.473]  length: 0 (resolved future 6)
[17:02:32.473] Relaying remaining futures
[17:02:32.473] signalConditionsASAP(NULL, pos=0) ...
[17:02:32.473] - nx: 6
[17:02:32.473] - relay: TRUE
[17:02:32.473] - stdout: TRUE
[17:02:32.473] - signal: TRUE
[17:02:32.473] - resignal: FALSE
[17:02:32.474] - force: TRUE
[17:02:32.474] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.474] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:32.474] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.474] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.474] signalConditionsASAP(NULL, pos=0) ... done
[17:02:32.474] resolve() on list environment ... DONE
[17:02:32.474] result() for MulticoreFuture ...
[17:02:32.474] result() for MulticoreFuture ... done
[17:02:32.475] result() for MulticoreFuture ...
[17:02:32.475] result() for MulticoreFuture ... done
[17:02:32.475] result() for MulticoreFuture ...
[17:02:32.475] result() for MulticoreFuture ... done
[17:02:32.475] result() for MulticoreFuture ...
[17:02:32.475] result() for MulticoreFuture ... done
[17:02:32.475] result() for MulticoreFuture ...
[17:02:32.476] result() for MulticoreFuture ... done
[17:02:32.476] result() for MulticoreFuture ...
[17:02:32.476] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c747e85a58> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:02:32.478] getGlobalsAndPackages() ...
[17:02:32.478] Searching for globals...
[17:02:32.478] 
[17:02:32.479] Searching for globals ... DONE
[17:02:32.479] - globals: [0] <none>
[17:02:32.479] getGlobalsAndPackages() ... DONE
[17:02:32.479] run() for ‘Future’ ...
[17:02:32.479] - state: ‘created’
[17:02:32.479] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.484] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.484] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.484]   - Field: ‘label’
[17:02:32.484]   - Field: ‘local’
[17:02:32.484]   - Field: ‘owner’
[17:02:32.484]   - Field: ‘envir’
[17:02:32.484]   - Field: ‘workers’
[17:02:32.485]   - Field: ‘packages’
[17:02:32.485]   - Field: ‘gc’
[17:02:32.485]   - Field: ‘job’
[17:02:32.485]   - Field: ‘conditions’
[17:02:32.485]   - Field: ‘expr’
[17:02:32.485]   - Field: ‘uuid’
[17:02:32.485]   - Field: ‘seed’
[17:02:32.485]   - Field: ‘version’
[17:02:32.485]   - Field: ‘result’
[17:02:32.485]   - Field: ‘asynchronous’
[17:02:32.486]   - Field: ‘calls’
[17:02:32.486]   - Field: ‘globals’
[17:02:32.486]   - Field: ‘stdout’
[17:02:32.486]   - Field: ‘earlySignal’
[17:02:32.486]   - Field: ‘lazy’
[17:02:32.486]   - Field: ‘state’
[17:02:32.486] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.486] - Launch lazy future ...
[17:02:32.487] Packages needed by the future expression (n = 0): <none>
[17:02:32.487] Packages needed by future strategies (n = 0): <none>
[17:02:32.487] {
[17:02:32.487]     {
[17:02:32.487]         {
[17:02:32.487]             ...future.startTime <- base::Sys.time()
[17:02:32.487]             {
[17:02:32.487]                 {
[17:02:32.487]                   {
[17:02:32.487]                     {
[17:02:32.487]                       base::local({
[17:02:32.487]                         has_future <- base::requireNamespace("future", 
[17:02:32.487]                           quietly = TRUE)
[17:02:32.487]                         if (has_future) {
[17:02:32.487]                           ns <- base::getNamespace("future")
[17:02:32.487]                           version <- ns[[".package"]][["version"]]
[17:02:32.487]                           if (is.null(version)) 
[17:02:32.487]                             version <- utils::packageVersion("future")
[17:02:32.487]                         }
[17:02:32.487]                         else {
[17:02:32.487]                           version <- NULL
[17:02:32.487]                         }
[17:02:32.487]                         if (!has_future || version < "1.8.0") {
[17:02:32.487]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.487]                             "", base::R.version$version.string), 
[17:02:32.487]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.487]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.487]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.487]                               "release", "version")], collapse = " "), 
[17:02:32.487]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.487]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.487]                             info)
[17:02:32.487]                           info <- base::paste(info, collapse = "; ")
[17:02:32.487]                           if (!has_future) {
[17:02:32.487]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.487]                               info)
[17:02:32.487]                           }
[17:02:32.487]                           else {
[17:02:32.487]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.487]                               info, version)
[17:02:32.487]                           }
[17:02:32.487]                           base::stop(msg)
[17:02:32.487]                         }
[17:02:32.487]                       })
[17:02:32.487]                     }
[17:02:32.487]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.487]                     base::options(mc.cores = 1L)
[17:02:32.487]                   }
[17:02:32.487]                   ...future.strategy.old <- future::plan("list")
[17:02:32.487]                   options(future.plan = NULL)
[17:02:32.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.487]                 }
[17:02:32.487]                 ...future.workdir <- getwd()
[17:02:32.487]             }
[17:02:32.487]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.487]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.487]         }
[17:02:32.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.487]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.487]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.487]             base::names(...future.oldOptions))
[17:02:32.487]     }
[17:02:32.487]     if (FALSE) {
[17:02:32.487]     }
[17:02:32.487]     else {
[17:02:32.487]         if (TRUE) {
[17:02:32.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.487]                 open = "w")
[17:02:32.487]         }
[17:02:32.487]         else {
[17:02:32.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.487]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.487]         }
[17:02:32.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.487]             base::sink(type = "output", split = FALSE)
[17:02:32.487]             base::close(...future.stdout)
[17:02:32.487]         }, add = TRUE)
[17:02:32.487]     }
[17:02:32.487]     ...future.frame <- base::sys.nframe()
[17:02:32.487]     ...future.conditions <- base::list()
[17:02:32.487]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.487]     if (FALSE) {
[17:02:32.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.487]     }
[17:02:32.487]     ...future.result <- base::tryCatch({
[17:02:32.487]         base::withCallingHandlers({
[17:02:32.487]             ...future.value <- base::withVisible(base::local({
[17:02:32.487]                 withCallingHandlers({
[17:02:32.487]                   2
[17:02:32.487]                 }, immediateCondition = function(cond) {
[17:02:32.487]                   save_rds <- function (object, pathname, ...) 
[17:02:32.487]                   {
[17:02:32.487]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.487]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.487]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.487]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.487]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.487]                         fi_tmp[["mtime"]])
[17:02:32.487]                     }
[17:02:32.487]                     tryCatch({
[17:02:32.487]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.487]                     }, error = function(ex) {
[17:02:32.487]                       msg <- conditionMessage(ex)
[17:02:32.487]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.487]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.487]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.487]                         fi_tmp[["mtime"]], msg)
[17:02:32.487]                       ex$message <- msg
[17:02:32.487]                       stop(ex)
[17:02:32.487]                     })
[17:02:32.487]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.487]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.487]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.487]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.487]                       fi <- file.info(pathname)
[17:02:32.487]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.487]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.487]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.487]                         fi[["size"]], fi[["mtime"]])
[17:02:32.487]                       stop(msg)
[17:02:32.487]                     }
[17:02:32.487]                     invisible(pathname)
[17:02:32.487]                   }
[17:02:32.487]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.487]                     rootPath = tempdir()) 
[17:02:32.487]                   {
[17:02:32.487]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.487]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.487]                       tmpdir = path, fileext = ".rds")
[17:02:32.487]                     save_rds(obj, file)
[17:02:32.487]                   }
[17:02:32.487]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.487]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.487]                   {
[17:02:32.487]                     inherits <- base::inherits
[17:02:32.487]                     invokeRestart <- base::invokeRestart
[17:02:32.487]                     is.null <- base::is.null
[17:02:32.487]                     muffled <- FALSE
[17:02:32.487]                     if (inherits(cond, "message")) {
[17:02:32.487]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.487]                       if (muffled) 
[17:02:32.487]                         invokeRestart("muffleMessage")
[17:02:32.487]                     }
[17:02:32.487]                     else if (inherits(cond, "warning")) {
[17:02:32.487]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.487]                       if (muffled) 
[17:02:32.487]                         invokeRestart("muffleWarning")
[17:02:32.487]                     }
[17:02:32.487]                     else if (inherits(cond, "condition")) {
[17:02:32.487]                       if (!is.null(pattern)) {
[17:02:32.487]                         computeRestarts <- base::computeRestarts
[17:02:32.487]                         grepl <- base::grepl
[17:02:32.487]                         restarts <- computeRestarts(cond)
[17:02:32.487]                         for (restart in restarts) {
[17:02:32.487]                           name <- restart$name
[17:02:32.487]                           if (is.null(name)) 
[17:02:32.487]                             next
[17:02:32.487]                           if (!grepl(pattern, name)) 
[17:02:32.487]                             next
[17:02:32.487]                           invokeRestart(restart)
[17:02:32.487]                           muffled <- TRUE
[17:02:32.487]                           break
[17:02:32.487]                         }
[17:02:32.487]                       }
[17:02:32.487]                     }
[17:02:32.487]                     invisible(muffled)
[17:02:32.487]                   }
[17:02:32.487]                   muffleCondition(cond)
[17:02:32.487]                 })
[17:02:32.487]             }))
[17:02:32.487]             future::FutureResult(value = ...future.value$value, 
[17:02:32.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.487]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.487]                     ...future.globalenv.names))
[17:02:32.487]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.487]         }, condition = base::local({
[17:02:32.487]             c <- base::c
[17:02:32.487]             inherits <- base::inherits
[17:02:32.487]             invokeRestart <- base::invokeRestart
[17:02:32.487]             length <- base::length
[17:02:32.487]             list <- base::list
[17:02:32.487]             seq.int <- base::seq.int
[17:02:32.487]             signalCondition <- base::signalCondition
[17:02:32.487]             sys.calls <- base::sys.calls
[17:02:32.487]             `[[` <- base::`[[`
[17:02:32.487]             `+` <- base::`+`
[17:02:32.487]             `<<-` <- base::`<<-`
[17:02:32.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.487]                   3L)]
[17:02:32.487]             }
[17:02:32.487]             function(cond) {
[17:02:32.487]                 is_error <- inherits(cond, "error")
[17:02:32.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.487]                   NULL)
[17:02:32.487]                 if (is_error) {
[17:02:32.487]                   sessionInformation <- function() {
[17:02:32.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.487]                       search = base::search(), system = base::Sys.info())
[17:02:32.487]                   }
[17:02:32.487]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.487]                     cond$call), session = sessionInformation(), 
[17:02:32.487]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.487]                   signalCondition(cond)
[17:02:32.487]                 }
[17:02:32.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.487]                 "immediateCondition"))) {
[17:02:32.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.487]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.487]                   if (TRUE && !signal) {
[17:02:32.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.487]                     {
[17:02:32.487]                       inherits <- base::inherits
[17:02:32.487]                       invokeRestart <- base::invokeRestart
[17:02:32.487]                       is.null <- base::is.null
[17:02:32.487]                       muffled <- FALSE
[17:02:32.487]                       if (inherits(cond, "message")) {
[17:02:32.487]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.487]                         if (muffled) 
[17:02:32.487]                           invokeRestart("muffleMessage")
[17:02:32.487]                       }
[17:02:32.487]                       else if (inherits(cond, "warning")) {
[17:02:32.487]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.487]                         if (muffled) 
[17:02:32.487]                           invokeRestart("muffleWarning")
[17:02:32.487]                       }
[17:02:32.487]                       else if (inherits(cond, "condition")) {
[17:02:32.487]                         if (!is.null(pattern)) {
[17:02:32.487]                           computeRestarts <- base::computeRestarts
[17:02:32.487]                           grepl <- base::grepl
[17:02:32.487]                           restarts <- computeRestarts(cond)
[17:02:32.487]                           for (restart in restarts) {
[17:02:32.487]                             name <- restart$name
[17:02:32.487]                             if (is.null(name)) 
[17:02:32.487]                               next
[17:02:32.487]                             if (!grepl(pattern, name)) 
[17:02:32.487]                               next
[17:02:32.487]                             invokeRestart(restart)
[17:02:32.487]                             muffled <- TRUE
[17:02:32.487]                             break
[17:02:32.487]                           }
[17:02:32.487]                         }
[17:02:32.487]                       }
[17:02:32.487]                       invisible(muffled)
[17:02:32.487]                     }
[17:02:32.487]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.487]                   }
[17:02:32.487]                 }
[17:02:32.487]                 else {
[17:02:32.487]                   if (TRUE) {
[17:02:32.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.487]                     {
[17:02:32.487]                       inherits <- base::inherits
[17:02:32.487]                       invokeRestart <- base::invokeRestart
[17:02:32.487]                       is.null <- base::is.null
[17:02:32.487]                       muffled <- FALSE
[17:02:32.487]                       if (inherits(cond, "message")) {
[17:02:32.487]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.487]                         if (muffled) 
[17:02:32.487]                           invokeRestart("muffleMessage")
[17:02:32.487]                       }
[17:02:32.487]                       else if (inherits(cond, "warning")) {
[17:02:32.487]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.487]                         if (muffled) 
[17:02:32.487]                           invokeRestart("muffleWarning")
[17:02:32.487]                       }
[17:02:32.487]                       else if (inherits(cond, "condition")) {
[17:02:32.487]                         if (!is.null(pattern)) {
[17:02:32.487]                           computeRestarts <- base::computeRestarts
[17:02:32.487]                           grepl <- base::grepl
[17:02:32.487]                           restarts <- computeRestarts(cond)
[17:02:32.487]                           for (restart in restarts) {
[17:02:32.487]                             name <- restart$name
[17:02:32.487]                             if (is.null(name)) 
[17:02:32.487]                               next
[17:02:32.487]                             if (!grepl(pattern, name)) 
[17:02:32.487]                               next
[17:02:32.487]                             invokeRestart(restart)
[17:02:32.487]                             muffled <- TRUE
[17:02:32.487]                             break
[17:02:32.487]                           }
[17:02:32.487]                         }
[17:02:32.487]                       }
[17:02:32.487]                       invisible(muffled)
[17:02:32.487]                     }
[17:02:32.487]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.487]                   }
[17:02:32.487]                 }
[17:02:32.487]             }
[17:02:32.487]         }))
[17:02:32.487]     }, error = function(ex) {
[17:02:32.487]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.487]                 ...future.rng), started = ...future.startTime, 
[17:02:32.487]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.487]             version = "1.8"), class = "FutureResult")
[17:02:32.487]     }, finally = {
[17:02:32.487]         if (!identical(...future.workdir, getwd())) 
[17:02:32.487]             setwd(...future.workdir)
[17:02:32.487]         {
[17:02:32.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.487]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.487]             }
[17:02:32.487]             base::options(...future.oldOptions)
[17:02:32.487]             if (.Platform$OS.type == "windows") {
[17:02:32.487]                 old_names <- names(...future.oldEnvVars)
[17:02:32.487]                 envs <- base::Sys.getenv()
[17:02:32.487]                 names <- names(envs)
[17:02:32.487]                 common <- intersect(names, old_names)
[17:02:32.487]                 added <- setdiff(names, old_names)
[17:02:32.487]                 removed <- setdiff(old_names, names)
[17:02:32.487]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.487]                   envs[common]]
[17:02:32.487]                 NAMES <- toupper(changed)
[17:02:32.487]                 args <- list()
[17:02:32.487]                 for (kk in seq_along(NAMES)) {
[17:02:32.487]                   name <- changed[[kk]]
[17:02:32.487]                   NAME <- NAMES[[kk]]
[17:02:32.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.487]                     next
[17:02:32.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.487]                 }
[17:02:32.487]                 NAMES <- toupper(added)
[17:02:32.487]                 for (kk in seq_along(NAMES)) {
[17:02:32.487]                   name <- added[[kk]]
[17:02:32.487]                   NAME <- NAMES[[kk]]
[17:02:32.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.487]                     next
[17:02:32.487]                   args[[name]] <- ""
[17:02:32.487]                 }
[17:02:32.487]                 NAMES <- toupper(removed)
[17:02:32.487]                 for (kk in seq_along(NAMES)) {
[17:02:32.487]                   name <- removed[[kk]]
[17:02:32.487]                   NAME <- NAMES[[kk]]
[17:02:32.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.487]                     next
[17:02:32.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.487]                 }
[17:02:32.487]                 if (length(args) > 0) 
[17:02:32.487]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.487]             }
[17:02:32.487]             else {
[17:02:32.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.487]             }
[17:02:32.487]             {
[17:02:32.487]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.487]                   0L) {
[17:02:32.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.487]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.487]                   base::options(opts)
[17:02:32.487]                 }
[17:02:32.487]                 {
[17:02:32.487]                   {
[17:02:32.487]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.487]                     NULL
[17:02:32.487]                   }
[17:02:32.487]                   options(future.plan = NULL)
[17:02:32.487]                   if (is.na(NA_character_)) 
[17:02:32.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.487]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.487]                     .init = FALSE)
[17:02:32.487]                 }
[17:02:32.487]             }
[17:02:32.487]         }
[17:02:32.487]     })
[17:02:32.487]     if (TRUE) {
[17:02:32.487]         base::sink(type = "output", split = FALSE)
[17:02:32.487]         if (TRUE) {
[17:02:32.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.487]         }
[17:02:32.487]         else {
[17:02:32.487]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.487]         }
[17:02:32.487]         base::close(...future.stdout)
[17:02:32.487]         ...future.stdout <- NULL
[17:02:32.487]     }
[17:02:32.487]     ...future.result$conditions <- ...future.conditions
[17:02:32.487]     ...future.result$finished <- base::Sys.time()
[17:02:32.487]     ...future.result
[17:02:32.487] }
[17:02:32.490] requestCore(): workers = 2
[17:02:32.493] MulticoreFuture started
[17:02:32.493] - Launch lazy future ... done
[17:02:32.493] run() for ‘MulticoreFuture’ ... done
[17:02:32.494] getGlobalsAndPackages() ...
[17:02:32.494] plan(): Setting new future strategy stack:
[17:02:32.494] Searching for globals...
[17:02:32.494] List of future strategies:
[17:02:32.494] 1. sequential:
[17:02:32.494]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.494]    - tweaked: FALSE
[17:02:32.494]    - call: NULL
[17:02:32.495] 
[17:02:32.495] Searching for globals ... DONE
[17:02:32.495] plan(): nbrOfWorkers() = 1
[17:02:32.495] - globals: [0] <none>
[17:02:32.495] getGlobalsAndPackages() ... DONE
[17:02:32.495] run() for ‘Future’ ...
[17:02:32.496] - state: ‘created’
[17:02:32.496] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.497] plan(): Setting new future strategy stack:
[17:02:32.497] List of future strategies:
[17:02:32.497] 1. multicore:
[17:02:32.497]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.497]    - tweaked: FALSE
[17:02:32.497]    - call: plan(strategy)
[17:02:32.501] plan(): nbrOfWorkers() = 2
[17:02:32.501] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.501] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.501]   - Field: ‘label’
[17:02:32.502]   - Field: ‘local’
[17:02:32.502]   - Field: ‘owner’
[17:02:32.502]   - Field: ‘envir’
[17:02:32.502]   - Field: ‘workers’
[17:02:32.502]   - Field: ‘packages’
[17:02:32.502]   - Field: ‘gc’
[17:02:32.502]   - Field: ‘job’
[17:02:32.503]   - Field: ‘conditions’
[17:02:32.503]   - Field: ‘expr’
[17:02:32.503]   - Field: ‘uuid’
[17:02:32.503]   - Field: ‘seed’
[17:02:32.503]   - Field: ‘version’
[17:02:32.503]   - Field: ‘result’
[17:02:32.503]   - Field: ‘asynchronous’
[17:02:32.504]   - Field: ‘calls’
[17:02:32.504]   - Field: ‘globals’
[17:02:32.504]   - Field: ‘stdout’
[17:02:32.504]   - Field: ‘earlySignal’
[17:02:32.504]   - Field: ‘lazy’
[17:02:32.504]   - Field: ‘state’
[17:02:32.504] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.505] - Launch lazy future ...
[17:02:32.505] Packages needed by the future expression (n = 0): <none>
[17:02:32.505] Packages needed by future strategies (n = 0): <none>
[17:02:32.506] {
[17:02:32.506]     {
[17:02:32.506]         {
[17:02:32.506]             ...future.startTime <- base::Sys.time()
[17:02:32.506]             {
[17:02:32.506]                 {
[17:02:32.506]                   {
[17:02:32.506]                     {
[17:02:32.506]                       base::local({
[17:02:32.506]                         has_future <- base::requireNamespace("future", 
[17:02:32.506]                           quietly = TRUE)
[17:02:32.506]                         if (has_future) {
[17:02:32.506]                           ns <- base::getNamespace("future")
[17:02:32.506]                           version <- ns[[".package"]][["version"]]
[17:02:32.506]                           if (is.null(version)) 
[17:02:32.506]                             version <- utils::packageVersion("future")
[17:02:32.506]                         }
[17:02:32.506]                         else {
[17:02:32.506]                           version <- NULL
[17:02:32.506]                         }
[17:02:32.506]                         if (!has_future || version < "1.8.0") {
[17:02:32.506]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.506]                             "", base::R.version$version.string), 
[17:02:32.506]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.506]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.506]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.506]                               "release", "version")], collapse = " "), 
[17:02:32.506]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.506]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.506]                             info)
[17:02:32.506]                           info <- base::paste(info, collapse = "; ")
[17:02:32.506]                           if (!has_future) {
[17:02:32.506]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.506]                               info)
[17:02:32.506]                           }
[17:02:32.506]                           else {
[17:02:32.506]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.506]                               info, version)
[17:02:32.506]                           }
[17:02:32.506]                           base::stop(msg)
[17:02:32.506]                         }
[17:02:32.506]                       })
[17:02:32.506]                     }
[17:02:32.506]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.506]                     base::options(mc.cores = 1L)
[17:02:32.506]                   }
[17:02:32.506]                   ...future.strategy.old <- future::plan("list")
[17:02:32.506]                   options(future.plan = NULL)
[17:02:32.506]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.506]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.506]                 }
[17:02:32.506]                 ...future.workdir <- getwd()
[17:02:32.506]             }
[17:02:32.506]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.506]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.506]         }
[17:02:32.506]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.506]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.506]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.506]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.506]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.506]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.506]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.506]             base::names(...future.oldOptions))
[17:02:32.506]     }
[17:02:32.506]     if (FALSE) {
[17:02:32.506]     }
[17:02:32.506]     else {
[17:02:32.506]         if (TRUE) {
[17:02:32.506]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.506]                 open = "w")
[17:02:32.506]         }
[17:02:32.506]         else {
[17:02:32.506]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.506]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.506]         }
[17:02:32.506]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.506]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.506]             base::sink(type = "output", split = FALSE)
[17:02:32.506]             base::close(...future.stdout)
[17:02:32.506]         }, add = TRUE)
[17:02:32.506]     }
[17:02:32.506]     ...future.frame <- base::sys.nframe()
[17:02:32.506]     ...future.conditions <- base::list()
[17:02:32.506]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.506]     if (FALSE) {
[17:02:32.506]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.506]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.506]     }
[17:02:32.506]     ...future.result <- base::tryCatch({
[17:02:32.506]         base::withCallingHandlers({
[17:02:32.506]             ...future.value <- base::withVisible(base::local({
[17:02:32.506]                 withCallingHandlers({
[17:02:32.506]                   NULL
[17:02:32.506]                 }, immediateCondition = function(cond) {
[17:02:32.506]                   save_rds <- function (object, pathname, ...) 
[17:02:32.506]                   {
[17:02:32.506]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.506]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.506]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.506]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.506]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.506]                         fi_tmp[["mtime"]])
[17:02:32.506]                     }
[17:02:32.506]                     tryCatch({
[17:02:32.506]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.506]                     }, error = function(ex) {
[17:02:32.506]                       msg <- conditionMessage(ex)
[17:02:32.506]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.506]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.506]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.506]                         fi_tmp[["mtime"]], msg)
[17:02:32.506]                       ex$message <- msg
[17:02:32.506]                       stop(ex)
[17:02:32.506]                     })
[17:02:32.506]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.506]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.506]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.506]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.506]                       fi <- file.info(pathname)
[17:02:32.506]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.506]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.506]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.506]                         fi[["size"]], fi[["mtime"]])
[17:02:32.506]                       stop(msg)
[17:02:32.506]                     }
[17:02:32.506]                     invisible(pathname)
[17:02:32.506]                   }
[17:02:32.506]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.506]                     rootPath = tempdir()) 
[17:02:32.506]                   {
[17:02:32.506]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.506]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.506]                       tmpdir = path, fileext = ".rds")
[17:02:32.506]                     save_rds(obj, file)
[17:02:32.506]                   }
[17:02:32.506]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.506]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.506]                   {
[17:02:32.506]                     inherits <- base::inherits
[17:02:32.506]                     invokeRestart <- base::invokeRestart
[17:02:32.506]                     is.null <- base::is.null
[17:02:32.506]                     muffled <- FALSE
[17:02:32.506]                     if (inherits(cond, "message")) {
[17:02:32.506]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.506]                       if (muffled) 
[17:02:32.506]                         invokeRestart("muffleMessage")
[17:02:32.506]                     }
[17:02:32.506]                     else if (inherits(cond, "warning")) {
[17:02:32.506]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.506]                       if (muffled) 
[17:02:32.506]                         invokeRestart("muffleWarning")
[17:02:32.506]                     }
[17:02:32.506]                     else if (inherits(cond, "condition")) {
[17:02:32.506]                       if (!is.null(pattern)) {
[17:02:32.506]                         computeRestarts <- base::computeRestarts
[17:02:32.506]                         grepl <- base::grepl
[17:02:32.506]                         restarts <- computeRestarts(cond)
[17:02:32.506]                         for (restart in restarts) {
[17:02:32.506]                           name <- restart$name
[17:02:32.506]                           if (is.null(name)) 
[17:02:32.506]                             next
[17:02:32.506]                           if (!grepl(pattern, name)) 
[17:02:32.506]                             next
[17:02:32.506]                           invokeRestart(restart)
[17:02:32.506]                           muffled <- TRUE
[17:02:32.506]                           break
[17:02:32.506]                         }
[17:02:32.506]                       }
[17:02:32.506]                     }
[17:02:32.506]                     invisible(muffled)
[17:02:32.506]                   }
[17:02:32.506]                   muffleCondition(cond)
[17:02:32.506]                 })
[17:02:32.506]             }))
[17:02:32.506]             future::FutureResult(value = ...future.value$value, 
[17:02:32.506]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.506]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.506]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.506]                     ...future.globalenv.names))
[17:02:32.506]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.506]         }, condition = base::local({
[17:02:32.506]             c <- base::c
[17:02:32.506]             inherits <- base::inherits
[17:02:32.506]             invokeRestart <- base::invokeRestart
[17:02:32.506]             length <- base::length
[17:02:32.506]             list <- base::list
[17:02:32.506]             seq.int <- base::seq.int
[17:02:32.506]             signalCondition <- base::signalCondition
[17:02:32.506]             sys.calls <- base::sys.calls
[17:02:32.506]             `[[` <- base::`[[`
[17:02:32.506]             `+` <- base::`+`
[17:02:32.506]             `<<-` <- base::`<<-`
[17:02:32.506]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.506]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.506]                   3L)]
[17:02:32.506]             }
[17:02:32.506]             function(cond) {
[17:02:32.506]                 is_error <- inherits(cond, "error")
[17:02:32.506]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.506]                   NULL)
[17:02:32.506]                 if (is_error) {
[17:02:32.506]                   sessionInformation <- function() {
[17:02:32.506]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.506]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.506]                       search = base::search(), system = base::Sys.info())
[17:02:32.506]                   }
[17:02:32.506]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.506]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.506]                     cond$call), session = sessionInformation(), 
[17:02:32.506]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.506]                   signalCondition(cond)
[17:02:32.506]                 }
[17:02:32.506]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.506]                 "immediateCondition"))) {
[17:02:32.506]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.506]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.506]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.506]                   if (TRUE && !signal) {
[17:02:32.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.506]                     {
[17:02:32.506]                       inherits <- base::inherits
[17:02:32.506]                       invokeRestart <- base::invokeRestart
[17:02:32.506]                       is.null <- base::is.null
[17:02:32.506]                       muffled <- FALSE
[17:02:32.506]                       if (inherits(cond, "message")) {
[17:02:32.506]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.506]                         if (muffled) 
[17:02:32.506]                           invokeRestart("muffleMessage")
[17:02:32.506]                       }
[17:02:32.506]                       else if (inherits(cond, "warning")) {
[17:02:32.506]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.506]                         if (muffled) 
[17:02:32.506]                           invokeRestart("muffleWarning")
[17:02:32.506]                       }
[17:02:32.506]                       else if (inherits(cond, "condition")) {
[17:02:32.506]                         if (!is.null(pattern)) {
[17:02:32.506]                           computeRestarts <- base::computeRestarts
[17:02:32.506]                           grepl <- base::grepl
[17:02:32.506]                           restarts <- computeRestarts(cond)
[17:02:32.506]                           for (restart in restarts) {
[17:02:32.506]                             name <- restart$name
[17:02:32.506]                             if (is.null(name)) 
[17:02:32.506]                               next
[17:02:32.506]                             if (!grepl(pattern, name)) 
[17:02:32.506]                               next
[17:02:32.506]                             invokeRestart(restart)
[17:02:32.506]                             muffled <- TRUE
[17:02:32.506]                             break
[17:02:32.506]                           }
[17:02:32.506]                         }
[17:02:32.506]                       }
[17:02:32.506]                       invisible(muffled)
[17:02:32.506]                     }
[17:02:32.506]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.506]                   }
[17:02:32.506]                 }
[17:02:32.506]                 else {
[17:02:32.506]                   if (TRUE) {
[17:02:32.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.506]                     {
[17:02:32.506]                       inherits <- base::inherits
[17:02:32.506]                       invokeRestart <- base::invokeRestart
[17:02:32.506]                       is.null <- base::is.null
[17:02:32.506]                       muffled <- FALSE
[17:02:32.506]                       if (inherits(cond, "message")) {
[17:02:32.506]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.506]                         if (muffled) 
[17:02:32.506]                           invokeRestart("muffleMessage")
[17:02:32.506]                       }
[17:02:32.506]                       else if (inherits(cond, "warning")) {
[17:02:32.506]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.506]                         if (muffled) 
[17:02:32.506]                           invokeRestart("muffleWarning")
[17:02:32.506]                       }
[17:02:32.506]                       else if (inherits(cond, "condition")) {
[17:02:32.506]                         if (!is.null(pattern)) {
[17:02:32.506]                           computeRestarts <- base::computeRestarts
[17:02:32.506]                           grepl <- base::grepl
[17:02:32.506]                           restarts <- computeRestarts(cond)
[17:02:32.506]                           for (restart in restarts) {
[17:02:32.506]                             name <- restart$name
[17:02:32.506]                             if (is.null(name)) 
[17:02:32.506]                               next
[17:02:32.506]                             if (!grepl(pattern, name)) 
[17:02:32.506]                               next
[17:02:32.506]                             invokeRestart(restart)
[17:02:32.506]                             muffled <- TRUE
[17:02:32.506]                             break
[17:02:32.506]                           }
[17:02:32.506]                         }
[17:02:32.506]                       }
[17:02:32.506]                       invisible(muffled)
[17:02:32.506]                     }
[17:02:32.506]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.506]                   }
[17:02:32.506]                 }
[17:02:32.506]             }
[17:02:32.506]         }))
[17:02:32.506]     }, error = function(ex) {
[17:02:32.506]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.506]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.506]                 ...future.rng), started = ...future.startTime, 
[17:02:32.506]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.506]             version = "1.8"), class = "FutureResult")
[17:02:32.506]     }, finally = {
[17:02:32.506]         if (!identical(...future.workdir, getwd())) 
[17:02:32.506]             setwd(...future.workdir)
[17:02:32.506]         {
[17:02:32.506]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.506]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.506]             }
[17:02:32.506]             base::options(...future.oldOptions)
[17:02:32.506]             if (.Platform$OS.type == "windows") {
[17:02:32.506]                 old_names <- names(...future.oldEnvVars)
[17:02:32.506]                 envs <- base::Sys.getenv()
[17:02:32.506]                 names <- names(envs)
[17:02:32.506]                 common <- intersect(names, old_names)
[17:02:32.506]                 added <- setdiff(names, old_names)
[17:02:32.506]                 removed <- setdiff(old_names, names)
[17:02:32.506]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.506]                   envs[common]]
[17:02:32.506]                 NAMES <- toupper(changed)
[17:02:32.506]                 args <- list()
[17:02:32.506]                 for (kk in seq_along(NAMES)) {
[17:02:32.506]                   name <- changed[[kk]]
[17:02:32.506]                   NAME <- NAMES[[kk]]
[17:02:32.506]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.506]                     next
[17:02:32.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.506]                 }
[17:02:32.506]                 NAMES <- toupper(added)
[17:02:32.506]                 for (kk in seq_along(NAMES)) {
[17:02:32.506]                   name <- added[[kk]]
[17:02:32.506]                   NAME <- NAMES[[kk]]
[17:02:32.506]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.506]                     next
[17:02:32.506]                   args[[name]] <- ""
[17:02:32.506]                 }
[17:02:32.506]                 NAMES <- toupper(removed)
[17:02:32.506]                 for (kk in seq_along(NAMES)) {
[17:02:32.506]                   name <- removed[[kk]]
[17:02:32.506]                   NAME <- NAMES[[kk]]
[17:02:32.506]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.506]                     next
[17:02:32.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.506]                 }
[17:02:32.506]                 if (length(args) > 0) 
[17:02:32.506]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.506]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.506]             }
[17:02:32.506]             else {
[17:02:32.506]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.506]             }
[17:02:32.506]             {
[17:02:32.506]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.506]                   0L) {
[17:02:32.506]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.506]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.506]                   base::options(opts)
[17:02:32.506]                 }
[17:02:32.506]                 {
[17:02:32.506]                   {
[17:02:32.506]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.506]                     NULL
[17:02:32.506]                   }
[17:02:32.506]                   options(future.plan = NULL)
[17:02:32.506]                   if (is.na(NA_character_)) 
[17:02:32.506]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.506]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.506]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.506]                     .init = FALSE)
[17:02:32.506]                 }
[17:02:32.506]             }
[17:02:32.506]         }
[17:02:32.506]     })
[17:02:32.506]     if (TRUE) {
[17:02:32.506]         base::sink(type = "output", split = FALSE)
[17:02:32.506]         if (TRUE) {
[17:02:32.506]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.506]         }
[17:02:32.506]         else {
[17:02:32.506]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.506]         }
[17:02:32.506]         base::close(...future.stdout)
[17:02:32.506]         ...future.stdout <- NULL
[17:02:32.506]     }
[17:02:32.506]     ...future.result$conditions <- ...future.conditions
[17:02:32.506]     ...future.result$finished <- base::Sys.time()
[17:02:32.506]     ...future.result
[17:02:32.506] }
[17:02:32.509] requestCore(): workers = 2
[17:02:32.512] MulticoreFuture started
[17:02:32.513] - Launch lazy future ... done
[17:02:32.513] run() for ‘MulticoreFuture’ ... done
[17:02:32.513] plan(): Setting new future strategy stack:
[17:02:32.514] getGlobalsAndPackages() ...
[17:02:32.514] Searching for globals...
[17:02:32.514] List of future strategies:
[17:02:32.514] 1. sequential:
[17:02:32.514]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.514]    - tweaked: FALSE
[17:02:32.514]    - call: NULL
[17:02:32.515] plan(): nbrOfWorkers() = 1
[17:02:32.515] - globals found: [1] ‘{’
[17:02:32.516] Searching for globals ... DONE
[17:02:32.516] Resolving globals: FALSE
[17:02:32.516] 
[17:02:32.516] 
[17:02:32.517] getGlobalsAndPackages() ... DONE
[17:02:32.517] plan(): Setting new future strategy stack:
[17:02:32.517] run() for ‘Future’ ...
[17:02:32.517] List of future strategies:
[17:02:32.517] 1. multicore:
[17:02:32.517]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.517]    - tweaked: FALSE
[17:02:32.517]    - call: plan(strategy)
[17:02:32.517] - state: ‘created’
[17:02:32.517] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.522] plan(): nbrOfWorkers() = 2
[17:02:32.523] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.523] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.523]   - Field: ‘label’
[17:02:32.523]   - Field: ‘local’
[17:02:32.523]   - Field: ‘owner’
[17:02:32.524]   - Field: ‘envir’
[17:02:32.524]   - Field: ‘workers’
[17:02:32.524]   - Field: ‘packages’
[17:02:32.524]   - Field: ‘gc’
[17:02:32.524]   - Field: ‘job’
[17:02:32.524]   - Field: ‘conditions’
[17:02:32.524]   - Field: ‘expr’
[17:02:32.525]   - Field: ‘uuid’
[17:02:32.525]   - Field: ‘seed’
[17:02:32.525]   - Field: ‘version’
[17:02:32.525]   - Field: ‘result’
[17:02:32.525]   - Field: ‘asynchronous’
[17:02:32.525]   - Field: ‘calls’
[17:02:32.525]   - Field: ‘globals’
[17:02:32.526]   - Field: ‘stdout’
[17:02:32.526]   - Field: ‘earlySignal’
[17:02:32.526]   - Field: ‘lazy’
[17:02:32.526]   - Field: ‘state’
[17:02:32.526] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.526] - Launch lazy future ...
[17:02:32.527] Packages needed by the future expression (n = 0): <none>
[17:02:32.527] Packages needed by future strategies (n = 0): <none>
[17:02:32.528] {
[17:02:32.528]     {
[17:02:32.528]         {
[17:02:32.528]             ...future.startTime <- base::Sys.time()
[17:02:32.528]             {
[17:02:32.528]                 {
[17:02:32.528]                   {
[17:02:32.528]                     {
[17:02:32.528]                       base::local({
[17:02:32.528]                         has_future <- base::requireNamespace("future", 
[17:02:32.528]                           quietly = TRUE)
[17:02:32.528]                         if (has_future) {
[17:02:32.528]                           ns <- base::getNamespace("future")
[17:02:32.528]                           version <- ns[[".package"]][["version"]]
[17:02:32.528]                           if (is.null(version)) 
[17:02:32.528]                             version <- utils::packageVersion("future")
[17:02:32.528]                         }
[17:02:32.528]                         else {
[17:02:32.528]                           version <- NULL
[17:02:32.528]                         }
[17:02:32.528]                         if (!has_future || version < "1.8.0") {
[17:02:32.528]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.528]                             "", base::R.version$version.string), 
[17:02:32.528]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.528]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.528]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.528]                               "release", "version")], collapse = " "), 
[17:02:32.528]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.528]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.528]                             info)
[17:02:32.528]                           info <- base::paste(info, collapse = "; ")
[17:02:32.528]                           if (!has_future) {
[17:02:32.528]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.528]                               info)
[17:02:32.528]                           }
[17:02:32.528]                           else {
[17:02:32.528]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.528]                               info, version)
[17:02:32.528]                           }
[17:02:32.528]                           base::stop(msg)
[17:02:32.528]                         }
[17:02:32.528]                       })
[17:02:32.528]                     }
[17:02:32.528]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.528]                     base::options(mc.cores = 1L)
[17:02:32.528]                   }
[17:02:32.528]                   ...future.strategy.old <- future::plan("list")
[17:02:32.528]                   options(future.plan = NULL)
[17:02:32.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.528]                 }
[17:02:32.528]                 ...future.workdir <- getwd()
[17:02:32.528]             }
[17:02:32.528]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.528]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.528]         }
[17:02:32.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.528]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.528]             base::names(...future.oldOptions))
[17:02:32.528]     }
[17:02:32.528]     if (FALSE) {
[17:02:32.528]     }
[17:02:32.528]     else {
[17:02:32.528]         if (TRUE) {
[17:02:32.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.528]                 open = "w")
[17:02:32.528]         }
[17:02:32.528]         else {
[17:02:32.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.528]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.528]         }
[17:02:32.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.528]             base::sink(type = "output", split = FALSE)
[17:02:32.528]             base::close(...future.stdout)
[17:02:32.528]         }, add = TRUE)
[17:02:32.528]     }
[17:02:32.528]     ...future.frame <- base::sys.nframe()
[17:02:32.528]     ...future.conditions <- base::list()
[17:02:32.528]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.528]     if (FALSE) {
[17:02:32.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.528]     }
[17:02:32.528]     ...future.result <- base::tryCatch({
[17:02:32.528]         base::withCallingHandlers({
[17:02:32.528]             ...future.value <- base::withVisible(base::local({
[17:02:32.528]                 withCallingHandlers({
[17:02:32.528]                   {
[17:02:32.528]                     4
[17:02:32.528]                   }
[17:02:32.528]                 }, immediateCondition = function(cond) {
[17:02:32.528]                   save_rds <- function (object, pathname, ...) 
[17:02:32.528]                   {
[17:02:32.528]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.528]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.528]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.528]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.528]                         fi_tmp[["mtime"]])
[17:02:32.528]                     }
[17:02:32.528]                     tryCatch({
[17:02:32.528]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.528]                     }, error = function(ex) {
[17:02:32.528]                       msg <- conditionMessage(ex)
[17:02:32.528]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.528]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.528]                         fi_tmp[["mtime"]], msg)
[17:02:32.528]                       ex$message <- msg
[17:02:32.528]                       stop(ex)
[17:02:32.528]                     })
[17:02:32.528]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.528]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.528]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.528]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.528]                       fi <- file.info(pathname)
[17:02:32.528]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.528]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.528]                         fi[["size"]], fi[["mtime"]])
[17:02:32.528]                       stop(msg)
[17:02:32.528]                     }
[17:02:32.528]                     invisible(pathname)
[17:02:32.528]                   }
[17:02:32.528]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.528]                     rootPath = tempdir()) 
[17:02:32.528]                   {
[17:02:32.528]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.528]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.528]                       tmpdir = path, fileext = ".rds")
[17:02:32.528]                     save_rds(obj, file)
[17:02:32.528]                   }
[17:02:32.528]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.528]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.528]                   {
[17:02:32.528]                     inherits <- base::inherits
[17:02:32.528]                     invokeRestart <- base::invokeRestart
[17:02:32.528]                     is.null <- base::is.null
[17:02:32.528]                     muffled <- FALSE
[17:02:32.528]                     if (inherits(cond, "message")) {
[17:02:32.528]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.528]                       if (muffled) 
[17:02:32.528]                         invokeRestart("muffleMessage")
[17:02:32.528]                     }
[17:02:32.528]                     else if (inherits(cond, "warning")) {
[17:02:32.528]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.528]                       if (muffled) 
[17:02:32.528]                         invokeRestart("muffleWarning")
[17:02:32.528]                     }
[17:02:32.528]                     else if (inherits(cond, "condition")) {
[17:02:32.528]                       if (!is.null(pattern)) {
[17:02:32.528]                         computeRestarts <- base::computeRestarts
[17:02:32.528]                         grepl <- base::grepl
[17:02:32.528]                         restarts <- computeRestarts(cond)
[17:02:32.528]                         for (restart in restarts) {
[17:02:32.528]                           name <- restart$name
[17:02:32.528]                           if (is.null(name)) 
[17:02:32.528]                             next
[17:02:32.528]                           if (!grepl(pattern, name)) 
[17:02:32.528]                             next
[17:02:32.528]                           invokeRestart(restart)
[17:02:32.528]                           muffled <- TRUE
[17:02:32.528]                           break
[17:02:32.528]                         }
[17:02:32.528]                       }
[17:02:32.528]                     }
[17:02:32.528]                     invisible(muffled)
[17:02:32.528]                   }
[17:02:32.528]                   muffleCondition(cond)
[17:02:32.528]                 })
[17:02:32.528]             }))
[17:02:32.528]             future::FutureResult(value = ...future.value$value, 
[17:02:32.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.528]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.528]                     ...future.globalenv.names))
[17:02:32.528]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.528]         }, condition = base::local({
[17:02:32.528]             c <- base::c
[17:02:32.528]             inherits <- base::inherits
[17:02:32.528]             invokeRestart <- base::invokeRestart
[17:02:32.528]             length <- base::length
[17:02:32.528]             list <- base::list
[17:02:32.528]             seq.int <- base::seq.int
[17:02:32.528]             signalCondition <- base::signalCondition
[17:02:32.528]             sys.calls <- base::sys.calls
[17:02:32.528]             `[[` <- base::`[[`
[17:02:32.528]             `+` <- base::`+`
[17:02:32.528]             `<<-` <- base::`<<-`
[17:02:32.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.528]                   3L)]
[17:02:32.528]             }
[17:02:32.528]             function(cond) {
[17:02:32.528]                 is_error <- inherits(cond, "error")
[17:02:32.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.528]                   NULL)
[17:02:32.528]                 if (is_error) {
[17:02:32.528]                   sessionInformation <- function() {
[17:02:32.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.528]                       search = base::search(), system = base::Sys.info())
[17:02:32.528]                   }
[17:02:32.528]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.528]                     cond$call), session = sessionInformation(), 
[17:02:32.528]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.528]                   signalCondition(cond)
[17:02:32.528]                 }
[17:02:32.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.528]                 "immediateCondition"))) {
[17:02:32.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.528]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.528]                   if (TRUE && !signal) {
[17:02:32.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.528]                     {
[17:02:32.528]                       inherits <- base::inherits
[17:02:32.528]                       invokeRestart <- base::invokeRestart
[17:02:32.528]                       is.null <- base::is.null
[17:02:32.528]                       muffled <- FALSE
[17:02:32.528]                       if (inherits(cond, "message")) {
[17:02:32.528]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.528]                         if (muffled) 
[17:02:32.528]                           invokeRestart("muffleMessage")
[17:02:32.528]                       }
[17:02:32.528]                       else if (inherits(cond, "warning")) {
[17:02:32.528]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.528]                         if (muffled) 
[17:02:32.528]                           invokeRestart("muffleWarning")
[17:02:32.528]                       }
[17:02:32.528]                       else if (inherits(cond, "condition")) {
[17:02:32.528]                         if (!is.null(pattern)) {
[17:02:32.528]                           computeRestarts <- base::computeRestarts
[17:02:32.528]                           grepl <- base::grepl
[17:02:32.528]                           restarts <- computeRestarts(cond)
[17:02:32.528]                           for (restart in restarts) {
[17:02:32.528]                             name <- restart$name
[17:02:32.528]                             if (is.null(name)) 
[17:02:32.528]                               next
[17:02:32.528]                             if (!grepl(pattern, name)) 
[17:02:32.528]                               next
[17:02:32.528]                             invokeRestart(restart)
[17:02:32.528]                             muffled <- TRUE
[17:02:32.528]                             break
[17:02:32.528]                           }
[17:02:32.528]                         }
[17:02:32.528]                       }
[17:02:32.528]                       invisible(muffled)
[17:02:32.528]                     }
[17:02:32.528]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.528]                   }
[17:02:32.528]                 }
[17:02:32.528]                 else {
[17:02:32.528]                   if (TRUE) {
[17:02:32.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.528]                     {
[17:02:32.528]                       inherits <- base::inherits
[17:02:32.528]                       invokeRestart <- base::invokeRestart
[17:02:32.528]                       is.null <- base::is.null
[17:02:32.528]                       muffled <- FALSE
[17:02:32.528]                       if (inherits(cond, "message")) {
[17:02:32.528]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.528]                         if (muffled) 
[17:02:32.528]                           invokeRestart("muffleMessage")
[17:02:32.528]                       }
[17:02:32.528]                       else if (inherits(cond, "warning")) {
[17:02:32.528]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.528]                         if (muffled) 
[17:02:32.528]                           invokeRestart("muffleWarning")
[17:02:32.528]                       }
[17:02:32.528]                       else if (inherits(cond, "condition")) {
[17:02:32.528]                         if (!is.null(pattern)) {
[17:02:32.528]                           computeRestarts <- base::computeRestarts
[17:02:32.528]                           grepl <- base::grepl
[17:02:32.528]                           restarts <- computeRestarts(cond)
[17:02:32.528]                           for (restart in restarts) {
[17:02:32.528]                             name <- restart$name
[17:02:32.528]                             if (is.null(name)) 
[17:02:32.528]                               next
[17:02:32.528]                             if (!grepl(pattern, name)) 
[17:02:32.528]                               next
[17:02:32.528]                             invokeRestart(restart)
[17:02:32.528]                             muffled <- TRUE
[17:02:32.528]                             break
[17:02:32.528]                           }
[17:02:32.528]                         }
[17:02:32.528]                       }
[17:02:32.528]                       invisible(muffled)
[17:02:32.528]                     }
[17:02:32.528]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.528]                   }
[17:02:32.528]                 }
[17:02:32.528]             }
[17:02:32.528]         }))
[17:02:32.528]     }, error = function(ex) {
[17:02:32.528]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.528]                 ...future.rng), started = ...future.startTime, 
[17:02:32.528]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.528]             version = "1.8"), class = "FutureResult")
[17:02:32.528]     }, finally = {
[17:02:32.528]         if (!identical(...future.workdir, getwd())) 
[17:02:32.528]             setwd(...future.workdir)
[17:02:32.528]         {
[17:02:32.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.528]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.528]             }
[17:02:32.528]             base::options(...future.oldOptions)
[17:02:32.528]             if (.Platform$OS.type == "windows") {
[17:02:32.528]                 old_names <- names(...future.oldEnvVars)
[17:02:32.528]                 envs <- base::Sys.getenv()
[17:02:32.528]                 names <- names(envs)
[17:02:32.528]                 common <- intersect(names, old_names)
[17:02:32.528]                 added <- setdiff(names, old_names)
[17:02:32.528]                 removed <- setdiff(old_names, names)
[17:02:32.528]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.528]                   envs[common]]
[17:02:32.528]                 NAMES <- toupper(changed)
[17:02:32.528]                 args <- list()
[17:02:32.528]                 for (kk in seq_along(NAMES)) {
[17:02:32.528]                   name <- changed[[kk]]
[17:02:32.528]                   NAME <- NAMES[[kk]]
[17:02:32.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.528]                     next
[17:02:32.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.528]                 }
[17:02:32.528]                 NAMES <- toupper(added)
[17:02:32.528]                 for (kk in seq_along(NAMES)) {
[17:02:32.528]                   name <- added[[kk]]
[17:02:32.528]                   NAME <- NAMES[[kk]]
[17:02:32.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.528]                     next
[17:02:32.528]                   args[[name]] <- ""
[17:02:32.528]                 }
[17:02:32.528]                 NAMES <- toupper(removed)
[17:02:32.528]                 for (kk in seq_along(NAMES)) {
[17:02:32.528]                   name <- removed[[kk]]
[17:02:32.528]                   NAME <- NAMES[[kk]]
[17:02:32.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.528]                     next
[17:02:32.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.528]                 }
[17:02:32.528]                 if (length(args) > 0) 
[17:02:32.528]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.528]             }
[17:02:32.528]             else {
[17:02:32.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.528]             }
[17:02:32.528]             {
[17:02:32.528]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.528]                   0L) {
[17:02:32.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.528]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.528]                   base::options(opts)
[17:02:32.528]                 }
[17:02:32.528]                 {
[17:02:32.528]                   {
[17:02:32.528]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.528]                     NULL
[17:02:32.528]                   }
[17:02:32.528]                   options(future.plan = NULL)
[17:02:32.528]                   if (is.na(NA_character_)) 
[17:02:32.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.528]                     .init = FALSE)
[17:02:32.528]                 }
[17:02:32.528]             }
[17:02:32.528]         }
[17:02:32.528]     })
[17:02:32.528]     if (TRUE) {
[17:02:32.528]         base::sink(type = "output", split = FALSE)
[17:02:32.528]         if (TRUE) {
[17:02:32.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.528]         }
[17:02:32.528]         else {
[17:02:32.528]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.528]         }
[17:02:32.528]         base::close(...future.stdout)
[17:02:32.528]         ...future.stdout <- NULL
[17:02:32.528]     }
[17:02:32.528]     ...future.result$conditions <- ...future.conditions
[17:02:32.528]     ...future.result$finished <- base::Sys.time()
[17:02:32.528]     ...future.result
[17:02:32.528] }
[17:02:32.531] requestCore(): workers = 2
[17:02:32.531] Poll #1 (0): usedCores() = 2, workers = 2
[17:02:32.542] result() for MulticoreFuture ...
[17:02:32.543] result() for MulticoreFuture ...
[17:02:32.543] result() for MulticoreFuture ... done
[17:02:32.543] result() for MulticoreFuture ... done
[17:02:32.544] result() for MulticoreFuture ...
[17:02:32.544] result() for MulticoreFuture ... done
[17:02:32.546] MulticoreFuture started
[17:02:32.547] - Launch lazy future ... done
[17:02:32.547] run() for ‘MulticoreFuture’ ... done
[17:02:32.548] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55c74acc1e30> 
[17:02:32.548] List of future strategies:
[17:02:32.548] 1. sequential:
[17:02:32.548]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.548]    - tweaked: FALSE
[17:02:32.548]    - call: NULL
[17:02:32.549] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55c74b7c39b0> 
 - attr(*, "dim.")=[17:02:32.552] plan(): Setting new future strategy stack:
[17:02:32.552] List of future strategies:
[17:02:32.552] 1. multicore:
[17:02:32.552]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.552]    - tweaked: FALSE
[17:02:32.552]    - call: plan(strategy)
 int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ :[17:02:32.568] plan(): nbrOfWorkers() = 2
 chr "a"
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:32.575] resolve() on list environment ...
[17:02:32.575]  recursive: 0
[17:02:32.576]  length: 6
[17:02:32.576]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:32.577] signalConditionsASAP(numeric, pos=1) ...
[17:02:32.577] - nx: 6
[17:02:32.577] - relay: TRUE
[17:02:32.577] - stdout: TRUE
[17:02:32.577] - signal: TRUE
[17:02:32.577] - resignal: FALSE
[17:02:32.577] - force: TRUE
[17:02:32.577] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.577] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.578]  - until=2
[17:02:32.578]  - relaying element #2
[17:02:32.578] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.578] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.578] signalConditionsASAP(NULL, pos=1) ... done
[17:02:32.578]  length: 5 (resolved future 1)
[17:02:32.578] Future #2
[17:02:32.579] result() for MulticoreFuture ...
[17:02:32.579] result() for MulticoreFuture ... done
[17:02:32.579] result() for MulticoreFuture ...
[17:02:32.579] result() for MulticoreFuture ... done
[17:02:32.579] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:32.579] - nx: 6
[17:02:32.580] - relay: TRUE
[17:02:32.580] - stdout: TRUE
[17:02:32.580] - signal: TRUE
[17:02:32.580] - resignal: FALSE
[17:02:32.580] - force: TRUE
[17:02:32.580] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.580] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.580]  - until=2
[17:02:32.581]  - relaying element #2
[17:02:32.581] result() for MulticoreFuture ...
[17:02:32.581] result() for MulticoreFuture ... done
[17:02:32.581] result() for MulticoreFuture ...
[17:02:32.581] result() for MulticoreFuture ... done
[17:02:32.581] result() for MulticoreFuture ...
[17:02:32.581] result() for MulticoreFuture ... done
[17:02:32.581] result() for MulticoreFuture ...
[17:02:32.582] result() for MulticoreFuture ... done
[17:02:32.582] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.582] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.582] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:32.582]  length: 4 (resolved future 2)
[17:02:32.582] Future #3
[17:02:32.583] result() for MulticoreFuture ...
[17:02:32.583] result() for MulticoreFuture ...
[17:02:32.584] result() for MulticoreFuture ... done
[17:02:32.584] result() for MulticoreFuture ... done
[17:02:32.584] result() for MulticoreFuture ...
[17:02:32.584] result() for MulticoreFuture ... done
[17:02:32.584] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:32.585] - nx: 6
[17:02:32.585] - relay: TRUE
[17:02:32.585] - stdout: TRUE
[17:02:32.585] - signal: TRUE
[17:02:32.585] - resignal: FALSE
[17:02:32.585] - force: TRUE
[17:02:32.585] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.586] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.586]  - until=3
[17:02:32.586]  - relaying element #3
[17:02:32.586] result() for MulticoreFuture ...
[17:02:32.586] result() for MulticoreFuture ... done
[17:02:32.586] result() for MulticoreFuture ...
[17:02:32.587] result() for MulticoreFuture ... done
[17:02:32.587] result() for MulticoreFuture ...
[17:02:32.587] result() for MulticoreFuture ... done
[17:02:32.587] result() for MulticoreFuture ...
[17:02:32.587] result() for MulticoreFuture ... done
[17:02:32.587] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.588] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.588] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:32.588]  length: 3 (resolved future 3)
[17:02:32.588] Future #4
[17:02:32.589] result() for MulticoreFuture ...
[17:02:32.589] result() for MulticoreFuture ...
[17:02:32.589] result() for MulticoreFuture ... done
[17:02:32.590] result() for MulticoreFuture ... done
[17:02:32.590] result() for MulticoreFuture ...
[17:02:32.590] result() for MulticoreFuture ... done
[17:02:32.590] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:02:32.590] - nx: 6
[17:02:32.590] - relay: TRUE
[17:02:32.590] - stdout: TRUE
[17:02:32.590] - signal: TRUE
[17:02:32.591] - resignal: FALSE
[17:02:32.591] - force: TRUE
[17:02:32.591] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.591] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.591]  - until=4
[17:02:32.591]  - relaying element #4
[17:02:32.591] result() for MulticoreFuture ...
[17:02:32.591] result() for MulticoreFuture ... done
[17:02:32.591] result() for MulticoreFuture ...
[17:02:32.591] result() for MulticoreFuture ... done
[17:02:32.592] result() for MulticoreFuture ...
[17:02:32.592] result() for MulticoreFuture ... done
[17:02:32.592] result() for MulticoreFuture ...
[17:02:32.592] result() for MulticoreFuture ... done
[17:02:32.592] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.592] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.592] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:02:32.592]  length: 2 (resolved future 4)
[17:02:32.593] signalConditionsASAP(NULL, pos=5) ...
[17:02:32.593] - nx: 6
[17:02:32.593] - relay: TRUE
[17:02:32.593] - stdout: TRUE
[17:02:32.593] - signal: TRUE
[17:02:32.593] - resignal: FALSE
[17:02:32.593] - force: TRUE
[17:02:32.593] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.593] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.593]  - until=6
[17:02:32.593]  - relaying element #6
[17:02:32.594] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:32.594] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.594] signalConditionsASAP(NULL, pos=5) ... done
[17:02:32.594]  length: 1 (resolved future 5)
[17:02:32.594] signalConditionsASAP(numeric, pos=6) ...
[17:02:32.594] - nx: 6
[17:02:32.594] - relay: TRUE
[17:02:32.594] - stdout: TRUE
[17:02:32.594] - signal: TRUE
[17:02:32.594] - resignal: FALSE
[17:02:32.595] - force: TRUE
[17:02:32.595] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:32.595] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.595]  - until=6
[17:02:32.595] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.595] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.595] signalConditionsASAP(numeric, pos=6) ... done
[17:02:32.595]  length: 0 (resolved future 6)
[17:02:32.595] Relaying remaining futures
[17:02:32.596] signalConditionsASAP(NULL, pos=0) ...
[17:02:32.596] - nx: 6
[17:02:32.596] - relay: TRUE
[17:02:32.596] - stdout: TRUE
[17:02:32.596] - signal: TRUE
[17:02:32.596] - resignal: FALSE
[17:02:32.596] - force: TRUE
[17:02:32.596] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.596] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:32.596] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.597] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.597] signalConditionsASAP(NULL, pos=0) ... done
[17:02:32.597] resolve() on list environment ... DONE
[17:02:32.597] result() for MulticoreFuture ...
[17:02:32.597] result() for MulticoreFuture ... done
[17:02:32.597] result() for MulticoreFuture ...
[17:02:32.597] result() for MulticoreFuture ... done
[17:02:32.597] result() for MulticoreFuture ...
[17:02:32.598] result() for MulticoreFuture ... done
[17:02:32.598] result() for MulticoreFuture ...
[17:02:32.598] result() for MulticoreFuture ... done
[17:02:32.598] result() for MulticoreFuture ...
[17:02:32.598] result() for MulticoreFuture ... done
[17:02:32.598] result() for MulticoreFuture ...
[17:02:32.598] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c749d1f6e8> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:02:32.601] getGlobalsAndPackages() ...
[17:02:32.601] Searching for globals...
[17:02:32.602] 
[17:02:32.602] Searching for globals ... DONE
[17:02:32.602] - globals: [0] <none>
[17:02:32.602] getGlobalsAndPackages() ... DONE
[17:02:32.602] run() for ‘Future’ ...
[17:02:32.602] - state: ‘created’
[17:02:32.602] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.607] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.607]   - Field: ‘label’
[17:02:32.607]   - Field: ‘local’
[17:02:32.607]   - Field: ‘owner’
[17:02:32.607]   - Field: ‘envir’
[17:02:32.607]   - Field: ‘workers’
[17:02:32.607]   - Field: ‘packages’
[17:02:32.608]   - Field: ‘gc’
[17:02:32.608]   - Field: ‘job’
[17:02:32.608]   - Field: ‘conditions’
[17:02:32.608]   - Field: ‘expr’
[17:02:32.608]   - Field: ‘uuid’
[17:02:32.608]   - Field: ‘seed’
[17:02:32.608]   - Field: ‘version’
[17:02:32.608]   - Field: ‘result’
[17:02:32.608]   - Field: ‘asynchronous’
[17:02:32.609]   - Field: ‘calls’
[17:02:32.609]   - Field: ‘globals’
[17:02:32.609]   - Field: ‘stdout’
[17:02:32.609]   - Field: ‘earlySignal’
[17:02:32.609]   - Field: ‘lazy’
[17:02:32.609]   - Field: ‘state’
[17:02:32.609] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.609] - Launch lazy future ...
[17:02:32.610] Packages needed by the future expression (n = 0): <none>
[17:02:32.610] Packages needed by future strategies (n = 0): <none>
[17:02:32.610] {
[17:02:32.610]     {
[17:02:32.610]         {
[17:02:32.610]             ...future.startTime <- base::Sys.time()
[17:02:32.610]             {
[17:02:32.610]                 {
[17:02:32.610]                   {
[17:02:32.610]                     {
[17:02:32.610]                       base::local({
[17:02:32.610]                         has_future <- base::requireNamespace("future", 
[17:02:32.610]                           quietly = TRUE)
[17:02:32.610]                         if (has_future) {
[17:02:32.610]                           ns <- base::getNamespace("future")
[17:02:32.610]                           version <- ns[[".package"]][["version"]]
[17:02:32.610]                           if (is.null(version)) 
[17:02:32.610]                             version <- utils::packageVersion("future")
[17:02:32.610]                         }
[17:02:32.610]                         else {
[17:02:32.610]                           version <- NULL
[17:02:32.610]                         }
[17:02:32.610]                         if (!has_future || version < "1.8.0") {
[17:02:32.610]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.610]                             "", base::R.version$version.string), 
[17:02:32.610]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.610]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.610]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.610]                               "release", "version")], collapse = " "), 
[17:02:32.610]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.610]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.610]                             info)
[17:02:32.610]                           info <- base::paste(info, collapse = "; ")
[17:02:32.610]                           if (!has_future) {
[17:02:32.610]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.610]                               info)
[17:02:32.610]                           }
[17:02:32.610]                           else {
[17:02:32.610]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.610]                               info, version)
[17:02:32.610]                           }
[17:02:32.610]                           base::stop(msg)
[17:02:32.610]                         }
[17:02:32.610]                       })
[17:02:32.610]                     }
[17:02:32.610]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.610]                     base::options(mc.cores = 1L)
[17:02:32.610]                   }
[17:02:32.610]                   ...future.strategy.old <- future::plan("list")
[17:02:32.610]                   options(future.plan = NULL)
[17:02:32.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.610]                 }
[17:02:32.610]                 ...future.workdir <- getwd()
[17:02:32.610]             }
[17:02:32.610]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.610]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.610]         }
[17:02:32.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.610]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.610]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.610]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.610]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.610]             base::names(...future.oldOptions))
[17:02:32.610]     }
[17:02:32.610]     if (FALSE) {
[17:02:32.610]     }
[17:02:32.610]     else {
[17:02:32.610]         if (TRUE) {
[17:02:32.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.610]                 open = "w")
[17:02:32.610]         }
[17:02:32.610]         else {
[17:02:32.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.610]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.610]         }
[17:02:32.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.610]             base::sink(type = "output", split = FALSE)
[17:02:32.610]             base::close(...future.stdout)
[17:02:32.610]         }, add = TRUE)
[17:02:32.610]     }
[17:02:32.610]     ...future.frame <- base::sys.nframe()
[17:02:32.610]     ...future.conditions <- base::list()
[17:02:32.610]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.610]     if (FALSE) {
[17:02:32.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.610]     }
[17:02:32.610]     ...future.result <- base::tryCatch({
[17:02:32.610]         base::withCallingHandlers({
[17:02:32.610]             ...future.value <- base::withVisible(base::local({
[17:02:32.610]                 withCallingHandlers({
[17:02:32.610]                   2
[17:02:32.610]                 }, immediateCondition = function(cond) {
[17:02:32.610]                   save_rds <- function (object, pathname, ...) 
[17:02:32.610]                   {
[17:02:32.610]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.610]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.610]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.610]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.610]                         fi_tmp[["mtime"]])
[17:02:32.610]                     }
[17:02:32.610]                     tryCatch({
[17:02:32.610]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.610]                     }, error = function(ex) {
[17:02:32.610]                       msg <- conditionMessage(ex)
[17:02:32.610]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.610]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.610]                         fi_tmp[["mtime"]], msg)
[17:02:32.610]                       ex$message <- msg
[17:02:32.610]                       stop(ex)
[17:02:32.610]                     })
[17:02:32.610]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.610]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.610]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.610]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.610]                       fi <- file.info(pathname)
[17:02:32.610]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.610]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.610]                         fi[["size"]], fi[["mtime"]])
[17:02:32.610]                       stop(msg)
[17:02:32.610]                     }
[17:02:32.610]                     invisible(pathname)
[17:02:32.610]                   }
[17:02:32.610]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.610]                     rootPath = tempdir()) 
[17:02:32.610]                   {
[17:02:32.610]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.610]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.610]                       tmpdir = path, fileext = ".rds")
[17:02:32.610]                     save_rds(obj, file)
[17:02:32.610]                   }
[17:02:32.610]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.610]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.610]                   {
[17:02:32.610]                     inherits <- base::inherits
[17:02:32.610]                     invokeRestart <- base::invokeRestart
[17:02:32.610]                     is.null <- base::is.null
[17:02:32.610]                     muffled <- FALSE
[17:02:32.610]                     if (inherits(cond, "message")) {
[17:02:32.610]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.610]                       if (muffled) 
[17:02:32.610]                         invokeRestart("muffleMessage")
[17:02:32.610]                     }
[17:02:32.610]                     else if (inherits(cond, "warning")) {
[17:02:32.610]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.610]                       if (muffled) 
[17:02:32.610]                         invokeRestart("muffleWarning")
[17:02:32.610]                     }
[17:02:32.610]                     else if (inherits(cond, "condition")) {
[17:02:32.610]                       if (!is.null(pattern)) {
[17:02:32.610]                         computeRestarts <- base::computeRestarts
[17:02:32.610]                         grepl <- base::grepl
[17:02:32.610]                         restarts <- computeRestarts(cond)
[17:02:32.610]                         for (restart in restarts) {
[17:02:32.610]                           name <- restart$name
[17:02:32.610]                           if (is.null(name)) 
[17:02:32.610]                             next
[17:02:32.610]                           if (!grepl(pattern, name)) 
[17:02:32.610]                             next
[17:02:32.610]                           invokeRestart(restart)
[17:02:32.610]                           muffled <- TRUE
[17:02:32.610]                           break
[17:02:32.610]                         }
[17:02:32.610]                       }
[17:02:32.610]                     }
[17:02:32.610]                     invisible(muffled)
[17:02:32.610]                   }
[17:02:32.610]                   muffleCondition(cond)
[17:02:32.610]                 })
[17:02:32.610]             }))
[17:02:32.610]             future::FutureResult(value = ...future.value$value, 
[17:02:32.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.610]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.610]                     ...future.globalenv.names))
[17:02:32.610]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.610]         }, condition = base::local({
[17:02:32.610]             c <- base::c
[17:02:32.610]             inherits <- base::inherits
[17:02:32.610]             invokeRestart <- base::invokeRestart
[17:02:32.610]             length <- base::length
[17:02:32.610]             list <- base::list
[17:02:32.610]             seq.int <- base::seq.int
[17:02:32.610]             signalCondition <- base::signalCondition
[17:02:32.610]             sys.calls <- base::sys.calls
[17:02:32.610]             `[[` <- base::`[[`
[17:02:32.610]             `+` <- base::`+`
[17:02:32.610]             `<<-` <- base::`<<-`
[17:02:32.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.610]                   3L)]
[17:02:32.610]             }
[17:02:32.610]             function(cond) {
[17:02:32.610]                 is_error <- inherits(cond, "error")
[17:02:32.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.610]                   NULL)
[17:02:32.610]                 if (is_error) {
[17:02:32.610]                   sessionInformation <- function() {
[17:02:32.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.610]                       search = base::search(), system = base::Sys.info())
[17:02:32.610]                   }
[17:02:32.610]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.610]                     cond$call), session = sessionInformation(), 
[17:02:32.610]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.610]                   signalCondition(cond)
[17:02:32.610]                 }
[17:02:32.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.610]                 "immediateCondition"))) {
[17:02:32.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.610]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.610]                   if (TRUE && !signal) {
[17:02:32.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.610]                     {
[17:02:32.610]                       inherits <- base::inherits
[17:02:32.610]                       invokeRestart <- base::invokeRestart
[17:02:32.610]                       is.null <- base::is.null
[17:02:32.610]                       muffled <- FALSE
[17:02:32.610]                       if (inherits(cond, "message")) {
[17:02:32.610]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.610]                         if (muffled) 
[17:02:32.610]                           invokeRestart("muffleMessage")
[17:02:32.610]                       }
[17:02:32.610]                       else if (inherits(cond, "warning")) {
[17:02:32.610]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.610]                         if (muffled) 
[17:02:32.610]                           invokeRestart("muffleWarning")
[17:02:32.610]                       }
[17:02:32.610]                       else if (inherits(cond, "condition")) {
[17:02:32.610]                         if (!is.null(pattern)) {
[17:02:32.610]                           computeRestarts <- base::computeRestarts
[17:02:32.610]                           grepl <- base::grepl
[17:02:32.610]                           restarts <- computeRestarts(cond)
[17:02:32.610]                           for (restart in restarts) {
[17:02:32.610]                             name <- restart$name
[17:02:32.610]                             if (is.null(name)) 
[17:02:32.610]                               next
[17:02:32.610]                             if (!grepl(pattern, name)) 
[17:02:32.610]                               next
[17:02:32.610]                             invokeRestart(restart)
[17:02:32.610]                             muffled <- TRUE
[17:02:32.610]                             break
[17:02:32.610]                           }
[17:02:32.610]                         }
[17:02:32.610]                       }
[17:02:32.610]                       invisible(muffled)
[17:02:32.610]                     }
[17:02:32.610]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.610]                   }
[17:02:32.610]                 }
[17:02:32.610]                 else {
[17:02:32.610]                   if (TRUE) {
[17:02:32.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.610]                     {
[17:02:32.610]                       inherits <- base::inherits
[17:02:32.610]                       invokeRestart <- base::invokeRestart
[17:02:32.610]                       is.null <- base::is.null
[17:02:32.610]                       muffled <- FALSE
[17:02:32.610]                       if (inherits(cond, "message")) {
[17:02:32.610]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.610]                         if (muffled) 
[17:02:32.610]                           invokeRestart("muffleMessage")
[17:02:32.610]                       }
[17:02:32.610]                       else if (inherits(cond, "warning")) {
[17:02:32.610]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.610]                         if (muffled) 
[17:02:32.610]                           invokeRestart("muffleWarning")
[17:02:32.610]                       }
[17:02:32.610]                       else if (inherits(cond, "condition")) {
[17:02:32.610]                         if (!is.null(pattern)) {
[17:02:32.610]                           computeRestarts <- base::computeRestarts
[17:02:32.610]                           grepl <- base::grepl
[17:02:32.610]                           restarts <- computeRestarts(cond)
[17:02:32.610]                           for (restart in restarts) {
[17:02:32.610]                             name <- restart$name
[17:02:32.610]                             if (is.null(name)) 
[17:02:32.610]                               next
[17:02:32.610]                             if (!grepl(pattern, name)) 
[17:02:32.610]                               next
[17:02:32.610]                             invokeRestart(restart)
[17:02:32.610]                             muffled <- TRUE
[17:02:32.610]                             break
[17:02:32.610]                           }
[17:02:32.610]                         }
[17:02:32.610]                       }
[17:02:32.610]                       invisible(muffled)
[17:02:32.610]                     }
[17:02:32.610]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.610]                   }
[17:02:32.610]                 }
[17:02:32.610]             }
[17:02:32.610]         }))
[17:02:32.610]     }, error = function(ex) {
[17:02:32.610]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.610]                 ...future.rng), started = ...future.startTime, 
[17:02:32.610]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.610]             version = "1.8"), class = "FutureResult")
[17:02:32.610]     }, finally = {
[17:02:32.610]         if (!identical(...future.workdir, getwd())) 
[17:02:32.610]             setwd(...future.workdir)
[17:02:32.610]         {
[17:02:32.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.610]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.610]             }
[17:02:32.610]             base::options(...future.oldOptions)
[17:02:32.610]             if (.Platform$OS.type == "windows") {
[17:02:32.610]                 old_names <- names(...future.oldEnvVars)
[17:02:32.610]                 envs <- base::Sys.getenv()
[17:02:32.610]                 names <- names(envs)
[17:02:32.610]                 common <- intersect(names, old_names)
[17:02:32.610]                 added <- setdiff(names, old_names)
[17:02:32.610]                 removed <- setdiff(old_names, names)
[17:02:32.610]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.610]                   envs[common]]
[17:02:32.610]                 NAMES <- toupper(changed)
[17:02:32.610]                 args <- list()
[17:02:32.610]                 for (kk in seq_along(NAMES)) {
[17:02:32.610]                   name <- changed[[kk]]
[17:02:32.610]                   NAME <- NAMES[[kk]]
[17:02:32.610]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.610]                     next
[17:02:32.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.610]                 }
[17:02:32.610]                 NAMES <- toupper(added)
[17:02:32.610]                 for (kk in seq_along(NAMES)) {
[17:02:32.610]                   name <- added[[kk]]
[17:02:32.610]                   NAME <- NAMES[[kk]]
[17:02:32.610]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.610]                     next
[17:02:32.610]                   args[[name]] <- ""
[17:02:32.610]                 }
[17:02:32.610]                 NAMES <- toupper(removed)
[17:02:32.610]                 for (kk in seq_along(NAMES)) {
[17:02:32.610]                   name <- removed[[kk]]
[17:02:32.610]                   NAME <- NAMES[[kk]]
[17:02:32.610]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.610]                     next
[17:02:32.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.610]                 }
[17:02:32.610]                 if (length(args) > 0) 
[17:02:32.610]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.610]             }
[17:02:32.610]             else {
[17:02:32.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.610]             }
[17:02:32.610]             {
[17:02:32.610]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.610]                   0L) {
[17:02:32.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.610]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.610]                   base::options(opts)
[17:02:32.610]                 }
[17:02:32.610]                 {
[17:02:32.610]                   {
[17:02:32.610]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.610]                     NULL
[17:02:32.610]                   }
[17:02:32.610]                   options(future.plan = NULL)
[17:02:32.610]                   if (is.na(NA_character_)) 
[17:02:32.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.610]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.610]                     .init = FALSE)
[17:02:32.610]                 }
[17:02:32.610]             }
[17:02:32.610]         }
[17:02:32.610]     })
[17:02:32.610]     if (TRUE) {
[17:02:32.610]         base::sink(type = "output", split = FALSE)
[17:02:32.610]         if (TRUE) {
[17:02:32.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.610]         }
[17:02:32.610]         else {
[17:02:32.610]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.610]         }
[17:02:32.610]         base::close(...future.stdout)
[17:02:32.610]         ...future.stdout <- NULL
[17:02:32.610]     }
[17:02:32.610]     ...future.result$conditions <- ...future.conditions
[17:02:32.610]     ...future.result$finished <- base::Sys.time()
[17:02:32.610]     ...future.result
[17:02:32.610] }
[17:02:32.613] requestCore(): workers = 2
[17:02:32.615] MulticoreFuture started
[17:02:32.615] - Launch lazy future ... done
[17:02:32.616] run() for ‘MulticoreFuture’ ... done
[17:02:32.616] getGlobalsAndPackages() ...
[17:02:32.616] Searching for globals...
[17:02:32.616] plan(): Setting new future strategy stack:
[17:02:32.617] 
[17:02:32.617] Searching for globals ... DONE
[17:02:32.617] List of future strategies:
[17:02:32.617] 1. sequential:
[17:02:32.617]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.617]    - tweaked: FALSE
[17:02:32.617]    - call: NULL
[17:02:32.617] - globals: [0] <none>
[17:02:32.618] plan(): nbrOfWorkers() = 1
[17:02:32.618] getGlobalsAndPackages() ... DONE
[17:02:32.618] run() for ‘Future’ ...
[17:02:32.618] - state: ‘created’
[17:02:32.618] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.620] plan(): Setting new future strategy stack:
[17:02:32.620] List of future strategies:
[17:02:32.620] 1. multicore:
[17:02:32.620]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.620]    - tweaked: FALSE
[17:02:32.620]    - call: plan(strategy)
[17:02:32.624] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.624] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.624]   - Field: ‘label’
[17:02:32.625] plan(): nbrOfWorkers() = 2
[17:02:32.625]   - Field: ‘local’
[17:02:32.625]   - Field: ‘owner’
[17:02:32.625]   - Field: ‘envir’
[17:02:32.625]   - Field: ‘workers’
[17:02:32.625]   - Field: ‘packages’
[17:02:32.625]   - Field: ‘gc’
[17:02:32.625]   - Field: ‘job’
[17:02:32.626]   - Field: ‘conditions’
[17:02:32.626]   - Field: ‘expr’
[17:02:32.626]   - Field: ‘uuid’
[17:02:32.626]   - Field: ‘seed’
[17:02:32.626]   - Field: ‘version’
[17:02:32.626]   - Field: ‘result’
[17:02:32.626]   - Field: ‘asynchronous’
[17:02:32.627]   - Field: ‘calls’
[17:02:32.627]   - Field: ‘globals’
[17:02:32.627]   - Field: ‘stdout’
[17:02:32.627]   - Field: ‘earlySignal’
[17:02:32.627]   - Field: ‘lazy’
[17:02:32.627]   - Field: ‘state’
[17:02:32.627] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.628] - Launch lazy future ...
[17:02:32.628] Packages needed by the future expression (n = 0): <none>
[17:02:32.628] Packages needed by future strategies (n = 0): <none>
[17:02:32.629] {
[17:02:32.629]     {
[17:02:32.629]         {
[17:02:32.629]             ...future.startTime <- base::Sys.time()
[17:02:32.629]             {
[17:02:32.629]                 {
[17:02:32.629]                   {
[17:02:32.629]                     {
[17:02:32.629]                       base::local({
[17:02:32.629]                         has_future <- base::requireNamespace("future", 
[17:02:32.629]                           quietly = TRUE)
[17:02:32.629]                         if (has_future) {
[17:02:32.629]                           ns <- base::getNamespace("future")
[17:02:32.629]                           version <- ns[[".package"]][["version"]]
[17:02:32.629]                           if (is.null(version)) 
[17:02:32.629]                             version <- utils::packageVersion("future")
[17:02:32.629]                         }
[17:02:32.629]                         else {
[17:02:32.629]                           version <- NULL
[17:02:32.629]                         }
[17:02:32.629]                         if (!has_future || version < "1.8.0") {
[17:02:32.629]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.629]                             "", base::R.version$version.string), 
[17:02:32.629]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.629]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.629]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.629]                               "release", "version")], collapse = " "), 
[17:02:32.629]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.629]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.629]                             info)
[17:02:32.629]                           info <- base::paste(info, collapse = "; ")
[17:02:32.629]                           if (!has_future) {
[17:02:32.629]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.629]                               info)
[17:02:32.629]                           }
[17:02:32.629]                           else {
[17:02:32.629]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.629]                               info, version)
[17:02:32.629]                           }
[17:02:32.629]                           base::stop(msg)
[17:02:32.629]                         }
[17:02:32.629]                       })
[17:02:32.629]                     }
[17:02:32.629]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.629]                     base::options(mc.cores = 1L)
[17:02:32.629]                   }
[17:02:32.629]                   ...future.strategy.old <- future::plan("list")
[17:02:32.629]                   options(future.plan = NULL)
[17:02:32.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.629]                 }
[17:02:32.629]                 ...future.workdir <- getwd()
[17:02:32.629]             }
[17:02:32.629]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.629]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.629]         }
[17:02:32.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.629]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.629]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.629]             base::names(...future.oldOptions))
[17:02:32.629]     }
[17:02:32.629]     if (FALSE) {
[17:02:32.629]     }
[17:02:32.629]     else {
[17:02:32.629]         if (TRUE) {
[17:02:32.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.629]                 open = "w")
[17:02:32.629]         }
[17:02:32.629]         else {
[17:02:32.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.629]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.629]         }
[17:02:32.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.629]             base::sink(type = "output", split = FALSE)
[17:02:32.629]             base::close(...future.stdout)
[17:02:32.629]         }, add = TRUE)
[17:02:32.629]     }
[17:02:32.629]     ...future.frame <- base::sys.nframe()
[17:02:32.629]     ...future.conditions <- base::list()
[17:02:32.629]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.629]     if (FALSE) {
[17:02:32.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.629]     }
[17:02:32.629]     ...future.result <- base::tryCatch({
[17:02:32.629]         base::withCallingHandlers({
[17:02:32.629]             ...future.value <- base::withVisible(base::local({
[17:02:32.629]                 withCallingHandlers({
[17:02:32.629]                   NULL
[17:02:32.629]                 }, immediateCondition = function(cond) {
[17:02:32.629]                   save_rds <- function (object, pathname, ...) 
[17:02:32.629]                   {
[17:02:32.629]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.629]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.629]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.629]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.629]                         fi_tmp[["mtime"]])
[17:02:32.629]                     }
[17:02:32.629]                     tryCatch({
[17:02:32.629]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.629]                     }, error = function(ex) {
[17:02:32.629]                       msg <- conditionMessage(ex)
[17:02:32.629]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.629]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.629]                         fi_tmp[["mtime"]], msg)
[17:02:32.629]                       ex$message <- msg
[17:02:32.629]                       stop(ex)
[17:02:32.629]                     })
[17:02:32.629]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.629]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.629]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.629]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.629]                       fi <- file.info(pathname)
[17:02:32.629]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.629]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.629]                         fi[["size"]], fi[["mtime"]])
[17:02:32.629]                       stop(msg)
[17:02:32.629]                     }
[17:02:32.629]                     invisible(pathname)
[17:02:32.629]                   }
[17:02:32.629]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.629]                     rootPath = tempdir()) 
[17:02:32.629]                   {
[17:02:32.629]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.629]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.629]                       tmpdir = path, fileext = ".rds")
[17:02:32.629]                     save_rds(obj, file)
[17:02:32.629]                   }
[17:02:32.629]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.629]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.629]                   {
[17:02:32.629]                     inherits <- base::inherits
[17:02:32.629]                     invokeRestart <- base::invokeRestart
[17:02:32.629]                     is.null <- base::is.null
[17:02:32.629]                     muffled <- FALSE
[17:02:32.629]                     if (inherits(cond, "message")) {
[17:02:32.629]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.629]                       if (muffled) 
[17:02:32.629]                         invokeRestart("muffleMessage")
[17:02:32.629]                     }
[17:02:32.629]                     else if (inherits(cond, "warning")) {
[17:02:32.629]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.629]                       if (muffled) 
[17:02:32.629]                         invokeRestart("muffleWarning")
[17:02:32.629]                     }
[17:02:32.629]                     else if (inherits(cond, "condition")) {
[17:02:32.629]                       if (!is.null(pattern)) {
[17:02:32.629]                         computeRestarts <- base::computeRestarts
[17:02:32.629]                         grepl <- base::grepl
[17:02:32.629]                         restarts <- computeRestarts(cond)
[17:02:32.629]                         for (restart in restarts) {
[17:02:32.629]                           name <- restart$name
[17:02:32.629]                           if (is.null(name)) 
[17:02:32.629]                             next
[17:02:32.629]                           if (!grepl(pattern, name)) 
[17:02:32.629]                             next
[17:02:32.629]                           invokeRestart(restart)
[17:02:32.629]                           muffled <- TRUE
[17:02:32.629]                           break
[17:02:32.629]                         }
[17:02:32.629]                       }
[17:02:32.629]                     }
[17:02:32.629]                     invisible(muffled)
[17:02:32.629]                   }
[17:02:32.629]                   muffleCondition(cond)
[17:02:32.629]                 })
[17:02:32.629]             }))
[17:02:32.629]             future::FutureResult(value = ...future.value$value, 
[17:02:32.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.629]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.629]                     ...future.globalenv.names))
[17:02:32.629]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.629]         }, condition = base::local({
[17:02:32.629]             c <- base::c
[17:02:32.629]             inherits <- base::inherits
[17:02:32.629]             invokeRestart <- base::invokeRestart
[17:02:32.629]             length <- base::length
[17:02:32.629]             list <- base::list
[17:02:32.629]             seq.int <- base::seq.int
[17:02:32.629]             signalCondition <- base::signalCondition
[17:02:32.629]             sys.calls <- base::sys.calls
[17:02:32.629]             `[[` <- base::`[[`
[17:02:32.629]             `+` <- base::`+`
[17:02:32.629]             `<<-` <- base::`<<-`
[17:02:32.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.629]                   3L)]
[17:02:32.629]             }
[17:02:32.629]             function(cond) {
[17:02:32.629]                 is_error <- inherits(cond, "error")
[17:02:32.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.629]                   NULL)
[17:02:32.629]                 if (is_error) {
[17:02:32.629]                   sessionInformation <- function() {
[17:02:32.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.629]                       search = base::search(), system = base::Sys.info())
[17:02:32.629]                   }
[17:02:32.629]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.629]                     cond$call), session = sessionInformation(), 
[17:02:32.629]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.629]                   signalCondition(cond)
[17:02:32.629]                 }
[17:02:32.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.629]                 "immediateCondition"))) {
[17:02:32.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.629]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.629]                   if (TRUE && !signal) {
[17:02:32.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.629]                     {
[17:02:32.629]                       inherits <- base::inherits
[17:02:32.629]                       invokeRestart <- base::invokeRestart
[17:02:32.629]                       is.null <- base::is.null
[17:02:32.629]                       muffled <- FALSE
[17:02:32.629]                       if (inherits(cond, "message")) {
[17:02:32.629]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.629]                         if (muffled) 
[17:02:32.629]                           invokeRestart("muffleMessage")
[17:02:32.629]                       }
[17:02:32.629]                       else if (inherits(cond, "warning")) {
[17:02:32.629]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.629]                         if (muffled) 
[17:02:32.629]                           invokeRestart("muffleWarning")
[17:02:32.629]                       }
[17:02:32.629]                       else if (inherits(cond, "condition")) {
[17:02:32.629]                         if (!is.null(pattern)) {
[17:02:32.629]                           computeRestarts <- base::computeRestarts
[17:02:32.629]                           grepl <- base::grepl
[17:02:32.629]                           restarts <- computeRestarts(cond)
[17:02:32.629]                           for (restart in restarts) {
[17:02:32.629]                             name <- restart$name
[17:02:32.629]                             if (is.null(name)) 
[17:02:32.629]                               next
[17:02:32.629]                             if (!grepl(pattern, name)) 
[17:02:32.629]                               next
[17:02:32.629]                             invokeRestart(restart)
[17:02:32.629]                             muffled <- TRUE
[17:02:32.629]                             break
[17:02:32.629]                           }
[17:02:32.629]                         }
[17:02:32.629]                       }
[17:02:32.629]                       invisible(muffled)
[17:02:32.629]                     }
[17:02:32.629]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.629]                   }
[17:02:32.629]                 }
[17:02:32.629]                 else {
[17:02:32.629]                   if (TRUE) {
[17:02:32.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.629]                     {
[17:02:32.629]                       inherits <- base::inherits
[17:02:32.629]                       invokeRestart <- base::invokeRestart
[17:02:32.629]                       is.null <- base::is.null
[17:02:32.629]                       muffled <- FALSE
[17:02:32.629]                       if (inherits(cond, "message")) {
[17:02:32.629]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.629]                         if (muffled) 
[17:02:32.629]                           invokeRestart("muffleMessage")
[17:02:32.629]                       }
[17:02:32.629]                       else if (inherits(cond, "warning")) {
[17:02:32.629]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.629]                         if (muffled) 
[17:02:32.629]                           invokeRestart("muffleWarning")
[17:02:32.629]                       }
[17:02:32.629]                       else if (inherits(cond, "condition")) {
[17:02:32.629]                         if (!is.null(pattern)) {
[17:02:32.629]                           computeRestarts <- base::computeRestarts
[17:02:32.629]                           grepl <- base::grepl
[17:02:32.629]                           restarts <- computeRestarts(cond)
[17:02:32.629]                           for (restart in restarts) {
[17:02:32.629]                             name <- restart$name
[17:02:32.629]                             if (is.null(name)) 
[17:02:32.629]                               next
[17:02:32.629]                             if (!grepl(pattern, name)) 
[17:02:32.629]                               next
[17:02:32.629]                             invokeRestart(restart)
[17:02:32.629]                             muffled <- TRUE
[17:02:32.629]                             break
[17:02:32.629]                           }
[17:02:32.629]                         }
[17:02:32.629]                       }
[17:02:32.629]                       invisible(muffled)
[17:02:32.629]                     }
[17:02:32.629]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.629]                   }
[17:02:32.629]                 }
[17:02:32.629]             }
[17:02:32.629]         }))
[17:02:32.629]     }, error = function(ex) {
[17:02:32.629]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.629]                 ...future.rng), started = ...future.startTime, 
[17:02:32.629]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.629]             version = "1.8"), class = "FutureResult")
[17:02:32.629]     }, finally = {
[17:02:32.629]         if (!identical(...future.workdir, getwd())) 
[17:02:32.629]             setwd(...future.workdir)
[17:02:32.629]         {
[17:02:32.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.629]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.629]             }
[17:02:32.629]             base::options(...future.oldOptions)
[17:02:32.629]             if (.Platform$OS.type == "windows") {
[17:02:32.629]                 old_names <- names(...future.oldEnvVars)
[17:02:32.629]                 envs <- base::Sys.getenv()
[17:02:32.629]                 names <- names(envs)
[17:02:32.629]                 common <- intersect(names, old_names)
[17:02:32.629]                 added <- setdiff(names, old_names)
[17:02:32.629]                 removed <- setdiff(old_names, names)
[17:02:32.629]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.629]                   envs[common]]
[17:02:32.629]                 NAMES <- toupper(changed)
[17:02:32.629]                 args <- list()
[17:02:32.629]                 for (kk in seq_along(NAMES)) {
[17:02:32.629]                   name <- changed[[kk]]
[17:02:32.629]                   NAME <- NAMES[[kk]]
[17:02:32.629]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.629]                     next
[17:02:32.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.629]                 }
[17:02:32.629]                 NAMES <- toupper(added)
[17:02:32.629]                 for (kk in seq_along(NAMES)) {
[17:02:32.629]                   name <- added[[kk]]
[17:02:32.629]                   NAME <- NAMES[[kk]]
[17:02:32.629]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.629]                     next
[17:02:32.629]                   args[[name]] <- ""
[17:02:32.629]                 }
[17:02:32.629]                 NAMES <- toupper(removed)
[17:02:32.629]                 for (kk in seq_along(NAMES)) {
[17:02:32.629]                   name <- removed[[kk]]
[17:02:32.629]                   NAME <- NAMES[[kk]]
[17:02:32.629]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.629]                     next
[17:02:32.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.629]                 }
[17:02:32.629]                 if (length(args) > 0) 
[17:02:32.629]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.629]             }
[17:02:32.629]             else {
[17:02:32.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.629]             }
[17:02:32.629]             {
[17:02:32.629]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.629]                   0L) {
[17:02:32.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.629]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.629]                   base::options(opts)
[17:02:32.629]                 }
[17:02:32.629]                 {
[17:02:32.629]                   {
[17:02:32.629]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.629]                     NULL
[17:02:32.629]                   }
[17:02:32.629]                   options(future.plan = NULL)
[17:02:32.629]                   if (is.na(NA_character_)) 
[17:02:32.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.629]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.629]                     .init = FALSE)
[17:02:32.629]                 }
[17:02:32.629]             }
[17:02:32.629]         }
[17:02:32.629]     })
[17:02:32.629]     if (TRUE) {
[17:02:32.629]         base::sink(type = "output", split = FALSE)
[17:02:32.629]         if (TRUE) {
[17:02:32.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.629]         }
[17:02:32.629]         else {
[17:02:32.629]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.629]         }
[17:02:32.629]         base::close(...future.stdout)
[17:02:32.629]         ...future.stdout <- NULL
[17:02:32.629]     }
[17:02:32.629]     ...future.result$conditions <- ...future.conditions
[17:02:32.629]     ...future.result$finished <- base::Sys.time()
[17:02:32.629]     ...future.result
[17:02:32.629] }
[17:02:32.633] requestCore(): workers = 2
[17:02:32.636] MulticoreFuture started
[17:02:32.636] - Launch lazy future ... done
[17:02:32.636] run() for ‘MulticoreFuture’ ... done
[17:02:32.637] plan(): Setting new future strategy stack:
[17:02:32.638] getGlobalsAndPackages() ...
[17:02:32.638] Searching for globals...
[17:02:32.637] List of future strategies:
[17:02:32.637] 1. sequential:
[17:02:32.637]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.637]    - tweaked: FALSE
[17:02:32.637]    - call: NULL
[17:02:32.639] plan(): nbrOfWorkers() = 1
[17:02:32.640] - globals found: [1] ‘{’
[17:02:32.640] Searching for globals ... DONE
[17:02:32.640] Resolving globals: FALSE
[17:02:32.641] 
[17:02:32.641] 
[17:02:32.642] getGlobalsAndPackages() ... DONE
[17:02:32.642] plan(): Setting new future strategy stack:
[17:02:32.642] run() for ‘Future’ ...
[17:02:32.642] List of future strategies:
[17:02:32.642] 1. multicore:
[17:02:32.642]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.642]    - tweaked: FALSE
[17:02:32.642]    - call: plan(strategy)
[17:02:32.642] - state: ‘created’
[17:02:32.643] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:32.648] plan(): nbrOfWorkers() = 2
[17:02:32.648] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:32.649] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:32.649]   - Field: ‘label’
[17:02:32.649]   - Field: ‘local’
[17:02:32.649]   - Field: ‘owner’
[17:02:32.649]   - Field: ‘envir’
[17:02:32.650]   - Field: ‘workers’
[17:02:32.650]   - Field: ‘packages’
[17:02:32.650]   - Field: ‘gc’
[17:02:32.650]   - Field: ‘job’
[17:02:32.650]   - Field: ‘conditions’
[17:02:32.650]   - Field: ‘expr’
[17:02:32.650]   - Field: ‘uuid’
[17:02:32.650]   - Field: ‘seed’
[17:02:32.651]   - Field: ‘version’
[17:02:32.651]   - Field: ‘result’
[17:02:32.651]   - Field: ‘asynchronous’
[17:02:32.651]   - Field: ‘calls’
[17:02:32.651]   - Field: ‘globals’
[17:02:32.651]   - Field: ‘stdout’
[17:02:32.651]   - Field: ‘earlySignal’
[17:02:32.652]   - Field: ‘lazy’
[17:02:32.652]   - Field: ‘state’
[17:02:32.652] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:32.652] - Launch lazy future ...
[17:02:32.652] Packages needed by the future expression (n = 0): <none>
[17:02:32.653] Packages needed by future strategies (n = 0): <none>
[17:02:32.653] {
[17:02:32.653]     {
[17:02:32.653]         {
[17:02:32.653]             ...future.startTime <- base::Sys.time()
[17:02:32.653]             {
[17:02:32.653]                 {
[17:02:32.653]                   {
[17:02:32.653]                     {
[17:02:32.653]                       base::local({
[17:02:32.653]                         has_future <- base::requireNamespace("future", 
[17:02:32.653]                           quietly = TRUE)
[17:02:32.653]                         if (has_future) {
[17:02:32.653]                           ns <- base::getNamespace("future")
[17:02:32.653]                           version <- ns[[".package"]][["version"]]
[17:02:32.653]                           if (is.null(version)) 
[17:02:32.653]                             version <- utils::packageVersion("future")
[17:02:32.653]                         }
[17:02:32.653]                         else {
[17:02:32.653]                           version <- NULL
[17:02:32.653]                         }
[17:02:32.653]                         if (!has_future || version < "1.8.0") {
[17:02:32.653]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:32.653]                             "", base::R.version$version.string), 
[17:02:32.653]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:32.653]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:32.653]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:32.653]                               "release", "version")], collapse = " "), 
[17:02:32.653]                             hostname = base::Sys.info()[["nodename"]])
[17:02:32.653]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:32.653]                             info)
[17:02:32.653]                           info <- base::paste(info, collapse = "; ")
[17:02:32.653]                           if (!has_future) {
[17:02:32.653]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:32.653]                               info)
[17:02:32.653]                           }
[17:02:32.653]                           else {
[17:02:32.653]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:32.653]                               info, version)
[17:02:32.653]                           }
[17:02:32.653]                           base::stop(msg)
[17:02:32.653]                         }
[17:02:32.653]                       })
[17:02:32.653]                     }
[17:02:32.653]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:32.653]                     base::options(mc.cores = 1L)
[17:02:32.653]                   }
[17:02:32.653]                   ...future.strategy.old <- future::plan("list")
[17:02:32.653]                   options(future.plan = NULL)
[17:02:32.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:32.653]                 }
[17:02:32.653]                 ...future.workdir <- getwd()
[17:02:32.653]             }
[17:02:32.653]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:32.653]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:32.653]         }
[17:02:32.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:32.653]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:32.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:32.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:32.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:32.653]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:32.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:32.653]             base::names(...future.oldOptions))
[17:02:32.653]     }
[17:02:32.653]     if (FALSE) {
[17:02:32.653]     }
[17:02:32.653]     else {
[17:02:32.653]         if (TRUE) {
[17:02:32.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:32.653]                 open = "w")
[17:02:32.653]         }
[17:02:32.653]         else {
[17:02:32.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:32.653]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:32.653]         }
[17:02:32.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:32.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:32.653]             base::sink(type = "output", split = FALSE)
[17:02:32.653]             base::close(...future.stdout)
[17:02:32.653]         }, add = TRUE)
[17:02:32.653]     }
[17:02:32.653]     ...future.frame <- base::sys.nframe()
[17:02:32.653]     ...future.conditions <- base::list()
[17:02:32.653]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:32.653]     if (FALSE) {
[17:02:32.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:32.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:32.653]     }
[17:02:32.653]     ...future.result <- base::tryCatch({
[17:02:32.653]         base::withCallingHandlers({
[17:02:32.653]             ...future.value <- base::withVisible(base::local({
[17:02:32.653]                 withCallingHandlers({
[17:02:32.653]                   {
[17:02:32.653]                     4
[17:02:32.653]                   }
[17:02:32.653]                 }, immediateCondition = function(cond) {
[17:02:32.653]                   save_rds <- function (object, pathname, ...) 
[17:02:32.653]                   {
[17:02:32.653]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:32.653]                     if (file_test("-f", pathname_tmp)) {
[17:02:32.653]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.653]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:32.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.653]                         fi_tmp[["mtime"]])
[17:02:32.653]                     }
[17:02:32.653]                     tryCatch({
[17:02:32.653]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:32.653]                     }, error = function(ex) {
[17:02:32.653]                       msg <- conditionMessage(ex)
[17:02:32.653]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.653]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:32.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.653]                         fi_tmp[["mtime"]], msg)
[17:02:32.653]                       ex$message <- msg
[17:02:32.653]                       stop(ex)
[17:02:32.653]                     })
[17:02:32.653]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:32.653]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:32.653]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:32.653]                       fi_tmp <- file.info(pathname_tmp)
[17:02:32.653]                       fi <- file.info(pathname)
[17:02:32.653]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:32.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:32.653]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:32.653]                         fi[["size"]], fi[["mtime"]])
[17:02:32.653]                       stop(msg)
[17:02:32.653]                     }
[17:02:32.653]                     invisible(pathname)
[17:02:32.653]                   }
[17:02:32.653]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:32.653]                     rootPath = tempdir()) 
[17:02:32.653]                   {
[17:02:32.653]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:32.653]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:32.653]                       tmpdir = path, fileext = ".rds")
[17:02:32.653]                     save_rds(obj, file)
[17:02:32.653]                   }
[17:02:32.653]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9yGsuH/.future/immediateConditions")
[17:02:32.653]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.653]                   {
[17:02:32.653]                     inherits <- base::inherits
[17:02:32.653]                     invokeRestart <- base::invokeRestart
[17:02:32.653]                     is.null <- base::is.null
[17:02:32.653]                     muffled <- FALSE
[17:02:32.653]                     if (inherits(cond, "message")) {
[17:02:32.653]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:32.653]                       if (muffled) 
[17:02:32.653]                         invokeRestart("muffleMessage")
[17:02:32.653]                     }
[17:02:32.653]                     else if (inherits(cond, "warning")) {
[17:02:32.653]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:32.653]                       if (muffled) 
[17:02:32.653]                         invokeRestart("muffleWarning")
[17:02:32.653]                     }
[17:02:32.653]                     else if (inherits(cond, "condition")) {
[17:02:32.653]                       if (!is.null(pattern)) {
[17:02:32.653]                         computeRestarts <- base::computeRestarts
[17:02:32.653]                         grepl <- base::grepl
[17:02:32.653]                         restarts <- computeRestarts(cond)
[17:02:32.653]                         for (restart in restarts) {
[17:02:32.653]                           name <- restart$name
[17:02:32.653]                           if (is.null(name)) 
[17:02:32.653]                             next
[17:02:32.653]                           if (!grepl(pattern, name)) 
[17:02:32.653]                             next
[17:02:32.653]                           invokeRestart(restart)
[17:02:32.653]                           muffled <- TRUE
[17:02:32.653]                           break
[17:02:32.653]                         }
[17:02:32.653]                       }
[17:02:32.653]                     }
[17:02:32.653]                     invisible(muffled)
[17:02:32.653]                   }
[17:02:32.653]                   muffleCondition(cond)
[17:02:32.653]                 })
[17:02:32.653]             }))
[17:02:32.653]             future::FutureResult(value = ...future.value$value, 
[17:02:32.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.653]                   ...future.rng), globalenv = if (FALSE) 
[17:02:32.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:32.653]                     ...future.globalenv.names))
[17:02:32.653]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:32.653]         }, condition = base::local({
[17:02:32.653]             c <- base::c
[17:02:32.653]             inherits <- base::inherits
[17:02:32.653]             invokeRestart <- base::invokeRestart
[17:02:32.653]             length <- base::length
[17:02:32.653]             list <- base::list
[17:02:32.653]             seq.int <- base::seq.int
[17:02:32.653]             signalCondition <- base::signalCondition
[17:02:32.653]             sys.calls <- base::sys.calls
[17:02:32.653]             `[[` <- base::`[[`
[17:02:32.653]             `+` <- base::`+`
[17:02:32.653]             `<<-` <- base::`<<-`
[17:02:32.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:32.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:32.653]                   3L)]
[17:02:32.653]             }
[17:02:32.653]             function(cond) {
[17:02:32.653]                 is_error <- inherits(cond, "error")
[17:02:32.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:32.653]                   NULL)
[17:02:32.653]                 if (is_error) {
[17:02:32.653]                   sessionInformation <- function() {
[17:02:32.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:32.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:32.653]                       search = base::search(), system = base::Sys.info())
[17:02:32.653]                   }
[17:02:32.653]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:32.653]                     cond$call), session = sessionInformation(), 
[17:02:32.653]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:32.653]                   signalCondition(cond)
[17:02:32.653]                 }
[17:02:32.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:32.653]                 "immediateCondition"))) {
[17:02:32.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:32.653]                   ...future.conditions[[length(...future.conditions) + 
[17:02:32.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:32.653]                   if (TRUE && !signal) {
[17:02:32.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.653]                     {
[17:02:32.653]                       inherits <- base::inherits
[17:02:32.653]                       invokeRestart <- base::invokeRestart
[17:02:32.653]                       is.null <- base::is.null
[17:02:32.653]                       muffled <- FALSE
[17:02:32.653]                       if (inherits(cond, "message")) {
[17:02:32.653]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.653]                         if (muffled) 
[17:02:32.653]                           invokeRestart("muffleMessage")
[17:02:32.653]                       }
[17:02:32.653]                       else if (inherits(cond, "warning")) {
[17:02:32.653]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.653]                         if (muffled) 
[17:02:32.653]                           invokeRestart("muffleWarning")
[17:02:32.653]                       }
[17:02:32.653]                       else if (inherits(cond, "condition")) {
[17:02:32.653]                         if (!is.null(pattern)) {
[17:02:32.653]                           computeRestarts <- base::computeRestarts
[17:02:32.653]                           grepl <- base::grepl
[17:02:32.653]                           restarts <- computeRestarts(cond)
[17:02:32.653]                           for (restart in restarts) {
[17:02:32.653]                             name <- restart$name
[17:02:32.653]                             if (is.null(name)) 
[17:02:32.653]                               next
[17:02:32.653]                             if (!grepl(pattern, name)) 
[17:02:32.653]                               next
[17:02:32.653]                             invokeRestart(restart)
[17:02:32.653]                             muffled <- TRUE
[17:02:32.653]                             break
[17:02:32.653]                           }
[17:02:32.653]                         }
[17:02:32.653]                       }
[17:02:32.653]                       invisible(muffled)
[17:02:32.653]                     }
[17:02:32.653]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.653]                   }
[17:02:32.653]                 }
[17:02:32.653]                 else {
[17:02:32.653]                   if (TRUE) {
[17:02:32.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:32.653]                     {
[17:02:32.653]                       inherits <- base::inherits
[17:02:32.653]                       invokeRestart <- base::invokeRestart
[17:02:32.653]                       is.null <- base::is.null
[17:02:32.653]                       muffled <- FALSE
[17:02:32.653]                       if (inherits(cond, "message")) {
[17:02:32.653]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:32.653]                         if (muffled) 
[17:02:32.653]                           invokeRestart("muffleMessage")
[17:02:32.653]                       }
[17:02:32.653]                       else if (inherits(cond, "warning")) {
[17:02:32.653]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:32.653]                         if (muffled) 
[17:02:32.653]                           invokeRestart("muffleWarning")
[17:02:32.653]                       }
[17:02:32.653]                       else if (inherits(cond, "condition")) {
[17:02:32.653]                         if (!is.null(pattern)) {
[17:02:32.653]                           computeRestarts <- base::computeRestarts
[17:02:32.653]                           grepl <- base::grepl
[17:02:32.653]                           restarts <- computeRestarts(cond)
[17:02:32.653]                           for (restart in restarts) {
[17:02:32.653]                             name <- restart$name
[17:02:32.653]                             if (is.null(name)) 
[17:02:32.653]                               next
[17:02:32.653]                             if (!grepl(pattern, name)) 
[17:02:32.653]                               next
[17:02:32.653]                             invokeRestart(restart)
[17:02:32.653]                             muffled <- TRUE
[17:02:32.653]                             break
[17:02:32.653]                           }
[17:02:32.653]                         }
[17:02:32.653]                       }
[17:02:32.653]                       invisible(muffled)
[17:02:32.653]                     }
[17:02:32.653]                     muffleCondition(cond, pattern = "^muffle")
[17:02:32.653]                   }
[17:02:32.653]                 }
[17:02:32.653]             }
[17:02:32.653]         }))
[17:02:32.653]     }, error = function(ex) {
[17:02:32.653]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:32.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:32.653]                 ...future.rng), started = ...future.startTime, 
[17:02:32.653]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:32.653]             version = "1.8"), class = "FutureResult")
[17:02:32.653]     }, finally = {
[17:02:32.653]         if (!identical(...future.workdir, getwd())) 
[17:02:32.653]             setwd(...future.workdir)
[17:02:32.653]         {
[17:02:32.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:32.653]                 ...future.oldOptions$nwarnings <- NULL
[17:02:32.653]             }
[17:02:32.653]             base::options(...future.oldOptions)
[17:02:32.653]             if (.Platform$OS.type == "windows") {
[17:02:32.653]                 old_names <- names(...future.oldEnvVars)
[17:02:32.653]                 envs <- base::Sys.getenv()
[17:02:32.653]                 names <- names(envs)
[17:02:32.653]                 common <- intersect(names, old_names)
[17:02:32.653]                 added <- setdiff(names, old_names)
[17:02:32.653]                 removed <- setdiff(old_names, names)
[17:02:32.653]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:32.653]                   envs[common]]
[17:02:32.653]                 NAMES <- toupper(changed)
[17:02:32.653]                 args <- list()
[17:02:32.653]                 for (kk in seq_along(NAMES)) {
[17:02:32.653]                   name <- changed[[kk]]
[17:02:32.653]                   NAME <- NAMES[[kk]]
[17:02:32.653]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.653]                     next
[17:02:32.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.653]                 }
[17:02:32.653]                 NAMES <- toupper(added)
[17:02:32.653]                 for (kk in seq_along(NAMES)) {
[17:02:32.653]                   name <- added[[kk]]
[17:02:32.653]                   NAME <- NAMES[[kk]]
[17:02:32.653]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.653]                     next
[17:02:32.653]                   args[[name]] <- ""
[17:02:32.653]                 }
[17:02:32.653]                 NAMES <- toupper(removed)
[17:02:32.653]                 for (kk in seq_along(NAMES)) {
[17:02:32.653]                   name <- removed[[kk]]
[17:02:32.653]                   NAME <- NAMES[[kk]]
[17:02:32.653]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:32.653]                     next
[17:02:32.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:32.653]                 }
[17:02:32.653]                 if (length(args) > 0) 
[17:02:32.653]                   base::do.call(base::Sys.setenv, args = args)
[17:02:32.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:32.653]             }
[17:02:32.653]             else {
[17:02:32.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:32.653]             }
[17:02:32.653]             {
[17:02:32.653]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:32.653]                   0L) {
[17:02:32.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:32.653]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:32.653]                   base::options(opts)
[17:02:32.653]                 }
[17:02:32.653]                 {
[17:02:32.653]                   {
[17:02:32.653]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:32.653]                     NULL
[17:02:32.653]                   }
[17:02:32.653]                   options(future.plan = NULL)
[17:02:32.653]                   if (is.na(NA_character_)) 
[17:02:32.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:32.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:32.653]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:32.653]                     .init = FALSE)
[17:02:32.653]                 }
[17:02:32.653]             }
[17:02:32.653]         }
[17:02:32.653]     })
[17:02:32.653]     if (TRUE) {
[17:02:32.653]         base::sink(type = "output", split = FALSE)
[17:02:32.653]         if (TRUE) {
[17:02:32.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:32.653]         }
[17:02:32.653]         else {
[17:02:32.653]             ...future.result["stdout"] <- base::list(NULL)
[17:02:32.653]         }
[17:02:32.653]         base::close(...future.stdout)
[17:02:32.653]         ...future.stdout <- NULL
[17:02:32.653]     }
[17:02:32.653]     ...future.result$conditions <- ...future.conditions
[17:02:32.653]     ...future.result$finished <- base::Sys.time()
[17:02:32.653]     ...future.result
[17:02:32.653] }
[17:02:32.657] requestCore(): workers = 2
[17:02:32.657] Poll #1 (0): usedCores() = 2, workers = 2
[17:02:32.668] result() for MulticoreFuture ...
[17:02:32.669] result() for MulticoreFuture ...
[17:02:32.669] result() for MulticoreFuture ... done
[17:02:32.669] result() for MulticoreFuture ... done
[17:02:32.669] result() for MulticoreFuture ...
[17:02:32.670] result() for MulticoreFuture ... done
[17:02:32.672] MulticoreFuture started
[17:02:32.673] - Launch lazy future ... done
[17:02:32.673] run() for ‘MulticoreFuture’ ... done
[17:02:32.674] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55c747220ff8> 
[17:02:32.674] List of future strategies:
[17:02:32.674] 1. sequential:
[17:02:32.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:32.674]    - tweaked: FALSE
[17:02:32.674]    - call: NULL
[17:02:32.676] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55c74af72778> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=[17:02:32.679] plan(): Setting new future strategy stack:
List of 4
  ..$ :[17:02:32.679] List of future strategies:
[17:02:32.679] 1. multicore:
[17:02:32.679]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:32.679]    - tweaked: FALSE
[17:02:32.679]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:02:32.685] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:32.689] resolve() on list environment ...
[17:02:32.690]  recursive: 0
[17:02:32.691]  length: 6
[17:02:32.691]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:32.691] signalConditionsASAP(numeric, pos=1) ...
[17:02:32.691] - nx: 6
[17:02:32.692] - relay: TRUE
[17:02:32.692] - stdout: TRUE
[17:02:32.692] - signal: TRUE
[17:02:32.692] - resignal: FALSE
[17:02:32.692] - force: TRUE
[17:02:32.692] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.692] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.692]  - until=2
[17:02:32.693]  - relaying element #2
[17:02:32.693] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.693] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.693] signalConditionsASAP(NULL, pos=1) ... done
[17:02:32.693]  length: 5 (resolved future 1)
[17:02:32.693] Future #2
[17:02:32.693] result() for MulticoreFuture ...
[17:02:32.694] result() for MulticoreFuture ... done
[17:02:32.694] result() for MulticoreFuture ...
[17:02:32.694] result() for MulticoreFuture ... done
[17:02:32.694] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:02:32.694] - nx: 6
[17:02:32.694] - relay: TRUE
[17:02:32.694] - stdout: TRUE
[17:02:32.695] - signal: TRUE
[17:02:32.695] - resignal: FALSE
[17:02:32.695] - force: TRUE
[17:02:32.695] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.695] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:32.695]  - until=2
[17:02:32.695]  - relaying element #2
[17:02:32.695] result() for MulticoreFuture ...
[17:02:32.696] result() for MulticoreFuture ... done
[17:02:32.696] result() for MulticoreFuture ...
[17:02:32.696] result() for MulticoreFuture ... done
[17:02:32.696] result() for MulticoreFuture ...
[17:02:32.696] result() for MulticoreFuture ... done
[17:02:32.696] result() for MulticoreFuture ...
[17:02:32.696] result() for MulticoreFuture ... done
[17:02:32.696] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.697] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.697] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:02:32.697]  length: 4 (resolved future 2)
[17:02:32.697] Future #3
[17:02:32.697] result() for MulticoreFuture ...
[17:02:32.698] result() for MulticoreFuture ...
[17:02:32.698] result() for MulticoreFuture ... done
[17:02:32.699] result() for MulticoreFuture ... done
[17:02:32.699] result() for MulticoreFuture ...
[17:02:32.699] result() for MulticoreFuture ... done
[17:02:32.699] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:02:32.699] - nx: 6
[17:02:32.699] - relay: TRUE
[17:02:32.699] - stdout: TRUE
[17:02:32.699] - signal: TRUE
[17:02:32.700] - resignal: FALSE
[17:02:32.700] - force: TRUE
[17:02:32.700] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.700] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:32.700]  - until=3
[17:02:32.700]  - relaying element #3
[17:02:32.700] result() for MulticoreFuture ...
[17:02:32.701] result() for MulticoreFuture ... done
[17:02:32.701] result() for MulticoreFuture ...
[17:02:32.701] result() for MulticoreFuture ... done
[17:02:32.701] result() for MulticoreFuture ...
[17:02:32.701] result() for MulticoreFuture ... done
[17:02:32.701] result() for MulticoreFuture ...
[17:02:32.701] result() for MulticoreFuture ... done
[17:02:32.701] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.702] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.702] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:02:32.702]  length: 3 (resolved future 3)
[17:02:32.702] Future #4
[17:02:32.702] result() for MulticoreFuture ...
[17:02:32.703] result() for MulticoreFuture ...
[17:02:32.703] result() for MulticoreFuture ... done
[17:02:32.704] result() for MulticoreFuture ... done
[17:02:32.704] result() for MulticoreFuture ...
[17:02:32.704] result() for MulticoreFuture ... done
[17:02:32.704] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:02:32.704] - nx: 6
[17:02:32.704] - relay: TRUE
[17:02:32.705] - stdout: TRUE
[17:02:32.705] - signal: TRUE
[17:02:32.705] - resignal: FALSE
[17:02:32.705] - force: TRUE
[17:02:32.705] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.705] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:32.706]  - until=4
[17:02:32.706]  - relaying element #4
[17:02:32.706] result() for MulticoreFuture ...
[17:02:32.706] result() for MulticoreFuture ... done
[17:02:32.710] result() for MulticoreFuture ...
[17:02:32.711] result() for MulticoreFuture ... done
[17:02:32.711] result() for MulticoreFuture ...
[17:02:32.711] result() for MulticoreFuture ... done
[17:02:32.712] result() for MulticoreFuture ...
[17:02:32.712] result() for MulticoreFuture ... done
[17:02:32.712] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.712] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.712] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:02:32.713]  length: 2 (resolved future 4)
[17:02:32.713] signalConditionsASAP(NULL, pos=5) ...
[17:02:32.713] - nx: 6
[17:02:32.713] - relay: TRUE
[17:02:32.713] - stdout: TRUE
[17:02:32.713] - signal: TRUE
[17:02:32.713] - resignal: FALSE
[17:02:32.713] - force: TRUE
[17:02:32.713] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.714] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.714]  - until=6
[17:02:32.714]  - relaying element #6
[17:02:32.714] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:32.714] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.714] signalConditionsASAP(NULL, pos=5) ... done
[17:02:32.714]  length: 1 (resolved future 5)
[17:02:32.714] signalConditionsASAP(numeric, pos=6) ...
[17:02:32.715] - nx: 6
[17:02:32.715] - relay: TRUE
[17:02:32.715] - stdout: TRUE
[17:02:32.715] - signal: TRUE
[17:02:32.715] - resignal: FALSE
[17:02:32.715] - force: TRUE
[17:02:32.715] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:32.715] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.715]  - until=6
[17:02:32.715] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.716] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.716] signalConditionsASAP(numeric, pos=6) ... done
[17:02:32.716]  length: 0 (resolved future 6)
[17:02:32.716] Relaying remaining futures
[17:02:32.716] signalConditionsASAP(NULL, pos=0) ...
[17:02:32.716] - nx: 6
[17:02:32.716] - relay: TRUE
[17:02:32.716] - stdout: TRUE
[17:02:32.716] - signal: TRUE
[17:02:32.716] - resignal: FALSE
[17:02:32.717] - force: TRUE
[17:02:32.717] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.717] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:32.717] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:32.717] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:32.717] signalConditionsASAP(NULL, pos=0) ... done
[17:02:32.717] resolve() on list environment ... DONE
[17:02:32.717] result() for MulticoreFuture ...
[17:02:32.717] result() for MulticoreFuture ... done
[17:02:32.718] result() for MulticoreFuture ...
[17:02:32.718] result() for MulticoreFuture ... done
[17:02:32.718] result() for MulticoreFuture ...
[17:02:32.718] result() for MulticoreFuture ... done
[17:02:32.718] result() for MulticoreFuture ...
[17:02:32.718] result() for MulticoreFuture ... done
[17:02:32.718] result() for MulticoreFuture ...
[17:02:32.718] result() for MulticoreFuture ... done
[17:02:32.719] result() for MulticoreFuture ...
[17:02:32.719] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c74b2f80f0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[17:02:32.721] plan(): Setting new future strategy stack:
[17:02:32.722] List of future strategies:
[17:02:32.722] 1. multisession:
[17:02:32.722]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:02:32.722]    - tweaked: FALSE
[17:02:32.722]    - call: plan(strategy)
[17:02:32.722] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:02:32.722] multisession:
[17:02:32.722] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:02:32.722] - tweaked: FALSE
[17:02:32.722] - call: plan(strategy)
[17:02:32.727] getGlobalsAndPackages() ...
[17:02:32.727] Not searching for globals
[17:02:32.727] - globals: [0] <none>
[17:02:32.727] getGlobalsAndPackages() ... DONE
[17:02:32.728] [local output] makeClusterPSOCK() ...
[17:02:32.732] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:02:32.733] [local output] Base port: 11551
[17:02:32.733] [local output] Getting setup options for 2 cluster nodes ...
[17:02:32.733] [local output]  - Node 1 of 2 ...
[17:02:32.733] [local output] localMachine=TRUE => revtunnel=FALSE

[17:02:32.734] [local output] Rscript port: 11551

[17:02:32.735] [local output]  - Node 2 of 2 ...
[17:02:32.735] [local output] localMachine=TRUE => revtunnel=FALSE

[17:02:32.736] [local output] Rscript port: 11551

[17:02:32.736] [local output] Getting setup options for 2 cluster nodes ... done
[17:02:32.736] [local output]  - Parallel setup requested for some PSOCK nodes
[17:02:32.736] [local output] Setting up PSOCK nodes in parallel
[17:02:32.736] List of 36
[17:02:32.736]  $ worker          : chr "localhost"
[17:02:32.736]   ..- attr(*, "localhost")= logi TRUE
[17:02:32.736]  $ master          : chr "localhost"
[17:02:32.736]  $ port            : int 11551
[17:02:32.736]  $ connectTimeout  : num 120
[17:02:32.736]  $ timeout         : num 2592000
[17:02:32.736]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:02:32.736]  $ homogeneous     : logi TRUE
[17:02:32.736]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:02:32.736]  $ rscript_envs    : NULL
[17:02:32.736]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:02:32.736]  $ rscript_startup : NULL
[17:02:32.736]  $ rscript_sh      : chr "sh"
[17:02:32.736]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:02:32.736]  $ methods         : logi TRUE
[17:02:32.736]  $ socketOptions   : chr "no-delay"
[17:02:32.736]  $ useXDR          : logi FALSE
[17:02:32.736]  $ outfile         : chr "/dev/null"
[17:02:32.736]  $ renice          : int NA
[17:02:32.736]  $ rshcmd          : NULL
[17:02:32.736]  $ user            : chr(0) 
[17:02:32.736]  $ revtunnel       : logi FALSE
[17:02:32.736]  $ rshlogfile      : NULL
[17:02:32.736]  $ rshopts         : chr(0) 
[17:02:32.736]  $ rank            : int 1
[17:02:32.736]  $ manual          : logi FALSE
[17:02:32.736]  $ dryrun          : logi FALSE
[17:02:32.736]  $ quiet           : logi FALSE
[17:02:32.736]  $ setup_strategy  : chr "parallel"
[17:02:32.736]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:02:32.736]  $ pidfile         : chr "/tmp/Rtmp9yGsuH/worker.rank=1.parallelly.parent=42097.a47145b00e60.pid"
[17:02:32.736]  $ rshcmd_label    : NULL
[17:02:32.736]  $ rsh_call        : NULL
[17:02:32.736]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:02:32.736]  $ localMachine    : logi TRUE
[17:02:32.736]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:02:32.736]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:02:32.736]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:02:32.736]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:02:32.736]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:02:32.736]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:02:32.736]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:02:32.736]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:02:32.736]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:02:32.736]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:02:32.736]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:02:32.736]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:02:32.736]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:02:32.736]  $ arguments       :List of 28
[17:02:32.736]   ..$ worker          : chr "localhost"
[17:02:32.736]   ..$ master          : NULL
[17:02:32.736]   ..$ port            : int 11551
[17:02:32.736]   ..$ connectTimeout  : num 120
[17:02:32.736]   ..$ timeout         : num 2592000
[17:02:32.736]   ..$ rscript         : NULL
[17:02:32.736]   ..$ homogeneous     : NULL
[17:02:32.736]   ..$ rscript_args    : NULL
[17:02:32.736]   ..$ rscript_envs    : NULL
[17:02:32.736]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:02:32.736]   ..$ rscript_startup : NULL
[17:02:32.736]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:02:32.736]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:02:32.736]   ..$ methods         : logi TRUE
[17:02:32.736]   ..$ socketOptions   : chr "no-delay"
[17:02:32.736]   ..$ useXDR          : logi FALSE
[17:02:32.736]   ..$ outfile         : chr "/dev/null"
[17:02:32.736]   ..$ renice          : int NA
[17:02:32.736]   ..$ rshcmd          : NULL
[17:02:32.736]   ..$ user            : NULL
[17:02:32.736]   ..$ revtunnel       : logi NA
[17:02:32.736]   ..$ rshlogfile      : NULL
[17:02:32.736]   ..$ rshopts         : NULL
[17:02:32.736]   ..$ rank            : int 1
[17:02:32.736]   ..$ manual          : logi FALSE
[17:02:32.736]   ..$ dryrun          : logi FALSE
[17:02:32.736]   ..$ quiet           : logi FALSE
[17:02:32.736]   ..$ setup_strategy  : chr "parallel"
[17:02:32.736]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:02:32.756] [local output] System call to launch all workers:
[17:02:32.756] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp9yGsuH/worker.rank=1.parallelly.parent=42097.a47145b00e60.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11551 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:02:32.756] [local output] Starting PSOCK main server
[17:02:32.757] [local output] Workers launched
[17:02:32.758] [local output] Waiting for workers to connect back
[17:02:32.758]  - [local output] 0 workers out of 2 ready
[17:02:32.986]  - [local output] 0 workers out of 2 ready
[17:02:32.986]  - [local output] 1 workers out of 2 ready
[17:02:33.010]  - [local output] 1 workers out of 2 ready
[17:02:33.010]  - [local output] 2 workers out of 2 ready
[17:02:33.011] [local output] Launching of workers completed
[17:02:33.011] [local output] Collecting session information from workers
[17:02:33.011] [local output]  - Worker #1 of 2
[17:02:33.012] [local output]  - Worker #2 of 2
[17:02:33.012] [local output] makeClusterPSOCK() ... done
[17:02:33.023] Packages needed by the future expression (n = 0): <none>
[17:02:33.023] Packages needed by future strategies (n = 0): <none>
[17:02:33.024] {
[17:02:33.024]     {
[17:02:33.024]         {
[17:02:33.024]             ...future.startTime <- base::Sys.time()
[17:02:33.024]             {
[17:02:33.024]                 {
[17:02:33.024]                   {
[17:02:33.024]                     {
[17:02:33.024]                       base::local({
[17:02:33.024]                         has_future <- base::requireNamespace("future", 
[17:02:33.024]                           quietly = TRUE)
[17:02:33.024]                         if (has_future) {
[17:02:33.024]                           ns <- base::getNamespace("future")
[17:02:33.024]                           version <- ns[[".package"]][["version"]]
[17:02:33.024]                           if (is.null(version)) 
[17:02:33.024]                             version <- utils::packageVersion("future")
[17:02:33.024]                         }
[17:02:33.024]                         else {
[17:02:33.024]                           version <- NULL
[17:02:33.024]                         }
[17:02:33.024]                         if (!has_future || version < "1.8.0") {
[17:02:33.024]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.024]                             "", base::R.version$version.string), 
[17:02:33.024]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.024]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.024]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.024]                               "release", "version")], collapse = " "), 
[17:02:33.024]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.024]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.024]                             info)
[17:02:33.024]                           info <- base::paste(info, collapse = "; ")
[17:02:33.024]                           if (!has_future) {
[17:02:33.024]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.024]                               info)
[17:02:33.024]                           }
[17:02:33.024]                           else {
[17:02:33.024]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.024]                               info, version)
[17:02:33.024]                           }
[17:02:33.024]                           base::stop(msg)
[17:02:33.024]                         }
[17:02:33.024]                       })
[17:02:33.024]                     }
[17:02:33.024]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.024]                     base::options(mc.cores = 1L)
[17:02:33.024]                   }
[17:02:33.024]                   ...future.strategy.old <- future::plan("list")
[17:02:33.024]                   options(future.plan = NULL)
[17:02:33.024]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.024]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.024]                 }
[17:02:33.024]                 ...future.workdir <- getwd()
[17:02:33.024]             }
[17:02:33.024]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.024]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.024]         }
[17:02:33.024]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.024]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.024]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.024]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.024]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.024]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.024]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.024]             base::names(...future.oldOptions))
[17:02:33.024]     }
[17:02:33.024]     if (FALSE) {
[17:02:33.024]     }
[17:02:33.024]     else {
[17:02:33.024]         if (TRUE) {
[17:02:33.024]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.024]                 open = "w")
[17:02:33.024]         }
[17:02:33.024]         else {
[17:02:33.024]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.024]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.024]         }
[17:02:33.024]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.024]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.024]             base::sink(type = "output", split = FALSE)
[17:02:33.024]             base::close(...future.stdout)
[17:02:33.024]         }, add = TRUE)
[17:02:33.024]     }
[17:02:33.024]     ...future.frame <- base::sys.nframe()
[17:02:33.024]     ...future.conditions <- base::list()
[17:02:33.024]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.024]     if (FALSE) {
[17:02:33.024]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.024]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.024]     }
[17:02:33.024]     ...future.result <- base::tryCatch({
[17:02:33.024]         base::withCallingHandlers({
[17:02:33.024]             ...future.value <- base::withVisible(base::local({
[17:02:33.024]                 ...future.makeSendCondition <- base::local({
[17:02:33.024]                   sendCondition <- NULL
[17:02:33.024]                   function(frame = 1L) {
[17:02:33.024]                     if (is.function(sendCondition)) 
[17:02:33.024]                       return(sendCondition)
[17:02:33.024]                     ns <- getNamespace("parallel")
[17:02:33.024]                     if (exists("sendData", mode = "function", 
[17:02:33.024]                       envir = ns)) {
[17:02:33.024]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.024]                         envir = ns)
[17:02:33.024]                       envir <- sys.frame(frame)
[17:02:33.024]                       master <- NULL
[17:02:33.024]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.024]                         !identical(envir, emptyenv())) {
[17:02:33.024]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.024]                           inherits = FALSE)) {
[17:02:33.024]                           master <- get("master", mode = "list", 
[17:02:33.024]                             envir = envir, inherits = FALSE)
[17:02:33.024]                           if (inherits(master, c("SOCKnode", 
[17:02:33.024]                             "SOCK0node"))) {
[17:02:33.024]                             sendCondition <<- function(cond) {
[17:02:33.024]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.024]                                 success = TRUE)
[17:02:33.024]                               parallel_sendData(master, data)
[17:02:33.024]                             }
[17:02:33.024]                             return(sendCondition)
[17:02:33.024]                           }
[17:02:33.024]                         }
[17:02:33.024]                         frame <- frame + 1L
[17:02:33.024]                         envir <- sys.frame(frame)
[17:02:33.024]                       }
[17:02:33.024]                     }
[17:02:33.024]                     sendCondition <<- function(cond) NULL
[17:02:33.024]                   }
[17:02:33.024]                 })
[17:02:33.024]                 withCallingHandlers({
[17:02:33.024]                   NA
[17:02:33.024]                 }, immediateCondition = function(cond) {
[17:02:33.024]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.024]                   sendCondition(cond)
[17:02:33.024]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.024]                   {
[17:02:33.024]                     inherits <- base::inherits
[17:02:33.024]                     invokeRestart <- base::invokeRestart
[17:02:33.024]                     is.null <- base::is.null
[17:02:33.024]                     muffled <- FALSE
[17:02:33.024]                     if (inherits(cond, "message")) {
[17:02:33.024]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.024]                       if (muffled) 
[17:02:33.024]                         invokeRestart("muffleMessage")
[17:02:33.024]                     }
[17:02:33.024]                     else if (inherits(cond, "warning")) {
[17:02:33.024]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.024]                       if (muffled) 
[17:02:33.024]                         invokeRestart("muffleWarning")
[17:02:33.024]                     }
[17:02:33.024]                     else if (inherits(cond, "condition")) {
[17:02:33.024]                       if (!is.null(pattern)) {
[17:02:33.024]                         computeRestarts <- base::computeRestarts
[17:02:33.024]                         grepl <- base::grepl
[17:02:33.024]                         restarts <- computeRestarts(cond)
[17:02:33.024]                         for (restart in restarts) {
[17:02:33.024]                           name <- restart$name
[17:02:33.024]                           if (is.null(name)) 
[17:02:33.024]                             next
[17:02:33.024]                           if (!grepl(pattern, name)) 
[17:02:33.024]                             next
[17:02:33.024]                           invokeRestart(restart)
[17:02:33.024]                           muffled <- TRUE
[17:02:33.024]                           break
[17:02:33.024]                         }
[17:02:33.024]                       }
[17:02:33.024]                     }
[17:02:33.024]                     invisible(muffled)
[17:02:33.024]                   }
[17:02:33.024]                   muffleCondition(cond)
[17:02:33.024]                 })
[17:02:33.024]             }))
[17:02:33.024]             future::FutureResult(value = ...future.value$value, 
[17:02:33.024]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.024]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.024]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.024]                     ...future.globalenv.names))
[17:02:33.024]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.024]         }, condition = base::local({
[17:02:33.024]             c <- base::c
[17:02:33.024]             inherits <- base::inherits
[17:02:33.024]             invokeRestart <- base::invokeRestart
[17:02:33.024]             length <- base::length
[17:02:33.024]             list <- base::list
[17:02:33.024]             seq.int <- base::seq.int
[17:02:33.024]             signalCondition <- base::signalCondition
[17:02:33.024]             sys.calls <- base::sys.calls
[17:02:33.024]             `[[` <- base::`[[`
[17:02:33.024]             `+` <- base::`+`
[17:02:33.024]             `<<-` <- base::`<<-`
[17:02:33.024]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.024]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.024]                   3L)]
[17:02:33.024]             }
[17:02:33.024]             function(cond) {
[17:02:33.024]                 is_error <- inherits(cond, "error")
[17:02:33.024]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.024]                   NULL)
[17:02:33.024]                 if (is_error) {
[17:02:33.024]                   sessionInformation <- function() {
[17:02:33.024]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.024]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.024]                       search = base::search(), system = base::Sys.info())
[17:02:33.024]                   }
[17:02:33.024]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.024]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.024]                     cond$call), session = sessionInformation(), 
[17:02:33.024]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.024]                   signalCondition(cond)
[17:02:33.024]                 }
[17:02:33.024]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.024]                 "immediateCondition"))) {
[17:02:33.024]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.024]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.024]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.024]                   if (TRUE && !signal) {
[17:02:33.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.024]                     {
[17:02:33.024]                       inherits <- base::inherits
[17:02:33.024]                       invokeRestart <- base::invokeRestart
[17:02:33.024]                       is.null <- base::is.null
[17:02:33.024]                       muffled <- FALSE
[17:02:33.024]                       if (inherits(cond, "message")) {
[17:02:33.024]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.024]                         if (muffled) 
[17:02:33.024]                           invokeRestart("muffleMessage")
[17:02:33.024]                       }
[17:02:33.024]                       else if (inherits(cond, "warning")) {
[17:02:33.024]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.024]                         if (muffled) 
[17:02:33.024]                           invokeRestart("muffleWarning")
[17:02:33.024]                       }
[17:02:33.024]                       else if (inherits(cond, "condition")) {
[17:02:33.024]                         if (!is.null(pattern)) {
[17:02:33.024]                           computeRestarts <- base::computeRestarts
[17:02:33.024]                           grepl <- base::grepl
[17:02:33.024]                           restarts <- computeRestarts(cond)
[17:02:33.024]                           for (restart in restarts) {
[17:02:33.024]                             name <- restart$name
[17:02:33.024]                             if (is.null(name)) 
[17:02:33.024]                               next
[17:02:33.024]                             if (!grepl(pattern, name)) 
[17:02:33.024]                               next
[17:02:33.024]                             invokeRestart(restart)
[17:02:33.024]                             muffled <- TRUE
[17:02:33.024]                             break
[17:02:33.024]                           }
[17:02:33.024]                         }
[17:02:33.024]                       }
[17:02:33.024]                       invisible(muffled)
[17:02:33.024]                     }
[17:02:33.024]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.024]                   }
[17:02:33.024]                 }
[17:02:33.024]                 else {
[17:02:33.024]                   if (TRUE) {
[17:02:33.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.024]                     {
[17:02:33.024]                       inherits <- base::inherits
[17:02:33.024]                       invokeRestart <- base::invokeRestart
[17:02:33.024]                       is.null <- base::is.null
[17:02:33.024]                       muffled <- FALSE
[17:02:33.024]                       if (inherits(cond, "message")) {
[17:02:33.024]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.024]                         if (muffled) 
[17:02:33.024]                           invokeRestart("muffleMessage")
[17:02:33.024]                       }
[17:02:33.024]                       else if (inherits(cond, "warning")) {
[17:02:33.024]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.024]                         if (muffled) 
[17:02:33.024]                           invokeRestart("muffleWarning")
[17:02:33.024]                       }
[17:02:33.024]                       else if (inherits(cond, "condition")) {
[17:02:33.024]                         if (!is.null(pattern)) {
[17:02:33.024]                           computeRestarts <- base::computeRestarts
[17:02:33.024]                           grepl <- base::grepl
[17:02:33.024]                           restarts <- computeRestarts(cond)
[17:02:33.024]                           for (restart in restarts) {
[17:02:33.024]                             name <- restart$name
[17:02:33.024]                             if (is.null(name)) 
[17:02:33.024]                               next
[17:02:33.024]                             if (!grepl(pattern, name)) 
[17:02:33.024]                               next
[17:02:33.024]                             invokeRestart(restart)
[17:02:33.024]                             muffled <- TRUE
[17:02:33.024]                             break
[17:02:33.024]                           }
[17:02:33.024]                         }
[17:02:33.024]                       }
[17:02:33.024]                       invisible(muffled)
[17:02:33.024]                     }
[17:02:33.024]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.024]                   }
[17:02:33.024]                 }
[17:02:33.024]             }
[17:02:33.024]         }))
[17:02:33.024]     }, error = function(ex) {
[17:02:33.024]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.024]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.024]                 ...future.rng), started = ...future.startTime, 
[17:02:33.024]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.024]             version = "1.8"), class = "FutureResult")
[17:02:33.024]     }, finally = {
[17:02:33.024]         if (!identical(...future.workdir, getwd())) 
[17:02:33.024]             setwd(...future.workdir)
[17:02:33.024]         {
[17:02:33.024]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.024]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.024]             }
[17:02:33.024]             base::options(...future.oldOptions)
[17:02:33.024]             if (.Platform$OS.type == "windows") {
[17:02:33.024]                 old_names <- names(...future.oldEnvVars)
[17:02:33.024]                 envs <- base::Sys.getenv()
[17:02:33.024]                 names <- names(envs)
[17:02:33.024]                 common <- intersect(names, old_names)
[17:02:33.024]                 added <- setdiff(names, old_names)
[17:02:33.024]                 removed <- setdiff(old_names, names)
[17:02:33.024]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.024]                   envs[common]]
[17:02:33.024]                 NAMES <- toupper(changed)
[17:02:33.024]                 args <- list()
[17:02:33.024]                 for (kk in seq_along(NAMES)) {
[17:02:33.024]                   name <- changed[[kk]]
[17:02:33.024]                   NAME <- NAMES[[kk]]
[17:02:33.024]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.024]                     next
[17:02:33.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.024]                 }
[17:02:33.024]                 NAMES <- toupper(added)
[17:02:33.024]                 for (kk in seq_along(NAMES)) {
[17:02:33.024]                   name <- added[[kk]]
[17:02:33.024]                   NAME <- NAMES[[kk]]
[17:02:33.024]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.024]                     next
[17:02:33.024]                   args[[name]] <- ""
[17:02:33.024]                 }
[17:02:33.024]                 NAMES <- toupper(removed)
[17:02:33.024]                 for (kk in seq_along(NAMES)) {
[17:02:33.024]                   name <- removed[[kk]]
[17:02:33.024]                   NAME <- NAMES[[kk]]
[17:02:33.024]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.024]                     next
[17:02:33.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.024]                 }
[17:02:33.024]                 if (length(args) > 0) 
[17:02:33.024]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.024]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.024]             }
[17:02:33.024]             else {
[17:02:33.024]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.024]             }
[17:02:33.024]             {
[17:02:33.024]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.024]                   0L) {
[17:02:33.024]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.024]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.024]                   base::options(opts)
[17:02:33.024]                 }
[17:02:33.024]                 {
[17:02:33.024]                   {
[17:02:33.024]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.024]                     NULL
[17:02:33.024]                   }
[17:02:33.024]                   options(future.plan = NULL)
[17:02:33.024]                   if (is.na(NA_character_)) 
[17:02:33.024]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.024]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.024]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.024]                     .init = FALSE)
[17:02:33.024]                 }
[17:02:33.024]             }
[17:02:33.024]         }
[17:02:33.024]     })
[17:02:33.024]     if (TRUE) {
[17:02:33.024]         base::sink(type = "output", split = FALSE)
[17:02:33.024]         if (TRUE) {
[17:02:33.024]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.024]         }
[17:02:33.024]         else {
[17:02:33.024]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.024]         }
[17:02:33.024]         base::close(...future.stdout)
[17:02:33.024]         ...future.stdout <- NULL
[17:02:33.024]     }
[17:02:33.024]     ...future.result$conditions <- ...future.conditions
[17:02:33.024]     ...future.result$finished <- base::Sys.time()
[17:02:33.024]     ...future.result
[17:02:33.024] }
[17:02:33.077] MultisessionFuture started
[17:02:33.077] result() for ClusterFuture ...
[17:02:33.078] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.078] - Validating connection of MultisessionFuture
[17:02:33.110] - received message: FutureResult
[17:02:33.111] - Received FutureResult
[17:02:33.111] - Erased future from FutureRegistry
[17:02:33.111] result() for ClusterFuture ...
[17:02:33.111] - result already collected: FutureResult
[17:02:33.111] result() for ClusterFuture ... done
[17:02:33.111] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:33.111] result() for ClusterFuture ... done
[17:02:33.111] result() for ClusterFuture ...
[17:02:33.111] - result already collected: FutureResult
[17:02:33.112] result() for ClusterFuture ... done
[17:02:33.112] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:02:33.116] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:02:33.116] getGlobalsAndPackages() ...
[17:02:33.116] Searching for globals...
[17:02:33.116] 
[17:02:33.117] Searching for globals ... DONE
[17:02:33.117] - globals: [0] <none>
[17:02:33.117] getGlobalsAndPackages() ... DONE
[17:02:33.117] run() for ‘Future’ ...
[17:02:33.117] - state: ‘created’
[17:02:33.117] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.132] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.132]   - Field: ‘node’
[17:02:33.132]   - Field: ‘label’
[17:02:33.132]   - Field: ‘local’
[17:02:33.132]   - Field: ‘owner’
[17:02:33.132]   - Field: ‘envir’
[17:02:33.132]   - Field: ‘workers’
[17:02:33.132]   - Field: ‘packages’
[17:02:33.133]   - Field: ‘gc’
[17:02:33.133]   - Field: ‘conditions’
[17:02:33.133]   - Field: ‘persistent’
[17:02:33.133]   - Field: ‘expr’
[17:02:33.133]   - Field: ‘uuid’
[17:02:33.133]   - Field: ‘seed’
[17:02:33.133]   - Field: ‘version’
[17:02:33.133]   - Field: ‘result’
[17:02:33.133]   - Field: ‘asynchronous’
[17:02:33.133]   - Field: ‘calls’
[17:02:33.134]   - Field: ‘globals’
[17:02:33.134]   - Field: ‘stdout’
[17:02:33.134]   - Field: ‘earlySignal’
[17:02:33.134]   - Field: ‘lazy’
[17:02:33.134]   - Field: ‘state’
[17:02:33.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.134] - Launch lazy future ...
[17:02:33.134] Packages needed by the future expression (n = 0): <none>
[17:02:33.135] Packages needed by future strategies (n = 0): <none>
[17:02:33.135] {
[17:02:33.135]     {
[17:02:33.135]         {
[17:02:33.135]             ...future.startTime <- base::Sys.time()
[17:02:33.135]             {
[17:02:33.135]                 {
[17:02:33.135]                   {
[17:02:33.135]                     {
[17:02:33.135]                       base::local({
[17:02:33.135]                         has_future <- base::requireNamespace("future", 
[17:02:33.135]                           quietly = TRUE)
[17:02:33.135]                         if (has_future) {
[17:02:33.135]                           ns <- base::getNamespace("future")
[17:02:33.135]                           version <- ns[[".package"]][["version"]]
[17:02:33.135]                           if (is.null(version)) 
[17:02:33.135]                             version <- utils::packageVersion("future")
[17:02:33.135]                         }
[17:02:33.135]                         else {
[17:02:33.135]                           version <- NULL
[17:02:33.135]                         }
[17:02:33.135]                         if (!has_future || version < "1.8.0") {
[17:02:33.135]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.135]                             "", base::R.version$version.string), 
[17:02:33.135]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.135]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.135]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.135]                               "release", "version")], collapse = " "), 
[17:02:33.135]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.135]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.135]                             info)
[17:02:33.135]                           info <- base::paste(info, collapse = "; ")
[17:02:33.135]                           if (!has_future) {
[17:02:33.135]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.135]                               info)
[17:02:33.135]                           }
[17:02:33.135]                           else {
[17:02:33.135]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.135]                               info, version)
[17:02:33.135]                           }
[17:02:33.135]                           base::stop(msg)
[17:02:33.135]                         }
[17:02:33.135]                       })
[17:02:33.135]                     }
[17:02:33.135]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.135]                     base::options(mc.cores = 1L)
[17:02:33.135]                   }
[17:02:33.135]                   ...future.strategy.old <- future::plan("list")
[17:02:33.135]                   options(future.plan = NULL)
[17:02:33.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.135]                 }
[17:02:33.135]                 ...future.workdir <- getwd()
[17:02:33.135]             }
[17:02:33.135]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.135]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.135]         }
[17:02:33.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.135]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.135]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.135]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.135]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.135]             base::names(...future.oldOptions))
[17:02:33.135]     }
[17:02:33.135]     if (FALSE) {
[17:02:33.135]     }
[17:02:33.135]     else {
[17:02:33.135]         if (TRUE) {
[17:02:33.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.135]                 open = "w")
[17:02:33.135]         }
[17:02:33.135]         else {
[17:02:33.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.135]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.135]         }
[17:02:33.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.135]             base::sink(type = "output", split = FALSE)
[17:02:33.135]             base::close(...future.stdout)
[17:02:33.135]         }, add = TRUE)
[17:02:33.135]     }
[17:02:33.135]     ...future.frame <- base::sys.nframe()
[17:02:33.135]     ...future.conditions <- base::list()
[17:02:33.135]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.135]     if (FALSE) {
[17:02:33.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.135]     }
[17:02:33.135]     ...future.result <- base::tryCatch({
[17:02:33.135]         base::withCallingHandlers({
[17:02:33.135]             ...future.value <- base::withVisible(base::local({
[17:02:33.135]                 ...future.makeSendCondition <- base::local({
[17:02:33.135]                   sendCondition <- NULL
[17:02:33.135]                   function(frame = 1L) {
[17:02:33.135]                     if (is.function(sendCondition)) 
[17:02:33.135]                       return(sendCondition)
[17:02:33.135]                     ns <- getNamespace("parallel")
[17:02:33.135]                     if (exists("sendData", mode = "function", 
[17:02:33.135]                       envir = ns)) {
[17:02:33.135]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.135]                         envir = ns)
[17:02:33.135]                       envir <- sys.frame(frame)
[17:02:33.135]                       master <- NULL
[17:02:33.135]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.135]                         !identical(envir, emptyenv())) {
[17:02:33.135]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.135]                           inherits = FALSE)) {
[17:02:33.135]                           master <- get("master", mode = "list", 
[17:02:33.135]                             envir = envir, inherits = FALSE)
[17:02:33.135]                           if (inherits(master, c("SOCKnode", 
[17:02:33.135]                             "SOCK0node"))) {
[17:02:33.135]                             sendCondition <<- function(cond) {
[17:02:33.135]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.135]                                 success = TRUE)
[17:02:33.135]                               parallel_sendData(master, data)
[17:02:33.135]                             }
[17:02:33.135]                             return(sendCondition)
[17:02:33.135]                           }
[17:02:33.135]                         }
[17:02:33.135]                         frame <- frame + 1L
[17:02:33.135]                         envir <- sys.frame(frame)
[17:02:33.135]                       }
[17:02:33.135]                     }
[17:02:33.135]                     sendCondition <<- function(cond) NULL
[17:02:33.135]                   }
[17:02:33.135]                 })
[17:02:33.135]                 withCallingHandlers({
[17:02:33.135]                   2
[17:02:33.135]                 }, immediateCondition = function(cond) {
[17:02:33.135]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.135]                   sendCondition(cond)
[17:02:33.135]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.135]                   {
[17:02:33.135]                     inherits <- base::inherits
[17:02:33.135]                     invokeRestart <- base::invokeRestart
[17:02:33.135]                     is.null <- base::is.null
[17:02:33.135]                     muffled <- FALSE
[17:02:33.135]                     if (inherits(cond, "message")) {
[17:02:33.135]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.135]                       if (muffled) 
[17:02:33.135]                         invokeRestart("muffleMessage")
[17:02:33.135]                     }
[17:02:33.135]                     else if (inherits(cond, "warning")) {
[17:02:33.135]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.135]                       if (muffled) 
[17:02:33.135]                         invokeRestart("muffleWarning")
[17:02:33.135]                     }
[17:02:33.135]                     else if (inherits(cond, "condition")) {
[17:02:33.135]                       if (!is.null(pattern)) {
[17:02:33.135]                         computeRestarts <- base::computeRestarts
[17:02:33.135]                         grepl <- base::grepl
[17:02:33.135]                         restarts <- computeRestarts(cond)
[17:02:33.135]                         for (restart in restarts) {
[17:02:33.135]                           name <- restart$name
[17:02:33.135]                           if (is.null(name)) 
[17:02:33.135]                             next
[17:02:33.135]                           if (!grepl(pattern, name)) 
[17:02:33.135]                             next
[17:02:33.135]                           invokeRestart(restart)
[17:02:33.135]                           muffled <- TRUE
[17:02:33.135]                           break
[17:02:33.135]                         }
[17:02:33.135]                       }
[17:02:33.135]                     }
[17:02:33.135]                     invisible(muffled)
[17:02:33.135]                   }
[17:02:33.135]                   muffleCondition(cond)
[17:02:33.135]                 })
[17:02:33.135]             }))
[17:02:33.135]             future::FutureResult(value = ...future.value$value, 
[17:02:33.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.135]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.135]                     ...future.globalenv.names))
[17:02:33.135]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.135]         }, condition = base::local({
[17:02:33.135]             c <- base::c
[17:02:33.135]             inherits <- base::inherits
[17:02:33.135]             invokeRestart <- base::invokeRestart
[17:02:33.135]             length <- base::length
[17:02:33.135]             list <- base::list
[17:02:33.135]             seq.int <- base::seq.int
[17:02:33.135]             signalCondition <- base::signalCondition
[17:02:33.135]             sys.calls <- base::sys.calls
[17:02:33.135]             `[[` <- base::`[[`
[17:02:33.135]             `+` <- base::`+`
[17:02:33.135]             `<<-` <- base::`<<-`
[17:02:33.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.135]                   3L)]
[17:02:33.135]             }
[17:02:33.135]             function(cond) {
[17:02:33.135]                 is_error <- inherits(cond, "error")
[17:02:33.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.135]                   NULL)
[17:02:33.135]                 if (is_error) {
[17:02:33.135]                   sessionInformation <- function() {
[17:02:33.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.135]                       search = base::search(), system = base::Sys.info())
[17:02:33.135]                   }
[17:02:33.135]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.135]                     cond$call), session = sessionInformation(), 
[17:02:33.135]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.135]                   signalCondition(cond)
[17:02:33.135]                 }
[17:02:33.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.135]                 "immediateCondition"))) {
[17:02:33.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.135]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.135]                   if (TRUE && !signal) {
[17:02:33.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.135]                     {
[17:02:33.135]                       inherits <- base::inherits
[17:02:33.135]                       invokeRestart <- base::invokeRestart
[17:02:33.135]                       is.null <- base::is.null
[17:02:33.135]                       muffled <- FALSE
[17:02:33.135]                       if (inherits(cond, "message")) {
[17:02:33.135]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.135]                         if (muffled) 
[17:02:33.135]                           invokeRestart("muffleMessage")
[17:02:33.135]                       }
[17:02:33.135]                       else if (inherits(cond, "warning")) {
[17:02:33.135]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.135]                         if (muffled) 
[17:02:33.135]                           invokeRestart("muffleWarning")
[17:02:33.135]                       }
[17:02:33.135]                       else if (inherits(cond, "condition")) {
[17:02:33.135]                         if (!is.null(pattern)) {
[17:02:33.135]                           computeRestarts <- base::computeRestarts
[17:02:33.135]                           grepl <- base::grepl
[17:02:33.135]                           restarts <- computeRestarts(cond)
[17:02:33.135]                           for (restart in restarts) {
[17:02:33.135]                             name <- restart$name
[17:02:33.135]                             if (is.null(name)) 
[17:02:33.135]                               next
[17:02:33.135]                             if (!grepl(pattern, name)) 
[17:02:33.135]                               next
[17:02:33.135]                             invokeRestart(restart)
[17:02:33.135]                             muffled <- TRUE
[17:02:33.135]                             break
[17:02:33.135]                           }
[17:02:33.135]                         }
[17:02:33.135]                       }
[17:02:33.135]                       invisible(muffled)
[17:02:33.135]                     }
[17:02:33.135]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.135]                   }
[17:02:33.135]                 }
[17:02:33.135]                 else {
[17:02:33.135]                   if (TRUE) {
[17:02:33.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.135]                     {
[17:02:33.135]                       inherits <- base::inherits
[17:02:33.135]                       invokeRestart <- base::invokeRestart
[17:02:33.135]                       is.null <- base::is.null
[17:02:33.135]                       muffled <- FALSE
[17:02:33.135]                       if (inherits(cond, "message")) {
[17:02:33.135]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.135]                         if (muffled) 
[17:02:33.135]                           invokeRestart("muffleMessage")
[17:02:33.135]                       }
[17:02:33.135]                       else if (inherits(cond, "warning")) {
[17:02:33.135]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.135]                         if (muffled) 
[17:02:33.135]                           invokeRestart("muffleWarning")
[17:02:33.135]                       }
[17:02:33.135]                       else if (inherits(cond, "condition")) {
[17:02:33.135]                         if (!is.null(pattern)) {
[17:02:33.135]                           computeRestarts <- base::computeRestarts
[17:02:33.135]                           grepl <- base::grepl
[17:02:33.135]                           restarts <- computeRestarts(cond)
[17:02:33.135]                           for (restart in restarts) {
[17:02:33.135]                             name <- restart$name
[17:02:33.135]                             if (is.null(name)) 
[17:02:33.135]                               next
[17:02:33.135]                             if (!grepl(pattern, name)) 
[17:02:33.135]                               next
[17:02:33.135]                             invokeRestart(restart)
[17:02:33.135]                             muffled <- TRUE
[17:02:33.135]                             break
[17:02:33.135]                           }
[17:02:33.135]                         }
[17:02:33.135]                       }
[17:02:33.135]                       invisible(muffled)
[17:02:33.135]                     }
[17:02:33.135]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.135]                   }
[17:02:33.135]                 }
[17:02:33.135]             }
[17:02:33.135]         }))
[17:02:33.135]     }, error = function(ex) {
[17:02:33.135]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.135]                 ...future.rng), started = ...future.startTime, 
[17:02:33.135]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.135]             version = "1.8"), class = "FutureResult")
[17:02:33.135]     }, finally = {
[17:02:33.135]         if (!identical(...future.workdir, getwd())) 
[17:02:33.135]             setwd(...future.workdir)
[17:02:33.135]         {
[17:02:33.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.135]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.135]             }
[17:02:33.135]             base::options(...future.oldOptions)
[17:02:33.135]             if (.Platform$OS.type == "windows") {
[17:02:33.135]                 old_names <- names(...future.oldEnvVars)
[17:02:33.135]                 envs <- base::Sys.getenv()
[17:02:33.135]                 names <- names(envs)
[17:02:33.135]                 common <- intersect(names, old_names)
[17:02:33.135]                 added <- setdiff(names, old_names)
[17:02:33.135]                 removed <- setdiff(old_names, names)
[17:02:33.135]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.135]                   envs[common]]
[17:02:33.135]                 NAMES <- toupper(changed)
[17:02:33.135]                 args <- list()
[17:02:33.135]                 for (kk in seq_along(NAMES)) {
[17:02:33.135]                   name <- changed[[kk]]
[17:02:33.135]                   NAME <- NAMES[[kk]]
[17:02:33.135]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.135]                     next
[17:02:33.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.135]                 }
[17:02:33.135]                 NAMES <- toupper(added)
[17:02:33.135]                 for (kk in seq_along(NAMES)) {
[17:02:33.135]                   name <- added[[kk]]
[17:02:33.135]                   NAME <- NAMES[[kk]]
[17:02:33.135]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.135]                     next
[17:02:33.135]                   args[[name]] <- ""
[17:02:33.135]                 }
[17:02:33.135]                 NAMES <- toupper(removed)
[17:02:33.135]                 for (kk in seq_along(NAMES)) {
[17:02:33.135]                   name <- removed[[kk]]
[17:02:33.135]                   NAME <- NAMES[[kk]]
[17:02:33.135]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.135]                     next
[17:02:33.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.135]                 }
[17:02:33.135]                 if (length(args) > 0) 
[17:02:33.135]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.135]             }
[17:02:33.135]             else {
[17:02:33.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.135]             }
[17:02:33.135]             {
[17:02:33.135]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.135]                   0L) {
[17:02:33.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.135]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.135]                   base::options(opts)
[17:02:33.135]                 }
[17:02:33.135]                 {
[17:02:33.135]                   {
[17:02:33.135]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.135]                     NULL
[17:02:33.135]                   }
[17:02:33.135]                   options(future.plan = NULL)
[17:02:33.135]                   if (is.na(NA_character_)) 
[17:02:33.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.135]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.135]                     .init = FALSE)
[17:02:33.135]                 }
[17:02:33.135]             }
[17:02:33.135]         }
[17:02:33.135]     })
[17:02:33.135]     if (TRUE) {
[17:02:33.135]         base::sink(type = "output", split = FALSE)
[17:02:33.135]         if (TRUE) {
[17:02:33.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.135]         }
[17:02:33.135]         else {
[17:02:33.135]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.135]         }
[17:02:33.135]         base::close(...future.stdout)
[17:02:33.135]         ...future.stdout <- NULL
[17:02:33.135]     }
[17:02:33.135]     ...future.result$conditions <- ...future.conditions
[17:02:33.135]     ...future.result$finished <- base::Sys.time()
[17:02:33.135]     ...future.result
[17:02:33.135] }
[17:02:33.138] MultisessionFuture started
[17:02:33.139] - Launch lazy future ... done
[17:02:33.139] run() for ‘MultisessionFuture’ ... done
[17:02:33.139] getGlobalsAndPackages() ...
[17:02:33.139] Searching for globals...
[17:02:33.139] 
[17:02:33.139] Searching for globals ... DONE
[17:02:33.140] - globals: [0] <none>
[17:02:33.140] getGlobalsAndPackages() ... DONE
[17:02:33.140] run() for ‘Future’ ...
[17:02:33.140] - state: ‘created’
[17:02:33.140] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.154] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.154] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.154]   - Field: ‘node’
[17:02:33.155]   - Field: ‘label’
[17:02:33.155]   - Field: ‘local’
[17:02:33.155]   - Field: ‘owner’
[17:02:33.155]   - Field: ‘envir’
[17:02:33.155]   - Field: ‘workers’
[17:02:33.155]   - Field: ‘packages’
[17:02:33.155]   - Field: ‘gc’
[17:02:33.155]   - Field: ‘conditions’
[17:02:33.155]   - Field: ‘persistent’
[17:02:33.155]   - Field: ‘expr’
[17:02:33.156]   - Field: ‘uuid’
[17:02:33.156]   - Field: ‘seed’
[17:02:33.156]   - Field: ‘version’
[17:02:33.156]   - Field: ‘result’
[17:02:33.156]   - Field: ‘asynchronous’
[17:02:33.156]   - Field: ‘calls’
[17:02:33.156]   - Field: ‘globals’
[17:02:33.156]   - Field: ‘stdout’
[17:02:33.156]   - Field: ‘earlySignal’
[17:02:33.156]   - Field: ‘lazy’
[17:02:33.156]   - Field: ‘state’
[17:02:33.157] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.157] - Launch lazy future ...
[17:02:33.157] Packages needed by the future expression (n = 0): <none>
[17:02:33.157] Packages needed by future strategies (n = 0): <none>
[17:02:33.158] {
[17:02:33.158]     {
[17:02:33.158]         {
[17:02:33.158]             ...future.startTime <- base::Sys.time()
[17:02:33.158]             {
[17:02:33.158]                 {
[17:02:33.158]                   {
[17:02:33.158]                     {
[17:02:33.158]                       base::local({
[17:02:33.158]                         has_future <- base::requireNamespace("future", 
[17:02:33.158]                           quietly = TRUE)
[17:02:33.158]                         if (has_future) {
[17:02:33.158]                           ns <- base::getNamespace("future")
[17:02:33.158]                           version <- ns[[".package"]][["version"]]
[17:02:33.158]                           if (is.null(version)) 
[17:02:33.158]                             version <- utils::packageVersion("future")
[17:02:33.158]                         }
[17:02:33.158]                         else {
[17:02:33.158]                           version <- NULL
[17:02:33.158]                         }
[17:02:33.158]                         if (!has_future || version < "1.8.0") {
[17:02:33.158]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.158]                             "", base::R.version$version.string), 
[17:02:33.158]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.158]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.158]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.158]                               "release", "version")], collapse = " "), 
[17:02:33.158]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.158]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.158]                             info)
[17:02:33.158]                           info <- base::paste(info, collapse = "; ")
[17:02:33.158]                           if (!has_future) {
[17:02:33.158]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.158]                               info)
[17:02:33.158]                           }
[17:02:33.158]                           else {
[17:02:33.158]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.158]                               info, version)
[17:02:33.158]                           }
[17:02:33.158]                           base::stop(msg)
[17:02:33.158]                         }
[17:02:33.158]                       })
[17:02:33.158]                     }
[17:02:33.158]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.158]                     base::options(mc.cores = 1L)
[17:02:33.158]                   }
[17:02:33.158]                   ...future.strategy.old <- future::plan("list")
[17:02:33.158]                   options(future.plan = NULL)
[17:02:33.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.158]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.158]                 }
[17:02:33.158]                 ...future.workdir <- getwd()
[17:02:33.158]             }
[17:02:33.158]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.158]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.158]         }
[17:02:33.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.158]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.158]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.158]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.158]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.158]             base::names(...future.oldOptions))
[17:02:33.158]     }
[17:02:33.158]     if (FALSE) {
[17:02:33.158]     }
[17:02:33.158]     else {
[17:02:33.158]         if (TRUE) {
[17:02:33.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.158]                 open = "w")
[17:02:33.158]         }
[17:02:33.158]         else {
[17:02:33.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.158]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.158]         }
[17:02:33.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.158]             base::sink(type = "output", split = FALSE)
[17:02:33.158]             base::close(...future.stdout)
[17:02:33.158]         }, add = TRUE)
[17:02:33.158]     }
[17:02:33.158]     ...future.frame <- base::sys.nframe()
[17:02:33.158]     ...future.conditions <- base::list()
[17:02:33.158]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.158]     if (FALSE) {
[17:02:33.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.158]     }
[17:02:33.158]     ...future.result <- base::tryCatch({
[17:02:33.158]         base::withCallingHandlers({
[17:02:33.158]             ...future.value <- base::withVisible(base::local({
[17:02:33.158]                 ...future.makeSendCondition <- base::local({
[17:02:33.158]                   sendCondition <- NULL
[17:02:33.158]                   function(frame = 1L) {
[17:02:33.158]                     if (is.function(sendCondition)) 
[17:02:33.158]                       return(sendCondition)
[17:02:33.158]                     ns <- getNamespace("parallel")
[17:02:33.158]                     if (exists("sendData", mode = "function", 
[17:02:33.158]                       envir = ns)) {
[17:02:33.158]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.158]                         envir = ns)
[17:02:33.158]                       envir <- sys.frame(frame)
[17:02:33.158]                       master <- NULL
[17:02:33.158]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.158]                         !identical(envir, emptyenv())) {
[17:02:33.158]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.158]                           inherits = FALSE)) {
[17:02:33.158]                           master <- get("master", mode = "list", 
[17:02:33.158]                             envir = envir, inherits = FALSE)
[17:02:33.158]                           if (inherits(master, c("SOCKnode", 
[17:02:33.158]                             "SOCK0node"))) {
[17:02:33.158]                             sendCondition <<- function(cond) {
[17:02:33.158]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.158]                                 success = TRUE)
[17:02:33.158]                               parallel_sendData(master, data)
[17:02:33.158]                             }
[17:02:33.158]                             return(sendCondition)
[17:02:33.158]                           }
[17:02:33.158]                         }
[17:02:33.158]                         frame <- frame + 1L
[17:02:33.158]                         envir <- sys.frame(frame)
[17:02:33.158]                       }
[17:02:33.158]                     }
[17:02:33.158]                     sendCondition <<- function(cond) NULL
[17:02:33.158]                   }
[17:02:33.158]                 })
[17:02:33.158]                 withCallingHandlers({
[17:02:33.158]                   NULL
[17:02:33.158]                 }, immediateCondition = function(cond) {
[17:02:33.158]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.158]                   sendCondition(cond)
[17:02:33.158]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.158]                   {
[17:02:33.158]                     inherits <- base::inherits
[17:02:33.158]                     invokeRestart <- base::invokeRestart
[17:02:33.158]                     is.null <- base::is.null
[17:02:33.158]                     muffled <- FALSE
[17:02:33.158]                     if (inherits(cond, "message")) {
[17:02:33.158]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.158]                       if (muffled) 
[17:02:33.158]                         invokeRestart("muffleMessage")
[17:02:33.158]                     }
[17:02:33.158]                     else if (inherits(cond, "warning")) {
[17:02:33.158]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.158]                       if (muffled) 
[17:02:33.158]                         invokeRestart("muffleWarning")
[17:02:33.158]                     }
[17:02:33.158]                     else if (inherits(cond, "condition")) {
[17:02:33.158]                       if (!is.null(pattern)) {
[17:02:33.158]                         computeRestarts <- base::computeRestarts
[17:02:33.158]                         grepl <- base::grepl
[17:02:33.158]                         restarts <- computeRestarts(cond)
[17:02:33.158]                         for (restart in restarts) {
[17:02:33.158]                           name <- restart$name
[17:02:33.158]                           if (is.null(name)) 
[17:02:33.158]                             next
[17:02:33.158]                           if (!grepl(pattern, name)) 
[17:02:33.158]                             next
[17:02:33.158]                           invokeRestart(restart)
[17:02:33.158]                           muffled <- TRUE
[17:02:33.158]                           break
[17:02:33.158]                         }
[17:02:33.158]                       }
[17:02:33.158]                     }
[17:02:33.158]                     invisible(muffled)
[17:02:33.158]                   }
[17:02:33.158]                   muffleCondition(cond)
[17:02:33.158]                 })
[17:02:33.158]             }))
[17:02:33.158]             future::FutureResult(value = ...future.value$value, 
[17:02:33.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.158]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.158]                     ...future.globalenv.names))
[17:02:33.158]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.158]         }, condition = base::local({
[17:02:33.158]             c <- base::c
[17:02:33.158]             inherits <- base::inherits
[17:02:33.158]             invokeRestart <- base::invokeRestart
[17:02:33.158]             length <- base::length
[17:02:33.158]             list <- base::list
[17:02:33.158]             seq.int <- base::seq.int
[17:02:33.158]             signalCondition <- base::signalCondition
[17:02:33.158]             sys.calls <- base::sys.calls
[17:02:33.158]             `[[` <- base::`[[`
[17:02:33.158]             `+` <- base::`+`
[17:02:33.158]             `<<-` <- base::`<<-`
[17:02:33.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.158]                   3L)]
[17:02:33.158]             }
[17:02:33.158]             function(cond) {
[17:02:33.158]                 is_error <- inherits(cond, "error")
[17:02:33.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.158]                   NULL)
[17:02:33.158]                 if (is_error) {
[17:02:33.158]                   sessionInformation <- function() {
[17:02:33.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.158]                       search = base::search(), system = base::Sys.info())
[17:02:33.158]                   }
[17:02:33.158]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.158]                     cond$call), session = sessionInformation(), 
[17:02:33.158]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.158]                   signalCondition(cond)
[17:02:33.158]                 }
[17:02:33.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.158]                 "immediateCondition"))) {
[17:02:33.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.158]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.158]                   if (TRUE && !signal) {
[17:02:33.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.158]                     {
[17:02:33.158]                       inherits <- base::inherits
[17:02:33.158]                       invokeRestart <- base::invokeRestart
[17:02:33.158]                       is.null <- base::is.null
[17:02:33.158]                       muffled <- FALSE
[17:02:33.158]                       if (inherits(cond, "message")) {
[17:02:33.158]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.158]                         if (muffled) 
[17:02:33.158]                           invokeRestart("muffleMessage")
[17:02:33.158]                       }
[17:02:33.158]                       else if (inherits(cond, "warning")) {
[17:02:33.158]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.158]                         if (muffled) 
[17:02:33.158]                           invokeRestart("muffleWarning")
[17:02:33.158]                       }
[17:02:33.158]                       else if (inherits(cond, "condition")) {
[17:02:33.158]                         if (!is.null(pattern)) {
[17:02:33.158]                           computeRestarts <- base::computeRestarts
[17:02:33.158]                           grepl <- base::grepl
[17:02:33.158]                           restarts <- computeRestarts(cond)
[17:02:33.158]                           for (restart in restarts) {
[17:02:33.158]                             name <- restart$name
[17:02:33.158]                             if (is.null(name)) 
[17:02:33.158]                               next
[17:02:33.158]                             if (!grepl(pattern, name)) 
[17:02:33.158]                               next
[17:02:33.158]                             invokeRestart(restart)
[17:02:33.158]                             muffled <- TRUE
[17:02:33.158]                             break
[17:02:33.158]                           }
[17:02:33.158]                         }
[17:02:33.158]                       }
[17:02:33.158]                       invisible(muffled)
[17:02:33.158]                     }
[17:02:33.158]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.158]                   }
[17:02:33.158]                 }
[17:02:33.158]                 else {
[17:02:33.158]                   if (TRUE) {
[17:02:33.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.158]                     {
[17:02:33.158]                       inherits <- base::inherits
[17:02:33.158]                       invokeRestart <- base::invokeRestart
[17:02:33.158]                       is.null <- base::is.null
[17:02:33.158]                       muffled <- FALSE
[17:02:33.158]                       if (inherits(cond, "message")) {
[17:02:33.158]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.158]                         if (muffled) 
[17:02:33.158]                           invokeRestart("muffleMessage")
[17:02:33.158]                       }
[17:02:33.158]                       else if (inherits(cond, "warning")) {
[17:02:33.158]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.158]                         if (muffled) 
[17:02:33.158]                           invokeRestart("muffleWarning")
[17:02:33.158]                       }
[17:02:33.158]                       else if (inherits(cond, "condition")) {
[17:02:33.158]                         if (!is.null(pattern)) {
[17:02:33.158]                           computeRestarts <- base::computeRestarts
[17:02:33.158]                           grepl <- base::grepl
[17:02:33.158]                           restarts <- computeRestarts(cond)
[17:02:33.158]                           for (restart in restarts) {
[17:02:33.158]                             name <- restart$name
[17:02:33.158]                             if (is.null(name)) 
[17:02:33.158]                               next
[17:02:33.158]                             if (!grepl(pattern, name)) 
[17:02:33.158]                               next
[17:02:33.158]                             invokeRestart(restart)
[17:02:33.158]                             muffled <- TRUE
[17:02:33.158]                             break
[17:02:33.158]                           }
[17:02:33.158]                         }
[17:02:33.158]                       }
[17:02:33.158]                       invisible(muffled)
[17:02:33.158]                     }
[17:02:33.158]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.158]                   }
[17:02:33.158]                 }
[17:02:33.158]             }
[17:02:33.158]         }))
[17:02:33.158]     }, error = function(ex) {
[17:02:33.158]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.158]                 ...future.rng), started = ...future.startTime, 
[17:02:33.158]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.158]             version = "1.8"), class = "FutureResult")
[17:02:33.158]     }, finally = {
[17:02:33.158]         if (!identical(...future.workdir, getwd())) 
[17:02:33.158]             setwd(...future.workdir)
[17:02:33.158]         {
[17:02:33.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.158]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.158]             }
[17:02:33.158]             base::options(...future.oldOptions)
[17:02:33.158]             if (.Platform$OS.type == "windows") {
[17:02:33.158]                 old_names <- names(...future.oldEnvVars)
[17:02:33.158]                 envs <- base::Sys.getenv()
[17:02:33.158]                 names <- names(envs)
[17:02:33.158]                 common <- intersect(names, old_names)
[17:02:33.158]                 added <- setdiff(names, old_names)
[17:02:33.158]                 removed <- setdiff(old_names, names)
[17:02:33.158]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.158]                   envs[common]]
[17:02:33.158]                 NAMES <- toupper(changed)
[17:02:33.158]                 args <- list()
[17:02:33.158]                 for (kk in seq_along(NAMES)) {
[17:02:33.158]                   name <- changed[[kk]]
[17:02:33.158]                   NAME <- NAMES[[kk]]
[17:02:33.158]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.158]                     next
[17:02:33.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.158]                 }
[17:02:33.158]                 NAMES <- toupper(added)
[17:02:33.158]                 for (kk in seq_along(NAMES)) {
[17:02:33.158]                   name <- added[[kk]]
[17:02:33.158]                   NAME <- NAMES[[kk]]
[17:02:33.158]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.158]                     next
[17:02:33.158]                   args[[name]] <- ""
[17:02:33.158]                 }
[17:02:33.158]                 NAMES <- toupper(removed)
[17:02:33.158]                 for (kk in seq_along(NAMES)) {
[17:02:33.158]                   name <- removed[[kk]]
[17:02:33.158]                   NAME <- NAMES[[kk]]
[17:02:33.158]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.158]                     next
[17:02:33.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.158]                 }
[17:02:33.158]                 if (length(args) > 0) 
[17:02:33.158]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.158]             }
[17:02:33.158]             else {
[17:02:33.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.158]             }
[17:02:33.158]             {
[17:02:33.158]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.158]                   0L) {
[17:02:33.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.158]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.158]                   base::options(opts)
[17:02:33.158]                 }
[17:02:33.158]                 {
[17:02:33.158]                   {
[17:02:33.158]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.158]                     NULL
[17:02:33.158]                   }
[17:02:33.158]                   options(future.plan = NULL)
[17:02:33.158]                   if (is.na(NA_character_)) 
[17:02:33.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.158]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.158]                     .init = FALSE)
[17:02:33.158]                 }
[17:02:33.158]             }
[17:02:33.158]         }
[17:02:33.158]     })
[17:02:33.158]     if (TRUE) {
[17:02:33.158]         base::sink(type = "output", split = FALSE)
[17:02:33.158]         if (TRUE) {
[17:02:33.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.158]         }
[17:02:33.158]         else {
[17:02:33.158]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.158]         }
[17:02:33.158]         base::close(...future.stdout)
[17:02:33.158]         ...future.stdout <- NULL
[17:02:33.158]     }
[17:02:33.158]     ...future.result$conditions <- ...future.conditions
[17:02:33.158]     ...future.result$finished <- base::Sys.time()
[17:02:33.158]     ...future.result
[17:02:33.158] }
[17:02:33.212] MultisessionFuture started
[17:02:33.212] - Launch lazy future ... done
[17:02:33.212] run() for ‘MultisessionFuture’ ... done
[17:02:33.213] getGlobalsAndPackages() ...
[17:02:33.213] Searching for globals...
[17:02:33.214] - globals found: [1] ‘{’
[17:02:33.214] Searching for globals ... DONE
[17:02:33.214] Resolving globals: FALSE
[17:02:33.214] 
[17:02:33.214] 
[17:02:33.214] getGlobalsAndPackages() ... DONE
[17:02:33.215] run() for ‘Future’ ...
[17:02:33.215] - state: ‘created’
[17:02:33.215] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.232] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.233]   - Field: ‘node’
[17:02:33.233]   - Field: ‘label’
[17:02:33.233]   - Field: ‘local’
[17:02:33.233]   - Field: ‘owner’
[17:02:33.234]   - Field: ‘envir’
[17:02:33.234]   - Field: ‘workers’
[17:02:33.234]   - Field: ‘packages’
[17:02:33.234]   - Field: ‘gc’
[17:02:33.234]   - Field: ‘conditions’
[17:02:33.234]   - Field: ‘persistent’
[17:02:33.235]   - Field: ‘expr’
[17:02:33.235]   - Field: ‘uuid’
[17:02:33.235]   - Field: ‘seed’
[17:02:33.235]   - Field: ‘version’
[17:02:33.235]   - Field: ‘result’
[17:02:33.235]   - Field: ‘asynchronous’
[17:02:33.236]   - Field: ‘calls’
[17:02:33.236]   - Field: ‘globals’
[17:02:33.236]   - Field: ‘stdout’
[17:02:33.236]   - Field: ‘earlySignal’
[17:02:33.236]   - Field: ‘lazy’
[17:02:33.236]   - Field: ‘state’
[17:02:33.236] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.237] - Launch lazy future ...
[17:02:33.237] Packages needed by the future expression (n = 0): <none>
[17:02:33.237] Packages needed by future strategies (n = 0): <none>
[17:02:33.243] {
[17:02:33.243]     {
[17:02:33.243]         {
[17:02:33.243]             ...future.startTime <- base::Sys.time()
[17:02:33.243]             {
[17:02:33.243]                 {
[17:02:33.243]                   {
[17:02:33.243]                     {
[17:02:33.243]                       base::local({
[17:02:33.243]                         has_future <- base::requireNamespace("future", 
[17:02:33.243]                           quietly = TRUE)
[17:02:33.243]                         if (has_future) {
[17:02:33.243]                           ns <- base::getNamespace("future")
[17:02:33.243]                           version <- ns[[".package"]][["version"]]
[17:02:33.243]                           if (is.null(version)) 
[17:02:33.243]                             version <- utils::packageVersion("future")
[17:02:33.243]                         }
[17:02:33.243]                         else {
[17:02:33.243]                           version <- NULL
[17:02:33.243]                         }
[17:02:33.243]                         if (!has_future || version < "1.8.0") {
[17:02:33.243]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.243]                             "", base::R.version$version.string), 
[17:02:33.243]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.243]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.243]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.243]                               "release", "version")], collapse = " "), 
[17:02:33.243]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.243]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.243]                             info)
[17:02:33.243]                           info <- base::paste(info, collapse = "; ")
[17:02:33.243]                           if (!has_future) {
[17:02:33.243]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.243]                               info)
[17:02:33.243]                           }
[17:02:33.243]                           else {
[17:02:33.243]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.243]                               info, version)
[17:02:33.243]                           }
[17:02:33.243]                           base::stop(msg)
[17:02:33.243]                         }
[17:02:33.243]                       })
[17:02:33.243]                     }
[17:02:33.243]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.243]                     base::options(mc.cores = 1L)
[17:02:33.243]                   }
[17:02:33.243]                   ...future.strategy.old <- future::plan("list")
[17:02:33.243]                   options(future.plan = NULL)
[17:02:33.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.243]                 }
[17:02:33.243]                 ...future.workdir <- getwd()
[17:02:33.243]             }
[17:02:33.243]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.243]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.243]         }
[17:02:33.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.243]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.243]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.243]             base::names(...future.oldOptions))
[17:02:33.243]     }
[17:02:33.243]     if (FALSE) {
[17:02:33.243]     }
[17:02:33.243]     else {
[17:02:33.243]         if (TRUE) {
[17:02:33.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.243]                 open = "w")
[17:02:33.243]         }
[17:02:33.243]         else {
[17:02:33.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.243]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.243]         }
[17:02:33.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.243]             base::sink(type = "output", split = FALSE)
[17:02:33.243]             base::close(...future.stdout)
[17:02:33.243]         }, add = TRUE)
[17:02:33.243]     }
[17:02:33.243]     ...future.frame <- base::sys.nframe()
[17:02:33.243]     ...future.conditions <- base::list()
[17:02:33.243]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.243]     if (FALSE) {
[17:02:33.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.243]     }
[17:02:33.243]     ...future.result <- base::tryCatch({
[17:02:33.243]         base::withCallingHandlers({
[17:02:33.243]             ...future.value <- base::withVisible(base::local({
[17:02:33.243]                 ...future.makeSendCondition <- base::local({
[17:02:33.243]                   sendCondition <- NULL
[17:02:33.243]                   function(frame = 1L) {
[17:02:33.243]                     if (is.function(sendCondition)) 
[17:02:33.243]                       return(sendCondition)
[17:02:33.243]                     ns <- getNamespace("parallel")
[17:02:33.243]                     if (exists("sendData", mode = "function", 
[17:02:33.243]                       envir = ns)) {
[17:02:33.243]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.243]                         envir = ns)
[17:02:33.243]                       envir <- sys.frame(frame)
[17:02:33.243]                       master <- NULL
[17:02:33.243]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.243]                         !identical(envir, emptyenv())) {
[17:02:33.243]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.243]                           inherits = FALSE)) {
[17:02:33.243]                           master <- get("master", mode = "list", 
[17:02:33.243]                             envir = envir, inherits = FALSE)
[17:02:33.243]                           if (inherits(master, c("SOCKnode", 
[17:02:33.243]                             "SOCK0node"))) {
[17:02:33.243]                             sendCondition <<- function(cond) {
[17:02:33.243]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.243]                                 success = TRUE)
[17:02:33.243]                               parallel_sendData(master, data)
[17:02:33.243]                             }
[17:02:33.243]                             return(sendCondition)
[17:02:33.243]                           }
[17:02:33.243]                         }
[17:02:33.243]                         frame <- frame + 1L
[17:02:33.243]                         envir <- sys.frame(frame)
[17:02:33.243]                       }
[17:02:33.243]                     }
[17:02:33.243]                     sendCondition <<- function(cond) NULL
[17:02:33.243]                   }
[17:02:33.243]                 })
[17:02:33.243]                 withCallingHandlers({
[17:02:33.243]                   {
[17:02:33.243]                     4
[17:02:33.243]                   }
[17:02:33.243]                 }, immediateCondition = function(cond) {
[17:02:33.243]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.243]                   sendCondition(cond)
[17:02:33.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.243]                   {
[17:02:33.243]                     inherits <- base::inherits
[17:02:33.243]                     invokeRestart <- base::invokeRestart
[17:02:33.243]                     is.null <- base::is.null
[17:02:33.243]                     muffled <- FALSE
[17:02:33.243]                     if (inherits(cond, "message")) {
[17:02:33.243]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.243]                       if (muffled) 
[17:02:33.243]                         invokeRestart("muffleMessage")
[17:02:33.243]                     }
[17:02:33.243]                     else if (inherits(cond, "warning")) {
[17:02:33.243]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.243]                       if (muffled) 
[17:02:33.243]                         invokeRestart("muffleWarning")
[17:02:33.243]                     }
[17:02:33.243]                     else if (inherits(cond, "condition")) {
[17:02:33.243]                       if (!is.null(pattern)) {
[17:02:33.243]                         computeRestarts <- base::computeRestarts
[17:02:33.243]                         grepl <- base::grepl
[17:02:33.243]                         restarts <- computeRestarts(cond)
[17:02:33.243]                         for (restart in restarts) {
[17:02:33.243]                           name <- restart$name
[17:02:33.243]                           if (is.null(name)) 
[17:02:33.243]                             next
[17:02:33.243]                           if (!grepl(pattern, name)) 
[17:02:33.243]                             next
[17:02:33.243]                           invokeRestart(restart)
[17:02:33.243]                           muffled <- TRUE
[17:02:33.243]                           break
[17:02:33.243]                         }
[17:02:33.243]                       }
[17:02:33.243]                     }
[17:02:33.243]                     invisible(muffled)
[17:02:33.243]                   }
[17:02:33.243]                   muffleCondition(cond)
[17:02:33.243]                 })
[17:02:33.243]             }))
[17:02:33.243]             future::FutureResult(value = ...future.value$value, 
[17:02:33.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.243]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.243]                     ...future.globalenv.names))
[17:02:33.243]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.243]         }, condition = base::local({
[17:02:33.243]             c <- base::c
[17:02:33.243]             inherits <- base::inherits
[17:02:33.243]             invokeRestart <- base::invokeRestart
[17:02:33.243]             length <- base::length
[17:02:33.243]             list <- base::list
[17:02:33.243]             seq.int <- base::seq.int
[17:02:33.243]             signalCondition <- base::signalCondition
[17:02:33.243]             sys.calls <- base::sys.calls
[17:02:33.243]             `[[` <- base::`[[`
[17:02:33.243]             `+` <- base::`+`
[17:02:33.243]             `<<-` <- base::`<<-`
[17:02:33.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.243]                   3L)]
[17:02:33.243]             }
[17:02:33.243]             function(cond) {
[17:02:33.243]                 is_error <- inherits(cond, "error")
[17:02:33.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.243]                   NULL)
[17:02:33.243]                 if (is_error) {
[17:02:33.243]                   sessionInformation <- function() {
[17:02:33.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.243]                       search = base::search(), system = base::Sys.info())
[17:02:33.243]                   }
[17:02:33.243]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.243]                     cond$call), session = sessionInformation(), 
[17:02:33.243]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.243]                   signalCondition(cond)
[17:02:33.243]                 }
[17:02:33.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.243]                 "immediateCondition"))) {
[17:02:33.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.243]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.243]                   if (TRUE && !signal) {
[17:02:33.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.243]                     {
[17:02:33.243]                       inherits <- base::inherits
[17:02:33.243]                       invokeRestart <- base::invokeRestart
[17:02:33.243]                       is.null <- base::is.null
[17:02:33.243]                       muffled <- FALSE
[17:02:33.243]                       if (inherits(cond, "message")) {
[17:02:33.243]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.243]                         if (muffled) 
[17:02:33.243]                           invokeRestart("muffleMessage")
[17:02:33.243]                       }
[17:02:33.243]                       else if (inherits(cond, "warning")) {
[17:02:33.243]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.243]                         if (muffled) 
[17:02:33.243]                           invokeRestart("muffleWarning")
[17:02:33.243]                       }
[17:02:33.243]                       else if (inherits(cond, "condition")) {
[17:02:33.243]                         if (!is.null(pattern)) {
[17:02:33.243]                           computeRestarts <- base::computeRestarts
[17:02:33.243]                           grepl <- base::grepl
[17:02:33.243]                           restarts <- computeRestarts(cond)
[17:02:33.243]                           for (restart in restarts) {
[17:02:33.243]                             name <- restart$name
[17:02:33.243]                             if (is.null(name)) 
[17:02:33.243]                               next
[17:02:33.243]                             if (!grepl(pattern, name)) 
[17:02:33.243]                               next
[17:02:33.243]                             invokeRestart(restart)
[17:02:33.243]                             muffled <- TRUE
[17:02:33.243]                             break
[17:02:33.243]                           }
[17:02:33.243]                         }
[17:02:33.243]                       }
[17:02:33.243]                       invisible(muffled)
[17:02:33.243]                     }
[17:02:33.243]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.243]                   }
[17:02:33.243]                 }
[17:02:33.243]                 else {
[17:02:33.243]                   if (TRUE) {
[17:02:33.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.243]                     {
[17:02:33.243]                       inherits <- base::inherits
[17:02:33.243]                       invokeRestart <- base::invokeRestart
[17:02:33.243]                       is.null <- base::is.null
[17:02:33.243]                       muffled <- FALSE
[17:02:33.243]                       if (inherits(cond, "message")) {
[17:02:33.243]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.243]                         if (muffled) 
[17:02:33.243]                           invokeRestart("muffleMessage")
[17:02:33.243]                       }
[17:02:33.243]                       else if (inherits(cond, "warning")) {
[17:02:33.243]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.243]                         if (muffled) 
[17:02:33.243]                           invokeRestart("muffleWarning")
[17:02:33.243]                       }
[17:02:33.243]                       else if (inherits(cond, "condition")) {
[17:02:33.243]                         if (!is.null(pattern)) {
[17:02:33.243]                           computeRestarts <- base::computeRestarts
[17:02:33.243]                           grepl <- base::grepl
[17:02:33.243]                           restarts <- computeRestarts(cond)
[17:02:33.243]                           for (restart in restarts) {
[17:02:33.243]                             name <- restart$name
[17:02:33.243]                             if (is.null(name)) 
[17:02:33.243]                               next
[17:02:33.243]                             if (!grepl(pattern, name)) 
[17:02:33.243]                               next
[17:02:33.243]                             invokeRestart(restart)
[17:02:33.243]                             muffled <- TRUE
[17:02:33.243]                             break
[17:02:33.243]                           }
[17:02:33.243]                         }
[17:02:33.243]                       }
[17:02:33.243]                       invisible(muffled)
[17:02:33.243]                     }
[17:02:33.243]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.243]                   }
[17:02:33.243]                 }
[17:02:33.243]             }
[17:02:33.243]         }))
[17:02:33.243]     }, error = function(ex) {
[17:02:33.243]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.243]                 ...future.rng), started = ...future.startTime, 
[17:02:33.243]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.243]             version = "1.8"), class = "FutureResult")
[17:02:33.243]     }, finally = {
[17:02:33.243]         if (!identical(...future.workdir, getwd())) 
[17:02:33.243]             setwd(...future.workdir)
[17:02:33.243]         {
[17:02:33.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.243]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.243]             }
[17:02:33.243]             base::options(...future.oldOptions)
[17:02:33.243]             if (.Platform$OS.type == "windows") {
[17:02:33.243]                 old_names <- names(...future.oldEnvVars)
[17:02:33.243]                 envs <- base::Sys.getenv()
[17:02:33.243]                 names <- names(envs)
[17:02:33.243]                 common <- intersect(names, old_names)
[17:02:33.243]                 added <- setdiff(names, old_names)
[17:02:33.243]                 removed <- setdiff(old_names, names)
[17:02:33.243]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.243]                   envs[common]]
[17:02:33.243]                 NAMES <- toupper(changed)
[17:02:33.243]                 args <- list()
[17:02:33.243]                 for (kk in seq_along(NAMES)) {
[17:02:33.243]                   name <- changed[[kk]]
[17:02:33.243]                   NAME <- NAMES[[kk]]
[17:02:33.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.243]                     next
[17:02:33.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.243]                 }
[17:02:33.243]                 NAMES <- toupper(added)
[17:02:33.243]                 for (kk in seq_along(NAMES)) {
[17:02:33.243]                   name <- added[[kk]]
[17:02:33.243]                   NAME <- NAMES[[kk]]
[17:02:33.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.243]                     next
[17:02:33.243]                   args[[name]] <- ""
[17:02:33.243]                 }
[17:02:33.243]                 NAMES <- toupper(removed)
[17:02:33.243]                 for (kk in seq_along(NAMES)) {
[17:02:33.243]                   name <- removed[[kk]]
[17:02:33.243]                   NAME <- NAMES[[kk]]
[17:02:33.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.243]                     next
[17:02:33.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.243]                 }
[17:02:33.243]                 if (length(args) > 0) 
[17:02:33.243]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.243]             }
[17:02:33.243]             else {
[17:02:33.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.243]             }
[17:02:33.243]             {
[17:02:33.243]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.243]                   0L) {
[17:02:33.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.243]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.243]                   base::options(opts)
[17:02:33.243]                 }
[17:02:33.243]                 {
[17:02:33.243]                   {
[17:02:33.243]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.243]                     NULL
[17:02:33.243]                   }
[17:02:33.243]                   options(future.plan = NULL)
[17:02:33.243]                   if (is.na(NA_character_)) 
[17:02:33.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.243]                     .init = FALSE)
[17:02:33.243]                 }
[17:02:33.243]             }
[17:02:33.243]         }
[17:02:33.243]     })
[17:02:33.243]     if (TRUE) {
[17:02:33.243]         base::sink(type = "output", split = FALSE)
[17:02:33.243]         if (TRUE) {
[17:02:33.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.243]         }
[17:02:33.243]         else {
[17:02:33.243]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.243]         }
[17:02:33.243]         base::close(...future.stdout)
[17:02:33.243]         ...future.stdout <- NULL
[17:02:33.243]     }
[17:02:33.243]     ...future.result$conditions <- ...future.conditions
[17:02:33.243]     ...future.result$finished <- base::Sys.time()
[17:02:33.243]     ...future.result
[17:02:33.243] }
[17:02:33.246] Poll #1 (0): usedNodes() = 2, workers = 2
[17:02:33.257] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.258] - Validating connection of MultisessionFuture
[17:02:33.258] - received message: FutureResult
[17:02:33.258] - Received FutureResult
[17:02:33.258] - Erased future from FutureRegistry
[17:02:33.258] result() for ClusterFuture ...
[17:02:33.258] - result already collected: FutureResult
[17:02:33.258] result() for ClusterFuture ... done
[17:02:33.258] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:33.259] result() for ClusterFuture ...
[17:02:33.259] - result already collected: FutureResult
[17:02:33.259] result() for ClusterFuture ... done
[17:02:33.259] result() for ClusterFuture ...
[17:02:33.259] - result already collected: FutureResult
[17:02:33.259] result() for ClusterFuture ... done
[17:02:33.260] MultisessionFuture started
[17:02:33.260] - Launch lazy future ... done
[17:02:33.260] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c74acb2db0> 
Classes 'listenv', 'environment' <environment: 0x55c749e08d78> 
[17:02:33.263] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.263] - Validating connection of MultisessionFuture
[17:02:33.263] - received message: FutureResult
[17:02:33.264] - Received FutureResult
[17:02:33.264] - Erased future from FutureRegistry
[17:02:33.264] result() for ClusterFuture ...
[17:02:33.264] - result already collected: FutureResult
[17:02:33.264] result() for ClusterFuture ... done
[17:02:33.264] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:33.265] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.265] - Validating connection of MultisessionFuture
[17:02:33.266] - received message: FutureResult
[17:02:33.266] - Received FutureResult
[17:02:33.266] - Erased future from FutureRegistry
[17:02:33.266] result() for ClusterFuture ...
[17:02:33.266] - result already collected: FutureResult
[17:02:33.266] result() for ClusterFuture ... done
[17:02:33.266] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:33.268] resolve() on list environment ...
[17:02:33.268]  recursive: 0
[17:02:33.269]  length: 6
[17:02:33.269]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:33.269] signalConditionsASAP(numeric, pos=1) ...
[17:02:33.269] - nx: 6
[17:02:33.269] - relay: TRUE
[17:02:33.269] - stdout: TRUE
[17:02:33.269] - signal: TRUE
[17:02:33.269] - resignal: FALSE
[17:02:33.269] - force: TRUE
[17:02:33.269] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.270] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.270]  - until=2
[17:02:33.270]  - relaying element #2
[17:02:33.270] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.270] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.270] signalConditionsASAP(NULL, pos=1) ... done
[17:02:33.270]  length: 5 (resolved future 1)
[17:02:33.270] Future #2
[17:02:33.270] result() for ClusterFuture ...
[17:02:33.270] - result already collected: FutureResult
[17:02:33.271] result() for ClusterFuture ... done
[17:02:33.271] result() for ClusterFuture ...
[17:02:33.271] - result already collected: FutureResult
[17:02:33.271] result() for ClusterFuture ... done
[17:02:33.271] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:33.271] - nx: 6
[17:02:33.271] - relay: TRUE
[17:02:33.271] - stdout: TRUE
[17:02:33.271] - signal: TRUE
[17:02:33.271] - resignal: FALSE
[17:02:33.271] - force: TRUE
[17:02:33.271] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.272] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.272]  - until=2
[17:02:33.272]  - relaying element #2
[17:02:33.272] result() for ClusterFuture ...
[17:02:33.272] - result already collected: FutureResult
[17:02:33.272] result() for ClusterFuture ... done
[17:02:33.272] result() for ClusterFuture ...
[17:02:33.272] - result already collected: FutureResult
[17:02:33.272] result() for ClusterFuture ... done
[17:02:33.272] result() for ClusterFuture ...
[17:02:33.272] - result already collected: FutureResult
[17:02:33.273] result() for ClusterFuture ... done
[17:02:33.273] result() for ClusterFuture ...
[17:02:33.273] - result already collected: FutureResult
[17:02:33.273] result() for ClusterFuture ... done
[17:02:33.273] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.273] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.273] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:33.273]  length: 4 (resolved future 2)
[17:02:33.273] Future #3
[17:02:33.273] result() for ClusterFuture ...
[17:02:33.273] - result already collected: FutureResult
[17:02:33.274] result() for ClusterFuture ... done
[17:02:33.274] result() for ClusterFuture ...
[17:02:33.274] - result already collected: FutureResult
[17:02:33.274] result() for ClusterFuture ... done
[17:02:33.274] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:33.274] - nx: 6
[17:02:33.274] - relay: TRUE
[17:02:33.274] - stdout: TRUE
[17:02:33.274] - signal: TRUE
[17:02:33.274] - resignal: FALSE
[17:02:33.274] - force: TRUE
[17:02:33.274] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.275] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.275]  - until=3
[17:02:33.275]  - relaying element #3
[17:02:33.275] result() for ClusterFuture ...
[17:02:33.275] - result already collected: FutureResult
[17:02:33.275] result() for ClusterFuture ... done
[17:02:33.275] result() for ClusterFuture ...
[17:02:33.275] - result already collected: FutureResult
[17:02:33.275] result() for ClusterFuture ... done
[17:02:33.275] result() for ClusterFuture ...
[17:02:33.275] - result already collected: FutureResult
[17:02:33.276] result() for ClusterFuture ... done
[17:02:33.276] result() for ClusterFuture ...
[17:02:33.276] - result already collected: FutureResult
[17:02:33.276] result() for ClusterFuture ... done
[17:02:33.276] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.276] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.276] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:33.276]  length: 3 (resolved future 3)
[17:02:33.276] Future #4
[17:02:33.276] result() for ClusterFuture ...
[17:02:33.276] - result already collected: FutureResult
[17:02:33.277] result() for ClusterFuture ... done
[17:02:33.277] result() for ClusterFuture ...
[17:02:33.277] - result already collected: FutureResult
[17:02:33.277] result() for ClusterFuture ... done
[17:02:33.277] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:02:33.277] - nx: 6
[17:02:33.277] - relay: TRUE
[17:02:33.277] - stdout: TRUE
[17:02:33.277] - signal: TRUE
[17:02:33.277] - resignal: FALSE
[17:02:33.277] - force: TRUE
[17:02:33.277] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.278] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.278]  - until=4
[17:02:33.278]  - relaying element #4
[17:02:33.278] result() for ClusterFuture ...
[17:02:33.278] - result already collected: FutureResult
[17:02:33.278] result() for ClusterFuture ... done
[17:02:33.278] result() for ClusterFuture ...
[17:02:33.278] - result already collected: FutureResult
[17:02:33.278] result() for ClusterFuture ... done
[17:02:33.278] result() for ClusterFuture ...
[17:02:33.278] - result already collected: FutureResult
[17:02:33.279] result() for ClusterFuture ... done
[17:02:33.279] result() for ClusterFuture ...
[17:02:33.279] - result already collected: FutureResult
[17:02:33.279] result() for ClusterFuture ... done
[17:02:33.279] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.279] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.279] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:02:33.279]  length: 2 (resolved future 4)
[17:02:33.279] signalConditionsASAP(NULL, pos=5) ...
[17:02:33.279] - nx: 6
[17:02:33.279] - relay: TRUE
[17:02:33.280] - stdout: TRUE
[17:02:33.280] - signal: TRUE
[17:02:33.280] - resignal: FALSE
[17:02:33.280] - force: TRUE
[17:02:33.280] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.280] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.280]  - until=6
[17:02:33.280]  - relaying element #6
[17:02:33.280] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:33.280] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.280] signalConditionsASAP(NULL, pos=5) ... done
[17:02:33.281]  length: 1 (resolved future 5)
[17:02:33.281] signalConditionsASAP(numeric, pos=6) ...
[17:02:33.281] - nx: 6
[17:02:33.281] - relay: TRUE
[17:02:33.281] - stdout: TRUE
[17:02:33.281] - signal: TRUE
[17:02:33.281] - resignal: FALSE
[17:02:33.281] - force: TRUE
[17:02:33.281] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:33.281] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.281]  - until=6
[17:02:33.282] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.282] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.282] signalConditionsASAP(numeric, pos=6) ... done
[17:02:33.282]  length: 0 (resolved future 6)
[17:02:33.282] Relaying remaining futures
[17:02:33.282] signalConditionsASAP(NULL, pos=0) ...
[17:02:33.282] - nx: 6
[17:02:33.282] - relay: TRUE
[17:02:33.282] - stdout: TRUE
[17:02:33.282] - signal: TRUE
[17:02:33.282] - resignal: FALSE
[17:02:33.282] - force: TRUE
[17:02:33.283] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.283] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:33.283] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.283] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.283] signalConditionsASAP(NULL, pos=0) ... done
[17:02:33.283] resolve() on list environment ... DONE
[17:02:33.283] result() for ClusterFuture ...
[17:02:33.283] - result already collected: FutureResult
[17:02:33.283] result() for ClusterFuture ... done
[17:02:33.284] result() for ClusterFuture ...
[17:02:33.284] - result already collected: FutureResult
[17:02:33.284] result() for ClusterFuture ... done
[17:02:33.284] result() for ClusterFuture ...
[17:02:33.284] - result already collected: FutureResult
[17:02:33.284] result() for ClusterFuture ... done
[17:02:33.284] result() for ClusterFuture ...
[17:02:33.284] - result already collected: FutureResult
[17:02:33.284] result() for ClusterFuture ... done
[17:02:33.285] result() for ClusterFuture ...
[17:02:33.285] - result already collected: FutureResult
[17:02:33.285] result() for ClusterFuture ... done
[17:02:33.285] result() for ClusterFuture ...
[17:02:33.285] - result already collected: FutureResult
[17:02:33.285] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c749729f28> 
Dimensions: c(1, 6)
[17:02:33.286] getGlobalsAndPackages() ...
[17:02:33.286] Searching for globals...
[17:02:33.286] 
[17:02:33.286] Searching for globals ... DONE
[17:02:33.286] - globals: [0] <none>
[17:02:33.286] getGlobalsAndPackages() ... DONE
[17:02:33.287] run() for ‘Future’ ...
[17:02:33.287] - state: ‘created’
[17:02:33.287] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.301] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.301] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.301]   - Field: ‘node’
[17:02:33.301]   - Field: ‘label’
[17:02:33.301]   - Field: ‘local’
[17:02:33.302]   - Field: ‘owner’
[17:02:33.302]   - Field: ‘envir’
[17:02:33.302]   - Field: ‘workers’
[17:02:33.302]   - Field: ‘packages’
[17:02:33.302]   - Field: ‘gc’
[17:02:33.302]   - Field: ‘conditions’
[17:02:33.302]   - Field: ‘persistent’
[17:02:33.302]   - Field: ‘expr’
[17:02:33.302]   - Field: ‘uuid’
[17:02:33.302]   - Field: ‘seed’
[17:02:33.303]   - Field: ‘version’
[17:02:33.303]   - Field: ‘result’
[17:02:33.303]   - Field: ‘asynchronous’
[17:02:33.303]   - Field: ‘calls’
[17:02:33.303]   - Field: ‘globals’
[17:02:33.303]   - Field: ‘stdout’
[17:02:33.303]   - Field: ‘earlySignal’
[17:02:33.303]   - Field: ‘lazy’
[17:02:33.303]   - Field: ‘state’
[17:02:33.303] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.303] - Launch lazy future ...
[17:02:33.304] Packages needed by the future expression (n = 0): <none>
[17:02:33.304] Packages needed by future strategies (n = 0): <none>
[17:02:33.304] {
[17:02:33.304]     {
[17:02:33.304]         {
[17:02:33.304]             ...future.startTime <- base::Sys.time()
[17:02:33.304]             {
[17:02:33.304]                 {
[17:02:33.304]                   {
[17:02:33.304]                     {
[17:02:33.304]                       base::local({
[17:02:33.304]                         has_future <- base::requireNamespace("future", 
[17:02:33.304]                           quietly = TRUE)
[17:02:33.304]                         if (has_future) {
[17:02:33.304]                           ns <- base::getNamespace("future")
[17:02:33.304]                           version <- ns[[".package"]][["version"]]
[17:02:33.304]                           if (is.null(version)) 
[17:02:33.304]                             version <- utils::packageVersion("future")
[17:02:33.304]                         }
[17:02:33.304]                         else {
[17:02:33.304]                           version <- NULL
[17:02:33.304]                         }
[17:02:33.304]                         if (!has_future || version < "1.8.0") {
[17:02:33.304]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.304]                             "", base::R.version$version.string), 
[17:02:33.304]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.304]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.304]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.304]                               "release", "version")], collapse = " "), 
[17:02:33.304]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.304]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.304]                             info)
[17:02:33.304]                           info <- base::paste(info, collapse = "; ")
[17:02:33.304]                           if (!has_future) {
[17:02:33.304]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.304]                               info)
[17:02:33.304]                           }
[17:02:33.304]                           else {
[17:02:33.304]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.304]                               info, version)
[17:02:33.304]                           }
[17:02:33.304]                           base::stop(msg)
[17:02:33.304]                         }
[17:02:33.304]                       })
[17:02:33.304]                     }
[17:02:33.304]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.304]                     base::options(mc.cores = 1L)
[17:02:33.304]                   }
[17:02:33.304]                   ...future.strategy.old <- future::plan("list")
[17:02:33.304]                   options(future.plan = NULL)
[17:02:33.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.304]                 }
[17:02:33.304]                 ...future.workdir <- getwd()
[17:02:33.304]             }
[17:02:33.304]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.304]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.304]         }
[17:02:33.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.304]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.304]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.304]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.304]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.304]             base::names(...future.oldOptions))
[17:02:33.304]     }
[17:02:33.304]     if (FALSE) {
[17:02:33.304]     }
[17:02:33.304]     else {
[17:02:33.304]         if (TRUE) {
[17:02:33.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.304]                 open = "w")
[17:02:33.304]         }
[17:02:33.304]         else {
[17:02:33.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.304]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.304]         }
[17:02:33.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.304]             base::sink(type = "output", split = FALSE)
[17:02:33.304]             base::close(...future.stdout)
[17:02:33.304]         }, add = TRUE)
[17:02:33.304]     }
[17:02:33.304]     ...future.frame <- base::sys.nframe()
[17:02:33.304]     ...future.conditions <- base::list()
[17:02:33.304]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.304]     if (FALSE) {
[17:02:33.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.304]     }
[17:02:33.304]     ...future.result <- base::tryCatch({
[17:02:33.304]         base::withCallingHandlers({
[17:02:33.304]             ...future.value <- base::withVisible(base::local({
[17:02:33.304]                 ...future.makeSendCondition <- base::local({
[17:02:33.304]                   sendCondition <- NULL
[17:02:33.304]                   function(frame = 1L) {
[17:02:33.304]                     if (is.function(sendCondition)) 
[17:02:33.304]                       return(sendCondition)
[17:02:33.304]                     ns <- getNamespace("parallel")
[17:02:33.304]                     if (exists("sendData", mode = "function", 
[17:02:33.304]                       envir = ns)) {
[17:02:33.304]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.304]                         envir = ns)
[17:02:33.304]                       envir <- sys.frame(frame)
[17:02:33.304]                       master <- NULL
[17:02:33.304]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.304]                         !identical(envir, emptyenv())) {
[17:02:33.304]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.304]                           inherits = FALSE)) {
[17:02:33.304]                           master <- get("master", mode = "list", 
[17:02:33.304]                             envir = envir, inherits = FALSE)
[17:02:33.304]                           if (inherits(master, c("SOCKnode", 
[17:02:33.304]                             "SOCK0node"))) {
[17:02:33.304]                             sendCondition <<- function(cond) {
[17:02:33.304]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.304]                                 success = TRUE)
[17:02:33.304]                               parallel_sendData(master, data)
[17:02:33.304]                             }
[17:02:33.304]                             return(sendCondition)
[17:02:33.304]                           }
[17:02:33.304]                         }
[17:02:33.304]                         frame <- frame + 1L
[17:02:33.304]                         envir <- sys.frame(frame)
[17:02:33.304]                       }
[17:02:33.304]                     }
[17:02:33.304]                     sendCondition <<- function(cond) NULL
[17:02:33.304]                   }
[17:02:33.304]                 })
[17:02:33.304]                 withCallingHandlers({
[17:02:33.304]                   2
[17:02:33.304]                 }, immediateCondition = function(cond) {
[17:02:33.304]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.304]                   sendCondition(cond)
[17:02:33.304]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.304]                   {
[17:02:33.304]                     inherits <- base::inherits
[17:02:33.304]                     invokeRestart <- base::invokeRestart
[17:02:33.304]                     is.null <- base::is.null
[17:02:33.304]                     muffled <- FALSE
[17:02:33.304]                     if (inherits(cond, "message")) {
[17:02:33.304]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.304]                       if (muffled) 
[17:02:33.304]                         invokeRestart("muffleMessage")
[17:02:33.304]                     }
[17:02:33.304]                     else if (inherits(cond, "warning")) {
[17:02:33.304]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.304]                       if (muffled) 
[17:02:33.304]                         invokeRestart("muffleWarning")
[17:02:33.304]                     }
[17:02:33.304]                     else if (inherits(cond, "condition")) {
[17:02:33.304]                       if (!is.null(pattern)) {
[17:02:33.304]                         computeRestarts <- base::computeRestarts
[17:02:33.304]                         grepl <- base::grepl
[17:02:33.304]                         restarts <- computeRestarts(cond)
[17:02:33.304]                         for (restart in restarts) {
[17:02:33.304]                           name <- restart$name
[17:02:33.304]                           if (is.null(name)) 
[17:02:33.304]                             next
[17:02:33.304]                           if (!grepl(pattern, name)) 
[17:02:33.304]                             next
[17:02:33.304]                           invokeRestart(restart)
[17:02:33.304]                           muffled <- TRUE
[17:02:33.304]                           break
[17:02:33.304]                         }
[17:02:33.304]                       }
[17:02:33.304]                     }
[17:02:33.304]                     invisible(muffled)
[17:02:33.304]                   }
[17:02:33.304]                   muffleCondition(cond)
[17:02:33.304]                 })
[17:02:33.304]             }))
[17:02:33.304]             future::FutureResult(value = ...future.value$value, 
[17:02:33.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.304]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.304]                     ...future.globalenv.names))
[17:02:33.304]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.304]         }, condition = base::local({
[17:02:33.304]             c <- base::c
[17:02:33.304]             inherits <- base::inherits
[17:02:33.304]             invokeRestart <- base::invokeRestart
[17:02:33.304]             length <- base::length
[17:02:33.304]             list <- base::list
[17:02:33.304]             seq.int <- base::seq.int
[17:02:33.304]             signalCondition <- base::signalCondition
[17:02:33.304]             sys.calls <- base::sys.calls
[17:02:33.304]             `[[` <- base::`[[`
[17:02:33.304]             `+` <- base::`+`
[17:02:33.304]             `<<-` <- base::`<<-`
[17:02:33.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.304]                   3L)]
[17:02:33.304]             }
[17:02:33.304]             function(cond) {
[17:02:33.304]                 is_error <- inherits(cond, "error")
[17:02:33.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.304]                   NULL)
[17:02:33.304]                 if (is_error) {
[17:02:33.304]                   sessionInformation <- function() {
[17:02:33.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.304]                       search = base::search(), system = base::Sys.info())
[17:02:33.304]                   }
[17:02:33.304]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.304]                     cond$call), session = sessionInformation(), 
[17:02:33.304]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.304]                   signalCondition(cond)
[17:02:33.304]                 }
[17:02:33.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.304]                 "immediateCondition"))) {
[17:02:33.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.304]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.304]                   if (TRUE && !signal) {
[17:02:33.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.304]                     {
[17:02:33.304]                       inherits <- base::inherits
[17:02:33.304]                       invokeRestart <- base::invokeRestart
[17:02:33.304]                       is.null <- base::is.null
[17:02:33.304]                       muffled <- FALSE
[17:02:33.304]                       if (inherits(cond, "message")) {
[17:02:33.304]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.304]                         if (muffled) 
[17:02:33.304]                           invokeRestart("muffleMessage")
[17:02:33.304]                       }
[17:02:33.304]                       else if (inherits(cond, "warning")) {
[17:02:33.304]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.304]                         if (muffled) 
[17:02:33.304]                           invokeRestart("muffleWarning")
[17:02:33.304]                       }
[17:02:33.304]                       else if (inherits(cond, "condition")) {
[17:02:33.304]                         if (!is.null(pattern)) {
[17:02:33.304]                           computeRestarts <- base::computeRestarts
[17:02:33.304]                           grepl <- base::grepl
[17:02:33.304]                           restarts <- computeRestarts(cond)
[17:02:33.304]                           for (restart in restarts) {
[17:02:33.304]                             name <- restart$name
[17:02:33.304]                             if (is.null(name)) 
[17:02:33.304]                               next
[17:02:33.304]                             if (!grepl(pattern, name)) 
[17:02:33.304]                               next
[17:02:33.304]                             invokeRestart(restart)
[17:02:33.304]                             muffled <- TRUE
[17:02:33.304]                             break
[17:02:33.304]                           }
[17:02:33.304]                         }
[17:02:33.304]                       }
[17:02:33.304]                       invisible(muffled)
[17:02:33.304]                     }
[17:02:33.304]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.304]                   }
[17:02:33.304]                 }
[17:02:33.304]                 else {
[17:02:33.304]                   if (TRUE) {
[17:02:33.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.304]                     {
[17:02:33.304]                       inherits <- base::inherits
[17:02:33.304]                       invokeRestart <- base::invokeRestart
[17:02:33.304]                       is.null <- base::is.null
[17:02:33.304]                       muffled <- FALSE
[17:02:33.304]                       if (inherits(cond, "message")) {
[17:02:33.304]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.304]                         if (muffled) 
[17:02:33.304]                           invokeRestart("muffleMessage")
[17:02:33.304]                       }
[17:02:33.304]                       else if (inherits(cond, "warning")) {
[17:02:33.304]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.304]                         if (muffled) 
[17:02:33.304]                           invokeRestart("muffleWarning")
[17:02:33.304]                       }
[17:02:33.304]                       else if (inherits(cond, "condition")) {
[17:02:33.304]                         if (!is.null(pattern)) {
[17:02:33.304]                           computeRestarts <- base::computeRestarts
[17:02:33.304]                           grepl <- base::grepl
[17:02:33.304]                           restarts <- computeRestarts(cond)
[17:02:33.304]                           for (restart in restarts) {
[17:02:33.304]                             name <- restart$name
[17:02:33.304]                             if (is.null(name)) 
[17:02:33.304]                               next
[17:02:33.304]                             if (!grepl(pattern, name)) 
[17:02:33.304]                               next
[17:02:33.304]                             invokeRestart(restart)
[17:02:33.304]                             muffled <- TRUE
[17:02:33.304]                             break
[17:02:33.304]                           }
[17:02:33.304]                         }
[17:02:33.304]                       }
[17:02:33.304]                       invisible(muffled)
[17:02:33.304]                     }
[17:02:33.304]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.304]                   }
[17:02:33.304]                 }
[17:02:33.304]             }
[17:02:33.304]         }))
[17:02:33.304]     }, error = function(ex) {
[17:02:33.304]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.304]                 ...future.rng), started = ...future.startTime, 
[17:02:33.304]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.304]             version = "1.8"), class = "FutureResult")
[17:02:33.304]     }, finally = {
[17:02:33.304]         if (!identical(...future.workdir, getwd())) 
[17:02:33.304]             setwd(...future.workdir)
[17:02:33.304]         {
[17:02:33.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.304]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.304]             }
[17:02:33.304]             base::options(...future.oldOptions)
[17:02:33.304]             if (.Platform$OS.type == "windows") {
[17:02:33.304]                 old_names <- names(...future.oldEnvVars)
[17:02:33.304]                 envs <- base::Sys.getenv()
[17:02:33.304]                 names <- names(envs)
[17:02:33.304]                 common <- intersect(names, old_names)
[17:02:33.304]                 added <- setdiff(names, old_names)
[17:02:33.304]                 removed <- setdiff(old_names, names)
[17:02:33.304]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.304]                   envs[common]]
[17:02:33.304]                 NAMES <- toupper(changed)
[17:02:33.304]                 args <- list()
[17:02:33.304]                 for (kk in seq_along(NAMES)) {
[17:02:33.304]                   name <- changed[[kk]]
[17:02:33.304]                   NAME <- NAMES[[kk]]
[17:02:33.304]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.304]                     next
[17:02:33.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.304]                 }
[17:02:33.304]                 NAMES <- toupper(added)
[17:02:33.304]                 for (kk in seq_along(NAMES)) {
[17:02:33.304]                   name <- added[[kk]]
[17:02:33.304]                   NAME <- NAMES[[kk]]
[17:02:33.304]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.304]                     next
[17:02:33.304]                   args[[name]] <- ""
[17:02:33.304]                 }
[17:02:33.304]                 NAMES <- toupper(removed)
[17:02:33.304]                 for (kk in seq_along(NAMES)) {
[17:02:33.304]                   name <- removed[[kk]]
[17:02:33.304]                   NAME <- NAMES[[kk]]
[17:02:33.304]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.304]                     next
[17:02:33.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.304]                 }
[17:02:33.304]                 if (length(args) > 0) 
[17:02:33.304]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.304]             }
[17:02:33.304]             else {
[17:02:33.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.304]             }
[17:02:33.304]             {
[17:02:33.304]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.304]                   0L) {
[17:02:33.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.304]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.304]                   base::options(opts)
[17:02:33.304]                 }
[17:02:33.304]                 {
[17:02:33.304]                   {
[17:02:33.304]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.304]                     NULL
[17:02:33.304]                   }
[17:02:33.304]                   options(future.plan = NULL)
[17:02:33.304]                   if (is.na(NA_character_)) 
[17:02:33.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.304]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.304]                     .init = FALSE)
[17:02:33.304]                 }
[17:02:33.304]             }
[17:02:33.304]         }
[17:02:33.304]     })
[17:02:33.304]     if (TRUE) {
[17:02:33.304]         base::sink(type = "output", split = FALSE)
[17:02:33.304]         if (TRUE) {
[17:02:33.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.304]         }
[17:02:33.304]         else {
[17:02:33.304]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.304]         }
[17:02:33.304]         base::close(...future.stdout)
[17:02:33.304]         ...future.stdout <- NULL
[17:02:33.304]     }
[17:02:33.304]     ...future.result$conditions <- ...future.conditions
[17:02:33.304]     ...future.result$finished <- base::Sys.time()
[17:02:33.304]     ...future.result
[17:02:33.304] }
[17:02:33.308] MultisessionFuture started
[17:02:33.308] - Launch lazy future ... done
[17:02:33.308] run() for ‘MultisessionFuture’ ... done
[17:02:33.308] getGlobalsAndPackages() ...
[17:02:33.308] Searching for globals...
[17:02:33.309] 
[17:02:33.309] Searching for globals ... DONE
[17:02:33.309] - globals: [0] <none>
[17:02:33.309] getGlobalsAndPackages() ... DONE
[17:02:33.310] run() for ‘Future’ ...
[17:02:33.310] - state: ‘created’
[17:02:33.310] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.324] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.324] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.325]   - Field: ‘node’
[17:02:33.325]   - Field: ‘label’
[17:02:33.325]   - Field: ‘local’
[17:02:33.325]   - Field: ‘owner’
[17:02:33.325]   - Field: ‘envir’
[17:02:33.325]   - Field: ‘workers’
[17:02:33.325]   - Field: ‘packages’
[17:02:33.325]   - Field: ‘gc’
[17:02:33.325]   - Field: ‘conditions’
[17:02:33.325]   - Field: ‘persistent’
[17:02:33.326]   - Field: ‘expr’
[17:02:33.326]   - Field: ‘uuid’
[17:02:33.326]   - Field: ‘seed’
[17:02:33.326]   - Field: ‘version’
[17:02:33.326]   - Field: ‘result’
[17:02:33.326]   - Field: ‘asynchronous’
[17:02:33.326]   - Field: ‘calls’
[17:02:33.326]   - Field: ‘globals’
[17:02:33.326]   - Field: ‘stdout’
[17:02:33.326]   - Field: ‘earlySignal’
[17:02:33.326]   - Field: ‘lazy’
[17:02:33.327]   - Field: ‘state’
[17:02:33.327] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.327] - Launch lazy future ...
[17:02:33.327] Packages needed by the future expression (n = 0): <none>
[17:02:33.327] Packages needed by future strategies (n = 0): <none>
[17:02:33.328] {
[17:02:33.328]     {
[17:02:33.328]         {
[17:02:33.328]             ...future.startTime <- base::Sys.time()
[17:02:33.328]             {
[17:02:33.328]                 {
[17:02:33.328]                   {
[17:02:33.328]                     {
[17:02:33.328]                       base::local({
[17:02:33.328]                         has_future <- base::requireNamespace("future", 
[17:02:33.328]                           quietly = TRUE)
[17:02:33.328]                         if (has_future) {
[17:02:33.328]                           ns <- base::getNamespace("future")
[17:02:33.328]                           version <- ns[[".package"]][["version"]]
[17:02:33.328]                           if (is.null(version)) 
[17:02:33.328]                             version <- utils::packageVersion("future")
[17:02:33.328]                         }
[17:02:33.328]                         else {
[17:02:33.328]                           version <- NULL
[17:02:33.328]                         }
[17:02:33.328]                         if (!has_future || version < "1.8.0") {
[17:02:33.328]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.328]                             "", base::R.version$version.string), 
[17:02:33.328]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.328]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.328]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.328]                               "release", "version")], collapse = " "), 
[17:02:33.328]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.328]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.328]                             info)
[17:02:33.328]                           info <- base::paste(info, collapse = "; ")
[17:02:33.328]                           if (!has_future) {
[17:02:33.328]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.328]                               info)
[17:02:33.328]                           }
[17:02:33.328]                           else {
[17:02:33.328]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.328]                               info, version)
[17:02:33.328]                           }
[17:02:33.328]                           base::stop(msg)
[17:02:33.328]                         }
[17:02:33.328]                       })
[17:02:33.328]                     }
[17:02:33.328]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.328]                     base::options(mc.cores = 1L)
[17:02:33.328]                   }
[17:02:33.328]                   ...future.strategy.old <- future::plan("list")
[17:02:33.328]                   options(future.plan = NULL)
[17:02:33.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.328]                 }
[17:02:33.328]                 ...future.workdir <- getwd()
[17:02:33.328]             }
[17:02:33.328]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.328]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.328]         }
[17:02:33.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.328]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.328]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.328]             base::names(...future.oldOptions))
[17:02:33.328]     }
[17:02:33.328]     if (FALSE) {
[17:02:33.328]     }
[17:02:33.328]     else {
[17:02:33.328]         if (TRUE) {
[17:02:33.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.328]                 open = "w")
[17:02:33.328]         }
[17:02:33.328]         else {
[17:02:33.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.328]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.328]         }
[17:02:33.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.328]             base::sink(type = "output", split = FALSE)
[17:02:33.328]             base::close(...future.stdout)
[17:02:33.328]         }, add = TRUE)
[17:02:33.328]     }
[17:02:33.328]     ...future.frame <- base::sys.nframe()
[17:02:33.328]     ...future.conditions <- base::list()
[17:02:33.328]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.328]     if (FALSE) {
[17:02:33.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.328]     }
[17:02:33.328]     ...future.result <- base::tryCatch({
[17:02:33.328]         base::withCallingHandlers({
[17:02:33.328]             ...future.value <- base::withVisible(base::local({
[17:02:33.328]                 ...future.makeSendCondition <- base::local({
[17:02:33.328]                   sendCondition <- NULL
[17:02:33.328]                   function(frame = 1L) {
[17:02:33.328]                     if (is.function(sendCondition)) 
[17:02:33.328]                       return(sendCondition)
[17:02:33.328]                     ns <- getNamespace("parallel")
[17:02:33.328]                     if (exists("sendData", mode = "function", 
[17:02:33.328]                       envir = ns)) {
[17:02:33.328]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.328]                         envir = ns)
[17:02:33.328]                       envir <- sys.frame(frame)
[17:02:33.328]                       master <- NULL
[17:02:33.328]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.328]                         !identical(envir, emptyenv())) {
[17:02:33.328]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.328]                           inherits = FALSE)) {
[17:02:33.328]                           master <- get("master", mode = "list", 
[17:02:33.328]                             envir = envir, inherits = FALSE)
[17:02:33.328]                           if (inherits(master, c("SOCKnode", 
[17:02:33.328]                             "SOCK0node"))) {
[17:02:33.328]                             sendCondition <<- function(cond) {
[17:02:33.328]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.328]                                 success = TRUE)
[17:02:33.328]                               parallel_sendData(master, data)
[17:02:33.328]                             }
[17:02:33.328]                             return(sendCondition)
[17:02:33.328]                           }
[17:02:33.328]                         }
[17:02:33.328]                         frame <- frame + 1L
[17:02:33.328]                         envir <- sys.frame(frame)
[17:02:33.328]                       }
[17:02:33.328]                     }
[17:02:33.328]                     sendCondition <<- function(cond) NULL
[17:02:33.328]                   }
[17:02:33.328]                 })
[17:02:33.328]                 withCallingHandlers({
[17:02:33.328]                   NULL
[17:02:33.328]                 }, immediateCondition = function(cond) {
[17:02:33.328]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.328]                   sendCondition(cond)
[17:02:33.328]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.328]                   {
[17:02:33.328]                     inherits <- base::inherits
[17:02:33.328]                     invokeRestart <- base::invokeRestart
[17:02:33.328]                     is.null <- base::is.null
[17:02:33.328]                     muffled <- FALSE
[17:02:33.328]                     if (inherits(cond, "message")) {
[17:02:33.328]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.328]                       if (muffled) 
[17:02:33.328]                         invokeRestart("muffleMessage")
[17:02:33.328]                     }
[17:02:33.328]                     else if (inherits(cond, "warning")) {
[17:02:33.328]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.328]                       if (muffled) 
[17:02:33.328]                         invokeRestart("muffleWarning")
[17:02:33.328]                     }
[17:02:33.328]                     else if (inherits(cond, "condition")) {
[17:02:33.328]                       if (!is.null(pattern)) {
[17:02:33.328]                         computeRestarts <- base::computeRestarts
[17:02:33.328]                         grepl <- base::grepl
[17:02:33.328]                         restarts <- computeRestarts(cond)
[17:02:33.328]                         for (restart in restarts) {
[17:02:33.328]                           name <- restart$name
[17:02:33.328]                           if (is.null(name)) 
[17:02:33.328]                             next
[17:02:33.328]                           if (!grepl(pattern, name)) 
[17:02:33.328]                             next
[17:02:33.328]                           invokeRestart(restart)
[17:02:33.328]                           muffled <- TRUE
[17:02:33.328]                           break
[17:02:33.328]                         }
[17:02:33.328]                       }
[17:02:33.328]                     }
[17:02:33.328]                     invisible(muffled)
[17:02:33.328]                   }
[17:02:33.328]                   muffleCondition(cond)
[17:02:33.328]                 })
[17:02:33.328]             }))
[17:02:33.328]             future::FutureResult(value = ...future.value$value, 
[17:02:33.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.328]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.328]                     ...future.globalenv.names))
[17:02:33.328]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.328]         }, condition = base::local({
[17:02:33.328]             c <- base::c
[17:02:33.328]             inherits <- base::inherits
[17:02:33.328]             invokeRestart <- base::invokeRestart
[17:02:33.328]             length <- base::length
[17:02:33.328]             list <- base::list
[17:02:33.328]             seq.int <- base::seq.int
[17:02:33.328]             signalCondition <- base::signalCondition
[17:02:33.328]             sys.calls <- base::sys.calls
[17:02:33.328]             `[[` <- base::`[[`
[17:02:33.328]             `+` <- base::`+`
[17:02:33.328]             `<<-` <- base::`<<-`
[17:02:33.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.328]                   3L)]
[17:02:33.328]             }
[17:02:33.328]             function(cond) {
[17:02:33.328]                 is_error <- inherits(cond, "error")
[17:02:33.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.328]                   NULL)
[17:02:33.328]                 if (is_error) {
[17:02:33.328]                   sessionInformation <- function() {
[17:02:33.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.328]                       search = base::search(), system = base::Sys.info())
[17:02:33.328]                   }
[17:02:33.328]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.328]                     cond$call), session = sessionInformation(), 
[17:02:33.328]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.328]                   signalCondition(cond)
[17:02:33.328]                 }
[17:02:33.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.328]                 "immediateCondition"))) {
[17:02:33.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.328]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.328]                   if (TRUE && !signal) {
[17:02:33.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.328]                     {
[17:02:33.328]                       inherits <- base::inherits
[17:02:33.328]                       invokeRestart <- base::invokeRestart
[17:02:33.328]                       is.null <- base::is.null
[17:02:33.328]                       muffled <- FALSE
[17:02:33.328]                       if (inherits(cond, "message")) {
[17:02:33.328]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.328]                         if (muffled) 
[17:02:33.328]                           invokeRestart("muffleMessage")
[17:02:33.328]                       }
[17:02:33.328]                       else if (inherits(cond, "warning")) {
[17:02:33.328]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.328]                         if (muffled) 
[17:02:33.328]                           invokeRestart("muffleWarning")
[17:02:33.328]                       }
[17:02:33.328]                       else if (inherits(cond, "condition")) {
[17:02:33.328]                         if (!is.null(pattern)) {
[17:02:33.328]                           computeRestarts <- base::computeRestarts
[17:02:33.328]                           grepl <- base::grepl
[17:02:33.328]                           restarts <- computeRestarts(cond)
[17:02:33.328]                           for (restart in restarts) {
[17:02:33.328]                             name <- restart$name
[17:02:33.328]                             if (is.null(name)) 
[17:02:33.328]                               next
[17:02:33.328]                             if (!grepl(pattern, name)) 
[17:02:33.328]                               next
[17:02:33.328]                             invokeRestart(restart)
[17:02:33.328]                             muffled <- TRUE
[17:02:33.328]                             break
[17:02:33.328]                           }
[17:02:33.328]                         }
[17:02:33.328]                       }
[17:02:33.328]                       invisible(muffled)
[17:02:33.328]                     }
[17:02:33.328]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.328]                   }
[17:02:33.328]                 }
[17:02:33.328]                 else {
[17:02:33.328]                   if (TRUE) {
[17:02:33.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.328]                     {
[17:02:33.328]                       inherits <- base::inherits
[17:02:33.328]                       invokeRestart <- base::invokeRestart
[17:02:33.328]                       is.null <- base::is.null
[17:02:33.328]                       muffled <- FALSE
[17:02:33.328]                       if (inherits(cond, "message")) {
[17:02:33.328]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.328]                         if (muffled) 
[17:02:33.328]                           invokeRestart("muffleMessage")
[17:02:33.328]                       }
[17:02:33.328]                       else if (inherits(cond, "warning")) {
[17:02:33.328]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.328]                         if (muffled) 
[17:02:33.328]                           invokeRestart("muffleWarning")
[17:02:33.328]                       }
[17:02:33.328]                       else if (inherits(cond, "condition")) {
[17:02:33.328]                         if (!is.null(pattern)) {
[17:02:33.328]                           computeRestarts <- base::computeRestarts
[17:02:33.328]                           grepl <- base::grepl
[17:02:33.328]                           restarts <- computeRestarts(cond)
[17:02:33.328]                           for (restart in restarts) {
[17:02:33.328]                             name <- restart$name
[17:02:33.328]                             if (is.null(name)) 
[17:02:33.328]                               next
[17:02:33.328]                             if (!grepl(pattern, name)) 
[17:02:33.328]                               next
[17:02:33.328]                             invokeRestart(restart)
[17:02:33.328]                             muffled <- TRUE
[17:02:33.328]                             break
[17:02:33.328]                           }
[17:02:33.328]                         }
[17:02:33.328]                       }
[17:02:33.328]                       invisible(muffled)
[17:02:33.328]                     }
[17:02:33.328]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.328]                   }
[17:02:33.328]                 }
[17:02:33.328]             }
[17:02:33.328]         }))
[17:02:33.328]     }, error = function(ex) {
[17:02:33.328]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.328]                 ...future.rng), started = ...future.startTime, 
[17:02:33.328]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.328]             version = "1.8"), class = "FutureResult")
[17:02:33.328]     }, finally = {
[17:02:33.328]         if (!identical(...future.workdir, getwd())) 
[17:02:33.328]             setwd(...future.workdir)
[17:02:33.328]         {
[17:02:33.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.328]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.328]             }
[17:02:33.328]             base::options(...future.oldOptions)
[17:02:33.328]             if (.Platform$OS.type == "windows") {
[17:02:33.328]                 old_names <- names(...future.oldEnvVars)
[17:02:33.328]                 envs <- base::Sys.getenv()
[17:02:33.328]                 names <- names(envs)
[17:02:33.328]                 common <- intersect(names, old_names)
[17:02:33.328]                 added <- setdiff(names, old_names)
[17:02:33.328]                 removed <- setdiff(old_names, names)
[17:02:33.328]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.328]                   envs[common]]
[17:02:33.328]                 NAMES <- toupper(changed)
[17:02:33.328]                 args <- list()
[17:02:33.328]                 for (kk in seq_along(NAMES)) {
[17:02:33.328]                   name <- changed[[kk]]
[17:02:33.328]                   NAME <- NAMES[[kk]]
[17:02:33.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.328]                     next
[17:02:33.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.328]                 }
[17:02:33.328]                 NAMES <- toupper(added)
[17:02:33.328]                 for (kk in seq_along(NAMES)) {
[17:02:33.328]                   name <- added[[kk]]
[17:02:33.328]                   NAME <- NAMES[[kk]]
[17:02:33.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.328]                     next
[17:02:33.328]                   args[[name]] <- ""
[17:02:33.328]                 }
[17:02:33.328]                 NAMES <- toupper(removed)
[17:02:33.328]                 for (kk in seq_along(NAMES)) {
[17:02:33.328]                   name <- removed[[kk]]
[17:02:33.328]                   NAME <- NAMES[[kk]]
[17:02:33.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.328]                     next
[17:02:33.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.328]                 }
[17:02:33.328]                 if (length(args) > 0) 
[17:02:33.328]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.328]             }
[17:02:33.328]             else {
[17:02:33.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.328]             }
[17:02:33.328]             {
[17:02:33.328]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.328]                   0L) {
[17:02:33.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.328]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.328]                   base::options(opts)
[17:02:33.328]                 }
[17:02:33.328]                 {
[17:02:33.328]                   {
[17:02:33.328]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.328]                     NULL
[17:02:33.328]                   }
[17:02:33.328]                   options(future.plan = NULL)
[17:02:33.328]                   if (is.na(NA_character_)) 
[17:02:33.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.328]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.328]                     .init = FALSE)
[17:02:33.328]                 }
[17:02:33.328]             }
[17:02:33.328]         }
[17:02:33.328]     })
[17:02:33.328]     if (TRUE) {
[17:02:33.328]         base::sink(type = "output", split = FALSE)
[17:02:33.328]         if (TRUE) {
[17:02:33.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.328]         }
[17:02:33.328]         else {
[17:02:33.328]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.328]         }
[17:02:33.328]         base::close(...future.stdout)
[17:02:33.328]         ...future.stdout <- NULL
[17:02:33.328]     }
[17:02:33.328]     ...future.result$conditions <- ...future.conditions
[17:02:33.328]     ...future.result$finished <- base::Sys.time()
[17:02:33.328]     ...future.result
[17:02:33.328] }
[17:02:33.331] MultisessionFuture started
[17:02:33.331] - Launch lazy future ... done
[17:02:33.331] run() for ‘MultisessionFuture’ ... done
[17:02:33.331] getGlobalsAndPackages() ...
[17:02:33.331] Searching for globals...
[17:02:33.332] - globals found: [1] ‘{’
[17:02:33.332] Searching for globals ... DONE
[17:02:33.332] Resolving globals: FALSE
[17:02:33.333] 
[17:02:33.333] 
[17:02:33.333] getGlobalsAndPackages() ... DONE
[17:02:33.333] run() for ‘Future’ ...
[17:02:33.333] - state: ‘created’
[17:02:33.333] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.347] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.347] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.348]   - Field: ‘node’
[17:02:33.348]   - Field: ‘label’
[17:02:33.348]   - Field: ‘local’
[17:02:33.348]   - Field: ‘owner’
[17:02:33.348]   - Field: ‘envir’
[17:02:33.348]   - Field: ‘workers’
[17:02:33.348]   - Field: ‘packages’
[17:02:33.348]   - Field: ‘gc’
[17:02:33.348]   - Field: ‘conditions’
[17:02:33.348]   - Field: ‘persistent’
[17:02:33.349]   - Field: ‘expr’
[17:02:33.349]   - Field: ‘uuid’
[17:02:33.349]   - Field: ‘seed’
[17:02:33.349]   - Field: ‘version’
[17:02:33.349]   - Field: ‘result’
[17:02:33.349]   - Field: ‘asynchronous’
[17:02:33.349]   - Field: ‘calls’
[17:02:33.349]   - Field: ‘globals’
[17:02:33.349]   - Field: ‘stdout’
[17:02:33.349]   - Field: ‘earlySignal’
[17:02:33.349]   - Field: ‘lazy’
[17:02:33.350]   - Field: ‘state’
[17:02:33.350] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.350] - Launch lazy future ...
[17:02:33.350] Packages needed by the future expression (n = 0): <none>
[17:02:33.350] Packages needed by future strategies (n = 0): <none>
[17:02:33.351] {
[17:02:33.351]     {
[17:02:33.351]         {
[17:02:33.351]             ...future.startTime <- base::Sys.time()
[17:02:33.351]             {
[17:02:33.351]                 {
[17:02:33.351]                   {
[17:02:33.351]                     {
[17:02:33.351]                       base::local({
[17:02:33.351]                         has_future <- base::requireNamespace("future", 
[17:02:33.351]                           quietly = TRUE)
[17:02:33.351]                         if (has_future) {
[17:02:33.351]                           ns <- base::getNamespace("future")
[17:02:33.351]                           version <- ns[[".package"]][["version"]]
[17:02:33.351]                           if (is.null(version)) 
[17:02:33.351]                             version <- utils::packageVersion("future")
[17:02:33.351]                         }
[17:02:33.351]                         else {
[17:02:33.351]                           version <- NULL
[17:02:33.351]                         }
[17:02:33.351]                         if (!has_future || version < "1.8.0") {
[17:02:33.351]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.351]                             "", base::R.version$version.string), 
[17:02:33.351]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.351]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.351]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.351]                               "release", "version")], collapse = " "), 
[17:02:33.351]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.351]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.351]                             info)
[17:02:33.351]                           info <- base::paste(info, collapse = "; ")
[17:02:33.351]                           if (!has_future) {
[17:02:33.351]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.351]                               info)
[17:02:33.351]                           }
[17:02:33.351]                           else {
[17:02:33.351]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.351]                               info, version)
[17:02:33.351]                           }
[17:02:33.351]                           base::stop(msg)
[17:02:33.351]                         }
[17:02:33.351]                       })
[17:02:33.351]                     }
[17:02:33.351]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.351]                     base::options(mc.cores = 1L)
[17:02:33.351]                   }
[17:02:33.351]                   ...future.strategy.old <- future::plan("list")
[17:02:33.351]                   options(future.plan = NULL)
[17:02:33.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.351]                 }
[17:02:33.351]                 ...future.workdir <- getwd()
[17:02:33.351]             }
[17:02:33.351]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.351]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.351]         }
[17:02:33.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.351]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.351]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.351]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.351]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.351]             base::names(...future.oldOptions))
[17:02:33.351]     }
[17:02:33.351]     if (FALSE) {
[17:02:33.351]     }
[17:02:33.351]     else {
[17:02:33.351]         if (TRUE) {
[17:02:33.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.351]                 open = "w")
[17:02:33.351]         }
[17:02:33.351]         else {
[17:02:33.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.351]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.351]         }
[17:02:33.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.351]             base::sink(type = "output", split = FALSE)
[17:02:33.351]             base::close(...future.stdout)
[17:02:33.351]         }, add = TRUE)
[17:02:33.351]     }
[17:02:33.351]     ...future.frame <- base::sys.nframe()
[17:02:33.351]     ...future.conditions <- base::list()
[17:02:33.351]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.351]     if (FALSE) {
[17:02:33.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.351]     }
[17:02:33.351]     ...future.result <- base::tryCatch({
[17:02:33.351]         base::withCallingHandlers({
[17:02:33.351]             ...future.value <- base::withVisible(base::local({
[17:02:33.351]                 ...future.makeSendCondition <- base::local({
[17:02:33.351]                   sendCondition <- NULL
[17:02:33.351]                   function(frame = 1L) {
[17:02:33.351]                     if (is.function(sendCondition)) 
[17:02:33.351]                       return(sendCondition)
[17:02:33.351]                     ns <- getNamespace("parallel")
[17:02:33.351]                     if (exists("sendData", mode = "function", 
[17:02:33.351]                       envir = ns)) {
[17:02:33.351]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.351]                         envir = ns)
[17:02:33.351]                       envir <- sys.frame(frame)
[17:02:33.351]                       master <- NULL
[17:02:33.351]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.351]                         !identical(envir, emptyenv())) {
[17:02:33.351]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.351]                           inherits = FALSE)) {
[17:02:33.351]                           master <- get("master", mode = "list", 
[17:02:33.351]                             envir = envir, inherits = FALSE)
[17:02:33.351]                           if (inherits(master, c("SOCKnode", 
[17:02:33.351]                             "SOCK0node"))) {
[17:02:33.351]                             sendCondition <<- function(cond) {
[17:02:33.351]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.351]                                 success = TRUE)
[17:02:33.351]                               parallel_sendData(master, data)
[17:02:33.351]                             }
[17:02:33.351]                             return(sendCondition)
[17:02:33.351]                           }
[17:02:33.351]                         }
[17:02:33.351]                         frame <- frame + 1L
[17:02:33.351]                         envir <- sys.frame(frame)
[17:02:33.351]                       }
[17:02:33.351]                     }
[17:02:33.351]                     sendCondition <<- function(cond) NULL
[17:02:33.351]                   }
[17:02:33.351]                 })
[17:02:33.351]                 withCallingHandlers({
[17:02:33.351]                   {
[17:02:33.351]                     4
[17:02:33.351]                   }
[17:02:33.351]                 }, immediateCondition = function(cond) {
[17:02:33.351]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.351]                   sendCondition(cond)
[17:02:33.351]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.351]                   {
[17:02:33.351]                     inherits <- base::inherits
[17:02:33.351]                     invokeRestart <- base::invokeRestart
[17:02:33.351]                     is.null <- base::is.null
[17:02:33.351]                     muffled <- FALSE
[17:02:33.351]                     if (inherits(cond, "message")) {
[17:02:33.351]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.351]                       if (muffled) 
[17:02:33.351]                         invokeRestart("muffleMessage")
[17:02:33.351]                     }
[17:02:33.351]                     else if (inherits(cond, "warning")) {
[17:02:33.351]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.351]                       if (muffled) 
[17:02:33.351]                         invokeRestart("muffleWarning")
[17:02:33.351]                     }
[17:02:33.351]                     else if (inherits(cond, "condition")) {
[17:02:33.351]                       if (!is.null(pattern)) {
[17:02:33.351]                         computeRestarts <- base::computeRestarts
[17:02:33.351]                         grepl <- base::grepl
[17:02:33.351]                         restarts <- computeRestarts(cond)
[17:02:33.351]                         for (restart in restarts) {
[17:02:33.351]                           name <- restart$name
[17:02:33.351]                           if (is.null(name)) 
[17:02:33.351]                             next
[17:02:33.351]                           if (!grepl(pattern, name)) 
[17:02:33.351]                             next
[17:02:33.351]                           invokeRestart(restart)
[17:02:33.351]                           muffled <- TRUE
[17:02:33.351]                           break
[17:02:33.351]                         }
[17:02:33.351]                       }
[17:02:33.351]                     }
[17:02:33.351]                     invisible(muffled)
[17:02:33.351]                   }
[17:02:33.351]                   muffleCondition(cond)
[17:02:33.351]                 })
[17:02:33.351]             }))
[17:02:33.351]             future::FutureResult(value = ...future.value$value, 
[17:02:33.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.351]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.351]                     ...future.globalenv.names))
[17:02:33.351]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.351]         }, condition = base::local({
[17:02:33.351]             c <- base::c
[17:02:33.351]             inherits <- base::inherits
[17:02:33.351]             invokeRestart <- base::invokeRestart
[17:02:33.351]             length <- base::length
[17:02:33.351]             list <- base::list
[17:02:33.351]             seq.int <- base::seq.int
[17:02:33.351]             signalCondition <- base::signalCondition
[17:02:33.351]             sys.calls <- base::sys.calls
[17:02:33.351]             `[[` <- base::`[[`
[17:02:33.351]             `+` <- base::`+`
[17:02:33.351]             `<<-` <- base::`<<-`
[17:02:33.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.351]                   3L)]
[17:02:33.351]             }
[17:02:33.351]             function(cond) {
[17:02:33.351]                 is_error <- inherits(cond, "error")
[17:02:33.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.351]                   NULL)
[17:02:33.351]                 if (is_error) {
[17:02:33.351]                   sessionInformation <- function() {
[17:02:33.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.351]                       search = base::search(), system = base::Sys.info())
[17:02:33.351]                   }
[17:02:33.351]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.351]                     cond$call), session = sessionInformation(), 
[17:02:33.351]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.351]                   signalCondition(cond)
[17:02:33.351]                 }
[17:02:33.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.351]                 "immediateCondition"))) {
[17:02:33.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.351]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.351]                   if (TRUE && !signal) {
[17:02:33.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.351]                     {
[17:02:33.351]                       inherits <- base::inherits
[17:02:33.351]                       invokeRestart <- base::invokeRestart
[17:02:33.351]                       is.null <- base::is.null
[17:02:33.351]                       muffled <- FALSE
[17:02:33.351]                       if (inherits(cond, "message")) {
[17:02:33.351]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.351]                         if (muffled) 
[17:02:33.351]                           invokeRestart("muffleMessage")
[17:02:33.351]                       }
[17:02:33.351]                       else if (inherits(cond, "warning")) {
[17:02:33.351]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.351]                         if (muffled) 
[17:02:33.351]                           invokeRestart("muffleWarning")
[17:02:33.351]                       }
[17:02:33.351]                       else if (inherits(cond, "condition")) {
[17:02:33.351]                         if (!is.null(pattern)) {
[17:02:33.351]                           computeRestarts <- base::computeRestarts
[17:02:33.351]                           grepl <- base::grepl
[17:02:33.351]                           restarts <- computeRestarts(cond)
[17:02:33.351]                           for (restart in restarts) {
[17:02:33.351]                             name <- restart$name
[17:02:33.351]                             if (is.null(name)) 
[17:02:33.351]                               next
[17:02:33.351]                             if (!grepl(pattern, name)) 
[17:02:33.351]                               next
[17:02:33.351]                             invokeRestart(restart)
[17:02:33.351]                             muffled <- TRUE
[17:02:33.351]                             break
[17:02:33.351]                           }
[17:02:33.351]                         }
[17:02:33.351]                       }
[17:02:33.351]                       invisible(muffled)
[17:02:33.351]                     }
[17:02:33.351]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.351]                   }
[17:02:33.351]                 }
[17:02:33.351]                 else {
[17:02:33.351]                   if (TRUE) {
[17:02:33.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.351]                     {
[17:02:33.351]                       inherits <- base::inherits
[17:02:33.351]                       invokeRestart <- base::invokeRestart
[17:02:33.351]                       is.null <- base::is.null
[17:02:33.351]                       muffled <- FALSE
[17:02:33.351]                       if (inherits(cond, "message")) {
[17:02:33.351]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.351]                         if (muffled) 
[17:02:33.351]                           invokeRestart("muffleMessage")
[17:02:33.351]                       }
[17:02:33.351]                       else if (inherits(cond, "warning")) {
[17:02:33.351]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.351]                         if (muffled) 
[17:02:33.351]                           invokeRestart("muffleWarning")
[17:02:33.351]                       }
[17:02:33.351]                       else if (inherits(cond, "condition")) {
[17:02:33.351]                         if (!is.null(pattern)) {
[17:02:33.351]                           computeRestarts <- base::computeRestarts
[17:02:33.351]                           grepl <- base::grepl
[17:02:33.351]                           restarts <- computeRestarts(cond)
[17:02:33.351]                           for (restart in restarts) {
[17:02:33.351]                             name <- restart$name
[17:02:33.351]                             if (is.null(name)) 
[17:02:33.351]                               next
[17:02:33.351]                             if (!grepl(pattern, name)) 
[17:02:33.351]                               next
[17:02:33.351]                             invokeRestart(restart)
[17:02:33.351]                             muffled <- TRUE
[17:02:33.351]                             break
[17:02:33.351]                           }
[17:02:33.351]                         }
[17:02:33.351]                       }
[17:02:33.351]                       invisible(muffled)
[17:02:33.351]                     }
[17:02:33.351]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.351]                   }
[17:02:33.351]                 }
[17:02:33.351]             }
[17:02:33.351]         }))
[17:02:33.351]     }, error = function(ex) {
[17:02:33.351]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.351]                 ...future.rng), started = ...future.startTime, 
[17:02:33.351]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.351]             version = "1.8"), class = "FutureResult")
[17:02:33.351]     }, finally = {
[17:02:33.351]         if (!identical(...future.workdir, getwd())) 
[17:02:33.351]             setwd(...future.workdir)
[17:02:33.351]         {
[17:02:33.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.351]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.351]             }
[17:02:33.351]             base::options(...future.oldOptions)
[17:02:33.351]             if (.Platform$OS.type == "windows") {
[17:02:33.351]                 old_names <- names(...future.oldEnvVars)
[17:02:33.351]                 envs <- base::Sys.getenv()
[17:02:33.351]                 names <- names(envs)
[17:02:33.351]                 common <- intersect(names, old_names)
[17:02:33.351]                 added <- setdiff(names, old_names)
[17:02:33.351]                 removed <- setdiff(old_names, names)
[17:02:33.351]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.351]                   envs[common]]
[17:02:33.351]                 NAMES <- toupper(changed)
[17:02:33.351]                 args <- list()
[17:02:33.351]                 for (kk in seq_along(NAMES)) {
[17:02:33.351]                   name <- changed[[kk]]
[17:02:33.351]                   NAME <- NAMES[[kk]]
[17:02:33.351]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.351]                     next
[17:02:33.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.351]                 }
[17:02:33.351]                 NAMES <- toupper(added)
[17:02:33.351]                 for (kk in seq_along(NAMES)) {
[17:02:33.351]                   name <- added[[kk]]
[17:02:33.351]                   NAME <- NAMES[[kk]]
[17:02:33.351]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.351]                     next
[17:02:33.351]                   args[[name]] <- ""
[17:02:33.351]                 }
[17:02:33.351]                 NAMES <- toupper(removed)
[17:02:33.351]                 for (kk in seq_along(NAMES)) {
[17:02:33.351]                   name <- removed[[kk]]
[17:02:33.351]                   NAME <- NAMES[[kk]]
[17:02:33.351]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.351]                     next
[17:02:33.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.351]                 }
[17:02:33.351]                 if (length(args) > 0) 
[17:02:33.351]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.351]             }
[17:02:33.351]             else {
[17:02:33.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.351]             }
[17:02:33.351]             {
[17:02:33.351]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.351]                   0L) {
[17:02:33.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.351]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.351]                   base::options(opts)
[17:02:33.351]                 }
[17:02:33.351]                 {
[17:02:33.351]                   {
[17:02:33.351]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.351]                     NULL
[17:02:33.351]                   }
[17:02:33.351]                   options(future.plan = NULL)
[17:02:33.351]                   if (is.na(NA_character_)) 
[17:02:33.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.351]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.351]                     .init = FALSE)
[17:02:33.351]                 }
[17:02:33.351]             }
[17:02:33.351]         }
[17:02:33.351]     })
[17:02:33.351]     if (TRUE) {
[17:02:33.351]         base::sink(type = "output", split = FALSE)
[17:02:33.351]         if (TRUE) {
[17:02:33.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.351]         }
[17:02:33.351]         else {
[17:02:33.351]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.351]         }
[17:02:33.351]         base::close(...future.stdout)
[17:02:33.351]         ...future.stdout <- NULL
[17:02:33.351]     }
[17:02:33.351]     ...future.result$conditions <- ...future.conditions
[17:02:33.351]     ...future.result$finished <- base::Sys.time()
[17:02:33.351]     ...future.result
[17:02:33.351] }
[17:02:33.353] Poll #1 (0): usedNodes() = 2, workers = 2
[17:02:33.364] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.364] - Validating connection of MultisessionFuture
[17:02:33.364] - received message: FutureResult
[17:02:33.364] - Received FutureResult
[17:02:33.364] - Erased future from FutureRegistry
[17:02:33.365] result() for ClusterFuture ...
[17:02:33.365] - result already collected: FutureResult
[17:02:33.365] result() for ClusterFuture ... done
[17:02:33.365] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:33.365] result() for ClusterFuture ...
[17:02:33.365] - result already collected: FutureResult
[17:02:33.365] result() for ClusterFuture ... done
[17:02:33.365] result() for ClusterFuture ...
[17:02:33.365] - result already collected: FutureResult
[17:02:33.365] result() for ClusterFuture ... done
[17:02:33.366] MultisessionFuture started
[17:02:33.366] - Launch lazy future ... done
[17:02:33.367] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c74a0f56b0> 
Classes 'listenv', 'environment' <environment: 0x55c74b3df2c0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:02:33.370] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.371] - Validating connection of MultisessionFuture
[17:02:33.371] - received message: FutureResult
[17:02:33.371] - Received FutureResult
[17:02:33.371] - Erased future from FutureRegistry
[17:02:33.371] result() for ClusterFuture ...
[17:02:33.371] - result already collected: FutureResult
[17:02:33.371] result() for ClusterFuture ... done
[17:02:33.371] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:33.372] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.372] - Validating connection of MultisessionFuture
[17:02:33.372] - received message: FutureResult
[17:02:33.372] - Received FutureResult
[17:02:33.372] - Erased future from FutureRegistry
[17:02:33.372] result() for ClusterFuture ...
[17:02:33.372] - result already collected: FutureResult
[17:02:33.373] result() for ClusterFuture ... done
[17:02:33.373] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:33.375] resolve() on list environment ...
[17:02:33.375]  recursive: 0
[17:02:33.379]  length: 6
[17:02:33.379]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:33.379] signalConditionsASAP(numeric, pos=1) ...
[17:02:33.379] - nx: 6
[17:02:33.379] - relay: TRUE
[17:02:33.379] - stdout: TRUE
[17:02:33.380] - signal: TRUE
[17:02:33.380] - resignal: FALSE
[17:02:33.380] - force: TRUE
[17:02:33.380] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.380] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.380]  - until=2
[17:02:33.380]  - relaying element #2
[17:02:33.380] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.380] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.380] signalConditionsASAP(NULL, pos=1) ... done
[17:02:33.380]  length: 5 (resolved future 1)
[17:02:33.381] Future #2
[17:02:33.381] result() for ClusterFuture ...
[17:02:33.381] - result already collected: FutureResult
[17:02:33.381] result() for ClusterFuture ... done
[17:02:33.381] result() for ClusterFuture ...
[17:02:33.381] - result already collected: FutureResult
[17:02:33.381] result() for ClusterFuture ... done
[17:02:33.381] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:33.381] - nx: 6
[17:02:33.381] - relay: TRUE
[17:02:33.381] - stdout: TRUE
[17:02:33.381] - signal: TRUE
[17:02:33.382] - resignal: FALSE
[17:02:33.382] - force: TRUE
[17:02:33.382] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.382] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.382]  - until=2
[17:02:33.382]  - relaying element #2
[17:02:33.382] result() for ClusterFuture ...
[17:02:33.382] - result already collected: FutureResult
[17:02:33.382] result() for ClusterFuture ... done
[17:02:33.382] result() for ClusterFuture ...
[17:02:33.382] - result already collected: FutureResult
[17:02:33.382] result() for ClusterFuture ... done
[17:02:33.383] result() for ClusterFuture ...
[17:02:33.383] - result already collected: FutureResult
[17:02:33.383] result() for ClusterFuture ... done
[17:02:33.383] result() for ClusterFuture ...
[17:02:33.383] - result already collected: FutureResult
[17:02:33.383] result() for ClusterFuture ... done
[17:02:33.383] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.383] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.383] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:33.383]  length: 4 (resolved future 2)
[17:02:33.384] Future #3
[17:02:33.384] result() for ClusterFuture ...
[17:02:33.384] - result already collected: FutureResult
[17:02:33.384] result() for ClusterFuture ... done
[17:02:33.384] result() for ClusterFuture ...
[17:02:33.384] - result already collected: FutureResult
[17:02:33.384] result() for ClusterFuture ... done
[17:02:33.384] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:33.384] - nx: 6
[17:02:33.384] - relay: TRUE
[17:02:33.384] - stdout: TRUE
[17:02:33.384] - signal: TRUE
[17:02:33.385] - resignal: FALSE
[17:02:33.385] - force: TRUE
[17:02:33.385] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.385] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.385]  - until=3
[17:02:33.385]  - relaying element #3
[17:02:33.385] result() for ClusterFuture ...
[17:02:33.385] - result already collected: FutureResult
[17:02:33.385] result() for ClusterFuture ... done
[17:02:33.385] result() for ClusterFuture ...
[17:02:33.385] - result already collected: FutureResult
[17:02:33.385] result() for ClusterFuture ... done
[17:02:33.386] result() for ClusterFuture ...
[17:02:33.386] - result already collected: FutureResult
[17:02:33.386] result() for ClusterFuture ... done
[17:02:33.386] result() for ClusterFuture ...
[17:02:33.386] - result already collected: FutureResult
[17:02:33.386] result() for ClusterFuture ... done
[17:02:33.386] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.386] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.386] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:33.386]  length: 3 (resolved future 3)
[17:02:33.386] Future #4
[17:02:33.386] result() for ClusterFuture ...
[17:02:33.387] - result already collected: FutureResult
[17:02:33.387] result() for ClusterFuture ... done
[17:02:33.387] result() for ClusterFuture ...
[17:02:33.387] - result already collected: FutureResult
[17:02:33.387] result() for ClusterFuture ... done
[17:02:33.387] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:02:33.387] - nx: 6
[17:02:33.387] - relay: TRUE
[17:02:33.387] - stdout: TRUE
[17:02:33.387] - signal: TRUE
[17:02:33.387] - resignal: FALSE
[17:02:33.388] - force: TRUE
[17:02:33.388] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.388] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.388]  - until=4
[17:02:33.388]  - relaying element #4
[17:02:33.388] result() for ClusterFuture ...
[17:02:33.388] - result already collected: FutureResult
[17:02:33.388] result() for ClusterFuture ... done
[17:02:33.388] result() for ClusterFuture ...
[17:02:33.388] - result already collected: FutureResult
[17:02:33.388] result() for ClusterFuture ... done
[17:02:33.388] result() for ClusterFuture ...
[17:02:33.389] - result already collected: FutureResult
[17:02:33.389] result() for ClusterFuture ... done
[17:02:33.389] result() for ClusterFuture ...
[17:02:33.389] - result already collected: FutureResult
[17:02:33.389] result() for ClusterFuture ... done
[17:02:33.389] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.389] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.389] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:02:33.389]  length: 2 (resolved future 4)
[17:02:33.389] signalConditionsASAP(NULL, pos=5) ...
[17:02:33.389] - nx: 6
[17:02:33.389] - relay: TRUE
[17:02:33.390] - stdout: TRUE
[17:02:33.390] - signal: TRUE
[17:02:33.390] - resignal: FALSE
[17:02:33.390] - force: TRUE
[17:02:33.390] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.390] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.390]  - until=6
[17:02:33.390]  - relaying element #6
[17:02:33.390] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:33.390] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.390] signalConditionsASAP(NULL, pos=5) ... done
[17:02:33.390]  length: 1 (resolved future 5)
[17:02:33.391] signalConditionsASAP(numeric, pos=6) ...
[17:02:33.391] - nx: 6
[17:02:33.391] - relay: TRUE
[17:02:33.391] - stdout: TRUE
[17:02:33.391] - signal: TRUE
[17:02:33.391] - resignal: FALSE
[17:02:33.391] - force: TRUE
[17:02:33.391] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:33.391] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.391]  - until=6
[17:02:33.391] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.391] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.392] signalConditionsASAP(numeric, pos=6) ... done
[17:02:33.392]  length: 0 (resolved future 6)
[17:02:33.392] Relaying remaining futures
[17:02:33.392] signalConditionsASAP(NULL, pos=0) ...
[17:02:33.392] - nx: 6
[17:02:33.392] - relay: TRUE
[17:02:33.392] - stdout: TRUE
[17:02:33.392] - signal: TRUE
[17:02:33.392] - resignal: FALSE
[17:02:33.392] - force: TRUE
[17:02:33.392] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.392] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:33.393] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.393] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.393] signalConditionsASAP(NULL, pos=0) ... done
[17:02:33.393] resolve() on list environment ... DONE
[17:02:33.393] result() for ClusterFuture ...
[17:02:33.393] - result already collected: FutureResult
[17:02:33.393] result() for ClusterFuture ... done
[17:02:33.393] result() for ClusterFuture ...
[17:02:33.393] - result already collected: FutureResult
[17:02:33.393] result() for ClusterFuture ... done
[17:02:33.394] result() for ClusterFuture ...
[17:02:33.394] - result already collected: FutureResult
[17:02:33.394] result() for ClusterFuture ... done
[17:02:33.394] result() for ClusterFuture ...
[17:02:33.394] - result already collected: FutureResult
[17:02:33.394] result() for ClusterFuture ... done
[17:02:33.394] result() for ClusterFuture ...
[17:02:33.394] - result already collected: FutureResult
[17:02:33.394] result() for ClusterFuture ... done
[17:02:33.394] result() for ClusterFuture ...
[17:02:33.394] - result already collected: FutureResult
[17:02:33.395] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c74b7223a0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:02:33.396] getGlobalsAndPackages() ...
[17:02:33.396] Searching for globals...
[17:02:33.397] 
[17:02:33.397] Searching for globals ... DONE
[17:02:33.397] - globals: [0] <none>
[17:02:33.397] getGlobalsAndPackages() ... DONE
[17:02:33.397] run() for ‘Future’ ...
[17:02:33.397] - state: ‘created’
[17:02:33.397] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.413] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.413] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.413]   - Field: ‘node’
[17:02:33.413]   - Field: ‘label’
[17:02:33.414]   - Field: ‘local’
[17:02:33.414]   - Field: ‘owner’
[17:02:33.414]   - Field: ‘envir’
[17:02:33.414]   - Field: ‘workers’
[17:02:33.414]   - Field: ‘packages’
[17:02:33.414]   - Field: ‘gc’
[17:02:33.414]   - Field: ‘conditions’
[17:02:33.414]   - Field: ‘persistent’
[17:02:33.414]   - Field: ‘expr’
[17:02:33.414]   - Field: ‘uuid’
[17:02:33.415]   - Field: ‘seed’
[17:02:33.415]   - Field: ‘version’
[17:02:33.415]   - Field: ‘result’
[17:02:33.415]   - Field: ‘asynchronous’
[17:02:33.415]   - Field: ‘calls’
[17:02:33.415]   - Field: ‘globals’
[17:02:33.415]   - Field: ‘stdout’
[17:02:33.415]   - Field: ‘earlySignal’
[17:02:33.415]   - Field: ‘lazy’
[17:02:33.415]   - Field: ‘state’
[17:02:33.415] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.416] - Launch lazy future ...
[17:02:33.416] Packages needed by the future expression (n = 0): <none>
[17:02:33.416] Packages needed by future strategies (n = 0): <none>
[17:02:33.416] {
[17:02:33.416]     {
[17:02:33.416]         {
[17:02:33.416]             ...future.startTime <- base::Sys.time()
[17:02:33.416]             {
[17:02:33.416]                 {
[17:02:33.416]                   {
[17:02:33.416]                     {
[17:02:33.416]                       base::local({
[17:02:33.416]                         has_future <- base::requireNamespace("future", 
[17:02:33.416]                           quietly = TRUE)
[17:02:33.416]                         if (has_future) {
[17:02:33.416]                           ns <- base::getNamespace("future")
[17:02:33.416]                           version <- ns[[".package"]][["version"]]
[17:02:33.416]                           if (is.null(version)) 
[17:02:33.416]                             version <- utils::packageVersion("future")
[17:02:33.416]                         }
[17:02:33.416]                         else {
[17:02:33.416]                           version <- NULL
[17:02:33.416]                         }
[17:02:33.416]                         if (!has_future || version < "1.8.0") {
[17:02:33.416]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.416]                             "", base::R.version$version.string), 
[17:02:33.416]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.416]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.416]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.416]                               "release", "version")], collapse = " "), 
[17:02:33.416]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.416]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.416]                             info)
[17:02:33.416]                           info <- base::paste(info, collapse = "; ")
[17:02:33.416]                           if (!has_future) {
[17:02:33.416]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.416]                               info)
[17:02:33.416]                           }
[17:02:33.416]                           else {
[17:02:33.416]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.416]                               info, version)
[17:02:33.416]                           }
[17:02:33.416]                           base::stop(msg)
[17:02:33.416]                         }
[17:02:33.416]                       })
[17:02:33.416]                     }
[17:02:33.416]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.416]                     base::options(mc.cores = 1L)
[17:02:33.416]                   }
[17:02:33.416]                   ...future.strategy.old <- future::plan("list")
[17:02:33.416]                   options(future.plan = NULL)
[17:02:33.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.416]                 }
[17:02:33.416]                 ...future.workdir <- getwd()
[17:02:33.416]             }
[17:02:33.416]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.416]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.416]         }
[17:02:33.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.416]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.416]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.416]             base::names(...future.oldOptions))
[17:02:33.416]     }
[17:02:33.416]     if (FALSE) {
[17:02:33.416]     }
[17:02:33.416]     else {
[17:02:33.416]         if (TRUE) {
[17:02:33.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.416]                 open = "w")
[17:02:33.416]         }
[17:02:33.416]         else {
[17:02:33.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.416]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.416]         }
[17:02:33.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.416]             base::sink(type = "output", split = FALSE)
[17:02:33.416]             base::close(...future.stdout)
[17:02:33.416]         }, add = TRUE)
[17:02:33.416]     }
[17:02:33.416]     ...future.frame <- base::sys.nframe()
[17:02:33.416]     ...future.conditions <- base::list()
[17:02:33.416]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.416]     if (FALSE) {
[17:02:33.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.416]     }
[17:02:33.416]     ...future.result <- base::tryCatch({
[17:02:33.416]         base::withCallingHandlers({
[17:02:33.416]             ...future.value <- base::withVisible(base::local({
[17:02:33.416]                 ...future.makeSendCondition <- base::local({
[17:02:33.416]                   sendCondition <- NULL
[17:02:33.416]                   function(frame = 1L) {
[17:02:33.416]                     if (is.function(sendCondition)) 
[17:02:33.416]                       return(sendCondition)
[17:02:33.416]                     ns <- getNamespace("parallel")
[17:02:33.416]                     if (exists("sendData", mode = "function", 
[17:02:33.416]                       envir = ns)) {
[17:02:33.416]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.416]                         envir = ns)
[17:02:33.416]                       envir <- sys.frame(frame)
[17:02:33.416]                       master <- NULL
[17:02:33.416]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.416]                         !identical(envir, emptyenv())) {
[17:02:33.416]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.416]                           inherits = FALSE)) {
[17:02:33.416]                           master <- get("master", mode = "list", 
[17:02:33.416]                             envir = envir, inherits = FALSE)
[17:02:33.416]                           if (inherits(master, c("SOCKnode", 
[17:02:33.416]                             "SOCK0node"))) {
[17:02:33.416]                             sendCondition <<- function(cond) {
[17:02:33.416]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.416]                                 success = TRUE)
[17:02:33.416]                               parallel_sendData(master, data)
[17:02:33.416]                             }
[17:02:33.416]                             return(sendCondition)
[17:02:33.416]                           }
[17:02:33.416]                         }
[17:02:33.416]                         frame <- frame + 1L
[17:02:33.416]                         envir <- sys.frame(frame)
[17:02:33.416]                       }
[17:02:33.416]                     }
[17:02:33.416]                     sendCondition <<- function(cond) NULL
[17:02:33.416]                   }
[17:02:33.416]                 })
[17:02:33.416]                 withCallingHandlers({
[17:02:33.416]                   2
[17:02:33.416]                 }, immediateCondition = function(cond) {
[17:02:33.416]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.416]                   sendCondition(cond)
[17:02:33.416]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.416]                   {
[17:02:33.416]                     inherits <- base::inherits
[17:02:33.416]                     invokeRestart <- base::invokeRestart
[17:02:33.416]                     is.null <- base::is.null
[17:02:33.416]                     muffled <- FALSE
[17:02:33.416]                     if (inherits(cond, "message")) {
[17:02:33.416]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.416]                       if (muffled) 
[17:02:33.416]                         invokeRestart("muffleMessage")
[17:02:33.416]                     }
[17:02:33.416]                     else if (inherits(cond, "warning")) {
[17:02:33.416]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.416]                       if (muffled) 
[17:02:33.416]                         invokeRestart("muffleWarning")
[17:02:33.416]                     }
[17:02:33.416]                     else if (inherits(cond, "condition")) {
[17:02:33.416]                       if (!is.null(pattern)) {
[17:02:33.416]                         computeRestarts <- base::computeRestarts
[17:02:33.416]                         grepl <- base::grepl
[17:02:33.416]                         restarts <- computeRestarts(cond)
[17:02:33.416]                         for (restart in restarts) {
[17:02:33.416]                           name <- restart$name
[17:02:33.416]                           if (is.null(name)) 
[17:02:33.416]                             next
[17:02:33.416]                           if (!grepl(pattern, name)) 
[17:02:33.416]                             next
[17:02:33.416]                           invokeRestart(restart)
[17:02:33.416]                           muffled <- TRUE
[17:02:33.416]                           break
[17:02:33.416]                         }
[17:02:33.416]                       }
[17:02:33.416]                     }
[17:02:33.416]                     invisible(muffled)
[17:02:33.416]                   }
[17:02:33.416]                   muffleCondition(cond)
[17:02:33.416]                 })
[17:02:33.416]             }))
[17:02:33.416]             future::FutureResult(value = ...future.value$value, 
[17:02:33.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.416]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.416]                     ...future.globalenv.names))
[17:02:33.416]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.416]         }, condition = base::local({
[17:02:33.416]             c <- base::c
[17:02:33.416]             inherits <- base::inherits
[17:02:33.416]             invokeRestart <- base::invokeRestart
[17:02:33.416]             length <- base::length
[17:02:33.416]             list <- base::list
[17:02:33.416]             seq.int <- base::seq.int
[17:02:33.416]             signalCondition <- base::signalCondition
[17:02:33.416]             sys.calls <- base::sys.calls
[17:02:33.416]             `[[` <- base::`[[`
[17:02:33.416]             `+` <- base::`+`
[17:02:33.416]             `<<-` <- base::`<<-`
[17:02:33.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.416]                   3L)]
[17:02:33.416]             }
[17:02:33.416]             function(cond) {
[17:02:33.416]                 is_error <- inherits(cond, "error")
[17:02:33.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.416]                   NULL)
[17:02:33.416]                 if (is_error) {
[17:02:33.416]                   sessionInformation <- function() {
[17:02:33.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.416]                       search = base::search(), system = base::Sys.info())
[17:02:33.416]                   }
[17:02:33.416]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.416]                     cond$call), session = sessionInformation(), 
[17:02:33.416]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.416]                   signalCondition(cond)
[17:02:33.416]                 }
[17:02:33.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.416]                 "immediateCondition"))) {
[17:02:33.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.416]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.416]                   if (TRUE && !signal) {
[17:02:33.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.416]                     {
[17:02:33.416]                       inherits <- base::inherits
[17:02:33.416]                       invokeRestart <- base::invokeRestart
[17:02:33.416]                       is.null <- base::is.null
[17:02:33.416]                       muffled <- FALSE
[17:02:33.416]                       if (inherits(cond, "message")) {
[17:02:33.416]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.416]                         if (muffled) 
[17:02:33.416]                           invokeRestart("muffleMessage")
[17:02:33.416]                       }
[17:02:33.416]                       else if (inherits(cond, "warning")) {
[17:02:33.416]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.416]                         if (muffled) 
[17:02:33.416]                           invokeRestart("muffleWarning")
[17:02:33.416]                       }
[17:02:33.416]                       else if (inherits(cond, "condition")) {
[17:02:33.416]                         if (!is.null(pattern)) {
[17:02:33.416]                           computeRestarts <- base::computeRestarts
[17:02:33.416]                           grepl <- base::grepl
[17:02:33.416]                           restarts <- computeRestarts(cond)
[17:02:33.416]                           for (restart in restarts) {
[17:02:33.416]                             name <- restart$name
[17:02:33.416]                             if (is.null(name)) 
[17:02:33.416]                               next
[17:02:33.416]                             if (!grepl(pattern, name)) 
[17:02:33.416]                               next
[17:02:33.416]                             invokeRestart(restart)
[17:02:33.416]                             muffled <- TRUE
[17:02:33.416]                             break
[17:02:33.416]                           }
[17:02:33.416]                         }
[17:02:33.416]                       }
[17:02:33.416]                       invisible(muffled)
[17:02:33.416]                     }
[17:02:33.416]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.416]                   }
[17:02:33.416]                 }
[17:02:33.416]                 else {
[17:02:33.416]                   if (TRUE) {
[17:02:33.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.416]                     {
[17:02:33.416]                       inherits <- base::inherits
[17:02:33.416]                       invokeRestart <- base::invokeRestart
[17:02:33.416]                       is.null <- base::is.null
[17:02:33.416]                       muffled <- FALSE
[17:02:33.416]                       if (inherits(cond, "message")) {
[17:02:33.416]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.416]                         if (muffled) 
[17:02:33.416]                           invokeRestart("muffleMessage")
[17:02:33.416]                       }
[17:02:33.416]                       else if (inherits(cond, "warning")) {
[17:02:33.416]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.416]                         if (muffled) 
[17:02:33.416]                           invokeRestart("muffleWarning")
[17:02:33.416]                       }
[17:02:33.416]                       else if (inherits(cond, "condition")) {
[17:02:33.416]                         if (!is.null(pattern)) {
[17:02:33.416]                           computeRestarts <- base::computeRestarts
[17:02:33.416]                           grepl <- base::grepl
[17:02:33.416]                           restarts <- computeRestarts(cond)
[17:02:33.416]                           for (restart in restarts) {
[17:02:33.416]                             name <- restart$name
[17:02:33.416]                             if (is.null(name)) 
[17:02:33.416]                               next
[17:02:33.416]                             if (!grepl(pattern, name)) 
[17:02:33.416]                               next
[17:02:33.416]                             invokeRestart(restart)
[17:02:33.416]                             muffled <- TRUE
[17:02:33.416]                             break
[17:02:33.416]                           }
[17:02:33.416]                         }
[17:02:33.416]                       }
[17:02:33.416]                       invisible(muffled)
[17:02:33.416]                     }
[17:02:33.416]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.416]                   }
[17:02:33.416]                 }
[17:02:33.416]             }
[17:02:33.416]         }))
[17:02:33.416]     }, error = function(ex) {
[17:02:33.416]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.416]                 ...future.rng), started = ...future.startTime, 
[17:02:33.416]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.416]             version = "1.8"), class = "FutureResult")
[17:02:33.416]     }, finally = {
[17:02:33.416]         if (!identical(...future.workdir, getwd())) 
[17:02:33.416]             setwd(...future.workdir)
[17:02:33.416]         {
[17:02:33.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.416]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.416]             }
[17:02:33.416]             base::options(...future.oldOptions)
[17:02:33.416]             if (.Platform$OS.type == "windows") {
[17:02:33.416]                 old_names <- names(...future.oldEnvVars)
[17:02:33.416]                 envs <- base::Sys.getenv()
[17:02:33.416]                 names <- names(envs)
[17:02:33.416]                 common <- intersect(names, old_names)
[17:02:33.416]                 added <- setdiff(names, old_names)
[17:02:33.416]                 removed <- setdiff(old_names, names)
[17:02:33.416]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.416]                   envs[common]]
[17:02:33.416]                 NAMES <- toupper(changed)
[17:02:33.416]                 args <- list()
[17:02:33.416]                 for (kk in seq_along(NAMES)) {
[17:02:33.416]                   name <- changed[[kk]]
[17:02:33.416]                   NAME <- NAMES[[kk]]
[17:02:33.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.416]                     next
[17:02:33.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.416]                 }
[17:02:33.416]                 NAMES <- toupper(added)
[17:02:33.416]                 for (kk in seq_along(NAMES)) {
[17:02:33.416]                   name <- added[[kk]]
[17:02:33.416]                   NAME <- NAMES[[kk]]
[17:02:33.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.416]                     next
[17:02:33.416]                   args[[name]] <- ""
[17:02:33.416]                 }
[17:02:33.416]                 NAMES <- toupper(removed)
[17:02:33.416]                 for (kk in seq_along(NAMES)) {
[17:02:33.416]                   name <- removed[[kk]]
[17:02:33.416]                   NAME <- NAMES[[kk]]
[17:02:33.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.416]                     next
[17:02:33.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.416]                 }
[17:02:33.416]                 if (length(args) > 0) 
[17:02:33.416]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.416]             }
[17:02:33.416]             else {
[17:02:33.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.416]             }
[17:02:33.416]             {
[17:02:33.416]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.416]                   0L) {
[17:02:33.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.416]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.416]                   base::options(opts)
[17:02:33.416]                 }
[17:02:33.416]                 {
[17:02:33.416]                   {
[17:02:33.416]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.416]                     NULL
[17:02:33.416]                   }
[17:02:33.416]                   options(future.plan = NULL)
[17:02:33.416]                   if (is.na(NA_character_)) 
[17:02:33.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.416]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.416]                     .init = FALSE)
[17:02:33.416]                 }
[17:02:33.416]             }
[17:02:33.416]         }
[17:02:33.416]     })
[17:02:33.416]     if (TRUE) {
[17:02:33.416]         base::sink(type = "output", split = FALSE)
[17:02:33.416]         if (TRUE) {
[17:02:33.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.416]         }
[17:02:33.416]         else {
[17:02:33.416]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.416]         }
[17:02:33.416]         base::close(...future.stdout)
[17:02:33.416]         ...future.stdout <- NULL
[17:02:33.416]     }
[17:02:33.416]     ...future.result$conditions <- ...future.conditions
[17:02:33.416]     ...future.result$finished <- base::Sys.time()
[17:02:33.416]     ...future.result
[17:02:33.416] }
[17:02:33.419] MultisessionFuture started
[17:02:33.420] - Launch lazy future ... done
[17:02:33.420] run() for ‘MultisessionFuture’ ... done
[17:02:33.420] getGlobalsAndPackages() ...
[17:02:33.420] Searching for globals...
[17:02:33.421] 
[17:02:33.421] Searching for globals ... DONE
[17:02:33.421] - globals: [0] <none>
[17:02:33.421] getGlobalsAndPackages() ... DONE
[17:02:33.421] run() for ‘Future’ ...
[17:02:33.422] - state: ‘created’
[17:02:33.422] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.436] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.436]   - Field: ‘node’
[17:02:33.436]   - Field: ‘label’
[17:02:33.436]   - Field: ‘local’
[17:02:33.436]   - Field: ‘owner’
[17:02:33.436]   - Field: ‘envir’
[17:02:33.437]   - Field: ‘workers’
[17:02:33.437]   - Field: ‘packages’
[17:02:33.437]   - Field: ‘gc’
[17:02:33.437]   - Field: ‘conditions’
[17:02:33.437]   - Field: ‘persistent’
[17:02:33.437]   - Field: ‘expr’
[17:02:33.437]   - Field: ‘uuid’
[17:02:33.437]   - Field: ‘seed’
[17:02:33.437]   - Field: ‘version’
[17:02:33.437]   - Field: ‘result’
[17:02:33.437]   - Field: ‘asynchronous’
[17:02:33.438]   - Field: ‘calls’
[17:02:33.438]   - Field: ‘globals’
[17:02:33.438]   - Field: ‘stdout’
[17:02:33.438]   - Field: ‘earlySignal’
[17:02:33.438]   - Field: ‘lazy’
[17:02:33.438]   - Field: ‘state’
[17:02:33.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.438] - Launch lazy future ...
[17:02:33.438] Packages needed by the future expression (n = 0): <none>
[17:02:33.439] Packages needed by future strategies (n = 0): <none>
[17:02:33.439] {
[17:02:33.439]     {
[17:02:33.439]         {
[17:02:33.439]             ...future.startTime <- base::Sys.time()
[17:02:33.439]             {
[17:02:33.439]                 {
[17:02:33.439]                   {
[17:02:33.439]                     {
[17:02:33.439]                       base::local({
[17:02:33.439]                         has_future <- base::requireNamespace("future", 
[17:02:33.439]                           quietly = TRUE)
[17:02:33.439]                         if (has_future) {
[17:02:33.439]                           ns <- base::getNamespace("future")
[17:02:33.439]                           version <- ns[[".package"]][["version"]]
[17:02:33.439]                           if (is.null(version)) 
[17:02:33.439]                             version <- utils::packageVersion("future")
[17:02:33.439]                         }
[17:02:33.439]                         else {
[17:02:33.439]                           version <- NULL
[17:02:33.439]                         }
[17:02:33.439]                         if (!has_future || version < "1.8.0") {
[17:02:33.439]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.439]                             "", base::R.version$version.string), 
[17:02:33.439]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.439]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.439]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.439]                               "release", "version")], collapse = " "), 
[17:02:33.439]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.439]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.439]                             info)
[17:02:33.439]                           info <- base::paste(info, collapse = "; ")
[17:02:33.439]                           if (!has_future) {
[17:02:33.439]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.439]                               info)
[17:02:33.439]                           }
[17:02:33.439]                           else {
[17:02:33.439]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.439]                               info, version)
[17:02:33.439]                           }
[17:02:33.439]                           base::stop(msg)
[17:02:33.439]                         }
[17:02:33.439]                       })
[17:02:33.439]                     }
[17:02:33.439]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.439]                     base::options(mc.cores = 1L)
[17:02:33.439]                   }
[17:02:33.439]                   ...future.strategy.old <- future::plan("list")
[17:02:33.439]                   options(future.plan = NULL)
[17:02:33.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.439]                 }
[17:02:33.439]                 ...future.workdir <- getwd()
[17:02:33.439]             }
[17:02:33.439]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.439]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.439]         }
[17:02:33.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.439]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.439]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.439]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.439]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.439]             base::names(...future.oldOptions))
[17:02:33.439]     }
[17:02:33.439]     if (FALSE) {
[17:02:33.439]     }
[17:02:33.439]     else {
[17:02:33.439]         if (TRUE) {
[17:02:33.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.439]                 open = "w")
[17:02:33.439]         }
[17:02:33.439]         else {
[17:02:33.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.439]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.439]         }
[17:02:33.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.439]             base::sink(type = "output", split = FALSE)
[17:02:33.439]             base::close(...future.stdout)
[17:02:33.439]         }, add = TRUE)
[17:02:33.439]     }
[17:02:33.439]     ...future.frame <- base::sys.nframe()
[17:02:33.439]     ...future.conditions <- base::list()
[17:02:33.439]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.439]     if (FALSE) {
[17:02:33.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.439]     }
[17:02:33.439]     ...future.result <- base::tryCatch({
[17:02:33.439]         base::withCallingHandlers({
[17:02:33.439]             ...future.value <- base::withVisible(base::local({
[17:02:33.439]                 ...future.makeSendCondition <- base::local({
[17:02:33.439]                   sendCondition <- NULL
[17:02:33.439]                   function(frame = 1L) {
[17:02:33.439]                     if (is.function(sendCondition)) 
[17:02:33.439]                       return(sendCondition)
[17:02:33.439]                     ns <- getNamespace("parallel")
[17:02:33.439]                     if (exists("sendData", mode = "function", 
[17:02:33.439]                       envir = ns)) {
[17:02:33.439]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.439]                         envir = ns)
[17:02:33.439]                       envir <- sys.frame(frame)
[17:02:33.439]                       master <- NULL
[17:02:33.439]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.439]                         !identical(envir, emptyenv())) {
[17:02:33.439]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.439]                           inherits = FALSE)) {
[17:02:33.439]                           master <- get("master", mode = "list", 
[17:02:33.439]                             envir = envir, inherits = FALSE)
[17:02:33.439]                           if (inherits(master, c("SOCKnode", 
[17:02:33.439]                             "SOCK0node"))) {
[17:02:33.439]                             sendCondition <<- function(cond) {
[17:02:33.439]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.439]                                 success = TRUE)
[17:02:33.439]                               parallel_sendData(master, data)
[17:02:33.439]                             }
[17:02:33.439]                             return(sendCondition)
[17:02:33.439]                           }
[17:02:33.439]                         }
[17:02:33.439]                         frame <- frame + 1L
[17:02:33.439]                         envir <- sys.frame(frame)
[17:02:33.439]                       }
[17:02:33.439]                     }
[17:02:33.439]                     sendCondition <<- function(cond) NULL
[17:02:33.439]                   }
[17:02:33.439]                 })
[17:02:33.439]                 withCallingHandlers({
[17:02:33.439]                   NULL
[17:02:33.439]                 }, immediateCondition = function(cond) {
[17:02:33.439]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.439]                   sendCondition(cond)
[17:02:33.439]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.439]                   {
[17:02:33.439]                     inherits <- base::inherits
[17:02:33.439]                     invokeRestart <- base::invokeRestart
[17:02:33.439]                     is.null <- base::is.null
[17:02:33.439]                     muffled <- FALSE
[17:02:33.439]                     if (inherits(cond, "message")) {
[17:02:33.439]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.439]                       if (muffled) 
[17:02:33.439]                         invokeRestart("muffleMessage")
[17:02:33.439]                     }
[17:02:33.439]                     else if (inherits(cond, "warning")) {
[17:02:33.439]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.439]                       if (muffled) 
[17:02:33.439]                         invokeRestart("muffleWarning")
[17:02:33.439]                     }
[17:02:33.439]                     else if (inherits(cond, "condition")) {
[17:02:33.439]                       if (!is.null(pattern)) {
[17:02:33.439]                         computeRestarts <- base::computeRestarts
[17:02:33.439]                         grepl <- base::grepl
[17:02:33.439]                         restarts <- computeRestarts(cond)
[17:02:33.439]                         for (restart in restarts) {
[17:02:33.439]                           name <- restart$name
[17:02:33.439]                           if (is.null(name)) 
[17:02:33.439]                             next
[17:02:33.439]                           if (!grepl(pattern, name)) 
[17:02:33.439]                             next
[17:02:33.439]                           invokeRestart(restart)
[17:02:33.439]                           muffled <- TRUE
[17:02:33.439]                           break
[17:02:33.439]                         }
[17:02:33.439]                       }
[17:02:33.439]                     }
[17:02:33.439]                     invisible(muffled)
[17:02:33.439]                   }
[17:02:33.439]                   muffleCondition(cond)
[17:02:33.439]                 })
[17:02:33.439]             }))
[17:02:33.439]             future::FutureResult(value = ...future.value$value, 
[17:02:33.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.439]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.439]                     ...future.globalenv.names))
[17:02:33.439]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.439]         }, condition = base::local({
[17:02:33.439]             c <- base::c
[17:02:33.439]             inherits <- base::inherits
[17:02:33.439]             invokeRestart <- base::invokeRestart
[17:02:33.439]             length <- base::length
[17:02:33.439]             list <- base::list
[17:02:33.439]             seq.int <- base::seq.int
[17:02:33.439]             signalCondition <- base::signalCondition
[17:02:33.439]             sys.calls <- base::sys.calls
[17:02:33.439]             `[[` <- base::`[[`
[17:02:33.439]             `+` <- base::`+`
[17:02:33.439]             `<<-` <- base::`<<-`
[17:02:33.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.439]                   3L)]
[17:02:33.439]             }
[17:02:33.439]             function(cond) {
[17:02:33.439]                 is_error <- inherits(cond, "error")
[17:02:33.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.439]                   NULL)
[17:02:33.439]                 if (is_error) {
[17:02:33.439]                   sessionInformation <- function() {
[17:02:33.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.439]                       search = base::search(), system = base::Sys.info())
[17:02:33.439]                   }
[17:02:33.439]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.439]                     cond$call), session = sessionInformation(), 
[17:02:33.439]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.439]                   signalCondition(cond)
[17:02:33.439]                 }
[17:02:33.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.439]                 "immediateCondition"))) {
[17:02:33.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.439]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.439]                   if (TRUE && !signal) {
[17:02:33.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.439]                     {
[17:02:33.439]                       inherits <- base::inherits
[17:02:33.439]                       invokeRestart <- base::invokeRestart
[17:02:33.439]                       is.null <- base::is.null
[17:02:33.439]                       muffled <- FALSE
[17:02:33.439]                       if (inherits(cond, "message")) {
[17:02:33.439]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.439]                         if (muffled) 
[17:02:33.439]                           invokeRestart("muffleMessage")
[17:02:33.439]                       }
[17:02:33.439]                       else if (inherits(cond, "warning")) {
[17:02:33.439]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.439]                         if (muffled) 
[17:02:33.439]                           invokeRestart("muffleWarning")
[17:02:33.439]                       }
[17:02:33.439]                       else if (inherits(cond, "condition")) {
[17:02:33.439]                         if (!is.null(pattern)) {
[17:02:33.439]                           computeRestarts <- base::computeRestarts
[17:02:33.439]                           grepl <- base::grepl
[17:02:33.439]                           restarts <- computeRestarts(cond)
[17:02:33.439]                           for (restart in restarts) {
[17:02:33.439]                             name <- restart$name
[17:02:33.439]                             if (is.null(name)) 
[17:02:33.439]                               next
[17:02:33.439]                             if (!grepl(pattern, name)) 
[17:02:33.439]                               next
[17:02:33.439]                             invokeRestart(restart)
[17:02:33.439]                             muffled <- TRUE
[17:02:33.439]                             break
[17:02:33.439]                           }
[17:02:33.439]                         }
[17:02:33.439]                       }
[17:02:33.439]                       invisible(muffled)
[17:02:33.439]                     }
[17:02:33.439]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.439]                   }
[17:02:33.439]                 }
[17:02:33.439]                 else {
[17:02:33.439]                   if (TRUE) {
[17:02:33.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.439]                     {
[17:02:33.439]                       inherits <- base::inherits
[17:02:33.439]                       invokeRestart <- base::invokeRestart
[17:02:33.439]                       is.null <- base::is.null
[17:02:33.439]                       muffled <- FALSE
[17:02:33.439]                       if (inherits(cond, "message")) {
[17:02:33.439]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.439]                         if (muffled) 
[17:02:33.439]                           invokeRestart("muffleMessage")
[17:02:33.439]                       }
[17:02:33.439]                       else if (inherits(cond, "warning")) {
[17:02:33.439]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.439]                         if (muffled) 
[17:02:33.439]                           invokeRestart("muffleWarning")
[17:02:33.439]                       }
[17:02:33.439]                       else if (inherits(cond, "condition")) {
[17:02:33.439]                         if (!is.null(pattern)) {
[17:02:33.439]                           computeRestarts <- base::computeRestarts
[17:02:33.439]                           grepl <- base::grepl
[17:02:33.439]                           restarts <- computeRestarts(cond)
[17:02:33.439]                           for (restart in restarts) {
[17:02:33.439]                             name <- restart$name
[17:02:33.439]                             if (is.null(name)) 
[17:02:33.439]                               next
[17:02:33.439]                             if (!grepl(pattern, name)) 
[17:02:33.439]                               next
[17:02:33.439]                             invokeRestart(restart)
[17:02:33.439]                             muffled <- TRUE
[17:02:33.439]                             break
[17:02:33.439]                           }
[17:02:33.439]                         }
[17:02:33.439]                       }
[17:02:33.439]                       invisible(muffled)
[17:02:33.439]                     }
[17:02:33.439]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.439]                   }
[17:02:33.439]                 }
[17:02:33.439]             }
[17:02:33.439]         }))
[17:02:33.439]     }, error = function(ex) {
[17:02:33.439]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.439]                 ...future.rng), started = ...future.startTime, 
[17:02:33.439]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.439]             version = "1.8"), class = "FutureResult")
[17:02:33.439]     }, finally = {
[17:02:33.439]         if (!identical(...future.workdir, getwd())) 
[17:02:33.439]             setwd(...future.workdir)
[17:02:33.439]         {
[17:02:33.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.439]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.439]             }
[17:02:33.439]             base::options(...future.oldOptions)
[17:02:33.439]             if (.Platform$OS.type == "windows") {
[17:02:33.439]                 old_names <- names(...future.oldEnvVars)
[17:02:33.439]                 envs <- base::Sys.getenv()
[17:02:33.439]                 names <- names(envs)
[17:02:33.439]                 common <- intersect(names, old_names)
[17:02:33.439]                 added <- setdiff(names, old_names)
[17:02:33.439]                 removed <- setdiff(old_names, names)
[17:02:33.439]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.439]                   envs[common]]
[17:02:33.439]                 NAMES <- toupper(changed)
[17:02:33.439]                 args <- list()
[17:02:33.439]                 for (kk in seq_along(NAMES)) {
[17:02:33.439]                   name <- changed[[kk]]
[17:02:33.439]                   NAME <- NAMES[[kk]]
[17:02:33.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.439]                     next
[17:02:33.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.439]                 }
[17:02:33.439]                 NAMES <- toupper(added)
[17:02:33.439]                 for (kk in seq_along(NAMES)) {
[17:02:33.439]                   name <- added[[kk]]
[17:02:33.439]                   NAME <- NAMES[[kk]]
[17:02:33.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.439]                     next
[17:02:33.439]                   args[[name]] <- ""
[17:02:33.439]                 }
[17:02:33.439]                 NAMES <- toupper(removed)
[17:02:33.439]                 for (kk in seq_along(NAMES)) {
[17:02:33.439]                   name <- removed[[kk]]
[17:02:33.439]                   NAME <- NAMES[[kk]]
[17:02:33.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.439]                     next
[17:02:33.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.439]                 }
[17:02:33.439]                 if (length(args) > 0) 
[17:02:33.439]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.439]             }
[17:02:33.439]             else {
[17:02:33.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.439]             }
[17:02:33.439]             {
[17:02:33.439]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.439]                   0L) {
[17:02:33.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.439]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.439]                   base::options(opts)
[17:02:33.439]                 }
[17:02:33.439]                 {
[17:02:33.439]                   {
[17:02:33.439]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.439]                     NULL
[17:02:33.439]                   }
[17:02:33.439]                   options(future.plan = NULL)
[17:02:33.439]                   if (is.na(NA_character_)) 
[17:02:33.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.439]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.439]                     .init = FALSE)
[17:02:33.439]                 }
[17:02:33.439]             }
[17:02:33.439]         }
[17:02:33.439]     })
[17:02:33.439]     if (TRUE) {
[17:02:33.439]         base::sink(type = "output", split = FALSE)
[17:02:33.439]         if (TRUE) {
[17:02:33.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.439]         }
[17:02:33.439]         else {
[17:02:33.439]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.439]         }
[17:02:33.439]         base::close(...future.stdout)
[17:02:33.439]         ...future.stdout <- NULL
[17:02:33.439]     }
[17:02:33.439]     ...future.result$conditions <- ...future.conditions
[17:02:33.439]     ...future.result$finished <- base::Sys.time()
[17:02:33.439]     ...future.result
[17:02:33.439] }
[17:02:33.442] MultisessionFuture started
[17:02:33.442] - Launch lazy future ... done
[17:02:33.442] run() for ‘MultisessionFuture’ ... done
[17:02:33.443] getGlobalsAndPackages() ...
[17:02:33.443] Searching for globals...
[17:02:33.443] - globals found: [1] ‘{’
[17:02:33.443] Searching for globals ... DONE
[17:02:33.444] Resolving globals: FALSE
[17:02:33.444] 
[17:02:33.444] 
[17:02:33.444] getGlobalsAndPackages() ... DONE
[17:02:33.444] run() for ‘Future’ ...
[17:02:33.444] - state: ‘created’
[17:02:33.444] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.458] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.458]   - Field: ‘node’
[17:02:33.459]   - Field: ‘label’
[17:02:33.459]   - Field: ‘local’
[17:02:33.459]   - Field: ‘owner’
[17:02:33.459]   - Field: ‘envir’
[17:02:33.459]   - Field: ‘workers’
[17:02:33.459]   - Field: ‘packages’
[17:02:33.459]   - Field: ‘gc’
[17:02:33.459]   - Field: ‘conditions’
[17:02:33.459]   - Field: ‘persistent’
[17:02:33.459]   - Field: ‘expr’
[17:02:33.460]   - Field: ‘uuid’
[17:02:33.460]   - Field: ‘seed’
[17:02:33.460]   - Field: ‘version’
[17:02:33.460]   - Field: ‘result’
[17:02:33.460]   - Field: ‘asynchronous’
[17:02:33.460]   - Field: ‘calls’
[17:02:33.460]   - Field: ‘globals’
[17:02:33.460]   - Field: ‘stdout’
[17:02:33.460]   - Field: ‘earlySignal’
[17:02:33.460]   - Field: ‘lazy’
[17:02:33.460]   - Field: ‘state’
[17:02:33.461] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.461] - Launch lazy future ...
[17:02:33.461] Packages needed by the future expression (n = 0): <none>
[17:02:33.461] Packages needed by future strategies (n = 0): <none>
[17:02:33.461] {
[17:02:33.461]     {
[17:02:33.461]         {
[17:02:33.461]             ...future.startTime <- base::Sys.time()
[17:02:33.461]             {
[17:02:33.461]                 {
[17:02:33.461]                   {
[17:02:33.461]                     {
[17:02:33.461]                       base::local({
[17:02:33.461]                         has_future <- base::requireNamespace("future", 
[17:02:33.461]                           quietly = TRUE)
[17:02:33.461]                         if (has_future) {
[17:02:33.461]                           ns <- base::getNamespace("future")
[17:02:33.461]                           version <- ns[[".package"]][["version"]]
[17:02:33.461]                           if (is.null(version)) 
[17:02:33.461]                             version <- utils::packageVersion("future")
[17:02:33.461]                         }
[17:02:33.461]                         else {
[17:02:33.461]                           version <- NULL
[17:02:33.461]                         }
[17:02:33.461]                         if (!has_future || version < "1.8.0") {
[17:02:33.461]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.461]                             "", base::R.version$version.string), 
[17:02:33.461]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.461]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.461]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.461]                               "release", "version")], collapse = " "), 
[17:02:33.461]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.461]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.461]                             info)
[17:02:33.461]                           info <- base::paste(info, collapse = "; ")
[17:02:33.461]                           if (!has_future) {
[17:02:33.461]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.461]                               info)
[17:02:33.461]                           }
[17:02:33.461]                           else {
[17:02:33.461]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.461]                               info, version)
[17:02:33.461]                           }
[17:02:33.461]                           base::stop(msg)
[17:02:33.461]                         }
[17:02:33.461]                       })
[17:02:33.461]                     }
[17:02:33.461]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.461]                     base::options(mc.cores = 1L)
[17:02:33.461]                   }
[17:02:33.461]                   ...future.strategy.old <- future::plan("list")
[17:02:33.461]                   options(future.plan = NULL)
[17:02:33.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.461]                 }
[17:02:33.461]                 ...future.workdir <- getwd()
[17:02:33.461]             }
[17:02:33.461]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.461]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.461]         }
[17:02:33.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.461]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.461]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.461]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.461]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.461]             base::names(...future.oldOptions))
[17:02:33.461]     }
[17:02:33.461]     if (FALSE) {
[17:02:33.461]     }
[17:02:33.461]     else {
[17:02:33.461]         if (TRUE) {
[17:02:33.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.461]                 open = "w")
[17:02:33.461]         }
[17:02:33.461]         else {
[17:02:33.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.461]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.461]         }
[17:02:33.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.461]             base::sink(type = "output", split = FALSE)
[17:02:33.461]             base::close(...future.stdout)
[17:02:33.461]         }, add = TRUE)
[17:02:33.461]     }
[17:02:33.461]     ...future.frame <- base::sys.nframe()
[17:02:33.461]     ...future.conditions <- base::list()
[17:02:33.461]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.461]     if (FALSE) {
[17:02:33.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.461]     }
[17:02:33.461]     ...future.result <- base::tryCatch({
[17:02:33.461]         base::withCallingHandlers({
[17:02:33.461]             ...future.value <- base::withVisible(base::local({
[17:02:33.461]                 ...future.makeSendCondition <- base::local({
[17:02:33.461]                   sendCondition <- NULL
[17:02:33.461]                   function(frame = 1L) {
[17:02:33.461]                     if (is.function(sendCondition)) 
[17:02:33.461]                       return(sendCondition)
[17:02:33.461]                     ns <- getNamespace("parallel")
[17:02:33.461]                     if (exists("sendData", mode = "function", 
[17:02:33.461]                       envir = ns)) {
[17:02:33.461]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.461]                         envir = ns)
[17:02:33.461]                       envir <- sys.frame(frame)
[17:02:33.461]                       master <- NULL
[17:02:33.461]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.461]                         !identical(envir, emptyenv())) {
[17:02:33.461]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.461]                           inherits = FALSE)) {
[17:02:33.461]                           master <- get("master", mode = "list", 
[17:02:33.461]                             envir = envir, inherits = FALSE)
[17:02:33.461]                           if (inherits(master, c("SOCKnode", 
[17:02:33.461]                             "SOCK0node"))) {
[17:02:33.461]                             sendCondition <<- function(cond) {
[17:02:33.461]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.461]                                 success = TRUE)
[17:02:33.461]                               parallel_sendData(master, data)
[17:02:33.461]                             }
[17:02:33.461]                             return(sendCondition)
[17:02:33.461]                           }
[17:02:33.461]                         }
[17:02:33.461]                         frame <- frame + 1L
[17:02:33.461]                         envir <- sys.frame(frame)
[17:02:33.461]                       }
[17:02:33.461]                     }
[17:02:33.461]                     sendCondition <<- function(cond) NULL
[17:02:33.461]                   }
[17:02:33.461]                 })
[17:02:33.461]                 withCallingHandlers({
[17:02:33.461]                   {
[17:02:33.461]                     4
[17:02:33.461]                   }
[17:02:33.461]                 }, immediateCondition = function(cond) {
[17:02:33.461]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.461]                   sendCondition(cond)
[17:02:33.461]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.461]                   {
[17:02:33.461]                     inherits <- base::inherits
[17:02:33.461]                     invokeRestart <- base::invokeRestart
[17:02:33.461]                     is.null <- base::is.null
[17:02:33.461]                     muffled <- FALSE
[17:02:33.461]                     if (inherits(cond, "message")) {
[17:02:33.461]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.461]                       if (muffled) 
[17:02:33.461]                         invokeRestart("muffleMessage")
[17:02:33.461]                     }
[17:02:33.461]                     else if (inherits(cond, "warning")) {
[17:02:33.461]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.461]                       if (muffled) 
[17:02:33.461]                         invokeRestart("muffleWarning")
[17:02:33.461]                     }
[17:02:33.461]                     else if (inherits(cond, "condition")) {
[17:02:33.461]                       if (!is.null(pattern)) {
[17:02:33.461]                         computeRestarts <- base::computeRestarts
[17:02:33.461]                         grepl <- base::grepl
[17:02:33.461]                         restarts <- computeRestarts(cond)
[17:02:33.461]                         for (restart in restarts) {
[17:02:33.461]                           name <- restart$name
[17:02:33.461]                           if (is.null(name)) 
[17:02:33.461]                             next
[17:02:33.461]                           if (!grepl(pattern, name)) 
[17:02:33.461]                             next
[17:02:33.461]                           invokeRestart(restart)
[17:02:33.461]                           muffled <- TRUE
[17:02:33.461]                           break
[17:02:33.461]                         }
[17:02:33.461]                       }
[17:02:33.461]                     }
[17:02:33.461]                     invisible(muffled)
[17:02:33.461]                   }
[17:02:33.461]                   muffleCondition(cond)
[17:02:33.461]                 })
[17:02:33.461]             }))
[17:02:33.461]             future::FutureResult(value = ...future.value$value, 
[17:02:33.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.461]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.461]                     ...future.globalenv.names))
[17:02:33.461]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.461]         }, condition = base::local({
[17:02:33.461]             c <- base::c
[17:02:33.461]             inherits <- base::inherits
[17:02:33.461]             invokeRestart <- base::invokeRestart
[17:02:33.461]             length <- base::length
[17:02:33.461]             list <- base::list
[17:02:33.461]             seq.int <- base::seq.int
[17:02:33.461]             signalCondition <- base::signalCondition
[17:02:33.461]             sys.calls <- base::sys.calls
[17:02:33.461]             `[[` <- base::`[[`
[17:02:33.461]             `+` <- base::`+`
[17:02:33.461]             `<<-` <- base::`<<-`
[17:02:33.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.461]                   3L)]
[17:02:33.461]             }
[17:02:33.461]             function(cond) {
[17:02:33.461]                 is_error <- inherits(cond, "error")
[17:02:33.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.461]                   NULL)
[17:02:33.461]                 if (is_error) {
[17:02:33.461]                   sessionInformation <- function() {
[17:02:33.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.461]                       search = base::search(), system = base::Sys.info())
[17:02:33.461]                   }
[17:02:33.461]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.461]                     cond$call), session = sessionInformation(), 
[17:02:33.461]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.461]                   signalCondition(cond)
[17:02:33.461]                 }
[17:02:33.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.461]                 "immediateCondition"))) {
[17:02:33.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.461]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.461]                   if (TRUE && !signal) {
[17:02:33.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.461]                     {
[17:02:33.461]                       inherits <- base::inherits
[17:02:33.461]                       invokeRestart <- base::invokeRestart
[17:02:33.461]                       is.null <- base::is.null
[17:02:33.461]                       muffled <- FALSE
[17:02:33.461]                       if (inherits(cond, "message")) {
[17:02:33.461]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.461]                         if (muffled) 
[17:02:33.461]                           invokeRestart("muffleMessage")
[17:02:33.461]                       }
[17:02:33.461]                       else if (inherits(cond, "warning")) {
[17:02:33.461]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.461]                         if (muffled) 
[17:02:33.461]                           invokeRestart("muffleWarning")
[17:02:33.461]                       }
[17:02:33.461]                       else if (inherits(cond, "condition")) {
[17:02:33.461]                         if (!is.null(pattern)) {
[17:02:33.461]                           computeRestarts <- base::computeRestarts
[17:02:33.461]                           grepl <- base::grepl
[17:02:33.461]                           restarts <- computeRestarts(cond)
[17:02:33.461]                           for (restart in restarts) {
[17:02:33.461]                             name <- restart$name
[17:02:33.461]                             if (is.null(name)) 
[17:02:33.461]                               next
[17:02:33.461]                             if (!grepl(pattern, name)) 
[17:02:33.461]                               next
[17:02:33.461]                             invokeRestart(restart)
[17:02:33.461]                             muffled <- TRUE
[17:02:33.461]                             break
[17:02:33.461]                           }
[17:02:33.461]                         }
[17:02:33.461]                       }
[17:02:33.461]                       invisible(muffled)
[17:02:33.461]                     }
[17:02:33.461]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.461]                   }
[17:02:33.461]                 }
[17:02:33.461]                 else {
[17:02:33.461]                   if (TRUE) {
[17:02:33.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.461]                     {
[17:02:33.461]                       inherits <- base::inherits
[17:02:33.461]                       invokeRestart <- base::invokeRestart
[17:02:33.461]                       is.null <- base::is.null
[17:02:33.461]                       muffled <- FALSE
[17:02:33.461]                       if (inherits(cond, "message")) {
[17:02:33.461]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.461]                         if (muffled) 
[17:02:33.461]                           invokeRestart("muffleMessage")
[17:02:33.461]                       }
[17:02:33.461]                       else if (inherits(cond, "warning")) {
[17:02:33.461]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.461]                         if (muffled) 
[17:02:33.461]                           invokeRestart("muffleWarning")
[17:02:33.461]                       }
[17:02:33.461]                       else if (inherits(cond, "condition")) {
[17:02:33.461]                         if (!is.null(pattern)) {
[17:02:33.461]                           computeRestarts <- base::computeRestarts
[17:02:33.461]                           grepl <- base::grepl
[17:02:33.461]                           restarts <- computeRestarts(cond)
[17:02:33.461]                           for (restart in restarts) {
[17:02:33.461]                             name <- restart$name
[17:02:33.461]                             if (is.null(name)) 
[17:02:33.461]                               next
[17:02:33.461]                             if (!grepl(pattern, name)) 
[17:02:33.461]                               next
[17:02:33.461]                             invokeRestart(restart)
[17:02:33.461]                             muffled <- TRUE
[17:02:33.461]                             break
[17:02:33.461]                           }
[17:02:33.461]                         }
[17:02:33.461]                       }
[17:02:33.461]                       invisible(muffled)
[17:02:33.461]                     }
[17:02:33.461]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.461]                   }
[17:02:33.461]                 }
[17:02:33.461]             }
[17:02:33.461]         }))
[17:02:33.461]     }, error = function(ex) {
[17:02:33.461]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.461]                 ...future.rng), started = ...future.startTime, 
[17:02:33.461]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.461]             version = "1.8"), class = "FutureResult")
[17:02:33.461]     }, finally = {
[17:02:33.461]         if (!identical(...future.workdir, getwd())) 
[17:02:33.461]             setwd(...future.workdir)
[17:02:33.461]         {
[17:02:33.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.461]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.461]             }
[17:02:33.461]             base::options(...future.oldOptions)
[17:02:33.461]             if (.Platform$OS.type == "windows") {
[17:02:33.461]                 old_names <- names(...future.oldEnvVars)
[17:02:33.461]                 envs <- base::Sys.getenv()
[17:02:33.461]                 names <- names(envs)
[17:02:33.461]                 common <- intersect(names, old_names)
[17:02:33.461]                 added <- setdiff(names, old_names)
[17:02:33.461]                 removed <- setdiff(old_names, names)
[17:02:33.461]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.461]                   envs[common]]
[17:02:33.461]                 NAMES <- toupper(changed)
[17:02:33.461]                 args <- list()
[17:02:33.461]                 for (kk in seq_along(NAMES)) {
[17:02:33.461]                   name <- changed[[kk]]
[17:02:33.461]                   NAME <- NAMES[[kk]]
[17:02:33.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.461]                     next
[17:02:33.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.461]                 }
[17:02:33.461]                 NAMES <- toupper(added)
[17:02:33.461]                 for (kk in seq_along(NAMES)) {
[17:02:33.461]                   name <- added[[kk]]
[17:02:33.461]                   NAME <- NAMES[[kk]]
[17:02:33.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.461]                     next
[17:02:33.461]                   args[[name]] <- ""
[17:02:33.461]                 }
[17:02:33.461]                 NAMES <- toupper(removed)
[17:02:33.461]                 for (kk in seq_along(NAMES)) {
[17:02:33.461]                   name <- removed[[kk]]
[17:02:33.461]                   NAME <- NAMES[[kk]]
[17:02:33.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.461]                     next
[17:02:33.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.461]                 }
[17:02:33.461]                 if (length(args) > 0) 
[17:02:33.461]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.461]             }
[17:02:33.461]             else {
[17:02:33.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.461]             }
[17:02:33.461]             {
[17:02:33.461]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.461]                   0L) {
[17:02:33.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.461]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.461]                   base::options(opts)
[17:02:33.461]                 }
[17:02:33.461]                 {
[17:02:33.461]                   {
[17:02:33.461]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.461]                     NULL
[17:02:33.461]                   }
[17:02:33.461]                   options(future.plan = NULL)
[17:02:33.461]                   if (is.na(NA_character_)) 
[17:02:33.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.461]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.461]                     .init = FALSE)
[17:02:33.461]                 }
[17:02:33.461]             }
[17:02:33.461]         }
[17:02:33.461]     })
[17:02:33.461]     if (TRUE) {
[17:02:33.461]         base::sink(type = "output", split = FALSE)
[17:02:33.461]         if (TRUE) {
[17:02:33.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.461]         }
[17:02:33.461]         else {
[17:02:33.461]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.461]         }
[17:02:33.461]         base::close(...future.stdout)
[17:02:33.461]         ...future.stdout <- NULL
[17:02:33.461]     }
[17:02:33.461]     ...future.result$conditions <- ...future.conditions
[17:02:33.461]     ...future.result$finished <- base::Sys.time()
[17:02:33.461]     ...future.result
[17:02:33.461] }
[17:02:33.464] Poll #1 (0): usedNodes() = 2, workers = 2
[17:02:33.474] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.475] - Validating connection of MultisessionFuture
[17:02:33.475] - received message: FutureResult
[17:02:33.475] - Received FutureResult
[17:02:33.475] - Erased future from FutureRegistry
[17:02:33.475] result() for ClusterFuture ...
[17:02:33.475] - result already collected: FutureResult
[17:02:33.475] result() for ClusterFuture ... done
[17:02:33.475] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:33.476] result() for ClusterFuture ...
[17:02:33.476] - result already collected: FutureResult
[17:02:33.476] result() for ClusterFuture ... done
[17:02:33.476] result() for ClusterFuture ...
[17:02:33.476] - result already collected: FutureResult
[17:02:33.476] result() for ClusterFuture ... done
[17:02:33.477] MultisessionFuture started
[17:02:33.477] - Launch lazy future ... done
[17:02:33.477] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c747e3a4a0> 
Classes 'listenv', 'environment' <environment: 0x55c74af40d98> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:02:33.481] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.481] - Validating connection of MultisessionFuture
[17:02:33.482] - received message: FutureResult
[17:02:33.482] - Received FutureResult
[17:02:33.482] - Erased future from FutureRegistry
[17:02:33.482] result() for ClusterFuture ...
[17:02:33.482] - result already collected: FutureResult
[17:02:33.482] result() for ClusterFuture ... done
[17:02:33.482] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:33.482] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.483] - Validating connection of MultisessionFuture
[17:02:33.483] - received message: FutureResult
[17:02:33.483] - Received FutureResult
[17:02:33.483] - Erased future from FutureRegistry
[17:02:33.483] result() for ClusterFuture ...
[17:02:33.483] - result already collected: FutureResult
[17:02:33.483] result() for ClusterFuture ... done
[17:02:33.483] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:33.486] resolve() on list environment ...
[17:02:33.486]  recursive: 0
[17:02:33.487]  length: 6
[17:02:33.487]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:33.487] signalConditionsASAP(numeric, pos=1) ...
[17:02:33.487] - nx: 6
[17:02:33.487] - relay: TRUE
[17:02:33.487] - stdout: TRUE
[17:02:33.487] - signal: TRUE
[17:02:33.487] - resignal: FALSE
[17:02:33.487] - force: TRUE
[17:02:33.487] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.488] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.488]  - until=2
[17:02:33.488]  - relaying element #2
[17:02:33.488] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.488] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.488] signalConditionsASAP(NULL, pos=1) ... done
[17:02:33.488]  length: 5 (resolved future 1)
[17:02:33.488] Future #2
[17:02:33.488] result() for ClusterFuture ...
[17:02:33.488] - result already collected: FutureResult
[17:02:33.488] result() for ClusterFuture ... done
[17:02:33.489] result() for ClusterFuture ...
[17:02:33.489] - result already collected: FutureResult
[17:02:33.489] result() for ClusterFuture ... done
[17:02:33.489] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:33.489] - nx: 6
[17:02:33.489] - relay: TRUE
[17:02:33.489] - stdout: TRUE
[17:02:33.489] - signal: TRUE
[17:02:33.489] - resignal: FALSE
[17:02:33.489] - force: TRUE
[17:02:33.489] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.489] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.490]  - until=2
[17:02:33.490]  - relaying element #2
[17:02:33.490] result() for ClusterFuture ...
[17:02:33.490] - result already collected: FutureResult
[17:02:33.490] result() for ClusterFuture ... done
[17:02:33.490] result() for ClusterFuture ...
[17:02:33.490] - result already collected: FutureResult
[17:02:33.490] result() for ClusterFuture ... done
[17:02:33.490] result() for ClusterFuture ...
[17:02:33.490] - result already collected: FutureResult
[17:02:33.490] result() for ClusterFuture ... done
[17:02:33.491] result() for ClusterFuture ...
[17:02:33.491] - result already collected: FutureResult
[17:02:33.491] result() for ClusterFuture ... done
[17:02:33.491] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.491] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.491] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:33.491]  length: 4 (resolved future 2)
[17:02:33.491] Future #3
[17:02:33.491] result() for ClusterFuture ...
[17:02:33.491] - result already collected: FutureResult
[17:02:33.492] result() for ClusterFuture ... done
[17:02:33.492] result() for ClusterFuture ...
[17:02:33.492] - result already collected: FutureResult
[17:02:33.492] result() for ClusterFuture ... done
[17:02:33.492] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:33.492] - nx: 6
[17:02:33.492] - relay: TRUE
[17:02:33.492] - stdout: TRUE
[17:02:33.492] - signal: TRUE
[17:02:33.492] - resignal: FALSE
[17:02:33.492] - force: TRUE
[17:02:33.492] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.493] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.493]  - until=3
[17:02:33.493]  - relaying element #3
[17:02:33.493] result() for ClusterFuture ...
[17:02:33.493] - result already collected: FutureResult
[17:02:33.493] result() for ClusterFuture ... done
[17:02:33.493] result() for ClusterFuture ...
[17:02:33.493] - result already collected: FutureResult
[17:02:33.493] result() for ClusterFuture ... done
[17:02:33.493] result() for ClusterFuture ...
[17:02:33.493] - result already collected: FutureResult
[17:02:33.494] result() for ClusterFuture ... done
[17:02:33.494] result() for ClusterFuture ...
[17:02:33.494] - result already collected: FutureResult
[17:02:33.494] result() for ClusterFuture ... done
[17:02:33.494] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.494] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.497] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:33.497]  length: 3 (resolved future 3)
[17:02:33.497] Future #4
[17:02:33.497] result() for ClusterFuture ...
[17:02:33.497] - result already collected: FutureResult
[17:02:33.498] result() for ClusterFuture ... done
[17:02:33.498] result() for ClusterFuture ...
[17:02:33.498] - result already collected: FutureResult
[17:02:33.498] result() for ClusterFuture ... done
[17:02:33.498] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:02:33.498] - nx: 6
[17:02:33.498] - relay: TRUE
[17:02:33.498] - stdout: TRUE
[17:02:33.498] - signal: TRUE
[17:02:33.498] - resignal: FALSE
[17:02:33.498] - force: TRUE
[17:02:33.499] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.499] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.499]  - until=4
[17:02:33.499]  - relaying element #4
[17:02:33.499] result() for ClusterFuture ...
[17:02:33.499] - result already collected: FutureResult
[17:02:33.499] result() for ClusterFuture ... done
[17:02:33.499] result() for ClusterFuture ...
[17:02:33.499] - result already collected: FutureResult
[17:02:33.499] result() for ClusterFuture ... done
[17:02:33.499] result() for ClusterFuture ...
[17:02:33.500] - result already collected: FutureResult
[17:02:33.500] result() for ClusterFuture ... done
[17:02:33.500] result() for ClusterFuture ...
[17:02:33.500] - result already collected: FutureResult
[17:02:33.500] result() for ClusterFuture ... done
[17:02:33.500] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.500] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.500] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:02:33.500]  length: 2 (resolved future 4)
[17:02:33.500] signalConditionsASAP(NULL, pos=5) ...
[17:02:33.500] - nx: 6
[17:02:33.500] - relay: TRUE
[17:02:33.501] - stdout: TRUE
[17:02:33.501] - signal: TRUE
[17:02:33.501] - resignal: FALSE
[17:02:33.501] - force: TRUE
[17:02:33.501] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.501] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.501]  - until=6
[17:02:33.501]  - relaying element #6
[17:02:33.501] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:33.501] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.501] signalConditionsASAP(NULL, pos=5) ... done
[17:02:33.501]  length: 1 (resolved future 5)
[17:02:33.502] signalConditionsASAP(numeric, pos=6) ...
[17:02:33.502] - nx: 6
[17:02:33.502] - relay: TRUE
[17:02:33.502] - stdout: TRUE
[17:02:33.502] - signal: TRUE
[17:02:33.502] - resignal: FALSE
[17:02:33.502] - force: TRUE
[17:02:33.502] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:33.502] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.502]  - until=6
[17:02:33.502] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.502] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.503] signalConditionsASAP(numeric, pos=6) ... done
[17:02:33.503]  length: 0 (resolved future 6)
[17:02:33.503] Relaying remaining futures
[17:02:33.503] signalConditionsASAP(NULL, pos=0) ...
[17:02:33.503] - nx: 6
[17:02:33.503] - relay: TRUE
[17:02:33.503] - stdout: TRUE
[17:02:33.503] - signal: TRUE
[17:02:33.503] - resignal: FALSE
[17:02:33.503] - force: TRUE
[17:02:33.503] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.503] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:33.504] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.504] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.504] signalConditionsASAP(NULL, pos=0) ... done
[17:02:33.504] resolve() on list environment ... DONE
[17:02:33.504] result() for ClusterFuture ...
[17:02:33.504] - result already collected: FutureResult
[17:02:33.504] result() for ClusterFuture ... done
[17:02:33.504] result() for ClusterFuture ...
[17:02:33.504] - result already collected: FutureResult
[17:02:33.504] result() for ClusterFuture ... done
[17:02:33.505] result() for ClusterFuture ...
[17:02:33.505] - result already collected: FutureResult
[17:02:33.505] result() for ClusterFuture ... done
[17:02:33.505] result() for ClusterFuture ...
[17:02:33.505] - result already collected: FutureResult
[17:02:33.505] result() for ClusterFuture ... done
[17:02:33.505] result() for ClusterFuture ...
[17:02:33.505] - result already collected: FutureResult
[17:02:33.505] result() for ClusterFuture ... done
[17:02:33.505] result() for ClusterFuture ...
[17:02:33.506] - result already collected: FutureResult
[17:02:33.506] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c74b33fe38> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:02:33.507] getGlobalsAndPackages() ...
[17:02:33.508] Searching for globals...
[17:02:33.508] 
[17:02:33.508] Searching for globals ... DONE
[17:02:33.508] - globals: [0] <none>
[17:02:33.508] getGlobalsAndPackages() ... DONE
[17:02:33.508] run() for ‘Future’ ...
[17:02:33.509] - state: ‘created’
[17:02:33.509] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.523] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.523] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.523]   - Field: ‘node’
[17:02:33.524]   - Field: ‘label’
[17:02:33.524]   - Field: ‘local’
[17:02:33.524]   - Field: ‘owner’
[17:02:33.524]   - Field: ‘envir’
[17:02:33.524]   - Field: ‘workers’
[17:02:33.524]   - Field: ‘packages’
[17:02:33.524]   - Field: ‘gc’
[17:02:33.524]   - Field: ‘conditions’
[17:02:33.524]   - Field: ‘persistent’
[17:02:33.524]   - Field: ‘expr’
[17:02:33.524]   - Field: ‘uuid’
[17:02:33.525]   - Field: ‘seed’
[17:02:33.525]   - Field: ‘version’
[17:02:33.525]   - Field: ‘result’
[17:02:33.525]   - Field: ‘asynchronous’
[17:02:33.525]   - Field: ‘calls’
[17:02:33.525]   - Field: ‘globals’
[17:02:33.525]   - Field: ‘stdout’
[17:02:33.525]   - Field: ‘earlySignal’
[17:02:33.525]   - Field: ‘lazy’
[17:02:33.525]   - Field: ‘state’
[17:02:33.525] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.526] - Launch lazy future ...
[17:02:33.526] Packages needed by the future expression (n = 0): <none>
[17:02:33.526] Packages needed by future strategies (n = 0): <none>
[17:02:33.526] {
[17:02:33.526]     {
[17:02:33.526]         {
[17:02:33.526]             ...future.startTime <- base::Sys.time()
[17:02:33.526]             {
[17:02:33.526]                 {
[17:02:33.526]                   {
[17:02:33.526]                     {
[17:02:33.526]                       base::local({
[17:02:33.526]                         has_future <- base::requireNamespace("future", 
[17:02:33.526]                           quietly = TRUE)
[17:02:33.526]                         if (has_future) {
[17:02:33.526]                           ns <- base::getNamespace("future")
[17:02:33.526]                           version <- ns[[".package"]][["version"]]
[17:02:33.526]                           if (is.null(version)) 
[17:02:33.526]                             version <- utils::packageVersion("future")
[17:02:33.526]                         }
[17:02:33.526]                         else {
[17:02:33.526]                           version <- NULL
[17:02:33.526]                         }
[17:02:33.526]                         if (!has_future || version < "1.8.0") {
[17:02:33.526]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.526]                             "", base::R.version$version.string), 
[17:02:33.526]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.526]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.526]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.526]                               "release", "version")], collapse = " "), 
[17:02:33.526]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.526]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.526]                             info)
[17:02:33.526]                           info <- base::paste(info, collapse = "; ")
[17:02:33.526]                           if (!has_future) {
[17:02:33.526]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.526]                               info)
[17:02:33.526]                           }
[17:02:33.526]                           else {
[17:02:33.526]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.526]                               info, version)
[17:02:33.526]                           }
[17:02:33.526]                           base::stop(msg)
[17:02:33.526]                         }
[17:02:33.526]                       })
[17:02:33.526]                     }
[17:02:33.526]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.526]                     base::options(mc.cores = 1L)
[17:02:33.526]                   }
[17:02:33.526]                   ...future.strategy.old <- future::plan("list")
[17:02:33.526]                   options(future.plan = NULL)
[17:02:33.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.526]                 }
[17:02:33.526]                 ...future.workdir <- getwd()
[17:02:33.526]             }
[17:02:33.526]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.526]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.526]         }
[17:02:33.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.526]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.526]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.526]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.526]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.526]             base::names(...future.oldOptions))
[17:02:33.526]     }
[17:02:33.526]     if (FALSE) {
[17:02:33.526]     }
[17:02:33.526]     else {
[17:02:33.526]         if (TRUE) {
[17:02:33.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.526]                 open = "w")
[17:02:33.526]         }
[17:02:33.526]         else {
[17:02:33.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.526]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.526]         }
[17:02:33.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.526]             base::sink(type = "output", split = FALSE)
[17:02:33.526]             base::close(...future.stdout)
[17:02:33.526]         }, add = TRUE)
[17:02:33.526]     }
[17:02:33.526]     ...future.frame <- base::sys.nframe()
[17:02:33.526]     ...future.conditions <- base::list()
[17:02:33.526]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.526]     if (FALSE) {
[17:02:33.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.526]     }
[17:02:33.526]     ...future.result <- base::tryCatch({
[17:02:33.526]         base::withCallingHandlers({
[17:02:33.526]             ...future.value <- base::withVisible(base::local({
[17:02:33.526]                 ...future.makeSendCondition <- base::local({
[17:02:33.526]                   sendCondition <- NULL
[17:02:33.526]                   function(frame = 1L) {
[17:02:33.526]                     if (is.function(sendCondition)) 
[17:02:33.526]                       return(sendCondition)
[17:02:33.526]                     ns <- getNamespace("parallel")
[17:02:33.526]                     if (exists("sendData", mode = "function", 
[17:02:33.526]                       envir = ns)) {
[17:02:33.526]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.526]                         envir = ns)
[17:02:33.526]                       envir <- sys.frame(frame)
[17:02:33.526]                       master <- NULL
[17:02:33.526]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.526]                         !identical(envir, emptyenv())) {
[17:02:33.526]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.526]                           inherits = FALSE)) {
[17:02:33.526]                           master <- get("master", mode = "list", 
[17:02:33.526]                             envir = envir, inherits = FALSE)
[17:02:33.526]                           if (inherits(master, c("SOCKnode", 
[17:02:33.526]                             "SOCK0node"))) {
[17:02:33.526]                             sendCondition <<- function(cond) {
[17:02:33.526]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.526]                                 success = TRUE)
[17:02:33.526]                               parallel_sendData(master, data)
[17:02:33.526]                             }
[17:02:33.526]                             return(sendCondition)
[17:02:33.526]                           }
[17:02:33.526]                         }
[17:02:33.526]                         frame <- frame + 1L
[17:02:33.526]                         envir <- sys.frame(frame)
[17:02:33.526]                       }
[17:02:33.526]                     }
[17:02:33.526]                     sendCondition <<- function(cond) NULL
[17:02:33.526]                   }
[17:02:33.526]                 })
[17:02:33.526]                 withCallingHandlers({
[17:02:33.526]                   2
[17:02:33.526]                 }, immediateCondition = function(cond) {
[17:02:33.526]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.526]                   sendCondition(cond)
[17:02:33.526]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.526]                   {
[17:02:33.526]                     inherits <- base::inherits
[17:02:33.526]                     invokeRestart <- base::invokeRestart
[17:02:33.526]                     is.null <- base::is.null
[17:02:33.526]                     muffled <- FALSE
[17:02:33.526]                     if (inherits(cond, "message")) {
[17:02:33.526]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.526]                       if (muffled) 
[17:02:33.526]                         invokeRestart("muffleMessage")
[17:02:33.526]                     }
[17:02:33.526]                     else if (inherits(cond, "warning")) {
[17:02:33.526]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.526]                       if (muffled) 
[17:02:33.526]                         invokeRestart("muffleWarning")
[17:02:33.526]                     }
[17:02:33.526]                     else if (inherits(cond, "condition")) {
[17:02:33.526]                       if (!is.null(pattern)) {
[17:02:33.526]                         computeRestarts <- base::computeRestarts
[17:02:33.526]                         grepl <- base::grepl
[17:02:33.526]                         restarts <- computeRestarts(cond)
[17:02:33.526]                         for (restart in restarts) {
[17:02:33.526]                           name <- restart$name
[17:02:33.526]                           if (is.null(name)) 
[17:02:33.526]                             next
[17:02:33.526]                           if (!grepl(pattern, name)) 
[17:02:33.526]                             next
[17:02:33.526]                           invokeRestart(restart)
[17:02:33.526]                           muffled <- TRUE
[17:02:33.526]                           break
[17:02:33.526]                         }
[17:02:33.526]                       }
[17:02:33.526]                     }
[17:02:33.526]                     invisible(muffled)
[17:02:33.526]                   }
[17:02:33.526]                   muffleCondition(cond)
[17:02:33.526]                 })
[17:02:33.526]             }))
[17:02:33.526]             future::FutureResult(value = ...future.value$value, 
[17:02:33.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.526]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.526]                     ...future.globalenv.names))
[17:02:33.526]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.526]         }, condition = base::local({
[17:02:33.526]             c <- base::c
[17:02:33.526]             inherits <- base::inherits
[17:02:33.526]             invokeRestart <- base::invokeRestart
[17:02:33.526]             length <- base::length
[17:02:33.526]             list <- base::list
[17:02:33.526]             seq.int <- base::seq.int
[17:02:33.526]             signalCondition <- base::signalCondition
[17:02:33.526]             sys.calls <- base::sys.calls
[17:02:33.526]             `[[` <- base::`[[`
[17:02:33.526]             `+` <- base::`+`
[17:02:33.526]             `<<-` <- base::`<<-`
[17:02:33.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.526]                   3L)]
[17:02:33.526]             }
[17:02:33.526]             function(cond) {
[17:02:33.526]                 is_error <- inherits(cond, "error")
[17:02:33.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.526]                   NULL)
[17:02:33.526]                 if (is_error) {
[17:02:33.526]                   sessionInformation <- function() {
[17:02:33.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.526]                       search = base::search(), system = base::Sys.info())
[17:02:33.526]                   }
[17:02:33.526]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.526]                     cond$call), session = sessionInformation(), 
[17:02:33.526]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.526]                   signalCondition(cond)
[17:02:33.526]                 }
[17:02:33.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.526]                 "immediateCondition"))) {
[17:02:33.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.526]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.526]                   if (TRUE && !signal) {
[17:02:33.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.526]                     {
[17:02:33.526]                       inherits <- base::inherits
[17:02:33.526]                       invokeRestart <- base::invokeRestart
[17:02:33.526]                       is.null <- base::is.null
[17:02:33.526]                       muffled <- FALSE
[17:02:33.526]                       if (inherits(cond, "message")) {
[17:02:33.526]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.526]                         if (muffled) 
[17:02:33.526]                           invokeRestart("muffleMessage")
[17:02:33.526]                       }
[17:02:33.526]                       else if (inherits(cond, "warning")) {
[17:02:33.526]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.526]                         if (muffled) 
[17:02:33.526]                           invokeRestart("muffleWarning")
[17:02:33.526]                       }
[17:02:33.526]                       else if (inherits(cond, "condition")) {
[17:02:33.526]                         if (!is.null(pattern)) {
[17:02:33.526]                           computeRestarts <- base::computeRestarts
[17:02:33.526]                           grepl <- base::grepl
[17:02:33.526]                           restarts <- computeRestarts(cond)
[17:02:33.526]                           for (restart in restarts) {
[17:02:33.526]                             name <- restart$name
[17:02:33.526]                             if (is.null(name)) 
[17:02:33.526]                               next
[17:02:33.526]                             if (!grepl(pattern, name)) 
[17:02:33.526]                               next
[17:02:33.526]                             invokeRestart(restart)
[17:02:33.526]                             muffled <- TRUE
[17:02:33.526]                             break
[17:02:33.526]                           }
[17:02:33.526]                         }
[17:02:33.526]                       }
[17:02:33.526]                       invisible(muffled)
[17:02:33.526]                     }
[17:02:33.526]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.526]                   }
[17:02:33.526]                 }
[17:02:33.526]                 else {
[17:02:33.526]                   if (TRUE) {
[17:02:33.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.526]                     {
[17:02:33.526]                       inherits <- base::inherits
[17:02:33.526]                       invokeRestart <- base::invokeRestart
[17:02:33.526]                       is.null <- base::is.null
[17:02:33.526]                       muffled <- FALSE
[17:02:33.526]                       if (inherits(cond, "message")) {
[17:02:33.526]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.526]                         if (muffled) 
[17:02:33.526]                           invokeRestart("muffleMessage")
[17:02:33.526]                       }
[17:02:33.526]                       else if (inherits(cond, "warning")) {
[17:02:33.526]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.526]                         if (muffled) 
[17:02:33.526]                           invokeRestart("muffleWarning")
[17:02:33.526]                       }
[17:02:33.526]                       else if (inherits(cond, "condition")) {
[17:02:33.526]                         if (!is.null(pattern)) {
[17:02:33.526]                           computeRestarts <- base::computeRestarts
[17:02:33.526]                           grepl <- base::grepl
[17:02:33.526]                           restarts <- computeRestarts(cond)
[17:02:33.526]                           for (restart in restarts) {
[17:02:33.526]                             name <- restart$name
[17:02:33.526]                             if (is.null(name)) 
[17:02:33.526]                               next
[17:02:33.526]                             if (!grepl(pattern, name)) 
[17:02:33.526]                               next
[17:02:33.526]                             invokeRestart(restart)
[17:02:33.526]                             muffled <- TRUE
[17:02:33.526]                             break
[17:02:33.526]                           }
[17:02:33.526]                         }
[17:02:33.526]                       }
[17:02:33.526]                       invisible(muffled)
[17:02:33.526]                     }
[17:02:33.526]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.526]                   }
[17:02:33.526]                 }
[17:02:33.526]             }
[17:02:33.526]         }))
[17:02:33.526]     }, error = function(ex) {
[17:02:33.526]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.526]                 ...future.rng), started = ...future.startTime, 
[17:02:33.526]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.526]             version = "1.8"), class = "FutureResult")
[17:02:33.526]     }, finally = {
[17:02:33.526]         if (!identical(...future.workdir, getwd())) 
[17:02:33.526]             setwd(...future.workdir)
[17:02:33.526]         {
[17:02:33.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.526]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.526]             }
[17:02:33.526]             base::options(...future.oldOptions)
[17:02:33.526]             if (.Platform$OS.type == "windows") {
[17:02:33.526]                 old_names <- names(...future.oldEnvVars)
[17:02:33.526]                 envs <- base::Sys.getenv()
[17:02:33.526]                 names <- names(envs)
[17:02:33.526]                 common <- intersect(names, old_names)
[17:02:33.526]                 added <- setdiff(names, old_names)
[17:02:33.526]                 removed <- setdiff(old_names, names)
[17:02:33.526]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.526]                   envs[common]]
[17:02:33.526]                 NAMES <- toupper(changed)
[17:02:33.526]                 args <- list()
[17:02:33.526]                 for (kk in seq_along(NAMES)) {
[17:02:33.526]                   name <- changed[[kk]]
[17:02:33.526]                   NAME <- NAMES[[kk]]
[17:02:33.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.526]                     next
[17:02:33.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.526]                 }
[17:02:33.526]                 NAMES <- toupper(added)
[17:02:33.526]                 for (kk in seq_along(NAMES)) {
[17:02:33.526]                   name <- added[[kk]]
[17:02:33.526]                   NAME <- NAMES[[kk]]
[17:02:33.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.526]                     next
[17:02:33.526]                   args[[name]] <- ""
[17:02:33.526]                 }
[17:02:33.526]                 NAMES <- toupper(removed)
[17:02:33.526]                 for (kk in seq_along(NAMES)) {
[17:02:33.526]                   name <- removed[[kk]]
[17:02:33.526]                   NAME <- NAMES[[kk]]
[17:02:33.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.526]                     next
[17:02:33.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.526]                 }
[17:02:33.526]                 if (length(args) > 0) 
[17:02:33.526]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.526]             }
[17:02:33.526]             else {
[17:02:33.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.526]             }
[17:02:33.526]             {
[17:02:33.526]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.526]                   0L) {
[17:02:33.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.526]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.526]                   base::options(opts)
[17:02:33.526]                 }
[17:02:33.526]                 {
[17:02:33.526]                   {
[17:02:33.526]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.526]                     NULL
[17:02:33.526]                   }
[17:02:33.526]                   options(future.plan = NULL)
[17:02:33.526]                   if (is.na(NA_character_)) 
[17:02:33.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.526]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.526]                     .init = FALSE)
[17:02:33.526]                 }
[17:02:33.526]             }
[17:02:33.526]         }
[17:02:33.526]     })
[17:02:33.526]     if (TRUE) {
[17:02:33.526]         base::sink(type = "output", split = FALSE)
[17:02:33.526]         if (TRUE) {
[17:02:33.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.526]         }
[17:02:33.526]         else {
[17:02:33.526]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.526]         }
[17:02:33.526]         base::close(...future.stdout)
[17:02:33.526]         ...future.stdout <- NULL
[17:02:33.526]     }
[17:02:33.526]     ...future.result$conditions <- ...future.conditions
[17:02:33.526]     ...future.result$finished <- base::Sys.time()
[17:02:33.526]     ...future.result
[17:02:33.526] }
[17:02:33.530] MultisessionFuture started
[17:02:33.530] - Launch lazy future ... done
[17:02:33.530] run() for ‘MultisessionFuture’ ... done
[17:02:33.530] getGlobalsAndPackages() ...
[17:02:33.530] Searching for globals...
[17:02:33.531] 
[17:02:33.531] Searching for globals ... DONE
[17:02:33.531] - globals: [0] <none>
[17:02:33.531] getGlobalsAndPackages() ... DONE
[17:02:33.532] run() for ‘Future’ ...
[17:02:33.532] - state: ‘created’
[17:02:33.532] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.548] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.548]   - Field: ‘node’
[17:02:33.548]   - Field: ‘label’
[17:02:33.548]   - Field: ‘local’
[17:02:33.548]   - Field: ‘owner’
[17:02:33.548]   - Field: ‘envir’
[17:02:33.549]   - Field: ‘workers’
[17:02:33.549]   - Field: ‘packages’
[17:02:33.549]   - Field: ‘gc’
[17:02:33.549]   - Field: ‘conditions’
[17:02:33.549]   - Field: ‘persistent’
[17:02:33.549]   - Field: ‘expr’
[17:02:33.549]   - Field: ‘uuid’
[17:02:33.549]   - Field: ‘seed’
[17:02:33.549]   - Field: ‘version’
[17:02:33.549]   - Field: ‘result’
[17:02:33.549]   - Field: ‘asynchronous’
[17:02:33.550]   - Field: ‘calls’
[17:02:33.550]   - Field: ‘globals’
[17:02:33.550]   - Field: ‘stdout’
[17:02:33.550]   - Field: ‘earlySignal’
[17:02:33.550]   - Field: ‘lazy’
[17:02:33.550]   - Field: ‘state’
[17:02:33.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.550] - Launch lazy future ...
[17:02:33.550] Packages needed by the future expression (n = 0): <none>
[17:02:33.551] Packages needed by future strategies (n = 0): <none>
[17:02:33.551] {
[17:02:33.551]     {
[17:02:33.551]         {
[17:02:33.551]             ...future.startTime <- base::Sys.time()
[17:02:33.551]             {
[17:02:33.551]                 {
[17:02:33.551]                   {
[17:02:33.551]                     {
[17:02:33.551]                       base::local({
[17:02:33.551]                         has_future <- base::requireNamespace("future", 
[17:02:33.551]                           quietly = TRUE)
[17:02:33.551]                         if (has_future) {
[17:02:33.551]                           ns <- base::getNamespace("future")
[17:02:33.551]                           version <- ns[[".package"]][["version"]]
[17:02:33.551]                           if (is.null(version)) 
[17:02:33.551]                             version <- utils::packageVersion("future")
[17:02:33.551]                         }
[17:02:33.551]                         else {
[17:02:33.551]                           version <- NULL
[17:02:33.551]                         }
[17:02:33.551]                         if (!has_future || version < "1.8.0") {
[17:02:33.551]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.551]                             "", base::R.version$version.string), 
[17:02:33.551]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.551]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.551]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.551]                               "release", "version")], collapse = " "), 
[17:02:33.551]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.551]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.551]                             info)
[17:02:33.551]                           info <- base::paste(info, collapse = "; ")
[17:02:33.551]                           if (!has_future) {
[17:02:33.551]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.551]                               info)
[17:02:33.551]                           }
[17:02:33.551]                           else {
[17:02:33.551]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.551]                               info, version)
[17:02:33.551]                           }
[17:02:33.551]                           base::stop(msg)
[17:02:33.551]                         }
[17:02:33.551]                       })
[17:02:33.551]                     }
[17:02:33.551]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.551]                     base::options(mc.cores = 1L)
[17:02:33.551]                   }
[17:02:33.551]                   ...future.strategy.old <- future::plan("list")
[17:02:33.551]                   options(future.plan = NULL)
[17:02:33.551]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.551]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.551]                 }
[17:02:33.551]                 ...future.workdir <- getwd()
[17:02:33.551]             }
[17:02:33.551]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.551]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.551]         }
[17:02:33.551]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.551]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.551]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.551]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.551]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.551]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.551]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.551]             base::names(...future.oldOptions))
[17:02:33.551]     }
[17:02:33.551]     if (FALSE) {
[17:02:33.551]     }
[17:02:33.551]     else {
[17:02:33.551]         if (TRUE) {
[17:02:33.551]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.551]                 open = "w")
[17:02:33.551]         }
[17:02:33.551]         else {
[17:02:33.551]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.551]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.551]         }
[17:02:33.551]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.551]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.551]             base::sink(type = "output", split = FALSE)
[17:02:33.551]             base::close(...future.stdout)
[17:02:33.551]         }, add = TRUE)
[17:02:33.551]     }
[17:02:33.551]     ...future.frame <- base::sys.nframe()
[17:02:33.551]     ...future.conditions <- base::list()
[17:02:33.551]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.551]     if (FALSE) {
[17:02:33.551]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.551]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.551]     }
[17:02:33.551]     ...future.result <- base::tryCatch({
[17:02:33.551]         base::withCallingHandlers({
[17:02:33.551]             ...future.value <- base::withVisible(base::local({
[17:02:33.551]                 ...future.makeSendCondition <- base::local({
[17:02:33.551]                   sendCondition <- NULL
[17:02:33.551]                   function(frame = 1L) {
[17:02:33.551]                     if (is.function(sendCondition)) 
[17:02:33.551]                       return(sendCondition)
[17:02:33.551]                     ns <- getNamespace("parallel")
[17:02:33.551]                     if (exists("sendData", mode = "function", 
[17:02:33.551]                       envir = ns)) {
[17:02:33.551]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.551]                         envir = ns)
[17:02:33.551]                       envir <- sys.frame(frame)
[17:02:33.551]                       master <- NULL
[17:02:33.551]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.551]                         !identical(envir, emptyenv())) {
[17:02:33.551]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.551]                           inherits = FALSE)) {
[17:02:33.551]                           master <- get("master", mode = "list", 
[17:02:33.551]                             envir = envir, inherits = FALSE)
[17:02:33.551]                           if (inherits(master, c("SOCKnode", 
[17:02:33.551]                             "SOCK0node"))) {
[17:02:33.551]                             sendCondition <<- function(cond) {
[17:02:33.551]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.551]                                 success = TRUE)
[17:02:33.551]                               parallel_sendData(master, data)
[17:02:33.551]                             }
[17:02:33.551]                             return(sendCondition)
[17:02:33.551]                           }
[17:02:33.551]                         }
[17:02:33.551]                         frame <- frame + 1L
[17:02:33.551]                         envir <- sys.frame(frame)
[17:02:33.551]                       }
[17:02:33.551]                     }
[17:02:33.551]                     sendCondition <<- function(cond) NULL
[17:02:33.551]                   }
[17:02:33.551]                 })
[17:02:33.551]                 withCallingHandlers({
[17:02:33.551]                   NULL
[17:02:33.551]                 }, immediateCondition = function(cond) {
[17:02:33.551]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.551]                   sendCondition(cond)
[17:02:33.551]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.551]                   {
[17:02:33.551]                     inherits <- base::inherits
[17:02:33.551]                     invokeRestart <- base::invokeRestart
[17:02:33.551]                     is.null <- base::is.null
[17:02:33.551]                     muffled <- FALSE
[17:02:33.551]                     if (inherits(cond, "message")) {
[17:02:33.551]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.551]                       if (muffled) 
[17:02:33.551]                         invokeRestart("muffleMessage")
[17:02:33.551]                     }
[17:02:33.551]                     else if (inherits(cond, "warning")) {
[17:02:33.551]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.551]                       if (muffled) 
[17:02:33.551]                         invokeRestart("muffleWarning")
[17:02:33.551]                     }
[17:02:33.551]                     else if (inherits(cond, "condition")) {
[17:02:33.551]                       if (!is.null(pattern)) {
[17:02:33.551]                         computeRestarts <- base::computeRestarts
[17:02:33.551]                         grepl <- base::grepl
[17:02:33.551]                         restarts <- computeRestarts(cond)
[17:02:33.551]                         for (restart in restarts) {
[17:02:33.551]                           name <- restart$name
[17:02:33.551]                           if (is.null(name)) 
[17:02:33.551]                             next
[17:02:33.551]                           if (!grepl(pattern, name)) 
[17:02:33.551]                             next
[17:02:33.551]                           invokeRestart(restart)
[17:02:33.551]                           muffled <- TRUE
[17:02:33.551]                           break
[17:02:33.551]                         }
[17:02:33.551]                       }
[17:02:33.551]                     }
[17:02:33.551]                     invisible(muffled)
[17:02:33.551]                   }
[17:02:33.551]                   muffleCondition(cond)
[17:02:33.551]                 })
[17:02:33.551]             }))
[17:02:33.551]             future::FutureResult(value = ...future.value$value, 
[17:02:33.551]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.551]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.551]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.551]                     ...future.globalenv.names))
[17:02:33.551]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.551]         }, condition = base::local({
[17:02:33.551]             c <- base::c
[17:02:33.551]             inherits <- base::inherits
[17:02:33.551]             invokeRestart <- base::invokeRestart
[17:02:33.551]             length <- base::length
[17:02:33.551]             list <- base::list
[17:02:33.551]             seq.int <- base::seq.int
[17:02:33.551]             signalCondition <- base::signalCondition
[17:02:33.551]             sys.calls <- base::sys.calls
[17:02:33.551]             `[[` <- base::`[[`
[17:02:33.551]             `+` <- base::`+`
[17:02:33.551]             `<<-` <- base::`<<-`
[17:02:33.551]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.551]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.551]                   3L)]
[17:02:33.551]             }
[17:02:33.551]             function(cond) {
[17:02:33.551]                 is_error <- inherits(cond, "error")
[17:02:33.551]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.551]                   NULL)
[17:02:33.551]                 if (is_error) {
[17:02:33.551]                   sessionInformation <- function() {
[17:02:33.551]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.551]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.551]                       search = base::search(), system = base::Sys.info())
[17:02:33.551]                   }
[17:02:33.551]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.551]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.551]                     cond$call), session = sessionInformation(), 
[17:02:33.551]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.551]                   signalCondition(cond)
[17:02:33.551]                 }
[17:02:33.551]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.551]                 "immediateCondition"))) {
[17:02:33.551]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.551]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.551]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.551]                   if (TRUE && !signal) {
[17:02:33.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.551]                     {
[17:02:33.551]                       inherits <- base::inherits
[17:02:33.551]                       invokeRestart <- base::invokeRestart
[17:02:33.551]                       is.null <- base::is.null
[17:02:33.551]                       muffled <- FALSE
[17:02:33.551]                       if (inherits(cond, "message")) {
[17:02:33.551]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.551]                         if (muffled) 
[17:02:33.551]                           invokeRestart("muffleMessage")
[17:02:33.551]                       }
[17:02:33.551]                       else if (inherits(cond, "warning")) {
[17:02:33.551]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.551]                         if (muffled) 
[17:02:33.551]                           invokeRestart("muffleWarning")
[17:02:33.551]                       }
[17:02:33.551]                       else if (inherits(cond, "condition")) {
[17:02:33.551]                         if (!is.null(pattern)) {
[17:02:33.551]                           computeRestarts <- base::computeRestarts
[17:02:33.551]                           grepl <- base::grepl
[17:02:33.551]                           restarts <- computeRestarts(cond)
[17:02:33.551]                           for (restart in restarts) {
[17:02:33.551]                             name <- restart$name
[17:02:33.551]                             if (is.null(name)) 
[17:02:33.551]                               next
[17:02:33.551]                             if (!grepl(pattern, name)) 
[17:02:33.551]                               next
[17:02:33.551]                             invokeRestart(restart)
[17:02:33.551]                             muffled <- TRUE
[17:02:33.551]                             break
[17:02:33.551]                           }
[17:02:33.551]                         }
[17:02:33.551]                       }
[17:02:33.551]                       invisible(muffled)
[17:02:33.551]                     }
[17:02:33.551]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.551]                   }
[17:02:33.551]                 }
[17:02:33.551]                 else {
[17:02:33.551]                   if (TRUE) {
[17:02:33.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.551]                     {
[17:02:33.551]                       inherits <- base::inherits
[17:02:33.551]                       invokeRestart <- base::invokeRestart
[17:02:33.551]                       is.null <- base::is.null
[17:02:33.551]                       muffled <- FALSE
[17:02:33.551]                       if (inherits(cond, "message")) {
[17:02:33.551]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.551]                         if (muffled) 
[17:02:33.551]                           invokeRestart("muffleMessage")
[17:02:33.551]                       }
[17:02:33.551]                       else if (inherits(cond, "warning")) {
[17:02:33.551]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.551]                         if (muffled) 
[17:02:33.551]                           invokeRestart("muffleWarning")
[17:02:33.551]                       }
[17:02:33.551]                       else if (inherits(cond, "condition")) {
[17:02:33.551]                         if (!is.null(pattern)) {
[17:02:33.551]                           computeRestarts <- base::computeRestarts
[17:02:33.551]                           grepl <- base::grepl
[17:02:33.551]                           restarts <- computeRestarts(cond)
[17:02:33.551]                           for (restart in restarts) {
[17:02:33.551]                             name <- restart$name
[17:02:33.551]                             if (is.null(name)) 
[17:02:33.551]                               next
[17:02:33.551]                             if (!grepl(pattern, name)) 
[17:02:33.551]                               next
[17:02:33.551]                             invokeRestart(restart)
[17:02:33.551]                             muffled <- TRUE
[17:02:33.551]                             break
[17:02:33.551]                           }
[17:02:33.551]                         }
[17:02:33.551]                       }
[17:02:33.551]                       invisible(muffled)
[17:02:33.551]                     }
[17:02:33.551]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.551]                   }
[17:02:33.551]                 }
[17:02:33.551]             }
[17:02:33.551]         }))
[17:02:33.551]     }, error = function(ex) {
[17:02:33.551]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.551]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.551]                 ...future.rng), started = ...future.startTime, 
[17:02:33.551]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.551]             version = "1.8"), class = "FutureResult")
[17:02:33.551]     }, finally = {
[17:02:33.551]         if (!identical(...future.workdir, getwd())) 
[17:02:33.551]             setwd(...future.workdir)
[17:02:33.551]         {
[17:02:33.551]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.551]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.551]             }
[17:02:33.551]             base::options(...future.oldOptions)
[17:02:33.551]             if (.Platform$OS.type == "windows") {
[17:02:33.551]                 old_names <- names(...future.oldEnvVars)
[17:02:33.551]                 envs <- base::Sys.getenv()
[17:02:33.551]                 names <- names(envs)
[17:02:33.551]                 common <- intersect(names, old_names)
[17:02:33.551]                 added <- setdiff(names, old_names)
[17:02:33.551]                 removed <- setdiff(old_names, names)
[17:02:33.551]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.551]                   envs[common]]
[17:02:33.551]                 NAMES <- toupper(changed)
[17:02:33.551]                 args <- list()
[17:02:33.551]                 for (kk in seq_along(NAMES)) {
[17:02:33.551]                   name <- changed[[kk]]
[17:02:33.551]                   NAME <- NAMES[[kk]]
[17:02:33.551]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.551]                     next
[17:02:33.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.551]                 }
[17:02:33.551]                 NAMES <- toupper(added)
[17:02:33.551]                 for (kk in seq_along(NAMES)) {
[17:02:33.551]                   name <- added[[kk]]
[17:02:33.551]                   NAME <- NAMES[[kk]]
[17:02:33.551]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.551]                     next
[17:02:33.551]                   args[[name]] <- ""
[17:02:33.551]                 }
[17:02:33.551]                 NAMES <- toupper(removed)
[17:02:33.551]                 for (kk in seq_along(NAMES)) {
[17:02:33.551]                   name <- removed[[kk]]
[17:02:33.551]                   NAME <- NAMES[[kk]]
[17:02:33.551]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.551]                     next
[17:02:33.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.551]                 }
[17:02:33.551]                 if (length(args) > 0) 
[17:02:33.551]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.551]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.551]             }
[17:02:33.551]             else {
[17:02:33.551]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.551]             }
[17:02:33.551]             {
[17:02:33.551]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.551]                   0L) {
[17:02:33.551]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.551]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.551]                   base::options(opts)
[17:02:33.551]                 }
[17:02:33.551]                 {
[17:02:33.551]                   {
[17:02:33.551]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.551]                     NULL
[17:02:33.551]                   }
[17:02:33.551]                   options(future.plan = NULL)
[17:02:33.551]                   if (is.na(NA_character_)) 
[17:02:33.551]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.551]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.551]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.551]                     .init = FALSE)
[17:02:33.551]                 }
[17:02:33.551]             }
[17:02:33.551]         }
[17:02:33.551]     })
[17:02:33.551]     if (TRUE) {
[17:02:33.551]         base::sink(type = "output", split = FALSE)
[17:02:33.551]         if (TRUE) {
[17:02:33.551]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.551]         }
[17:02:33.551]         else {
[17:02:33.551]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.551]         }
[17:02:33.551]         base::close(...future.stdout)
[17:02:33.551]         ...future.stdout <- NULL
[17:02:33.551]     }
[17:02:33.551]     ...future.result$conditions <- ...future.conditions
[17:02:33.551]     ...future.result$finished <- base::Sys.time()
[17:02:33.551]     ...future.result
[17:02:33.551] }
[17:02:33.554] MultisessionFuture started
[17:02:33.554] - Launch lazy future ... done
[17:02:33.554] run() for ‘MultisessionFuture’ ... done
[17:02:33.555] getGlobalsAndPackages() ...
[17:02:33.555] Searching for globals...
[17:02:33.555] - globals found: [1] ‘{’
[17:02:33.556] Searching for globals ... DONE
[17:02:33.556] Resolving globals: FALSE
[17:02:33.556] 
[17:02:33.556] 
[17:02:33.556] getGlobalsAndPackages() ... DONE
[17:02:33.556] run() for ‘Future’ ...
[17:02:33.557] - state: ‘created’
[17:02:33.557] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.571] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.571] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.571]   - Field: ‘node’
[17:02:33.571]   - Field: ‘label’
[17:02:33.571]   - Field: ‘local’
[17:02:33.571]   - Field: ‘owner’
[17:02:33.571]   - Field: ‘envir’
[17:02:33.571]   - Field: ‘workers’
[17:02:33.572]   - Field: ‘packages’
[17:02:33.572]   - Field: ‘gc’
[17:02:33.572]   - Field: ‘conditions’
[17:02:33.572]   - Field: ‘persistent’
[17:02:33.572]   - Field: ‘expr’
[17:02:33.572]   - Field: ‘uuid’
[17:02:33.572]   - Field: ‘seed’
[17:02:33.572]   - Field: ‘version’
[17:02:33.572]   - Field: ‘result’
[17:02:33.572]   - Field: ‘asynchronous’
[17:02:33.573]   - Field: ‘calls’
[17:02:33.573]   - Field: ‘globals’
[17:02:33.573]   - Field: ‘stdout’
[17:02:33.573]   - Field: ‘earlySignal’
[17:02:33.573]   - Field: ‘lazy’
[17:02:33.573]   - Field: ‘state’
[17:02:33.573] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.573] - Launch lazy future ...
[17:02:33.573] Packages needed by the future expression (n = 0): <none>
[17:02:33.574] Packages needed by future strategies (n = 0): <none>
[17:02:33.574] {
[17:02:33.574]     {
[17:02:33.574]         {
[17:02:33.574]             ...future.startTime <- base::Sys.time()
[17:02:33.574]             {
[17:02:33.574]                 {
[17:02:33.574]                   {
[17:02:33.574]                     {
[17:02:33.574]                       base::local({
[17:02:33.574]                         has_future <- base::requireNamespace("future", 
[17:02:33.574]                           quietly = TRUE)
[17:02:33.574]                         if (has_future) {
[17:02:33.574]                           ns <- base::getNamespace("future")
[17:02:33.574]                           version <- ns[[".package"]][["version"]]
[17:02:33.574]                           if (is.null(version)) 
[17:02:33.574]                             version <- utils::packageVersion("future")
[17:02:33.574]                         }
[17:02:33.574]                         else {
[17:02:33.574]                           version <- NULL
[17:02:33.574]                         }
[17:02:33.574]                         if (!has_future || version < "1.8.0") {
[17:02:33.574]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.574]                             "", base::R.version$version.string), 
[17:02:33.574]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.574]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.574]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.574]                               "release", "version")], collapse = " "), 
[17:02:33.574]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.574]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.574]                             info)
[17:02:33.574]                           info <- base::paste(info, collapse = "; ")
[17:02:33.574]                           if (!has_future) {
[17:02:33.574]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.574]                               info)
[17:02:33.574]                           }
[17:02:33.574]                           else {
[17:02:33.574]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.574]                               info, version)
[17:02:33.574]                           }
[17:02:33.574]                           base::stop(msg)
[17:02:33.574]                         }
[17:02:33.574]                       })
[17:02:33.574]                     }
[17:02:33.574]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.574]                     base::options(mc.cores = 1L)
[17:02:33.574]                   }
[17:02:33.574]                   ...future.strategy.old <- future::plan("list")
[17:02:33.574]                   options(future.plan = NULL)
[17:02:33.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.574]                 }
[17:02:33.574]                 ...future.workdir <- getwd()
[17:02:33.574]             }
[17:02:33.574]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.574]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.574]         }
[17:02:33.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.574]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.574]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.574]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.574]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.574]             base::names(...future.oldOptions))
[17:02:33.574]     }
[17:02:33.574]     if (FALSE) {
[17:02:33.574]     }
[17:02:33.574]     else {
[17:02:33.574]         if (TRUE) {
[17:02:33.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.574]                 open = "w")
[17:02:33.574]         }
[17:02:33.574]         else {
[17:02:33.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.574]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.574]         }
[17:02:33.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.574]             base::sink(type = "output", split = FALSE)
[17:02:33.574]             base::close(...future.stdout)
[17:02:33.574]         }, add = TRUE)
[17:02:33.574]     }
[17:02:33.574]     ...future.frame <- base::sys.nframe()
[17:02:33.574]     ...future.conditions <- base::list()
[17:02:33.574]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.574]     if (FALSE) {
[17:02:33.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.574]     }
[17:02:33.574]     ...future.result <- base::tryCatch({
[17:02:33.574]         base::withCallingHandlers({
[17:02:33.574]             ...future.value <- base::withVisible(base::local({
[17:02:33.574]                 ...future.makeSendCondition <- base::local({
[17:02:33.574]                   sendCondition <- NULL
[17:02:33.574]                   function(frame = 1L) {
[17:02:33.574]                     if (is.function(sendCondition)) 
[17:02:33.574]                       return(sendCondition)
[17:02:33.574]                     ns <- getNamespace("parallel")
[17:02:33.574]                     if (exists("sendData", mode = "function", 
[17:02:33.574]                       envir = ns)) {
[17:02:33.574]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.574]                         envir = ns)
[17:02:33.574]                       envir <- sys.frame(frame)
[17:02:33.574]                       master <- NULL
[17:02:33.574]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.574]                         !identical(envir, emptyenv())) {
[17:02:33.574]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.574]                           inherits = FALSE)) {
[17:02:33.574]                           master <- get("master", mode = "list", 
[17:02:33.574]                             envir = envir, inherits = FALSE)
[17:02:33.574]                           if (inherits(master, c("SOCKnode", 
[17:02:33.574]                             "SOCK0node"))) {
[17:02:33.574]                             sendCondition <<- function(cond) {
[17:02:33.574]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.574]                                 success = TRUE)
[17:02:33.574]                               parallel_sendData(master, data)
[17:02:33.574]                             }
[17:02:33.574]                             return(sendCondition)
[17:02:33.574]                           }
[17:02:33.574]                         }
[17:02:33.574]                         frame <- frame + 1L
[17:02:33.574]                         envir <- sys.frame(frame)
[17:02:33.574]                       }
[17:02:33.574]                     }
[17:02:33.574]                     sendCondition <<- function(cond) NULL
[17:02:33.574]                   }
[17:02:33.574]                 })
[17:02:33.574]                 withCallingHandlers({
[17:02:33.574]                   {
[17:02:33.574]                     4
[17:02:33.574]                   }
[17:02:33.574]                 }, immediateCondition = function(cond) {
[17:02:33.574]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.574]                   sendCondition(cond)
[17:02:33.574]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.574]                   {
[17:02:33.574]                     inherits <- base::inherits
[17:02:33.574]                     invokeRestart <- base::invokeRestart
[17:02:33.574]                     is.null <- base::is.null
[17:02:33.574]                     muffled <- FALSE
[17:02:33.574]                     if (inherits(cond, "message")) {
[17:02:33.574]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.574]                       if (muffled) 
[17:02:33.574]                         invokeRestart("muffleMessage")
[17:02:33.574]                     }
[17:02:33.574]                     else if (inherits(cond, "warning")) {
[17:02:33.574]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.574]                       if (muffled) 
[17:02:33.574]                         invokeRestart("muffleWarning")
[17:02:33.574]                     }
[17:02:33.574]                     else if (inherits(cond, "condition")) {
[17:02:33.574]                       if (!is.null(pattern)) {
[17:02:33.574]                         computeRestarts <- base::computeRestarts
[17:02:33.574]                         grepl <- base::grepl
[17:02:33.574]                         restarts <- computeRestarts(cond)
[17:02:33.574]                         for (restart in restarts) {
[17:02:33.574]                           name <- restart$name
[17:02:33.574]                           if (is.null(name)) 
[17:02:33.574]                             next
[17:02:33.574]                           if (!grepl(pattern, name)) 
[17:02:33.574]                             next
[17:02:33.574]                           invokeRestart(restart)
[17:02:33.574]                           muffled <- TRUE
[17:02:33.574]                           break
[17:02:33.574]                         }
[17:02:33.574]                       }
[17:02:33.574]                     }
[17:02:33.574]                     invisible(muffled)
[17:02:33.574]                   }
[17:02:33.574]                   muffleCondition(cond)
[17:02:33.574]                 })
[17:02:33.574]             }))
[17:02:33.574]             future::FutureResult(value = ...future.value$value, 
[17:02:33.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.574]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.574]                     ...future.globalenv.names))
[17:02:33.574]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.574]         }, condition = base::local({
[17:02:33.574]             c <- base::c
[17:02:33.574]             inherits <- base::inherits
[17:02:33.574]             invokeRestart <- base::invokeRestart
[17:02:33.574]             length <- base::length
[17:02:33.574]             list <- base::list
[17:02:33.574]             seq.int <- base::seq.int
[17:02:33.574]             signalCondition <- base::signalCondition
[17:02:33.574]             sys.calls <- base::sys.calls
[17:02:33.574]             `[[` <- base::`[[`
[17:02:33.574]             `+` <- base::`+`
[17:02:33.574]             `<<-` <- base::`<<-`
[17:02:33.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.574]                   3L)]
[17:02:33.574]             }
[17:02:33.574]             function(cond) {
[17:02:33.574]                 is_error <- inherits(cond, "error")
[17:02:33.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.574]                   NULL)
[17:02:33.574]                 if (is_error) {
[17:02:33.574]                   sessionInformation <- function() {
[17:02:33.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.574]                       search = base::search(), system = base::Sys.info())
[17:02:33.574]                   }
[17:02:33.574]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.574]                     cond$call), session = sessionInformation(), 
[17:02:33.574]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.574]                   signalCondition(cond)
[17:02:33.574]                 }
[17:02:33.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.574]                 "immediateCondition"))) {
[17:02:33.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.574]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.574]                   if (TRUE && !signal) {
[17:02:33.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.574]                     {
[17:02:33.574]                       inherits <- base::inherits
[17:02:33.574]                       invokeRestart <- base::invokeRestart
[17:02:33.574]                       is.null <- base::is.null
[17:02:33.574]                       muffled <- FALSE
[17:02:33.574]                       if (inherits(cond, "message")) {
[17:02:33.574]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.574]                         if (muffled) 
[17:02:33.574]                           invokeRestart("muffleMessage")
[17:02:33.574]                       }
[17:02:33.574]                       else if (inherits(cond, "warning")) {
[17:02:33.574]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.574]                         if (muffled) 
[17:02:33.574]                           invokeRestart("muffleWarning")
[17:02:33.574]                       }
[17:02:33.574]                       else if (inherits(cond, "condition")) {
[17:02:33.574]                         if (!is.null(pattern)) {
[17:02:33.574]                           computeRestarts <- base::computeRestarts
[17:02:33.574]                           grepl <- base::grepl
[17:02:33.574]                           restarts <- computeRestarts(cond)
[17:02:33.574]                           for (restart in restarts) {
[17:02:33.574]                             name <- restart$name
[17:02:33.574]                             if (is.null(name)) 
[17:02:33.574]                               next
[17:02:33.574]                             if (!grepl(pattern, name)) 
[17:02:33.574]                               next
[17:02:33.574]                             invokeRestart(restart)
[17:02:33.574]                             muffled <- TRUE
[17:02:33.574]                             break
[17:02:33.574]                           }
[17:02:33.574]                         }
[17:02:33.574]                       }
[17:02:33.574]                       invisible(muffled)
[17:02:33.574]                     }
[17:02:33.574]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.574]                   }
[17:02:33.574]                 }
[17:02:33.574]                 else {
[17:02:33.574]                   if (TRUE) {
[17:02:33.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.574]                     {
[17:02:33.574]                       inherits <- base::inherits
[17:02:33.574]                       invokeRestart <- base::invokeRestart
[17:02:33.574]                       is.null <- base::is.null
[17:02:33.574]                       muffled <- FALSE
[17:02:33.574]                       if (inherits(cond, "message")) {
[17:02:33.574]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.574]                         if (muffled) 
[17:02:33.574]                           invokeRestart("muffleMessage")
[17:02:33.574]                       }
[17:02:33.574]                       else if (inherits(cond, "warning")) {
[17:02:33.574]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.574]                         if (muffled) 
[17:02:33.574]                           invokeRestart("muffleWarning")
[17:02:33.574]                       }
[17:02:33.574]                       else if (inherits(cond, "condition")) {
[17:02:33.574]                         if (!is.null(pattern)) {
[17:02:33.574]                           computeRestarts <- base::computeRestarts
[17:02:33.574]                           grepl <- base::grepl
[17:02:33.574]                           restarts <- computeRestarts(cond)
[17:02:33.574]                           for (restart in restarts) {
[17:02:33.574]                             name <- restart$name
[17:02:33.574]                             if (is.null(name)) 
[17:02:33.574]                               next
[17:02:33.574]                             if (!grepl(pattern, name)) 
[17:02:33.574]                               next
[17:02:33.574]                             invokeRestart(restart)
[17:02:33.574]                             muffled <- TRUE
[17:02:33.574]                             break
[17:02:33.574]                           }
[17:02:33.574]                         }
[17:02:33.574]                       }
[17:02:33.574]                       invisible(muffled)
[17:02:33.574]                     }
[17:02:33.574]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.574]                   }
[17:02:33.574]                 }
[17:02:33.574]             }
[17:02:33.574]         }))
[17:02:33.574]     }, error = function(ex) {
[17:02:33.574]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.574]                 ...future.rng), started = ...future.startTime, 
[17:02:33.574]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.574]             version = "1.8"), class = "FutureResult")
[17:02:33.574]     }, finally = {
[17:02:33.574]         if (!identical(...future.workdir, getwd())) 
[17:02:33.574]             setwd(...future.workdir)
[17:02:33.574]         {
[17:02:33.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.574]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.574]             }
[17:02:33.574]             base::options(...future.oldOptions)
[17:02:33.574]             if (.Platform$OS.type == "windows") {
[17:02:33.574]                 old_names <- names(...future.oldEnvVars)
[17:02:33.574]                 envs <- base::Sys.getenv()
[17:02:33.574]                 names <- names(envs)
[17:02:33.574]                 common <- intersect(names, old_names)
[17:02:33.574]                 added <- setdiff(names, old_names)
[17:02:33.574]                 removed <- setdiff(old_names, names)
[17:02:33.574]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.574]                   envs[common]]
[17:02:33.574]                 NAMES <- toupper(changed)
[17:02:33.574]                 args <- list()
[17:02:33.574]                 for (kk in seq_along(NAMES)) {
[17:02:33.574]                   name <- changed[[kk]]
[17:02:33.574]                   NAME <- NAMES[[kk]]
[17:02:33.574]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.574]                     next
[17:02:33.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.574]                 }
[17:02:33.574]                 NAMES <- toupper(added)
[17:02:33.574]                 for (kk in seq_along(NAMES)) {
[17:02:33.574]                   name <- added[[kk]]
[17:02:33.574]                   NAME <- NAMES[[kk]]
[17:02:33.574]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.574]                     next
[17:02:33.574]                   args[[name]] <- ""
[17:02:33.574]                 }
[17:02:33.574]                 NAMES <- toupper(removed)
[17:02:33.574]                 for (kk in seq_along(NAMES)) {
[17:02:33.574]                   name <- removed[[kk]]
[17:02:33.574]                   NAME <- NAMES[[kk]]
[17:02:33.574]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.574]                     next
[17:02:33.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.574]                 }
[17:02:33.574]                 if (length(args) > 0) 
[17:02:33.574]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.574]             }
[17:02:33.574]             else {
[17:02:33.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.574]             }
[17:02:33.574]             {
[17:02:33.574]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.574]                   0L) {
[17:02:33.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.574]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.574]                   base::options(opts)
[17:02:33.574]                 }
[17:02:33.574]                 {
[17:02:33.574]                   {
[17:02:33.574]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.574]                     NULL
[17:02:33.574]                   }
[17:02:33.574]                   options(future.plan = NULL)
[17:02:33.574]                   if (is.na(NA_character_)) 
[17:02:33.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.574]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.574]                     .init = FALSE)
[17:02:33.574]                 }
[17:02:33.574]             }
[17:02:33.574]         }
[17:02:33.574]     })
[17:02:33.574]     if (TRUE) {
[17:02:33.574]         base::sink(type = "output", split = FALSE)
[17:02:33.574]         if (TRUE) {
[17:02:33.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.574]         }
[17:02:33.574]         else {
[17:02:33.574]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.574]         }
[17:02:33.574]         base::close(...future.stdout)
[17:02:33.574]         ...future.stdout <- NULL
[17:02:33.574]     }
[17:02:33.574]     ...future.result$conditions <- ...future.conditions
[17:02:33.574]     ...future.result$finished <- base::Sys.time()
[17:02:33.574]     ...future.result
[17:02:33.574] }
[17:02:33.576] Poll #1 (0): usedNodes() = 2, workers = 2
[17:02:33.587] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.587] - Validating connection of MultisessionFuture
[17:02:33.588] - received message: FutureResult
[17:02:33.588] - Received FutureResult
[17:02:33.588] - Erased future from FutureRegistry
[17:02:33.588] result() for ClusterFuture ...
[17:02:33.588] - result already collected: FutureResult
[17:02:33.588] result() for ClusterFuture ... done
[17:02:33.588] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:33.588] result() for ClusterFuture ...
[17:02:33.588] - result already collected: FutureResult
[17:02:33.588] result() for ClusterFuture ... done
[17:02:33.589] result() for ClusterFuture ...
[17:02:33.589] - result already collected: FutureResult
[17:02:33.589] result() for ClusterFuture ... done
[17:02:33.590] MultisessionFuture started
[17:02:33.590] - Launch lazy future ... done
[17:02:33.590] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c749625210> 
Classes 'listenv', 'environment' <environment: 0x55c74aa5bb80> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:02:33.594] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.594] - Validating connection of MultisessionFuture
[17:02:33.595] - received message: FutureResult
[17:02:33.595] - Received FutureResult
[17:02:33.595] - Erased future from FutureRegistry
[17:02:33.595] result() for ClusterFuture ...
[17:02:33.595] - result already collected: FutureResult
[17:02:33.595] result() for ClusterFuture ... done
[17:02:33.595] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:33.596] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.596] - Validating connection of MultisessionFuture
[17:02:33.596] - received message: FutureResult
[17:02:33.596] - Received FutureResult
[17:02:33.596] - Erased future from FutureRegistry
[17:02:33.596] result() for ClusterFuture ...
[17:02:33.596] - result already collected: FutureResult
[17:02:33.596] result() for ClusterFuture ... done
[17:02:33.596] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:33.599] resolve() on list environment ...
[17:02:33.599]  recursive: 0
[17:02:33.600]  length: 6
[17:02:33.600]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:33.600] signalConditionsASAP(numeric, pos=1) ...
[17:02:33.600] - nx: 6
[17:02:33.600] - relay: TRUE
[17:02:33.601] - stdout: TRUE
[17:02:33.601] - signal: TRUE
[17:02:33.601] - resignal: FALSE
[17:02:33.601] - force: TRUE
[17:02:33.601] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.601] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.601]  - until=2
[17:02:33.601]  - relaying element #2
[17:02:33.601] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.601] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.601] signalConditionsASAP(NULL, pos=1) ... done
[17:02:33.602]  length: 5 (resolved future 1)
[17:02:33.602] Future #2
[17:02:33.602] result() for ClusterFuture ...
[17:02:33.602] - result already collected: FutureResult
[17:02:33.602] result() for ClusterFuture ... done
[17:02:33.602] result() for ClusterFuture ...
[17:02:33.602] - result already collected: FutureResult
[17:02:33.602] result() for ClusterFuture ... done
[17:02:33.602] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:33.602] - nx: 6
[17:02:33.602] - relay: TRUE
[17:02:33.603] - stdout: TRUE
[17:02:33.603] - signal: TRUE
[17:02:33.603] - resignal: FALSE
[17:02:33.603] - force: TRUE
[17:02:33.603] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.603] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.603]  - until=2
[17:02:33.603]  - relaying element #2
[17:02:33.603] result() for ClusterFuture ...
[17:02:33.603] - result already collected: FutureResult
[17:02:33.603] result() for ClusterFuture ... done
[17:02:33.604] result() for ClusterFuture ...
[17:02:33.604] - result already collected: FutureResult
[17:02:33.604] result() for ClusterFuture ... done
[17:02:33.604] result() for ClusterFuture ...
[17:02:33.604] - result already collected: FutureResult
[17:02:33.604] result() for ClusterFuture ... done
[17:02:33.604] result() for ClusterFuture ...
[17:02:33.604] - result already collected: FutureResult
[17:02:33.604] result() for ClusterFuture ... done
[17:02:33.604] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.604] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.604] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:33.605]  length: 4 (resolved future 2)
[17:02:33.605] Future #3
[17:02:33.605] result() for ClusterFuture ...
[17:02:33.605] - result already collected: FutureResult
[17:02:33.605] result() for ClusterFuture ... done
[17:02:33.605] result() for ClusterFuture ...
[17:02:33.605] - result already collected: FutureResult
[17:02:33.605] result() for ClusterFuture ... done
[17:02:33.605] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:33.605] - nx: 6
[17:02:33.605] - relay: TRUE
[17:02:33.606] - stdout: TRUE
[17:02:33.606] - signal: TRUE
[17:02:33.606] - resignal: FALSE
[17:02:33.606] - force: TRUE
[17:02:33.606] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.606] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.606]  - until=3
[17:02:33.606]  - relaying element #3
[17:02:33.606] result() for ClusterFuture ...
[17:02:33.606] - result already collected: FutureResult
[17:02:33.606] result() for ClusterFuture ... done
[17:02:33.606] result() for ClusterFuture ...
[17:02:33.607] - result already collected: FutureResult
[17:02:33.607] result() for ClusterFuture ... done
[17:02:33.607] result() for ClusterFuture ...
[17:02:33.607] - result already collected: FutureResult
[17:02:33.607] result() for ClusterFuture ... done
[17:02:33.607] result() for ClusterFuture ...
[17:02:33.607] - result already collected: FutureResult
[17:02:33.607] result() for ClusterFuture ... done
[17:02:33.607] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.607] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.607] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:33.608]  length: 3 (resolved future 3)
[17:02:33.608] Future #4
[17:02:33.608] result() for ClusterFuture ...
[17:02:33.608] - result already collected: FutureResult
[17:02:33.608] result() for ClusterFuture ... done
[17:02:33.608] result() for ClusterFuture ...
[17:02:33.608] - result already collected: FutureResult
[17:02:33.608] result() for ClusterFuture ... done
[17:02:33.608] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:02:33.608] - nx: 6
[17:02:33.608] - relay: TRUE
[17:02:33.609] - stdout: TRUE
[17:02:33.609] - signal: TRUE
[17:02:33.609] - resignal: FALSE
[17:02:33.609] - force: TRUE
[17:02:33.609] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.609] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.609]  - until=4
[17:02:33.609]  - relaying element #4
[17:02:33.609] result() for ClusterFuture ...
[17:02:33.609] - result already collected: FutureResult
[17:02:33.609] result() for ClusterFuture ... done
[17:02:33.609] result() for ClusterFuture ...
[17:02:33.610] - result already collected: FutureResult
[17:02:33.610] result() for ClusterFuture ... done
[17:02:33.610] result() for ClusterFuture ...
[17:02:33.610] - result already collected: FutureResult
[17:02:33.610] result() for ClusterFuture ... done
[17:02:33.610] result() for ClusterFuture ...
[17:02:33.610] - result already collected: FutureResult
[17:02:33.610] result() for ClusterFuture ... done
[17:02:33.610] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.610] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.610] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:02:33.611]  length: 2 (resolved future 4)
[17:02:33.611] signalConditionsASAP(NULL, pos=5) ...
[17:02:33.611] - nx: 6
[17:02:33.611] - relay: TRUE
[17:02:33.611] - stdout: TRUE
[17:02:33.611] - signal: TRUE
[17:02:33.611] - resignal: FALSE
[17:02:33.611] - force: TRUE
[17:02:33.611] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.611] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.611]  - until=6
[17:02:33.612]  - relaying element #6
[17:02:33.612] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:33.612] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.612] signalConditionsASAP(NULL, pos=5) ... done
[17:02:33.612]  length: 1 (resolved future 5)
[17:02:33.612] signalConditionsASAP(numeric, pos=6) ...
[17:02:33.612] - nx: 6
[17:02:33.612] - relay: TRUE
[17:02:33.612] - stdout: TRUE
[17:02:33.612] - signal: TRUE
[17:02:33.612] - resignal: FALSE
[17:02:33.612] - force: TRUE
[17:02:33.613] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:33.613] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.613]  - until=6
[17:02:33.613] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.613] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.613] signalConditionsASAP(numeric, pos=6) ... done
[17:02:33.613]  length: 0 (resolved future 6)
[17:02:33.613] Relaying remaining futures
[17:02:33.613] signalConditionsASAP(NULL, pos=0) ...
[17:02:33.613] - nx: 6
[17:02:33.613] - relay: TRUE
[17:02:33.613] - stdout: TRUE
[17:02:33.614] - signal: TRUE
[17:02:33.614] - resignal: FALSE
[17:02:33.614] - force: TRUE
[17:02:33.614] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.614] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:33.614] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.614] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.614] signalConditionsASAP(NULL, pos=0) ... done
[17:02:33.614] resolve() on list environment ... DONE
[17:02:33.614] result() for ClusterFuture ...
[17:02:33.617] - result already collected: FutureResult
[17:02:33.617] result() for ClusterFuture ... done
[17:02:33.618] result() for ClusterFuture ...
[17:02:33.618] - result already collected: FutureResult
[17:02:33.618] result() for ClusterFuture ... done
[17:02:33.618] result() for ClusterFuture ...
[17:02:33.618] - result already collected: FutureResult
[17:02:33.618] result() for ClusterFuture ... done
[17:02:33.618] result() for ClusterFuture ...
[17:02:33.618] - result already collected: FutureResult
[17:02:33.618] result() for ClusterFuture ... done
[17:02:33.619] result() for ClusterFuture ...
[17:02:33.619] - result already collected: FutureResult
[17:02:33.619] result() for ClusterFuture ... done
[17:02:33.619] result() for ClusterFuture ...
[17:02:33.619] - result already collected: FutureResult
[17:02:33.619] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c74aef9e60> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:02:33.621] getGlobalsAndPackages() ...
[17:02:33.621] Searching for globals...
[17:02:33.622] 
[17:02:33.622] Searching for globals ... DONE
[17:02:33.622] - globals: [0] <none>
[17:02:33.622] getGlobalsAndPackages() ... DONE
[17:02:33.622] run() for ‘Future’ ...
[17:02:33.622] - state: ‘created’
[17:02:33.622] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.636] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.637] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.637]   - Field: ‘node’
[17:02:33.637]   - Field: ‘label’
[17:02:33.637]   - Field: ‘local’
[17:02:33.637]   - Field: ‘owner’
[17:02:33.637]   - Field: ‘envir’
[17:02:33.637]   - Field: ‘workers’
[17:02:33.637]   - Field: ‘packages’
[17:02:33.637]   - Field: ‘gc’
[17:02:33.637]   - Field: ‘conditions’
[17:02:33.637]   - Field: ‘persistent’
[17:02:33.638]   - Field: ‘expr’
[17:02:33.638]   - Field: ‘uuid’
[17:02:33.638]   - Field: ‘seed’
[17:02:33.638]   - Field: ‘version’
[17:02:33.638]   - Field: ‘result’
[17:02:33.638]   - Field: ‘asynchronous’
[17:02:33.638]   - Field: ‘calls’
[17:02:33.638]   - Field: ‘globals’
[17:02:33.638]   - Field: ‘stdout’
[17:02:33.638]   - Field: ‘earlySignal’
[17:02:33.638]   - Field: ‘lazy’
[17:02:33.638]   - Field: ‘state’
[17:02:33.639] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.639] - Launch lazy future ...
[17:02:33.639] Packages needed by the future expression (n = 0): <none>
[17:02:33.639] Packages needed by future strategies (n = 0): <none>
[17:02:33.640] {
[17:02:33.640]     {
[17:02:33.640]         {
[17:02:33.640]             ...future.startTime <- base::Sys.time()
[17:02:33.640]             {
[17:02:33.640]                 {
[17:02:33.640]                   {
[17:02:33.640]                     {
[17:02:33.640]                       base::local({
[17:02:33.640]                         has_future <- base::requireNamespace("future", 
[17:02:33.640]                           quietly = TRUE)
[17:02:33.640]                         if (has_future) {
[17:02:33.640]                           ns <- base::getNamespace("future")
[17:02:33.640]                           version <- ns[[".package"]][["version"]]
[17:02:33.640]                           if (is.null(version)) 
[17:02:33.640]                             version <- utils::packageVersion("future")
[17:02:33.640]                         }
[17:02:33.640]                         else {
[17:02:33.640]                           version <- NULL
[17:02:33.640]                         }
[17:02:33.640]                         if (!has_future || version < "1.8.0") {
[17:02:33.640]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.640]                             "", base::R.version$version.string), 
[17:02:33.640]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.640]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.640]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.640]                               "release", "version")], collapse = " "), 
[17:02:33.640]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.640]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.640]                             info)
[17:02:33.640]                           info <- base::paste(info, collapse = "; ")
[17:02:33.640]                           if (!has_future) {
[17:02:33.640]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.640]                               info)
[17:02:33.640]                           }
[17:02:33.640]                           else {
[17:02:33.640]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.640]                               info, version)
[17:02:33.640]                           }
[17:02:33.640]                           base::stop(msg)
[17:02:33.640]                         }
[17:02:33.640]                       })
[17:02:33.640]                     }
[17:02:33.640]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.640]                     base::options(mc.cores = 1L)
[17:02:33.640]                   }
[17:02:33.640]                   ...future.strategy.old <- future::plan("list")
[17:02:33.640]                   options(future.plan = NULL)
[17:02:33.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.640]                 }
[17:02:33.640]                 ...future.workdir <- getwd()
[17:02:33.640]             }
[17:02:33.640]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.640]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.640]         }
[17:02:33.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.640]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.640]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.640]             base::names(...future.oldOptions))
[17:02:33.640]     }
[17:02:33.640]     if (FALSE) {
[17:02:33.640]     }
[17:02:33.640]     else {
[17:02:33.640]         if (TRUE) {
[17:02:33.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.640]                 open = "w")
[17:02:33.640]         }
[17:02:33.640]         else {
[17:02:33.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.640]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.640]         }
[17:02:33.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.640]             base::sink(type = "output", split = FALSE)
[17:02:33.640]             base::close(...future.stdout)
[17:02:33.640]         }, add = TRUE)
[17:02:33.640]     }
[17:02:33.640]     ...future.frame <- base::sys.nframe()
[17:02:33.640]     ...future.conditions <- base::list()
[17:02:33.640]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.640]     if (FALSE) {
[17:02:33.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.640]     }
[17:02:33.640]     ...future.result <- base::tryCatch({
[17:02:33.640]         base::withCallingHandlers({
[17:02:33.640]             ...future.value <- base::withVisible(base::local({
[17:02:33.640]                 ...future.makeSendCondition <- base::local({
[17:02:33.640]                   sendCondition <- NULL
[17:02:33.640]                   function(frame = 1L) {
[17:02:33.640]                     if (is.function(sendCondition)) 
[17:02:33.640]                       return(sendCondition)
[17:02:33.640]                     ns <- getNamespace("parallel")
[17:02:33.640]                     if (exists("sendData", mode = "function", 
[17:02:33.640]                       envir = ns)) {
[17:02:33.640]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.640]                         envir = ns)
[17:02:33.640]                       envir <- sys.frame(frame)
[17:02:33.640]                       master <- NULL
[17:02:33.640]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.640]                         !identical(envir, emptyenv())) {
[17:02:33.640]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.640]                           inherits = FALSE)) {
[17:02:33.640]                           master <- get("master", mode = "list", 
[17:02:33.640]                             envir = envir, inherits = FALSE)
[17:02:33.640]                           if (inherits(master, c("SOCKnode", 
[17:02:33.640]                             "SOCK0node"))) {
[17:02:33.640]                             sendCondition <<- function(cond) {
[17:02:33.640]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.640]                                 success = TRUE)
[17:02:33.640]                               parallel_sendData(master, data)
[17:02:33.640]                             }
[17:02:33.640]                             return(sendCondition)
[17:02:33.640]                           }
[17:02:33.640]                         }
[17:02:33.640]                         frame <- frame + 1L
[17:02:33.640]                         envir <- sys.frame(frame)
[17:02:33.640]                       }
[17:02:33.640]                     }
[17:02:33.640]                     sendCondition <<- function(cond) NULL
[17:02:33.640]                   }
[17:02:33.640]                 })
[17:02:33.640]                 withCallingHandlers({
[17:02:33.640]                   2
[17:02:33.640]                 }, immediateCondition = function(cond) {
[17:02:33.640]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.640]                   sendCondition(cond)
[17:02:33.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.640]                   {
[17:02:33.640]                     inherits <- base::inherits
[17:02:33.640]                     invokeRestart <- base::invokeRestart
[17:02:33.640]                     is.null <- base::is.null
[17:02:33.640]                     muffled <- FALSE
[17:02:33.640]                     if (inherits(cond, "message")) {
[17:02:33.640]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.640]                       if (muffled) 
[17:02:33.640]                         invokeRestart("muffleMessage")
[17:02:33.640]                     }
[17:02:33.640]                     else if (inherits(cond, "warning")) {
[17:02:33.640]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.640]                       if (muffled) 
[17:02:33.640]                         invokeRestart("muffleWarning")
[17:02:33.640]                     }
[17:02:33.640]                     else if (inherits(cond, "condition")) {
[17:02:33.640]                       if (!is.null(pattern)) {
[17:02:33.640]                         computeRestarts <- base::computeRestarts
[17:02:33.640]                         grepl <- base::grepl
[17:02:33.640]                         restarts <- computeRestarts(cond)
[17:02:33.640]                         for (restart in restarts) {
[17:02:33.640]                           name <- restart$name
[17:02:33.640]                           if (is.null(name)) 
[17:02:33.640]                             next
[17:02:33.640]                           if (!grepl(pattern, name)) 
[17:02:33.640]                             next
[17:02:33.640]                           invokeRestart(restart)
[17:02:33.640]                           muffled <- TRUE
[17:02:33.640]                           break
[17:02:33.640]                         }
[17:02:33.640]                       }
[17:02:33.640]                     }
[17:02:33.640]                     invisible(muffled)
[17:02:33.640]                   }
[17:02:33.640]                   muffleCondition(cond)
[17:02:33.640]                 })
[17:02:33.640]             }))
[17:02:33.640]             future::FutureResult(value = ...future.value$value, 
[17:02:33.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.640]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.640]                     ...future.globalenv.names))
[17:02:33.640]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.640]         }, condition = base::local({
[17:02:33.640]             c <- base::c
[17:02:33.640]             inherits <- base::inherits
[17:02:33.640]             invokeRestart <- base::invokeRestart
[17:02:33.640]             length <- base::length
[17:02:33.640]             list <- base::list
[17:02:33.640]             seq.int <- base::seq.int
[17:02:33.640]             signalCondition <- base::signalCondition
[17:02:33.640]             sys.calls <- base::sys.calls
[17:02:33.640]             `[[` <- base::`[[`
[17:02:33.640]             `+` <- base::`+`
[17:02:33.640]             `<<-` <- base::`<<-`
[17:02:33.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.640]                   3L)]
[17:02:33.640]             }
[17:02:33.640]             function(cond) {
[17:02:33.640]                 is_error <- inherits(cond, "error")
[17:02:33.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.640]                   NULL)
[17:02:33.640]                 if (is_error) {
[17:02:33.640]                   sessionInformation <- function() {
[17:02:33.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.640]                       search = base::search(), system = base::Sys.info())
[17:02:33.640]                   }
[17:02:33.640]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.640]                     cond$call), session = sessionInformation(), 
[17:02:33.640]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.640]                   signalCondition(cond)
[17:02:33.640]                 }
[17:02:33.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.640]                 "immediateCondition"))) {
[17:02:33.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.640]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.640]                   if (TRUE && !signal) {
[17:02:33.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.640]                     {
[17:02:33.640]                       inherits <- base::inherits
[17:02:33.640]                       invokeRestart <- base::invokeRestart
[17:02:33.640]                       is.null <- base::is.null
[17:02:33.640]                       muffled <- FALSE
[17:02:33.640]                       if (inherits(cond, "message")) {
[17:02:33.640]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.640]                         if (muffled) 
[17:02:33.640]                           invokeRestart("muffleMessage")
[17:02:33.640]                       }
[17:02:33.640]                       else if (inherits(cond, "warning")) {
[17:02:33.640]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.640]                         if (muffled) 
[17:02:33.640]                           invokeRestart("muffleWarning")
[17:02:33.640]                       }
[17:02:33.640]                       else if (inherits(cond, "condition")) {
[17:02:33.640]                         if (!is.null(pattern)) {
[17:02:33.640]                           computeRestarts <- base::computeRestarts
[17:02:33.640]                           grepl <- base::grepl
[17:02:33.640]                           restarts <- computeRestarts(cond)
[17:02:33.640]                           for (restart in restarts) {
[17:02:33.640]                             name <- restart$name
[17:02:33.640]                             if (is.null(name)) 
[17:02:33.640]                               next
[17:02:33.640]                             if (!grepl(pattern, name)) 
[17:02:33.640]                               next
[17:02:33.640]                             invokeRestart(restart)
[17:02:33.640]                             muffled <- TRUE
[17:02:33.640]                             break
[17:02:33.640]                           }
[17:02:33.640]                         }
[17:02:33.640]                       }
[17:02:33.640]                       invisible(muffled)
[17:02:33.640]                     }
[17:02:33.640]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.640]                   }
[17:02:33.640]                 }
[17:02:33.640]                 else {
[17:02:33.640]                   if (TRUE) {
[17:02:33.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.640]                     {
[17:02:33.640]                       inherits <- base::inherits
[17:02:33.640]                       invokeRestart <- base::invokeRestart
[17:02:33.640]                       is.null <- base::is.null
[17:02:33.640]                       muffled <- FALSE
[17:02:33.640]                       if (inherits(cond, "message")) {
[17:02:33.640]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.640]                         if (muffled) 
[17:02:33.640]                           invokeRestart("muffleMessage")
[17:02:33.640]                       }
[17:02:33.640]                       else if (inherits(cond, "warning")) {
[17:02:33.640]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.640]                         if (muffled) 
[17:02:33.640]                           invokeRestart("muffleWarning")
[17:02:33.640]                       }
[17:02:33.640]                       else if (inherits(cond, "condition")) {
[17:02:33.640]                         if (!is.null(pattern)) {
[17:02:33.640]                           computeRestarts <- base::computeRestarts
[17:02:33.640]                           grepl <- base::grepl
[17:02:33.640]                           restarts <- computeRestarts(cond)
[17:02:33.640]                           for (restart in restarts) {
[17:02:33.640]                             name <- restart$name
[17:02:33.640]                             if (is.null(name)) 
[17:02:33.640]                               next
[17:02:33.640]                             if (!grepl(pattern, name)) 
[17:02:33.640]                               next
[17:02:33.640]                             invokeRestart(restart)
[17:02:33.640]                             muffled <- TRUE
[17:02:33.640]                             break
[17:02:33.640]                           }
[17:02:33.640]                         }
[17:02:33.640]                       }
[17:02:33.640]                       invisible(muffled)
[17:02:33.640]                     }
[17:02:33.640]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.640]                   }
[17:02:33.640]                 }
[17:02:33.640]             }
[17:02:33.640]         }))
[17:02:33.640]     }, error = function(ex) {
[17:02:33.640]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.640]                 ...future.rng), started = ...future.startTime, 
[17:02:33.640]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.640]             version = "1.8"), class = "FutureResult")
[17:02:33.640]     }, finally = {
[17:02:33.640]         if (!identical(...future.workdir, getwd())) 
[17:02:33.640]             setwd(...future.workdir)
[17:02:33.640]         {
[17:02:33.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.640]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.640]             }
[17:02:33.640]             base::options(...future.oldOptions)
[17:02:33.640]             if (.Platform$OS.type == "windows") {
[17:02:33.640]                 old_names <- names(...future.oldEnvVars)
[17:02:33.640]                 envs <- base::Sys.getenv()
[17:02:33.640]                 names <- names(envs)
[17:02:33.640]                 common <- intersect(names, old_names)
[17:02:33.640]                 added <- setdiff(names, old_names)
[17:02:33.640]                 removed <- setdiff(old_names, names)
[17:02:33.640]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.640]                   envs[common]]
[17:02:33.640]                 NAMES <- toupper(changed)
[17:02:33.640]                 args <- list()
[17:02:33.640]                 for (kk in seq_along(NAMES)) {
[17:02:33.640]                   name <- changed[[kk]]
[17:02:33.640]                   NAME <- NAMES[[kk]]
[17:02:33.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.640]                     next
[17:02:33.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.640]                 }
[17:02:33.640]                 NAMES <- toupper(added)
[17:02:33.640]                 for (kk in seq_along(NAMES)) {
[17:02:33.640]                   name <- added[[kk]]
[17:02:33.640]                   NAME <- NAMES[[kk]]
[17:02:33.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.640]                     next
[17:02:33.640]                   args[[name]] <- ""
[17:02:33.640]                 }
[17:02:33.640]                 NAMES <- toupper(removed)
[17:02:33.640]                 for (kk in seq_along(NAMES)) {
[17:02:33.640]                   name <- removed[[kk]]
[17:02:33.640]                   NAME <- NAMES[[kk]]
[17:02:33.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.640]                     next
[17:02:33.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.640]                 }
[17:02:33.640]                 if (length(args) > 0) 
[17:02:33.640]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.640]             }
[17:02:33.640]             else {
[17:02:33.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.640]             }
[17:02:33.640]             {
[17:02:33.640]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.640]                   0L) {
[17:02:33.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.640]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.640]                   base::options(opts)
[17:02:33.640]                 }
[17:02:33.640]                 {
[17:02:33.640]                   {
[17:02:33.640]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.640]                     NULL
[17:02:33.640]                   }
[17:02:33.640]                   options(future.plan = NULL)
[17:02:33.640]                   if (is.na(NA_character_)) 
[17:02:33.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.640]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.640]                     .init = FALSE)
[17:02:33.640]                 }
[17:02:33.640]             }
[17:02:33.640]         }
[17:02:33.640]     })
[17:02:33.640]     if (TRUE) {
[17:02:33.640]         base::sink(type = "output", split = FALSE)
[17:02:33.640]         if (TRUE) {
[17:02:33.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.640]         }
[17:02:33.640]         else {
[17:02:33.640]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.640]         }
[17:02:33.640]         base::close(...future.stdout)
[17:02:33.640]         ...future.stdout <- NULL
[17:02:33.640]     }
[17:02:33.640]     ...future.result$conditions <- ...future.conditions
[17:02:33.640]     ...future.result$finished <- base::Sys.time()
[17:02:33.640]     ...future.result
[17:02:33.640] }
[17:02:33.643] MultisessionFuture started
[17:02:33.643] - Launch lazy future ... done
[17:02:33.643] run() for ‘MultisessionFuture’ ... done
[17:02:33.643] getGlobalsAndPackages() ...
[17:02:33.643] Searching for globals...
[17:02:33.644] 
[17:02:33.644] Searching for globals ... DONE
[17:02:33.644] - globals: [0] <none>
[17:02:33.644] getGlobalsAndPackages() ... DONE
[17:02:33.645] run() for ‘Future’ ...
[17:02:33.645] - state: ‘created’
[17:02:33.645] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.660] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.660] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.660]   - Field: ‘node’
[17:02:33.660]   - Field: ‘label’
[17:02:33.660]   - Field: ‘local’
[17:02:33.660]   - Field: ‘owner’
[17:02:33.660]   - Field: ‘envir’
[17:02:33.660]   - Field: ‘workers’
[17:02:33.660]   - Field: ‘packages’
[17:02:33.661]   - Field: ‘gc’
[17:02:33.661]   - Field: ‘conditions’
[17:02:33.661]   - Field: ‘persistent’
[17:02:33.661]   - Field: ‘expr’
[17:02:33.661]   - Field: ‘uuid’
[17:02:33.661]   - Field: ‘seed’
[17:02:33.661]   - Field: ‘version’
[17:02:33.661]   - Field: ‘result’
[17:02:33.661]   - Field: ‘asynchronous’
[17:02:33.661]   - Field: ‘calls’
[17:02:33.661]   - Field: ‘globals’
[17:02:33.662]   - Field: ‘stdout’
[17:02:33.662]   - Field: ‘earlySignal’
[17:02:33.662]   - Field: ‘lazy’
[17:02:33.662]   - Field: ‘state’
[17:02:33.662] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.662] - Launch lazy future ...
[17:02:33.662] Packages needed by the future expression (n = 0): <none>
[17:02:33.662] Packages needed by future strategies (n = 0): <none>
[17:02:33.663] {
[17:02:33.663]     {
[17:02:33.663]         {
[17:02:33.663]             ...future.startTime <- base::Sys.time()
[17:02:33.663]             {
[17:02:33.663]                 {
[17:02:33.663]                   {
[17:02:33.663]                     {
[17:02:33.663]                       base::local({
[17:02:33.663]                         has_future <- base::requireNamespace("future", 
[17:02:33.663]                           quietly = TRUE)
[17:02:33.663]                         if (has_future) {
[17:02:33.663]                           ns <- base::getNamespace("future")
[17:02:33.663]                           version <- ns[[".package"]][["version"]]
[17:02:33.663]                           if (is.null(version)) 
[17:02:33.663]                             version <- utils::packageVersion("future")
[17:02:33.663]                         }
[17:02:33.663]                         else {
[17:02:33.663]                           version <- NULL
[17:02:33.663]                         }
[17:02:33.663]                         if (!has_future || version < "1.8.0") {
[17:02:33.663]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.663]                             "", base::R.version$version.string), 
[17:02:33.663]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.663]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.663]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.663]                               "release", "version")], collapse = " "), 
[17:02:33.663]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.663]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.663]                             info)
[17:02:33.663]                           info <- base::paste(info, collapse = "; ")
[17:02:33.663]                           if (!has_future) {
[17:02:33.663]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.663]                               info)
[17:02:33.663]                           }
[17:02:33.663]                           else {
[17:02:33.663]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.663]                               info, version)
[17:02:33.663]                           }
[17:02:33.663]                           base::stop(msg)
[17:02:33.663]                         }
[17:02:33.663]                       })
[17:02:33.663]                     }
[17:02:33.663]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.663]                     base::options(mc.cores = 1L)
[17:02:33.663]                   }
[17:02:33.663]                   ...future.strategy.old <- future::plan("list")
[17:02:33.663]                   options(future.plan = NULL)
[17:02:33.663]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.663]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.663]                 }
[17:02:33.663]                 ...future.workdir <- getwd()
[17:02:33.663]             }
[17:02:33.663]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.663]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.663]         }
[17:02:33.663]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.663]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.663]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.663]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.663]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.663]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.663]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.663]             base::names(...future.oldOptions))
[17:02:33.663]     }
[17:02:33.663]     if (FALSE) {
[17:02:33.663]     }
[17:02:33.663]     else {
[17:02:33.663]         if (TRUE) {
[17:02:33.663]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.663]                 open = "w")
[17:02:33.663]         }
[17:02:33.663]         else {
[17:02:33.663]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.663]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.663]         }
[17:02:33.663]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.663]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.663]             base::sink(type = "output", split = FALSE)
[17:02:33.663]             base::close(...future.stdout)
[17:02:33.663]         }, add = TRUE)
[17:02:33.663]     }
[17:02:33.663]     ...future.frame <- base::sys.nframe()
[17:02:33.663]     ...future.conditions <- base::list()
[17:02:33.663]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.663]     if (FALSE) {
[17:02:33.663]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.663]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.663]     }
[17:02:33.663]     ...future.result <- base::tryCatch({
[17:02:33.663]         base::withCallingHandlers({
[17:02:33.663]             ...future.value <- base::withVisible(base::local({
[17:02:33.663]                 ...future.makeSendCondition <- base::local({
[17:02:33.663]                   sendCondition <- NULL
[17:02:33.663]                   function(frame = 1L) {
[17:02:33.663]                     if (is.function(sendCondition)) 
[17:02:33.663]                       return(sendCondition)
[17:02:33.663]                     ns <- getNamespace("parallel")
[17:02:33.663]                     if (exists("sendData", mode = "function", 
[17:02:33.663]                       envir = ns)) {
[17:02:33.663]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.663]                         envir = ns)
[17:02:33.663]                       envir <- sys.frame(frame)
[17:02:33.663]                       master <- NULL
[17:02:33.663]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.663]                         !identical(envir, emptyenv())) {
[17:02:33.663]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.663]                           inherits = FALSE)) {
[17:02:33.663]                           master <- get("master", mode = "list", 
[17:02:33.663]                             envir = envir, inherits = FALSE)
[17:02:33.663]                           if (inherits(master, c("SOCKnode", 
[17:02:33.663]                             "SOCK0node"))) {
[17:02:33.663]                             sendCondition <<- function(cond) {
[17:02:33.663]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.663]                                 success = TRUE)
[17:02:33.663]                               parallel_sendData(master, data)
[17:02:33.663]                             }
[17:02:33.663]                             return(sendCondition)
[17:02:33.663]                           }
[17:02:33.663]                         }
[17:02:33.663]                         frame <- frame + 1L
[17:02:33.663]                         envir <- sys.frame(frame)
[17:02:33.663]                       }
[17:02:33.663]                     }
[17:02:33.663]                     sendCondition <<- function(cond) NULL
[17:02:33.663]                   }
[17:02:33.663]                 })
[17:02:33.663]                 withCallingHandlers({
[17:02:33.663]                   NULL
[17:02:33.663]                 }, immediateCondition = function(cond) {
[17:02:33.663]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.663]                   sendCondition(cond)
[17:02:33.663]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.663]                   {
[17:02:33.663]                     inherits <- base::inherits
[17:02:33.663]                     invokeRestart <- base::invokeRestart
[17:02:33.663]                     is.null <- base::is.null
[17:02:33.663]                     muffled <- FALSE
[17:02:33.663]                     if (inherits(cond, "message")) {
[17:02:33.663]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.663]                       if (muffled) 
[17:02:33.663]                         invokeRestart("muffleMessage")
[17:02:33.663]                     }
[17:02:33.663]                     else if (inherits(cond, "warning")) {
[17:02:33.663]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.663]                       if (muffled) 
[17:02:33.663]                         invokeRestart("muffleWarning")
[17:02:33.663]                     }
[17:02:33.663]                     else if (inherits(cond, "condition")) {
[17:02:33.663]                       if (!is.null(pattern)) {
[17:02:33.663]                         computeRestarts <- base::computeRestarts
[17:02:33.663]                         grepl <- base::grepl
[17:02:33.663]                         restarts <- computeRestarts(cond)
[17:02:33.663]                         for (restart in restarts) {
[17:02:33.663]                           name <- restart$name
[17:02:33.663]                           if (is.null(name)) 
[17:02:33.663]                             next
[17:02:33.663]                           if (!grepl(pattern, name)) 
[17:02:33.663]                             next
[17:02:33.663]                           invokeRestart(restart)
[17:02:33.663]                           muffled <- TRUE
[17:02:33.663]                           break
[17:02:33.663]                         }
[17:02:33.663]                       }
[17:02:33.663]                     }
[17:02:33.663]                     invisible(muffled)
[17:02:33.663]                   }
[17:02:33.663]                   muffleCondition(cond)
[17:02:33.663]                 })
[17:02:33.663]             }))
[17:02:33.663]             future::FutureResult(value = ...future.value$value, 
[17:02:33.663]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.663]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.663]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.663]                     ...future.globalenv.names))
[17:02:33.663]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.663]         }, condition = base::local({
[17:02:33.663]             c <- base::c
[17:02:33.663]             inherits <- base::inherits
[17:02:33.663]             invokeRestart <- base::invokeRestart
[17:02:33.663]             length <- base::length
[17:02:33.663]             list <- base::list
[17:02:33.663]             seq.int <- base::seq.int
[17:02:33.663]             signalCondition <- base::signalCondition
[17:02:33.663]             sys.calls <- base::sys.calls
[17:02:33.663]             `[[` <- base::`[[`
[17:02:33.663]             `+` <- base::`+`
[17:02:33.663]             `<<-` <- base::`<<-`
[17:02:33.663]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.663]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.663]                   3L)]
[17:02:33.663]             }
[17:02:33.663]             function(cond) {
[17:02:33.663]                 is_error <- inherits(cond, "error")
[17:02:33.663]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.663]                   NULL)
[17:02:33.663]                 if (is_error) {
[17:02:33.663]                   sessionInformation <- function() {
[17:02:33.663]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.663]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.663]                       search = base::search(), system = base::Sys.info())
[17:02:33.663]                   }
[17:02:33.663]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.663]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.663]                     cond$call), session = sessionInformation(), 
[17:02:33.663]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.663]                   signalCondition(cond)
[17:02:33.663]                 }
[17:02:33.663]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.663]                 "immediateCondition"))) {
[17:02:33.663]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.663]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.663]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.663]                   if (TRUE && !signal) {
[17:02:33.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.663]                     {
[17:02:33.663]                       inherits <- base::inherits
[17:02:33.663]                       invokeRestart <- base::invokeRestart
[17:02:33.663]                       is.null <- base::is.null
[17:02:33.663]                       muffled <- FALSE
[17:02:33.663]                       if (inherits(cond, "message")) {
[17:02:33.663]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.663]                         if (muffled) 
[17:02:33.663]                           invokeRestart("muffleMessage")
[17:02:33.663]                       }
[17:02:33.663]                       else if (inherits(cond, "warning")) {
[17:02:33.663]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.663]                         if (muffled) 
[17:02:33.663]                           invokeRestart("muffleWarning")
[17:02:33.663]                       }
[17:02:33.663]                       else if (inherits(cond, "condition")) {
[17:02:33.663]                         if (!is.null(pattern)) {
[17:02:33.663]                           computeRestarts <- base::computeRestarts
[17:02:33.663]                           grepl <- base::grepl
[17:02:33.663]                           restarts <- computeRestarts(cond)
[17:02:33.663]                           for (restart in restarts) {
[17:02:33.663]                             name <- restart$name
[17:02:33.663]                             if (is.null(name)) 
[17:02:33.663]                               next
[17:02:33.663]                             if (!grepl(pattern, name)) 
[17:02:33.663]                               next
[17:02:33.663]                             invokeRestart(restart)
[17:02:33.663]                             muffled <- TRUE
[17:02:33.663]                             break
[17:02:33.663]                           }
[17:02:33.663]                         }
[17:02:33.663]                       }
[17:02:33.663]                       invisible(muffled)
[17:02:33.663]                     }
[17:02:33.663]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.663]                   }
[17:02:33.663]                 }
[17:02:33.663]                 else {
[17:02:33.663]                   if (TRUE) {
[17:02:33.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.663]                     {
[17:02:33.663]                       inherits <- base::inherits
[17:02:33.663]                       invokeRestart <- base::invokeRestart
[17:02:33.663]                       is.null <- base::is.null
[17:02:33.663]                       muffled <- FALSE
[17:02:33.663]                       if (inherits(cond, "message")) {
[17:02:33.663]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.663]                         if (muffled) 
[17:02:33.663]                           invokeRestart("muffleMessage")
[17:02:33.663]                       }
[17:02:33.663]                       else if (inherits(cond, "warning")) {
[17:02:33.663]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.663]                         if (muffled) 
[17:02:33.663]                           invokeRestart("muffleWarning")
[17:02:33.663]                       }
[17:02:33.663]                       else if (inherits(cond, "condition")) {
[17:02:33.663]                         if (!is.null(pattern)) {
[17:02:33.663]                           computeRestarts <- base::computeRestarts
[17:02:33.663]                           grepl <- base::grepl
[17:02:33.663]                           restarts <- computeRestarts(cond)
[17:02:33.663]                           for (restart in restarts) {
[17:02:33.663]                             name <- restart$name
[17:02:33.663]                             if (is.null(name)) 
[17:02:33.663]                               next
[17:02:33.663]                             if (!grepl(pattern, name)) 
[17:02:33.663]                               next
[17:02:33.663]                             invokeRestart(restart)
[17:02:33.663]                             muffled <- TRUE
[17:02:33.663]                             break
[17:02:33.663]                           }
[17:02:33.663]                         }
[17:02:33.663]                       }
[17:02:33.663]                       invisible(muffled)
[17:02:33.663]                     }
[17:02:33.663]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.663]                   }
[17:02:33.663]                 }
[17:02:33.663]             }
[17:02:33.663]         }))
[17:02:33.663]     }, error = function(ex) {
[17:02:33.663]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.663]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.663]                 ...future.rng), started = ...future.startTime, 
[17:02:33.663]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.663]             version = "1.8"), class = "FutureResult")
[17:02:33.663]     }, finally = {
[17:02:33.663]         if (!identical(...future.workdir, getwd())) 
[17:02:33.663]             setwd(...future.workdir)
[17:02:33.663]         {
[17:02:33.663]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.663]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.663]             }
[17:02:33.663]             base::options(...future.oldOptions)
[17:02:33.663]             if (.Platform$OS.type == "windows") {
[17:02:33.663]                 old_names <- names(...future.oldEnvVars)
[17:02:33.663]                 envs <- base::Sys.getenv()
[17:02:33.663]                 names <- names(envs)
[17:02:33.663]                 common <- intersect(names, old_names)
[17:02:33.663]                 added <- setdiff(names, old_names)
[17:02:33.663]                 removed <- setdiff(old_names, names)
[17:02:33.663]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.663]                   envs[common]]
[17:02:33.663]                 NAMES <- toupper(changed)
[17:02:33.663]                 args <- list()
[17:02:33.663]                 for (kk in seq_along(NAMES)) {
[17:02:33.663]                   name <- changed[[kk]]
[17:02:33.663]                   NAME <- NAMES[[kk]]
[17:02:33.663]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.663]                     next
[17:02:33.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.663]                 }
[17:02:33.663]                 NAMES <- toupper(added)
[17:02:33.663]                 for (kk in seq_along(NAMES)) {
[17:02:33.663]                   name <- added[[kk]]
[17:02:33.663]                   NAME <- NAMES[[kk]]
[17:02:33.663]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.663]                     next
[17:02:33.663]                   args[[name]] <- ""
[17:02:33.663]                 }
[17:02:33.663]                 NAMES <- toupper(removed)
[17:02:33.663]                 for (kk in seq_along(NAMES)) {
[17:02:33.663]                   name <- removed[[kk]]
[17:02:33.663]                   NAME <- NAMES[[kk]]
[17:02:33.663]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.663]                     next
[17:02:33.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.663]                 }
[17:02:33.663]                 if (length(args) > 0) 
[17:02:33.663]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.663]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.663]             }
[17:02:33.663]             else {
[17:02:33.663]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.663]             }
[17:02:33.663]             {
[17:02:33.663]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.663]                   0L) {
[17:02:33.663]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.663]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.663]                   base::options(opts)
[17:02:33.663]                 }
[17:02:33.663]                 {
[17:02:33.663]                   {
[17:02:33.663]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.663]                     NULL
[17:02:33.663]                   }
[17:02:33.663]                   options(future.plan = NULL)
[17:02:33.663]                   if (is.na(NA_character_)) 
[17:02:33.663]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.663]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.663]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.663]                     .init = FALSE)
[17:02:33.663]                 }
[17:02:33.663]             }
[17:02:33.663]         }
[17:02:33.663]     })
[17:02:33.663]     if (TRUE) {
[17:02:33.663]         base::sink(type = "output", split = FALSE)
[17:02:33.663]         if (TRUE) {
[17:02:33.663]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.663]         }
[17:02:33.663]         else {
[17:02:33.663]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.663]         }
[17:02:33.663]         base::close(...future.stdout)
[17:02:33.663]         ...future.stdout <- NULL
[17:02:33.663]     }
[17:02:33.663]     ...future.result$conditions <- ...future.conditions
[17:02:33.663]     ...future.result$finished <- base::Sys.time()
[17:02:33.663]     ...future.result
[17:02:33.663] }
[17:02:33.666] MultisessionFuture started
[17:02:33.666] - Launch lazy future ... done
[17:02:33.666] run() for ‘MultisessionFuture’ ... done
[17:02:33.666] getGlobalsAndPackages() ...
[17:02:33.667] Searching for globals...
[17:02:33.667] - globals found: [1] ‘{’
[17:02:33.667] Searching for globals ... DONE
[17:02:33.667] Resolving globals: FALSE
[17:02:33.668] 
[17:02:33.668] 
[17:02:33.668] getGlobalsAndPackages() ... DONE
[17:02:33.668] run() for ‘Future’ ...
[17:02:33.668] - state: ‘created’
[17:02:33.668] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:33.683] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:33.683] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:33.683]   - Field: ‘node’
[17:02:33.684]   - Field: ‘label’
[17:02:33.684]   - Field: ‘local’
[17:02:33.684]   - Field: ‘owner’
[17:02:33.684]   - Field: ‘envir’
[17:02:33.684]   - Field: ‘workers’
[17:02:33.684]   - Field: ‘packages’
[17:02:33.684]   - Field: ‘gc’
[17:02:33.684]   - Field: ‘conditions’
[17:02:33.684]   - Field: ‘persistent’
[17:02:33.684]   - Field: ‘expr’
[17:02:33.684]   - Field: ‘uuid’
[17:02:33.685]   - Field: ‘seed’
[17:02:33.685]   - Field: ‘version’
[17:02:33.685]   - Field: ‘result’
[17:02:33.685]   - Field: ‘asynchronous’
[17:02:33.685]   - Field: ‘calls’
[17:02:33.685]   - Field: ‘globals’
[17:02:33.685]   - Field: ‘stdout’
[17:02:33.685]   - Field: ‘earlySignal’
[17:02:33.685]   - Field: ‘lazy’
[17:02:33.685]   - Field: ‘state’
[17:02:33.685] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:33.686] - Launch lazy future ...
[17:02:33.686] Packages needed by the future expression (n = 0): <none>
[17:02:33.686] Packages needed by future strategies (n = 0): <none>
[17:02:33.686] {
[17:02:33.686]     {
[17:02:33.686]         {
[17:02:33.686]             ...future.startTime <- base::Sys.time()
[17:02:33.686]             {
[17:02:33.686]                 {
[17:02:33.686]                   {
[17:02:33.686]                     {
[17:02:33.686]                       base::local({
[17:02:33.686]                         has_future <- base::requireNamespace("future", 
[17:02:33.686]                           quietly = TRUE)
[17:02:33.686]                         if (has_future) {
[17:02:33.686]                           ns <- base::getNamespace("future")
[17:02:33.686]                           version <- ns[[".package"]][["version"]]
[17:02:33.686]                           if (is.null(version)) 
[17:02:33.686]                             version <- utils::packageVersion("future")
[17:02:33.686]                         }
[17:02:33.686]                         else {
[17:02:33.686]                           version <- NULL
[17:02:33.686]                         }
[17:02:33.686]                         if (!has_future || version < "1.8.0") {
[17:02:33.686]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:33.686]                             "", base::R.version$version.string), 
[17:02:33.686]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:33.686]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:33.686]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:33.686]                               "release", "version")], collapse = " "), 
[17:02:33.686]                             hostname = base::Sys.info()[["nodename"]])
[17:02:33.686]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:33.686]                             info)
[17:02:33.686]                           info <- base::paste(info, collapse = "; ")
[17:02:33.686]                           if (!has_future) {
[17:02:33.686]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:33.686]                               info)
[17:02:33.686]                           }
[17:02:33.686]                           else {
[17:02:33.686]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:33.686]                               info, version)
[17:02:33.686]                           }
[17:02:33.686]                           base::stop(msg)
[17:02:33.686]                         }
[17:02:33.686]                       })
[17:02:33.686]                     }
[17:02:33.686]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:33.686]                     base::options(mc.cores = 1L)
[17:02:33.686]                   }
[17:02:33.686]                   ...future.strategy.old <- future::plan("list")
[17:02:33.686]                   options(future.plan = NULL)
[17:02:33.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:33.686]                 }
[17:02:33.686]                 ...future.workdir <- getwd()
[17:02:33.686]             }
[17:02:33.686]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:33.686]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:33.686]         }
[17:02:33.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:02:33.686]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:33.686]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:02:33.686]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:02:33.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:33.686]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:33.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:33.686]             base::names(...future.oldOptions))
[17:02:33.686]     }
[17:02:33.686]     if (FALSE) {
[17:02:33.686]     }
[17:02:33.686]     else {
[17:02:33.686]         if (TRUE) {
[17:02:33.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:33.686]                 open = "w")
[17:02:33.686]         }
[17:02:33.686]         else {
[17:02:33.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:33.686]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:33.686]         }
[17:02:33.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:33.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:33.686]             base::sink(type = "output", split = FALSE)
[17:02:33.686]             base::close(...future.stdout)
[17:02:33.686]         }, add = TRUE)
[17:02:33.686]     }
[17:02:33.686]     ...future.frame <- base::sys.nframe()
[17:02:33.686]     ...future.conditions <- base::list()
[17:02:33.686]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:33.686]     if (FALSE) {
[17:02:33.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:33.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:33.686]     }
[17:02:33.686]     ...future.result <- base::tryCatch({
[17:02:33.686]         base::withCallingHandlers({
[17:02:33.686]             ...future.value <- base::withVisible(base::local({
[17:02:33.686]                 ...future.makeSendCondition <- base::local({
[17:02:33.686]                   sendCondition <- NULL
[17:02:33.686]                   function(frame = 1L) {
[17:02:33.686]                     if (is.function(sendCondition)) 
[17:02:33.686]                       return(sendCondition)
[17:02:33.686]                     ns <- getNamespace("parallel")
[17:02:33.686]                     if (exists("sendData", mode = "function", 
[17:02:33.686]                       envir = ns)) {
[17:02:33.686]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:33.686]                         envir = ns)
[17:02:33.686]                       envir <- sys.frame(frame)
[17:02:33.686]                       master <- NULL
[17:02:33.686]                       while (!identical(envir, .GlobalEnv) && 
[17:02:33.686]                         !identical(envir, emptyenv())) {
[17:02:33.686]                         if (exists("master", mode = "list", envir = envir, 
[17:02:33.686]                           inherits = FALSE)) {
[17:02:33.686]                           master <- get("master", mode = "list", 
[17:02:33.686]                             envir = envir, inherits = FALSE)
[17:02:33.686]                           if (inherits(master, c("SOCKnode", 
[17:02:33.686]                             "SOCK0node"))) {
[17:02:33.686]                             sendCondition <<- function(cond) {
[17:02:33.686]                               data <- list(type = "VALUE", value = cond, 
[17:02:33.686]                                 success = TRUE)
[17:02:33.686]                               parallel_sendData(master, data)
[17:02:33.686]                             }
[17:02:33.686]                             return(sendCondition)
[17:02:33.686]                           }
[17:02:33.686]                         }
[17:02:33.686]                         frame <- frame + 1L
[17:02:33.686]                         envir <- sys.frame(frame)
[17:02:33.686]                       }
[17:02:33.686]                     }
[17:02:33.686]                     sendCondition <<- function(cond) NULL
[17:02:33.686]                   }
[17:02:33.686]                 })
[17:02:33.686]                 withCallingHandlers({
[17:02:33.686]                   {
[17:02:33.686]                     4
[17:02:33.686]                   }
[17:02:33.686]                 }, immediateCondition = function(cond) {
[17:02:33.686]                   sendCondition <- ...future.makeSendCondition()
[17:02:33.686]                   sendCondition(cond)
[17:02:33.686]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.686]                   {
[17:02:33.686]                     inherits <- base::inherits
[17:02:33.686]                     invokeRestart <- base::invokeRestart
[17:02:33.686]                     is.null <- base::is.null
[17:02:33.686]                     muffled <- FALSE
[17:02:33.686]                     if (inherits(cond, "message")) {
[17:02:33.686]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:33.686]                       if (muffled) 
[17:02:33.686]                         invokeRestart("muffleMessage")
[17:02:33.686]                     }
[17:02:33.686]                     else if (inherits(cond, "warning")) {
[17:02:33.686]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:33.686]                       if (muffled) 
[17:02:33.686]                         invokeRestart("muffleWarning")
[17:02:33.686]                     }
[17:02:33.686]                     else if (inherits(cond, "condition")) {
[17:02:33.686]                       if (!is.null(pattern)) {
[17:02:33.686]                         computeRestarts <- base::computeRestarts
[17:02:33.686]                         grepl <- base::grepl
[17:02:33.686]                         restarts <- computeRestarts(cond)
[17:02:33.686]                         for (restart in restarts) {
[17:02:33.686]                           name <- restart$name
[17:02:33.686]                           if (is.null(name)) 
[17:02:33.686]                             next
[17:02:33.686]                           if (!grepl(pattern, name)) 
[17:02:33.686]                             next
[17:02:33.686]                           invokeRestart(restart)
[17:02:33.686]                           muffled <- TRUE
[17:02:33.686]                           break
[17:02:33.686]                         }
[17:02:33.686]                       }
[17:02:33.686]                     }
[17:02:33.686]                     invisible(muffled)
[17:02:33.686]                   }
[17:02:33.686]                   muffleCondition(cond)
[17:02:33.686]                 })
[17:02:33.686]             }))
[17:02:33.686]             future::FutureResult(value = ...future.value$value, 
[17:02:33.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.686]                   ...future.rng), globalenv = if (FALSE) 
[17:02:33.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:33.686]                     ...future.globalenv.names))
[17:02:33.686]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:33.686]         }, condition = base::local({
[17:02:33.686]             c <- base::c
[17:02:33.686]             inherits <- base::inherits
[17:02:33.686]             invokeRestart <- base::invokeRestart
[17:02:33.686]             length <- base::length
[17:02:33.686]             list <- base::list
[17:02:33.686]             seq.int <- base::seq.int
[17:02:33.686]             signalCondition <- base::signalCondition
[17:02:33.686]             sys.calls <- base::sys.calls
[17:02:33.686]             `[[` <- base::`[[`
[17:02:33.686]             `+` <- base::`+`
[17:02:33.686]             `<<-` <- base::`<<-`
[17:02:33.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:33.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:33.686]                   3L)]
[17:02:33.686]             }
[17:02:33.686]             function(cond) {
[17:02:33.686]                 is_error <- inherits(cond, "error")
[17:02:33.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:33.686]                   NULL)
[17:02:33.686]                 if (is_error) {
[17:02:33.686]                   sessionInformation <- function() {
[17:02:33.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:33.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:33.686]                       search = base::search(), system = base::Sys.info())
[17:02:33.686]                   }
[17:02:33.686]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:33.686]                     cond$call), session = sessionInformation(), 
[17:02:33.686]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:33.686]                   signalCondition(cond)
[17:02:33.686]                 }
[17:02:33.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:33.686]                 "immediateCondition"))) {
[17:02:33.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:33.686]                   ...future.conditions[[length(...future.conditions) + 
[17:02:33.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:33.686]                   if (TRUE && !signal) {
[17:02:33.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.686]                     {
[17:02:33.686]                       inherits <- base::inherits
[17:02:33.686]                       invokeRestart <- base::invokeRestart
[17:02:33.686]                       is.null <- base::is.null
[17:02:33.686]                       muffled <- FALSE
[17:02:33.686]                       if (inherits(cond, "message")) {
[17:02:33.686]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.686]                         if (muffled) 
[17:02:33.686]                           invokeRestart("muffleMessage")
[17:02:33.686]                       }
[17:02:33.686]                       else if (inherits(cond, "warning")) {
[17:02:33.686]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.686]                         if (muffled) 
[17:02:33.686]                           invokeRestart("muffleWarning")
[17:02:33.686]                       }
[17:02:33.686]                       else if (inherits(cond, "condition")) {
[17:02:33.686]                         if (!is.null(pattern)) {
[17:02:33.686]                           computeRestarts <- base::computeRestarts
[17:02:33.686]                           grepl <- base::grepl
[17:02:33.686]                           restarts <- computeRestarts(cond)
[17:02:33.686]                           for (restart in restarts) {
[17:02:33.686]                             name <- restart$name
[17:02:33.686]                             if (is.null(name)) 
[17:02:33.686]                               next
[17:02:33.686]                             if (!grepl(pattern, name)) 
[17:02:33.686]                               next
[17:02:33.686]                             invokeRestart(restart)
[17:02:33.686]                             muffled <- TRUE
[17:02:33.686]                             break
[17:02:33.686]                           }
[17:02:33.686]                         }
[17:02:33.686]                       }
[17:02:33.686]                       invisible(muffled)
[17:02:33.686]                     }
[17:02:33.686]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.686]                   }
[17:02:33.686]                 }
[17:02:33.686]                 else {
[17:02:33.686]                   if (TRUE) {
[17:02:33.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:33.686]                     {
[17:02:33.686]                       inherits <- base::inherits
[17:02:33.686]                       invokeRestart <- base::invokeRestart
[17:02:33.686]                       is.null <- base::is.null
[17:02:33.686]                       muffled <- FALSE
[17:02:33.686]                       if (inherits(cond, "message")) {
[17:02:33.686]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:33.686]                         if (muffled) 
[17:02:33.686]                           invokeRestart("muffleMessage")
[17:02:33.686]                       }
[17:02:33.686]                       else if (inherits(cond, "warning")) {
[17:02:33.686]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:33.686]                         if (muffled) 
[17:02:33.686]                           invokeRestart("muffleWarning")
[17:02:33.686]                       }
[17:02:33.686]                       else if (inherits(cond, "condition")) {
[17:02:33.686]                         if (!is.null(pattern)) {
[17:02:33.686]                           computeRestarts <- base::computeRestarts
[17:02:33.686]                           grepl <- base::grepl
[17:02:33.686]                           restarts <- computeRestarts(cond)
[17:02:33.686]                           for (restart in restarts) {
[17:02:33.686]                             name <- restart$name
[17:02:33.686]                             if (is.null(name)) 
[17:02:33.686]                               next
[17:02:33.686]                             if (!grepl(pattern, name)) 
[17:02:33.686]                               next
[17:02:33.686]                             invokeRestart(restart)
[17:02:33.686]                             muffled <- TRUE
[17:02:33.686]                             break
[17:02:33.686]                           }
[17:02:33.686]                         }
[17:02:33.686]                       }
[17:02:33.686]                       invisible(muffled)
[17:02:33.686]                     }
[17:02:33.686]                     muffleCondition(cond, pattern = "^muffle")
[17:02:33.686]                   }
[17:02:33.686]                 }
[17:02:33.686]             }
[17:02:33.686]         }))
[17:02:33.686]     }, error = function(ex) {
[17:02:33.686]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:33.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:33.686]                 ...future.rng), started = ...future.startTime, 
[17:02:33.686]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:33.686]             version = "1.8"), class = "FutureResult")
[17:02:33.686]     }, finally = {
[17:02:33.686]         if (!identical(...future.workdir, getwd())) 
[17:02:33.686]             setwd(...future.workdir)
[17:02:33.686]         {
[17:02:33.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:33.686]                 ...future.oldOptions$nwarnings <- NULL
[17:02:33.686]             }
[17:02:33.686]             base::options(...future.oldOptions)
[17:02:33.686]             if (.Platform$OS.type == "windows") {
[17:02:33.686]                 old_names <- names(...future.oldEnvVars)
[17:02:33.686]                 envs <- base::Sys.getenv()
[17:02:33.686]                 names <- names(envs)
[17:02:33.686]                 common <- intersect(names, old_names)
[17:02:33.686]                 added <- setdiff(names, old_names)
[17:02:33.686]                 removed <- setdiff(old_names, names)
[17:02:33.686]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:33.686]                   envs[common]]
[17:02:33.686]                 NAMES <- toupper(changed)
[17:02:33.686]                 args <- list()
[17:02:33.686]                 for (kk in seq_along(NAMES)) {
[17:02:33.686]                   name <- changed[[kk]]
[17:02:33.686]                   NAME <- NAMES[[kk]]
[17:02:33.686]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.686]                     next
[17:02:33.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.686]                 }
[17:02:33.686]                 NAMES <- toupper(added)
[17:02:33.686]                 for (kk in seq_along(NAMES)) {
[17:02:33.686]                   name <- added[[kk]]
[17:02:33.686]                   NAME <- NAMES[[kk]]
[17:02:33.686]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.686]                     next
[17:02:33.686]                   args[[name]] <- ""
[17:02:33.686]                 }
[17:02:33.686]                 NAMES <- toupper(removed)
[17:02:33.686]                 for (kk in seq_along(NAMES)) {
[17:02:33.686]                   name <- removed[[kk]]
[17:02:33.686]                   NAME <- NAMES[[kk]]
[17:02:33.686]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:33.686]                     next
[17:02:33.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:33.686]                 }
[17:02:33.686]                 if (length(args) > 0) 
[17:02:33.686]                   base::do.call(base::Sys.setenv, args = args)
[17:02:33.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:33.686]             }
[17:02:33.686]             else {
[17:02:33.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:33.686]             }
[17:02:33.686]             {
[17:02:33.686]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:33.686]                   0L) {
[17:02:33.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:33.686]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:33.686]                   base::options(opts)
[17:02:33.686]                 }
[17:02:33.686]                 {
[17:02:33.686]                   {
[17:02:33.686]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:33.686]                     NULL
[17:02:33.686]                   }
[17:02:33.686]                   options(future.plan = NULL)
[17:02:33.686]                   if (is.na(NA_character_)) 
[17:02:33.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:33.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:33.686]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:33.686]                     .init = FALSE)
[17:02:33.686]                 }
[17:02:33.686]             }
[17:02:33.686]         }
[17:02:33.686]     })
[17:02:33.686]     if (TRUE) {
[17:02:33.686]         base::sink(type = "output", split = FALSE)
[17:02:33.686]         if (TRUE) {
[17:02:33.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:33.686]         }
[17:02:33.686]         else {
[17:02:33.686]             ...future.result["stdout"] <- base::list(NULL)
[17:02:33.686]         }
[17:02:33.686]         base::close(...future.stdout)
[17:02:33.686]         ...future.stdout <- NULL
[17:02:33.686]     }
[17:02:33.686]     ...future.result$conditions <- ...future.conditions
[17:02:33.686]     ...future.result$finished <- base::Sys.time()
[17:02:33.686]     ...future.result
[17:02:33.686] }
[17:02:33.689] Poll #1 (0): usedNodes() = 2, workers = 2
[17:02:33.699] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.700] - Validating connection of MultisessionFuture
[17:02:33.700] - received message: FutureResult
[17:02:33.700] - Received FutureResult
[17:02:33.700] - Erased future from FutureRegistry
[17:02:33.700] result() for ClusterFuture ...
[17:02:33.700] - result already collected: FutureResult
[17:02:33.700] result() for ClusterFuture ... done
[17:02:33.700] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:33.701] result() for ClusterFuture ...
[17:02:33.701] - result already collected: FutureResult
[17:02:33.701] result() for ClusterFuture ... done
[17:02:33.701] result() for ClusterFuture ...
[17:02:33.701] - result already collected: FutureResult
[17:02:33.701] result() for ClusterFuture ... done
[17:02:33.702] MultisessionFuture started
[17:02:33.702] - Launch lazy future ... done
[17:02:33.702] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c749e2f370> 
Classes 'listenv', 'environment' <environment: 0x55c74a6140f8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:02:33.707] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.707] - Validating connection of MultisessionFuture
[17:02:33.707] - received message: FutureResult
[17:02:33.707] - Received FutureResult
[17:02:33.707] - Erased future from FutureRegistry
[17:02:33.707] result() for ClusterFuture ...
[17:02:33.708] - result already collected: FutureResult
[17:02:33.708] result() for ClusterFuture ... done
[17:02:33.708] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:33.708] receiveMessageFromWorker() for ClusterFuture ...
[17:02:33.708] - Validating connection of MultisessionFuture
[17:02:33.708] - received message: FutureResult
[17:02:33.709] - Received FutureResult
[17:02:33.709] - Erased future from FutureRegistry
[17:02:33.709] result() for ClusterFuture ...
[17:02:33.709] - result already collected: FutureResult
[17:02:33.709] result() for ClusterFuture ... done
[17:02:33.709] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:02:33.712] resolve() on list environment ...
[17:02:33.712]  recursive: 0
[17:02:33.713]  length: 6
[17:02:33.713]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:02:33.713] signalConditionsASAP(numeric, pos=1) ...
[17:02:33.713] - nx: 6
[17:02:33.713] - relay: TRUE
[17:02:33.713] - stdout: TRUE
[17:02:33.713] - signal: TRUE
[17:02:33.713] - resignal: FALSE
[17:02:33.713] - force: TRUE
[17:02:33.714] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.714] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.714]  - until=2
[17:02:33.714]  - relaying element #2
[17:02:33.714] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.714] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.714] signalConditionsASAP(NULL, pos=1) ... done
[17:02:33.714]  length: 5 (resolved future 1)
[17:02:33.714] Future #2
[17:02:33.714] result() for ClusterFuture ...
[17:02:33.715] - result already collected: FutureResult
[17:02:33.715] result() for ClusterFuture ... done
[17:02:33.715] result() for ClusterFuture ...
[17:02:33.715] - result already collected: FutureResult
[17:02:33.715] result() for ClusterFuture ... done
[17:02:33.715] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:02:33.715] - nx: 6
[17:02:33.715] - relay: TRUE
[17:02:33.715] - stdout: TRUE
[17:02:33.715] - signal: TRUE
[17:02:33.715] - resignal: FALSE
[17:02:33.715] - force: TRUE
[17:02:33.716] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.716] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:02:33.716]  - until=2
[17:02:33.716]  - relaying element #2
[17:02:33.716] result() for ClusterFuture ...
[17:02:33.716] - result already collected: FutureResult
[17:02:33.716] result() for ClusterFuture ... done
[17:02:33.716] result() for ClusterFuture ...
[17:02:33.716] - result already collected: FutureResult
[17:02:33.716] result() for ClusterFuture ... done
[17:02:33.716] result() for ClusterFuture ...
[17:02:33.717] - result already collected: FutureResult
[17:02:33.717] result() for ClusterFuture ... done
[17:02:33.717] result() for ClusterFuture ...
[17:02:33.717] - result already collected: FutureResult
[17:02:33.717] result() for ClusterFuture ... done
[17:02:33.717] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.717] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.717] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:02:33.717]  length: 4 (resolved future 2)
[17:02:33.717] Future #3
[17:02:33.717] result() for ClusterFuture ...
[17:02:33.718] - result already collected: FutureResult
[17:02:33.718] result() for ClusterFuture ... done
[17:02:33.718] result() for ClusterFuture ...
[17:02:33.718] - result already collected: FutureResult
[17:02:33.718] result() for ClusterFuture ... done
[17:02:33.718] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:02:33.718] - nx: 6
[17:02:33.718] - relay: TRUE
[17:02:33.718] - stdout: TRUE
[17:02:33.718] - signal: TRUE
[17:02:33.718] - resignal: FALSE
[17:02:33.718] - force: TRUE
[17:02:33.719] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.719] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:02:33.719]  - until=3
[17:02:33.719]  - relaying element #3
[17:02:33.719] result() for ClusterFuture ...
[17:02:33.719] - result already collected: FutureResult
[17:02:33.719] result() for ClusterFuture ... done
[17:02:33.719] result() for ClusterFuture ...
[17:02:33.719] - result already collected: FutureResult
[17:02:33.719] result() for ClusterFuture ... done
[17:02:33.719] result() for ClusterFuture ...
[17:02:33.720] - result already collected: FutureResult
[17:02:33.720] result() for ClusterFuture ... done
[17:02:33.720] result() for ClusterFuture ...
[17:02:33.720] - result already collected: FutureResult
[17:02:33.720] result() for ClusterFuture ... done
[17:02:33.720] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.720] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.720] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:02:33.720]  length: 3 (resolved future 3)
[17:02:33.720] Future #4
[17:02:33.720] result() for ClusterFuture ...
[17:02:33.721] - result already collected: FutureResult
[17:02:33.721] result() for ClusterFuture ... done
[17:02:33.721] result() for ClusterFuture ...
[17:02:33.721] - result already collected: FutureResult
[17:02:33.721] result() for ClusterFuture ... done
[17:02:33.721] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:02:33.721] - nx: 6
[17:02:33.721] - relay: TRUE
[17:02:33.721] - stdout: TRUE
[17:02:33.721] - signal: TRUE
[17:02:33.721] - resignal: FALSE
[17:02:33.721] - force: TRUE
[17:02:33.722] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.722] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:02:33.722]  - until=4
[17:02:33.722]  - relaying element #4
[17:02:33.722] result() for ClusterFuture ...
[17:02:33.722] - result already collected: FutureResult
[17:02:33.722] result() for ClusterFuture ... done
[17:02:33.722] result() for ClusterFuture ...
[17:02:33.722] - result already collected: FutureResult
[17:02:33.722] result() for ClusterFuture ... done
[17:02:33.722] result() for ClusterFuture ...
[17:02:33.723] - result already collected: FutureResult
[17:02:33.723] result() for ClusterFuture ... done
[17:02:33.723] result() for ClusterFuture ...
[17:02:33.723] - result already collected: FutureResult
[17:02:33.723] result() for ClusterFuture ... done
[17:02:33.723] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.723] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.723] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:02:33.723]  length: 2 (resolved future 4)
[17:02:33.723] signalConditionsASAP(NULL, pos=5) ...
[17:02:33.723] - nx: 6
[17:02:33.724] - relay: TRUE
[17:02:33.724] - stdout: TRUE
[17:02:33.724] - signal: TRUE
[17:02:33.724] - resignal: FALSE
[17:02:33.724] - force: TRUE
[17:02:33.724] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.724] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.724]  - until=6
[17:02:33.724]  - relaying element #6
[17:02:33.724] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:33.724] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.724] signalConditionsASAP(NULL, pos=5) ... done
[17:02:33.725]  length: 1 (resolved future 5)
[17:02:33.725] signalConditionsASAP(numeric, pos=6) ...
[17:02:33.725] - nx: 6
[17:02:33.725] - relay: TRUE
[17:02:33.725] - stdout: TRUE
[17:02:33.725] - signal: TRUE
[17:02:33.725] - resignal: FALSE
[17:02:33.725] - force: TRUE
[17:02:33.725] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:02:33.725] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.725]  - until=6
[17:02:33.725] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.726] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.726] signalConditionsASAP(numeric, pos=6) ... done
[17:02:33.726]  length: 0 (resolved future 6)
[17:02:33.726] Relaying remaining futures
[17:02:33.726] signalConditionsASAP(NULL, pos=0) ...
[17:02:33.726] - nx: 6
[17:02:33.726] - relay: TRUE
[17:02:33.726] - stdout: TRUE
[17:02:33.726] - signal: TRUE
[17:02:33.726] - resignal: FALSE
[17:02:33.726] - force: TRUE
[17:02:33.726] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.726] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:02:33.727] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:02:33.727] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:02:33.727] signalConditionsASAP(NULL, pos=0) ... done
[17:02:33.727] resolve() on list environment ... DONE
[17:02:33.727] result() for ClusterFuture ...
[17:02:33.727] - result already collected: FutureResult
[17:02:33.727] result() for ClusterFuture ... done
[17:02:33.727] result() for ClusterFuture ...
[17:02:33.727] - result already collected: FutureResult
[17:02:33.727] result() for ClusterFuture ... done
[17:02:33.728] result() for ClusterFuture ...
[17:02:33.728] - result already collected: FutureResult
[17:02:33.728] result() for ClusterFuture ... done
[17:02:33.728] result() for ClusterFuture ...
[17:02:33.728] - result already collected: FutureResult
[17:02:33.728] result() for ClusterFuture ... done
[17:02:33.728] result() for ClusterFuture ...
[17:02:33.728] - result already collected: FutureResult
[17:02:33.728] result() for ClusterFuture ... done
[17:02:33.729] result() for ClusterFuture ...
[17:02:33.729] - result already collected: FutureResult
[17:02:33.729] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c74aad63f0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[17:02:33.731] plan(): Setting new future strategy stack:
[17:02:33.732] List of future strategies:
[17:02:33.732] 1. FutureStrategy:
[17:02:33.732]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:33.732]    - tweaked: FALSE
[17:02:33.732]    - call: future::plan(oplan)
[17:02:33.732] plan(): nbrOfWorkers() = 1
> 
