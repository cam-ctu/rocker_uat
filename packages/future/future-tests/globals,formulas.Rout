
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:46:51.261] plan(): Setting new future strategy stack:
[17:46:51.262] List of future strategies:
[17:46:51.262] 1. sequential:
[17:46:51.262]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.262]    - tweaked: FALSE
[17:46:51.262]    - call: future::plan("sequential")
[17:46:51.273] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[17:46:51.332] plan(): Setting new future strategy stack:
[17:46:51.332] List of future strategies:
[17:46:51.332] 1. sequential:
[17:46:51.332]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.332]    - tweaked: FALSE
[17:46:51.332]    - call: plan(strategy)
[17:46:51.345] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[17:46:51.346] getGlobalsAndPackages() ...
[17:46:51.346] Searching for globals...
[17:46:51.353] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:51.353] Searching for globals ... DONE
[17:46:51.353] Resolving globals: FALSE
[17:46:51.354] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:51.355] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:51.355] - globals: [2] ‘weight’, ‘group’
[17:46:51.355] - packages: [1] ‘stats’
[17:46:51.355] getGlobalsAndPackages() ... DONE
[17:46:51.356] run() for ‘Future’ ...
[17:46:51.356] - state: ‘created’
[17:46:51.356] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:51.356] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:51.356] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:51.357]   - Field: ‘label’
[17:46:51.357]   - Field: ‘local’
[17:46:51.357]   - Field: ‘owner’
[17:46:51.357]   - Field: ‘envir’
[17:46:51.357]   - Field: ‘packages’
[17:46:51.357]   - Field: ‘gc’
[17:46:51.357]   - Field: ‘conditions’
[17:46:51.357]   - Field: ‘expr’
[17:46:51.357]   - Field: ‘uuid’
[17:46:51.357]   - Field: ‘seed’
[17:46:51.357]   - Field: ‘version’
[17:46:51.358]   - Field: ‘result’
[17:46:51.358]   - Field: ‘asynchronous’
[17:46:51.358]   - Field: ‘calls’
[17:46:51.358]   - Field: ‘globals’
[17:46:51.358]   - Field: ‘stdout’
[17:46:51.358]   - Field: ‘earlySignal’
[17:46:51.358]   - Field: ‘lazy’
[17:46:51.358]   - Field: ‘state’
[17:46:51.358] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:51.358] - Launch lazy future ...
[17:46:51.359] Packages needed by the future expression (n = 1): ‘stats’
[17:46:51.359] Packages needed by future strategies (n = 0): <none>
[17:46:51.360] {
[17:46:51.360]     {
[17:46:51.360]         {
[17:46:51.360]             ...future.startTime <- base::Sys.time()
[17:46:51.360]             {
[17:46:51.360]                 {
[17:46:51.360]                   {
[17:46:51.360]                     {
[17:46:51.360]                       base::local({
[17:46:51.360]                         has_future <- base::requireNamespace("future", 
[17:46:51.360]                           quietly = TRUE)
[17:46:51.360]                         if (has_future) {
[17:46:51.360]                           ns <- base::getNamespace("future")
[17:46:51.360]                           version <- ns[[".package"]][["version"]]
[17:46:51.360]                           if (is.null(version)) 
[17:46:51.360]                             version <- utils::packageVersion("future")
[17:46:51.360]                         }
[17:46:51.360]                         else {
[17:46:51.360]                           version <- NULL
[17:46:51.360]                         }
[17:46:51.360]                         if (!has_future || version < "1.8.0") {
[17:46:51.360]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.360]                             "", base::R.version$version.string), 
[17:46:51.360]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:51.360]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:51.360]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.360]                               "release", "version")], collapse = " "), 
[17:46:51.360]                             hostname = base::Sys.info()[["nodename"]])
[17:46:51.360]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.360]                             info)
[17:46:51.360]                           info <- base::paste(info, collapse = "; ")
[17:46:51.360]                           if (!has_future) {
[17:46:51.360]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.360]                               info)
[17:46:51.360]                           }
[17:46:51.360]                           else {
[17:46:51.360]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.360]                               info, version)
[17:46:51.360]                           }
[17:46:51.360]                           base::stop(msg)
[17:46:51.360]                         }
[17:46:51.360]                       })
[17:46:51.360]                     }
[17:46:51.360]                     base::local({
[17:46:51.360]                       for (pkg in "stats") {
[17:46:51.360]                         base::loadNamespace(pkg)
[17:46:51.360]                         base::library(pkg, character.only = TRUE)
[17:46:51.360]                       }
[17:46:51.360]                     })
[17:46:51.360]                   }
[17:46:51.360]                   ...future.strategy.old <- future::plan("list")
[17:46:51.360]                   options(future.plan = NULL)
[17:46:51.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.360]                 }
[17:46:51.360]                 ...future.workdir <- getwd()
[17:46:51.360]             }
[17:46:51.360]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.360]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.360]         }
[17:46:51.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.360]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.360]             base::names(...future.oldOptions))
[17:46:51.360]     }
[17:46:51.360]     if (FALSE) {
[17:46:51.360]     }
[17:46:51.360]     else {
[17:46:51.360]         if (TRUE) {
[17:46:51.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.360]                 open = "w")
[17:46:51.360]         }
[17:46:51.360]         else {
[17:46:51.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.360]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.360]         }
[17:46:51.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.360]             base::sink(type = "output", split = FALSE)
[17:46:51.360]             base::close(...future.stdout)
[17:46:51.360]         }, add = TRUE)
[17:46:51.360]     }
[17:46:51.360]     ...future.frame <- base::sys.nframe()
[17:46:51.360]     ...future.conditions <- base::list()
[17:46:51.360]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.360]     if (FALSE) {
[17:46:51.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.360]     }
[17:46:51.360]     ...future.result <- base::tryCatch({
[17:46:51.360]         base::withCallingHandlers({
[17:46:51.360]             ...future.value <- base::withVisible(base::local({
[17:46:51.360]                 lm(weight ~ group - 1)
[17:46:51.360]             }))
[17:46:51.360]             future::FutureResult(value = ...future.value$value, 
[17:46:51.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.360]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.360]                     ...future.globalenv.names))
[17:46:51.360]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.360]         }, condition = base::local({
[17:46:51.360]             c <- base::c
[17:46:51.360]             inherits <- base::inherits
[17:46:51.360]             invokeRestart <- base::invokeRestart
[17:46:51.360]             length <- base::length
[17:46:51.360]             list <- base::list
[17:46:51.360]             seq.int <- base::seq.int
[17:46:51.360]             signalCondition <- base::signalCondition
[17:46:51.360]             sys.calls <- base::sys.calls
[17:46:51.360]             `[[` <- base::`[[`
[17:46:51.360]             `+` <- base::`+`
[17:46:51.360]             `<<-` <- base::`<<-`
[17:46:51.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.360]                   3L)]
[17:46:51.360]             }
[17:46:51.360]             function(cond) {
[17:46:51.360]                 is_error <- inherits(cond, "error")
[17:46:51.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.360]                   NULL)
[17:46:51.360]                 if (is_error) {
[17:46:51.360]                   sessionInformation <- function() {
[17:46:51.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.360]                       search = base::search(), system = base::Sys.info())
[17:46:51.360]                   }
[17:46:51.360]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.360]                     cond$call), session = sessionInformation(), 
[17:46:51.360]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.360]                   signalCondition(cond)
[17:46:51.360]                 }
[17:46:51.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.360]                 "immediateCondition"))) {
[17:46:51.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.360]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.360]                   if (TRUE && !signal) {
[17:46:51.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.360]                     {
[17:46:51.360]                       inherits <- base::inherits
[17:46:51.360]                       invokeRestart <- base::invokeRestart
[17:46:51.360]                       is.null <- base::is.null
[17:46:51.360]                       muffled <- FALSE
[17:46:51.360]                       if (inherits(cond, "message")) {
[17:46:51.360]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.360]                         if (muffled) 
[17:46:51.360]                           invokeRestart("muffleMessage")
[17:46:51.360]                       }
[17:46:51.360]                       else if (inherits(cond, "warning")) {
[17:46:51.360]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.360]                         if (muffled) 
[17:46:51.360]                           invokeRestart("muffleWarning")
[17:46:51.360]                       }
[17:46:51.360]                       else if (inherits(cond, "condition")) {
[17:46:51.360]                         if (!is.null(pattern)) {
[17:46:51.360]                           computeRestarts <- base::computeRestarts
[17:46:51.360]                           grepl <- base::grepl
[17:46:51.360]                           restarts <- computeRestarts(cond)
[17:46:51.360]                           for (restart in restarts) {
[17:46:51.360]                             name <- restart$name
[17:46:51.360]                             if (is.null(name)) 
[17:46:51.360]                               next
[17:46:51.360]                             if (!grepl(pattern, name)) 
[17:46:51.360]                               next
[17:46:51.360]                             invokeRestart(restart)
[17:46:51.360]                             muffled <- TRUE
[17:46:51.360]                             break
[17:46:51.360]                           }
[17:46:51.360]                         }
[17:46:51.360]                       }
[17:46:51.360]                       invisible(muffled)
[17:46:51.360]                     }
[17:46:51.360]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.360]                   }
[17:46:51.360]                 }
[17:46:51.360]                 else {
[17:46:51.360]                   if (TRUE) {
[17:46:51.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.360]                     {
[17:46:51.360]                       inherits <- base::inherits
[17:46:51.360]                       invokeRestart <- base::invokeRestart
[17:46:51.360]                       is.null <- base::is.null
[17:46:51.360]                       muffled <- FALSE
[17:46:51.360]                       if (inherits(cond, "message")) {
[17:46:51.360]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.360]                         if (muffled) 
[17:46:51.360]                           invokeRestart("muffleMessage")
[17:46:51.360]                       }
[17:46:51.360]                       else if (inherits(cond, "warning")) {
[17:46:51.360]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.360]                         if (muffled) 
[17:46:51.360]                           invokeRestart("muffleWarning")
[17:46:51.360]                       }
[17:46:51.360]                       else if (inherits(cond, "condition")) {
[17:46:51.360]                         if (!is.null(pattern)) {
[17:46:51.360]                           computeRestarts <- base::computeRestarts
[17:46:51.360]                           grepl <- base::grepl
[17:46:51.360]                           restarts <- computeRestarts(cond)
[17:46:51.360]                           for (restart in restarts) {
[17:46:51.360]                             name <- restart$name
[17:46:51.360]                             if (is.null(name)) 
[17:46:51.360]                               next
[17:46:51.360]                             if (!grepl(pattern, name)) 
[17:46:51.360]                               next
[17:46:51.360]                             invokeRestart(restart)
[17:46:51.360]                             muffled <- TRUE
[17:46:51.360]                             break
[17:46:51.360]                           }
[17:46:51.360]                         }
[17:46:51.360]                       }
[17:46:51.360]                       invisible(muffled)
[17:46:51.360]                     }
[17:46:51.360]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.360]                   }
[17:46:51.360]                 }
[17:46:51.360]             }
[17:46:51.360]         }))
[17:46:51.360]     }, error = function(ex) {
[17:46:51.360]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.360]                 ...future.rng), started = ...future.startTime, 
[17:46:51.360]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.360]             version = "1.8"), class = "FutureResult")
[17:46:51.360]     }, finally = {
[17:46:51.360]         if (!identical(...future.workdir, getwd())) 
[17:46:51.360]             setwd(...future.workdir)
[17:46:51.360]         {
[17:46:51.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.360]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.360]             }
[17:46:51.360]             base::options(...future.oldOptions)
[17:46:51.360]             if (.Platform$OS.type == "windows") {
[17:46:51.360]                 old_names <- names(...future.oldEnvVars)
[17:46:51.360]                 envs <- base::Sys.getenv()
[17:46:51.360]                 names <- names(envs)
[17:46:51.360]                 common <- intersect(names, old_names)
[17:46:51.360]                 added <- setdiff(names, old_names)
[17:46:51.360]                 removed <- setdiff(old_names, names)
[17:46:51.360]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.360]                   envs[common]]
[17:46:51.360]                 NAMES <- toupper(changed)
[17:46:51.360]                 args <- list()
[17:46:51.360]                 for (kk in seq_along(NAMES)) {
[17:46:51.360]                   name <- changed[[kk]]
[17:46:51.360]                   NAME <- NAMES[[kk]]
[17:46:51.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.360]                     next
[17:46:51.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.360]                 }
[17:46:51.360]                 NAMES <- toupper(added)
[17:46:51.360]                 for (kk in seq_along(NAMES)) {
[17:46:51.360]                   name <- added[[kk]]
[17:46:51.360]                   NAME <- NAMES[[kk]]
[17:46:51.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.360]                     next
[17:46:51.360]                   args[[name]] <- ""
[17:46:51.360]                 }
[17:46:51.360]                 NAMES <- toupper(removed)
[17:46:51.360]                 for (kk in seq_along(NAMES)) {
[17:46:51.360]                   name <- removed[[kk]]
[17:46:51.360]                   NAME <- NAMES[[kk]]
[17:46:51.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.360]                     next
[17:46:51.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.360]                 }
[17:46:51.360]                 if (length(args) > 0) 
[17:46:51.360]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.360]             }
[17:46:51.360]             else {
[17:46:51.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.360]             }
[17:46:51.360]             {
[17:46:51.360]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.360]                   0L) {
[17:46:51.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.360]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.360]                   base::options(opts)
[17:46:51.360]                 }
[17:46:51.360]                 {
[17:46:51.360]                   {
[17:46:51.360]                     NULL
[17:46:51.360]                     RNGkind("Mersenne-Twister")
[17:46:51.360]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:51.360]                       inherits = FALSE)
[17:46:51.360]                   }
[17:46:51.360]                   options(future.plan = NULL)
[17:46:51.360]                   if (is.na(NA_character_)) 
[17:46:51.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.360]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.360]                     .init = FALSE)
[17:46:51.360]                 }
[17:46:51.360]             }
[17:46:51.360]         }
[17:46:51.360]     })
[17:46:51.360]     if (TRUE) {
[17:46:51.360]         base::sink(type = "output", split = FALSE)
[17:46:51.360]         if (TRUE) {
[17:46:51.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.360]         }
[17:46:51.360]         else {
[17:46:51.360]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.360]         }
[17:46:51.360]         base::close(...future.stdout)
[17:46:51.360]         ...future.stdout <- NULL
[17:46:51.360]     }
[17:46:51.360]     ...future.result$conditions <- ...future.conditions
[17:46:51.360]     ...future.result$finished <- base::Sys.time()
[17:46:51.360]     ...future.result
[17:46:51.360] }
[17:46:51.362] assign_globals() ...
[17:46:51.362] List of 2
[17:46:51.362]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:46:51.362]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:46:51.362]  - attr(*, "where")=List of 2
[17:46:51.362]   ..$ weight:<environment: R_EmptyEnv> 
[17:46:51.362]   ..$ group :<environment: R_EmptyEnv> 
[17:46:51.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.362]  - attr(*, "resolved")= logi FALSE
[17:46:51.362]  - attr(*, "total_size")= num 896
[17:46:51.362]  - attr(*, "already-done")= logi TRUE
[17:46:51.365] - copied ‘weight’ to environment
[17:46:51.365] - copied ‘group’ to environment
[17:46:51.365] assign_globals() ... done
[17:46:51.366] plan(): Setting new future strategy stack:
[17:46:51.366] List of future strategies:
[17:46:51.366] 1. sequential:
[17:46:51.366]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.366]    - tweaked: FALSE
[17:46:51.366]    - call: NULL
[17:46:51.366] plan(): nbrOfWorkers() = 1
[17:46:51.368] plan(): Setting new future strategy stack:
[17:46:51.368] List of future strategies:
[17:46:51.368] 1. sequential:
[17:46:51.368]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.368]    - tweaked: FALSE
[17:46:51.368]    - call: plan(strategy)
[17:46:51.369] plan(): nbrOfWorkers() = 1
[17:46:51.369] SequentialFuture started (and completed)
[17:46:51.369] - Launch lazy future ... done
[17:46:51.370] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:46:51.372] getGlobalsAndPackages() ...
[17:46:51.372] Searching for globals...
[17:46:51.374] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:51.374] Searching for globals ... DONE
[17:46:51.374] Resolving globals: FALSE
[17:46:51.374] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:51.375] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:51.375] - globals: [2] ‘weight’, ‘group’
[17:46:51.375] - packages: [1] ‘stats’
[17:46:51.375] getGlobalsAndPackages() ... DONE
[17:46:51.375] run() for ‘Future’ ...
[17:46:51.375] - state: ‘created’
[17:46:51.376] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:51.376] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:51.376] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:51.376]   - Field: ‘label’
[17:46:51.376]   - Field: ‘local’
[17:46:51.376]   - Field: ‘owner’
[17:46:51.376]   - Field: ‘envir’
[17:46:51.376]   - Field: ‘packages’
[17:46:51.377]   - Field: ‘gc’
[17:46:51.377]   - Field: ‘conditions’
[17:46:51.377]   - Field: ‘expr’
[17:46:51.377]   - Field: ‘uuid’
[17:46:51.377]   - Field: ‘seed’
[17:46:51.377]   - Field: ‘version’
[17:46:51.377]   - Field: ‘result’
[17:46:51.377]   - Field: ‘asynchronous’
[17:46:51.380]   - Field: ‘calls’
[17:46:51.380]   - Field: ‘globals’
[17:46:51.380]   - Field: ‘stdout’
[17:46:51.380]   - Field: ‘earlySignal’
[17:46:51.380]   - Field: ‘lazy’
[17:46:51.380]   - Field: ‘state’
[17:46:51.380] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:51.380] - Launch lazy future ...
[17:46:51.381] Packages needed by the future expression (n = 1): ‘stats’
[17:46:51.381] Packages needed by future strategies (n = 0): <none>
[17:46:51.381] {
[17:46:51.381]     {
[17:46:51.381]         {
[17:46:51.381]             ...future.startTime <- base::Sys.time()
[17:46:51.381]             {
[17:46:51.381]                 {
[17:46:51.381]                   {
[17:46:51.381]                     {
[17:46:51.381]                       base::local({
[17:46:51.381]                         has_future <- base::requireNamespace("future", 
[17:46:51.381]                           quietly = TRUE)
[17:46:51.381]                         if (has_future) {
[17:46:51.381]                           ns <- base::getNamespace("future")
[17:46:51.381]                           version <- ns[[".package"]][["version"]]
[17:46:51.381]                           if (is.null(version)) 
[17:46:51.381]                             version <- utils::packageVersion("future")
[17:46:51.381]                         }
[17:46:51.381]                         else {
[17:46:51.381]                           version <- NULL
[17:46:51.381]                         }
[17:46:51.381]                         if (!has_future || version < "1.8.0") {
[17:46:51.381]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.381]                             "", base::R.version$version.string), 
[17:46:51.381]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:51.381]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:51.381]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.381]                               "release", "version")], collapse = " "), 
[17:46:51.381]                             hostname = base::Sys.info()[["nodename"]])
[17:46:51.381]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.381]                             info)
[17:46:51.381]                           info <- base::paste(info, collapse = "; ")
[17:46:51.381]                           if (!has_future) {
[17:46:51.381]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.381]                               info)
[17:46:51.381]                           }
[17:46:51.381]                           else {
[17:46:51.381]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.381]                               info, version)
[17:46:51.381]                           }
[17:46:51.381]                           base::stop(msg)
[17:46:51.381]                         }
[17:46:51.381]                       })
[17:46:51.381]                     }
[17:46:51.381]                     base::local({
[17:46:51.381]                       for (pkg in "stats") {
[17:46:51.381]                         base::loadNamespace(pkg)
[17:46:51.381]                         base::library(pkg, character.only = TRUE)
[17:46:51.381]                       }
[17:46:51.381]                     })
[17:46:51.381]                   }
[17:46:51.381]                   ...future.strategy.old <- future::plan("list")
[17:46:51.381]                   options(future.plan = NULL)
[17:46:51.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.381]                 }
[17:46:51.381]                 ...future.workdir <- getwd()
[17:46:51.381]             }
[17:46:51.381]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.381]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.381]         }
[17:46:51.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.381]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.381]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.381]             base::names(...future.oldOptions))
[17:46:51.381]     }
[17:46:51.381]     if (FALSE) {
[17:46:51.381]     }
[17:46:51.381]     else {
[17:46:51.381]         if (TRUE) {
[17:46:51.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.381]                 open = "w")
[17:46:51.381]         }
[17:46:51.381]         else {
[17:46:51.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.381]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.381]         }
[17:46:51.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.381]             base::sink(type = "output", split = FALSE)
[17:46:51.381]             base::close(...future.stdout)
[17:46:51.381]         }, add = TRUE)
[17:46:51.381]     }
[17:46:51.381]     ...future.frame <- base::sys.nframe()
[17:46:51.381]     ...future.conditions <- base::list()
[17:46:51.381]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.381]     if (FALSE) {
[17:46:51.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.381]     }
[17:46:51.381]     ...future.result <- base::tryCatch({
[17:46:51.381]         base::withCallingHandlers({
[17:46:51.381]             ...future.value <- base::withVisible(base::local({
[17:46:51.381]                 lm(weight ~ group - 1)
[17:46:51.381]             }))
[17:46:51.381]             future::FutureResult(value = ...future.value$value, 
[17:46:51.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.381]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.381]                     ...future.globalenv.names))
[17:46:51.381]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.381]         }, condition = base::local({
[17:46:51.381]             c <- base::c
[17:46:51.381]             inherits <- base::inherits
[17:46:51.381]             invokeRestart <- base::invokeRestart
[17:46:51.381]             length <- base::length
[17:46:51.381]             list <- base::list
[17:46:51.381]             seq.int <- base::seq.int
[17:46:51.381]             signalCondition <- base::signalCondition
[17:46:51.381]             sys.calls <- base::sys.calls
[17:46:51.381]             `[[` <- base::`[[`
[17:46:51.381]             `+` <- base::`+`
[17:46:51.381]             `<<-` <- base::`<<-`
[17:46:51.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.381]                   3L)]
[17:46:51.381]             }
[17:46:51.381]             function(cond) {
[17:46:51.381]                 is_error <- inherits(cond, "error")
[17:46:51.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.381]                   NULL)
[17:46:51.381]                 if (is_error) {
[17:46:51.381]                   sessionInformation <- function() {
[17:46:51.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.381]                       search = base::search(), system = base::Sys.info())
[17:46:51.381]                   }
[17:46:51.381]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.381]                     cond$call), session = sessionInformation(), 
[17:46:51.381]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.381]                   signalCondition(cond)
[17:46:51.381]                 }
[17:46:51.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.381]                 "immediateCondition"))) {
[17:46:51.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.381]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.381]                   if (TRUE && !signal) {
[17:46:51.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.381]                     {
[17:46:51.381]                       inherits <- base::inherits
[17:46:51.381]                       invokeRestart <- base::invokeRestart
[17:46:51.381]                       is.null <- base::is.null
[17:46:51.381]                       muffled <- FALSE
[17:46:51.381]                       if (inherits(cond, "message")) {
[17:46:51.381]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.381]                         if (muffled) 
[17:46:51.381]                           invokeRestart("muffleMessage")
[17:46:51.381]                       }
[17:46:51.381]                       else if (inherits(cond, "warning")) {
[17:46:51.381]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.381]                         if (muffled) 
[17:46:51.381]                           invokeRestart("muffleWarning")
[17:46:51.381]                       }
[17:46:51.381]                       else if (inherits(cond, "condition")) {
[17:46:51.381]                         if (!is.null(pattern)) {
[17:46:51.381]                           computeRestarts <- base::computeRestarts
[17:46:51.381]                           grepl <- base::grepl
[17:46:51.381]                           restarts <- computeRestarts(cond)
[17:46:51.381]                           for (restart in restarts) {
[17:46:51.381]                             name <- restart$name
[17:46:51.381]                             if (is.null(name)) 
[17:46:51.381]                               next
[17:46:51.381]                             if (!grepl(pattern, name)) 
[17:46:51.381]                               next
[17:46:51.381]                             invokeRestart(restart)
[17:46:51.381]                             muffled <- TRUE
[17:46:51.381]                             break
[17:46:51.381]                           }
[17:46:51.381]                         }
[17:46:51.381]                       }
[17:46:51.381]                       invisible(muffled)
[17:46:51.381]                     }
[17:46:51.381]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.381]                   }
[17:46:51.381]                 }
[17:46:51.381]                 else {
[17:46:51.381]                   if (TRUE) {
[17:46:51.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.381]                     {
[17:46:51.381]                       inherits <- base::inherits
[17:46:51.381]                       invokeRestart <- base::invokeRestart
[17:46:51.381]                       is.null <- base::is.null
[17:46:51.381]                       muffled <- FALSE
[17:46:51.381]                       if (inherits(cond, "message")) {
[17:46:51.381]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.381]                         if (muffled) 
[17:46:51.381]                           invokeRestart("muffleMessage")
[17:46:51.381]                       }
[17:46:51.381]                       else if (inherits(cond, "warning")) {
[17:46:51.381]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.381]                         if (muffled) 
[17:46:51.381]                           invokeRestart("muffleWarning")
[17:46:51.381]                       }
[17:46:51.381]                       else if (inherits(cond, "condition")) {
[17:46:51.381]                         if (!is.null(pattern)) {
[17:46:51.381]                           computeRestarts <- base::computeRestarts
[17:46:51.381]                           grepl <- base::grepl
[17:46:51.381]                           restarts <- computeRestarts(cond)
[17:46:51.381]                           for (restart in restarts) {
[17:46:51.381]                             name <- restart$name
[17:46:51.381]                             if (is.null(name)) 
[17:46:51.381]                               next
[17:46:51.381]                             if (!grepl(pattern, name)) 
[17:46:51.381]                               next
[17:46:51.381]                             invokeRestart(restart)
[17:46:51.381]                             muffled <- TRUE
[17:46:51.381]                             break
[17:46:51.381]                           }
[17:46:51.381]                         }
[17:46:51.381]                       }
[17:46:51.381]                       invisible(muffled)
[17:46:51.381]                     }
[17:46:51.381]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.381]                   }
[17:46:51.381]                 }
[17:46:51.381]             }
[17:46:51.381]         }))
[17:46:51.381]     }, error = function(ex) {
[17:46:51.381]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.381]                 ...future.rng), started = ...future.startTime, 
[17:46:51.381]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.381]             version = "1.8"), class = "FutureResult")
[17:46:51.381]     }, finally = {
[17:46:51.381]         if (!identical(...future.workdir, getwd())) 
[17:46:51.381]             setwd(...future.workdir)
[17:46:51.381]         {
[17:46:51.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.381]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.381]             }
[17:46:51.381]             base::options(...future.oldOptions)
[17:46:51.381]             if (.Platform$OS.type == "windows") {
[17:46:51.381]                 old_names <- names(...future.oldEnvVars)
[17:46:51.381]                 envs <- base::Sys.getenv()
[17:46:51.381]                 names <- names(envs)
[17:46:51.381]                 common <- intersect(names, old_names)
[17:46:51.381]                 added <- setdiff(names, old_names)
[17:46:51.381]                 removed <- setdiff(old_names, names)
[17:46:51.381]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.381]                   envs[common]]
[17:46:51.381]                 NAMES <- toupper(changed)
[17:46:51.381]                 args <- list()
[17:46:51.381]                 for (kk in seq_along(NAMES)) {
[17:46:51.381]                   name <- changed[[kk]]
[17:46:51.381]                   NAME <- NAMES[[kk]]
[17:46:51.381]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.381]                     next
[17:46:51.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.381]                 }
[17:46:51.381]                 NAMES <- toupper(added)
[17:46:51.381]                 for (kk in seq_along(NAMES)) {
[17:46:51.381]                   name <- added[[kk]]
[17:46:51.381]                   NAME <- NAMES[[kk]]
[17:46:51.381]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.381]                     next
[17:46:51.381]                   args[[name]] <- ""
[17:46:51.381]                 }
[17:46:51.381]                 NAMES <- toupper(removed)
[17:46:51.381]                 for (kk in seq_along(NAMES)) {
[17:46:51.381]                   name <- removed[[kk]]
[17:46:51.381]                   NAME <- NAMES[[kk]]
[17:46:51.381]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.381]                     next
[17:46:51.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.381]                 }
[17:46:51.381]                 if (length(args) > 0) 
[17:46:51.381]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.381]             }
[17:46:51.381]             else {
[17:46:51.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.381]             }
[17:46:51.381]             {
[17:46:51.381]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.381]                   0L) {
[17:46:51.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.381]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.381]                   base::options(opts)
[17:46:51.381]                 }
[17:46:51.381]                 {
[17:46:51.381]                   {
[17:46:51.381]                     NULL
[17:46:51.381]                     RNGkind("Mersenne-Twister")
[17:46:51.381]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:51.381]                       inherits = FALSE)
[17:46:51.381]                   }
[17:46:51.381]                   options(future.plan = NULL)
[17:46:51.381]                   if (is.na(NA_character_)) 
[17:46:51.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.381]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.381]                     .init = FALSE)
[17:46:51.381]                 }
[17:46:51.381]             }
[17:46:51.381]         }
[17:46:51.381]     })
[17:46:51.381]     if (TRUE) {
[17:46:51.381]         base::sink(type = "output", split = FALSE)
[17:46:51.381]         if (TRUE) {
[17:46:51.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.381]         }
[17:46:51.381]         else {
[17:46:51.381]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.381]         }
[17:46:51.381]         base::close(...future.stdout)
[17:46:51.381]         ...future.stdout <- NULL
[17:46:51.381]     }
[17:46:51.381]     ...future.result$conditions <- ...future.conditions
[17:46:51.381]     ...future.result$finished <- base::Sys.time()
[17:46:51.381]     ...future.result
[17:46:51.381] }
[17:46:51.383] assign_globals() ...
[17:46:51.383] List of 2
[17:46:51.383]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:46:51.383]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:46:51.383]  - attr(*, "where")=List of 2
[17:46:51.383]   ..$ weight:<environment: R_EmptyEnv> 
[17:46:51.383]   ..$ group :<environment: R_EmptyEnv> 
[17:46:51.383]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.383]  - attr(*, "resolved")= logi FALSE
[17:46:51.383]  - attr(*, "total_size")= num 896
[17:46:51.383]  - attr(*, "already-done")= logi TRUE
[17:46:51.386] - copied ‘weight’ to environment
[17:46:51.386] - copied ‘group’ to environment
[17:46:51.386] assign_globals() ... done
[17:46:51.387] plan(): Setting new future strategy stack:
[17:46:51.387] List of future strategies:
[17:46:51.387] 1. sequential:
[17:46:51.387]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.387]    - tweaked: FALSE
[17:46:51.387]    - call: NULL
[17:46:51.387] plan(): nbrOfWorkers() = 1
[17:46:51.389] plan(): Setting new future strategy stack:
[17:46:51.389] List of future strategies:
[17:46:51.389] 1. sequential:
[17:46:51.389]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.389]    - tweaked: FALSE
[17:46:51.389]    - call: plan(strategy)
[17:46:51.389] plan(): nbrOfWorkers() = 1
[17:46:51.389] SequentialFuture started (and completed)
[17:46:51.389] - Launch lazy future ... done
[17:46:51.389] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:46:51.392] getGlobalsAndPackages() ...
[17:46:51.392] Searching for globals...
[17:46:51.393] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:51.393] Searching for globals ... DONE
[17:46:51.393] Resolving globals: FALSE
[17:46:51.394] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:51.394] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:51.394] - globals: [2] ‘weight’, ‘group’
[17:46:51.395] - packages: [1] ‘stats’
[17:46:51.395] getGlobalsAndPackages() ... DONE
[17:46:51.395] run() for ‘Future’ ...
[17:46:51.395] - state: ‘created’
[17:46:51.395] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:51.395] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:51.396] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:51.396]   - Field: ‘label’
[17:46:51.396]   - Field: ‘local’
[17:46:51.396]   - Field: ‘owner’
[17:46:51.396]   - Field: ‘envir’
[17:46:51.396]   - Field: ‘packages’
[17:46:51.396]   - Field: ‘gc’
[17:46:51.396]   - Field: ‘conditions’
[17:46:51.396]   - Field: ‘expr’
[17:46:51.396]   - Field: ‘uuid’
[17:46:51.397]   - Field: ‘seed’
[17:46:51.397]   - Field: ‘version’
[17:46:51.397]   - Field: ‘result’
[17:46:51.397]   - Field: ‘asynchronous’
[17:46:51.397]   - Field: ‘calls’
[17:46:51.397]   - Field: ‘globals’
[17:46:51.397]   - Field: ‘stdout’
[17:46:51.397]   - Field: ‘earlySignal’
[17:46:51.397]   - Field: ‘lazy’
[17:46:51.397]   - Field: ‘state’
[17:46:51.397] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:51.398] - Launch lazy future ...
[17:46:51.398] Packages needed by the future expression (n = 1): ‘stats’
[17:46:51.398] Packages needed by future strategies (n = 0): <none>
[17:46:51.398] {
[17:46:51.398]     {
[17:46:51.398]         {
[17:46:51.398]             ...future.startTime <- base::Sys.time()
[17:46:51.398]             {
[17:46:51.398]                 {
[17:46:51.398]                   {
[17:46:51.398]                     {
[17:46:51.398]                       base::local({
[17:46:51.398]                         has_future <- base::requireNamespace("future", 
[17:46:51.398]                           quietly = TRUE)
[17:46:51.398]                         if (has_future) {
[17:46:51.398]                           ns <- base::getNamespace("future")
[17:46:51.398]                           version <- ns[[".package"]][["version"]]
[17:46:51.398]                           if (is.null(version)) 
[17:46:51.398]                             version <- utils::packageVersion("future")
[17:46:51.398]                         }
[17:46:51.398]                         else {
[17:46:51.398]                           version <- NULL
[17:46:51.398]                         }
[17:46:51.398]                         if (!has_future || version < "1.8.0") {
[17:46:51.398]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.398]                             "", base::R.version$version.string), 
[17:46:51.398]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:51.398]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:51.398]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.398]                               "release", "version")], collapse = " "), 
[17:46:51.398]                             hostname = base::Sys.info()[["nodename"]])
[17:46:51.398]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.398]                             info)
[17:46:51.398]                           info <- base::paste(info, collapse = "; ")
[17:46:51.398]                           if (!has_future) {
[17:46:51.398]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.398]                               info)
[17:46:51.398]                           }
[17:46:51.398]                           else {
[17:46:51.398]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.398]                               info, version)
[17:46:51.398]                           }
[17:46:51.398]                           base::stop(msg)
[17:46:51.398]                         }
[17:46:51.398]                       })
[17:46:51.398]                     }
[17:46:51.398]                     base::local({
[17:46:51.398]                       for (pkg in "stats") {
[17:46:51.398]                         base::loadNamespace(pkg)
[17:46:51.398]                         base::library(pkg, character.only = TRUE)
[17:46:51.398]                       }
[17:46:51.398]                     })
[17:46:51.398]                   }
[17:46:51.398]                   ...future.strategy.old <- future::plan("list")
[17:46:51.398]                   options(future.plan = NULL)
[17:46:51.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.398]                 }
[17:46:51.398]                 ...future.workdir <- getwd()
[17:46:51.398]             }
[17:46:51.398]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.398]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.398]         }
[17:46:51.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.398]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.398]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.398]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.398]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.398]             base::names(...future.oldOptions))
[17:46:51.398]     }
[17:46:51.398]     if (FALSE) {
[17:46:51.398]     }
[17:46:51.398]     else {
[17:46:51.398]         if (TRUE) {
[17:46:51.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.398]                 open = "w")
[17:46:51.398]         }
[17:46:51.398]         else {
[17:46:51.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.398]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.398]         }
[17:46:51.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.398]             base::sink(type = "output", split = FALSE)
[17:46:51.398]             base::close(...future.stdout)
[17:46:51.398]         }, add = TRUE)
[17:46:51.398]     }
[17:46:51.398]     ...future.frame <- base::sys.nframe()
[17:46:51.398]     ...future.conditions <- base::list()
[17:46:51.398]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.398]     if (FALSE) {
[17:46:51.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.398]     }
[17:46:51.398]     ...future.result <- base::tryCatch({
[17:46:51.398]         base::withCallingHandlers({
[17:46:51.398]             ...future.value <- base::withVisible(base::local({
[17:46:51.398]                 lm(weight ~ group - 1)
[17:46:51.398]             }))
[17:46:51.398]             future::FutureResult(value = ...future.value$value, 
[17:46:51.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.398]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.398]                     ...future.globalenv.names))
[17:46:51.398]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.398]         }, condition = base::local({
[17:46:51.398]             c <- base::c
[17:46:51.398]             inherits <- base::inherits
[17:46:51.398]             invokeRestart <- base::invokeRestart
[17:46:51.398]             length <- base::length
[17:46:51.398]             list <- base::list
[17:46:51.398]             seq.int <- base::seq.int
[17:46:51.398]             signalCondition <- base::signalCondition
[17:46:51.398]             sys.calls <- base::sys.calls
[17:46:51.398]             `[[` <- base::`[[`
[17:46:51.398]             `+` <- base::`+`
[17:46:51.398]             `<<-` <- base::`<<-`
[17:46:51.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.398]                   3L)]
[17:46:51.398]             }
[17:46:51.398]             function(cond) {
[17:46:51.398]                 is_error <- inherits(cond, "error")
[17:46:51.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.398]                   NULL)
[17:46:51.398]                 if (is_error) {
[17:46:51.398]                   sessionInformation <- function() {
[17:46:51.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.398]                       search = base::search(), system = base::Sys.info())
[17:46:51.398]                   }
[17:46:51.398]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.398]                     cond$call), session = sessionInformation(), 
[17:46:51.398]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.398]                   signalCondition(cond)
[17:46:51.398]                 }
[17:46:51.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.398]                 "immediateCondition"))) {
[17:46:51.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.398]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.398]                   if (TRUE && !signal) {
[17:46:51.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.398]                     {
[17:46:51.398]                       inherits <- base::inherits
[17:46:51.398]                       invokeRestart <- base::invokeRestart
[17:46:51.398]                       is.null <- base::is.null
[17:46:51.398]                       muffled <- FALSE
[17:46:51.398]                       if (inherits(cond, "message")) {
[17:46:51.398]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.398]                         if (muffled) 
[17:46:51.398]                           invokeRestart("muffleMessage")
[17:46:51.398]                       }
[17:46:51.398]                       else if (inherits(cond, "warning")) {
[17:46:51.398]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.398]                         if (muffled) 
[17:46:51.398]                           invokeRestart("muffleWarning")
[17:46:51.398]                       }
[17:46:51.398]                       else if (inherits(cond, "condition")) {
[17:46:51.398]                         if (!is.null(pattern)) {
[17:46:51.398]                           computeRestarts <- base::computeRestarts
[17:46:51.398]                           grepl <- base::grepl
[17:46:51.398]                           restarts <- computeRestarts(cond)
[17:46:51.398]                           for (restart in restarts) {
[17:46:51.398]                             name <- restart$name
[17:46:51.398]                             if (is.null(name)) 
[17:46:51.398]                               next
[17:46:51.398]                             if (!grepl(pattern, name)) 
[17:46:51.398]                               next
[17:46:51.398]                             invokeRestart(restart)
[17:46:51.398]                             muffled <- TRUE
[17:46:51.398]                             break
[17:46:51.398]                           }
[17:46:51.398]                         }
[17:46:51.398]                       }
[17:46:51.398]                       invisible(muffled)
[17:46:51.398]                     }
[17:46:51.398]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.398]                   }
[17:46:51.398]                 }
[17:46:51.398]                 else {
[17:46:51.398]                   if (TRUE) {
[17:46:51.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.398]                     {
[17:46:51.398]                       inherits <- base::inherits
[17:46:51.398]                       invokeRestart <- base::invokeRestart
[17:46:51.398]                       is.null <- base::is.null
[17:46:51.398]                       muffled <- FALSE
[17:46:51.398]                       if (inherits(cond, "message")) {
[17:46:51.398]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.398]                         if (muffled) 
[17:46:51.398]                           invokeRestart("muffleMessage")
[17:46:51.398]                       }
[17:46:51.398]                       else if (inherits(cond, "warning")) {
[17:46:51.398]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.398]                         if (muffled) 
[17:46:51.398]                           invokeRestart("muffleWarning")
[17:46:51.398]                       }
[17:46:51.398]                       else if (inherits(cond, "condition")) {
[17:46:51.398]                         if (!is.null(pattern)) {
[17:46:51.398]                           computeRestarts <- base::computeRestarts
[17:46:51.398]                           grepl <- base::grepl
[17:46:51.398]                           restarts <- computeRestarts(cond)
[17:46:51.398]                           for (restart in restarts) {
[17:46:51.398]                             name <- restart$name
[17:46:51.398]                             if (is.null(name)) 
[17:46:51.398]                               next
[17:46:51.398]                             if (!grepl(pattern, name)) 
[17:46:51.398]                               next
[17:46:51.398]                             invokeRestart(restart)
[17:46:51.398]                             muffled <- TRUE
[17:46:51.398]                             break
[17:46:51.398]                           }
[17:46:51.398]                         }
[17:46:51.398]                       }
[17:46:51.398]                       invisible(muffled)
[17:46:51.398]                     }
[17:46:51.398]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.398]                   }
[17:46:51.398]                 }
[17:46:51.398]             }
[17:46:51.398]         }))
[17:46:51.398]     }, error = function(ex) {
[17:46:51.398]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.398]                 ...future.rng), started = ...future.startTime, 
[17:46:51.398]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.398]             version = "1.8"), class = "FutureResult")
[17:46:51.398]     }, finally = {
[17:46:51.398]         if (!identical(...future.workdir, getwd())) 
[17:46:51.398]             setwd(...future.workdir)
[17:46:51.398]         {
[17:46:51.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.398]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.398]             }
[17:46:51.398]             base::options(...future.oldOptions)
[17:46:51.398]             if (.Platform$OS.type == "windows") {
[17:46:51.398]                 old_names <- names(...future.oldEnvVars)
[17:46:51.398]                 envs <- base::Sys.getenv()
[17:46:51.398]                 names <- names(envs)
[17:46:51.398]                 common <- intersect(names, old_names)
[17:46:51.398]                 added <- setdiff(names, old_names)
[17:46:51.398]                 removed <- setdiff(old_names, names)
[17:46:51.398]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.398]                   envs[common]]
[17:46:51.398]                 NAMES <- toupper(changed)
[17:46:51.398]                 args <- list()
[17:46:51.398]                 for (kk in seq_along(NAMES)) {
[17:46:51.398]                   name <- changed[[kk]]
[17:46:51.398]                   NAME <- NAMES[[kk]]
[17:46:51.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.398]                     next
[17:46:51.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.398]                 }
[17:46:51.398]                 NAMES <- toupper(added)
[17:46:51.398]                 for (kk in seq_along(NAMES)) {
[17:46:51.398]                   name <- added[[kk]]
[17:46:51.398]                   NAME <- NAMES[[kk]]
[17:46:51.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.398]                     next
[17:46:51.398]                   args[[name]] <- ""
[17:46:51.398]                 }
[17:46:51.398]                 NAMES <- toupper(removed)
[17:46:51.398]                 for (kk in seq_along(NAMES)) {
[17:46:51.398]                   name <- removed[[kk]]
[17:46:51.398]                   NAME <- NAMES[[kk]]
[17:46:51.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.398]                     next
[17:46:51.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.398]                 }
[17:46:51.398]                 if (length(args) > 0) 
[17:46:51.398]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.398]             }
[17:46:51.398]             else {
[17:46:51.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.398]             }
[17:46:51.398]             {
[17:46:51.398]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.398]                   0L) {
[17:46:51.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.398]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.398]                   base::options(opts)
[17:46:51.398]                 }
[17:46:51.398]                 {
[17:46:51.398]                   {
[17:46:51.398]                     NULL
[17:46:51.398]                     RNGkind("Mersenne-Twister")
[17:46:51.398]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:51.398]                       inherits = FALSE)
[17:46:51.398]                   }
[17:46:51.398]                   options(future.plan = NULL)
[17:46:51.398]                   if (is.na(NA_character_)) 
[17:46:51.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.398]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.398]                     .init = FALSE)
[17:46:51.398]                 }
[17:46:51.398]             }
[17:46:51.398]         }
[17:46:51.398]     })
[17:46:51.398]     if (TRUE) {
[17:46:51.398]         base::sink(type = "output", split = FALSE)
[17:46:51.398]         if (TRUE) {
[17:46:51.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.398]         }
[17:46:51.398]         else {
[17:46:51.398]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.398]         }
[17:46:51.398]         base::close(...future.stdout)
[17:46:51.398]         ...future.stdout <- NULL
[17:46:51.398]     }
[17:46:51.398]     ...future.result$conditions <- ...future.conditions
[17:46:51.398]     ...future.result$finished <- base::Sys.time()
[17:46:51.398]     ...future.result
[17:46:51.398] }
[17:46:51.400] assign_globals() ...
[17:46:51.400] List of 2
[17:46:51.400]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:46:51.400]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:46:51.400]  - attr(*, "where")=List of 2
[17:46:51.400]   ..$ weight:<environment: R_EmptyEnv> 
[17:46:51.400]   ..$ group :<environment: R_EmptyEnv> 
[17:46:51.400]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.400]  - attr(*, "resolved")= logi FALSE
[17:46:51.400]  - attr(*, "total_size")= num 896
[17:46:51.400]  - attr(*, "already-done")= logi TRUE
[17:46:51.403] - copied ‘weight’ to environment
[17:46:51.403] - copied ‘group’ to environment
[17:46:51.403] assign_globals() ... done
[17:46:51.403] plan(): Setting new future strategy stack:
[17:46:51.404] List of future strategies:
[17:46:51.404] 1. sequential:
[17:46:51.404]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.404]    - tweaked: FALSE
[17:46:51.404]    - call: NULL
[17:46:51.404] plan(): nbrOfWorkers() = 1
[17:46:51.405] plan(): Setting new future strategy stack:
[17:46:51.405] List of future strategies:
[17:46:51.405] 1. sequential:
[17:46:51.405]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.405]    - tweaked: FALSE
[17:46:51.405]    - call: plan(strategy)
[17:46:51.406] plan(): nbrOfWorkers() = 1
[17:46:51.406] SequentialFuture started (and completed)
[17:46:51.406] - Launch lazy future ... done
[17:46:51.406] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:46:51.410] getGlobalsAndPackages() ...
[17:46:51.410] Searching for globals...
[17:46:51.411] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:51.411] Searching for globals ... DONE
[17:46:51.412] Resolving globals: FALSE
[17:46:51.412] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:51.412] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:51.412] - globals: [2] ‘weight’, ‘group’
[17:46:51.413] - packages: [1] ‘stats’
[17:46:51.413] getGlobalsAndPackages() ... DONE
[17:46:51.413] run() for ‘Future’ ...
[17:46:51.413] - state: ‘created’
[17:46:51.413] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:51.413] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:51.414] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:51.414]   - Field: ‘label’
[17:46:51.414]   - Field: ‘local’
[17:46:51.414]   - Field: ‘owner’
[17:46:51.414]   - Field: ‘envir’
[17:46:51.414]   - Field: ‘packages’
[17:46:51.414]   - Field: ‘gc’
[17:46:51.414]   - Field: ‘conditions’
[17:46:51.414]   - Field: ‘expr’
[17:46:51.414]   - Field: ‘uuid’
[17:46:51.414]   - Field: ‘seed’
[17:46:51.415]   - Field: ‘version’
[17:46:51.415]   - Field: ‘result’
[17:46:51.415]   - Field: ‘asynchronous’
[17:46:51.415]   - Field: ‘calls’
[17:46:51.415]   - Field: ‘globals’
[17:46:51.415]   - Field: ‘stdout’
[17:46:51.415]   - Field: ‘earlySignal’
[17:46:51.415]   - Field: ‘lazy’
[17:46:51.415]   - Field: ‘state’
[17:46:51.415] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:51.415] - Launch lazy future ...
[17:46:51.416] Packages needed by the future expression (n = 1): ‘stats’
[17:46:51.416] Packages needed by future strategies (n = 0): <none>
[17:46:51.416] {
[17:46:51.416]     {
[17:46:51.416]         {
[17:46:51.416]             ...future.startTime <- base::Sys.time()
[17:46:51.416]             {
[17:46:51.416]                 {
[17:46:51.416]                   {
[17:46:51.416]                     {
[17:46:51.416]                       base::local({
[17:46:51.416]                         has_future <- base::requireNamespace("future", 
[17:46:51.416]                           quietly = TRUE)
[17:46:51.416]                         if (has_future) {
[17:46:51.416]                           ns <- base::getNamespace("future")
[17:46:51.416]                           version <- ns[[".package"]][["version"]]
[17:46:51.416]                           if (is.null(version)) 
[17:46:51.416]                             version <- utils::packageVersion("future")
[17:46:51.416]                         }
[17:46:51.416]                         else {
[17:46:51.416]                           version <- NULL
[17:46:51.416]                         }
[17:46:51.416]                         if (!has_future || version < "1.8.0") {
[17:46:51.416]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.416]                             "", base::R.version$version.string), 
[17:46:51.416]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:51.416]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:51.416]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.416]                               "release", "version")], collapse = " "), 
[17:46:51.416]                             hostname = base::Sys.info()[["nodename"]])
[17:46:51.416]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.416]                             info)
[17:46:51.416]                           info <- base::paste(info, collapse = "; ")
[17:46:51.416]                           if (!has_future) {
[17:46:51.416]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.416]                               info)
[17:46:51.416]                           }
[17:46:51.416]                           else {
[17:46:51.416]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.416]                               info, version)
[17:46:51.416]                           }
[17:46:51.416]                           base::stop(msg)
[17:46:51.416]                         }
[17:46:51.416]                       })
[17:46:51.416]                     }
[17:46:51.416]                     base::local({
[17:46:51.416]                       for (pkg in "stats") {
[17:46:51.416]                         base::loadNamespace(pkg)
[17:46:51.416]                         base::library(pkg, character.only = TRUE)
[17:46:51.416]                       }
[17:46:51.416]                     })
[17:46:51.416]                   }
[17:46:51.416]                   ...future.strategy.old <- future::plan("list")
[17:46:51.416]                   options(future.plan = NULL)
[17:46:51.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.416]                 }
[17:46:51.416]                 ...future.workdir <- getwd()
[17:46:51.416]             }
[17:46:51.416]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.416]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.416]         }
[17:46:51.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.416]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.416]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.416]             base::names(...future.oldOptions))
[17:46:51.416]     }
[17:46:51.416]     if (FALSE) {
[17:46:51.416]     }
[17:46:51.416]     else {
[17:46:51.416]         if (TRUE) {
[17:46:51.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.416]                 open = "w")
[17:46:51.416]         }
[17:46:51.416]         else {
[17:46:51.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.416]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.416]         }
[17:46:51.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.416]             base::sink(type = "output", split = FALSE)
[17:46:51.416]             base::close(...future.stdout)
[17:46:51.416]         }, add = TRUE)
[17:46:51.416]     }
[17:46:51.416]     ...future.frame <- base::sys.nframe()
[17:46:51.416]     ...future.conditions <- base::list()
[17:46:51.416]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.416]     if (FALSE) {
[17:46:51.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.416]     }
[17:46:51.416]     ...future.result <- base::tryCatch({
[17:46:51.416]         base::withCallingHandlers({
[17:46:51.416]             ...future.value <- base::withVisible(base::local({
[17:46:51.416]                 lm(weight ~ group - 1)
[17:46:51.416]             }))
[17:46:51.416]             future::FutureResult(value = ...future.value$value, 
[17:46:51.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.416]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.416]                     ...future.globalenv.names))
[17:46:51.416]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.416]         }, condition = base::local({
[17:46:51.416]             c <- base::c
[17:46:51.416]             inherits <- base::inherits
[17:46:51.416]             invokeRestart <- base::invokeRestart
[17:46:51.416]             length <- base::length
[17:46:51.416]             list <- base::list
[17:46:51.416]             seq.int <- base::seq.int
[17:46:51.416]             signalCondition <- base::signalCondition
[17:46:51.416]             sys.calls <- base::sys.calls
[17:46:51.416]             `[[` <- base::`[[`
[17:46:51.416]             `+` <- base::`+`
[17:46:51.416]             `<<-` <- base::`<<-`
[17:46:51.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.416]                   3L)]
[17:46:51.416]             }
[17:46:51.416]             function(cond) {
[17:46:51.416]                 is_error <- inherits(cond, "error")
[17:46:51.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.416]                   NULL)
[17:46:51.416]                 if (is_error) {
[17:46:51.416]                   sessionInformation <- function() {
[17:46:51.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.416]                       search = base::search(), system = base::Sys.info())
[17:46:51.416]                   }
[17:46:51.416]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.416]                     cond$call), session = sessionInformation(), 
[17:46:51.416]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.416]                   signalCondition(cond)
[17:46:51.416]                 }
[17:46:51.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.416]                 "immediateCondition"))) {
[17:46:51.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.416]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.416]                   if (TRUE && !signal) {
[17:46:51.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.416]                     {
[17:46:51.416]                       inherits <- base::inherits
[17:46:51.416]                       invokeRestart <- base::invokeRestart
[17:46:51.416]                       is.null <- base::is.null
[17:46:51.416]                       muffled <- FALSE
[17:46:51.416]                       if (inherits(cond, "message")) {
[17:46:51.416]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.416]                         if (muffled) 
[17:46:51.416]                           invokeRestart("muffleMessage")
[17:46:51.416]                       }
[17:46:51.416]                       else if (inherits(cond, "warning")) {
[17:46:51.416]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.416]                         if (muffled) 
[17:46:51.416]                           invokeRestart("muffleWarning")
[17:46:51.416]                       }
[17:46:51.416]                       else if (inherits(cond, "condition")) {
[17:46:51.416]                         if (!is.null(pattern)) {
[17:46:51.416]                           computeRestarts <- base::computeRestarts
[17:46:51.416]                           grepl <- base::grepl
[17:46:51.416]                           restarts <- computeRestarts(cond)
[17:46:51.416]                           for (restart in restarts) {
[17:46:51.416]                             name <- restart$name
[17:46:51.416]                             if (is.null(name)) 
[17:46:51.416]                               next
[17:46:51.416]                             if (!grepl(pattern, name)) 
[17:46:51.416]                               next
[17:46:51.416]                             invokeRestart(restart)
[17:46:51.416]                             muffled <- TRUE
[17:46:51.416]                             break
[17:46:51.416]                           }
[17:46:51.416]                         }
[17:46:51.416]                       }
[17:46:51.416]                       invisible(muffled)
[17:46:51.416]                     }
[17:46:51.416]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.416]                   }
[17:46:51.416]                 }
[17:46:51.416]                 else {
[17:46:51.416]                   if (TRUE) {
[17:46:51.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.416]                     {
[17:46:51.416]                       inherits <- base::inherits
[17:46:51.416]                       invokeRestart <- base::invokeRestart
[17:46:51.416]                       is.null <- base::is.null
[17:46:51.416]                       muffled <- FALSE
[17:46:51.416]                       if (inherits(cond, "message")) {
[17:46:51.416]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.416]                         if (muffled) 
[17:46:51.416]                           invokeRestart("muffleMessage")
[17:46:51.416]                       }
[17:46:51.416]                       else if (inherits(cond, "warning")) {
[17:46:51.416]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.416]                         if (muffled) 
[17:46:51.416]                           invokeRestart("muffleWarning")
[17:46:51.416]                       }
[17:46:51.416]                       else if (inherits(cond, "condition")) {
[17:46:51.416]                         if (!is.null(pattern)) {
[17:46:51.416]                           computeRestarts <- base::computeRestarts
[17:46:51.416]                           grepl <- base::grepl
[17:46:51.416]                           restarts <- computeRestarts(cond)
[17:46:51.416]                           for (restart in restarts) {
[17:46:51.416]                             name <- restart$name
[17:46:51.416]                             if (is.null(name)) 
[17:46:51.416]                               next
[17:46:51.416]                             if (!grepl(pattern, name)) 
[17:46:51.416]                               next
[17:46:51.416]                             invokeRestart(restart)
[17:46:51.416]                             muffled <- TRUE
[17:46:51.416]                             break
[17:46:51.416]                           }
[17:46:51.416]                         }
[17:46:51.416]                       }
[17:46:51.416]                       invisible(muffled)
[17:46:51.416]                     }
[17:46:51.416]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.416]                   }
[17:46:51.416]                 }
[17:46:51.416]             }
[17:46:51.416]         }))
[17:46:51.416]     }, error = function(ex) {
[17:46:51.416]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.416]                 ...future.rng), started = ...future.startTime, 
[17:46:51.416]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.416]             version = "1.8"), class = "FutureResult")
[17:46:51.416]     }, finally = {
[17:46:51.416]         if (!identical(...future.workdir, getwd())) 
[17:46:51.416]             setwd(...future.workdir)
[17:46:51.416]         {
[17:46:51.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.416]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.416]             }
[17:46:51.416]             base::options(...future.oldOptions)
[17:46:51.416]             if (.Platform$OS.type == "windows") {
[17:46:51.416]                 old_names <- names(...future.oldEnvVars)
[17:46:51.416]                 envs <- base::Sys.getenv()
[17:46:51.416]                 names <- names(envs)
[17:46:51.416]                 common <- intersect(names, old_names)
[17:46:51.416]                 added <- setdiff(names, old_names)
[17:46:51.416]                 removed <- setdiff(old_names, names)
[17:46:51.416]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.416]                   envs[common]]
[17:46:51.416]                 NAMES <- toupper(changed)
[17:46:51.416]                 args <- list()
[17:46:51.416]                 for (kk in seq_along(NAMES)) {
[17:46:51.416]                   name <- changed[[kk]]
[17:46:51.416]                   NAME <- NAMES[[kk]]
[17:46:51.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.416]                     next
[17:46:51.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.416]                 }
[17:46:51.416]                 NAMES <- toupper(added)
[17:46:51.416]                 for (kk in seq_along(NAMES)) {
[17:46:51.416]                   name <- added[[kk]]
[17:46:51.416]                   NAME <- NAMES[[kk]]
[17:46:51.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.416]                     next
[17:46:51.416]                   args[[name]] <- ""
[17:46:51.416]                 }
[17:46:51.416]                 NAMES <- toupper(removed)
[17:46:51.416]                 for (kk in seq_along(NAMES)) {
[17:46:51.416]                   name <- removed[[kk]]
[17:46:51.416]                   NAME <- NAMES[[kk]]
[17:46:51.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.416]                     next
[17:46:51.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.416]                 }
[17:46:51.416]                 if (length(args) > 0) 
[17:46:51.416]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.416]             }
[17:46:51.416]             else {
[17:46:51.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.416]             }
[17:46:51.416]             {
[17:46:51.416]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.416]                   0L) {
[17:46:51.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.416]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.416]                   base::options(opts)
[17:46:51.416]                 }
[17:46:51.416]                 {
[17:46:51.416]                   {
[17:46:51.416]                     NULL
[17:46:51.416]                     RNGkind("Mersenne-Twister")
[17:46:51.416]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:51.416]                       inherits = FALSE)
[17:46:51.416]                   }
[17:46:51.416]                   options(future.plan = NULL)
[17:46:51.416]                   if (is.na(NA_character_)) 
[17:46:51.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.416]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.416]                     .init = FALSE)
[17:46:51.416]                 }
[17:46:51.416]             }
[17:46:51.416]         }
[17:46:51.416]     })
[17:46:51.416]     if (TRUE) {
[17:46:51.416]         base::sink(type = "output", split = FALSE)
[17:46:51.416]         if (TRUE) {
[17:46:51.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.416]         }
[17:46:51.416]         else {
[17:46:51.416]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.416]         }
[17:46:51.416]         base::close(...future.stdout)
[17:46:51.416]         ...future.stdout <- NULL
[17:46:51.416]     }
[17:46:51.416]     ...future.result$conditions <- ...future.conditions
[17:46:51.416]     ...future.result$finished <- base::Sys.time()
[17:46:51.416]     ...future.result
[17:46:51.416] }
[17:46:51.418] assign_globals() ...
[17:46:51.418] List of 2
[17:46:51.418]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:46:51.418]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:46:51.418]  - attr(*, "where")=List of 2
[17:46:51.418]   ..$ weight:<environment: R_EmptyEnv> 
[17:46:51.418]   ..$ group :<environment: R_EmptyEnv> 
[17:46:51.418]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.418]  - attr(*, "resolved")= logi FALSE
[17:46:51.418]  - attr(*, "total_size")= num 896
[17:46:51.418]  - attr(*, "already-done")= logi TRUE
[17:46:51.421] - copied ‘weight’ to environment
[17:46:51.421] - copied ‘group’ to environment
[17:46:51.421] assign_globals() ... done
[17:46:51.421] plan(): Setting new future strategy stack:
[17:46:51.421] List of future strategies:
[17:46:51.421] 1. sequential:
[17:46:51.421]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.421]    - tweaked: FALSE
[17:46:51.421]    - call: NULL
[17:46:51.422] plan(): nbrOfWorkers() = 1
[17:46:51.423] plan(): Setting new future strategy stack:
[17:46:51.423] List of future strategies:
[17:46:51.423] 1. sequential:
[17:46:51.423]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.423]    - tweaked: FALSE
[17:46:51.423]    - call: plan(strategy)
[17:46:51.424] plan(): nbrOfWorkers() = 1
[17:46:51.424] SequentialFuture started (and completed)
[17:46:51.424] - Launch lazy future ... done
[17:46:51.424] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:46:51.426] getGlobalsAndPackages() ...
[17:46:51.426] Searching for globals...
[17:46:51.427] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:51.427] Searching for globals ... DONE
[17:46:51.427] Resolving globals: FALSE
[17:46:51.428] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:51.428] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:51.428] - globals: [2] ‘weight’, ‘group’
[17:46:51.428] - packages: [1] ‘stats’
[17:46:51.429] getGlobalsAndPackages() ... DONE
[17:46:51.429] run() for ‘Future’ ...
[17:46:51.429] - state: ‘created’
[17:46:51.429] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:51.429] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:51.429] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:51.430]   - Field: ‘label’
[17:46:51.430]   - Field: ‘local’
[17:46:51.430]   - Field: ‘owner’
[17:46:51.430]   - Field: ‘envir’
[17:46:51.430]   - Field: ‘packages’
[17:46:51.430]   - Field: ‘gc’
[17:46:51.430]   - Field: ‘conditions’
[17:46:51.430]   - Field: ‘expr’
[17:46:51.430]   - Field: ‘uuid’
[17:46:51.430]   - Field: ‘seed’
[17:46:51.430]   - Field: ‘version’
[17:46:51.430]   - Field: ‘result’
[17:46:51.431]   - Field: ‘asynchronous’
[17:46:51.431]   - Field: ‘calls’
[17:46:51.431]   - Field: ‘globals’
[17:46:51.431]   - Field: ‘stdout’
[17:46:51.431]   - Field: ‘earlySignal’
[17:46:51.431]   - Field: ‘lazy’
[17:46:51.431]   - Field: ‘state’
[17:46:51.431] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:51.431] - Launch lazy future ...
[17:46:51.431] Packages needed by the future expression (n = 1): ‘stats’
[17:46:51.432] Packages needed by future strategies (n = 0): <none>
[17:46:51.433] {
[17:46:51.433]     {
[17:46:51.433]         {
[17:46:51.433]             ...future.startTime <- base::Sys.time()
[17:46:51.433]             {
[17:46:51.433]                 {
[17:46:51.433]                   {
[17:46:51.433]                     {
[17:46:51.433]                       base::local({
[17:46:51.433]                         has_future <- base::requireNamespace("future", 
[17:46:51.433]                           quietly = TRUE)
[17:46:51.433]                         if (has_future) {
[17:46:51.433]                           ns <- base::getNamespace("future")
[17:46:51.433]                           version <- ns[[".package"]][["version"]]
[17:46:51.433]                           if (is.null(version)) 
[17:46:51.433]                             version <- utils::packageVersion("future")
[17:46:51.433]                         }
[17:46:51.433]                         else {
[17:46:51.433]                           version <- NULL
[17:46:51.433]                         }
[17:46:51.433]                         if (!has_future || version < "1.8.0") {
[17:46:51.433]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.433]                             "", base::R.version$version.string), 
[17:46:51.433]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:51.433]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:51.433]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.433]                               "release", "version")], collapse = " "), 
[17:46:51.433]                             hostname = base::Sys.info()[["nodename"]])
[17:46:51.433]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.433]                             info)
[17:46:51.433]                           info <- base::paste(info, collapse = "; ")
[17:46:51.433]                           if (!has_future) {
[17:46:51.433]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.433]                               info)
[17:46:51.433]                           }
[17:46:51.433]                           else {
[17:46:51.433]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.433]                               info, version)
[17:46:51.433]                           }
[17:46:51.433]                           base::stop(msg)
[17:46:51.433]                         }
[17:46:51.433]                       })
[17:46:51.433]                     }
[17:46:51.433]                     base::local({
[17:46:51.433]                       for (pkg in "stats") {
[17:46:51.433]                         base::loadNamespace(pkg)
[17:46:51.433]                         base::library(pkg, character.only = TRUE)
[17:46:51.433]                       }
[17:46:51.433]                     })
[17:46:51.433]                   }
[17:46:51.433]                   ...future.strategy.old <- future::plan("list")
[17:46:51.433]                   options(future.plan = NULL)
[17:46:51.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.433]                 }
[17:46:51.433]                 ...future.workdir <- getwd()
[17:46:51.433]             }
[17:46:51.433]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.433]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.433]         }
[17:46:51.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.433]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.433]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.433]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.433]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.433]             base::names(...future.oldOptions))
[17:46:51.433]     }
[17:46:51.433]     if (FALSE) {
[17:46:51.433]     }
[17:46:51.433]     else {
[17:46:51.433]         if (TRUE) {
[17:46:51.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.433]                 open = "w")
[17:46:51.433]         }
[17:46:51.433]         else {
[17:46:51.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.433]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.433]         }
[17:46:51.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.433]             base::sink(type = "output", split = FALSE)
[17:46:51.433]             base::close(...future.stdout)
[17:46:51.433]         }, add = TRUE)
[17:46:51.433]     }
[17:46:51.433]     ...future.frame <- base::sys.nframe()
[17:46:51.433]     ...future.conditions <- base::list()
[17:46:51.433]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.433]     if (FALSE) {
[17:46:51.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.433]     }
[17:46:51.433]     ...future.result <- base::tryCatch({
[17:46:51.433]         base::withCallingHandlers({
[17:46:51.433]             ...future.value <- base::withVisible(base::local({
[17:46:51.433]                 lm(weight ~ group - 1)
[17:46:51.433]             }))
[17:46:51.433]             future::FutureResult(value = ...future.value$value, 
[17:46:51.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.433]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.433]                     ...future.globalenv.names))
[17:46:51.433]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.433]         }, condition = base::local({
[17:46:51.433]             c <- base::c
[17:46:51.433]             inherits <- base::inherits
[17:46:51.433]             invokeRestart <- base::invokeRestart
[17:46:51.433]             length <- base::length
[17:46:51.433]             list <- base::list
[17:46:51.433]             seq.int <- base::seq.int
[17:46:51.433]             signalCondition <- base::signalCondition
[17:46:51.433]             sys.calls <- base::sys.calls
[17:46:51.433]             `[[` <- base::`[[`
[17:46:51.433]             `+` <- base::`+`
[17:46:51.433]             `<<-` <- base::`<<-`
[17:46:51.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.433]                   3L)]
[17:46:51.433]             }
[17:46:51.433]             function(cond) {
[17:46:51.433]                 is_error <- inherits(cond, "error")
[17:46:51.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.433]                   NULL)
[17:46:51.433]                 if (is_error) {
[17:46:51.433]                   sessionInformation <- function() {
[17:46:51.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.433]                       search = base::search(), system = base::Sys.info())
[17:46:51.433]                   }
[17:46:51.433]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.433]                     cond$call), session = sessionInformation(), 
[17:46:51.433]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.433]                   signalCondition(cond)
[17:46:51.433]                 }
[17:46:51.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.433]                 "immediateCondition"))) {
[17:46:51.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.433]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.433]                   if (TRUE && !signal) {
[17:46:51.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.433]                     {
[17:46:51.433]                       inherits <- base::inherits
[17:46:51.433]                       invokeRestart <- base::invokeRestart
[17:46:51.433]                       is.null <- base::is.null
[17:46:51.433]                       muffled <- FALSE
[17:46:51.433]                       if (inherits(cond, "message")) {
[17:46:51.433]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.433]                         if (muffled) 
[17:46:51.433]                           invokeRestart("muffleMessage")
[17:46:51.433]                       }
[17:46:51.433]                       else if (inherits(cond, "warning")) {
[17:46:51.433]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.433]                         if (muffled) 
[17:46:51.433]                           invokeRestart("muffleWarning")
[17:46:51.433]                       }
[17:46:51.433]                       else if (inherits(cond, "condition")) {
[17:46:51.433]                         if (!is.null(pattern)) {
[17:46:51.433]                           computeRestarts <- base::computeRestarts
[17:46:51.433]                           grepl <- base::grepl
[17:46:51.433]                           restarts <- computeRestarts(cond)
[17:46:51.433]                           for (restart in restarts) {
[17:46:51.433]                             name <- restart$name
[17:46:51.433]                             if (is.null(name)) 
[17:46:51.433]                               next
[17:46:51.433]                             if (!grepl(pattern, name)) 
[17:46:51.433]                               next
[17:46:51.433]                             invokeRestart(restart)
[17:46:51.433]                             muffled <- TRUE
[17:46:51.433]                             break
[17:46:51.433]                           }
[17:46:51.433]                         }
[17:46:51.433]                       }
[17:46:51.433]                       invisible(muffled)
[17:46:51.433]                     }
[17:46:51.433]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.433]                   }
[17:46:51.433]                 }
[17:46:51.433]                 else {
[17:46:51.433]                   if (TRUE) {
[17:46:51.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.433]                     {
[17:46:51.433]                       inherits <- base::inherits
[17:46:51.433]                       invokeRestart <- base::invokeRestart
[17:46:51.433]                       is.null <- base::is.null
[17:46:51.433]                       muffled <- FALSE
[17:46:51.433]                       if (inherits(cond, "message")) {
[17:46:51.433]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.433]                         if (muffled) 
[17:46:51.433]                           invokeRestart("muffleMessage")
[17:46:51.433]                       }
[17:46:51.433]                       else if (inherits(cond, "warning")) {
[17:46:51.433]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.433]                         if (muffled) 
[17:46:51.433]                           invokeRestart("muffleWarning")
[17:46:51.433]                       }
[17:46:51.433]                       else if (inherits(cond, "condition")) {
[17:46:51.433]                         if (!is.null(pattern)) {
[17:46:51.433]                           computeRestarts <- base::computeRestarts
[17:46:51.433]                           grepl <- base::grepl
[17:46:51.433]                           restarts <- computeRestarts(cond)
[17:46:51.433]                           for (restart in restarts) {
[17:46:51.433]                             name <- restart$name
[17:46:51.433]                             if (is.null(name)) 
[17:46:51.433]                               next
[17:46:51.433]                             if (!grepl(pattern, name)) 
[17:46:51.433]                               next
[17:46:51.433]                             invokeRestart(restart)
[17:46:51.433]                             muffled <- TRUE
[17:46:51.433]                             break
[17:46:51.433]                           }
[17:46:51.433]                         }
[17:46:51.433]                       }
[17:46:51.433]                       invisible(muffled)
[17:46:51.433]                     }
[17:46:51.433]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.433]                   }
[17:46:51.433]                 }
[17:46:51.433]             }
[17:46:51.433]         }))
[17:46:51.433]     }, error = function(ex) {
[17:46:51.433]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.433]                 ...future.rng), started = ...future.startTime, 
[17:46:51.433]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.433]             version = "1.8"), class = "FutureResult")
[17:46:51.433]     }, finally = {
[17:46:51.433]         if (!identical(...future.workdir, getwd())) 
[17:46:51.433]             setwd(...future.workdir)
[17:46:51.433]         {
[17:46:51.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.433]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.433]             }
[17:46:51.433]             base::options(...future.oldOptions)
[17:46:51.433]             if (.Platform$OS.type == "windows") {
[17:46:51.433]                 old_names <- names(...future.oldEnvVars)
[17:46:51.433]                 envs <- base::Sys.getenv()
[17:46:51.433]                 names <- names(envs)
[17:46:51.433]                 common <- intersect(names, old_names)
[17:46:51.433]                 added <- setdiff(names, old_names)
[17:46:51.433]                 removed <- setdiff(old_names, names)
[17:46:51.433]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.433]                   envs[common]]
[17:46:51.433]                 NAMES <- toupper(changed)
[17:46:51.433]                 args <- list()
[17:46:51.433]                 for (kk in seq_along(NAMES)) {
[17:46:51.433]                   name <- changed[[kk]]
[17:46:51.433]                   NAME <- NAMES[[kk]]
[17:46:51.433]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.433]                     next
[17:46:51.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.433]                 }
[17:46:51.433]                 NAMES <- toupper(added)
[17:46:51.433]                 for (kk in seq_along(NAMES)) {
[17:46:51.433]                   name <- added[[kk]]
[17:46:51.433]                   NAME <- NAMES[[kk]]
[17:46:51.433]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.433]                     next
[17:46:51.433]                   args[[name]] <- ""
[17:46:51.433]                 }
[17:46:51.433]                 NAMES <- toupper(removed)
[17:46:51.433]                 for (kk in seq_along(NAMES)) {
[17:46:51.433]                   name <- removed[[kk]]
[17:46:51.433]                   NAME <- NAMES[[kk]]
[17:46:51.433]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.433]                     next
[17:46:51.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.433]                 }
[17:46:51.433]                 if (length(args) > 0) 
[17:46:51.433]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.433]             }
[17:46:51.433]             else {
[17:46:51.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.433]             }
[17:46:51.433]             {
[17:46:51.433]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.433]                   0L) {
[17:46:51.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.433]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.433]                   base::options(opts)
[17:46:51.433]                 }
[17:46:51.433]                 {
[17:46:51.433]                   {
[17:46:51.433]                     NULL
[17:46:51.433]                     RNGkind("Mersenne-Twister")
[17:46:51.433]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:51.433]                       inherits = FALSE)
[17:46:51.433]                   }
[17:46:51.433]                   options(future.plan = NULL)
[17:46:51.433]                   if (is.na(NA_character_)) 
[17:46:51.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.433]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.433]                     .init = FALSE)
[17:46:51.433]                 }
[17:46:51.433]             }
[17:46:51.433]         }
[17:46:51.433]     })
[17:46:51.433]     if (TRUE) {
[17:46:51.433]         base::sink(type = "output", split = FALSE)
[17:46:51.433]         if (TRUE) {
[17:46:51.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.433]         }
[17:46:51.433]         else {
[17:46:51.433]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.433]         }
[17:46:51.433]         base::close(...future.stdout)
[17:46:51.433]         ...future.stdout <- NULL
[17:46:51.433]     }
[17:46:51.433]     ...future.result$conditions <- ...future.conditions
[17:46:51.433]     ...future.result$finished <- base::Sys.time()
[17:46:51.433]     ...future.result
[17:46:51.433] }
[17:46:51.435] assign_globals() ...
[17:46:51.435] List of 2
[17:46:51.435]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:46:51.435]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:46:51.435]  - attr(*, "where")=List of 2
[17:46:51.435]   ..$ weight:<environment: R_EmptyEnv> 
[17:46:51.435]   ..$ group :<environment: R_EmptyEnv> 
[17:46:51.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.435]  - attr(*, "resolved")= logi FALSE
[17:46:51.435]  - attr(*, "total_size")= num 896
[17:46:51.435]  - attr(*, "already-done")= logi TRUE
[17:46:51.438] - copied ‘weight’ to environment
[17:46:51.438] - copied ‘group’ to environment
[17:46:51.438] assign_globals() ... done
[17:46:51.439] plan(): Setting new future strategy stack:
[17:46:51.439] List of future strategies:
[17:46:51.439] 1. sequential:
[17:46:51.439]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.439]    - tweaked: FALSE
[17:46:51.439]    - call: NULL
[17:46:51.439] plan(): nbrOfWorkers() = 1
[17:46:51.441] plan(): Setting new future strategy stack:
[17:46:51.441] List of future strategies:
[17:46:51.441] 1. sequential:
[17:46:51.441]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.441]    - tweaked: FALSE
[17:46:51.441]    - call: plan(strategy)
[17:46:51.441] plan(): nbrOfWorkers() = 1
[17:46:51.441] SequentialFuture started (and completed)
[17:46:51.442] - Launch lazy future ... done
[17:46:51.442] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[17:46:51.443] getGlobalsAndPackages() ...
[17:46:51.443] Searching for globals...
[17:46:51.444] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:46:51.445] Searching for globals ... DONE
[17:46:51.445] Resolving globals: FALSE
[17:46:51.445] The total size of the 1 globals is 96 bytes (96 bytes)
[17:46:51.445] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:46:51.445] - globals: [1] ‘x’
[17:46:51.446] - packages: [1] ‘stats’
[17:46:51.446] getGlobalsAndPackages() ... DONE
[17:46:51.446] run() for ‘Future’ ...
[17:46:51.446] - state: ‘created’
[17:46:51.446] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:51.446] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:51.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:51.447]   - Field: ‘label’
[17:46:51.447]   - Field: ‘local’
[17:46:51.447]   - Field: ‘owner’
[17:46:51.447]   - Field: ‘envir’
[17:46:51.447]   - Field: ‘packages’
[17:46:51.447]   - Field: ‘gc’
[17:46:51.447]   - Field: ‘conditions’
[17:46:51.447]   - Field: ‘expr’
[17:46:51.447]   - Field: ‘uuid’
[17:46:51.447]   - Field: ‘seed’
[17:46:51.448]   - Field: ‘version’
[17:46:51.448]   - Field: ‘result’
[17:46:51.448]   - Field: ‘asynchronous’
[17:46:51.448]   - Field: ‘calls’
[17:46:51.448]   - Field: ‘globals’
[17:46:51.448]   - Field: ‘stdout’
[17:46:51.448]   - Field: ‘earlySignal’
[17:46:51.448]   - Field: ‘lazy’
[17:46:51.448]   - Field: ‘state’
[17:46:51.448] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:51.448] - Launch lazy future ...
[17:46:51.449] Packages needed by the future expression (n = 1): ‘stats’
[17:46:51.449] Packages needed by future strategies (n = 0): <none>
[17:46:51.449] {
[17:46:51.449]     {
[17:46:51.449]         {
[17:46:51.449]             ...future.startTime <- base::Sys.time()
[17:46:51.449]             {
[17:46:51.449]                 {
[17:46:51.449]                   {
[17:46:51.449]                     {
[17:46:51.449]                       base::local({
[17:46:51.449]                         has_future <- base::requireNamespace("future", 
[17:46:51.449]                           quietly = TRUE)
[17:46:51.449]                         if (has_future) {
[17:46:51.449]                           ns <- base::getNamespace("future")
[17:46:51.449]                           version <- ns[[".package"]][["version"]]
[17:46:51.449]                           if (is.null(version)) 
[17:46:51.449]                             version <- utils::packageVersion("future")
[17:46:51.449]                         }
[17:46:51.449]                         else {
[17:46:51.449]                           version <- NULL
[17:46:51.449]                         }
[17:46:51.449]                         if (!has_future || version < "1.8.0") {
[17:46:51.449]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.449]                             "", base::R.version$version.string), 
[17:46:51.449]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:51.449]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:51.449]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.449]                               "release", "version")], collapse = " "), 
[17:46:51.449]                             hostname = base::Sys.info()[["nodename"]])
[17:46:51.449]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.449]                             info)
[17:46:51.449]                           info <- base::paste(info, collapse = "; ")
[17:46:51.449]                           if (!has_future) {
[17:46:51.449]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.449]                               info)
[17:46:51.449]                           }
[17:46:51.449]                           else {
[17:46:51.449]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.449]                               info, version)
[17:46:51.449]                           }
[17:46:51.449]                           base::stop(msg)
[17:46:51.449]                         }
[17:46:51.449]                       })
[17:46:51.449]                     }
[17:46:51.449]                     base::local({
[17:46:51.449]                       for (pkg in "stats") {
[17:46:51.449]                         base::loadNamespace(pkg)
[17:46:51.449]                         base::library(pkg, character.only = TRUE)
[17:46:51.449]                       }
[17:46:51.449]                     })
[17:46:51.449]                   }
[17:46:51.449]                   ...future.strategy.old <- future::plan("list")
[17:46:51.449]                   options(future.plan = NULL)
[17:46:51.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.449]                 }
[17:46:51.449]                 ...future.workdir <- getwd()
[17:46:51.449]             }
[17:46:51.449]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.449]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.449]         }
[17:46:51.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.449]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.449]             base::names(...future.oldOptions))
[17:46:51.449]     }
[17:46:51.449]     if (FALSE) {
[17:46:51.449]     }
[17:46:51.449]     else {
[17:46:51.449]         if (TRUE) {
[17:46:51.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.449]                 open = "w")
[17:46:51.449]         }
[17:46:51.449]         else {
[17:46:51.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.449]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.449]         }
[17:46:51.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.449]             base::sink(type = "output", split = FALSE)
[17:46:51.449]             base::close(...future.stdout)
[17:46:51.449]         }, add = TRUE)
[17:46:51.449]     }
[17:46:51.449]     ...future.frame <- base::sys.nframe()
[17:46:51.449]     ...future.conditions <- base::list()
[17:46:51.449]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.449]     if (FALSE) {
[17:46:51.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.449]     }
[17:46:51.449]     ...future.result <- base::tryCatch({
[17:46:51.449]         base::withCallingHandlers({
[17:46:51.449]             ...future.value <- base::withVisible(base::local({
[17:46:51.449]                 xtabs(~x)
[17:46:51.449]             }))
[17:46:51.449]             future::FutureResult(value = ...future.value$value, 
[17:46:51.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.449]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.449]                     ...future.globalenv.names))
[17:46:51.449]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.449]         }, condition = base::local({
[17:46:51.449]             c <- base::c
[17:46:51.449]             inherits <- base::inherits
[17:46:51.449]             invokeRestart <- base::invokeRestart
[17:46:51.449]             length <- base::length
[17:46:51.449]             list <- base::list
[17:46:51.449]             seq.int <- base::seq.int
[17:46:51.449]             signalCondition <- base::signalCondition
[17:46:51.449]             sys.calls <- base::sys.calls
[17:46:51.449]             `[[` <- base::`[[`
[17:46:51.449]             `+` <- base::`+`
[17:46:51.449]             `<<-` <- base::`<<-`
[17:46:51.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.449]                   3L)]
[17:46:51.449]             }
[17:46:51.449]             function(cond) {
[17:46:51.449]                 is_error <- inherits(cond, "error")
[17:46:51.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.449]                   NULL)
[17:46:51.449]                 if (is_error) {
[17:46:51.449]                   sessionInformation <- function() {
[17:46:51.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.449]                       search = base::search(), system = base::Sys.info())
[17:46:51.449]                   }
[17:46:51.449]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.449]                     cond$call), session = sessionInformation(), 
[17:46:51.449]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.449]                   signalCondition(cond)
[17:46:51.449]                 }
[17:46:51.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.449]                 "immediateCondition"))) {
[17:46:51.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.449]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.449]                   if (TRUE && !signal) {
[17:46:51.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.449]                     {
[17:46:51.449]                       inherits <- base::inherits
[17:46:51.449]                       invokeRestart <- base::invokeRestart
[17:46:51.449]                       is.null <- base::is.null
[17:46:51.449]                       muffled <- FALSE
[17:46:51.449]                       if (inherits(cond, "message")) {
[17:46:51.449]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.449]                         if (muffled) 
[17:46:51.449]                           invokeRestart("muffleMessage")
[17:46:51.449]                       }
[17:46:51.449]                       else if (inherits(cond, "warning")) {
[17:46:51.449]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.449]                         if (muffled) 
[17:46:51.449]                           invokeRestart("muffleWarning")
[17:46:51.449]                       }
[17:46:51.449]                       else if (inherits(cond, "condition")) {
[17:46:51.449]                         if (!is.null(pattern)) {
[17:46:51.449]                           computeRestarts <- base::computeRestarts
[17:46:51.449]                           grepl <- base::grepl
[17:46:51.449]                           restarts <- computeRestarts(cond)
[17:46:51.449]                           for (restart in restarts) {
[17:46:51.449]                             name <- restart$name
[17:46:51.449]                             if (is.null(name)) 
[17:46:51.449]                               next
[17:46:51.449]                             if (!grepl(pattern, name)) 
[17:46:51.449]                               next
[17:46:51.449]                             invokeRestart(restart)
[17:46:51.449]                             muffled <- TRUE
[17:46:51.449]                             break
[17:46:51.449]                           }
[17:46:51.449]                         }
[17:46:51.449]                       }
[17:46:51.449]                       invisible(muffled)
[17:46:51.449]                     }
[17:46:51.449]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.449]                   }
[17:46:51.449]                 }
[17:46:51.449]                 else {
[17:46:51.449]                   if (TRUE) {
[17:46:51.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.449]                     {
[17:46:51.449]                       inherits <- base::inherits
[17:46:51.449]                       invokeRestart <- base::invokeRestart
[17:46:51.449]                       is.null <- base::is.null
[17:46:51.449]                       muffled <- FALSE
[17:46:51.449]                       if (inherits(cond, "message")) {
[17:46:51.449]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.449]                         if (muffled) 
[17:46:51.449]                           invokeRestart("muffleMessage")
[17:46:51.449]                       }
[17:46:51.449]                       else if (inherits(cond, "warning")) {
[17:46:51.449]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.449]                         if (muffled) 
[17:46:51.449]                           invokeRestart("muffleWarning")
[17:46:51.449]                       }
[17:46:51.449]                       else if (inherits(cond, "condition")) {
[17:46:51.449]                         if (!is.null(pattern)) {
[17:46:51.449]                           computeRestarts <- base::computeRestarts
[17:46:51.449]                           grepl <- base::grepl
[17:46:51.449]                           restarts <- computeRestarts(cond)
[17:46:51.449]                           for (restart in restarts) {
[17:46:51.449]                             name <- restart$name
[17:46:51.449]                             if (is.null(name)) 
[17:46:51.449]                               next
[17:46:51.449]                             if (!grepl(pattern, name)) 
[17:46:51.449]                               next
[17:46:51.449]                             invokeRestart(restart)
[17:46:51.449]                             muffled <- TRUE
[17:46:51.449]                             break
[17:46:51.449]                           }
[17:46:51.449]                         }
[17:46:51.449]                       }
[17:46:51.449]                       invisible(muffled)
[17:46:51.449]                     }
[17:46:51.449]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.449]                   }
[17:46:51.449]                 }
[17:46:51.449]             }
[17:46:51.449]         }))
[17:46:51.449]     }, error = function(ex) {
[17:46:51.449]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.449]                 ...future.rng), started = ...future.startTime, 
[17:46:51.449]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.449]             version = "1.8"), class = "FutureResult")
[17:46:51.449]     }, finally = {
[17:46:51.449]         if (!identical(...future.workdir, getwd())) 
[17:46:51.449]             setwd(...future.workdir)
[17:46:51.449]         {
[17:46:51.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.449]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.449]             }
[17:46:51.449]             base::options(...future.oldOptions)
[17:46:51.449]             if (.Platform$OS.type == "windows") {
[17:46:51.449]                 old_names <- names(...future.oldEnvVars)
[17:46:51.449]                 envs <- base::Sys.getenv()
[17:46:51.449]                 names <- names(envs)
[17:46:51.449]                 common <- intersect(names, old_names)
[17:46:51.449]                 added <- setdiff(names, old_names)
[17:46:51.449]                 removed <- setdiff(old_names, names)
[17:46:51.449]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.449]                   envs[common]]
[17:46:51.449]                 NAMES <- toupper(changed)
[17:46:51.449]                 args <- list()
[17:46:51.449]                 for (kk in seq_along(NAMES)) {
[17:46:51.449]                   name <- changed[[kk]]
[17:46:51.449]                   NAME <- NAMES[[kk]]
[17:46:51.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.449]                     next
[17:46:51.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.449]                 }
[17:46:51.449]                 NAMES <- toupper(added)
[17:46:51.449]                 for (kk in seq_along(NAMES)) {
[17:46:51.449]                   name <- added[[kk]]
[17:46:51.449]                   NAME <- NAMES[[kk]]
[17:46:51.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.449]                     next
[17:46:51.449]                   args[[name]] <- ""
[17:46:51.449]                 }
[17:46:51.449]                 NAMES <- toupper(removed)
[17:46:51.449]                 for (kk in seq_along(NAMES)) {
[17:46:51.449]                   name <- removed[[kk]]
[17:46:51.449]                   NAME <- NAMES[[kk]]
[17:46:51.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.449]                     next
[17:46:51.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.449]                 }
[17:46:51.449]                 if (length(args) > 0) 
[17:46:51.449]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.449]             }
[17:46:51.449]             else {
[17:46:51.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.449]             }
[17:46:51.449]             {
[17:46:51.449]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.449]                   0L) {
[17:46:51.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.449]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.449]                   base::options(opts)
[17:46:51.449]                 }
[17:46:51.449]                 {
[17:46:51.449]                   {
[17:46:51.449]                     NULL
[17:46:51.449]                     RNGkind("Mersenne-Twister")
[17:46:51.449]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:51.449]                       inherits = FALSE)
[17:46:51.449]                   }
[17:46:51.449]                   options(future.plan = NULL)
[17:46:51.449]                   if (is.na(NA_character_)) 
[17:46:51.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.449]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.449]                     .init = FALSE)
[17:46:51.449]                 }
[17:46:51.449]             }
[17:46:51.449]         }
[17:46:51.449]     })
[17:46:51.449]     if (TRUE) {
[17:46:51.449]         base::sink(type = "output", split = FALSE)
[17:46:51.449]         if (TRUE) {
[17:46:51.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.449]         }
[17:46:51.449]         else {
[17:46:51.449]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.449]         }
[17:46:51.449]         base::close(...future.stdout)
[17:46:51.449]         ...future.stdout <- NULL
[17:46:51.449]     }
[17:46:51.449]     ...future.result$conditions <- ...future.conditions
[17:46:51.449]     ...future.result$finished <- base::Sys.time()
[17:46:51.449]     ...future.result
[17:46:51.449] }
[17:46:51.451] assign_globals() ...
[17:46:51.451] List of 1
[17:46:51.451]  $ x: num [1:5] 1 1 2 2 2
[17:46:51.451]  - attr(*, "where")=List of 1
[17:46:51.451]   ..$ x:<environment: R_EmptyEnv> 
[17:46:51.451]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.451]  - attr(*, "resolved")= logi FALSE
[17:46:51.451]  - attr(*, "total_size")= num 96
[17:46:51.451]  - attr(*, "already-done")= logi TRUE
[17:46:51.453] - copied ‘x’ to environment
[17:46:51.453] assign_globals() ... done
[17:46:51.454] plan(): Setting new future strategy stack:
[17:46:51.454] List of future strategies:
[17:46:51.454] 1. sequential:
[17:46:51.454]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.454]    - tweaked: FALSE
[17:46:51.454]    - call: NULL
[17:46:51.454] plan(): nbrOfWorkers() = 1
[17:46:51.455] plan(): Setting new future strategy stack:
[17:46:51.455] List of future strategies:
[17:46:51.455] 1. sequential:
[17:46:51.455]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.455]    - tweaked: FALSE
[17:46:51.455]    - call: plan(strategy)
[17:46:51.456] plan(): nbrOfWorkers() = 1
[17:46:51.456] SequentialFuture started (and completed)
[17:46:51.456] - Launch lazy future ... done
[17:46:51.456] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[17:46:51.457] getGlobalsAndPackages() ...
[17:46:51.457] Searching for globals...
[17:46:51.458] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:46:51.458] Searching for globals ... DONE
[17:46:51.458] Resolving globals: FALSE
[17:46:51.458] The total size of the 1 globals is 96 bytes (96 bytes)
[17:46:51.459] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:46:51.460] - globals: [1] ‘x’
[17:46:51.461] - packages: [1] ‘stats’
[17:46:51.461] getGlobalsAndPackages() ... DONE
[17:46:51.461] run() for ‘Future’ ...
[17:46:51.461] - state: ‘created’
[17:46:51.461] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:51.461] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:51.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:51.462]   - Field: ‘label’
[17:46:51.462]   - Field: ‘local’
[17:46:51.462]   - Field: ‘owner’
[17:46:51.462]   - Field: ‘envir’
[17:46:51.462]   - Field: ‘packages’
[17:46:51.462]   - Field: ‘gc’
[17:46:51.462]   - Field: ‘conditions’
[17:46:51.462]   - Field: ‘expr’
[17:46:51.462]   - Field: ‘uuid’
[17:46:51.463]   - Field: ‘seed’
[17:46:51.463]   - Field: ‘version’
[17:46:51.463]   - Field: ‘result’
[17:46:51.463]   - Field: ‘asynchronous’
[17:46:51.463]   - Field: ‘calls’
[17:46:51.463]   - Field: ‘globals’
[17:46:51.463]   - Field: ‘stdout’
[17:46:51.463]   - Field: ‘earlySignal’
[17:46:51.463]   - Field: ‘lazy’
[17:46:51.463]   - Field: ‘state’
[17:46:51.463] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:51.464] - Launch lazy future ...
[17:46:51.464] Packages needed by the future expression (n = 1): ‘stats’
[17:46:51.464] Packages needed by future strategies (n = 0): <none>
[17:46:51.464] {
[17:46:51.464]     {
[17:46:51.464]         {
[17:46:51.464]             ...future.startTime <- base::Sys.time()
[17:46:51.464]             {
[17:46:51.464]                 {
[17:46:51.464]                   {
[17:46:51.464]                     {
[17:46:51.464]                       base::local({
[17:46:51.464]                         has_future <- base::requireNamespace("future", 
[17:46:51.464]                           quietly = TRUE)
[17:46:51.464]                         if (has_future) {
[17:46:51.464]                           ns <- base::getNamespace("future")
[17:46:51.464]                           version <- ns[[".package"]][["version"]]
[17:46:51.464]                           if (is.null(version)) 
[17:46:51.464]                             version <- utils::packageVersion("future")
[17:46:51.464]                         }
[17:46:51.464]                         else {
[17:46:51.464]                           version <- NULL
[17:46:51.464]                         }
[17:46:51.464]                         if (!has_future || version < "1.8.0") {
[17:46:51.464]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.464]                             "", base::R.version$version.string), 
[17:46:51.464]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:51.464]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:51.464]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.464]                               "release", "version")], collapse = " "), 
[17:46:51.464]                             hostname = base::Sys.info()[["nodename"]])
[17:46:51.464]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.464]                             info)
[17:46:51.464]                           info <- base::paste(info, collapse = "; ")
[17:46:51.464]                           if (!has_future) {
[17:46:51.464]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.464]                               info)
[17:46:51.464]                           }
[17:46:51.464]                           else {
[17:46:51.464]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.464]                               info, version)
[17:46:51.464]                           }
[17:46:51.464]                           base::stop(msg)
[17:46:51.464]                         }
[17:46:51.464]                       })
[17:46:51.464]                     }
[17:46:51.464]                     base::local({
[17:46:51.464]                       for (pkg in "stats") {
[17:46:51.464]                         base::loadNamespace(pkg)
[17:46:51.464]                         base::library(pkg, character.only = TRUE)
[17:46:51.464]                       }
[17:46:51.464]                     })
[17:46:51.464]                   }
[17:46:51.464]                   ...future.strategy.old <- future::plan("list")
[17:46:51.464]                   options(future.plan = NULL)
[17:46:51.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.464]                 }
[17:46:51.464]                 ...future.workdir <- getwd()
[17:46:51.464]             }
[17:46:51.464]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.464]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.464]         }
[17:46:51.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.464]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.464]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.464]             base::names(...future.oldOptions))
[17:46:51.464]     }
[17:46:51.464]     if (FALSE) {
[17:46:51.464]     }
[17:46:51.464]     else {
[17:46:51.464]         if (TRUE) {
[17:46:51.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.464]                 open = "w")
[17:46:51.464]         }
[17:46:51.464]         else {
[17:46:51.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.464]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.464]         }
[17:46:51.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.464]             base::sink(type = "output", split = FALSE)
[17:46:51.464]             base::close(...future.stdout)
[17:46:51.464]         }, add = TRUE)
[17:46:51.464]     }
[17:46:51.464]     ...future.frame <- base::sys.nframe()
[17:46:51.464]     ...future.conditions <- base::list()
[17:46:51.464]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.464]     if (FALSE) {
[17:46:51.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.464]     }
[17:46:51.464]     ...future.result <- base::tryCatch({
[17:46:51.464]         base::withCallingHandlers({
[17:46:51.464]             ...future.value <- base::withVisible(base::local({
[17:46:51.464]                 xtabs(~x)
[17:46:51.464]             }))
[17:46:51.464]             future::FutureResult(value = ...future.value$value, 
[17:46:51.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.464]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.464]                     ...future.globalenv.names))
[17:46:51.464]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.464]         }, condition = base::local({
[17:46:51.464]             c <- base::c
[17:46:51.464]             inherits <- base::inherits
[17:46:51.464]             invokeRestart <- base::invokeRestart
[17:46:51.464]             length <- base::length
[17:46:51.464]             list <- base::list
[17:46:51.464]             seq.int <- base::seq.int
[17:46:51.464]             signalCondition <- base::signalCondition
[17:46:51.464]             sys.calls <- base::sys.calls
[17:46:51.464]             `[[` <- base::`[[`
[17:46:51.464]             `+` <- base::`+`
[17:46:51.464]             `<<-` <- base::`<<-`
[17:46:51.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.464]                   3L)]
[17:46:51.464]             }
[17:46:51.464]             function(cond) {
[17:46:51.464]                 is_error <- inherits(cond, "error")
[17:46:51.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.464]                   NULL)
[17:46:51.464]                 if (is_error) {
[17:46:51.464]                   sessionInformation <- function() {
[17:46:51.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.464]                       search = base::search(), system = base::Sys.info())
[17:46:51.464]                   }
[17:46:51.464]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.464]                     cond$call), session = sessionInformation(), 
[17:46:51.464]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.464]                   signalCondition(cond)
[17:46:51.464]                 }
[17:46:51.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.464]                 "immediateCondition"))) {
[17:46:51.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.464]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.464]                   if (TRUE && !signal) {
[17:46:51.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.464]                     {
[17:46:51.464]                       inherits <- base::inherits
[17:46:51.464]                       invokeRestart <- base::invokeRestart
[17:46:51.464]                       is.null <- base::is.null
[17:46:51.464]                       muffled <- FALSE
[17:46:51.464]                       if (inherits(cond, "message")) {
[17:46:51.464]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.464]                         if (muffled) 
[17:46:51.464]                           invokeRestart("muffleMessage")
[17:46:51.464]                       }
[17:46:51.464]                       else if (inherits(cond, "warning")) {
[17:46:51.464]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.464]                         if (muffled) 
[17:46:51.464]                           invokeRestart("muffleWarning")
[17:46:51.464]                       }
[17:46:51.464]                       else if (inherits(cond, "condition")) {
[17:46:51.464]                         if (!is.null(pattern)) {
[17:46:51.464]                           computeRestarts <- base::computeRestarts
[17:46:51.464]                           grepl <- base::grepl
[17:46:51.464]                           restarts <- computeRestarts(cond)
[17:46:51.464]                           for (restart in restarts) {
[17:46:51.464]                             name <- restart$name
[17:46:51.464]                             if (is.null(name)) 
[17:46:51.464]                               next
[17:46:51.464]                             if (!grepl(pattern, name)) 
[17:46:51.464]                               next
[17:46:51.464]                             invokeRestart(restart)
[17:46:51.464]                             muffled <- TRUE
[17:46:51.464]                             break
[17:46:51.464]                           }
[17:46:51.464]                         }
[17:46:51.464]                       }
[17:46:51.464]                       invisible(muffled)
[17:46:51.464]                     }
[17:46:51.464]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.464]                   }
[17:46:51.464]                 }
[17:46:51.464]                 else {
[17:46:51.464]                   if (TRUE) {
[17:46:51.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.464]                     {
[17:46:51.464]                       inherits <- base::inherits
[17:46:51.464]                       invokeRestart <- base::invokeRestart
[17:46:51.464]                       is.null <- base::is.null
[17:46:51.464]                       muffled <- FALSE
[17:46:51.464]                       if (inherits(cond, "message")) {
[17:46:51.464]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.464]                         if (muffled) 
[17:46:51.464]                           invokeRestart("muffleMessage")
[17:46:51.464]                       }
[17:46:51.464]                       else if (inherits(cond, "warning")) {
[17:46:51.464]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.464]                         if (muffled) 
[17:46:51.464]                           invokeRestart("muffleWarning")
[17:46:51.464]                       }
[17:46:51.464]                       else if (inherits(cond, "condition")) {
[17:46:51.464]                         if (!is.null(pattern)) {
[17:46:51.464]                           computeRestarts <- base::computeRestarts
[17:46:51.464]                           grepl <- base::grepl
[17:46:51.464]                           restarts <- computeRestarts(cond)
[17:46:51.464]                           for (restart in restarts) {
[17:46:51.464]                             name <- restart$name
[17:46:51.464]                             if (is.null(name)) 
[17:46:51.464]                               next
[17:46:51.464]                             if (!grepl(pattern, name)) 
[17:46:51.464]                               next
[17:46:51.464]                             invokeRestart(restart)
[17:46:51.464]                             muffled <- TRUE
[17:46:51.464]                             break
[17:46:51.464]                           }
[17:46:51.464]                         }
[17:46:51.464]                       }
[17:46:51.464]                       invisible(muffled)
[17:46:51.464]                     }
[17:46:51.464]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.464]                   }
[17:46:51.464]                 }
[17:46:51.464]             }
[17:46:51.464]         }))
[17:46:51.464]     }, error = function(ex) {
[17:46:51.464]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.464]                 ...future.rng), started = ...future.startTime, 
[17:46:51.464]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.464]             version = "1.8"), class = "FutureResult")
[17:46:51.464]     }, finally = {
[17:46:51.464]         if (!identical(...future.workdir, getwd())) 
[17:46:51.464]             setwd(...future.workdir)
[17:46:51.464]         {
[17:46:51.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.464]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.464]             }
[17:46:51.464]             base::options(...future.oldOptions)
[17:46:51.464]             if (.Platform$OS.type == "windows") {
[17:46:51.464]                 old_names <- names(...future.oldEnvVars)
[17:46:51.464]                 envs <- base::Sys.getenv()
[17:46:51.464]                 names <- names(envs)
[17:46:51.464]                 common <- intersect(names, old_names)
[17:46:51.464]                 added <- setdiff(names, old_names)
[17:46:51.464]                 removed <- setdiff(old_names, names)
[17:46:51.464]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.464]                   envs[common]]
[17:46:51.464]                 NAMES <- toupper(changed)
[17:46:51.464]                 args <- list()
[17:46:51.464]                 for (kk in seq_along(NAMES)) {
[17:46:51.464]                   name <- changed[[kk]]
[17:46:51.464]                   NAME <- NAMES[[kk]]
[17:46:51.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.464]                     next
[17:46:51.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.464]                 }
[17:46:51.464]                 NAMES <- toupper(added)
[17:46:51.464]                 for (kk in seq_along(NAMES)) {
[17:46:51.464]                   name <- added[[kk]]
[17:46:51.464]                   NAME <- NAMES[[kk]]
[17:46:51.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.464]                     next
[17:46:51.464]                   args[[name]] <- ""
[17:46:51.464]                 }
[17:46:51.464]                 NAMES <- toupper(removed)
[17:46:51.464]                 for (kk in seq_along(NAMES)) {
[17:46:51.464]                   name <- removed[[kk]]
[17:46:51.464]                   NAME <- NAMES[[kk]]
[17:46:51.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.464]                     next
[17:46:51.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.464]                 }
[17:46:51.464]                 if (length(args) > 0) 
[17:46:51.464]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.464]             }
[17:46:51.464]             else {
[17:46:51.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.464]             }
[17:46:51.464]             {
[17:46:51.464]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.464]                   0L) {
[17:46:51.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.464]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.464]                   base::options(opts)
[17:46:51.464]                 }
[17:46:51.464]                 {
[17:46:51.464]                   {
[17:46:51.464]                     NULL
[17:46:51.464]                     RNGkind("Mersenne-Twister")
[17:46:51.464]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:51.464]                       inherits = FALSE)
[17:46:51.464]                   }
[17:46:51.464]                   options(future.plan = NULL)
[17:46:51.464]                   if (is.na(NA_character_)) 
[17:46:51.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.464]                     .init = FALSE)
[17:46:51.464]                 }
[17:46:51.464]             }
[17:46:51.464]         }
[17:46:51.464]     })
[17:46:51.464]     if (TRUE) {
[17:46:51.464]         base::sink(type = "output", split = FALSE)
[17:46:51.464]         if (TRUE) {
[17:46:51.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.464]         }
[17:46:51.464]         else {
[17:46:51.464]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.464]         }
[17:46:51.464]         base::close(...future.stdout)
[17:46:51.464]         ...future.stdout <- NULL
[17:46:51.464]     }
[17:46:51.464]     ...future.result$conditions <- ...future.conditions
[17:46:51.464]     ...future.result$finished <- base::Sys.time()
[17:46:51.464]     ...future.result
[17:46:51.464] }
[17:46:51.466] assign_globals() ...
[17:46:51.466] List of 1
[17:46:51.466]  $ x: num [1:5] 1 1 2 2 2
[17:46:51.466]  - attr(*, "where")=List of 1
[17:46:51.466]   ..$ x:<environment: R_EmptyEnv> 
[17:46:51.466]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.466]  - attr(*, "resolved")= logi FALSE
[17:46:51.466]  - attr(*, "total_size")= num 96
[17:46:51.466]  - attr(*, "already-done")= logi TRUE
[17:46:51.468] - copied ‘x’ to environment
[17:46:51.468] assign_globals() ... done
[17:46:51.469] plan(): Setting new future strategy stack:
[17:46:51.469] List of future strategies:
[17:46:51.469] 1. sequential:
[17:46:51.469]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.469]    - tweaked: FALSE
[17:46:51.469]    - call: NULL
[17:46:51.469] plan(): nbrOfWorkers() = 1
[17:46:51.470] plan(): Setting new future strategy stack:
[17:46:51.470] List of future strategies:
[17:46:51.470] 1. sequential:
[17:46:51.470]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.470]    - tweaked: FALSE
[17:46:51.470]    - call: plan(strategy)
[17:46:51.471] plan(): nbrOfWorkers() = 1
[17:46:51.471] SequentialFuture started (and completed)
[17:46:51.471] - Launch lazy future ... done
[17:46:51.471] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[17:46:51.473] getGlobalsAndPackages() ...
[17:46:51.473] Searching for globals...
[17:46:51.474] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[17:46:51.474] Searching for globals ... DONE
[17:46:51.475] Resolving globals: FALSE
[17:46:51.475] 
[17:46:51.475] - packages: [2] ‘stats’, ‘datasets’
[17:46:51.475] getGlobalsAndPackages() ... DONE
[17:46:51.476] run() for ‘Future’ ...
[17:46:51.476] - state: ‘created’
[17:46:51.476] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:51.476] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:51.476] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:51.476]   - Field: ‘label’
[17:46:51.476]   - Field: ‘local’
[17:46:51.476]   - Field: ‘owner’
[17:46:51.476]   - Field: ‘envir’
[17:46:51.477]   - Field: ‘packages’
[17:46:51.477]   - Field: ‘gc’
[17:46:51.477]   - Field: ‘conditions’
[17:46:51.477]   - Field: ‘expr’
[17:46:51.477]   - Field: ‘uuid’
[17:46:51.477]   - Field: ‘seed’
[17:46:51.477]   - Field: ‘version’
[17:46:51.477]   - Field: ‘result’
[17:46:51.477]   - Field: ‘asynchronous’
[17:46:51.477]   - Field: ‘calls’
[17:46:51.477]   - Field: ‘globals’
[17:46:51.478]   - Field: ‘stdout’
[17:46:51.478]   - Field: ‘earlySignal’
[17:46:51.478]   - Field: ‘lazy’
[17:46:51.478]   - Field: ‘state’
[17:46:51.478] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:51.478] - Launch lazy future ...
[17:46:51.478] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:51.478] Packages needed by future strategies (n = 0): <none>
[17:46:51.479] {
[17:46:51.479]     {
[17:46:51.479]         {
[17:46:51.479]             ...future.startTime <- base::Sys.time()
[17:46:51.479]             {
[17:46:51.479]                 {
[17:46:51.479]                   {
[17:46:51.479]                     {
[17:46:51.479]                       base::local({
[17:46:51.479]                         has_future <- base::requireNamespace("future", 
[17:46:51.479]                           quietly = TRUE)
[17:46:51.479]                         if (has_future) {
[17:46:51.479]                           ns <- base::getNamespace("future")
[17:46:51.479]                           version <- ns[[".package"]][["version"]]
[17:46:51.479]                           if (is.null(version)) 
[17:46:51.479]                             version <- utils::packageVersion("future")
[17:46:51.479]                         }
[17:46:51.479]                         else {
[17:46:51.479]                           version <- NULL
[17:46:51.479]                         }
[17:46:51.479]                         if (!has_future || version < "1.8.0") {
[17:46:51.479]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.479]                             "", base::R.version$version.string), 
[17:46:51.479]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:51.479]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:51.479]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.479]                               "release", "version")], collapse = " "), 
[17:46:51.479]                             hostname = base::Sys.info()[["nodename"]])
[17:46:51.479]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.479]                             info)
[17:46:51.479]                           info <- base::paste(info, collapse = "; ")
[17:46:51.479]                           if (!has_future) {
[17:46:51.479]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.479]                               info)
[17:46:51.479]                           }
[17:46:51.479]                           else {
[17:46:51.479]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.479]                               info, version)
[17:46:51.479]                           }
[17:46:51.479]                           base::stop(msg)
[17:46:51.479]                         }
[17:46:51.479]                       })
[17:46:51.479]                     }
[17:46:51.479]                     base::local({
[17:46:51.479]                       for (pkg in c("stats", "datasets")) {
[17:46:51.479]                         base::loadNamespace(pkg)
[17:46:51.479]                         base::library(pkg, character.only = TRUE)
[17:46:51.479]                       }
[17:46:51.479]                     })
[17:46:51.479]                   }
[17:46:51.479]                   ...future.strategy.old <- future::plan("list")
[17:46:51.479]                   options(future.plan = NULL)
[17:46:51.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.479]                 }
[17:46:51.479]                 ...future.workdir <- getwd()
[17:46:51.479]             }
[17:46:51.479]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.479]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.479]         }
[17:46:51.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.479]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.479]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.479]             base::names(...future.oldOptions))
[17:46:51.479]     }
[17:46:51.479]     if (FALSE) {
[17:46:51.479]     }
[17:46:51.479]     else {
[17:46:51.479]         if (TRUE) {
[17:46:51.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.479]                 open = "w")
[17:46:51.479]         }
[17:46:51.479]         else {
[17:46:51.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.479]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.479]         }
[17:46:51.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.479]             base::sink(type = "output", split = FALSE)
[17:46:51.479]             base::close(...future.stdout)
[17:46:51.479]         }, add = TRUE)
[17:46:51.479]     }
[17:46:51.479]     ...future.frame <- base::sys.nframe()
[17:46:51.479]     ...future.conditions <- base::list()
[17:46:51.479]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.479]     if (FALSE) {
[17:46:51.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.479]     }
[17:46:51.479]     ...future.result <- base::tryCatch({
[17:46:51.479]         base::withCallingHandlers({
[17:46:51.479]             ...future.value <- base::withVisible(base::local({
[17:46:51.479]                 lm(dist ~ . - 1, data = cars)
[17:46:51.479]             }))
[17:46:51.479]             future::FutureResult(value = ...future.value$value, 
[17:46:51.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.479]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.479]                     ...future.globalenv.names))
[17:46:51.479]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.479]         }, condition = base::local({
[17:46:51.479]             c <- base::c
[17:46:51.479]             inherits <- base::inherits
[17:46:51.479]             invokeRestart <- base::invokeRestart
[17:46:51.479]             length <- base::length
[17:46:51.479]             list <- base::list
[17:46:51.479]             seq.int <- base::seq.int
[17:46:51.479]             signalCondition <- base::signalCondition
[17:46:51.479]             sys.calls <- base::sys.calls
[17:46:51.479]             `[[` <- base::`[[`
[17:46:51.479]             `+` <- base::`+`
[17:46:51.479]             `<<-` <- base::`<<-`
[17:46:51.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.479]                   3L)]
[17:46:51.479]             }
[17:46:51.479]             function(cond) {
[17:46:51.479]                 is_error <- inherits(cond, "error")
[17:46:51.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.479]                   NULL)
[17:46:51.479]                 if (is_error) {
[17:46:51.479]                   sessionInformation <- function() {
[17:46:51.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.479]                       search = base::search(), system = base::Sys.info())
[17:46:51.479]                   }
[17:46:51.479]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.479]                     cond$call), session = sessionInformation(), 
[17:46:51.479]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.479]                   signalCondition(cond)
[17:46:51.479]                 }
[17:46:51.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.479]                 "immediateCondition"))) {
[17:46:51.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.479]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.479]                   if (TRUE && !signal) {
[17:46:51.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.479]                     {
[17:46:51.479]                       inherits <- base::inherits
[17:46:51.479]                       invokeRestart <- base::invokeRestart
[17:46:51.479]                       is.null <- base::is.null
[17:46:51.479]                       muffled <- FALSE
[17:46:51.479]                       if (inherits(cond, "message")) {
[17:46:51.479]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.479]                         if (muffled) 
[17:46:51.479]                           invokeRestart("muffleMessage")
[17:46:51.479]                       }
[17:46:51.479]                       else if (inherits(cond, "warning")) {
[17:46:51.479]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.479]                         if (muffled) 
[17:46:51.479]                           invokeRestart("muffleWarning")
[17:46:51.479]                       }
[17:46:51.479]                       else if (inherits(cond, "condition")) {
[17:46:51.479]                         if (!is.null(pattern)) {
[17:46:51.479]                           computeRestarts <- base::computeRestarts
[17:46:51.479]                           grepl <- base::grepl
[17:46:51.479]                           restarts <- computeRestarts(cond)
[17:46:51.479]                           for (restart in restarts) {
[17:46:51.479]                             name <- restart$name
[17:46:51.479]                             if (is.null(name)) 
[17:46:51.479]                               next
[17:46:51.479]                             if (!grepl(pattern, name)) 
[17:46:51.479]                               next
[17:46:51.479]                             invokeRestart(restart)
[17:46:51.479]                             muffled <- TRUE
[17:46:51.479]                             break
[17:46:51.479]                           }
[17:46:51.479]                         }
[17:46:51.479]                       }
[17:46:51.479]                       invisible(muffled)
[17:46:51.479]                     }
[17:46:51.479]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.479]                   }
[17:46:51.479]                 }
[17:46:51.479]                 else {
[17:46:51.479]                   if (TRUE) {
[17:46:51.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.479]                     {
[17:46:51.479]                       inherits <- base::inherits
[17:46:51.479]                       invokeRestart <- base::invokeRestart
[17:46:51.479]                       is.null <- base::is.null
[17:46:51.479]                       muffled <- FALSE
[17:46:51.479]                       if (inherits(cond, "message")) {
[17:46:51.479]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.479]                         if (muffled) 
[17:46:51.479]                           invokeRestart("muffleMessage")
[17:46:51.479]                       }
[17:46:51.479]                       else if (inherits(cond, "warning")) {
[17:46:51.479]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.479]                         if (muffled) 
[17:46:51.479]                           invokeRestart("muffleWarning")
[17:46:51.479]                       }
[17:46:51.479]                       else if (inherits(cond, "condition")) {
[17:46:51.479]                         if (!is.null(pattern)) {
[17:46:51.479]                           computeRestarts <- base::computeRestarts
[17:46:51.479]                           grepl <- base::grepl
[17:46:51.479]                           restarts <- computeRestarts(cond)
[17:46:51.479]                           for (restart in restarts) {
[17:46:51.479]                             name <- restart$name
[17:46:51.479]                             if (is.null(name)) 
[17:46:51.479]                               next
[17:46:51.479]                             if (!grepl(pattern, name)) 
[17:46:51.479]                               next
[17:46:51.479]                             invokeRestart(restart)
[17:46:51.479]                             muffled <- TRUE
[17:46:51.479]                             break
[17:46:51.479]                           }
[17:46:51.479]                         }
[17:46:51.479]                       }
[17:46:51.479]                       invisible(muffled)
[17:46:51.479]                     }
[17:46:51.479]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.479]                   }
[17:46:51.479]                 }
[17:46:51.479]             }
[17:46:51.479]         }))
[17:46:51.479]     }, error = function(ex) {
[17:46:51.479]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.479]                 ...future.rng), started = ...future.startTime, 
[17:46:51.479]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.479]             version = "1.8"), class = "FutureResult")
[17:46:51.479]     }, finally = {
[17:46:51.479]         if (!identical(...future.workdir, getwd())) 
[17:46:51.479]             setwd(...future.workdir)
[17:46:51.479]         {
[17:46:51.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.479]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.479]             }
[17:46:51.479]             base::options(...future.oldOptions)
[17:46:51.479]             if (.Platform$OS.type == "windows") {
[17:46:51.479]                 old_names <- names(...future.oldEnvVars)
[17:46:51.479]                 envs <- base::Sys.getenv()
[17:46:51.479]                 names <- names(envs)
[17:46:51.479]                 common <- intersect(names, old_names)
[17:46:51.479]                 added <- setdiff(names, old_names)
[17:46:51.479]                 removed <- setdiff(old_names, names)
[17:46:51.479]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.479]                   envs[common]]
[17:46:51.479]                 NAMES <- toupper(changed)
[17:46:51.479]                 args <- list()
[17:46:51.479]                 for (kk in seq_along(NAMES)) {
[17:46:51.479]                   name <- changed[[kk]]
[17:46:51.479]                   NAME <- NAMES[[kk]]
[17:46:51.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.479]                     next
[17:46:51.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.479]                 }
[17:46:51.479]                 NAMES <- toupper(added)
[17:46:51.479]                 for (kk in seq_along(NAMES)) {
[17:46:51.479]                   name <- added[[kk]]
[17:46:51.479]                   NAME <- NAMES[[kk]]
[17:46:51.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.479]                     next
[17:46:51.479]                   args[[name]] <- ""
[17:46:51.479]                 }
[17:46:51.479]                 NAMES <- toupper(removed)
[17:46:51.479]                 for (kk in seq_along(NAMES)) {
[17:46:51.479]                   name <- removed[[kk]]
[17:46:51.479]                   NAME <- NAMES[[kk]]
[17:46:51.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.479]                     next
[17:46:51.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.479]                 }
[17:46:51.479]                 if (length(args) > 0) 
[17:46:51.479]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.479]             }
[17:46:51.479]             else {
[17:46:51.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.479]             }
[17:46:51.479]             {
[17:46:51.479]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.479]                   0L) {
[17:46:51.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.479]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.479]                   base::options(opts)
[17:46:51.479]                 }
[17:46:51.479]                 {
[17:46:51.479]                   {
[17:46:51.479]                     NULL
[17:46:51.479]                     RNGkind("Mersenne-Twister")
[17:46:51.479]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:51.479]                       inherits = FALSE)
[17:46:51.479]                   }
[17:46:51.479]                   options(future.plan = NULL)
[17:46:51.479]                   if (is.na(NA_character_)) 
[17:46:51.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.479]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.479]                     .init = FALSE)
[17:46:51.479]                 }
[17:46:51.479]             }
[17:46:51.479]         }
[17:46:51.479]     })
[17:46:51.479]     if (TRUE) {
[17:46:51.479]         base::sink(type = "output", split = FALSE)
[17:46:51.479]         if (TRUE) {
[17:46:51.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.479]         }
[17:46:51.479]         else {
[17:46:51.479]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.479]         }
[17:46:51.479]         base::close(...future.stdout)
[17:46:51.479]         ...future.stdout <- NULL
[17:46:51.479]     }
[17:46:51.479]     ...future.result$conditions <- ...future.conditions
[17:46:51.479]     ...future.result$finished <- base::Sys.time()
[17:46:51.479]     ...future.result
[17:46:51.479] }
[17:46:51.481] plan(): Setting new future strategy stack:
[17:46:51.481] List of future strategies:
[17:46:51.481] 1. sequential:
[17:46:51.481]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.481]    - tweaked: FALSE
[17:46:51.481]    - call: NULL
[17:46:51.481] plan(): nbrOfWorkers() = 1
[17:46:51.482] plan(): Setting new future strategy stack:
[17:46:51.482] List of future strategies:
[17:46:51.482] 1. sequential:
[17:46:51.482]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.482]    - tweaked: FALSE
[17:46:51.482]    - call: plan(strategy)
[17:46:51.483] plan(): nbrOfWorkers() = 1
[17:46:51.483] SequentialFuture started (and completed)
[17:46:51.483] - Launch lazy future ... done
[17:46:51.483] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[17:46:51.485] getGlobalsAndPackages() ...
[17:46:51.486] Searching for globals...
[17:46:51.489] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[17:46:51.489] Searching for globals ... DONE
[17:46:51.489] Resolving globals: FALSE
[17:46:51.489] 
[17:46:51.489] - packages: [2] ‘stats’, ‘datasets’
[17:46:51.490] getGlobalsAndPackages() ... DONE
[17:46:51.490] run() for ‘Future’ ...
[17:46:51.490] - state: ‘created’
[17:46:51.490] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:51.490] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:51.490] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:51.490]   - Field: ‘label’
[17:46:51.491]   - Field: ‘local’
[17:46:51.491]   - Field: ‘owner’
[17:46:51.491]   - Field: ‘envir’
[17:46:51.491]   - Field: ‘packages’
[17:46:51.491]   - Field: ‘gc’
[17:46:51.491]   - Field: ‘conditions’
[17:46:51.491]   - Field: ‘expr’
[17:46:51.491]   - Field: ‘uuid’
[17:46:51.491]   - Field: ‘seed’
[17:46:51.491]   - Field: ‘version’
[17:46:51.492]   - Field: ‘result’
[17:46:51.492]   - Field: ‘asynchronous’
[17:46:51.492]   - Field: ‘calls’
[17:46:51.492]   - Field: ‘globals’
[17:46:51.492]   - Field: ‘stdout’
[17:46:51.492]   - Field: ‘earlySignal’
[17:46:51.492]   - Field: ‘lazy’
[17:46:51.492]   - Field: ‘state’
[17:46:51.492] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:51.492] - Launch lazy future ...
[17:46:51.492] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:51.493] Packages needed by future strategies (n = 0): <none>
[17:46:51.493] {
[17:46:51.493]     {
[17:46:51.493]         {
[17:46:51.493]             ...future.startTime <- base::Sys.time()
[17:46:51.493]             {
[17:46:51.493]                 {
[17:46:51.493]                   {
[17:46:51.493]                     {
[17:46:51.493]                       base::local({
[17:46:51.493]                         has_future <- base::requireNamespace("future", 
[17:46:51.493]                           quietly = TRUE)
[17:46:51.493]                         if (has_future) {
[17:46:51.493]                           ns <- base::getNamespace("future")
[17:46:51.493]                           version <- ns[[".package"]][["version"]]
[17:46:51.493]                           if (is.null(version)) 
[17:46:51.493]                             version <- utils::packageVersion("future")
[17:46:51.493]                         }
[17:46:51.493]                         else {
[17:46:51.493]                           version <- NULL
[17:46:51.493]                         }
[17:46:51.493]                         if (!has_future || version < "1.8.0") {
[17:46:51.493]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.493]                             "", base::R.version$version.string), 
[17:46:51.493]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:51.493]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:51.493]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.493]                               "release", "version")], collapse = " "), 
[17:46:51.493]                             hostname = base::Sys.info()[["nodename"]])
[17:46:51.493]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.493]                             info)
[17:46:51.493]                           info <- base::paste(info, collapse = "; ")
[17:46:51.493]                           if (!has_future) {
[17:46:51.493]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.493]                               info)
[17:46:51.493]                           }
[17:46:51.493]                           else {
[17:46:51.493]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.493]                               info, version)
[17:46:51.493]                           }
[17:46:51.493]                           base::stop(msg)
[17:46:51.493]                         }
[17:46:51.493]                       })
[17:46:51.493]                     }
[17:46:51.493]                     base::local({
[17:46:51.493]                       for (pkg in c("stats", "datasets")) {
[17:46:51.493]                         base::loadNamespace(pkg)
[17:46:51.493]                         base::library(pkg, character.only = TRUE)
[17:46:51.493]                       }
[17:46:51.493]                     })
[17:46:51.493]                   }
[17:46:51.493]                   ...future.strategy.old <- future::plan("list")
[17:46:51.493]                   options(future.plan = NULL)
[17:46:51.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.493]                 }
[17:46:51.493]                 ...future.workdir <- getwd()
[17:46:51.493]             }
[17:46:51.493]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.493]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.493]         }
[17:46:51.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.493]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.493]             base::names(...future.oldOptions))
[17:46:51.493]     }
[17:46:51.493]     if (FALSE) {
[17:46:51.493]     }
[17:46:51.493]     else {
[17:46:51.493]         if (TRUE) {
[17:46:51.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.493]                 open = "w")
[17:46:51.493]         }
[17:46:51.493]         else {
[17:46:51.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.493]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.493]         }
[17:46:51.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.493]             base::sink(type = "output", split = FALSE)
[17:46:51.493]             base::close(...future.stdout)
[17:46:51.493]         }, add = TRUE)
[17:46:51.493]     }
[17:46:51.493]     ...future.frame <- base::sys.nframe()
[17:46:51.493]     ...future.conditions <- base::list()
[17:46:51.493]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.493]     if (FALSE) {
[17:46:51.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.493]     }
[17:46:51.493]     ...future.result <- base::tryCatch({
[17:46:51.493]         base::withCallingHandlers({
[17:46:51.493]             ...future.value <- base::withVisible(base::local({
[17:46:51.493]                 lm(dist ~ . + 0, data = cars)
[17:46:51.493]             }))
[17:46:51.493]             future::FutureResult(value = ...future.value$value, 
[17:46:51.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.493]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.493]                     ...future.globalenv.names))
[17:46:51.493]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.493]         }, condition = base::local({
[17:46:51.493]             c <- base::c
[17:46:51.493]             inherits <- base::inherits
[17:46:51.493]             invokeRestart <- base::invokeRestart
[17:46:51.493]             length <- base::length
[17:46:51.493]             list <- base::list
[17:46:51.493]             seq.int <- base::seq.int
[17:46:51.493]             signalCondition <- base::signalCondition
[17:46:51.493]             sys.calls <- base::sys.calls
[17:46:51.493]             `[[` <- base::`[[`
[17:46:51.493]             `+` <- base::`+`
[17:46:51.493]             `<<-` <- base::`<<-`
[17:46:51.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.493]                   3L)]
[17:46:51.493]             }
[17:46:51.493]             function(cond) {
[17:46:51.493]                 is_error <- inherits(cond, "error")
[17:46:51.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.493]                   NULL)
[17:46:51.493]                 if (is_error) {
[17:46:51.493]                   sessionInformation <- function() {
[17:46:51.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.493]                       search = base::search(), system = base::Sys.info())
[17:46:51.493]                   }
[17:46:51.493]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.493]                     cond$call), session = sessionInformation(), 
[17:46:51.493]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.493]                   signalCondition(cond)
[17:46:51.493]                 }
[17:46:51.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.493]                 "immediateCondition"))) {
[17:46:51.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.493]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.493]                   if (TRUE && !signal) {
[17:46:51.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.493]                     {
[17:46:51.493]                       inherits <- base::inherits
[17:46:51.493]                       invokeRestart <- base::invokeRestart
[17:46:51.493]                       is.null <- base::is.null
[17:46:51.493]                       muffled <- FALSE
[17:46:51.493]                       if (inherits(cond, "message")) {
[17:46:51.493]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.493]                         if (muffled) 
[17:46:51.493]                           invokeRestart("muffleMessage")
[17:46:51.493]                       }
[17:46:51.493]                       else if (inherits(cond, "warning")) {
[17:46:51.493]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.493]                         if (muffled) 
[17:46:51.493]                           invokeRestart("muffleWarning")
[17:46:51.493]                       }
[17:46:51.493]                       else if (inherits(cond, "condition")) {
[17:46:51.493]                         if (!is.null(pattern)) {
[17:46:51.493]                           computeRestarts <- base::computeRestarts
[17:46:51.493]                           grepl <- base::grepl
[17:46:51.493]                           restarts <- computeRestarts(cond)
[17:46:51.493]                           for (restart in restarts) {
[17:46:51.493]                             name <- restart$name
[17:46:51.493]                             if (is.null(name)) 
[17:46:51.493]                               next
[17:46:51.493]                             if (!grepl(pattern, name)) 
[17:46:51.493]                               next
[17:46:51.493]                             invokeRestart(restart)
[17:46:51.493]                             muffled <- TRUE
[17:46:51.493]                             break
[17:46:51.493]                           }
[17:46:51.493]                         }
[17:46:51.493]                       }
[17:46:51.493]                       invisible(muffled)
[17:46:51.493]                     }
[17:46:51.493]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.493]                   }
[17:46:51.493]                 }
[17:46:51.493]                 else {
[17:46:51.493]                   if (TRUE) {
[17:46:51.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.493]                     {
[17:46:51.493]                       inherits <- base::inherits
[17:46:51.493]                       invokeRestart <- base::invokeRestart
[17:46:51.493]                       is.null <- base::is.null
[17:46:51.493]                       muffled <- FALSE
[17:46:51.493]                       if (inherits(cond, "message")) {
[17:46:51.493]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.493]                         if (muffled) 
[17:46:51.493]                           invokeRestart("muffleMessage")
[17:46:51.493]                       }
[17:46:51.493]                       else if (inherits(cond, "warning")) {
[17:46:51.493]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.493]                         if (muffled) 
[17:46:51.493]                           invokeRestart("muffleWarning")
[17:46:51.493]                       }
[17:46:51.493]                       else if (inherits(cond, "condition")) {
[17:46:51.493]                         if (!is.null(pattern)) {
[17:46:51.493]                           computeRestarts <- base::computeRestarts
[17:46:51.493]                           grepl <- base::grepl
[17:46:51.493]                           restarts <- computeRestarts(cond)
[17:46:51.493]                           for (restart in restarts) {
[17:46:51.493]                             name <- restart$name
[17:46:51.493]                             if (is.null(name)) 
[17:46:51.493]                               next
[17:46:51.493]                             if (!grepl(pattern, name)) 
[17:46:51.493]                               next
[17:46:51.493]                             invokeRestart(restart)
[17:46:51.493]                             muffled <- TRUE
[17:46:51.493]                             break
[17:46:51.493]                           }
[17:46:51.493]                         }
[17:46:51.493]                       }
[17:46:51.493]                       invisible(muffled)
[17:46:51.493]                     }
[17:46:51.493]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.493]                   }
[17:46:51.493]                 }
[17:46:51.493]             }
[17:46:51.493]         }))
[17:46:51.493]     }, error = function(ex) {
[17:46:51.493]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.493]                 ...future.rng), started = ...future.startTime, 
[17:46:51.493]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.493]             version = "1.8"), class = "FutureResult")
[17:46:51.493]     }, finally = {
[17:46:51.493]         if (!identical(...future.workdir, getwd())) 
[17:46:51.493]             setwd(...future.workdir)
[17:46:51.493]         {
[17:46:51.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.493]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.493]             }
[17:46:51.493]             base::options(...future.oldOptions)
[17:46:51.493]             if (.Platform$OS.type == "windows") {
[17:46:51.493]                 old_names <- names(...future.oldEnvVars)
[17:46:51.493]                 envs <- base::Sys.getenv()
[17:46:51.493]                 names <- names(envs)
[17:46:51.493]                 common <- intersect(names, old_names)
[17:46:51.493]                 added <- setdiff(names, old_names)
[17:46:51.493]                 removed <- setdiff(old_names, names)
[17:46:51.493]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.493]                   envs[common]]
[17:46:51.493]                 NAMES <- toupper(changed)
[17:46:51.493]                 args <- list()
[17:46:51.493]                 for (kk in seq_along(NAMES)) {
[17:46:51.493]                   name <- changed[[kk]]
[17:46:51.493]                   NAME <- NAMES[[kk]]
[17:46:51.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.493]                     next
[17:46:51.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.493]                 }
[17:46:51.493]                 NAMES <- toupper(added)
[17:46:51.493]                 for (kk in seq_along(NAMES)) {
[17:46:51.493]                   name <- added[[kk]]
[17:46:51.493]                   NAME <- NAMES[[kk]]
[17:46:51.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.493]                     next
[17:46:51.493]                   args[[name]] <- ""
[17:46:51.493]                 }
[17:46:51.493]                 NAMES <- toupper(removed)
[17:46:51.493]                 for (kk in seq_along(NAMES)) {
[17:46:51.493]                   name <- removed[[kk]]
[17:46:51.493]                   NAME <- NAMES[[kk]]
[17:46:51.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.493]                     next
[17:46:51.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.493]                 }
[17:46:51.493]                 if (length(args) > 0) 
[17:46:51.493]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.493]             }
[17:46:51.493]             else {
[17:46:51.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.493]             }
[17:46:51.493]             {
[17:46:51.493]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.493]                   0L) {
[17:46:51.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.493]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.493]                   base::options(opts)
[17:46:51.493]                 }
[17:46:51.493]                 {
[17:46:51.493]                   {
[17:46:51.493]                     NULL
[17:46:51.493]                     RNGkind("Mersenne-Twister")
[17:46:51.493]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:51.493]                       inherits = FALSE)
[17:46:51.493]                   }
[17:46:51.493]                   options(future.plan = NULL)
[17:46:51.493]                   if (is.na(NA_character_)) 
[17:46:51.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.493]                     .init = FALSE)
[17:46:51.493]                 }
[17:46:51.493]             }
[17:46:51.493]         }
[17:46:51.493]     })
[17:46:51.493]     if (TRUE) {
[17:46:51.493]         base::sink(type = "output", split = FALSE)
[17:46:51.493]         if (TRUE) {
[17:46:51.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.493]         }
[17:46:51.493]         else {
[17:46:51.493]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.493]         }
[17:46:51.493]         base::close(...future.stdout)
[17:46:51.493]         ...future.stdout <- NULL
[17:46:51.493]     }
[17:46:51.493]     ...future.result$conditions <- ...future.conditions
[17:46:51.493]     ...future.result$finished <- base::Sys.time()
[17:46:51.493]     ...future.result
[17:46:51.493] }
[17:46:51.495] plan(): Setting new future strategy stack:
[17:46:51.495] List of future strategies:
[17:46:51.495] 1. sequential:
[17:46:51.495]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.495]    - tweaked: FALSE
[17:46:51.495]    - call: NULL
[17:46:51.495] plan(): nbrOfWorkers() = 1
[17:46:51.497] plan(): Setting new future strategy stack:
[17:46:51.497] List of future strategies:
[17:46:51.497] 1. sequential:
[17:46:51.497]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.497]    - tweaked: FALSE
[17:46:51.497]    - call: plan(strategy)
[17:46:51.497] plan(): nbrOfWorkers() = 1
[17:46:51.497] SequentialFuture started (and completed)
[17:46:51.498] - Launch lazy future ... done
[17:46:51.498] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[17:46:51.500] getGlobalsAndPackages() ...
[17:46:51.500] Searching for globals...
[17:46:51.502] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[17:46:51.502] Searching for globals ... DONE
[17:46:51.502] Resolving globals: FALSE
[17:46:51.502] 
[17:46:51.502] - packages: [2] ‘stats’, ‘datasets’
[17:46:51.502] getGlobalsAndPackages() ... DONE
[17:46:51.503] run() for ‘Future’ ...
[17:46:51.503] - state: ‘created’
[17:46:51.503] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:51.503] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:51.503] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:51.503]   - Field: ‘label’
[17:46:51.503]   - Field: ‘local’
[17:46:51.504]   - Field: ‘owner’
[17:46:51.504]   - Field: ‘envir’
[17:46:51.504]   - Field: ‘packages’
[17:46:51.504]   - Field: ‘gc’
[17:46:51.504]   - Field: ‘conditions’
[17:46:51.504]   - Field: ‘expr’
[17:46:51.504]   - Field: ‘uuid’
[17:46:51.504]   - Field: ‘seed’
[17:46:51.504]   - Field: ‘version’
[17:46:51.504]   - Field: ‘result’
[17:46:51.504]   - Field: ‘asynchronous’
[17:46:51.504]   - Field: ‘calls’
[17:46:51.505]   - Field: ‘globals’
[17:46:51.505]   - Field: ‘stdout’
[17:46:51.505]   - Field: ‘earlySignal’
[17:46:51.505]   - Field: ‘lazy’
[17:46:51.505]   - Field: ‘state’
[17:46:51.505] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:51.505] - Launch lazy future ...
[17:46:51.505] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:51.505] Packages needed by future strategies (n = 0): <none>
[17:46:51.506] {
[17:46:51.506]     {
[17:46:51.506]         {
[17:46:51.506]             ...future.startTime <- base::Sys.time()
[17:46:51.506]             {
[17:46:51.506]                 {
[17:46:51.506]                   {
[17:46:51.506]                     {
[17:46:51.506]                       base::local({
[17:46:51.506]                         has_future <- base::requireNamespace("future", 
[17:46:51.506]                           quietly = TRUE)
[17:46:51.506]                         if (has_future) {
[17:46:51.506]                           ns <- base::getNamespace("future")
[17:46:51.506]                           version <- ns[[".package"]][["version"]]
[17:46:51.506]                           if (is.null(version)) 
[17:46:51.506]                             version <- utils::packageVersion("future")
[17:46:51.506]                         }
[17:46:51.506]                         else {
[17:46:51.506]                           version <- NULL
[17:46:51.506]                         }
[17:46:51.506]                         if (!has_future || version < "1.8.0") {
[17:46:51.506]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.506]                             "", base::R.version$version.string), 
[17:46:51.506]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:51.506]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:51.506]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.506]                               "release", "version")], collapse = " "), 
[17:46:51.506]                             hostname = base::Sys.info()[["nodename"]])
[17:46:51.506]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.506]                             info)
[17:46:51.506]                           info <- base::paste(info, collapse = "; ")
[17:46:51.506]                           if (!has_future) {
[17:46:51.506]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.506]                               info)
[17:46:51.506]                           }
[17:46:51.506]                           else {
[17:46:51.506]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.506]                               info, version)
[17:46:51.506]                           }
[17:46:51.506]                           base::stop(msg)
[17:46:51.506]                         }
[17:46:51.506]                       })
[17:46:51.506]                     }
[17:46:51.506]                     base::local({
[17:46:51.506]                       for (pkg in c("stats", "datasets")) {
[17:46:51.506]                         base::loadNamespace(pkg)
[17:46:51.506]                         base::library(pkg, character.only = TRUE)
[17:46:51.506]                       }
[17:46:51.506]                     })
[17:46:51.506]                   }
[17:46:51.506]                   ...future.strategy.old <- future::plan("list")
[17:46:51.506]                   options(future.plan = NULL)
[17:46:51.506]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.506]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.506]                 }
[17:46:51.506]                 ...future.workdir <- getwd()
[17:46:51.506]             }
[17:46:51.506]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.506]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.506]         }
[17:46:51.506]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.506]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.506]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.506]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.506]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.506]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.506]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.506]             base::names(...future.oldOptions))
[17:46:51.506]     }
[17:46:51.506]     if (FALSE) {
[17:46:51.506]     }
[17:46:51.506]     else {
[17:46:51.506]         if (TRUE) {
[17:46:51.506]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.506]                 open = "w")
[17:46:51.506]         }
[17:46:51.506]         else {
[17:46:51.506]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.506]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.506]         }
[17:46:51.506]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.506]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.506]             base::sink(type = "output", split = FALSE)
[17:46:51.506]             base::close(...future.stdout)
[17:46:51.506]         }, add = TRUE)
[17:46:51.506]     }
[17:46:51.506]     ...future.frame <- base::sys.nframe()
[17:46:51.506]     ...future.conditions <- base::list()
[17:46:51.506]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.506]     if (FALSE) {
[17:46:51.506]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.506]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.506]     }
[17:46:51.506]     ...future.result <- base::tryCatch({
[17:46:51.506]         base::withCallingHandlers({
[17:46:51.506]             ...future.value <- base::withVisible(base::local({
[17:46:51.506]                 lm(dist ~ speed + speed^2, data = cars)
[17:46:51.506]             }))
[17:46:51.506]             future::FutureResult(value = ...future.value$value, 
[17:46:51.506]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.506]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.506]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.506]                     ...future.globalenv.names))
[17:46:51.506]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.506]         }, condition = base::local({
[17:46:51.506]             c <- base::c
[17:46:51.506]             inherits <- base::inherits
[17:46:51.506]             invokeRestart <- base::invokeRestart
[17:46:51.506]             length <- base::length
[17:46:51.506]             list <- base::list
[17:46:51.506]             seq.int <- base::seq.int
[17:46:51.506]             signalCondition <- base::signalCondition
[17:46:51.506]             sys.calls <- base::sys.calls
[17:46:51.506]             `[[` <- base::`[[`
[17:46:51.506]             `+` <- base::`+`
[17:46:51.506]             `<<-` <- base::`<<-`
[17:46:51.506]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.506]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.506]                   3L)]
[17:46:51.506]             }
[17:46:51.506]             function(cond) {
[17:46:51.506]                 is_error <- inherits(cond, "error")
[17:46:51.506]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.506]                   NULL)
[17:46:51.506]                 if (is_error) {
[17:46:51.506]                   sessionInformation <- function() {
[17:46:51.506]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.506]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.506]                       search = base::search(), system = base::Sys.info())
[17:46:51.506]                   }
[17:46:51.506]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.506]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.506]                     cond$call), session = sessionInformation(), 
[17:46:51.506]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.506]                   signalCondition(cond)
[17:46:51.506]                 }
[17:46:51.506]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.506]                 "immediateCondition"))) {
[17:46:51.506]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.506]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.506]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.506]                   if (TRUE && !signal) {
[17:46:51.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.506]                     {
[17:46:51.506]                       inherits <- base::inherits
[17:46:51.506]                       invokeRestart <- base::invokeRestart
[17:46:51.506]                       is.null <- base::is.null
[17:46:51.506]                       muffled <- FALSE
[17:46:51.506]                       if (inherits(cond, "message")) {
[17:46:51.506]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.506]                         if (muffled) 
[17:46:51.506]                           invokeRestart("muffleMessage")
[17:46:51.506]                       }
[17:46:51.506]                       else if (inherits(cond, "warning")) {
[17:46:51.506]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.506]                         if (muffled) 
[17:46:51.506]                           invokeRestart("muffleWarning")
[17:46:51.506]                       }
[17:46:51.506]                       else if (inherits(cond, "condition")) {
[17:46:51.506]                         if (!is.null(pattern)) {
[17:46:51.506]                           computeRestarts <- base::computeRestarts
[17:46:51.506]                           grepl <- base::grepl
[17:46:51.506]                           restarts <- computeRestarts(cond)
[17:46:51.506]                           for (restart in restarts) {
[17:46:51.506]                             name <- restart$name
[17:46:51.506]                             if (is.null(name)) 
[17:46:51.506]                               next
[17:46:51.506]                             if (!grepl(pattern, name)) 
[17:46:51.506]                               next
[17:46:51.506]                             invokeRestart(restart)
[17:46:51.506]                             muffled <- TRUE
[17:46:51.506]                             break
[17:46:51.506]                           }
[17:46:51.506]                         }
[17:46:51.506]                       }
[17:46:51.506]                       invisible(muffled)
[17:46:51.506]                     }
[17:46:51.506]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.506]                   }
[17:46:51.506]                 }
[17:46:51.506]                 else {
[17:46:51.506]                   if (TRUE) {
[17:46:51.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.506]                     {
[17:46:51.506]                       inherits <- base::inherits
[17:46:51.506]                       invokeRestart <- base::invokeRestart
[17:46:51.506]                       is.null <- base::is.null
[17:46:51.506]                       muffled <- FALSE
[17:46:51.506]                       if (inherits(cond, "message")) {
[17:46:51.506]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.506]                         if (muffled) 
[17:46:51.506]                           invokeRestart("muffleMessage")
[17:46:51.506]                       }
[17:46:51.506]                       else if (inherits(cond, "warning")) {
[17:46:51.506]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.506]                         if (muffled) 
[17:46:51.506]                           invokeRestart("muffleWarning")
[17:46:51.506]                       }
[17:46:51.506]                       else if (inherits(cond, "condition")) {
[17:46:51.506]                         if (!is.null(pattern)) {
[17:46:51.506]                           computeRestarts <- base::computeRestarts
[17:46:51.506]                           grepl <- base::grepl
[17:46:51.506]                           restarts <- computeRestarts(cond)
[17:46:51.506]                           for (restart in restarts) {
[17:46:51.506]                             name <- restart$name
[17:46:51.506]                             if (is.null(name)) 
[17:46:51.506]                               next
[17:46:51.506]                             if (!grepl(pattern, name)) 
[17:46:51.506]                               next
[17:46:51.506]                             invokeRestart(restart)
[17:46:51.506]                             muffled <- TRUE
[17:46:51.506]                             break
[17:46:51.506]                           }
[17:46:51.506]                         }
[17:46:51.506]                       }
[17:46:51.506]                       invisible(muffled)
[17:46:51.506]                     }
[17:46:51.506]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.506]                   }
[17:46:51.506]                 }
[17:46:51.506]             }
[17:46:51.506]         }))
[17:46:51.506]     }, error = function(ex) {
[17:46:51.506]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.506]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.506]                 ...future.rng), started = ...future.startTime, 
[17:46:51.506]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.506]             version = "1.8"), class = "FutureResult")
[17:46:51.506]     }, finally = {
[17:46:51.506]         if (!identical(...future.workdir, getwd())) 
[17:46:51.506]             setwd(...future.workdir)
[17:46:51.506]         {
[17:46:51.506]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.506]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.506]             }
[17:46:51.506]             base::options(...future.oldOptions)
[17:46:51.506]             if (.Platform$OS.type == "windows") {
[17:46:51.506]                 old_names <- names(...future.oldEnvVars)
[17:46:51.506]                 envs <- base::Sys.getenv()
[17:46:51.506]                 names <- names(envs)
[17:46:51.506]                 common <- intersect(names, old_names)
[17:46:51.506]                 added <- setdiff(names, old_names)
[17:46:51.506]                 removed <- setdiff(old_names, names)
[17:46:51.506]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.506]                   envs[common]]
[17:46:51.506]                 NAMES <- toupper(changed)
[17:46:51.506]                 args <- list()
[17:46:51.506]                 for (kk in seq_along(NAMES)) {
[17:46:51.506]                   name <- changed[[kk]]
[17:46:51.506]                   NAME <- NAMES[[kk]]
[17:46:51.506]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.506]                     next
[17:46:51.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.506]                 }
[17:46:51.506]                 NAMES <- toupper(added)
[17:46:51.506]                 for (kk in seq_along(NAMES)) {
[17:46:51.506]                   name <- added[[kk]]
[17:46:51.506]                   NAME <- NAMES[[kk]]
[17:46:51.506]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.506]                     next
[17:46:51.506]                   args[[name]] <- ""
[17:46:51.506]                 }
[17:46:51.506]                 NAMES <- toupper(removed)
[17:46:51.506]                 for (kk in seq_along(NAMES)) {
[17:46:51.506]                   name <- removed[[kk]]
[17:46:51.506]                   NAME <- NAMES[[kk]]
[17:46:51.506]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.506]                     next
[17:46:51.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.506]                 }
[17:46:51.506]                 if (length(args) > 0) 
[17:46:51.506]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.506]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.506]             }
[17:46:51.506]             else {
[17:46:51.506]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.506]             }
[17:46:51.506]             {
[17:46:51.506]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.506]                   0L) {
[17:46:51.506]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.506]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.506]                   base::options(opts)
[17:46:51.506]                 }
[17:46:51.506]                 {
[17:46:51.506]                   {
[17:46:51.506]                     NULL
[17:46:51.506]                     RNGkind("Mersenne-Twister")
[17:46:51.506]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:51.506]                       inherits = FALSE)
[17:46:51.506]                   }
[17:46:51.506]                   options(future.plan = NULL)
[17:46:51.506]                   if (is.na(NA_character_)) 
[17:46:51.506]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.506]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.506]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.506]                     .init = FALSE)
[17:46:51.506]                 }
[17:46:51.506]             }
[17:46:51.506]         }
[17:46:51.506]     })
[17:46:51.506]     if (TRUE) {
[17:46:51.506]         base::sink(type = "output", split = FALSE)
[17:46:51.506]         if (TRUE) {
[17:46:51.506]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.506]         }
[17:46:51.506]         else {
[17:46:51.506]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.506]         }
[17:46:51.506]         base::close(...future.stdout)
[17:46:51.506]         ...future.stdout <- NULL
[17:46:51.506]     }
[17:46:51.506]     ...future.result$conditions <- ...future.conditions
[17:46:51.506]     ...future.result$finished <- base::Sys.time()
[17:46:51.506]     ...future.result
[17:46:51.506] }
[17:46:51.508] plan(): Setting new future strategy stack:
[17:46:51.508] List of future strategies:
[17:46:51.508] 1. sequential:
[17:46:51.508]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.508]    - tweaked: FALSE
[17:46:51.508]    - call: NULL
[17:46:51.508] plan(): nbrOfWorkers() = 1
[17:46:51.510] plan(): Setting new future strategy stack:
[17:46:51.510] List of future strategies:
[17:46:51.510] 1. sequential:
[17:46:51.510]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.510]    - tweaked: FALSE
[17:46:51.510]    - call: plan(strategy)
[17:46:51.510] plan(): nbrOfWorkers() = 1
[17:46:51.510] SequentialFuture started (and completed)
[17:46:51.510] - Launch lazy future ... done
[17:46:51.511] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[17:46:51.515] getGlobalsAndPackages() ...
[17:46:51.515] Searching for globals...
[17:46:51.517] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[17:46:51.517] Searching for globals ... DONE
[17:46:51.517] Resolving globals: FALSE
[17:46:51.518] 
[17:46:51.518] - packages: [2] ‘stats’, ‘datasets’
[17:46:51.518] getGlobalsAndPackages() ... DONE
[17:46:51.518] run() for ‘Future’ ...
[17:46:51.518] - state: ‘created’
[17:46:51.518] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:51.518] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:51.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:51.519]   - Field: ‘label’
[17:46:51.519]   - Field: ‘local’
[17:46:51.519]   - Field: ‘owner’
[17:46:51.519]   - Field: ‘envir’
[17:46:51.519]   - Field: ‘packages’
[17:46:51.519]   - Field: ‘gc’
[17:46:51.519]   - Field: ‘conditions’
[17:46:51.519]   - Field: ‘expr’
[17:46:51.519]   - Field: ‘uuid’
[17:46:51.520]   - Field: ‘seed’
[17:46:51.520]   - Field: ‘version’
[17:46:51.520]   - Field: ‘result’
[17:46:51.520]   - Field: ‘asynchronous’
[17:46:51.520]   - Field: ‘calls’
[17:46:51.520]   - Field: ‘globals’
[17:46:51.520]   - Field: ‘stdout’
[17:46:51.520]   - Field: ‘earlySignal’
[17:46:51.520]   - Field: ‘lazy’
[17:46:51.520]   - Field: ‘state’
[17:46:51.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:51.521] - Launch lazy future ...
[17:46:51.521] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:51.521] Packages needed by future strategies (n = 0): <none>
[17:46:51.521] {
[17:46:51.521]     {
[17:46:51.521]         {
[17:46:51.521]             ...future.startTime <- base::Sys.time()
[17:46:51.521]             {
[17:46:51.521]                 {
[17:46:51.521]                   {
[17:46:51.521]                     {
[17:46:51.521]                       base::local({
[17:46:51.521]                         has_future <- base::requireNamespace("future", 
[17:46:51.521]                           quietly = TRUE)
[17:46:51.521]                         if (has_future) {
[17:46:51.521]                           ns <- base::getNamespace("future")
[17:46:51.521]                           version <- ns[[".package"]][["version"]]
[17:46:51.521]                           if (is.null(version)) 
[17:46:51.521]                             version <- utils::packageVersion("future")
[17:46:51.521]                         }
[17:46:51.521]                         else {
[17:46:51.521]                           version <- NULL
[17:46:51.521]                         }
[17:46:51.521]                         if (!has_future || version < "1.8.0") {
[17:46:51.521]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.521]                             "", base::R.version$version.string), 
[17:46:51.521]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:51.521]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:51.521]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.521]                               "release", "version")], collapse = " "), 
[17:46:51.521]                             hostname = base::Sys.info()[["nodename"]])
[17:46:51.521]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.521]                             info)
[17:46:51.521]                           info <- base::paste(info, collapse = "; ")
[17:46:51.521]                           if (!has_future) {
[17:46:51.521]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.521]                               info)
[17:46:51.521]                           }
[17:46:51.521]                           else {
[17:46:51.521]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.521]                               info, version)
[17:46:51.521]                           }
[17:46:51.521]                           base::stop(msg)
[17:46:51.521]                         }
[17:46:51.521]                       })
[17:46:51.521]                     }
[17:46:51.521]                     base::local({
[17:46:51.521]                       for (pkg in c("stats", "datasets")) {
[17:46:51.521]                         base::loadNamespace(pkg)
[17:46:51.521]                         base::library(pkg, character.only = TRUE)
[17:46:51.521]                       }
[17:46:51.521]                     })
[17:46:51.521]                   }
[17:46:51.521]                   ...future.strategy.old <- future::plan("list")
[17:46:51.521]                   options(future.plan = NULL)
[17:46:51.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.521]                 }
[17:46:51.521]                 ...future.workdir <- getwd()
[17:46:51.521]             }
[17:46:51.521]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.521]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.521]         }
[17:46:51.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.521]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.521]             base::names(...future.oldOptions))
[17:46:51.521]     }
[17:46:51.521]     if (FALSE) {
[17:46:51.521]     }
[17:46:51.521]     else {
[17:46:51.521]         if (TRUE) {
[17:46:51.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.521]                 open = "w")
[17:46:51.521]         }
[17:46:51.521]         else {
[17:46:51.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.521]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.521]         }
[17:46:51.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.521]             base::sink(type = "output", split = FALSE)
[17:46:51.521]             base::close(...future.stdout)
[17:46:51.521]         }, add = TRUE)
[17:46:51.521]     }
[17:46:51.521]     ...future.frame <- base::sys.nframe()
[17:46:51.521]     ...future.conditions <- base::list()
[17:46:51.521]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.521]     if (FALSE) {
[17:46:51.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.521]     }
[17:46:51.521]     ...future.result <- base::tryCatch({
[17:46:51.521]         base::withCallingHandlers({
[17:46:51.521]             ...future.value <- base::withVisible(base::local({
[17:46:51.521]                 lm(dist ~ speed + I(speed^2), data = cars)
[17:46:51.521]             }))
[17:46:51.521]             future::FutureResult(value = ...future.value$value, 
[17:46:51.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.521]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.521]                     ...future.globalenv.names))
[17:46:51.521]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.521]         }, condition = base::local({
[17:46:51.521]             c <- base::c
[17:46:51.521]             inherits <- base::inherits
[17:46:51.521]             invokeRestart <- base::invokeRestart
[17:46:51.521]             length <- base::length
[17:46:51.521]             list <- base::list
[17:46:51.521]             seq.int <- base::seq.int
[17:46:51.521]             signalCondition <- base::signalCondition
[17:46:51.521]             sys.calls <- base::sys.calls
[17:46:51.521]             `[[` <- base::`[[`
[17:46:51.521]             `+` <- base::`+`
[17:46:51.521]             `<<-` <- base::`<<-`
[17:46:51.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.521]                   3L)]
[17:46:51.521]             }
[17:46:51.521]             function(cond) {
[17:46:51.521]                 is_error <- inherits(cond, "error")
[17:46:51.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.521]                   NULL)
[17:46:51.521]                 if (is_error) {
[17:46:51.521]                   sessionInformation <- function() {
[17:46:51.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.521]                       search = base::search(), system = base::Sys.info())
[17:46:51.521]                   }
[17:46:51.521]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.521]                     cond$call), session = sessionInformation(), 
[17:46:51.521]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.521]                   signalCondition(cond)
[17:46:51.521]                 }
[17:46:51.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.521]                 "immediateCondition"))) {
[17:46:51.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.521]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.521]                   if (TRUE && !signal) {
[17:46:51.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.521]                     {
[17:46:51.521]                       inherits <- base::inherits
[17:46:51.521]                       invokeRestart <- base::invokeRestart
[17:46:51.521]                       is.null <- base::is.null
[17:46:51.521]                       muffled <- FALSE
[17:46:51.521]                       if (inherits(cond, "message")) {
[17:46:51.521]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.521]                         if (muffled) 
[17:46:51.521]                           invokeRestart("muffleMessage")
[17:46:51.521]                       }
[17:46:51.521]                       else if (inherits(cond, "warning")) {
[17:46:51.521]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.521]                         if (muffled) 
[17:46:51.521]                           invokeRestart("muffleWarning")
[17:46:51.521]                       }
[17:46:51.521]                       else if (inherits(cond, "condition")) {
[17:46:51.521]                         if (!is.null(pattern)) {
[17:46:51.521]                           computeRestarts <- base::computeRestarts
[17:46:51.521]                           grepl <- base::grepl
[17:46:51.521]                           restarts <- computeRestarts(cond)
[17:46:51.521]                           for (restart in restarts) {
[17:46:51.521]                             name <- restart$name
[17:46:51.521]                             if (is.null(name)) 
[17:46:51.521]                               next
[17:46:51.521]                             if (!grepl(pattern, name)) 
[17:46:51.521]                               next
[17:46:51.521]                             invokeRestart(restart)
[17:46:51.521]                             muffled <- TRUE
[17:46:51.521]                             break
[17:46:51.521]                           }
[17:46:51.521]                         }
[17:46:51.521]                       }
[17:46:51.521]                       invisible(muffled)
[17:46:51.521]                     }
[17:46:51.521]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.521]                   }
[17:46:51.521]                 }
[17:46:51.521]                 else {
[17:46:51.521]                   if (TRUE) {
[17:46:51.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.521]                     {
[17:46:51.521]                       inherits <- base::inherits
[17:46:51.521]                       invokeRestart <- base::invokeRestart
[17:46:51.521]                       is.null <- base::is.null
[17:46:51.521]                       muffled <- FALSE
[17:46:51.521]                       if (inherits(cond, "message")) {
[17:46:51.521]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.521]                         if (muffled) 
[17:46:51.521]                           invokeRestart("muffleMessage")
[17:46:51.521]                       }
[17:46:51.521]                       else if (inherits(cond, "warning")) {
[17:46:51.521]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.521]                         if (muffled) 
[17:46:51.521]                           invokeRestart("muffleWarning")
[17:46:51.521]                       }
[17:46:51.521]                       else if (inherits(cond, "condition")) {
[17:46:51.521]                         if (!is.null(pattern)) {
[17:46:51.521]                           computeRestarts <- base::computeRestarts
[17:46:51.521]                           grepl <- base::grepl
[17:46:51.521]                           restarts <- computeRestarts(cond)
[17:46:51.521]                           for (restart in restarts) {
[17:46:51.521]                             name <- restart$name
[17:46:51.521]                             if (is.null(name)) 
[17:46:51.521]                               next
[17:46:51.521]                             if (!grepl(pattern, name)) 
[17:46:51.521]                               next
[17:46:51.521]                             invokeRestart(restart)
[17:46:51.521]                             muffled <- TRUE
[17:46:51.521]                             break
[17:46:51.521]                           }
[17:46:51.521]                         }
[17:46:51.521]                       }
[17:46:51.521]                       invisible(muffled)
[17:46:51.521]                     }
[17:46:51.521]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.521]                   }
[17:46:51.521]                 }
[17:46:51.521]             }
[17:46:51.521]         }))
[17:46:51.521]     }, error = function(ex) {
[17:46:51.521]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.521]                 ...future.rng), started = ...future.startTime, 
[17:46:51.521]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.521]             version = "1.8"), class = "FutureResult")
[17:46:51.521]     }, finally = {
[17:46:51.521]         if (!identical(...future.workdir, getwd())) 
[17:46:51.521]             setwd(...future.workdir)
[17:46:51.521]         {
[17:46:51.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.521]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.521]             }
[17:46:51.521]             base::options(...future.oldOptions)
[17:46:51.521]             if (.Platform$OS.type == "windows") {
[17:46:51.521]                 old_names <- names(...future.oldEnvVars)
[17:46:51.521]                 envs <- base::Sys.getenv()
[17:46:51.521]                 names <- names(envs)
[17:46:51.521]                 common <- intersect(names, old_names)
[17:46:51.521]                 added <- setdiff(names, old_names)
[17:46:51.521]                 removed <- setdiff(old_names, names)
[17:46:51.521]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.521]                   envs[common]]
[17:46:51.521]                 NAMES <- toupper(changed)
[17:46:51.521]                 args <- list()
[17:46:51.521]                 for (kk in seq_along(NAMES)) {
[17:46:51.521]                   name <- changed[[kk]]
[17:46:51.521]                   NAME <- NAMES[[kk]]
[17:46:51.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.521]                     next
[17:46:51.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.521]                 }
[17:46:51.521]                 NAMES <- toupper(added)
[17:46:51.521]                 for (kk in seq_along(NAMES)) {
[17:46:51.521]                   name <- added[[kk]]
[17:46:51.521]                   NAME <- NAMES[[kk]]
[17:46:51.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.521]                     next
[17:46:51.521]                   args[[name]] <- ""
[17:46:51.521]                 }
[17:46:51.521]                 NAMES <- toupper(removed)
[17:46:51.521]                 for (kk in seq_along(NAMES)) {
[17:46:51.521]                   name <- removed[[kk]]
[17:46:51.521]                   NAME <- NAMES[[kk]]
[17:46:51.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.521]                     next
[17:46:51.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.521]                 }
[17:46:51.521]                 if (length(args) > 0) 
[17:46:51.521]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.521]             }
[17:46:51.521]             else {
[17:46:51.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.521]             }
[17:46:51.521]             {
[17:46:51.521]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.521]                   0L) {
[17:46:51.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.521]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.521]                   base::options(opts)
[17:46:51.521]                 }
[17:46:51.521]                 {
[17:46:51.521]                   {
[17:46:51.521]                     NULL
[17:46:51.521]                     RNGkind("Mersenne-Twister")
[17:46:51.521]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:51.521]                       inherits = FALSE)
[17:46:51.521]                   }
[17:46:51.521]                   options(future.plan = NULL)
[17:46:51.521]                   if (is.na(NA_character_)) 
[17:46:51.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.521]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.521]                     .init = FALSE)
[17:46:51.521]                 }
[17:46:51.521]             }
[17:46:51.521]         }
[17:46:51.521]     })
[17:46:51.521]     if (TRUE) {
[17:46:51.521]         base::sink(type = "output", split = FALSE)
[17:46:51.521]         if (TRUE) {
[17:46:51.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.521]         }
[17:46:51.521]         else {
[17:46:51.521]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.521]         }
[17:46:51.521]         base::close(...future.stdout)
[17:46:51.521]         ...future.stdout <- NULL
[17:46:51.521]     }
[17:46:51.521]     ...future.result$conditions <- ...future.conditions
[17:46:51.521]     ...future.result$finished <- base::Sys.time()
[17:46:51.521]     ...future.result
[17:46:51.521] }
[17:46:51.523] plan(): Setting new future strategy stack:
[17:46:51.523] List of future strategies:
[17:46:51.523] 1. sequential:
[17:46:51.523]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.523]    - tweaked: FALSE
[17:46:51.523]    - call: NULL
[17:46:51.524] plan(): nbrOfWorkers() = 1
[17:46:51.525] plan(): Setting new future strategy stack:
[17:46:51.525] List of future strategies:
[17:46:51.525] 1. sequential:
[17:46:51.525]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.525]    - tweaked: FALSE
[17:46:51.525]    - call: plan(strategy)
[17:46:51.526] plan(): nbrOfWorkers() = 1
[17:46:51.526] SequentialFuture started (and completed)
[17:46:51.526] - Launch lazy future ... done
[17:46:51.526] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[17:46:51.529] getGlobalsAndPackages() ...
[17:46:51.529] Searching for globals...
[17:46:51.531] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[17:46:51.531] Searching for globals ... DONE
[17:46:51.531] Resolving globals: FALSE
[17:46:51.532] 
[17:46:51.532] - packages: [2] ‘stats’, ‘datasets’
[17:46:51.532] getGlobalsAndPackages() ... DONE
[17:46:51.532] run() for ‘Future’ ...
[17:46:51.532] - state: ‘created’
[17:46:51.532] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:51.532] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:51.533] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:51.533]   - Field: ‘label’
[17:46:51.533]   - Field: ‘local’
[17:46:51.533]   - Field: ‘owner’
[17:46:51.533]   - Field: ‘envir’
[17:46:51.533]   - Field: ‘packages’
[17:46:51.533]   - Field: ‘gc’
[17:46:51.533]   - Field: ‘conditions’
[17:46:51.533]   - Field: ‘expr’
[17:46:51.533]   - Field: ‘uuid’
[17:46:51.534]   - Field: ‘seed’
[17:46:51.534]   - Field: ‘version’
[17:46:51.534]   - Field: ‘result’
[17:46:51.534]   - Field: ‘asynchronous’
[17:46:51.534]   - Field: ‘calls’
[17:46:51.534]   - Field: ‘globals’
[17:46:51.534]   - Field: ‘stdout’
[17:46:51.534]   - Field: ‘earlySignal’
[17:46:51.534]   - Field: ‘lazy’
[17:46:51.534]   - Field: ‘state’
[17:46:51.534] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:51.535] - Launch lazy future ...
[17:46:51.535] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:51.535] Packages needed by future strategies (n = 0): <none>
[17:46:51.535] {
[17:46:51.535]     {
[17:46:51.535]         {
[17:46:51.535]             ...future.startTime <- base::Sys.time()
[17:46:51.535]             {
[17:46:51.535]                 {
[17:46:51.535]                   {
[17:46:51.535]                     {
[17:46:51.535]                       base::local({
[17:46:51.535]                         has_future <- base::requireNamespace("future", 
[17:46:51.535]                           quietly = TRUE)
[17:46:51.535]                         if (has_future) {
[17:46:51.535]                           ns <- base::getNamespace("future")
[17:46:51.535]                           version <- ns[[".package"]][["version"]]
[17:46:51.535]                           if (is.null(version)) 
[17:46:51.535]                             version <- utils::packageVersion("future")
[17:46:51.535]                         }
[17:46:51.535]                         else {
[17:46:51.535]                           version <- NULL
[17:46:51.535]                         }
[17:46:51.535]                         if (!has_future || version < "1.8.0") {
[17:46:51.535]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.535]                             "", base::R.version$version.string), 
[17:46:51.535]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:51.535]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:51.535]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.535]                               "release", "version")], collapse = " "), 
[17:46:51.535]                             hostname = base::Sys.info()[["nodename"]])
[17:46:51.535]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.535]                             info)
[17:46:51.535]                           info <- base::paste(info, collapse = "; ")
[17:46:51.535]                           if (!has_future) {
[17:46:51.535]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.535]                               info)
[17:46:51.535]                           }
[17:46:51.535]                           else {
[17:46:51.535]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.535]                               info, version)
[17:46:51.535]                           }
[17:46:51.535]                           base::stop(msg)
[17:46:51.535]                         }
[17:46:51.535]                       })
[17:46:51.535]                     }
[17:46:51.535]                     base::local({
[17:46:51.535]                       for (pkg in c("stats", "datasets")) {
[17:46:51.535]                         base::loadNamespace(pkg)
[17:46:51.535]                         base::library(pkg, character.only = TRUE)
[17:46:51.535]                       }
[17:46:51.535]                     })
[17:46:51.535]                   }
[17:46:51.535]                   ...future.strategy.old <- future::plan("list")
[17:46:51.535]                   options(future.plan = NULL)
[17:46:51.535]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.535]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.535]                 }
[17:46:51.535]                 ...future.workdir <- getwd()
[17:46:51.535]             }
[17:46:51.535]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.535]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.535]         }
[17:46:51.535]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.535]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.535]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.535]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.535]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.535]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.535]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.535]             base::names(...future.oldOptions))
[17:46:51.535]     }
[17:46:51.535]     if (FALSE) {
[17:46:51.535]     }
[17:46:51.535]     else {
[17:46:51.535]         if (TRUE) {
[17:46:51.535]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.535]                 open = "w")
[17:46:51.535]         }
[17:46:51.535]         else {
[17:46:51.535]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.535]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.535]         }
[17:46:51.535]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.535]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.535]             base::sink(type = "output", split = FALSE)
[17:46:51.535]             base::close(...future.stdout)
[17:46:51.535]         }, add = TRUE)
[17:46:51.535]     }
[17:46:51.535]     ...future.frame <- base::sys.nframe()
[17:46:51.535]     ...future.conditions <- base::list()
[17:46:51.535]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.535]     if (FALSE) {
[17:46:51.535]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.535]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.535]     }
[17:46:51.535]     ...future.result <- base::tryCatch({
[17:46:51.535]         base::withCallingHandlers({
[17:46:51.535]             ...future.value <- base::withVisible(base::local({
[17:46:51.535]                 lm(dist ~ poly(speed, 2), data = cars)
[17:46:51.535]             }))
[17:46:51.535]             future::FutureResult(value = ...future.value$value, 
[17:46:51.535]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.535]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.535]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.535]                     ...future.globalenv.names))
[17:46:51.535]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.535]         }, condition = base::local({
[17:46:51.535]             c <- base::c
[17:46:51.535]             inherits <- base::inherits
[17:46:51.535]             invokeRestart <- base::invokeRestart
[17:46:51.535]             length <- base::length
[17:46:51.535]             list <- base::list
[17:46:51.535]             seq.int <- base::seq.int
[17:46:51.535]             signalCondition <- base::signalCondition
[17:46:51.535]             sys.calls <- base::sys.calls
[17:46:51.535]             `[[` <- base::`[[`
[17:46:51.535]             `+` <- base::`+`
[17:46:51.535]             `<<-` <- base::`<<-`
[17:46:51.535]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.535]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.535]                   3L)]
[17:46:51.535]             }
[17:46:51.535]             function(cond) {
[17:46:51.535]                 is_error <- inherits(cond, "error")
[17:46:51.535]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.535]                   NULL)
[17:46:51.535]                 if (is_error) {
[17:46:51.535]                   sessionInformation <- function() {
[17:46:51.535]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.535]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.535]                       search = base::search(), system = base::Sys.info())
[17:46:51.535]                   }
[17:46:51.535]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.535]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.535]                     cond$call), session = sessionInformation(), 
[17:46:51.535]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.535]                   signalCondition(cond)
[17:46:51.535]                 }
[17:46:51.535]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.535]                 "immediateCondition"))) {
[17:46:51.535]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.535]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.535]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.535]                   if (TRUE && !signal) {
[17:46:51.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.535]                     {
[17:46:51.535]                       inherits <- base::inherits
[17:46:51.535]                       invokeRestart <- base::invokeRestart
[17:46:51.535]                       is.null <- base::is.null
[17:46:51.535]                       muffled <- FALSE
[17:46:51.535]                       if (inherits(cond, "message")) {
[17:46:51.535]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.535]                         if (muffled) 
[17:46:51.535]                           invokeRestart("muffleMessage")
[17:46:51.535]                       }
[17:46:51.535]                       else if (inherits(cond, "warning")) {
[17:46:51.535]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.535]                         if (muffled) 
[17:46:51.535]                           invokeRestart("muffleWarning")
[17:46:51.535]                       }
[17:46:51.535]                       else if (inherits(cond, "condition")) {
[17:46:51.535]                         if (!is.null(pattern)) {
[17:46:51.535]                           computeRestarts <- base::computeRestarts
[17:46:51.535]                           grepl <- base::grepl
[17:46:51.535]                           restarts <- computeRestarts(cond)
[17:46:51.535]                           for (restart in restarts) {
[17:46:51.535]                             name <- restart$name
[17:46:51.535]                             if (is.null(name)) 
[17:46:51.535]                               next
[17:46:51.535]                             if (!grepl(pattern, name)) 
[17:46:51.535]                               next
[17:46:51.535]                             invokeRestart(restart)
[17:46:51.535]                             muffled <- TRUE
[17:46:51.535]                             break
[17:46:51.535]                           }
[17:46:51.535]                         }
[17:46:51.535]                       }
[17:46:51.535]                       invisible(muffled)
[17:46:51.535]                     }
[17:46:51.535]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.535]                   }
[17:46:51.535]                 }
[17:46:51.535]                 else {
[17:46:51.535]                   if (TRUE) {
[17:46:51.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.535]                     {
[17:46:51.535]                       inherits <- base::inherits
[17:46:51.535]                       invokeRestart <- base::invokeRestart
[17:46:51.535]                       is.null <- base::is.null
[17:46:51.535]                       muffled <- FALSE
[17:46:51.535]                       if (inherits(cond, "message")) {
[17:46:51.535]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.535]                         if (muffled) 
[17:46:51.535]                           invokeRestart("muffleMessage")
[17:46:51.535]                       }
[17:46:51.535]                       else if (inherits(cond, "warning")) {
[17:46:51.535]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.535]                         if (muffled) 
[17:46:51.535]                           invokeRestart("muffleWarning")
[17:46:51.535]                       }
[17:46:51.535]                       else if (inherits(cond, "condition")) {
[17:46:51.535]                         if (!is.null(pattern)) {
[17:46:51.535]                           computeRestarts <- base::computeRestarts
[17:46:51.535]                           grepl <- base::grepl
[17:46:51.535]                           restarts <- computeRestarts(cond)
[17:46:51.535]                           for (restart in restarts) {
[17:46:51.535]                             name <- restart$name
[17:46:51.535]                             if (is.null(name)) 
[17:46:51.535]                               next
[17:46:51.535]                             if (!grepl(pattern, name)) 
[17:46:51.535]                               next
[17:46:51.535]                             invokeRestart(restart)
[17:46:51.535]                             muffled <- TRUE
[17:46:51.535]                             break
[17:46:51.535]                           }
[17:46:51.535]                         }
[17:46:51.535]                       }
[17:46:51.535]                       invisible(muffled)
[17:46:51.535]                     }
[17:46:51.535]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.535]                   }
[17:46:51.535]                 }
[17:46:51.535]             }
[17:46:51.535]         }))
[17:46:51.535]     }, error = function(ex) {
[17:46:51.535]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.535]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.535]                 ...future.rng), started = ...future.startTime, 
[17:46:51.535]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.535]             version = "1.8"), class = "FutureResult")
[17:46:51.535]     }, finally = {
[17:46:51.535]         if (!identical(...future.workdir, getwd())) 
[17:46:51.535]             setwd(...future.workdir)
[17:46:51.535]         {
[17:46:51.535]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.535]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.535]             }
[17:46:51.535]             base::options(...future.oldOptions)
[17:46:51.535]             if (.Platform$OS.type == "windows") {
[17:46:51.535]                 old_names <- names(...future.oldEnvVars)
[17:46:51.535]                 envs <- base::Sys.getenv()
[17:46:51.535]                 names <- names(envs)
[17:46:51.535]                 common <- intersect(names, old_names)
[17:46:51.535]                 added <- setdiff(names, old_names)
[17:46:51.535]                 removed <- setdiff(old_names, names)
[17:46:51.535]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.535]                   envs[common]]
[17:46:51.535]                 NAMES <- toupper(changed)
[17:46:51.535]                 args <- list()
[17:46:51.535]                 for (kk in seq_along(NAMES)) {
[17:46:51.535]                   name <- changed[[kk]]
[17:46:51.535]                   NAME <- NAMES[[kk]]
[17:46:51.535]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.535]                     next
[17:46:51.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.535]                 }
[17:46:51.535]                 NAMES <- toupper(added)
[17:46:51.535]                 for (kk in seq_along(NAMES)) {
[17:46:51.535]                   name <- added[[kk]]
[17:46:51.535]                   NAME <- NAMES[[kk]]
[17:46:51.535]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.535]                     next
[17:46:51.535]                   args[[name]] <- ""
[17:46:51.535]                 }
[17:46:51.535]                 NAMES <- toupper(removed)
[17:46:51.535]                 for (kk in seq_along(NAMES)) {
[17:46:51.535]                   name <- removed[[kk]]
[17:46:51.535]                   NAME <- NAMES[[kk]]
[17:46:51.535]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.535]                     next
[17:46:51.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.535]                 }
[17:46:51.535]                 if (length(args) > 0) 
[17:46:51.535]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.535]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.535]             }
[17:46:51.535]             else {
[17:46:51.535]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.535]             }
[17:46:51.535]             {
[17:46:51.535]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.535]                   0L) {
[17:46:51.535]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.535]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.535]                   base::options(opts)
[17:46:51.535]                 }
[17:46:51.535]                 {
[17:46:51.535]                   {
[17:46:51.535]                     NULL
[17:46:51.535]                     RNGkind("Mersenne-Twister")
[17:46:51.535]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:51.535]                       inherits = FALSE)
[17:46:51.535]                   }
[17:46:51.535]                   options(future.plan = NULL)
[17:46:51.535]                   if (is.na(NA_character_)) 
[17:46:51.535]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.535]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.535]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.535]                     .init = FALSE)
[17:46:51.535]                 }
[17:46:51.535]             }
[17:46:51.535]         }
[17:46:51.535]     })
[17:46:51.535]     if (TRUE) {
[17:46:51.535]         base::sink(type = "output", split = FALSE)
[17:46:51.535]         if (TRUE) {
[17:46:51.535]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.535]         }
[17:46:51.535]         else {
[17:46:51.535]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.535]         }
[17:46:51.535]         base::close(...future.stdout)
[17:46:51.535]         ...future.stdout <- NULL
[17:46:51.535]     }
[17:46:51.535]     ...future.result$conditions <- ...future.conditions
[17:46:51.535]     ...future.result$finished <- base::Sys.time()
[17:46:51.535]     ...future.result
[17:46:51.535] }
[17:46:51.537] plan(): Setting new future strategy stack:
[17:46:51.537] List of future strategies:
[17:46:51.537] 1. sequential:
[17:46:51.537]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.537]    - tweaked: FALSE
[17:46:51.537]    - call: NULL
[17:46:51.538] plan(): nbrOfWorkers() = 1
[17:46:51.541] plan(): Setting new future strategy stack:
[17:46:51.541] List of future strategies:
[17:46:51.541] 1. sequential:
[17:46:51.541]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.541]    - tweaked: FALSE
[17:46:51.541]    - call: plan(strategy)
[17:46:51.541] plan(): nbrOfWorkers() = 1
[17:46:51.541] SequentialFuture started (and completed)
[17:46:51.542] - Launch lazy future ... done
[17:46:51.542] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[17:46:51.544] getGlobalsAndPackages() ...
[17:46:51.544] Searching for globals...
[17:46:51.548] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:46:51.548] Searching for globals ... DONE
[17:46:51.548] Resolving globals: FALSE
[17:46:51.549] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:46:51.549] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:46:51.550] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:46:51.550] 
[17:46:51.550] getGlobalsAndPackages() ... DONE
[17:46:51.550] run() for ‘Future’ ...
[17:46:51.550] - state: ‘created’
[17:46:51.550] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:51.550] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:51.551] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:51.551]   - Field: ‘label’
[17:46:51.551]   - Field: ‘local’
[17:46:51.551]   - Field: ‘owner’
[17:46:51.551]   - Field: ‘envir’
[17:46:51.551]   - Field: ‘packages’
[17:46:51.551]   - Field: ‘gc’
[17:46:51.551]   - Field: ‘conditions’
[17:46:51.551]   - Field: ‘expr’
[17:46:51.551]   - Field: ‘uuid’
[17:46:51.551]   - Field: ‘seed’
[17:46:51.552]   - Field: ‘version’
[17:46:51.552]   - Field: ‘result’
[17:46:51.552]   - Field: ‘asynchronous’
[17:46:51.552]   - Field: ‘calls’
[17:46:51.552]   - Field: ‘globals’
[17:46:51.552]   - Field: ‘stdout’
[17:46:51.552]   - Field: ‘earlySignal’
[17:46:51.552]   - Field: ‘lazy’
[17:46:51.552]   - Field: ‘state’
[17:46:51.552] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:51.552] - Launch lazy future ...
[17:46:51.553] Packages needed by the future expression (n = 0): <none>
[17:46:51.553] Packages needed by future strategies (n = 0): <none>
[17:46:51.553] {
[17:46:51.553]     {
[17:46:51.553]         {
[17:46:51.553]             ...future.startTime <- base::Sys.time()
[17:46:51.553]             {
[17:46:51.553]                 {
[17:46:51.553]                   {
[17:46:51.553]                     base::local({
[17:46:51.553]                       has_future <- base::requireNamespace("future", 
[17:46:51.553]                         quietly = TRUE)
[17:46:51.553]                       if (has_future) {
[17:46:51.553]                         ns <- base::getNamespace("future")
[17:46:51.553]                         version <- ns[[".package"]][["version"]]
[17:46:51.553]                         if (is.null(version)) 
[17:46:51.553]                           version <- utils::packageVersion("future")
[17:46:51.553]                       }
[17:46:51.553]                       else {
[17:46:51.553]                         version <- NULL
[17:46:51.553]                       }
[17:46:51.553]                       if (!has_future || version < "1.8.0") {
[17:46:51.553]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.553]                           "", base::R.version$version.string), 
[17:46:51.553]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:51.553]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:51.553]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.553]                             "release", "version")], collapse = " "), 
[17:46:51.553]                           hostname = base::Sys.info()[["nodename"]])
[17:46:51.553]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.553]                           info)
[17:46:51.553]                         info <- base::paste(info, collapse = "; ")
[17:46:51.553]                         if (!has_future) {
[17:46:51.553]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.553]                             info)
[17:46:51.553]                         }
[17:46:51.553]                         else {
[17:46:51.553]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.553]                             info, version)
[17:46:51.553]                         }
[17:46:51.553]                         base::stop(msg)
[17:46:51.553]                       }
[17:46:51.553]                     })
[17:46:51.553]                   }
[17:46:51.553]                   ...future.strategy.old <- future::plan("list")
[17:46:51.553]                   options(future.plan = NULL)
[17:46:51.553]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.553]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.553]                 }
[17:46:51.553]                 ...future.workdir <- getwd()
[17:46:51.553]             }
[17:46:51.553]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.553]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.553]         }
[17:46:51.553]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.553]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.553]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.553]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.553]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.553]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.553]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.553]             base::names(...future.oldOptions))
[17:46:51.553]     }
[17:46:51.553]     if (FALSE) {
[17:46:51.553]     }
[17:46:51.553]     else {
[17:46:51.553]         if (TRUE) {
[17:46:51.553]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.553]                 open = "w")
[17:46:51.553]         }
[17:46:51.553]         else {
[17:46:51.553]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.553]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.553]         }
[17:46:51.553]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.553]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.553]             base::sink(type = "output", split = FALSE)
[17:46:51.553]             base::close(...future.stdout)
[17:46:51.553]         }, add = TRUE)
[17:46:51.553]     }
[17:46:51.553]     ...future.frame <- base::sys.nframe()
[17:46:51.553]     ...future.conditions <- base::list()
[17:46:51.553]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.553]     if (FALSE) {
[17:46:51.553]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.553]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.553]     }
[17:46:51.553]     ...future.result <- base::tryCatch({
[17:46:51.553]         base::withCallingHandlers({
[17:46:51.553]             ...future.value <- base::withVisible(base::local({
[17:46:51.553]                 outer_function(1L)
[17:46:51.553]             }))
[17:46:51.553]             future::FutureResult(value = ...future.value$value, 
[17:46:51.553]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.553]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.553]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.553]                     ...future.globalenv.names))
[17:46:51.553]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.553]         }, condition = base::local({
[17:46:51.553]             c <- base::c
[17:46:51.553]             inherits <- base::inherits
[17:46:51.553]             invokeRestart <- base::invokeRestart
[17:46:51.553]             length <- base::length
[17:46:51.553]             list <- base::list
[17:46:51.553]             seq.int <- base::seq.int
[17:46:51.553]             signalCondition <- base::signalCondition
[17:46:51.553]             sys.calls <- base::sys.calls
[17:46:51.553]             `[[` <- base::`[[`
[17:46:51.553]             `+` <- base::`+`
[17:46:51.553]             `<<-` <- base::`<<-`
[17:46:51.553]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.553]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.553]                   3L)]
[17:46:51.553]             }
[17:46:51.553]             function(cond) {
[17:46:51.553]                 is_error <- inherits(cond, "error")
[17:46:51.553]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.553]                   NULL)
[17:46:51.553]                 if (is_error) {
[17:46:51.553]                   sessionInformation <- function() {
[17:46:51.553]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.553]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.553]                       search = base::search(), system = base::Sys.info())
[17:46:51.553]                   }
[17:46:51.553]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.553]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.553]                     cond$call), session = sessionInformation(), 
[17:46:51.553]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.553]                   signalCondition(cond)
[17:46:51.553]                 }
[17:46:51.553]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.553]                 "immediateCondition"))) {
[17:46:51.553]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.553]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.553]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.553]                   if (TRUE && !signal) {
[17:46:51.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.553]                     {
[17:46:51.553]                       inherits <- base::inherits
[17:46:51.553]                       invokeRestart <- base::invokeRestart
[17:46:51.553]                       is.null <- base::is.null
[17:46:51.553]                       muffled <- FALSE
[17:46:51.553]                       if (inherits(cond, "message")) {
[17:46:51.553]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.553]                         if (muffled) 
[17:46:51.553]                           invokeRestart("muffleMessage")
[17:46:51.553]                       }
[17:46:51.553]                       else if (inherits(cond, "warning")) {
[17:46:51.553]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.553]                         if (muffled) 
[17:46:51.553]                           invokeRestart("muffleWarning")
[17:46:51.553]                       }
[17:46:51.553]                       else if (inherits(cond, "condition")) {
[17:46:51.553]                         if (!is.null(pattern)) {
[17:46:51.553]                           computeRestarts <- base::computeRestarts
[17:46:51.553]                           grepl <- base::grepl
[17:46:51.553]                           restarts <- computeRestarts(cond)
[17:46:51.553]                           for (restart in restarts) {
[17:46:51.553]                             name <- restart$name
[17:46:51.553]                             if (is.null(name)) 
[17:46:51.553]                               next
[17:46:51.553]                             if (!grepl(pattern, name)) 
[17:46:51.553]                               next
[17:46:51.553]                             invokeRestart(restart)
[17:46:51.553]                             muffled <- TRUE
[17:46:51.553]                             break
[17:46:51.553]                           }
[17:46:51.553]                         }
[17:46:51.553]                       }
[17:46:51.553]                       invisible(muffled)
[17:46:51.553]                     }
[17:46:51.553]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.553]                   }
[17:46:51.553]                 }
[17:46:51.553]                 else {
[17:46:51.553]                   if (TRUE) {
[17:46:51.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.553]                     {
[17:46:51.553]                       inherits <- base::inherits
[17:46:51.553]                       invokeRestart <- base::invokeRestart
[17:46:51.553]                       is.null <- base::is.null
[17:46:51.553]                       muffled <- FALSE
[17:46:51.553]                       if (inherits(cond, "message")) {
[17:46:51.553]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.553]                         if (muffled) 
[17:46:51.553]                           invokeRestart("muffleMessage")
[17:46:51.553]                       }
[17:46:51.553]                       else if (inherits(cond, "warning")) {
[17:46:51.553]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.553]                         if (muffled) 
[17:46:51.553]                           invokeRestart("muffleWarning")
[17:46:51.553]                       }
[17:46:51.553]                       else if (inherits(cond, "condition")) {
[17:46:51.553]                         if (!is.null(pattern)) {
[17:46:51.553]                           computeRestarts <- base::computeRestarts
[17:46:51.553]                           grepl <- base::grepl
[17:46:51.553]                           restarts <- computeRestarts(cond)
[17:46:51.553]                           for (restart in restarts) {
[17:46:51.553]                             name <- restart$name
[17:46:51.553]                             if (is.null(name)) 
[17:46:51.553]                               next
[17:46:51.553]                             if (!grepl(pattern, name)) 
[17:46:51.553]                               next
[17:46:51.553]                             invokeRestart(restart)
[17:46:51.553]                             muffled <- TRUE
[17:46:51.553]                             break
[17:46:51.553]                           }
[17:46:51.553]                         }
[17:46:51.553]                       }
[17:46:51.553]                       invisible(muffled)
[17:46:51.553]                     }
[17:46:51.553]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.553]                   }
[17:46:51.553]                 }
[17:46:51.553]             }
[17:46:51.553]         }))
[17:46:51.553]     }, error = function(ex) {
[17:46:51.553]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.553]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.553]                 ...future.rng), started = ...future.startTime, 
[17:46:51.553]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.553]             version = "1.8"), class = "FutureResult")
[17:46:51.553]     }, finally = {
[17:46:51.553]         if (!identical(...future.workdir, getwd())) 
[17:46:51.553]             setwd(...future.workdir)
[17:46:51.553]         {
[17:46:51.553]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.553]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.553]             }
[17:46:51.553]             base::options(...future.oldOptions)
[17:46:51.553]             if (.Platform$OS.type == "windows") {
[17:46:51.553]                 old_names <- names(...future.oldEnvVars)
[17:46:51.553]                 envs <- base::Sys.getenv()
[17:46:51.553]                 names <- names(envs)
[17:46:51.553]                 common <- intersect(names, old_names)
[17:46:51.553]                 added <- setdiff(names, old_names)
[17:46:51.553]                 removed <- setdiff(old_names, names)
[17:46:51.553]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.553]                   envs[common]]
[17:46:51.553]                 NAMES <- toupper(changed)
[17:46:51.553]                 args <- list()
[17:46:51.553]                 for (kk in seq_along(NAMES)) {
[17:46:51.553]                   name <- changed[[kk]]
[17:46:51.553]                   NAME <- NAMES[[kk]]
[17:46:51.553]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.553]                     next
[17:46:51.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.553]                 }
[17:46:51.553]                 NAMES <- toupper(added)
[17:46:51.553]                 for (kk in seq_along(NAMES)) {
[17:46:51.553]                   name <- added[[kk]]
[17:46:51.553]                   NAME <- NAMES[[kk]]
[17:46:51.553]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.553]                     next
[17:46:51.553]                   args[[name]] <- ""
[17:46:51.553]                 }
[17:46:51.553]                 NAMES <- toupper(removed)
[17:46:51.553]                 for (kk in seq_along(NAMES)) {
[17:46:51.553]                   name <- removed[[kk]]
[17:46:51.553]                   NAME <- NAMES[[kk]]
[17:46:51.553]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.553]                     next
[17:46:51.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.553]                 }
[17:46:51.553]                 if (length(args) > 0) 
[17:46:51.553]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.553]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.553]             }
[17:46:51.553]             else {
[17:46:51.553]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.553]             }
[17:46:51.553]             {
[17:46:51.553]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.553]                   0L) {
[17:46:51.553]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.553]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.553]                   base::options(opts)
[17:46:51.553]                 }
[17:46:51.553]                 {
[17:46:51.553]                   {
[17:46:51.553]                     NULL
[17:46:51.553]                     RNGkind("Mersenne-Twister")
[17:46:51.553]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:51.553]                       inherits = FALSE)
[17:46:51.553]                   }
[17:46:51.553]                   options(future.plan = NULL)
[17:46:51.553]                   if (is.na(NA_character_)) 
[17:46:51.553]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.553]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.553]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.553]                     .init = FALSE)
[17:46:51.553]                 }
[17:46:51.553]             }
[17:46:51.553]         }
[17:46:51.553]     })
[17:46:51.553]     if (TRUE) {
[17:46:51.553]         base::sink(type = "output", split = FALSE)
[17:46:51.553]         if (TRUE) {
[17:46:51.553]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.553]         }
[17:46:51.553]         else {
[17:46:51.553]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.553]         }
[17:46:51.553]         base::close(...future.stdout)
[17:46:51.553]         ...future.stdout <- NULL
[17:46:51.553]     }
[17:46:51.553]     ...future.result$conditions <- ...future.conditions
[17:46:51.553]     ...future.result$finished <- base::Sys.time()
[17:46:51.553]     ...future.result
[17:46:51.553] }
[17:46:51.555] assign_globals() ...
[17:46:51.555] List of 3
[17:46:51.555]  $ outer_function:function (x)  
[17:46:51.555]  $ map           :function (.x, .f, ...)  
[17:46:51.555]  $ inner_function:function (x)  
[17:46:51.555]  - attr(*, "where")=List of 3
[17:46:51.555]   ..$ outer_function:<environment: R_EmptyEnv> 
[17:46:51.555]   ..$ map           :<environment: R_EmptyEnv> 
[17:46:51.555]   ..$ inner_function:<environment: R_EmptyEnv> 
[17:46:51.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.555]  - attr(*, "resolved")= logi FALSE
[17:46:51.555]  - attr(*, "total_size")= num 7704
[17:46:51.555]  - attr(*, "already-done")= logi TRUE
[17:46:51.558] - reassign environment for ‘outer_function’
[17:46:51.558] - copied ‘outer_function’ to environment
[17:46:51.558] - reassign environment for ‘map’
[17:46:51.558] - copied ‘map’ to environment
[17:46:51.558] - reassign environment for ‘inner_function’
[17:46:51.558] - copied ‘inner_function’ to environment
[17:46:51.558] assign_globals() ... done
[17:46:51.559] plan(): Setting new future strategy stack:
[17:46:51.559] List of future strategies:
[17:46:51.559] 1. sequential:
[17:46:51.559]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.559]    - tweaked: FALSE
[17:46:51.559]    - call: NULL
[17:46:51.559] plan(): nbrOfWorkers() = 1
[17:46:51.566] plan(): Setting new future strategy stack:
[17:46:51.566] List of future strategies:
[17:46:51.566] 1. sequential:
[17:46:51.566]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.566]    - tweaked: FALSE
[17:46:51.566]    - call: plan(strategy)
[17:46:51.566] plan(): nbrOfWorkers() = 1
[17:46:51.566] SequentialFuture started (and completed)
[17:46:51.566] - Launch lazy future ... done
[17:46:51.566] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[17:46:51.568] getGlobalsAndPackages() ...
[17:46:51.568] Searching for globals...
[17:46:51.572] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:46:51.572] Searching for globals ... DONE
[17:46:51.572] Resolving globals: FALSE
[17:46:51.573] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:46:51.573] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:46:51.573] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:46:51.573] 
[17:46:51.573] getGlobalsAndPackages() ... DONE
[17:46:51.573] run() for ‘Future’ ...
[17:46:51.574] - state: ‘created’
[17:46:51.574] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:51.574] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:51.574] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:51.574]   - Field: ‘label’
[17:46:51.574]   - Field: ‘local’
[17:46:51.574]   - Field: ‘owner’
[17:46:51.574]   - Field: ‘envir’
[17:46:51.575]   - Field: ‘packages’
[17:46:51.575]   - Field: ‘gc’
[17:46:51.575]   - Field: ‘conditions’
[17:46:51.575]   - Field: ‘expr’
[17:46:51.575]   - Field: ‘uuid’
[17:46:51.575]   - Field: ‘seed’
[17:46:51.575]   - Field: ‘version’
[17:46:51.575]   - Field: ‘result’
[17:46:51.575]   - Field: ‘asynchronous’
[17:46:51.575]   - Field: ‘calls’
[17:46:51.575]   - Field: ‘globals’
[17:46:51.576]   - Field: ‘stdout’
[17:46:51.576]   - Field: ‘earlySignal’
[17:46:51.576]   - Field: ‘lazy’
[17:46:51.576]   - Field: ‘state’
[17:46:51.576] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:51.576] - Launch lazy future ...
[17:46:51.576] Packages needed by the future expression (n = 0): <none>
[17:46:51.576] Packages needed by future strategies (n = 0): <none>
[17:46:51.577] {
[17:46:51.577]     {
[17:46:51.577]         {
[17:46:51.577]             ...future.startTime <- base::Sys.time()
[17:46:51.577]             {
[17:46:51.577]                 {
[17:46:51.577]                   {
[17:46:51.577]                     base::local({
[17:46:51.577]                       has_future <- base::requireNamespace("future", 
[17:46:51.577]                         quietly = TRUE)
[17:46:51.577]                       if (has_future) {
[17:46:51.577]                         ns <- base::getNamespace("future")
[17:46:51.577]                         version <- ns[[".package"]][["version"]]
[17:46:51.577]                         if (is.null(version)) 
[17:46:51.577]                           version <- utils::packageVersion("future")
[17:46:51.577]                       }
[17:46:51.577]                       else {
[17:46:51.577]                         version <- NULL
[17:46:51.577]                       }
[17:46:51.577]                       if (!has_future || version < "1.8.0") {
[17:46:51.577]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.577]                           "", base::R.version$version.string), 
[17:46:51.577]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:51.577]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:51.577]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.577]                             "release", "version")], collapse = " "), 
[17:46:51.577]                           hostname = base::Sys.info()[["nodename"]])
[17:46:51.577]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.577]                           info)
[17:46:51.577]                         info <- base::paste(info, collapse = "; ")
[17:46:51.577]                         if (!has_future) {
[17:46:51.577]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.577]                             info)
[17:46:51.577]                         }
[17:46:51.577]                         else {
[17:46:51.577]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.577]                             info, version)
[17:46:51.577]                         }
[17:46:51.577]                         base::stop(msg)
[17:46:51.577]                       }
[17:46:51.577]                     })
[17:46:51.577]                   }
[17:46:51.577]                   ...future.strategy.old <- future::plan("list")
[17:46:51.577]                   options(future.plan = NULL)
[17:46:51.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.577]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.577]                 }
[17:46:51.577]                 ...future.workdir <- getwd()
[17:46:51.577]             }
[17:46:51.577]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.577]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.577]         }
[17:46:51.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.577]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.577]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.577]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.577]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.577]             base::names(...future.oldOptions))
[17:46:51.577]     }
[17:46:51.577]     if (FALSE) {
[17:46:51.577]     }
[17:46:51.577]     else {
[17:46:51.577]         if (TRUE) {
[17:46:51.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.577]                 open = "w")
[17:46:51.577]         }
[17:46:51.577]         else {
[17:46:51.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.577]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.577]         }
[17:46:51.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.577]             base::sink(type = "output", split = FALSE)
[17:46:51.577]             base::close(...future.stdout)
[17:46:51.577]         }, add = TRUE)
[17:46:51.577]     }
[17:46:51.577]     ...future.frame <- base::sys.nframe()
[17:46:51.577]     ...future.conditions <- base::list()
[17:46:51.577]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.577]     if (FALSE) {
[17:46:51.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.577]     }
[17:46:51.577]     ...future.result <- base::tryCatch({
[17:46:51.577]         base::withCallingHandlers({
[17:46:51.577]             ...future.value <- base::withVisible(base::local({
[17:46:51.577]                 outer_function(1L)
[17:46:51.577]             }))
[17:46:51.577]             future::FutureResult(value = ...future.value$value, 
[17:46:51.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.577]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.577]                     ...future.globalenv.names))
[17:46:51.577]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.577]         }, condition = base::local({
[17:46:51.577]             c <- base::c
[17:46:51.577]             inherits <- base::inherits
[17:46:51.577]             invokeRestart <- base::invokeRestart
[17:46:51.577]             length <- base::length
[17:46:51.577]             list <- base::list
[17:46:51.577]             seq.int <- base::seq.int
[17:46:51.577]             signalCondition <- base::signalCondition
[17:46:51.577]             sys.calls <- base::sys.calls
[17:46:51.577]             `[[` <- base::`[[`
[17:46:51.577]             `+` <- base::`+`
[17:46:51.577]             `<<-` <- base::`<<-`
[17:46:51.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.577]                   3L)]
[17:46:51.577]             }
[17:46:51.577]             function(cond) {
[17:46:51.577]                 is_error <- inherits(cond, "error")
[17:46:51.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.577]                   NULL)
[17:46:51.577]                 if (is_error) {
[17:46:51.577]                   sessionInformation <- function() {
[17:46:51.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.577]                       search = base::search(), system = base::Sys.info())
[17:46:51.577]                   }
[17:46:51.577]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.577]                     cond$call), session = sessionInformation(), 
[17:46:51.577]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.577]                   signalCondition(cond)
[17:46:51.577]                 }
[17:46:51.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.577]                 "immediateCondition"))) {
[17:46:51.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.577]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.577]                   if (TRUE && !signal) {
[17:46:51.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.577]                     {
[17:46:51.577]                       inherits <- base::inherits
[17:46:51.577]                       invokeRestart <- base::invokeRestart
[17:46:51.577]                       is.null <- base::is.null
[17:46:51.577]                       muffled <- FALSE
[17:46:51.577]                       if (inherits(cond, "message")) {
[17:46:51.577]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.577]                         if (muffled) 
[17:46:51.577]                           invokeRestart("muffleMessage")
[17:46:51.577]                       }
[17:46:51.577]                       else if (inherits(cond, "warning")) {
[17:46:51.577]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.577]                         if (muffled) 
[17:46:51.577]                           invokeRestart("muffleWarning")
[17:46:51.577]                       }
[17:46:51.577]                       else if (inherits(cond, "condition")) {
[17:46:51.577]                         if (!is.null(pattern)) {
[17:46:51.577]                           computeRestarts <- base::computeRestarts
[17:46:51.577]                           grepl <- base::grepl
[17:46:51.577]                           restarts <- computeRestarts(cond)
[17:46:51.577]                           for (restart in restarts) {
[17:46:51.577]                             name <- restart$name
[17:46:51.577]                             if (is.null(name)) 
[17:46:51.577]                               next
[17:46:51.577]                             if (!grepl(pattern, name)) 
[17:46:51.577]                               next
[17:46:51.577]                             invokeRestart(restart)
[17:46:51.577]                             muffled <- TRUE
[17:46:51.577]                             break
[17:46:51.577]                           }
[17:46:51.577]                         }
[17:46:51.577]                       }
[17:46:51.577]                       invisible(muffled)
[17:46:51.577]                     }
[17:46:51.577]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.577]                   }
[17:46:51.577]                 }
[17:46:51.577]                 else {
[17:46:51.577]                   if (TRUE) {
[17:46:51.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.577]                     {
[17:46:51.577]                       inherits <- base::inherits
[17:46:51.577]                       invokeRestart <- base::invokeRestart
[17:46:51.577]                       is.null <- base::is.null
[17:46:51.577]                       muffled <- FALSE
[17:46:51.577]                       if (inherits(cond, "message")) {
[17:46:51.577]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.577]                         if (muffled) 
[17:46:51.577]                           invokeRestart("muffleMessage")
[17:46:51.577]                       }
[17:46:51.577]                       else if (inherits(cond, "warning")) {
[17:46:51.577]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.577]                         if (muffled) 
[17:46:51.577]                           invokeRestart("muffleWarning")
[17:46:51.577]                       }
[17:46:51.577]                       else if (inherits(cond, "condition")) {
[17:46:51.577]                         if (!is.null(pattern)) {
[17:46:51.577]                           computeRestarts <- base::computeRestarts
[17:46:51.577]                           grepl <- base::grepl
[17:46:51.577]                           restarts <- computeRestarts(cond)
[17:46:51.577]                           for (restart in restarts) {
[17:46:51.577]                             name <- restart$name
[17:46:51.577]                             if (is.null(name)) 
[17:46:51.577]                               next
[17:46:51.577]                             if (!grepl(pattern, name)) 
[17:46:51.577]                               next
[17:46:51.577]                             invokeRestart(restart)
[17:46:51.577]                             muffled <- TRUE
[17:46:51.577]                             break
[17:46:51.577]                           }
[17:46:51.577]                         }
[17:46:51.577]                       }
[17:46:51.577]                       invisible(muffled)
[17:46:51.577]                     }
[17:46:51.577]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.577]                   }
[17:46:51.577]                 }
[17:46:51.577]             }
[17:46:51.577]         }))
[17:46:51.577]     }, error = function(ex) {
[17:46:51.577]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.577]                 ...future.rng), started = ...future.startTime, 
[17:46:51.577]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.577]             version = "1.8"), class = "FutureResult")
[17:46:51.577]     }, finally = {
[17:46:51.577]         if (!identical(...future.workdir, getwd())) 
[17:46:51.577]             setwd(...future.workdir)
[17:46:51.577]         {
[17:46:51.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.577]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.577]             }
[17:46:51.577]             base::options(...future.oldOptions)
[17:46:51.577]             if (.Platform$OS.type == "windows") {
[17:46:51.577]                 old_names <- names(...future.oldEnvVars)
[17:46:51.577]                 envs <- base::Sys.getenv()
[17:46:51.577]                 names <- names(envs)
[17:46:51.577]                 common <- intersect(names, old_names)
[17:46:51.577]                 added <- setdiff(names, old_names)
[17:46:51.577]                 removed <- setdiff(old_names, names)
[17:46:51.577]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.577]                   envs[common]]
[17:46:51.577]                 NAMES <- toupper(changed)
[17:46:51.577]                 args <- list()
[17:46:51.577]                 for (kk in seq_along(NAMES)) {
[17:46:51.577]                   name <- changed[[kk]]
[17:46:51.577]                   NAME <- NAMES[[kk]]
[17:46:51.577]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.577]                     next
[17:46:51.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.577]                 }
[17:46:51.577]                 NAMES <- toupper(added)
[17:46:51.577]                 for (kk in seq_along(NAMES)) {
[17:46:51.577]                   name <- added[[kk]]
[17:46:51.577]                   NAME <- NAMES[[kk]]
[17:46:51.577]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.577]                     next
[17:46:51.577]                   args[[name]] <- ""
[17:46:51.577]                 }
[17:46:51.577]                 NAMES <- toupper(removed)
[17:46:51.577]                 for (kk in seq_along(NAMES)) {
[17:46:51.577]                   name <- removed[[kk]]
[17:46:51.577]                   NAME <- NAMES[[kk]]
[17:46:51.577]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.577]                     next
[17:46:51.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.577]                 }
[17:46:51.577]                 if (length(args) > 0) 
[17:46:51.577]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.577]             }
[17:46:51.577]             else {
[17:46:51.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.577]             }
[17:46:51.577]             {
[17:46:51.577]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.577]                   0L) {
[17:46:51.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.577]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.577]                   base::options(opts)
[17:46:51.577]                 }
[17:46:51.577]                 {
[17:46:51.577]                   {
[17:46:51.577]                     NULL
[17:46:51.577]                     RNGkind("Mersenne-Twister")
[17:46:51.577]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:51.577]                       inherits = FALSE)
[17:46:51.577]                   }
[17:46:51.577]                   options(future.plan = NULL)
[17:46:51.577]                   if (is.na(NA_character_)) 
[17:46:51.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.577]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.577]                     .init = FALSE)
[17:46:51.577]                 }
[17:46:51.577]             }
[17:46:51.577]         }
[17:46:51.577]     })
[17:46:51.577]     if (TRUE) {
[17:46:51.577]         base::sink(type = "output", split = FALSE)
[17:46:51.577]         if (TRUE) {
[17:46:51.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.577]         }
[17:46:51.577]         else {
[17:46:51.577]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.577]         }
[17:46:51.577]         base::close(...future.stdout)
[17:46:51.577]         ...future.stdout <- NULL
[17:46:51.577]     }
[17:46:51.577]     ...future.result$conditions <- ...future.conditions
[17:46:51.577]     ...future.result$finished <- base::Sys.time()
[17:46:51.577]     ...future.result
[17:46:51.577] }
[17:46:51.578] assign_globals() ...
[17:46:51.578] List of 3
[17:46:51.578]  $ outer_function:function (x)  
[17:46:51.578]  $ map           :function (.x, .f, ...)  
[17:46:51.578]  $ inner_function:function (x)  
[17:46:51.578]  - attr(*, "where")=List of 3
[17:46:51.578]   ..$ outer_function:<environment: R_EmptyEnv> 
[17:46:51.578]   ..$ map           :<environment: R_EmptyEnv> 
[17:46:51.578]   ..$ inner_function:<environment: R_EmptyEnv> 
[17:46:51.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.578]  - attr(*, "resolved")= logi FALSE
[17:46:51.578]  - attr(*, "total_size")= num 7704
[17:46:51.578]  - attr(*, "already-done")= logi TRUE
[17:46:51.581] - reassign environment for ‘outer_function’
[17:46:51.581] - copied ‘outer_function’ to environment
[17:46:51.582] - reassign environment for ‘map’
[17:46:51.582] - copied ‘map’ to environment
[17:46:51.582] - reassign environment for ‘inner_function’
[17:46:51.582] - copied ‘inner_function’ to environment
[17:46:51.582] assign_globals() ... done
[17:46:51.582] plan(): Setting new future strategy stack:
[17:46:51.582] List of future strategies:
[17:46:51.582] 1. sequential:
[17:46:51.582]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.582]    - tweaked: FALSE
[17:46:51.582]    - call: NULL
[17:46:51.583] plan(): nbrOfWorkers() = 1
[17:46:51.584] plan(): Setting new future strategy stack:
[17:46:51.584] List of future strategies:
[17:46:51.584] 1. sequential:
[17:46:51.584]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.584]    - tweaked: FALSE
[17:46:51.584]    - call: plan(strategy)
[17:46:51.584] plan(): nbrOfWorkers() = 1
[17:46:51.584] SequentialFuture started (and completed)
[17:46:51.584] - Launch lazy future ... done
[17:46:51.584] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[17:46:51.596] plan(): Setting new future strategy stack:
[17:46:51.596] List of future strategies:
[17:46:51.596] 1. multicore:
[17:46:51.596]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:51.596]    - tweaked: FALSE
[17:46:51.596]    - call: plan(strategy)
[17:46:51.599] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[17:46:51.600] getGlobalsAndPackages() ...
[17:46:51.600] Searching for globals...
[17:46:51.601] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:51.601] Searching for globals ... DONE
[17:46:51.601] Resolving globals: FALSE
[17:46:51.602] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:51.602] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:51.602] - globals: [2] ‘weight’, ‘group’
[17:46:51.602] - packages: [1] ‘stats’
[17:46:51.603] getGlobalsAndPackages() ... DONE
[17:46:51.603] run() for ‘Future’ ...
[17:46:51.603] - state: ‘created’
[17:46:51.603] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:51.607] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:51.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:51.607]   - Field: ‘label’
[17:46:51.607]   - Field: ‘local’
[17:46:51.607]   - Field: ‘owner’
[17:46:51.607]   - Field: ‘envir’
[17:46:51.607]   - Field: ‘workers’
[17:46:51.607]   - Field: ‘packages’
[17:46:51.607]   - Field: ‘gc’
[17:46:51.607]   - Field: ‘job’
[17:46:51.608]   - Field: ‘conditions’
[17:46:51.608]   - Field: ‘expr’
[17:46:51.608]   - Field: ‘uuid’
[17:46:51.608]   - Field: ‘seed’
[17:46:51.608]   - Field: ‘version’
[17:46:51.608]   - Field: ‘result’
[17:46:51.608]   - Field: ‘asynchronous’
[17:46:51.608]   - Field: ‘calls’
[17:46:51.608]   - Field: ‘globals’
[17:46:51.608]   - Field: ‘stdout’
[17:46:51.608]   - Field: ‘earlySignal’
[17:46:51.609]   - Field: ‘lazy’
[17:46:51.609]   - Field: ‘state’
[17:46:51.609] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:51.609] - Launch lazy future ...
[17:46:51.610] Packages needed by the future expression (n = 1): ‘stats’
[17:46:51.610] Packages needed by future strategies (n = 0): <none>
[17:46:51.610] {
[17:46:51.610]     {
[17:46:51.610]         {
[17:46:51.610]             ...future.startTime <- base::Sys.time()
[17:46:51.610]             {
[17:46:51.610]                 {
[17:46:51.610]                   {
[17:46:51.610]                     {
[17:46:51.610]                       {
[17:46:51.610]                         base::local({
[17:46:51.610]                           has_future <- base::requireNamespace("future", 
[17:46:51.610]                             quietly = TRUE)
[17:46:51.610]                           if (has_future) {
[17:46:51.610]                             ns <- base::getNamespace("future")
[17:46:51.610]                             version <- ns[[".package"]][["version"]]
[17:46:51.610]                             if (is.null(version)) 
[17:46:51.610]                               version <- utils::packageVersion("future")
[17:46:51.610]                           }
[17:46:51.610]                           else {
[17:46:51.610]                             version <- NULL
[17:46:51.610]                           }
[17:46:51.610]                           if (!has_future || version < "1.8.0") {
[17:46:51.610]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.610]                               "", base::R.version$version.string), 
[17:46:51.610]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:51.610]                                 base::R.version$platform, 8 * 
[17:46:51.610]                                   base::.Machine$sizeof.pointer), 
[17:46:51.610]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.610]                                 "release", "version")], collapse = " "), 
[17:46:51.610]                               hostname = base::Sys.info()[["nodename"]])
[17:46:51.610]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.610]                               info)
[17:46:51.610]                             info <- base::paste(info, collapse = "; ")
[17:46:51.610]                             if (!has_future) {
[17:46:51.610]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.610]                                 info)
[17:46:51.610]                             }
[17:46:51.610]                             else {
[17:46:51.610]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.610]                                 info, version)
[17:46:51.610]                             }
[17:46:51.610]                             base::stop(msg)
[17:46:51.610]                           }
[17:46:51.610]                         })
[17:46:51.610]                       }
[17:46:51.610]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:51.610]                       base::options(mc.cores = 1L)
[17:46:51.610]                     }
[17:46:51.610]                     base::local({
[17:46:51.610]                       for (pkg in "stats") {
[17:46:51.610]                         base::loadNamespace(pkg)
[17:46:51.610]                         base::library(pkg, character.only = TRUE)
[17:46:51.610]                       }
[17:46:51.610]                     })
[17:46:51.610]                   }
[17:46:51.610]                   ...future.strategy.old <- future::plan("list")
[17:46:51.610]                   options(future.plan = NULL)
[17:46:51.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.610]                 }
[17:46:51.610]                 ...future.workdir <- getwd()
[17:46:51.610]             }
[17:46:51.610]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.610]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.610]         }
[17:46:51.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.610]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.610]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.610]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.610]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.610]             base::names(...future.oldOptions))
[17:46:51.610]     }
[17:46:51.610]     if (FALSE) {
[17:46:51.610]     }
[17:46:51.610]     else {
[17:46:51.610]         if (TRUE) {
[17:46:51.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.610]                 open = "w")
[17:46:51.610]         }
[17:46:51.610]         else {
[17:46:51.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.610]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.610]         }
[17:46:51.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.610]             base::sink(type = "output", split = FALSE)
[17:46:51.610]             base::close(...future.stdout)
[17:46:51.610]         }, add = TRUE)
[17:46:51.610]     }
[17:46:51.610]     ...future.frame <- base::sys.nframe()
[17:46:51.610]     ...future.conditions <- base::list()
[17:46:51.610]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.610]     if (FALSE) {
[17:46:51.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.610]     }
[17:46:51.610]     ...future.result <- base::tryCatch({
[17:46:51.610]         base::withCallingHandlers({
[17:46:51.610]             ...future.value <- base::withVisible(base::local({
[17:46:51.610]                 withCallingHandlers({
[17:46:51.610]                   {
[17:46:51.610]                     lm(weight ~ group - 1)
[17:46:51.610]                   }
[17:46:51.610]                 }, immediateCondition = function(cond) {
[17:46:51.610]                   save_rds <- function (object, pathname, ...) 
[17:46:51.610]                   {
[17:46:51.610]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:51.610]                     if (file_test("-f", pathname_tmp)) {
[17:46:51.610]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.610]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:51.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.610]                         fi_tmp[["mtime"]])
[17:46:51.610]                     }
[17:46:51.610]                     tryCatch({
[17:46:51.610]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:51.610]                     }, error = function(ex) {
[17:46:51.610]                       msg <- conditionMessage(ex)
[17:46:51.610]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.610]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:51.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.610]                         fi_tmp[["mtime"]], msg)
[17:46:51.610]                       ex$message <- msg
[17:46:51.610]                       stop(ex)
[17:46:51.610]                     })
[17:46:51.610]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:51.610]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:51.610]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:51.610]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.610]                       fi <- file.info(pathname)
[17:46:51.610]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:51.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.610]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:51.610]                         fi[["size"]], fi[["mtime"]])
[17:46:51.610]                       stop(msg)
[17:46:51.610]                     }
[17:46:51.610]                     invisible(pathname)
[17:46:51.610]                   }
[17:46:51.610]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:51.610]                     rootPath = tempdir()) 
[17:46:51.610]                   {
[17:46:51.610]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:51.610]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:51.610]                       tmpdir = path, fileext = ".rds")
[17:46:51.610]                     save_rds(obj, file)
[17:46:51.610]                   }
[17:46:51.610]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6A38RL/.future/immediateConditions")
[17:46:51.610]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.610]                   {
[17:46:51.610]                     inherits <- base::inherits
[17:46:51.610]                     invokeRestart <- base::invokeRestart
[17:46:51.610]                     is.null <- base::is.null
[17:46:51.610]                     muffled <- FALSE
[17:46:51.610]                     if (inherits(cond, "message")) {
[17:46:51.610]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:51.610]                       if (muffled) 
[17:46:51.610]                         invokeRestart("muffleMessage")
[17:46:51.610]                     }
[17:46:51.610]                     else if (inherits(cond, "warning")) {
[17:46:51.610]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:51.610]                       if (muffled) 
[17:46:51.610]                         invokeRestart("muffleWarning")
[17:46:51.610]                     }
[17:46:51.610]                     else if (inherits(cond, "condition")) {
[17:46:51.610]                       if (!is.null(pattern)) {
[17:46:51.610]                         computeRestarts <- base::computeRestarts
[17:46:51.610]                         grepl <- base::grepl
[17:46:51.610]                         restarts <- computeRestarts(cond)
[17:46:51.610]                         for (restart in restarts) {
[17:46:51.610]                           name <- restart$name
[17:46:51.610]                           if (is.null(name)) 
[17:46:51.610]                             next
[17:46:51.610]                           if (!grepl(pattern, name)) 
[17:46:51.610]                             next
[17:46:51.610]                           invokeRestart(restart)
[17:46:51.610]                           muffled <- TRUE
[17:46:51.610]                           break
[17:46:51.610]                         }
[17:46:51.610]                       }
[17:46:51.610]                     }
[17:46:51.610]                     invisible(muffled)
[17:46:51.610]                   }
[17:46:51.610]                   muffleCondition(cond)
[17:46:51.610]                 })
[17:46:51.610]             }))
[17:46:51.610]             future::FutureResult(value = ...future.value$value, 
[17:46:51.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.610]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.610]                     ...future.globalenv.names))
[17:46:51.610]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.610]         }, condition = base::local({
[17:46:51.610]             c <- base::c
[17:46:51.610]             inherits <- base::inherits
[17:46:51.610]             invokeRestart <- base::invokeRestart
[17:46:51.610]             length <- base::length
[17:46:51.610]             list <- base::list
[17:46:51.610]             seq.int <- base::seq.int
[17:46:51.610]             signalCondition <- base::signalCondition
[17:46:51.610]             sys.calls <- base::sys.calls
[17:46:51.610]             `[[` <- base::`[[`
[17:46:51.610]             `+` <- base::`+`
[17:46:51.610]             `<<-` <- base::`<<-`
[17:46:51.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.610]                   3L)]
[17:46:51.610]             }
[17:46:51.610]             function(cond) {
[17:46:51.610]                 is_error <- inherits(cond, "error")
[17:46:51.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.610]                   NULL)
[17:46:51.610]                 if (is_error) {
[17:46:51.610]                   sessionInformation <- function() {
[17:46:51.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.610]                       search = base::search(), system = base::Sys.info())
[17:46:51.610]                   }
[17:46:51.610]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.610]                     cond$call), session = sessionInformation(), 
[17:46:51.610]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.610]                   signalCondition(cond)
[17:46:51.610]                 }
[17:46:51.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.610]                 "immediateCondition"))) {
[17:46:51.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.610]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.610]                   if (TRUE && !signal) {
[17:46:51.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.610]                     {
[17:46:51.610]                       inherits <- base::inherits
[17:46:51.610]                       invokeRestart <- base::invokeRestart
[17:46:51.610]                       is.null <- base::is.null
[17:46:51.610]                       muffled <- FALSE
[17:46:51.610]                       if (inherits(cond, "message")) {
[17:46:51.610]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.610]                         if (muffled) 
[17:46:51.610]                           invokeRestart("muffleMessage")
[17:46:51.610]                       }
[17:46:51.610]                       else if (inherits(cond, "warning")) {
[17:46:51.610]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.610]                         if (muffled) 
[17:46:51.610]                           invokeRestart("muffleWarning")
[17:46:51.610]                       }
[17:46:51.610]                       else if (inherits(cond, "condition")) {
[17:46:51.610]                         if (!is.null(pattern)) {
[17:46:51.610]                           computeRestarts <- base::computeRestarts
[17:46:51.610]                           grepl <- base::grepl
[17:46:51.610]                           restarts <- computeRestarts(cond)
[17:46:51.610]                           for (restart in restarts) {
[17:46:51.610]                             name <- restart$name
[17:46:51.610]                             if (is.null(name)) 
[17:46:51.610]                               next
[17:46:51.610]                             if (!grepl(pattern, name)) 
[17:46:51.610]                               next
[17:46:51.610]                             invokeRestart(restart)
[17:46:51.610]                             muffled <- TRUE
[17:46:51.610]                             break
[17:46:51.610]                           }
[17:46:51.610]                         }
[17:46:51.610]                       }
[17:46:51.610]                       invisible(muffled)
[17:46:51.610]                     }
[17:46:51.610]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.610]                   }
[17:46:51.610]                 }
[17:46:51.610]                 else {
[17:46:51.610]                   if (TRUE) {
[17:46:51.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.610]                     {
[17:46:51.610]                       inherits <- base::inherits
[17:46:51.610]                       invokeRestart <- base::invokeRestart
[17:46:51.610]                       is.null <- base::is.null
[17:46:51.610]                       muffled <- FALSE
[17:46:51.610]                       if (inherits(cond, "message")) {
[17:46:51.610]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.610]                         if (muffled) 
[17:46:51.610]                           invokeRestart("muffleMessage")
[17:46:51.610]                       }
[17:46:51.610]                       else if (inherits(cond, "warning")) {
[17:46:51.610]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.610]                         if (muffled) 
[17:46:51.610]                           invokeRestart("muffleWarning")
[17:46:51.610]                       }
[17:46:51.610]                       else if (inherits(cond, "condition")) {
[17:46:51.610]                         if (!is.null(pattern)) {
[17:46:51.610]                           computeRestarts <- base::computeRestarts
[17:46:51.610]                           grepl <- base::grepl
[17:46:51.610]                           restarts <- computeRestarts(cond)
[17:46:51.610]                           for (restart in restarts) {
[17:46:51.610]                             name <- restart$name
[17:46:51.610]                             if (is.null(name)) 
[17:46:51.610]                               next
[17:46:51.610]                             if (!grepl(pattern, name)) 
[17:46:51.610]                               next
[17:46:51.610]                             invokeRestart(restart)
[17:46:51.610]                             muffled <- TRUE
[17:46:51.610]                             break
[17:46:51.610]                           }
[17:46:51.610]                         }
[17:46:51.610]                       }
[17:46:51.610]                       invisible(muffled)
[17:46:51.610]                     }
[17:46:51.610]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.610]                   }
[17:46:51.610]                 }
[17:46:51.610]             }
[17:46:51.610]         }))
[17:46:51.610]     }, error = function(ex) {
[17:46:51.610]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.610]                 ...future.rng), started = ...future.startTime, 
[17:46:51.610]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.610]             version = "1.8"), class = "FutureResult")
[17:46:51.610]     }, finally = {
[17:46:51.610]         if (!identical(...future.workdir, getwd())) 
[17:46:51.610]             setwd(...future.workdir)
[17:46:51.610]         {
[17:46:51.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.610]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.610]             }
[17:46:51.610]             base::options(...future.oldOptions)
[17:46:51.610]             if (.Platform$OS.type == "windows") {
[17:46:51.610]                 old_names <- names(...future.oldEnvVars)
[17:46:51.610]                 envs <- base::Sys.getenv()
[17:46:51.610]                 names <- names(envs)
[17:46:51.610]                 common <- intersect(names, old_names)
[17:46:51.610]                 added <- setdiff(names, old_names)
[17:46:51.610]                 removed <- setdiff(old_names, names)
[17:46:51.610]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.610]                   envs[common]]
[17:46:51.610]                 NAMES <- toupper(changed)
[17:46:51.610]                 args <- list()
[17:46:51.610]                 for (kk in seq_along(NAMES)) {
[17:46:51.610]                   name <- changed[[kk]]
[17:46:51.610]                   NAME <- NAMES[[kk]]
[17:46:51.610]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.610]                     next
[17:46:51.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.610]                 }
[17:46:51.610]                 NAMES <- toupper(added)
[17:46:51.610]                 for (kk in seq_along(NAMES)) {
[17:46:51.610]                   name <- added[[kk]]
[17:46:51.610]                   NAME <- NAMES[[kk]]
[17:46:51.610]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.610]                     next
[17:46:51.610]                   args[[name]] <- ""
[17:46:51.610]                 }
[17:46:51.610]                 NAMES <- toupper(removed)
[17:46:51.610]                 for (kk in seq_along(NAMES)) {
[17:46:51.610]                   name <- removed[[kk]]
[17:46:51.610]                   NAME <- NAMES[[kk]]
[17:46:51.610]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.610]                     next
[17:46:51.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.610]                 }
[17:46:51.610]                 if (length(args) > 0) 
[17:46:51.610]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.610]             }
[17:46:51.610]             else {
[17:46:51.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.610]             }
[17:46:51.610]             {
[17:46:51.610]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.610]                   0L) {
[17:46:51.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.610]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.610]                   base::options(opts)
[17:46:51.610]                 }
[17:46:51.610]                 {
[17:46:51.610]                   {
[17:46:51.610]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:51.610]                     NULL
[17:46:51.610]                   }
[17:46:51.610]                   options(future.plan = NULL)
[17:46:51.610]                   if (is.na(NA_character_)) 
[17:46:51.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.610]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.610]                     .init = FALSE)
[17:46:51.610]                 }
[17:46:51.610]             }
[17:46:51.610]         }
[17:46:51.610]     })
[17:46:51.610]     if (TRUE) {
[17:46:51.610]         base::sink(type = "output", split = FALSE)
[17:46:51.610]         if (TRUE) {
[17:46:51.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.610]         }
[17:46:51.610]         else {
[17:46:51.610]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.610]         }
[17:46:51.610]         base::close(...future.stdout)
[17:46:51.610]         ...future.stdout <- NULL
[17:46:51.610]     }
[17:46:51.610]     ...future.result$conditions <- ...future.conditions
[17:46:51.610]     ...future.result$finished <- base::Sys.time()
[17:46:51.610]     ...future.result
[17:46:51.610] }
[17:46:51.613] assign_globals() ...
[17:46:51.613] List of 2
[17:46:51.613]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:46:51.613]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:46:51.613]  - attr(*, "where")=List of 2
[17:46:51.613]   ..$ weight:<environment: R_EmptyEnv> 
[17:46:51.613]   ..$ group :<environment: R_EmptyEnv> 
[17:46:51.613]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.613]  - attr(*, "resolved")= logi FALSE
[17:46:51.613]  - attr(*, "total_size")= num 896
[17:46:51.613]  - attr(*, "already-done")= logi TRUE
[17:46:51.616] - copied ‘weight’ to environment
[17:46:51.616] - copied ‘group’ to environment
[17:46:51.616] assign_globals() ... done
[17:46:51.616] requestCore(): workers = 2
[17:46:51.623] MulticoreFuture started
[17:46:51.624] - Launch lazy future ... done
[17:46:51.624] run() for ‘MulticoreFuture’ ... done
[17:46:51.624] plan(): Setting new future strategy stack:
[17:46:51.625] result() for MulticoreFuture ...
[17:46:51.625] List of future strategies:
[17:46:51.625] 1. sequential:
[17:46:51.625]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.625]    - tweaked: FALSE
[17:46:51.625]    - call: NULL
[17:46:51.626] plan(): nbrOfWorkers() = 1
[17:46:51.629] plan(): Setting new future strategy stack:
[17:46:51.630] List of future strategies:
[17:46:51.630] 1. multicore:
[17:46:51.630]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:51.630]    - tweaked: FALSE
[17:46:51.630]    - call: plan(strategy)
[17:46:51.634] plan(): nbrOfWorkers() = 2
[17:46:51.640] result() for MulticoreFuture ...
[17:46:51.640] result() for MulticoreFuture ... done
[17:46:51.640] result() for MulticoreFuture ... done
[17:46:51.640] result() for MulticoreFuture ...
[17:46:51.640] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:46:51.643] getGlobalsAndPackages() ...
[17:46:51.643] Searching for globals...
[17:46:51.645] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:51.645] Searching for globals ... DONE
[17:46:51.645] Resolving globals: FALSE
[17:46:51.645] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:51.646] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:51.646] - globals: [2] ‘weight’, ‘group’
[17:46:51.646] - packages: [1] ‘stats’
[17:46:51.646] getGlobalsAndPackages() ... DONE
[17:46:51.647] run() for ‘Future’ ...
[17:46:51.647] - state: ‘created’
[17:46:51.647] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:51.651] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:51.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:51.651]   - Field: ‘label’
[17:46:51.651]   - Field: ‘local’
[17:46:51.651]   - Field: ‘owner’
[17:46:51.652]   - Field: ‘envir’
[17:46:51.652]   - Field: ‘workers’
[17:46:51.652]   - Field: ‘packages’
[17:46:51.652]   - Field: ‘gc’
[17:46:51.652]   - Field: ‘job’
[17:46:51.652]   - Field: ‘conditions’
[17:46:51.652]   - Field: ‘expr’
[17:46:51.652]   - Field: ‘uuid’
[17:46:51.652]   - Field: ‘seed’
[17:46:51.652]   - Field: ‘version’
[17:46:51.653]   - Field: ‘result’
[17:46:51.653]   - Field: ‘asynchronous’
[17:46:51.653]   - Field: ‘calls’
[17:46:51.653]   - Field: ‘globals’
[17:46:51.653]   - Field: ‘stdout’
[17:46:51.653]   - Field: ‘earlySignal’
[17:46:51.653]   - Field: ‘lazy’
[17:46:51.653]   - Field: ‘state’
[17:46:51.653] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:51.654] - Launch lazy future ...
[17:46:51.654] Packages needed by the future expression (n = 1): ‘stats’
[17:46:51.654] Packages needed by future strategies (n = 0): <none>
[17:46:51.655] {
[17:46:51.655]     {
[17:46:51.655]         {
[17:46:51.655]             ...future.startTime <- base::Sys.time()
[17:46:51.655]             {
[17:46:51.655]                 {
[17:46:51.655]                   {
[17:46:51.655]                     {
[17:46:51.655]                       {
[17:46:51.655]                         base::local({
[17:46:51.655]                           has_future <- base::requireNamespace("future", 
[17:46:51.655]                             quietly = TRUE)
[17:46:51.655]                           if (has_future) {
[17:46:51.655]                             ns <- base::getNamespace("future")
[17:46:51.655]                             version <- ns[[".package"]][["version"]]
[17:46:51.655]                             if (is.null(version)) 
[17:46:51.655]                               version <- utils::packageVersion("future")
[17:46:51.655]                           }
[17:46:51.655]                           else {
[17:46:51.655]                             version <- NULL
[17:46:51.655]                           }
[17:46:51.655]                           if (!has_future || version < "1.8.0") {
[17:46:51.655]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.655]                               "", base::R.version$version.string), 
[17:46:51.655]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:51.655]                                 base::R.version$platform, 8 * 
[17:46:51.655]                                   base::.Machine$sizeof.pointer), 
[17:46:51.655]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.655]                                 "release", "version")], collapse = " "), 
[17:46:51.655]                               hostname = base::Sys.info()[["nodename"]])
[17:46:51.655]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.655]                               info)
[17:46:51.655]                             info <- base::paste(info, collapse = "; ")
[17:46:51.655]                             if (!has_future) {
[17:46:51.655]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.655]                                 info)
[17:46:51.655]                             }
[17:46:51.655]                             else {
[17:46:51.655]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.655]                                 info, version)
[17:46:51.655]                             }
[17:46:51.655]                             base::stop(msg)
[17:46:51.655]                           }
[17:46:51.655]                         })
[17:46:51.655]                       }
[17:46:51.655]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:51.655]                       base::options(mc.cores = 1L)
[17:46:51.655]                     }
[17:46:51.655]                     base::local({
[17:46:51.655]                       for (pkg in "stats") {
[17:46:51.655]                         base::loadNamespace(pkg)
[17:46:51.655]                         base::library(pkg, character.only = TRUE)
[17:46:51.655]                       }
[17:46:51.655]                     })
[17:46:51.655]                   }
[17:46:51.655]                   ...future.strategy.old <- future::plan("list")
[17:46:51.655]                   options(future.plan = NULL)
[17:46:51.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.655]                 }
[17:46:51.655]                 ...future.workdir <- getwd()
[17:46:51.655]             }
[17:46:51.655]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.655]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.655]         }
[17:46:51.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.655]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.655]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.655]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.655]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.655]             base::names(...future.oldOptions))
[17:46:51.655]     }
[17:46:51.655]     if (FALSE) {
[17:46:51.655]     }
[17:46:51.655]     else {
[17:46:51.655]         if (TRUE) {
[17:46:51.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.655]                 open = "w")
[17:46:51.655]         }
[17:46:51.655]         else {
[17:46:51.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.655]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.655]         }
[17:46:51.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.655]             base::sink(type = "output", split = FALSE)
[17:46:51.655]             base::close(...future.stdout)
[17:46:51.655]         }, add = TRUE)
[17:46:51.655]     }
[17:46:51.655]     ...future.frame <- base::sys.nframe()
[17:46:51.655]     ...future.conditions <- base::list()
[17:46:51.655]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.655]     if (FALSE) {
[17:46:51.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.655]     }
[17:46:51.655]     ...future.result <- base::tryCatch({
[17:46:51.655]         base::withCallingHandlers({
[17:46:51.655]             ...future.value <- base::withVisible(base::local({
[17:46:51.655]                 withCallingHandlers({
[17:46:51.655]                   {
[17:46:51.655]                     lm(weight ~ group - 1)
[17:46:51.655]                   }
[17:46:51.655]                 }, immediateCondition = function(cond) {
[17:46:51.655]                   save_rds <- function (object, pathname, ...) 
[17:46:51.655]                   {
[17:46:51.655]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:51.655]                     if (file_test("-f", pathname_tmp)) {
[17:46:51.655]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.655]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:51.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.655]                         fi_tmp[["mtime"]])
[17:46:51.655]                     }
[17:46:51.655]                     tryCatch({
[17:46:51.655]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:51.655]                     }, error = function(ex) {
[17:46:51.655]                       msg <- conditionMessage(ex)
[17:46:51.655]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.655]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:51.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.655]                         fi_tmp[["mtime"]], msg)
[17:46:51.655]                       ex$message <- msg
[17:46:51.655]                       stop(ex)
[17:46:51.655]                     })
[17:46:51.655]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:51.655]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:51.655]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:51.655]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.655]                       fi <- file.info(pathname)
[17:46:51.655]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:51.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.655]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:51.655]                         fi[["size"]], fi[["mtime"]])
[17:46:51.655]                       stop(msg)
[17:46:51.655]                     }
[17:46:51.655]                     invisible(pathname)
[17:46:51.655]                   }
[17:46:51.655]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:51.655]                     rootPath = tempdir()) 
[17:46:51.655]                   {
[17:46:51.655]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:51.655]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:51.655]                       tmpdir = path, fileext = ".rds")
[17:46:51.655]                     save_rds(obj, file)
[17:46:51.655]                   }
[17:46:51.655]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6A38RL/.future/immediateConditions")
[17:46:51.655]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.655]                   {
[17:46:51.655]                     inherits <- base::inherits
[17:46:51.655]                     invokeRestart <- base::invokeRestart
[17:46:51.655]                     is.null <- base::is.null
[17:46:51.655]                     muffled <- FALSE
[17:46:51.655]                     if (inherits(cond, "message")) {
[17:46:51.655]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:51.655]                       if (muffled) 
[17:46:51.655]                         invokeRestart("muffleMessage")
[17:46:51.655]                     }
[17:46:51.655]                     else if (inherits(cond, "warning")) {
[17:46:51.655]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:51.655]                       if (muffled) 
[17:46:51.655]                         invokeRestart("muffleWarning")
[17:46:51.655]                     }
[17:46:51.655]                     else if (inherits(cond, "condition")) {
[17:46:51.655]                       if (!is.null(pattern)) {
[17:46:51.655]                         computeRestarts <- base::computeRestarts
[17:46:51.655]                         grepl <- base::grepl
[17:46:51.655]                         restarts <- computeRestarts(cond)
[17:46:51.655]                         for (restart in restarts) {
[17:46:51.655]                           name <- restart$name
[17:46:51.655]                           if (is.null(name)) 
[17:46:51.655]                             next
[17:46:51.655]                           if (!grepl(pattern, name)) 
[17:46:51.655]                             next
[17:46:51.655]                           invokeRestart(restart)
[17:46:51.655]                           muffled <- TRUE
[17:46:51.655]                           break
[17:46:51.655]                         }
[17:46:51.655]                       }
[17:46:51.655]                     }
[17:46:51.655]                     invisible(muffled)
[17:46:51.655]                   }
[17:46:51.655]                   muffleCondition(cond)
[17:46:51.655]                 })
[17:46:51.655]             }))
[17:46:51.655]             future::FutureResult(value = ...future.value$value, 
[17:46:51.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.655]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.655]                     ...future.globalenv.names))
[17:46:51.655]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.655]         }, condition = base::local({
[17:46:51.655]             c <- base::c
[17:46:51.655]             inherits <- base::inherits
[17:46:51.655]             invokeRestart <- base::invokeRestart
[17:46:51.655]             length <- base::length
[17:46:51.655]             list <- base::list
[17:46:51.655]             seq.int <- base::seq.int
[17:46:51.655]             signalCondition <- base::signalCondition
[17:46:51.655]             sys.calls <- base::sys.calls
[17:46:51.655]             `[[` <- base::`[[`
[17:46:51.655]             `+` <- base::`+`
[17:46:51.655]             `<<-` <- base::`<<-`
[17:46:51.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.655]                   3L)]
[17:46:51.655]             }
[17:46:51.655]             function(cond) {
[17:46:51.655]                 is_error <- inherits(cond, "error")
[17:46:51.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.655]                   NULL)
[17:46:51.655]                 if (is_error) {
[17:46:51.655]                   sessionInformation <- function() {
[17:46:51.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.655]                       search = base::search(), system = base::Sys.info())
[17:46:51.655]                   }
[17:46:51.655]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.655]                     cond$call), session = sessionInformation(), 
[17:46:51.655]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.655]                   signalCondition(cond)
[17:46:51.655]                 }
[17:46:51.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.655]                 "immediateCondition"))) {
[17:46:51.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.655]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.655]                   if (TRUE && !signal) {
[17:46:51.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.655]                     {
[17:46:51.655]                       inherits <- base::inherits
[17:46:51.655]                       invokeRestart <- base::invokeRestart
[17:46:51.655]                       is.null <- base::is.null
[17:46:51.655]                       muffled <- FALSE
[17:46:51.655]                       if (inherits(cond, "message")) {
[17:46:51.655]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.655]                         if (muffled) 
[17:46:51.655]                           invokeRestart("muffleMessage")
[17:46:51.655]                       }
[17:46:51.655]                       else if (inherits(cond, "warning")) {
[17:46:51.655]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.655]                         if (muffled) 
[17:46:51.655]                           invokeRestart("muffleWarning")
[17:46:51.655]                       }
[17:46:51.655]                       else if (inherits(cond, "condition")) {
[17:46:51.655]                         if (!is.null(pattern)) {
[17:46:51.655]                           computeRestarts <- base::computeRestarts
[17:46:51.655]                           grepl <- base::grepl
[17:46:51.655]                           restarts <- computeRestarts(cond)
[17:46:51.655]                           for (restart in restarts) {
[17:46:51.655]                             name <- restart$name
[17:46:51.655]                             if (is.null(name)) 
[17:46:51.655]                               next
[17:46:51.655]                             if (!grepl(pattern, name)) 
[17:46:51.655]                               next
[17:46:51.655]                             invokeRestart(restart)
[17:46:51.655]                             muffled <- TRUE
[17:46:51.655]                             break
[17:46:51.655]                           }
[17:46:51.655]                         }
[17:46:51.655]                       }
[17:46:51.655]                       invisible(muffled)
[17:46:51.655]                     }
[17:46:51.655]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.655]                   }
[17:46:51.655]                 }
[17:46:51.655]                 else {
[17:46:51.655]                   if (TRUE) {
[17:46:51.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.655]                     {
[17:46:51.655]                       inherits <- base::inherits
[17:46:51.655]                       invokeRestart <- base::invokeRestart
[17:46:51.655]                       is.null <- base::is.null
[17:46:51.655]                       muffled <- FALSE
[17:46:51.655]                       if (inherits(cond, "message")) {
[17:46:51.655]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.655]                         if (muffled) 
[17:46:51.655]                           invokeRestart("muffleMessage")
[17:46:51.655]                       }
[17:46:51.655]                       else if (inherits(cond, "warning")) {
[17:46:51.655]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.655]                         if (muffled) 
[17:46:51.655]                           invokeRestart("muffleWarning")
[17:46:51.655]                       }
[17:46:51.655]                       else if (inherits(cond, "condition")) {
[17:46:51.655]                         if (!is.null(pattern)) {
[17:46:51.655]                           computeRestarts <- base::computeRestarts
[17:46:51.655]                           grepl <- base::grepl
[17:46:51.655]                           restarts <- computeRestarts(cond)
[17:46:51.655]                           for (restart in restarts) {
[17:46:51.655]                             name <- restart$name
[17:46:51.655]                             if (is.null(name)) 
[17:46:51.655]                               next
[17:46:51.655]                             if (!grepl(pattern, name)) 
[17:46:51.655]                               next
[17:46:51.655]                             invokeRestart(restart)
[17:46:51.655]                             muffled <- TRUE
[17:46:51.655]                             break
[17:46:51.655]                           }
[17:46:51.655]                         }
[17:46:51.655]                       }
[17:46:51.655]                       invisible(muffled)
[17:46:51.655]                     }
[17:46:51.655]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.655]                   }
[17:46:51.655]                 }
[17:46:51.655]             }
[17:46:51.655]         }))
[17:46:51.655]     }, error = function(ex) {
[17:46:51.655]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.655]                 ...future.rng), started = ...future.startTime, 
[17:46:51.655]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.655]             version = "1.8"), class = "FutureResult")
[17:46:51.655]     }, finally = {
[17:46:51.655]         if (!identical(...future.workdir, getwd())) 
[17:46:51.655]             setwd(...future.workdir)
[17:46:51.655]         {
[17:46:51.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.655]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.655]             }
[17:46:51.655]             base::options(...future.oldOptions)
[17:46:51.655]             if (.Platform$OS.type == "windows") {
[17:46:51.655]                 old_names <- names(...future.oldEnvVars)
[17:46:51.655]                 envs <- base::Sys.getenv()
[17:46:51.655]                 names <- names(envs)
[17:46:51.655]                 common <- intersect(names, old_names)
[17:46:51.655]                 added <- setdiff(names, old_names)
[17:46:51.655]                 removed <- setdiff(old_names, names)
[17:46:51.655]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.655]                   envs[common]]
[17:46:51.655]                 NAMES <- toupper(changed)
[17:46:51.655]                 args <- list()
[17:46:51.655]                 for (kk in seq_along(NAMES)) {
[17:46:51.655]                   name <- changed[[kk]]
[17:46:51.655]                   NAME <- NAMES[[kk]]
[17:46:51.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.655]                     next
[17:46:51.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.655]                 }
[17:46:51.655]                 NAMES <- toupper(added)
[17:46:51.655]                 for (kk in seq_along(NAMES)) {
[17:46:51.655]                   name <- added[[kk]]
[17:46:51.655]                   NAME <- NAMES[[kk]]
[17:46:51.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.655]                     next
[17:46:51.655]                   args[[name]] <- ""
[17:46:51.655]                 }
[17:46:51.655]                 NAMES <- toupper(removed)
[17:46:51.655]                 for (kk in seq_along(NAMES)) {
[17:46:51.655]                   name <- removed[[kk]]
[17:46:51.655]                   NAME <- NAMES[[kk]]
[17:46:51.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.655]                     next
[17:46:51.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.655]                 }
[17:46:51.655]                 if (length(args) > 0) 
[17:46:51.655]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.655]             }
[17:46:51.655]             else {
[17:46:51.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.655]             }
[17:46:51.655]             {
[17:46:51.655]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.655]                   0L) {
[17:46:51.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.655]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.655]                   base::options(opts)
[17:46:51.655]                 }
[17:46:51.655]                 {
[17:46:51.655]                   {
[17:46:51.655]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:51.655]                     NULL
[17:46:51.655]                   }
[17:46:51.655]                   options(future.plan = NULL)
[17:46:51.655]                   if (is.na(NA_character_)) 
[17:46:51.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.655]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.655]                     .init = FALSE)
[17:46:51.655]                 }
[17:46:51.655]             }
[17:46:51.655]         }
[17:46:51.655]     })
[17:46:51.655]     if (TRUE) {
[17:46:51.655]         base::sink(type = "output", split = FALSE)
[17:46:51.655]         if (TRUE) {
[17:46:51.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.655]         }
[17:46:51.655]         else {
[17:46:51.655]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.655]         }
[17:46:51.655]         base::close(...future.stdout)
[17:46:51.655]         ...future.stdout <- NULL
[17:46:51.655]     }
[17:46:51.655]     ...future.result$conditions <- ...future.conditions
[17:46:51.655]     ...future.result$finished <- base::Sys.time()
[17:46:51.655]     ...future.result
[17:46:51.655] }
[17:46:51.657] assign_globals() ...
[17:46:51.657] List of 2
[17:46:51.657]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:46:51.657]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:46:51.657]  - attr(*, "where")=List of 2
[17:46:51.657]   ..$ weight:<environment: R_EmptyEnv> 
[17:46:51.657]   ..$ group :<environment: R_EmptyEnv> 
[17:46:51.657]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.657]  - attr(*, "resolved")= logi FALSE
[17:46:51.657]  - attr(*, "total_size")= num 896
[17:46:51.657]  - attr(*, "already-done")= logi TRUE
[17:46:51.661] - copied ‘weight’ to environment
[17:46:51.661] - copied ‘group’ to environment
[17:46:51.661] assign_globals() ... done
[17:46:51.661] requestCore(): workers = 2
[17:46:51.663] MulticoreFuture started
[17:46:51.663] - Launch lazy future ... done
[17:46:51.664] run() for ‘MulticoreFuture’ ... done
[17:46:51.664] result() for MulticoreFuture ...
[17:46:51.664] plan(): Setting new future strategy stack:
[17:46:51.665] List of future strategies:
[17:46:51.665] 1. sequential:
[17:46:51.665]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.665]    - tweaked: FALSE
[17:46:51.665]    - call: NULL
[17:46:51.666] plan(): nbrOfWorkers() = 1
[17:46:51.669] plan(): Setting new future strategy stack:
[17:46:51.669] List of future strategies:
[17:46:51.669] 1. multicore:
[17:46:51.669]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:51.669]    - tweaked: FALSE
[17:46:51.669]    - call: plan(strategy)
[17:46:51.679] plan(): nbrOfWorkers() = 2
[17:46:51.681] result() for MulticoreFuture ...
[17:46:51.682] result() for MulticoreFuture ... done
[17:46:51.682] result() for MulticoreFuture ... done
[17:46:51.682] result() for MulticoreFuture ...
[17:46:51.682] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:46:51.687] getGlobalsAndPackages() ...
[17:46:51.687] Searching for globals...
[17:46:51.690] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:51.690] Searching for globals ... DONE
[17:46:51.690] Resolving globals: FALSE
[17:46:51.691] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:51.691] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:51.691] - globals: [2] ‘weight’, ‘group’
[17:46:51.691] - packages: [1] ‘stats’
[17:46:51.692] getGlobalsAndPackages() ... DONE
[17:46:51.692] run() for ‘Future’ ...
[17:46:51.692] - state: ‘created’
[17:46:51.692] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:51.696] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:51.696] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:51.696]   - Field: ‘label’
[17:46:51.697]   - Field: ‘local’
[17:46:51.697]   - Field: ‘owner’
[17:46:51.697]   - Field: ‘envir’
[17:46:51.697]   - Field: ‘workers’
[17:46:51.697]   - Field: ‘packages’
[17:46:51.697]   - Field: ‘gc’
[17:46:51.697]   - Field: ‘job’
[17:46:51.697]   - Field: ‘conditions’
[17:46:51.698]   - Field: ‘expr’
[17:46:51.698]   - Field: ‘uuid’
[17:46:51.698]   - Field: ‘seed’
[17:46:51.698]   - Field: ‘version’
[17:46:51.698]   - Field: ‘result’
[17:46:51.698]   - Field: ‘asynchronous’
[17:46:51.698]   - Field: ‘calls’
[17:46:51.698]   - Field: ‘globals’
[17:46:51.698]   - Field: ‘stdout’
[17:46:51.699]   - Field: ‘earlySignal’
[17:46:51.699]   - Field: ‘lazy’
[17:46:51.699]   - Field: ‘state’
[17:46:51.699] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:51.699] - Launch lazy future ...
[17:46:51.699] Packages needed by the future expression (n = 1): ‘stats’
[17:46:51.700] Packages needed by future strategies (n = 0): <none>
[17:46:51.700] {
[17:46:51.700]     {
[17:46:51.700]         {
[17:46:51.700]             ...future.startTime <- base::Sys.time()
[17:46:51.700]             {
[17:46:51.700]                 {
[17:46:51.700]                   {
[17:46:51.700]                     {
[17:46:51.700]                       {
[17:46:51.700]                         base::local({
[17:46:51.700]                           has_future <- base::requireNamespace("future", 
[17:46:51.700]                             quietly = TRUE)
[17:46:51.700]                           if (has_future) {
[17:46:51.700]                             ns <- base::getNamespace("future")
[17:46:51.700]                             version <- ns[[".package"]][["version"]]
[17:46:51.700]                             if (is.null(version)) 
[17:46:51.700]                               version <- utils::packageVersion("future")
[17:46:51.700]                           }
[17:46:51.700]                           else {
[17:46:51.700]                             version <- NULL
[17:46:51.700]                           }
[17:46:51.700]                           if (!has_future || version < "1.8.0") {
[17:46:51.700]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.700]                               "", base::R.version$version.string), 
[17:46:51.700]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:51.700]                                 base::R.version$platform, 8 * 
[17:46:51.700]                                   base::.Machine$sizeof.pointer), 
[17:46:51.700]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.700]                                 "release", "version")], collapse = " "), 
[17:46:51.700]                               hostname = base::Sys.info()[["nodename"]])
[17:46:51.700]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.700]                               info)
[17:46:51.700]                             info <- base::paste(info, collapse = "; ")
[17:46:51.700]                             if (!has_future) {
[17:46:51.700]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.700]                                 info)
[17:46:51.700]                             }
[17:46:51.700]                             else {
[17:46:51.700]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.700]                                 info, version)
[17:46:51.700]                             }
[17:46:51.700]                             base::stop(msg)
[17:46:51.700]                           }
[17:46:51.700]                         })
[17:46:51.700]                       }
[17:46:51.700]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:51.700]                       base::options(mc.cores = 1L)
[17:46:51.700]                     }
[17:46:51.700]                     base::local({
[17:46:51.700]                       for (pkg in "stats") {
[17:46:51.700]                         base::loadNamespace(pkg)
[17:46:51.700]                         base::library(pkg, character.only = TRUE)
[17:46:51.700]                       }
[17:46:51.700]                     })
[17:46:51.700]                   }
[17:46:51.700]                   ...future.strategy.old <- future::plan("list")
[17:46:51.700]                   options(future.plan = NULL)
[17:46:51.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.700]                 }
[17:46:51.700]                 ...future.workdir <- getwd()
[17:46:51.700]             }
[17:46:51.700]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.700]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.700]         }
[17:46:51.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.700]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.700]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.700]             base::names(...future.oldOptions))
[17:46:51.700]     }
[17:46:51.700]     if (FALSE) {
[17:46:51.700]     }
[17:46:51.700]     else {
[17:46:51.700]         if (TRUE) {
[17:46:51.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.700]                 open = "w")
[17:46:51.700]         }
[17:46:51.700]         else {
[17:46:51.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.700]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.700]         }
[17:46:51.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.700]             base::sink(type = "output", split = FALSE)
[17:46:51.700]             base::close(...future.stdout)
[17:46:51.700]         }, add = TRUE)
[17:46:51.700]     }
[17:46:51.700]     ...future.frame <- base::sys.nframe()
[17:46:51.700]     ...future.conditions <- base::list()
[17:46:51.700]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.700]     if (FALSE) {
[17:46:51.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.700]     }
[17:46:51.700]     ...future.result <- base::tryCatch({
[17:46:51.700]         base::withCallingHandlers({
[17:46:51.700]             ...future.value <- base::withVisible(base::local({
[17:46:51.700]                 withCallingHandlers({
[17:46:51.700]                   {
[17:46:51.700]                     lm(weight ~ group - 1)
[17:46:51.700]                   }
[17:46:51.700]                 }, immediateCondition = function(cond) {
[17:46:51.700]                   save_rds <- function (object, pathname, ...) 
[17:46:51.700]                   {
[17:46:51.700]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:51.700]                     if (file_test("-f", pathname_tmp)) {
[17:46:51.700]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.700]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:51.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.700]                         fi_tmp[["mtime"]])
[17:46:51.700]                     }
[17:46:51.700]                     tryCatch({
[17:46:51.700]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:51.700]                     }, error = function(ex) {
[17:46:51.700]                       msg <- conditionMessage(ex)
[17:46:51.700]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.700]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:51.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.700]                         fi_tmp[["mtime"]], msg)
[17:46:51.700]                       ex$message <- msg
[17:46:51.700]                       stop(ex)
[17:46:51.700]                     })
[17:46:51.700]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:51.700]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:51.700]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:51.700]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.700]                       fi <- file.info(pathname)
[17:46:51.700]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:51.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.700]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:51.700]                         fi[["size"]], fi[["mtime"]])
[17:46:51.700]                       stop(msg)
[17:46:51.700]                     }
[17:46:51.700]                     invisible(pathname)
[17:46:51.700]                   }
[17:46:51.700]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:51.700]                     rootPath = tempdir()) 
[17:46:51.700]                   {
[17:46:51.700]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:51.700]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:51.700]                       tmpdir = path, fileext = ".rds")
[17:46:51.700]                     save_rds(obj, file)
[17:46:51.700]                   }
[17:46:51.700]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6A38RL/.future/immediateConditions")
[17:46:51.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.700]                   {
[17:46:51.700]                     inherits <- base::inherits
[17:46:51.700]                     invokeRestart <- base::invokeRestart
[17:46:51.700]                     is.null <- base::is.null
[17:46:51.700]                     muffled <- FALSE
[17:46:51.700]                     if (inherits(cond, "message")) {
[17:46:51.700]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:51.700]                       if (muffled) 
[17:46:51.700]                         invokeRestart("muffleMessage")
[17:46:51.700]                     }
[17:46:51.700]                     else if (inherits(cond, "warning")) {
[17:46:51.700]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:51.700]                       if (muffled) 
[17:46:51.700]                         invokeRestart("muffleWarning")
[17:46:51.700]                     }
[17:46:51.700]                     else if (inherits(cond, "condition")) {
[17:46:51.700]                       if (!is.null(pattern)) {
[17:46:51.700]                         computeRestarts <- base::computeRestarts
[17:46:51.700]                         grepl <- base::grepl
[17:46:51.700]                         restarts <- computeRestarts(cond)
[17:46:51.700]                         for (restart in restarts) {
[17:46:51.700]                           name <- restart$name
[17:46:51.700]                           if (is.null(name)) 
[17:46:51.700]                             next
[17:46:51.700]                           if (!grepl(pattern, name)) 
[17:46:51.700]                             next
[17:46:51.700]                           invokeRestart(restart)
[17:46:51.700]                           muffled <- TRUE
[17:46:51.700]                           break
[17:46:51.700]                         }
[17:46:51.700]                       }
[17:46:51.700]                     }
[17:46:51.700]                     invisible(muffled)
[17:46:51.700]                   }
[17:46:51.700]                   muffleCondition(cond)
[17:46:51.700]                 })
[17:46:51.700]             }))
[17:46:51.700]             future::FutureResult(value = ...future.value$value, 
[17:46:51.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.700]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.700]                     ...future.globalenv.names))
[17:46:51.700]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.700]         }, condition = base::local({
[17:46:51.700]             c <- base::c
[17:46:51.700]             inherits <- base::inherits
[17:46:51.700]             invokeRestart <- base::invokeRestart
[17:46:51.700]             length <- base::length
[17:46:51.700]             list <- base::list
[17:46:51.700]             seq.int <- base::seq.int
[17:46:51.700]             signalCondition <- base::signalCondition
[17:46:51.700]             sys.calls <- base::sys.calls
[17:46:51.700]             `[[` <- base::`[[`
[17:46:51.700]             `+` <- base::`+`
[17:46:51.700]             `<<-` <- base::`<<-`
[17:46:51.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.700]                   3L)]
[17:46:51.700]             }
[17:46:51.700]             function(cond) {
[17:46:51.700]                 is_error <- inherits(cond, "error")
[17:46:51.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.700]                   NULL)
[17:46:51.700]                 if (is_error) {
[17:46:51.700]                   sessionInformation <- function() {
[17:46:51.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.700]                       search = base::search(), system = base::Sys.info())
[17:46:51.700]                   }
[17:46:51.700]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.700]                     cond$call), session = sessionInformation(), 
[17:46:51.700]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.700]                   signalCondition(cond)
[17:46:51.700]                 }
[17:46:51.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.700]                 "immediateCondition"))) {
[17:46:51.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.700]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.700]                   if (TRUE && !signal) {
[17:46:51.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.700]                     {
[17:46:51.700]                       inherits <- base::inherits
[17:46:51.700]                       invokeRestart <- base::invokeRestart
[17:46:51.700]                       is.null <- base::is.null
[17:46:51.700]                       muffled <- FALSE
[17:46:51.700]                       if (inherits(cond, "message")) {
[17:46:51.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.700]                         if (muffled) 
[17:46:51.700]                           invokeRestart("muffleMessage")
[17:46:51.700]                       }
[17:46:51.700]                       else if (inherits(cond, "warning")) {
[17:46:51.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.700]                         if (muffled) 
[17:46:51.700]                           invokeRestart("muffleWarning")
[17:46:51.700]                       }
[17:46:51.700]                       else if (inherits(cond, "condition")) {
[17:46:51.700]                         if (!is.null(pattern)) {
[17:46:51.700]                           computeRestarts <- base::computeRestarts
[17:46:51.700]                           grepl <- base::grepl
[17:46:51.700]                           restarts <- computeRestarts(cond)
[17:46:51.700]                           for (restart in restarts) {
[17:46:51.700]                             name <- restart$name
[17:46:51.700]                             if (is.null(name)) 
[17:46:51.700]                               next
[17:46:51.700]                             if (!grepl(pattern, name)) 
[17:46:51.700]                               next
[17:46:51.700]                             invokeRestart(restart)
[17:46:51.700]                             muffled <- TRUE
[17:46:51.700]                             break
[17:46:51.700]                           }
[17:46:51.700]                         }
[17:46:51.700]                       }
[17:46:51.700]                       invisible(muffled)
[17:46:51.700]                     }
[17:46:51.700]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.700]                   }
[17:46:51.700]                 }
[17:46:51.700]                 else {
[17:46:51.700]                   if (TRUE) {
[17:46:51.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.700]                     {
[17:46:51.700]                       inherits <- base::inherits
[17:46:51.700]                       invokeRestart <- base::invokeRestart
[17:46:51.700]                       is.null <- base::is.null
[17:46:51.700]                       muffled <- FALSE
[17:46:51.700]                       if (inherits(cond, "message")) {
[17:46:51.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.700]                         if (muffled) 
[17:46:51.700]                           invokeRestart("muffleMessage")
[17:46:51.700]                       }
[17:46:51.700]                       else if (inherits(cond, "warning")) {
[17:46:51.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.700]                         if (muffled) 
[17:46:51.700]                           invokeRestart("muffleWarning")
[17:46:51.700]                       }
[17:46:51.700]                       else if (inherits(cond, "condition")) {
[17:46:51.700]                         if (!is.null(pattern)) {
[17:46:51.700]                           computeRestarts <- base::computeRestarts
[17:46:51.700]                           grepl <- base::grepl
[17:46:51.700]                           restarts <- computeRestarts(cond)
[17:46:51.700]                           for (restart in restarts) {
[17:46:51.700]                             name <- restart$name
[17:46:51.700]                             if (is.null(name)) 
[17:46:51.700]                               next
[17:46:51.700]                             if (!grepl(pattern, name)) 
[17:46:51.700]                               next
[17:46:51.700]                             invokeRestart(restart)
[17:46:51.700]                             muffled <- TRUE
[17:46:51.700]                             break
[17:46:51.700]                           }
[17:46:51.700]                         }
[17:46:51.700]                       }
[17:46:51.700]                       invisible(muffled)
[17:46:51.700]                     }
[17:46:51.700]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.700]                   }
[17:46:51.700]                 }
[17:46:51.700]             }
[17:46:51.700]         }))
[17:46:51.700]     }, error = function(ex) {
[17:46:51.700]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.700]                 ...future.rng), started = ...future.startTime, 
[17:46:51.700]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.700]             version = "1.8"), class = "FutureResult")
[17:46:51.700]     }, finally = {
[17:46:51.700]         if (!identical(...future.workdir, getwd())) 
[17:46:51.700]             setwd(...future.workdir)
[17:46:51.700]         {
[17:46:51.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.700]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.700]             }
[17:46:51.700]             base::options(...future.oldOptions)
[17:46:51.700]             if (.Platform$OS.type == "windows") {
[17:46:51.700]                 old_names <- names(...future.oldEnvVars)
[17:46:51.700]                 envs <- base::Sys.getenv()
[17:46:51.700]                 names <- names(envs)
[17:46:51.700]                 common <- intersect(names, old_names)
[17:46:51.700]                 added <- setdiff(names, old_names)
[17:46:51.700]                 removed <- setdiff(old_names, names)
[17:46:51.700]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.700]                   envs[common]]
[17:46:51.700]                 NAMES <- toupper(changed)
[17:46:51.700]                 args <- list()
[17:46:51.700]                 for (kk in seq_along(NAMES)) {
[17:46:51.700]                   name <- changed[[kk]]
[17:46:51.700]                   NAME <- NAMES[[kk]]
[17:46:51.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.700]                     next
[17:46:51.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.700]                 }
[17:46:51.700]                 NAMES <- toupper(added)
[17:46:51.700]                 for (kk in seq_along(NAMES)) {
[17:46:51.700]                   name <- added[[kk]]
[17:46:51.700]                   NAME <- NAMES[[kk]]
[17:46:51.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.700]                     next
[17:46:51.700]                   args[[name]] <- ""
[17:46:51.700]                 }
[17:46:51.700]                 NAMES <- toupper(removed)
[17:46:51.700]                 for (kk in seq_along(NAMES)) {
[17:46:51.700]                   name <- removed[[kk]]
[17:46:51.700]                   NAME <- NAMES[[kk]]
[17:46:51.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.700]                     next
[17:46:51.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.700]                 }
[17:46:51.700]                 if (length(args) > 0) 
[17:46:51.700]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.700]             }
[17:46:51.700]             else {
[17:46:51.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.700]             }
[17:46:51.700]             {
[17:46:51.700]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.700]                   0L) {
[17:46:51.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.700]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.700]                   base::options(opts)
[17:46:51.700]                 }
[17:46:51.700]                 {
[17:46:51.700]                   {
[17:46:51.700]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:51.700]                     NULL
[17:46:51.700]                   }
[17:46:51.700]                   options(future.plan = NULL)
[17:46:51.700]                   if (is.na(NA_character_)) 
[17:46:51.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.700]                     .init = FALSE)
[17:46:51.700]                 }
[17:46:51.700]             }
[17:46:51.700]         }
[17:46:51.700]     })
[17:46:51.700]     if (TRUE) {
[17:46:51.700]         base::sink(type = "output", split = FALSE)
[17:46:51.700]         if (TRUE) {
[17:46:51.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.700]         }
[17:46:51.700]         else {
[17:46:51.700]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.700]         }
[17:46:51.700]         base::close(...future.stdout)
[17:46:51.700]         ...future.stdout <- NULL
[17:46:51.700]     }
[17:46:51.700]     ...future.result$conditions <- ...future.conditions
[17:46:51.700]     ...future.result$finished <- base::Sys.time()
[17:46:51.700]     ...future.result
[17:46:51.700] }
[17:46:51.702] assign_globals() ...
[17:46:51.703] List of 2
[17:46:51.703]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:46:51.703]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:46:51.703]  - attr(*, "where")=List of 2
[17:46:51.703]   ..$ weight:<environment: R_EmptyEnv> 
[17:46:51.703]   ..$ group :<environment: R_EmptyEnv> 
[17:46:51.703]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.703]  - attr(*, "resolved")= logi FALSE
[17:46:51.703]  - attr(*, "total_size")= num 896
[17:46:51.703]  - attr(*, "already-done")= logi TRUE
[17:46:51.706] - copied ‘weight’ to environment
[17:46:51.706] - copied ‘group’ to environment
[17:46:51.706] assign_globals() ... done
[17:46:51.707] requestCore(): workers = 2
[17:46:51.709] MulticoreFuture started
[17:46:51.709] - Launch lazy future ... done
[17:46:51.709] run() for ‘MulticoreFuture’ ... done
[17:46:51.710] result() for MulticoreFuture ...
[17:46:51.710] plan(): Setting new future strategy stack:
[17:46:51.710] List of future strategies:
[17:46:51.710] 1. sequential:
[17:46:51.710]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.710]    - tweaked: FALSE
[17:46:51.710]    - call: NULL
[17:46:51.711] plan(): nbrOfWorkers() = 1
[17:46:51.715] plan(): Setting new future strategy stack:
[17:46:51.715] List of future strategies:
[17:46:51.715] 1. multicore:
[17:46:51.715]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:51.715]    - tweaked: FALSE
[17:46:51.715]    - call: plan(strategy)
[17:46:51.720] plan(): nbrOfWorkers() = 2
[17:46:51.722] result() for MulticoreFuture ...
[17:46:51.722] result() for MulticoreFuture ... done
[17:46:51.722] result() for MulticoreFuture ... done
[17:46:51.722] result() for MulticoreFuture ...
[17:46:51.723] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:46:51.725] getGlobalsAndPackages() ...
[17:46:51.725] Searching for globals...
[17:46:51.727] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:51.727] Searching for globals ... DONE
[17:46:51.728] Resolving globals: FALSE
[17:46:51.728] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:51.729] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:51.729] - globals: [2] ‘weight’, ‘group’
[17:46:51.729] - packages: [1] ‘stats’
[17:46:51.729] getGlobalsAndPackages() ... DONE
[17:46:51.729] run() for ‘Future’ ...
[17:46:51.730] - state: ‘created’
[17:46:51.730] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:51.737] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:51.737] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:51.737]   - Field: ‘label’
[17:46:51.737]   - Field: ‘local’
[17:46:51.737]   - Field: ‘owner’
[17:46:51.738]   - Field: ‘envir’
[17:46:51.738]   - Field: ‘workers’
[17:46:51.738]   - Field: ‘packages’
[17:46:51.738]   - Field: ‘gc’
[17:46:51.738]   - Field: ‘job’
[17:46:51.738]   - Field: ‘conditions’
[17:46:51.738]   - Field: ‘expr’
[17:46:51.739]   - Field: ‘uuid’
[17:46:51.739]   - Field: ‘seed’
[17:46:51.739]   - Field: ‘version’
[17:46:51.739]   - Field: ‘result’
[17:46:51.739]   - Field: ‘asynchronous’
[17:46:51.739]   - Field: ‘calls’
[17:46:51.739]   - Field: ‘globals’
[17:46:51.739]   - Field: ‘stdout’
[17:46:51.739]   - Field: ‘earlySignal’
[17:46:51.740]   - Field: ‘lazy’
[17:46:51.740]   - Field: ‘state’
[17:46:51.740] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:51.740] - Launch lazy future ...
[17:46:51.740] Packages needed by the future expression (n = 1): ‘stats’
[17:46:51.740] Packages needed by future strategies (n = 0): <none>
[17:46:51.741] {
[17:46:51.741]     {
[17:46:51.741]         {
[17:46:51.741]             ...future.startTime <- base::Sys.time()
[17:46:51.741]             {
[17:46:51.741]                 {
[17:46:51.741]                   {
[17:46:51.741]                     {
[17:46:51.741]                       {
[17:46:51.741]                         base::local({
[17:46:51.741]                           has_future <- base::requireNamespace("future", 
[17:46:51.741]                             quietly = TRUE)
[17:46:51.741]                           if (has_future) {
[17:46:51.741]                             ns <- base::getNamespace("future")
[17:46:51.741]                             version <- ns[[".package"]][["version"]]
[17:46:51.741]                             if (is.null(version)) 
[17:46:51.741]                               version <- utils::packageVersion("future")
[17:46:51.741]                           }
[17:46:51.741]                           else {
[17:46:51.741]                             version <- NULL
[17:46:51.741]                           }
[17:46:51.741]                           if (!has_future || version < "1.8.0") {
[17:46:51.741]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.741]                               "", base::R.version$version.string), 
[17:46:51.741]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:51.741]                                 base::R.version$platform, 8 * 
[17:46:51.741]                                   base::.Machine$sizeof.pointer), 
[17:46:51.741]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.741]                                 "release", "version")], collapse = " "), 
[17:46:51.741]                               hostname = base::Sys.info()[["nodename"]])
[17:46:51.741]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.741]                               info)
[17:46:51.741]                             info <- base::paste(info, collapse = "; ")
[17:46:51.741]                             if (!has_future) {
[17:46:51.741]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.741]                                 info)
[17:46:51.741]                             }
[17:46:51.741]                             else {
[17:46:51.741]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.741]                                 info, version)
[17:46:51.741]                             }
[17:46:51.741]                             base::stop(msg)
[17:46:51.741]                           }
[17:46:51.741]                         })
[17:46:51.741]                       }
[17:46:51.741]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:51.741]                       base::options(mc.cores = 1L)
[17:46:51.741]                     }
[17:46:51.741]                     base::local({
[17:46:51.741]                       for (pkg in "stats") {
[17:46:51.741]                         base::loadNamespace(pkg)
[17:46:51.741]                         base::library(pkg, character.only = TRUE)
[17:46:51.741]                       }
[17:46:51.741]                     })
[17:46:51.741]                   }
[17:46:51.741]                   ...future.strategy.old <- future::plan("list")
[17:46:51.741]                   options(future.plan = NULL)
[17:46:51.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.741]                 }
[17:46:51.741]                 ...future.workdir <- getwd()
[17:46:51.741]             }
[17:46:51.741]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.741]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.741]         }
[17:46:51.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.741]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.741]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.741]             base::names(...future.oldOptions))
[17:46:51.741]     }
[17:46:51.741]     if (FALSE) {
[17:46:51.741]     }
[17:46:51.741]     else {
[17:46:51.741]         if (TRUE) {
[17:46:51.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.741]                 open = "w")
[17:46:51.741]         }
[17:46:51.741]         else {
[17:46:51.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.741]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.741]         }
[17:46:51.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.741]             base::sink(type = "output", split = FALSE)
[17:46:51.741]             base::close(...future.stdout)
[17:46:51.741]         }, add = TRUE)
[17:46:51.741]     }
[17:46:51.741]     ...future.frame <- base::sys.nframe()
[17:46:51.741]     ...future.conditions <- base::list()
[17:46:51.741]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.741]     if (FALSE) {
[17:46:51.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.741]     }
[17:46:51.741]     ...future.result <- base::tryCatch({
[17:46:51.741]         base::withCallingHandlers({
[17:46:51.741]             ...future.value <- base::withVisible(base::local({
[17:46:51.741]                 withCallingHandlers({
[17:46:51.741]                   {
[17:46:51.741]                     lm(weight ~ group - 1)
[17:46:51.741]                   }
[17:46:51.741]                 }, immediateCondition = function(cond) {
[17:46:51.741]                   save_rds <- function (object, pathname, ...) 
[17:46:51.741]                   {
[17:46:51.741]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:51.741]                     if (file_test("-f", pathname_tmp)) {
[17:46:51.741]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.741]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:51.741]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.741]                         fi_tmp[["mtime"]])
[17:46:51.741]                     }
[17:46:51.741]                     tryCatch({
[17:46:51.741]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:51.741]                     }, error = function(ex) {
[17:46:51.741]                       msg <- conditionMessage(ex)
[17:46:51.741]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.741]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:51.741]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.741]                         fi_tmp[["mtime"]], msg)
[17:46:51.741]                       ex$message <- msg
[17:46:51.741]                       stop(ex)
[17:46:51.741]                     })
[17:46:51.741]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:51.741]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:51.741]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:51.741]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.741]                       fi <- file.info(pathname)
[17:46:51.741]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:51.741]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.741]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:51.741]                         fi[["size"]], fi[["mtime"]])
[17:46:51.741]                       stop(msg)
[17:46:51.741]                     }
[17:46:51.741]                     invisible(pathname)
[17:46:51.741]                   }
[17:46:51.741]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:51.741]                     rootPath = tempdir()) 
[17:46:51.741]                   {
[17:46:51.741]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:51.741]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:51.741]                       tmpdir = path, fileext = ".rds")
[17:46:51.741]                     save_rds(obj, file)
[17:46:51.741]                   }
[17:46:51.741]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6A38RL/.future/immediateConditions")
[17:46:51.741]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.741]                   {
[17:46:51.741]                     inherits <- base::inherits
[17:46:51.741]                     invokeRestart <- base::invokeRestart
[17:46:51.741]                     is.null <- base::is.null
[17:46:51.741]                     muffled <- FALSE
[17:46:51.741]                     if (inherits(cond, "message")) {
[17:46:51.741]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:51.741]                       if (muffled) 
[17:46:51.741]                         invokeRestart("muffleMessage")
[17:46:51.741]                     }
[17:46:51.741]                     else if (inherits(cond, "warning")) {
[17:46:51.741]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:51.741]                       if (muffled) 
[17:46:51.741]                         invokeRestart("muffleWarning")
[17:46:51.741]                     }
[17:46:51.741]                     else if (inherits(cond, "condition")) {
[17:46:51.741]                       if (!is.null(pattern)) {
[17:46:51.741]                         computeRestarts <- base::computeRestarts
[17:46:51.741]                         grepl <- base::grepl
[17:46:51.741]                         restarts <- computeRestarts(cond)
[17:46:51.741]                         for (restart in restarts) {
[17:46:51.741]                           name <- restart$name
[17:46:51.741]                           if (is.null(name)) 
[17:46:51.741]                             next
[17:46:51.741]                           if (!grepl(pattern, name)) 
[17:46:51.741]                             next
[17:46:51.741]                           invokeRestart(restart)
[17:46:51.741]                           muffled <- TRUE
[17:46:51.741]                           break
[17:46:51.741]                         }
[17:46:51.741]                       }
[17:46:51.741]                     }
[17:46:51.741]                     invisible(muffled)
[17:46:51.741]                   }
[17:46:51.741]                   muffleCondition(cond)
[17:46:51.741]                 })
[17:46:51.741]             }))
[17:46:51.741]             future::FutureResult(value = ...future.value$value, 
[17:46:51.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.741]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.741]                     ...future.globalenv.names))
[17:46:51.741]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.741]         }, condition = base::local({
[17:46:51.741]             c <- base::c
[17:46:51.741]             inherits <- base::inherits
[17:46:51.741]             invokeRestart <- base::invokeRestart
[17:46:51.741]             length <- base::length
[17:46:51.741]             list <- base::list
[17:46:51.741]             seq.int <- base::seq.int
[17:46:51.741]             signalCondition <- base::signalCondition
[17:46:51.741]             sys.calls <- base::sys.calls
[17:46:51.741]             `[[` <- base::`[[`
[17:46:51.741]             `+` <- base::`+`
[17:46:51.741]             `<<-` <- base::`<<-`
[17:46:51.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.741]                   3L)]
[17:46:51.741]             }
[17:46:51.741]             function(cond) {
[17:46:51.741]                 is_error <- inherits(cond, "error")
[17:46:51.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.741]                   NULL)
[17:46:51.741]                 if (is_error) {
[17:46:51.741]                   sessionInformation <- function() {
[17:46:51.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.741]                       search = base::search(), system = base::Sys.info())
[17:46:51.741]                   }
[17:46:51.741]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.741]                     cond$call), session = sessionInformation(), 
[17:46:51.741]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.741]                   signalCondition(cond)
[17:46:51.741]                 }
[17:46:51.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.741]                 "immediateCondition"))) {
[17:46:51.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.741]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.741]                   if (TRUE && !signal) {
[17:46:51.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.741]                     {
[17:46:51.741]                       inherits <- base::inherits
[17:46:51.741]                       invokeRestart <- base::invokeRestart
[17:46:51.741]                       is.null <- base::is.null
[17:46:51.741]                       muffled <- FALSE
[17:46:51.741]                       if (inherits(cond, "message")) {
[17:46:51.741]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.741]                         if (muffled) 
[17:46:51.741]                           invokeRestart("muffleMessage")
[17:46:51.741]                       }
[17:46:51.741]                       else if (inherits(cond, "warning")) {
[17:46:51.741]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.741]                         if (muffled) 
[17:46:51.741]                           invokeRestart("muffleWarning")
[17:46:51.741]                       }
[17:46:51.741]                       else if (inherits(cond, "condition")) {
[17:46:51.741]                         if (!is.null(pattern)) {
[17:46:51.741]                           computeRestarts <- base::computeRestarts
[17:46:51.741]                           grepl <- base::grepl
[17:46:51.741]                           restarts <- computeRestarts(cond)
[17:46:51.741]                           for (restart in restarts) {
[17:46:51.741]                             name <- restart$name
[17:46:51.741]                             if (is.null(name)) 
[17:46:51.741]                               next
[17:46:51.741]                             if (!grepl(pattern, name)) 
[17:46:51.741]                               next
[17:46:51.741]                             invokeRestart(restart)
[17:46:51.741]                             muffled <- TRUE
[17:46:51.741]                             break
[17:46:51.741]                           }
[17:46:51.741]                         }
[17:46:51.741]                       }
[17:46:51.741]                       invisible(muffled)
[17:46:51.741]                     }
[17:46:51.741]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.741]                   }
[17:46:51.741]                 }
[17:46:51.741]                 else {
[17:46:51.741]                   if (TRUE) {
[17:46:51.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.741]                     {
[17:46:51.741]                       inherits <- base::inherits
[17:46:51.741]                       invokeRestart <- base::invokeRestart
[17:46:51.741]                       is.null <- base::is.null
[17:46:51.741]                       muffled <- FALSE
[17:46:51.741]                       if (inherits(cond, "message")) {
[17:46:51.741]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.741]                         if (muffled) 
[17:46:51.741]                           invokeRestart("muffleMessage")
[17:46:51.741]                       }
[17:46:51.741]                       else if (inherits(cond, "warning")) {
[17:46:51.741]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.741]                         if (muffled) 
[17:46:51.741]                           invokeRestart("muffleWarning")
[17:46:51.741]                       }
[17:46:51.741]                       else if (inherits(cond, "condition")) {
[17:46:51.741]                         if (!is.null(pattern)) {
[17:46:51.741]                           computeRestarts <- base::computeRestarts
[17:46:51.741]                           grepl <- base::grepl
[17:46:51.741]                           restarts <- computeRestarts(cond)
[17:46:51.741]                           for (restart in restarts) {
[17:46:51.741]                             name <- restart$name
[17:46:51.741]                             if (is.null(name)) 
[17:46:51.741]                               next
[17:46:51.741]                             if (!grepl(pattern, name)) 
[17:46:51.741]                               next
[17:46:51.741]                             invokeRestart(restart)
[17:46:51.741]                             muffled <- TRUE
[17:46:51.741]                             break
[17:46:51.741]                           }
[17:46:51.741]                         }
[17:46:51.741]                       }
[17:46:51.741]                       invisible(muffled)
[17:46:51.741]                     }
[17:46:51.741]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.741]                   }
[17:46:51.741]                 }
[17:46:51.741]             }
[17:46:51.741]         }))
[17:46:51.741]     }, error = function(ex) {
[17:46:51.741]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.741]                 ...future.rng), started = ...future.startTime, 
[17:46:51.741]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.741]             version = "1.8"), class = "FutureResult")
[17:46:51.741]     }, finally = {
[17:46:51.741]         if (!identical(...future.workdir, getwd())) 
[17:46:51.741]             setwd(...future.workdir)
[17:46:51.741]         {
[17:46:51.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.741]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.741]             }
[17:46:51.741]             base::options(...future.oldOptions)
[17:46:51.741]             if (.Platform$OS.type == "windows") {
[17:46:51.741]                 old_names <- names(...future.oldEnvVars)
[17:46:51.741]                 envs <- base::Sys.getenv()
[17:46:51.741]                 names <- names(envs)
[17:46:51.741]                 common <- intersect(names, old_names)
[17:46:51.741]                 added <- setdiff(names, old_names)
[17:46:51.741]                 removed <- setdiff(old_names, names)
[17:46:51.741]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.741]                   envs[common]]
[17:46:51.741]                 NAMES <- toupper(changed)
[17:46:51.741]                 args <- list()
[17:46:51.741]                 for (kk in seq_along(NAMES)) {
[17:46:51.741]                   name <- changed[[kk]]
[17:46:51.741]                   NAME <- NAMES[[kk]]
[17:46:51.741]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.741]                     next
[17:46:51.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.741]                 }
[17:46:51.741]                 NAMES <- toupper(added)
[17:46:51.741]                 for (kk in seq_along(NAMES)) {
[17:46:51.741]                   name <- added[[kk]]
[17:46:51.741]                   NAME <- NAMES[[kk]]
[17:46:51.741]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.741]                     next
[17:46:51.741]                   args[[name]] <- ""
[17:46:51.741]                 }
[17:46:51.741]                 NAMES <- toupper(removed)
[17:46:51.741]                 for (kk in seq_along(NAMES)) {
[17:46:51.741]                   name <- removed[[kk]]
[17:46:51.741]                   NAME <- NAMES[[kk]]
[17:46:51.741]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.741]                     next
[17:46:51.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.741]                 }
[17:46:51.741]                 if (length(args) > 0) 
[17:46:51.741]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.741]             }
[17:46:51.741]             else {
[17:46:51.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.741]             }
[17:46:51.741]             {
[17:46:51.741]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.741]                   0L) {
[17:46:51.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.741]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.741]                   base::options(opts)
[17:46:51.741]                 }
[17:46:51.741]                 {
[17:46:51.741]                   {
[17:46:51.741]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:51.741]                     NULL
[17:46:51.741]                   }
[17:46:51.741]                   options(future.plan = NULL)
[17:46:51.741]                   if (is.na(NA_character_)) 
[17:46:51.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.741]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.741]                     .init = FALSE)
[17:46:51.741]                 }
[17:46:51.741]             }
[17:46:51.741]         }
[17:46:51.741]     })
[17:46:51.741]     if (TRUE) {
[17:46:51.741]         base::sink(type = "output", split = FALSE)
[17:46:51.741]         if (TRUE) {
[17:46:51.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.741]         }
[17:46:51.741]         else {
[17:46:51.741]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.741]         }
[17:46:51.741]         base::close(...future.stdout)
[17:46:51.741]         ...future.stdout <- NULL
[17:46:51.741]     }
[17:46:51.741]     ...future.result$conditions <- ...future.conditions
[17:46:51.741]     ...future.result$finished <- base::Sys.time()
[17:46:51.741]     ...future.result
[17:46:51.741] }
[17:46:51.743] assign_globals() ...
[17:46:51.744] List of 2
[17:46:51.744]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:46:51.744]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:46:51.744]  - attr(*, "where")=List of 2
[17:46:51.744]   ..$ weight:<environment: R_EmptyEnv> 
[17:46:51.744]   ..$ group :<environment: R_EmptyEnv> 
[17:46:51.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.744]  - attr(*, "resolved")= logi FALSE
[17:46:51.744]  - attr(*, "total_size")= num 896
[17:46:51.744]  - attr(*, "already-done")= logi TRUE
[17:46:51.747] - copied ‘weight’ to environment
[17:46:51.747] - copied ‘group’ to environment
[17:46:51.748] assign_globals() ... done
[17:46:51.748] requestCore(): workers = 2
[17:46:51.750] MulticoreFuture started
[17:46:51.750] - Launch lazy future ... done
[17:46:51.750] run() for ‘MulticoreFuture’ ... done
[17:46:51.751] result() for MulticoreFuture ...
[17:46:51.751] plan(): Setting new future strategy stack:
[17:46:51.752] List of future strategies:
[17:46:51.752] 1. sequential:
[17:46:51.752]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.752]    - tweaked: FALSE
[17:46:51.752]    - call: NULL
[17:46:51.753] plan(): nbrOfWorkers() = 1
[17:46:51.756] plan(): Setting new future strategy stack:
[17:46:51.756] List of future strategies:
[17:46:51.756] 1. multicore:
[17:46:51.756]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:51.756]    - tweaked: FALSE
[17:46:51.756]    - call: plan(strategy)
[17:46:51.761] plan(): nbrOfWorkers() = 2
[17:46:51.764] result() for MulticoreFuture ...
[17:46:51.764] result() for MulticoreFuture ... done
[17:46:51.764] result() for MulticoreFuture ... done
[17:46:51.764] result() for MulticoreFuture ...
[17:46:51.764] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:46:51.767] getGlobalsAndPackages() ...
[17:46:51.767] Searching for globals...
[17:46:51.769] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:51.769] Searching for globals ... DONE
[17:46:51.769] Resolving globals: FALSE
[17:46:51.770] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:51.770] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:51.771] - globals: [2] ‘weight’, ‘group’
[17:46:51.771] - packages: [1] ‘stats’
[17:46:51.771] getGlobalsAndPackages() ... DONE
[17:46:51.771] run() for ‘Future’ ...
[17:46:51.771] - state: ‘created’
[17:46:51.772] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:51.776] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:51.776] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:51.776]   - Field: ‘label’
[17:46:51.776]   - Field: ‘local’
[17:46:51.776]   - Field: ‘owner’
[17:46:51.777]   - Field: ‘envir’
[17:46:51.777]   - Field: ‘workers’
[17:46:51.777]   - Field: ‘packages’
[17:46:51.777]   - Field: ‘gc’
[17:46:51.777]   - Field: ‘job’
[17:46:51.777]   - Field: ‘conditions’
[17:46:51.777]   - Field: ‘expr’
[17:46:51.777]   - Field: ‘uuid’
[17:46:51.778]   - Field: ‘seed’
[17:46:51.778]   - Field: ‘version’
[17:46:51.778]   - Field: ‘result’
[17:46:51.778]   - Field: ‘asynchronous’
[17:46:51.778]   - Field: ‘calls’
[17:46:51.778]   - Field: ‘globals’
[17:46:51.778]   - Field: ‘stdout’
[17:46:51.778]   - Field: ‘earlySignal’
[17:46:51.778]   - Field: ‘lazy’
[17:46:51.778]   - Field: ‘state’
[17:46:51.779] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:51.779] - Launch lazy future ...
[17:46:51.779] Packages needed by the future expression (n = 1): ‘stats’
[17:46:51.779] Packages needed by future strategies (n = 0): <none>
[17:46:51.780] {
[17:46:51.780]     {
[17:46:51.780]         {
[17:46:51.780]             ...future.startTime <- base::Sys.time()
[17:46:51.780]             {
[17:46:51.780]                 {
[17:46:51.780]                   {
[17:46:51.780]                     {
[17:46:51.780]                       {
[17:46:51.780]                         base::local({
[17:46:51.780]                           has_future <- base::requireNamespace("future", 
[17:46:51.780]                             quietly = TRUE)
[17:46:51.780]                           if (has_future) {
[17:46:51.780]                             ns <- base::getNamespace("future")
[17:46:51.780]                             version <- ns[[".package"]][["version"]]
[17:46:51.780]                             if (is.null(version)) 
[17:46:51.780]                               version <- utils::packageVersion("future")
[17:46:51.780]                           }
[17:46:51.780]                           else {
[17:46:51.780]                             version <- NULL
[17:46:51.780]                           }
[17:46:51.780]                           if (!has_future || version < "1.8.0") {
[17:46:51.780]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.780]                               "", base::R.version$version.string), 
[17:46:51.780]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:51.780]                                 base::R.version$platform, 8 * 
[17:46:51.780]                                   base::.Machine$sizeof.pointer), 
[17:46:51.780]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.780]                                 "release", "version")], collapse = " "), 
[17:46:51.780]                               hostname = base::Sys.info()[["nodename"]])
[17:46:51.780]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.780]                               info)
[17:46:51.780]                             info <- base::paste(info, collapse = "; ")
[17:46:51.780]                             if (!has_future) {
[17:46:51.780]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.780]                                 info)
[17:46:51.780]                             }
[17:46:51.780]                             else {
[17:46:51.780]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.780]                                 info, version)
[17:46:51.780]                             }
[17:46:51.780]                             base::stop(msg)
[17:46:51.780]                           }
[17:46:51.780]                         })
[17:46:51.780]                       }
[17:46:51.780]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:51.780]                       base::options(mc.cores = 1L)
[17:46:51.780]                     }
[17:46:51.780]                     base::local({
[17:46:51.780]                       for (pkg in "stats") {
[17:46:51.780]                         base::loadNamespace(pkg)
[17:46:51.780]                         base::library(pkg, character.only = TRUE)
[17:46:51.780]                       }
[17:46:51.780]                     })
[17:46:51.780]                   }
[17:46:51.780]                   ...future.strategy.old <- future::plan("list")
[17:46:51.780]                   options(future.plan = NULL)
[17:46:51.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.780]                 }
[17:46:51.780]                 ...future.workdir <- getwd()
[17:46:51.780]             }
[17:46:51.780]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.780]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.780]         }
[17:46:51.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.780]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.780]             base::names(...future.oldOptions))
[17:46:51.780]     }
[17:46:51.780]     if (FALSE) {
[17:46:51.780]     }
[17:46:51.780]     else {
[17:46:51.780]         if (TRUE) {
[17:46:51.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.780]                 open = "w")
[17:46:51.780]         }
[17:46:51.780]         else {
[17:46:51.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.780]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.780]         }
[17:46:51.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.780]             base::sink(type = "output", split = FALSE)
[17:46:51.780]             base::close(...future.stdout)
[17:46:51.780]         }, add = TRUE)
[17:46:51.780]     }
[17:46:51.780]     ...future.frame <- base::sys.nframe()
[17:46:51.780]     ...future.conditions <- base::list()
[17:46:51.780]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.780]     if (FALSE) {
[17:46:51.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.780]     }
[17:46:51.780]     ...future.result <- base::tryCatch({
[17:46:51.780]         base::withCallingHandlers({
[17:46:51.780]             ...future.value <- base::withVisible(base::local({
[17:46:51.780]                 withCallingHandlers({
[17:46:51.780]                   {
[17:46:51.780]                     lm(weight ~ group - 1)
[17:46:51.780]                   }
[17:46:51.780]                 }, immediateCondition = function(cond) {
[17:46:51.780]                   save_rds <- function (object, pathname, ...) 
[17:46:51.780]                   {
[17:46:51.780]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:51.780]                     if (file_test("-f", pathname_tmp)) {
[17:46:51.780]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.780]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:51.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.780]                         fi_tmp[["mtime"]])
[17:46:51.780]                     }
[17:46:51.780]                     tryCatch({
[17:46:51.780]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:51.780]                     }, error = function(ex) {
[17:46:51.780]                       msg <- conditionMessage(ex)
[17:46:51.780]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.780]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:51.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.780]                         fi_tmp[["mtime"]], msg)
[17:46:51.780]                       ex$message <- msg
[17:46:51.780]                       stop(ex)
[17:46:51.780]                     })
[17:46:51.780]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:51.780]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:51.780]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:51.780]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.780]                       fi <- file.info(pathname)
[17:46:51.780]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:51.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.780]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:51.780]                         fi[["size"]], fi[["mtime"]])
[17:46:51.780]                       stop(msg)
[17:46:51.780]                     }
[17:46:51.780]                     invisible(pathname)
[17:46:51.780]                   }
[17:46:51.780]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:51.780]                     rootPath = tempdir()) 
[17:46:51.780]                   {
[17:46:51.780]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:51.780]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:51.780]                       tmpdir = path, fileext = ".rds")
[17:46:51.780]                     save_rds(obj, file)
[17:46:51.780]                   }
[17:46:51.780]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6A38RL/.future/immediateConditions")
[17:46:51.780]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.780]                   {
[17:46:51.780]                     inherits <- base::inherits
[17:46:51.780]                     invokeRestart <- base::invokeRestart
[17:46:51.780]                     is.null <- base::is.null
[17:46:51.780]                     muffled <- FALSE
[17:46:51.780]                     if (inherits(cond, "message")) {
[17:46:51.780]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:51.780]                       if (muffled) 
[17:46:51.780]                         invokeRestart("muffleMessage")
[17:46:51.780]                     }
[17:46:51.780]                     else if (inherits(cond, "warning")) {
[17:46:51.780]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:51.780]                       if (muffled) 
[17:46:51.780]                         invokeRestart("muffleWarning")
[17:46:51.780]                     }
[17:46:51.780]                     else if (inherits(cond, "condition")) {
[17:46:51.780]                       if (!is.null(pattern)) {
[17:46:51.780]                         computeRestarts <- base::computeRestarts
[17:46:51.780]                         grepl <- base::grepl
[17:46:51.780]                         restarts <- computeRestarts(cond)
[17:46:51.780]                         for (restart in restarts) {
[17:46:51.780]                           name <- restart$name
[17:46:51.780]                           if (is.null(name)) 
[17:46:51.780]                             next
[17:46:51.780]                           if (!grepl(pattern, name)) 
[17:46:51.780]                             next
[17:46:51.780]                           invokeRestart(restart)
[17:46:51.780]                           muffled <- TRUE
[17:46:51.780]                           break
[17:46:51.780]                         }
[17:46:51.780]                       }
[17:46:51.780]                     }
[17:46:51.780]                     invisible(muffled)
[17:46:51.780]                   }
[17:46:51.780]                   muffleCondition(cond)
[17:46:51.780]                 })
[17:46:51.780]             }))
[17:46:51.780]             future::FutureResult(value = ...future.value$value, 
[17:46:51.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.780]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.780]                     ...future.globalenv.names))
[17:46:51.780]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.780]         }, condition = base::local({
[17:46:51.780]             c <- base::c
[17:46:51.780]             inherits <- base::inherits
[17:46:51.780]             invokeRestart <- base::invokeRestart
[17:46:51.780]             length <- base::length
[17:46:51.780]             list <- base::list
[17:46:51.780]             seq.int <- base::seq.int
[17:46:51.780]             signalCondition <- base::signalCondition
[17:46:51.780]             sys.calls <- base::sys.calls
[17:46:51.780]             `[[` <- base::`[[`
[17:46:51.780]             `+` <- base::`+`
[17:46:51.780]             `<<-` <- base::`<<-`
[17:46:51.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.780]                   3L)]
[17:46:51.780]             }
[17:46:51.780]             function(cond) {
[17:46:51.780]                 is_error <- inherits(cond, "error")
[17:46:51.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.780]                   NULL)
[17:46:51.780]                 if (is_error) {
[17:46:51.780]                   sessionInformation <- function() {
[17:46:51.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.780]                       search = base::search(), system = base::Sys.info())
[17:46:51.780]                   }
[17:46:51.780]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.780]                     cond$call), session = sessionInformation(), 
[17:46:51.780]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.780]                   signalCondition(cond)
[17:46:51.780]                 }
[17:46:51.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.780]                 "immediateCondition"))) {
[17:46:51.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.780]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.780]                   if (TRUE && !signal) {
[17:46:51.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.780]                     {
[17:46:51.780]                       inherits <- base::inherits
[17:46:51.780]                       invokeRestart <- base::invokeRestart
[17:46:51.780]                       is.null <- base::is.null
[17:46:51.780]                       muffled <- FALSE
[17:46:51.780]                       if (inherits(cond, "message")) {
[17:46:51.780]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.780]                         if (muffled) 
[17:46:51.780]                           invokeRestart("muffleMessage")
[17:46:51.780]                       }
[17:46:51.780]                       else if (inherits(cond, "warning")) {
[17:46:51.780]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.780]                         if (muffled) 
[17:46:51.780]                           invokeRestart("muffleWarning")
[17:46:51.780]                       }
[17:46:51.780]                       else if (inherits(cond, "condition")) {
[17:46:51.780]                         if (!is.null(pattern)) {
[17:46:51.780]                           computeRestarts <- base::computeRestarts
[17:46:51.780]                           grepl <- base::grepl
[17:46:51.780]                           restarts <- computeRestarts(cond)
[17:46:51.780]                           for (restart in restarts) {
[17:46:51.780]                             name <- restart$name
[17:46:51.780]                             if (is.null(name)) 
[17:46:51.780]                               next
[17:46:51.780]                             if (!grepl(pattern, name)) 
[17:46:51.780]                               next
[17:46:51.780]                             invokeRestart(restart)
[17:46:51.780]                             muffled <- TRUE
[17:46:51.780]                             break
[17:46:51.780]                           }
[17:46:51.780]                         }
[17:46:51.780]                       }
[17:46:51.780]                       invisible(muffled)
[17:46:51.780]                     }
[17:46:51.780]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.780]                   }
[17:46:51.780]                 }
[17:46:51.780]                 else {
[17:46:51.780]                   if (TRUE) {
[17:46:51.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.780]                     {
[17:46:51.780]                       inherits <- base::inherits
[17:46:51.780]                       invokeRestart <- base::invokeRestart
[17:46:51.780]                       is.null <- base::is.null
[17:46:51.780]                       muffled <- FALSE
[17:46:51.780]                       if (inherits(cond, "message")) {
[17:46:51.780]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.780]                         if (muffled) 
[17:46:51.780]                           invokeRestart("muffleMessage")
[17:46:51.780]                       }
[17:46:51.780]                       else if (inherits(cond, "warning")) {
[17:46:51.780]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.780]                         if (muffled) 
[17:46:51.780]                           invokeRestart("muffleWarning")
[17:46:51.780]                       }
[17:46:51.780]                       else if (inherits(cond, "condition")) {
[17:46:51.780]                         if (!is.null(pattern)) {
[17:46:51.780]                           computeRestarts <- base::computeRestarts
[17:46:51.780]                           grepl <- base::grepl
[17:46:51.780]                           restarts <- computeRestarts(cond)
[17:46:51.780]                           for (restart in restarts) {
[17:46:51.780]                             name <- restart$name
[17:46:51.780]                             if (is.null(name)) 
[17:46:51.780]                               next
[17:46:51.780]                             if (!grepl(pattern, name)) 
[17:46:51.780]                               next
[17:46:51.780]                             invokeRestart(restart)
[17:46:51.780]                             muffled <- TRUE
[17:46:51.780]                             break
[17:46:51.780]                           }
[17:46:51.780]                         }
[17:46:51.780]                       }
[17:46:51.780]                       invisible(muffled)
[17:46:51.780]                     }
[17:46:51.780]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.780]                   }
[17:46:51.780]                 }
[17:46:51.780]             }
[17:46:51.780]         }))
[17:46:51.780]     }, error = function(ex) {
[17:46:51.780]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.780]                 ...future.rng), started = ...future.startTime, 
[17:46:51.780]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.780]             version = "1.8"), class = "FutureResult")
[17:46:51.780]     }, finally = {
[17:46:51.780]         if (!identical(...future.workdir, getwd())) 
[17:46:51.780]             setwd(...future.workdir)
[17:46:51.780]         {
[17:46:51.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.780]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.780]             }
[17:46:51.780]             base::options(...future.oldOptions)
[17:46:51.780]             if (.Platform$OS.type == "windows") {
[17:46:51.780]                 old_names <- names(...future.oldEnvVars)
[17:46:51.780]                 envs <- base::Sys.getenv()
[17:46:51.780]                 names <- names(envs)
[17:46:51.780]                 common <- intersect(names, old_names)
[17:46:51.780]                 added <- setdiff(names, old_names)
[17:46:51.780]                 removed <- setdiff(old_names, names)
[17:46:51.780]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.780]                   envs[common]]
[17:46:51.780]                 NAMES <- toupper(changed)
[17:46:51.780]                 args <- list()
[17:46:51.780]                 for (kk in seq_along(NAMES)) {
[17:46:51.780]                   name <- changed[[kk]]
[17:46:51.780]                   NAME <- NAMES[[kk]]
[17:46:51.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.780]                     next
[17:46:51.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.780]                 }
[17:46:51.780]                 NAMES <- toupper(added)
[17:46:51.780]                 for (kk in seq_along(NAMES)) {
[17:46:51.780]                   name <- added[[kk]]
[17:46:51.780]                   NAME <- NAMES[[kk]]
[17:46:51.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.780]                     next
[17:46:51.780]                   args[[name]] <- ""
[17:46:51.780]                 }
[17:46:51.780]                 NAMES <- toupper(removed)
[17:46:51.780]                 for (kk in seq_along(NAMES)) {
[17:46:51.780]                   name <- removed[[kk]]
[17:46:51.780]                   NAME <- NAMES[[kk]]
[17:46:51.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.780]                     next
[17:46:51.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.780]                 }
[17:46:51.780]                 if (length(args) > 0) 
[17:46:51.780]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.780]             }
[17:46:51.780]             else {
[17:46:51.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.780]             }
[17:46:51.780]             {
[17:46:51.780]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.780]                   0L) {
[17:46:51.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.780]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.780]                   base::options(opts)
[17:46:51.780]                 }
[17:46:51.780]                 {
[17:46:51.780]                   {
[17:46:51.780]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:51.780]                     NULL
[17:46:51.780]                   }
[17:46:51.780]                   options(future.plan = NULL)
[17:46:51.780]                   if (is.na(NA_character_)) 
[17:46:51.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.780]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.780]                     .init = FALSE)
[17:46:51.780]                 }
[17:46:51.780]             }
[17:46:51.780]         }
[17:46:51.780]     })
[17:46:51.780]     if (TRUE) {
[17:46:51.780]         base::sink(type = "output", split = FALSE)
[17:46:51.780]         if (TRUE) {
[17:46:51.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.780]         }
[17:46:51.780]         else {
[17:46:51.780]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.780]         }
[17:46:51.780]         base::close(...future.stdout)
[17:46:51.780]         ...future.stdout <- NULL
[17:46:51.780]     }
[17:46:51.780]     ...future.result$conditions <- ...future.conditions
[17:46:51.780]     ...future.result$finished <- base::Sys.time()
[17:46:51.780]     ...future.result
[17:46:51.780] }
[17:46:51.783] assign_globals() ...
[17:46:51.783] List of 2
[17:46:51.783]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:46:51.783]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:46:51.783]  - attr(*, "where")=List of 2
[17:46:51.783]   ..$ weight:<environment: R_EmptyEnv> 
[17:46:51.783]   ..$ group :<environment: R_EmptyEnv> 
[17:46:51.783]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.783]  - attr(*, "resolved")= logi FALSE
[17:46:51.783]  - attr(*, "total_size")= num 896
[17:46:51.783]  - attr(*, "already-done")= logi TRUE
[17:46:51.789] - copied ‘weight’ to environment
[17:46:51.789] - copied ‘group’ to environment
[17:46:51.789] assign_globals() ... done
[17:46:51.790] requestCore(): workers = 2
[17:46:51.792] MulticoreFuture started
[17:46:51.792] - Launch lazy future ... done
[17:46:51.792] run() for ‘MulticoreFuture’ ... done
[17:46:51.792] result() for MulticoreFuture ...
[17:46:51.793] plan(): Setting new future strategy stack:
[17:46:51.793] List of future strategies:
[17:46:51.793] 1. sequential:
[17:46:51.793]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.793]    - tweaked: FALSE
[17:46:51.793]    - call: NULL
[17:46:51.794] plan(): nbrOfWorkers() = 1
[17:46:51.798] plan(): Setting new future strategy stack:
[17:46:51.798] List of future strategies:
[17:46:51.798] 1. multicore:
[17:46:51.798]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:51.798]    - tweaked: FALSE
[17:46:51.798]    - call: plan(strategy)
[17:46:51.804] plan(): nbrOfWorkers() = 2
[17:46:51.806] result() for MulticoreFuture ...
[17:46:51.806] result() for MulticoreFuture ... done
[17:46:51.806] result() for MulticoreFuture ... done
[17:46:51.806] result() for MulticoreFuture ...
[17:46:51.806] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[17:46:51.809] getGlobalsAndPackages() ...
[17:46:51.809] Searching for globals...
[17:46:51.811] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:46:51.811] Searching for globals ... DONE
[17:46:51.811] Resolving globals: FALSE
[17:46:51.812] The total size of the 1 globals is 96 bytes (96 bytes)
[17:46:51.812] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:46:51.812] - globals: [1] ‘x’
[17:46:51.813] - packages: [1] ‘stats’
[17:46:51.813] getGlobalsAndPackages() ... DONE
[17:46:51.813] run() for ‘Future’ ...
[17:46:51.813] - state: ‘created’
[17:46:51.813] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:51.817] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:51.818] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:51.818]   - Field: ‘label’
[17:46:51.818]   - Field: ‘local’
[17:46:51.818]   - Field: ‘owner’
[17:46:51.818]   - Field: ‘envir’
[17:46:51.818]   - Field: ‘workers’
[17:46:51.818]   - Field: ‘packages’
[17:46:51.818]   - Field: ‘gc’
[17:46:51.819]   - Field: ‘job’
[17:46:51.819]   - Field: ‘conditions’
[17:46:51.819]   - Field: ‘expr’
[17:46:51.819]   - Field: ‘uuid’
[17:46:51.819]   - Field: ‘seed’
[17:46:51.819]   - Field: ‘version’
[17:46:51.819]   - Field: ‘result’
[17:46:51.819]   - Field: ‘asynchronous’
[17:46:51.819]   - Field: ‘calls’
[17:46:51.820]   - Field: ‘globals’
[17:46:51.820]   - Field: ‘stdout’
[17:46:51.820]   - Field: ‘earlySignal’
[17:46:51.820]   - Field: ‘lazy’
[17:46:51.820]   - Field: ‘state’
[17:46:51.820] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:51.820] - Launch lazy future ...
[17:46:51.821] Packages needed by the future expression (n = 1): ‘stats’
[17:46:51.821] Packages needed by future strategies (n = 0): <none>
[17:46:51.821] {
[17:46:51.821]     {
[17:46:51.821]         {
[17:46:51.821]             ...future.startTime <- base::Sys.time()
[17:46:51.821]             {
[17:46:51.821]                 {
[17:46:51.821]                   {
[17:46:51.821]                     {
[17:46:51.821]                       {
[17:46:51.821]                         base::local({
[17:46:51.821]                           has_future <- base::requireNamespace("future", 
[17:46:51.821]                             quietly = TRUE)
[17:46:51.821]                           if (has_future) {
[17:46:51.821]                             ns <- base::getNamespace("future")
[17:46:51.821]                             version <- ns[[".package"]][["version"]]
[17:46:51.821]                             if (is.null(version)) 
[17:46:51.821]                               version <- utils::packageVersion("future")
[17:46:51.821]                           }
[17:46:51.821]                           else {
[17:46:51.821]                             version <- NULL
[17:46:51.821]                           }
[17:46:51.821]                           if (!has_future || version < "1.8.0") {
[17:46:51.821]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.821]                               "", base::R.version$version.string), 
[17:46:51.821]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:51.821]                                 base::R.version$platform, 8 * 
[17:46:51.821]                                   base::.Machine$sizeof.pointer), 
[17:46:51.821]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.821]                                 "release", "version")], collapse = " "), 
[17:46:51.821]                               hostname = base::Sys.info()[["nodename"]])
[17:46:51.821]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.821]                               info)
[17:46:51.821]                             info <- base::paste(info, collapse = "; ")
[17:46:51.821]                             if (!has_future) {
[17:46:51.821]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.821]                                 info)
[17:46:51.821]                             }
[17:46:51.821]                             else {
[17:46:51.821]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.821]                                 info, version)
[17:46:51.821]                             }
[17:46:51.821]                             base::stop(msg)
[17:46:51.821]                           }
[17:46:51.821]                         })
[17:46:51.821]                       }
[17:46:51.821]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:51.821]                       base::options(mc.cores = 1L)
[17:46:51.821]                     }
[17:46:51.821]                     base::local({
[17:46:51.821]                       for (pkg in "stats") {
[17:46:51.821]                         base::loadNamespace(pkg)
[17:46:51.821]                         base::library(pkg, character.only = TRUE)
[17:46:51.821]                       }
[17:46:51.821]                     })
[17:46:51.821]                   }
[17:46:51.821]                   ...future.strategy.old <- future::plan("list")
[17:46:51.821]                   options(future.plan = NULL)
[17:46:51.821]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.821]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.821]                 }
[17:46:51.821]                 ...future.workdir <- getwd()
[17:46:51.821]             }
[17:46:51.821]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.821]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.821]         }
[17:46:51.821]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.821]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.821]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.821]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.821]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.821]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.821]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.821]             base::names(...future.oldOptions))
[17:46:51.821]     }
[17:46:51.821]     if (FALSE) {
[17:46:51.821]     }
[17:46:51.821]     else {
[17:46:51.821]         if (TRUE) {
[17:46:51.821]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.821]                 open = "w")
[17:46:51.821]         }
[17:46:51.821]         else {
[17:46:51.821]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.821]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.821]         }
[17:46:51.821]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.821]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.821]             base::sink(type = "output", split = FALSE)
[17:46:51.821]             base::close(...future.stdout)
[17:46:51.821]         }, add = TRUE)
[17:46:51.821]     }
[17:46:51.821]     ...future.frame <- base::sys.nframe()
[17:46:51.821]     ...future.conditions <- base::list()
[17:46:51.821]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.821]     if (FALSE) {
[17:46:51.821]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.821]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.821]     }
[17:46:51.821]     ...future.result <- base::tryCatch({
[17:46:51.821]         base::withCallingHandlers({
[17:46:51.821]             ...future.value <- base::withVisible(base::local({
[17:46:51.821]                 withCallingHandlers({
[17:46:51.821]                   {
[17:46:51.821]                     xtabs(~x)
[17:46:51.821]                   }
[17:46:51.821]                 }, immediateCondition = function(cond) {
[17:46:51.821]                   save_rds <- function (object, pathname, ...) 
[17:46:51.821]                   {
[17:46:51.821]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:51.821]                     if (file_test("-f", pathname_tmp)) {
[17:46:51.821]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.821]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:51.821]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.821]                         fi_tmp[["mtime"]])
[17:46:51.821]                     }
[17:46:51.821]                     tryCatch({
[17:46:51.821]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:51.821]                     }, error = function(ex) {
[17:46:51.821]                       msg <- conditionMessage(ex)
[17:46:51.821]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.821]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:51.821]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.821]                         fi_tmp[["mtime"]], msg)
[17:46:51.821]                       ex$message <- msg
[17:46:51.821]                       stop(ex)
[17:46:51.821]                     })
[17:46:51.821]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:51.821]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:51.821]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:51.821]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.821]                       fi <- file.info(pathname)
[17:46:51.821]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:51.821]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.821]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:51.821]                         fi[["size"]], fi[["mtime"]])
[17:46:51.821]                       stop(msg)
[17:46:51.821]                     }
[17:46:51.821]                     invisible(pathname)
[17:46:51.821]                   }
[17:46:51.821]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:51.821]                     rootPath = tempdir()) 
[17:46:51.821]                   {
[17:46:51.821]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:51.821]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:51.821]                       tmpdir = path, fileext = ".rds")
[17:46:51.821]                     save_rds(obj, file)
[17:46:51.821]                   }
[17:46:51.821]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6A38RL/.future/immediateConditions")
[17:46:51.821]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.821]                   {
[17:46:51.821]                     inherits <- base::inherits
[17:46:51.821]                     invokeRestart <- base::invokeRestart
[17:46:51.821]                     is.null <- base::is.null
[17:46:51.821]                     muffled <- FALSE
[17:46:51.821]                     if (inherits(cond, "message")) {
[17:46:51.821]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:51.821]                       if (muffled) 
[17:46:51.821]                         invokeRestart("muffleMessage")
[17:46:51.821]                     }
[17:46:51.821]                     else if (inherits(cond, "warning")) {
[17:46:51.821]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:51.821]                       if (muffled) 
[17:46:51.821]                         invokeRestart("muffleWarning")
[17:46:51.821]                     }
[17:46:51.821]                     else if (inherits(cond, "condition")) {
[17:46:51.821]                       if (!is.null(pattern)) {
[17:46:51.821]                         computeRestarts <- base::computeRestarts
[17:46:51.821]                         grepl <- base::grepl
[17:46:51.821]                         restarts <- computeRestarts(cond)
[17:46:51.821]                         for (restart in restarts) {
[17:46:51.821]                           name <- restart$name
[17:46:51.821]                           if (is.null(name)) 
[17:46:51.821]                             next
[17:46:51.821]                           if (!grepl(pattern, name)) 
[17:46:51.821]                             next
[17:46:51.821]                           invokeRestart(restart)
[17:46:51.821]                           muffled <- TRUE
[17:46:51.821]                           break
[17:46:51.821]                         }
[17:46:51.821]                       }
[17:46:51.821]                     }
[17:46:51.821]                     invisible(muffled)
[17:46:51.821]                   }
[17:46:51.821]                   muffleCondition(cond)
[17:46:51.821]                 })
[17:46:51.821]             }))
[17:46:51.821]             future::FutureResult(value = ...future.value$value, 
[17:46:51.821]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.821]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.821]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.821]                     ...future.globalenv.names))
[17:46:51.821]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.821]         }, condition = base::local({
[17:46:51.821]             c <- base::c
[17:46:51.821]             inherits <- base::inherits
[17:46:51.821]             invokeRestart <- base::invokeRestart
[17:46:51.821]             length <- base::length
[17:46:51.821]             list <- base::list
[17:46:51.821]             seq.int <- base::seq.int
[17:46:51.821]             signalCondition <- base::signalCondition
[17:46:51.821]             sys.calls <- base::sys.calls
[17:46:51.821]             `[[` <- base::`[[`
[17:46:51.821]             `+` <- base::`+`
[17:46:51.821]             `<<-` <- base::`<<-`
[17:46:51.821]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.821]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.821]                   3L)]
[17:46:51.821]             }
[17:46:51.821]             function(cond) {
[17:46:51.821]                 is_error <- inherits(cond, "error")
[17:46:51.821]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.821]                   NULL)
[17:46:51.821]                 if (is_error) {
[17:46:51.821]                   sessionInformation <- function() {
[17:46:51.821]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.821]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.821]                       search = base::search(), system = base::Sys.info())
[17:46:51.821]                   }
[17:46:51.821]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.821]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.821]                     cond$call), session = sessionInformation(), 
[17:46:51.821]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.821]                   signalCondition(cond)
[17:46:51.821]                 }
[17:46:51.821]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.821]                 "immediateCondition"))) {
[17:46:51.821]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.821]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.821]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.821]                   if (TRUE && !signal) {
[17:46:51.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.821]                     {
[17:46:51.821]                       inherits <- base::inherits
[17:46:51.821]                       invokeRestart <- base::invokeRestart
[17:46:51.821]                       is.null <- base::is.null
[17:46:51.821]                       muffled <- FALSE
[17:46:51.821]                       if (inherits(cond, "message")) {
[17:46:51.821]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.821]                         if (muffled) 
[17:46:51.821]                           invokeRestart("muffleMessage")
[17:46:51.821]                       }
[17:46:51.821]                       else if (inherits(cond, "warning")) {
[17:46:51.821]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.821]                         if (muffled) 
[17:46:51.821]                           invokeRestart("muffleWarning")
[17:46:51.821]                       }
[17:46:51.821]                       else if (inherits(cond, "condition")) {
[17:46:51.821]                         if (!is.null(pattern)) {
[17:46:51.821]                           computeRestarts <- base::computeRestarts
[17:46:51.821]                           grepl <- base::grepl
[17:46:51.821]                           restarts <- computeRestarts(cond)
[17:46:51.821]                           for (restart in restarts) {
[17:46:51.821]                             name <- restart$name
[17:46:51.821]                             if (is.null(name)) 
[17:46:51.821]                               next
[17:46:51.821]                             if (!grepl(pattern, name)) 
[17:46:51.821]                               next
[17:46:51.821]                             invokeRestart(restart)
[17:46:51.821]                             muffled <- TRUE
[17:46:51.821]                             break
[17:46:51.821]                           }
[17:46:51.821]                         }
[17:46:51.821]                       }
[17:46:51.821]                       invisible(muffled)
[17:46:51.821]                     }
[17:46:51.821]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.821]                   }
[17:46:51.821]                 }
[17:46:51.821]                 else {
[17:46:51.821]                   if (TRUE) {
[17:46:51.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.821]                     {
[17:46:51.821]                       inherits <- base::inherits
[17:46:51.821]                       invokeRestart <- base::invokeRestart
[17:46:51.821]                       is.null <- base::is.null
[17:46:51.821]                       muffled <- FALSE
[17:46:51.821]                       if (inherits(cond, "message")) {
[17:46:51.821]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.821]                         if (muffled) 
[17:46:51.821]                           invokeRestart("muffleMessage")
[17:46:51.821]                       }
[17:46:51.821]                       else if (inherits(cond, "warning")) {
[17:46:51.821]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.821]                         if (muffled) 
[17:46:51.821]                           invokeRestart("muffleWarning")
[17:46:51.821]                       }
[17:46:51.821]                       else if (inherits(cond, "condition")) {
[17:46:51.821]                         if (!is.null(pattern)) {
[17:46:51.821]                           computeRestarts <- base::computeRestarts
[17:46:51.821]                           grepl <- base::grepl
[17:46:51.821]                           restarts <- computeRestarts(cond)
[17:46:51.821]                           for (restart in restarts) {
[17:46:51.821]                             name <- restart$name
[17:46:51.821]                             if (is.null(name)) 
[17:46:51.821]                               next
[17:46:51.821]                             if (!grepl(pattern, name)) 
[17:46:51.821]                               next
[17:46:51.821]                             invokeRestart(restart)
[17:46:51.821]                             muffled <- TRUE
[17:46:51.821]                             break
[17:46:51.821]                           }
[17:46:51.821]                         }
[17:46:51.821]                       }
[17:46:51.821]                       invisible(muffled)
[17:46:51.821]                     }
[17:46:51.821]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.821]                   }
[17:46:51.821]                 }
[17:46:51.821]             }
[17:46:51.821]         }))
[17:46:51.821]     }, error = function(ex) {
[17:46:51.821]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.821]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.821]                 ...future.rng), started = ...future.startTime, 
[17:46:51.821]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.821]             version = "1.8"), class = "FutureResult")
[17:46:51.821]     }, finally = {
[17:46:51.821]         if (!identical(...future.workdir, getwd())) 
[17:46:51.821]             setwd(...future.workdir)
[17:46:51.821]         {
[17:46:51.821]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.821]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.821]             }
[17:46:51.821]             base::options(...future.oldOptions)
[17:46:51.821]             if (.Platform$OS.type == "windows") {
[17:46:51.821]                 old_names <- names(...future.oldEnvVars)
[17:46:51.821]                 envs <- base::Sys.getenv()
[17:46:51.821]                 names <- names(envs)
[17:46:51.821]                 common <- intersect(names, old_names)
[17:46:51.821]                 added <- setdiff(names, old_names)
[17:46:51.821]                 removed <- setdiff(old_names, names)
[17:46:51.821]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.821]                   envs[common]]
[17:46:51.821]                 NAMES <- toupper(changed)
[17:46:51.821]                 args <- list()
[17:46:51.821]                 for (kk in seq_along(NAMES)) {
[17:46:51.821]                   name <- changed[[kk]]
[17:46:51.821]                   NAME <- NAMES[[kk]]
[17:46:51.821]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.821]                     next
[17:46:51.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.821]                 }
[17:46:51.821]                 NAMES <- toupper(added)
[17:46:51.821]                 for (kk in seq_along(NAMES)) {
[17:46:51.821]                   name <- added[[kk]]
[17:46:51.821]                   NAME <- NAMES[[kk]]
[17:46:51.821]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.821]                     next
[17:46:51.821]                   args[[name]] <- ""
[17:46:51.821]                 }
[17:46:51.821]                 NAMES <- toupper(removed)
[17:46:51.821]                 for (kk in seq_along(NAMES)) {
[17:46:51.821]                   name <- removed[[kk]]
[17:46:51.821]                   NAME <- NAMES[[kk]]
[17:46:51.821]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.821]                     next
[17:46:51.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.821]                 }
[17:46:51.821]                 if (length(args) > 0) 
[17:46:51.821]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.821]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.821]             }
[17:46:51.821]             else {
[17:46:51.821]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.821]             }
[17:46:51.821]             {
[17:46:51.821]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.821]                   0L) {
[17:46:51.821]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.821]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.821]                   base::options(opts)
[17:46:51.821]                 }
[17:46:51.821]                 {
[17:46:51.821]                   {
[17:46:51.821]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:51.821]                     NULL
[17:46:51.821]                   }
[17:46:51.821]                   options(future.plan = NULL)
[17:46:51.821]                   if (is.na(NA_character_)) 
[17:46:51.821]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.821]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.821]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.821]                     .init = FALSE)
[17:46:51.821]                 }
[17:46:51.821]             }
[17:46:51.821]         }
[17:46:51.821]     })
[17:46:51.821]     if (TRUE) {
[17:46:51.821]         base::sink(type = "output", split = FALSE)
[17:46:51.821]         if (TRUE) {
[17:46:51.821]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.821]         }
[17:46:51.821]         else {
[17:46:51.821]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.821]         }
[17:46:51.821]         base::close(...future.stdout)
[17:46:51.821]         ...future.stdout <- NULL
[17:46:51.821]     }
[17:46:51.821]     ...future.result$conditions <- ...future.conditions
[17:46:51.821]     ...future.result$finished <- base::Sys.time()
[17:46:51.821]     ...future.result
[17:46:51.821] }
[17:46:51.824] assign_globals() ...
[17:46:51.824] List of 1
[17:46:51.824]  $ x: num [1:5] 1 1 2 2 2
[17:46:51.824]  - attr(*, "where")=List of 1
[17:46:51.824]   ..$ x:<environment: R_EmptyEnv> 
[17:46:51.824]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.824]  - attr(*, "resolved")= logi FALSE
[17:46:51.824]  - attr(*, "total_size")= num 96
[17:46:51.824]  - attr(*, "already-done")= logi TRUE
[17:46:51.827] - copied ‘x’ to environment
[17:46:51.827] assign_globals() ... done
[17:46:51.827] requestCore(): workers = 2
[17:46:51.830] MulticoreFuture started
[17:46:51.830] - Launch lazy future ... done
[17:46:51.830] run() for ‘MulticoreFuture’ ... done
[17:46:51.831] result() for MulticoreFuture ...
[17:46:51.831] plan(): Setting new future strategy stack:
[17:46:51.831] List of future strategies:
[17:46:51.831] 1. sequential:
[17:46:51.831]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.831]    - tweaked: FALSE
[17:46:51.831]    - call: NULL
[17:46:51.832] plan(): nbrOfWorkers() = 1
[17:46:51.835] plan(): Setting new future strategy stack:
[17:46:51.835] List of future strategies:
[17:46:51.835] 1. multicore:
[17:46:51.835]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:51.835]    - tweaked: FALSE
[17:46:51.835]    - call: plan(strategy)
[17:46:51.844] plan(): nbrOfWorkers() = 2
[17:46:51.845] result() for MulticoreFuture ...
[17:46:51.845] result() for MulticoreFuture ... done
[17:46:51.845] result() for MulticoreFuture ... done
[17:46:51.845] result() for MulticoreFuture ...
[17:46:51.845] result() for MulticoreFuture ... done
x
1 2 
2 3 
[17:46:51.847] getGlobalsAndPackages() ...
[17:46:51.847] Searching for globals...
[17:46:51.851] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:46:51.851] Searching for globals ... DONE
[17:46:51.851] Resolving globals: FALSE
[17:46:51.852] The total size of the 1 globals is 96 bytes (96 bytes)
[17:46:51.852] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:46:51.852] - globals: [1] ‘x’
[17:46:51.853] - packages: [1] ‘stats’
[17:46:51.853] getGlobalsAndPackages() ... DONE
[17:46:51.853] run() for ‘Future’ ...
[17:46:51.853] - state: ‘created’
[17:46:51.853] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:51.858] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:51.858] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:51.858]   - Field: ‘label’
[17:46:51.858]   - Field: ‘local’
[17:46:51.858]   - Field: ‘owner’
[17:46:51.858]   - Field: ‘envir’
[17:46:51.858]   - Field: ‘workers’
[17:46:51.858]   - Field: ‘packages’
[17:46:51.859]   - Field: ‘gc’
[17:46:51.859]   - Field: ‘job’
[17:46:51.859]   - Field: ‘conditions’
[17:46:51.859]   - Field: ‘expr’
[17:46:51.859]   - Field: ‘uuid’
[17:46:51.859]   - Field: ‘seed’
[17:46:51.859]   - Field: ‘version’
[17:46:51.859]   - Field: ‘result’
[17:46:51.860]   - Field: ‘asynchronous’
[17:46:51.860]   - Field: ‘calls’
[17:46:51.860]   - Field: ‘globals’
[17:46:51.860]   - Field: ‘stdout’
[17:46:51.860]   - Field: ‘earlySignal’
[17:46:51.860]   - Field: ‘lazy’
[17:46:51.860]   - Field: ‘state’
[17:46:51.860] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:51.860] - Launch lazy future ...
[17:46:51.861] Packages needed by the future expression (n = 1): ‘stats’
[17:46:51.861] Packages needed by future strategies (n = 0): <none>
[17:46:51.862] {
[17:46:51.862]     {
[17:46:51.862]         {
[17:46:51.862]             ...future.startTime <- base::Sys.time()
[17:46:51.862]             {
[17:46:51.862]                 {
[17:46:51.862]                   {
[17:46:51.862]                     {
[17:46:51.862]                       {
[17:46:51.862]                         base::local({
[17:46:51.862]                           has_future <- base::requireNamespace("future", 
[17:46:51.862]                             quietly = TRUE)
[17:46:51.862]                           if (has_future) {
[17:46:51.862]                             ns <- base::getNamespace("future")
[17:46:51.862]                             version <- ns[[".package"]][["version"]]
[17:46:51.862]                             if (is.null(version)) 
[17:46:51.862]                               version <- utils::packageVersion("future")
[17:46:51.862]                           }
[17:46:51.862]                           else {
[17:46:51.862]                             version <- NULL
[17:46:51.862]                           }
[17:46:51.862]                           if (!has_future || version < "1.8.0") {
[17:46:51.862]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.862]                               "", base::R.version$version.string), 
[17:46:51.862]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:51.862]                                 base::R.version$platform, 8 * 
[17:46:51.862]                                   base::.Machine$sizeof.pointer), 
[17:46:51.862]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.862]                                 "release", "version")], collapse = " "), 
[17:46:51.862]                               hostname = base::Sys.info()[["nodename"]])
[17:46:51.862]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.862]                               info)
[17:46:51.862]                             info <- base::paste(info, collapse = "; ")
[17:46:51.862]                             if (!has_future) {
[17:46:51.862]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.862]                                 info)
[17:46:51.862]                             }
[17:46:51.862]                             else {
[17:46:51.862]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.862]                                 info, version)
[17:46:51.862]                             }
[17:46:51.862]                             base::stop(msg)
[17:46:51.862]                           }
[17:46:51.862]                         })
[17:46:51.862]                       }
[17:46:51.862]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:51.862]                       base::options(mc.cores = 1L)
[17:46:51.862]                     }
[17:46:51.862]                     base::local({
[17:46:51.862]                       for (pkg in "stats") {
[17:46:51.862]                         base::loadNamespace(pkg)
[17:46:51.862]                         base::library(pkg, character.only = TRUE)
[17:46:51.862]                       }
[17:46:51.862]                     })
[17:46:51.862]                   }
[17:46:51.862]                   ...future.strategy.old <- future::plan("list")
[17:46:51.862]                   options(future.plan = NULL)
[17:46:51.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.862]                 }
[17:46:51.862]                 ...future.workdir <- getwd()
[17:46:51.862]             }
[17:46:51.862]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.862]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.862]         }
[17:46:51.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.862]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.862]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.862]             base::names(...future.oldOptions))
[17:46:51.862]     }
[17:46:51.862]     if (FALSE) {
[17:46:51.862]     }
[17:46:51.862]     else {
[17:46:51.862]         if (TRUE) {
[17:46:51.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.862]                 open = "w")
[17:46:51.862]         }
[17:46:51.862]         else {
[17:46:51.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.862]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.862]         }
[17:46:51.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.862]             base::sink(type = "output", split = FALSE)
[17:46:51.862]             base::close(...future.stdout)
[17:46:51.862]         }, add = TRUE)
[17:46:51.862]     }
[17:46:51.862]     ...future.frame <- base::sys.nframe()
[17:46:51.862]     ...future.conditions <- base::list()
[17:46:51.862]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.862]     if (FALSE) {
[17:46:51.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.862]     }
[17:46:51.862]     ...future.result <- base::tryCatch({
[17:46:51.862]         base::withCallingHandlers({
[17:46:51.862]             ...future.value <- base::withVisible(base::local({
[17:46:51.862]                 withCallingHandlers({
[17:46:51.862]                   {
[17:46:51.862]                     xtabs(~x)
[17:46:51.862]                   }
[17:46:51.862]                 }, immediateCondition = function(cond) {
[17:46:51.862]                   save_rds <- function (object, pathname, ...) 
[17:46:51.862]                   {
[17:46:51.862]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:51.862]                     if (file_test("-f", pathname_tmp)) {
[17:46:51.862]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.862]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:51.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.862]                         fi_tmp[["mtime"]])
[17:46:51.862]                     }
[17:46:51.862]                     tryCatch({
[17:46:51.862]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:51.862]                     }, error = function(ex) {
[17:46:51.862]                       msg <- conditionMessage(ex)
[17:46:51.862]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.862]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:51.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.862]                         fi_tmp[["mtime"]], msg)
[17:46:51.862]                       ex$message <- msg
[17:46:51.862]                       stop(ex)
[17:46:51.862]                     })
[17:46:51.862]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:51.862]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:51.862]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:51.862]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.862]                       fi <- file.info(pathname)
[17:46:51.862]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:51.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.862]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:51.862]                         fi[["size"]], fi[["mtime"]])
[17:46:51.862]                       stop(msg)
[17:46:51.862]                     }
[17:46:51.862]                     invisible(pathname)
[17:46:51.862]                   }
[17:46:51.862]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:51.862]                     rootPath = tempdir()) 
[17:46:51.862]                   {
[17:46:51.862]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:51.862]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:51.862]                       tmpdir = path, fileext = ".rds")
[17:46:51.862]                     save_rds(obj, file)
[17:46:51.862]                   }
[17:46:51.862]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6A38RL/.future/immediateConditions")
[17:46:51.862]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.862]                   {
[17:46:51.862]                     inherits <- base::inherits
[17:46:51.862]                     invokeRestart <- base::invokeRestart
[17:46:51.862]                     is.null <- base::is.null
[17:46:51.862]                     muffled <- FALSE
[17:46:51.862]                     if (inherits(cond, "message")) {
[17:46:51.862]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:51.862]                       if (muffled) 
[17:46:51.862]                         invokeRestart("muffleMessage")
[17:46:51.862]                     }
[17:46:51.862]                     else if (inherits(cond, "warning")) {
[17:46:51.862]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:51.862]                       if (muffled) 
[17:46:51.862]                         invokeRestart("muffleWarning")
[17:46:51.862]                     }
[17:46:51.862]                     else if (inherits(cond, "condition")) {
[17:46:51.862]                       if (!is.null(pattern)) {
[17:46:51.862]                         computeRestarts <- base::computeRestarts
[17:46:51.862]                         grepl <- base::grepl
[17:46:51.862]                         restarts <- computeRestarts(cond)
[17:46:51.862]                         for (restart in restarts) {
[17:46:51.862]                           name <- restart$name
[17:46:51.862]                           if (is.null(name)) 
[17:46:51.862]                             next
[17:46:51.862]                           if (!grepl(pattern, name)) 
[17:46:51.862]                             next
[17:46:51.862]                           invokeRestart(restart)
[17:46:51.862]                           muffled <- TRUE
[17:46:51.862]                           break
[17:46:51.862]                         }
[17:46:51.862]                       }
[17:46:51.862]                     }
[17:46:51.862]                     invisible(muffled)
[17:46:51.862]                   }
[17:46:51.862]                   muffleCondition(cond)
[17:46:51.862]                 })
[17:46:51.862]             }))
[17:46:51.862]             future::FutureResult(value = ...future.value$value, 
[17:46:51.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.862]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.862]                     ...future.globalenv.names))
[17:46:51.862]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.862]         }, condition = base::local({
[17:46:51.862]             c <- base::c
[17:46:51.862]             inherits <- base::inherits
[17:46:51.862]             invokeRestart <- base::invokeRestart
[17:46:51.862]             length <- base::length
[17:46:51.862]             list <- base::list
[17:46:51.862]             seq.int <- base::seq.int
[17:46:51.862]             signalCondition <- base::signalCondition
[17:46:51.862]             sys.calls <- base::sys.calls
[17:46:51.862]             `[[` <- base::`[[`
[17:46:51.862]             `+` <- base::`+`
[17:46:51.862]             `<<-` <- base::`<<-`
[17:46:51.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.862]                   3L)]
[17:46:51.862]             }
[17:46:51.862]             function(cond) {
[17:46:51.862]                 is_error <- inherits(cond, "error")
[17:46:51.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.862]                   NULL)
[17:46:51.862]                 if (is_error) {
[17:46:51.862]                   sessionInformation <- function() {
[17:46:51.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.862]                       search = base::search(), system = base::Sys.info())
[17:46:51.862]                   }
[17:46:51.862]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.862]                     cond$call), session = sessionInformation(), 
[17:46:51.862]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.862]                   signalCondition(cond)
[17:46:51.862]                 }
[17:46:51.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.862]                 "immediateCondition"))) {
[17:46:51.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.862]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.862]                   if (TRUE && !signal) {
[17:46:51.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.862]                     {
[17:46:51.862]                       inherits <- base::inherits
[17:46:51.862]                       invokeRestart <- base::invokeRestart
[17:46:51.862]                       is.null <- base::is.null
[17:46:51.862]                       muffled <- FALSE
[17:46:51.862]                       if (inherits(cond, "message")) {
[17:46:51.862]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.862]                         if (muffled) 
[17:46:51.862]                           invokeRestart("muffleMessage")
[17:46:51.862]                       }
[17:46:51.862]                       else if (inherits(cond, "warning")) {
[17:46:51.862]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.862]                         if (muffled) 
[17:46:51.862]                           invokeRestart("muffleWarning")
[17:46:51.862]                       }
[17:46:51.862]                       else if (inherits(cond, "condition")) {
[17:46:51.862]                         if (!is.null(pattern)) {
[17:46:51.862]                           computeRestarts <- base::computeRestarts
[17:46:51.862]                           grepl <- base::grepl
[17:46:51.862]                           restarts <- computeRestarts(cond)
[17:46:51.862]                           for (restart in restarts) {
[17:46:51.862]                             name <- restart$name
[17:46:51.862]                             if (is.null(name)) 
[17:46:51.862]                               next
[17:46:51.862]                             if (!grepl(pattern, name)) 
[17:46:51.862]                               next
[17:46:51.862]                             invokeRestart(restart)
[17:46:51.862]                             muffled <- TRUE
[17:46:51.862]                             break
[17:46:51.862]                           }
[17:46:51.862]                         }
[17:46:51.862]                       }
[17:46:51.862]                       invisible(muffled)
[17:46:51.862]                     }
[17:46:51.862]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.862]                   }
[17:46:51.862]                 }
[17:46:51.862]                 else {
[17:46:51.862]                   if (TRUE) {
[17:46:51.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.862]                     {
[17:46:51.862]                       inherits <- base::inherits
[17:46:51.862]                       invokeRestart <- base::invokeRestart
[17:46:51.862]                       is.null <- base::is.null
[17:46:51.862]                       muffled <- FALSE
[17:46:51.862]                       if (inherits(cond, "message")) {
[17:46:51.862]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.862]                         if (muffled) 
[17:46:51.862]                           invokeRestart("muffleMessage")
[17:46:51.862]                       }
[17:46:51.862]                       else if (inherits(cond, "warning")) {
[17:46:51.862]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.862]                         if (muffled) 
[17:46:51.862]                           invokeRestart("muffleWarning")
[17:46:51.862]                       }
[17:46:51.862]                       else if (inherits(cond, "condition")) {
[17:46:51.862]                         if (!is.null(pattern)) {
[17:46:51.862]                           computeRestarts <- base::computeRestarts
[17:46:51.862]                           grepl <- base::grepl
[17:46:51.862]                           restarts <- computeRestarts(cond)
[17:46:51.862]                           for (restart in restarts) {
[17:46:51.862]                             name <- restart$name
[17:46:51.862]                             if (is.null(name)) 
[17:46:51.862]                               next
[17:46:51.862]                             if (!grepl(pattern, name)) 
[17:46:51.862]                               next
[17:46:51.862]                             invokeRestart(restart)
[17:46:51.862]                             muffled <- TRUE
[17:46:51.862]                             break
[17:46:51.862]                           }
[17:46:51.862]                         }
[17:46:51.862]                       }
[17:46:51.862]                       invisible(muffled)
[17:46:51.862]                     }
[17:46:51.862]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.862]                   }
[17:46:51.862]                 }
[17:46:51.862]             }
[17:46:51.862]         }))
[17:46:51.862]     }, error = function(ex) {
[17:46:51.862]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.862]                 ...future.rng), started = ...future.startTime, 
[17:46:51.862]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.862]             version = "1.8"), class = "FutureResult")
[17:46:51.862]     }, finally = {
[17:46:51.862]         if (!identical(...future.workdir, getwd())) 
[17:46:51.862]             setwd(...future.workdir)
[17:46:51.862]         {
[17:46:51.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.862]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.862]             }
[17:46:51.862]             base::options(...future.oldOptions)
[17:46:51.862]             if (.Platform$OS.type == "windows") {
[17:46:51.862]                 old_names <- names(...future.oldEnvVars)
[17:46:51.862]                 envs <- base::Sys.getenv()
[17:46:51.862]                 names <- names(envs)
[17:46:51.862]                 common <- intersect(names, old_names)
[17:46:51.862]                 added <- setdiff(names, old_names)
[17:46:51.862]                 removed <- setdiff(old_names, names)
[17:46:51.862]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.862]                   envs[common]]
[17:46:51.862]                 NAMES <- toupper(changed)
[17:46:51.862]                 args <- list()
[17:46:51.862]                 for (kk in seq_along(NAMES)) {
[17:46:51.862]                   name <- changed[[kk]]
[17:46:51.862]                   NAME <- NAMES[[kk]]
[17:46:51.862]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.862]                     next
[17:46:51.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.862]                 }
[17:46:51.862]                 NAMES <- toupper(added)
[17:46:51.862]                 for (kk in seq_along(NAMES)) {
[17:46:51.862]                   name <- added[[kk]]
[17:46:51.862]                   NAME <- NAMES[[kk]]
[17:46:51.862]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.862]                     next
[17:46:51.862]                   args[[name]] <- ""
[17:46:51.862]                 }
[17:46:51.862]                 NAMES <- toupper(removed)
[17:46:51.862]                 for (kk in seq_along(NAMES)) {
[17:46:51.862]                   name <- removed[[kk]]
[17:46:51.862]                   NAME <- NAMES[[kk]]
[17:46:51.862]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.862]                     next
[17:46:51.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.862]                 }
[17:46:51.862]                 if (length(args) > 0) 
[17:46:51.862]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.862]             }
[17:46:51.862]             else {
[17:46:51.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.862]             }
[17:46:51.862]             {
[17:46:51.862]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.862]                   0L) {
[17:46:51.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.862]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.862]                   base::options(opts)
[17:46:51.862]                 }
[17:46:51.862]                 {
[17:46:51.862]                   {
[17:46:51.862]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:51.862]                     NULL
[17:46:51.862]                   }
[17:46:51.862]                   options(future.plan = NULL)
[17:46:51.862]                   if (is.na(NA_character_)) 
[17:46:51.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.862]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.862]                     .init = FALSE)
[17:46:51.862]                 }
[17:46:51.862]             }
[17:46:51.862]         }
[17:46:51.862]     })
[17:46:51.862]     if (TRUE) {
[17:46:51.862]         base::sink(type = "output", split = FALSE)
[17:46:51.862]         if (TRUE) {
[17:46:51.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.862]         }
[17:46:51.862]         else {
[17:46:51.862]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.862]         }
[17:46:51.862]         base::close(...future.stdout)
[17:46:51.862]         ...future.stdout <- NULL
[17:46:51.862]     }
[17:46:51.862]     ...future.result$conditions <- ...future.conditions
[17:46:51.862]     ...future.result$finished <- base::Sys.time()
[17:46:51.862]     ...future.result
[17:46:51.862] }
[17:46:51.864] assign_globals() ...
[17:46:51.864] List of 1
[17:46:51.864]  $ x: num [1:5] 1 1 2 2 2
[17:46:51.864]  - attr(*, "where")=List of 1
[17:46:51.864]   ..$ x:<environment: R_EmptyEnv> 
[17:46:51.864]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:51.864]  - attr(*, "resolved")= logi FALSE
[17:46:51.864]  - attr(*, "total_size")= num 96
[17:46:51.864]  - attr(*, "already-done")= logi TRUE
[17:46:51.867] - copied ‘x’ to environment
[17:46:51.867] assign_globals() ... done
[17:46:51.867] requestCore(): workers = 2
[17:46:51.869] MulticoreFuture started
[17:46:51.870] - Launch lazy future ... done
[17:46:51.870] run() for ‘MulticoreFuture’ ... done
[17:46:51.870] result() for MulticoreFuture ...
[17:46:51.871] plan(): Setting new future strategy stack:
[17:46:51.871] List of future strategies:
[17:46:51.871] 1. sequential:
[17:46:51.871]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.871]    - tweaked: FALSE
[17:46:51.871]    - call: NULL
[17:46:51.872] plan(): nbrOfWorkers() = 1
[17:46:51.874] plan(): Setting new future strategy stack:
[17:46:51.875] List of future strategies:
[17:46:51.875] 1. multicore:
[17:46:51.875]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:51.875]    - tweaked: FALSE
[17:46:51.875]    - call: plan(strategy)
[17:46:51.880] plan(): nbrOfWorkers() = 2
[17:46:51.881] result() for MulticoreFuture ...
[17:46:51.881] result() for MulticoreFuture ... done
[17:46:51.881] result() for MulticoreFuture ... done
[17:46:51.881] result() for MulticoreFuture ...
[17:46:51.881] result() for MulticoreFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[17:46:51.884] getGlobalsAndPackages() ...
[17:46:51.884] Searching for globals...
[17:46:51.886] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[17:46:51.886] Searching for globals ... DONE
[17:46:51.886] Resolving globals: FALSE
[17:46:51.887] 
[17:46:51.887] - packages: [2] ‘stats’, ‘datasets’
[17:46:51.887] getGlobalsAndPackages() ... DONE
[17:46:51.887] run() for ‘Future’ ...
[17:46:51.888] - state: ‘created’
[17:46:51.888] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:51.892] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:51.892] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:51.892]   - Field: ‘label’
[17:46:51.892]   - Field: ‘local’
[17:46:51.892]   - Field: ‘owner’
[17:46:51.892]   - Field: ‘envir’
[17:46:51.892]   - Field: ‘workers’
[17:46:51.893]   - Field: ‘packages’
[17:46:51.893]   - Field: ‘gc’
[17:46:51.893]   - Field: ‘job’
[17:46:51.893]   - Field: ‘conditions’
[17:46:51.893]   - Field: ‘expr’
[17:46:51.893]   - Field: ‘uuid’
[17:46:51.893]   - Field: ‘seed’
[17:46:51.893]   - Field: ‘version’
[17:46:51.893]   - Field: ‘result’
[17:46:51.894]   - Field: ‘asynchronous’
[17:46:51.894]   - Field: ‘calls’
[17:46:51.894]   - Field: ‘globals’
[17:46:51.894]   - Field: ‘stdout’
[17:46:51.894]   - Field: ‘earlySignal’
[17:46:51.894]   - Field: ‘lazy’
[17:46:51.894]   - Field: ‘state’
[17:46:51.894] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:51.894] - Launch lazy future ...
[17:46:51.895] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:51.895] Packages needed by future strategies (n = 0): <none>
[17:46:51.898] {
[17:46:51.898]     {
[17:46:51.898]         {
[17:46:51.898]             ...future.startTime <- base::Sys.time()
[17:46:51.898]             {
[17:46:51.898]                 {
[17:46:51.898]                   {
[17:46:51.898]                     {
[17:46:51.898]                       {
[17:46:51.898]                         base::local({
[17:46:51.898]                           has_future <- base::requireNamespace("future", 
[17:46:51.898]                             quietly = TRUE)
[17:46:51.898]                           if (has_future) {
[17:46:51.898]                             ns <- base::getNamespace("future")
[17:46:51.898]                             version <- ns[[".package"]][["version"]]
[17:46:51.898]                             if (is.null(version)) 
[17:46:51.898]                               version <- utils::packageVersion("future")
[17:46:51.898]                           }
[17:46:51.898]                           else {
[17:46:51.898]                             version <- NULL
[17:46:51.898]                           }
[17:46:51.898]                           if (!has_future || version < "1.8.0") {
[17:46:51.898]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.898]                               "", base::R.version$version.string), 
[17:46:51.898]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:51.898]                                 base::R.version$platform, 8 * 
[17:46:51.898]                                   base::.Machine$sizeof.pointer), 
[17:46:51.898]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.898]                                 "release", "version")], collapse = " "), 
[17:46:51.898]                               hostname = base::Sys.info()[["nodename"]])
[17:46:51.898]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.898]                               info)
[17:46:51.898]                             info <- base::paste(info, collapse = "; ")
[17:46:51.898]                             if (!has_future) {
[17:46:51.898]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.898]                                 info)
[17:46:51.898]                             }
[17:46:51.898]                             else {
[17:46:51.898]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.898]                                 info, version)
[17:46:51.898]                             }
[17:46:51.898]                             base::stop(msg)
[17:46:51.898]                           }
[17:46:51.898]                         })
[17:46:51.898]                       }
[17:46:51.898]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:51.898]                       base::options(mc.cores = 1L)
[17:46:51.898]                     }
[17:46:51.898]                     base::local({
[17:46:51.898]                       for (pkg in c("stats", "datasets")) {
[17:46:51.898]                         base::loadNamespace(pkg)
[17:46:51.898]                         base::library(pkg, character.only = TRUE)
[17:46:51.898]                       }
[17:46:51.898]                     })
[17:46:51.898]                   }
[17:46:51.898]                   ...future.strategy.old <- future::plan("list")
[17:46:51.898]                   options(future.plan = NULL)
[17:46:51.898]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.898]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.898]                 }
[17:46:51.898]                 ...future.workdir <- getwd()
[17:46:51.898]             }
[17:46:51.898]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.898]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.898]         }
[17:46:51.898]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.898]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.898]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.898]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.898]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.898]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.898]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.898]             base::names(...future.oldOptions))
[17:46:51.898]     }
[17:46:51.898]     if (FALSE) {
[17:46:51.898]     }
[17:46:51.898]     else {
[17:46:51.898]         if (TRUE) {
[17:46:51.898]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.898]                 open = "w")
[17:46:51.898]         }
[17:46:51.898]         else {
[17:46:51.898]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.898]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.898]         }
[17:46:51.898]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.898]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.898]             base::sink(type = "output", split = FALSE)
[17:46:51.898]             base::close(...future.stdout)
[17:46:51.898]         }, add = TRUE)
[17:46:51.898]     }
[17:46:51.898]     ...future.frame <- base::sys.nframe()
[17:46:51.898]     ...future.conditions <- base::list()
[17:46:51.898]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.898]     if (FALSE) {
[17:46:51.898]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.898]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.898]     }
[17:46:51.898]     ...future.result <- base::tryCatch({
[17:46:51.898]         base::withCallingHandlers({
[17:46:51.898]             ...future.value <- base::withVisible(base::local({
[17:46:51.898]                 withCallingHandlers({
[17:46:51.898]                   {
[17:46:51.898]                     lm(dist ~ . - 1, data = cars)
[17:46:51.898]                   }
[17:46:51.898]                 }, immediateCondition = function(cond) {
[17:46:51.898]                   save_rds <- function (object, pathname, ...) 
[17:46:51.898]                   {
[17:46:51.898]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:51.898]                     if (file_test("-f", pathname_tmp)) {
[17:46:51.898]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.898]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:51.898]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.898]                         fi_tmp[["mtime"]])
[17:46:51.898]                     }
[17:46:51.898]                     tryCatch({
[17:46:51.898]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:51.898]                     }, error = function(ex) {
[17:46:51.898]                       msg <- conditionMessage(ex)
[17:46:51.898]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.898]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:51.898]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.898]                         fi_tmp[["mtime"]], msg)
[17:46:51.898]                       ex$message <- msg
[17:46:51.898]                       stop(ex)
[17:46:51.898]                     })
[17:46:51.898]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:51.898]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:51.898]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:51.898]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.898]                       fi <- file.info(pathname)
[17:46:51.898]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:51.898]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.898]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:51.898]                         fi[["size"]], fi[["mtime"]])
[17:46:51.898]                       stop(msg)
[17:46:51.898]                     }
[17:46:51.898]                     invisible(pathname)
[17:46:51.898]                   }
[17:46:51.898]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:51.898]                     rootPath = tempdir()) 
[17:46:51.898]                   {
[17:46:51.898]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:51.898]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:51.898]                       tmpdir = path, fileext = ".rds")
[17:46:51.898]                     save_rds(obj, file)
[17:46:51.898]                   }
[17:46:51.898]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6A38RL/.future/immediateConditions")
[17:46:51.898]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.898]                   {
[17:46:51.898]                     inherits <- base::inherits
[17:46:51.898]                     invokeRestart <- base::invokeRestart
[17:46:51.898]                     is.null <- base::is.null
[17:46:51.898]                     muffled <- FALSE
[17:46:51.898]                     if (inherits(cond, "message")) {
[17:46:51.898]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:51.898]                       if (muffled) 
[17:46:51.898]                         invokeRestart("muffleMessage")
[17:46:51.898]                     }
[17:46:51.898]                     else if (inherits(cond, "warning")) {
[17:46:51.898]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:51.898]                       if (muffled) 
[17:46:51.898]                         invokeRestart("muffleWarning")
[17:46:51.898]                     }
[17:46:51.898]                     else if (inherits(cond, "condition")) {
[17:46:51.898]                       if (!is.null(pattern)) {
[17:46:51.898]                         computeRestarts <- base::computeRestarts
[17:46:51.898]                         grepl <- base::grepl
[17:46:51.898]                         restarts <- computeRestarts(cond)
[17:46:51.898]                         for (restart in restarts) {
[17:46:51.898]                           name <- restart$name
[17:46:51.898]                           if (is.null(name)) 
[17:46:51.898]                             next
[17:46:51.898]                           if (!grepl(pattern, name)) 
[17:46:51.898]                             next
[17:46:51.898]                           invokeRestart(restart)
[17:46:51.898]                           muffled <- TRUE
[17:46:51.898]                           break
[17:46:51.898]                         }
[17:46:51.898]                       }
[17:46:51.898]                     }
[17:46:51.898]                     invisible(muffled)
[17:46:51.898]                   }
[17:46:51.898]                   muffleCondition(cond)
[17:46:51.898]                 })
[17:46:51.898]             }))
[17:46:51.898]             future::FutureResult(value = ...future.value$value, 
[17:46:51.898]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.898]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.898]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.898]                     ...future.globalenv.names))
[17:46:51.898]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.898]         }, condition = base::local({
[17:46:51.898]             c <- base::c
[17:46:51.898]             inherits <- base::inherits
[17:46:51.898]             invokeRestart <- base::invokeRestart
[17:46:51.898]             length <- base::length
[17:46:51.898]             list <- base::list
[17:46:51.898]             seq.int <- base::seq.int
[17:46:51.898]             signalCondition <- base::signalCondition
[17:46:51.898]             sys.calls <- base::sys.calls
[17:46:51.898]             `[[` <- base::`[[`
[17:46:51.898]             `+` <- base::`+`
[17:46:51.898]             `<<-` <- base::`<<-`
[17:46:51.898]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.898]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.898]                   3L)]
[17:46:51.898]             }
[17:46:51.898]             function(cond) {
[17:46:51.898]                 is_error <- inherits(cond, "error")
[17:46:51.898]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.898]                   NULL)
[17:46:51.898]                 if (is_error) {
[17:46:51.898]                   sessionInformation <- function() {
[17:46:51.898]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.898]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.898]                       search = base::search(), system = base::Sys.info())
[17:46:51.898]                   }
[17:46:51.898]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.898]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.898]                     cond$call), session = sessionInformation(), 
[17:46:51.898]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.898]                   signalCondition(cond)
[17:46:51.898]                 }
[17:46:51.898]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.898]                 "immediateCondition"))) {
[17:46:51.898]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.898]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.898]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.898]                   if (TRUE && !signal) {
[17:46:51.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.898]                     {
[17:46:51.898]                       inherits <- base::inherits
[17:46:51.898]                       invokeRestart <- base::invokeRestart
[17:46:51.898]                       is.null <- base::is.null
[17:46:51.898]                       muffled <- FALSE
[17:46:51.898]                       if (inherits(cond, "message")) {
[17:46:51.898]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.898]                         if (muffled) 
[17:46:51.898]                           invokeRestart("muffleMessage")
[17:46:51.898]                       }
[17:46:51.898]                       else if (inherits(cond, "warning")) {
[17:46:51.898]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.898]                         if (muffled) 
[17:46:51.898]                           invokeRestart("muffleWarning")
[17:46:51.898]                       }
[17:46:51.898]                       else if (inherits(cond, "condition")) {
[17:46:51.898]                         if (!is.null(pattern)) {
[17:46:51.898]                           computeRestarts <- base::computeRestarts
[17:46:51.898]                           grepl <- base::grepl
[17:46:51.898]                           restarts <- computeRestarts(cond)
[17:46:51.898]                           for (restart in restarts) {
[17:46:51.898]                             name <- restart$name
[17:46:51.898]                             if (is.null(name)) 
[17:46:51.898]                               next
[17:46:51.898]                             if (!grepl(pattern, name)) 
[17:46:51.898]                               next
[17:46:51.898]                             invokeRestart(restart)
[17:46:51.898]                             muffled <- TRUE
[17:46:51.898]                             break
[17:46:51.898]                           }
[17:46:51.898]                         }
[17:46:51.898]                       }
[17:46:51.898]                       invisible(muffled)
[17:46:51.898]                     }
[17:46:51.898]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.898]                   }
[17:46:51.898]                 }
[17:46:51.898]                 else {
[17:46:51.898]                   if (TRUE) {
[17:46:51.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.898]                     {
[17:46:51.898]                       inherits <- base::inherits
[17:46:51.898]                       invokeRestart <- base::invokeRestart
[17:46:51.898]                       is.null <- base::is.null
[17:46:51.898]                       muffled <- FALSE
[17:46:51.898]                       if (inherits(cond, "message")) {
[17:46:51.898]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.898]                         if (muffled) 
[17:46:51.898]                           invokeRestart("muffleMessage")
[17:46:51.898]                       }
[17:46:51.898]                       else if (inherits(cond, "warning")) {
[17:46:51.898]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.898]                         if (muffled) 
[17:46:51.898]                           invokeRestart("muffleWarning")
[17:46:51.898]                       }
[17:46:51.898]                       else if (inherits(cond, "condition")) {
[17:46:51.898]                         if (!is.null(pattern)) {
[17:46:51.898]                           computeRestarts <- base::computeRestarts
[17:46:51.898]                           grepl <- base::grepl
[17:46:51.898]                           restarts <- computeRestarts(cond)
[17:46:51.898]                           for (restart in restarts) {
[17:46:51.898]                             name <- restart$name
[17:46:51.898]                             if (is.null(name)) 
[17:46:51.898]                               next
[17:46:51.898]                             if (!grepl(pattern, name)) 
[17:46:51.898]                               next
[17:46:51.898]                             invokeRestart(restart)
[17:46:51.898]                             muffled <- TRUE
[17:46:51.898]                             break
[17:46:51.898]                           }
[17:46:51.898]                         }
[17:46:51.898]                       }
[17:46:51.898]                       invisible(muffled)
[17:46:51.898]                     }
[17:46:51.898]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.898]                   }
[17:46:51.898]                 }
[17:46:51.898]             }
[17:46:51.898]         }))
[17:46:51.898]     }, error = function(ex) {
[17:46:51.898]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.898]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.898]                 ...future.rng), started = ...future.startTime, 
[17:46:51.898]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.898]             version = "1.8"), class = "FutureResult")
[17:46:51.898]     }, finally = {
[17:46:51.898]         if (!identical(...future.workdir, getwd())) 
[17:46:51.898]             setwd(...future.workdir)
[17:46:51.898]         {
[17:46:51.898]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.898]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.898]             }
[17:46:51.898]             base::options(...future.oldOptions)
[17:46:51.898]             if (.Platform$OS.type == "windows") {
[17:46:51.898]                 old_names <- names(...future.oldEnvVars)
[17:46:51.898]                 envs <- base::Sys.getenv()
[17:46:51.898]                 names <- names(envs)
[17:46:51.898]                 common <- intersect(names, old_names)
[17:46:51.898]                 added <- setdiff(names, old_names)
[17:46:51.898]                 removed <- setdiff(old_names, names)
[17:46:51.898]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.898]                   envs[common]]
[17:46:51.898]                 NAMES <- toupper(changed)
[17:46:51.898]                 args <- list()
[17:46:51.898]                 for (kk in seq_along(NAMES)) {
[17:46:51.898]                   name <- changed[[kk]]
[17:46:51.898]                   NAME <- NAMES[[kk]]
[17:46:51.898]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.898]                     next
[17:46:51.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.898]                 }
[17:46:51.898]                 NAMES <- toupper(added)
[17:46:51.898]                 for (kk in seq_along(NAMES)) {
[17:46:51.898]                   name <- added[[kk]]
[17:46:51.898]                   NAME <- NAMES[[kk]]
[17:46:51.898]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.898]                     next
[17:46:51.898]                   args[[name]] <- ""
[17:46:51.898]                 }
[17:46:51.898]                 NAMES <- toupper(removed)
[17:46:51.898]                 for (kk in seq_along(NAMES)) {
[17:46:51.898]                   name <- removed[[kk]]
[17:46:51.898]                   NAME <- NAMES[[kk]]
[17:46:51.898]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.898]                     next
[17:46:51.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.898]                 }
[17:46:51.898]                 if (length(args) > 0) 
[17:46:51.898]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.898]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.898]             }
[17:46:51.898]             else {
[17:46:51.898]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.898]             }
[17:46:51.898]             {
[17:46:51.898]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.898]                   0L) {
[17:46:51.898]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.898]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.898]                   base::options(opts)
[17:46:51.898]                 }
[17:46:51.898]                 {
[17:46:51.898]                   {
[17:46:51.898]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:51.898]                     NULL
[17:46:51.898]                   }
[17:46:51.898]                   options(future.plan = NULL)
[17:46:51.898]                   if (is.na(NA_character_)) 
[17:46:51.898]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.898]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.898]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.898]                     .init = FALSE)
[17:46:51.898]                 }
[17:46:51.898]             }
[17:46:51.898]         }
[17:46:51.898]     })
[17:46:51.898]     if (TRUE) {
[17:46:51.898]         base::sink(type = "output", split = FALSE)
[17:46:51.898]         if (TRUE) {
[17:46:51.898]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.898]         }
[17:46:51.898]         else {
[17:46:51.898]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.898]         }
[17:46:51.898]         base::close(...future.stdout)
[17:46:51.898]         ...future.stdout <- NULL
[17:46:51.898]     }
[17:46:51.898]     ...future.result$conditions <- ...future.conditions
[17:46:51.898]     ...future.result$finished <- base::Sys.time()
[17:46:51.898]     ...future.result
[17:46:51.898] }
[17:46:51.901] requestCore(): workers = 2
[17:46:51.902] MulticoreFuture started
[17:46:51.903] - Launch lazy future ... done
[17:46:51.903] run() for ‘MulticoreFuture’ ... done
[17:46:51.904] result() for MulticoreFuture ...
[17:46:51.904] plan(): Setting new future strategy stack:
[17:46:51.904] List of future strategies:
[17:46:51.904] 1. sequential:
[17:46:51.904]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.904]    - tweaked: FALSE
[17:46:51.904]    - call: NULL
[17:46:51.905] plan(): nbrOfWorkers() = 1
[17:46:51.909] plan(): Setting new future strategy stack:
[17:46:51.909] List of future strategies:
[17:46:51.909] 1. multicore:
[17:46:51.909]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:51.909]    - tweaked: FALSE
[17:46:51.909]    - call: plan(strategy)
[17:46:51.914] plan(): nbrOfWorkers() = 2
[17:46:51.916] result() for MulticoreFuture ...
[17:46:51.916] result() for MulticoreFuture ... done
[17:46:51.916] result() for MulticoreFuture ... done
[17:46:51.917] result() for MulticoreFuture ...
[17:46:51.917] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[17:46:51.920] getGlobalsAndPackages() ...
[17:46:51.920] Searching for globals...
[17:46:51.922] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[17:46:51.923] Searching for globals ... DONE
[17:46:51.923] Resolving globals: FALSE
[17:46:51.923] 
[17:46:51.923] - packages: [2] ‘stats’, ‘datasets’
[17:46:51.924] getGlobalsAndPackages() ... DONE
[17:46:51.924] run() for ‘Future’ ...
[17:46:51.924] - state: ‘created’
[17:46:51.924] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:51.928] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:51.929] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:51.929]   - Field: ‘label’
[17:46:51.929]   - Field: ‘local’
[17:46:51.929]   - Field: ‘owner’
[17:46:51.929]   - Field: ‘envir’
[17:46:51.929]   - Field: ‘workers’
[17:46:51.929]   - Field: ‘packages’
[17:46:51.929]   - Field: ‘gc’
[17:46:51.930]   - Field: ‘job’
[17:46:51.930]   - Field: ‘conditions’
[17:46:51.930]   - Field: ‘expr’
[17:46:51.930]   - Field: ‘uuid’
[17:46:51.930]   - Field: ‘seed’
[17:46:51.930]   - Field: ‘version’
[17:46:51.930]   - Field: ‘result’
[17:46:51.930]   - Field: ‘asynchronous’
[17:46:51.930]   - Field: ‘calls’
[17:46:51.930]   - Field: ‘globals’
[17:46:51.931]   - Field: ‘stdout’
[17:46:51.931]   - Field: ‘earlySignal’
[17:46:51.931]   - Field: ‘lazy’
[17:46:51.931]   - Field: ‘state’
[17:46:51.931] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:51.931] - Launch lazy future ...
[17:46:51.932] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:51.932] Packages needed by future strategies (n = 0): <none>
[17:46:51.932] {
[17:46:51.932]     {
[17:46:51.932]         {
[17:46:51.932]             ...future.startTime <- base::Sys.time()
[17:46:51.932]             {
[17:46:51.932]                 {
[17:46:51.932]                   {
[17:46:51.932]                     {
[17:46:51.932]                       {
[17:46:51.932]                         base::local({
[17:46:51.932]                           has_future <- base::requireNamespace("future", 
[17:46:51.932]                             quietly = TRUE)
[17:46:51.932]                           if (has_future) {
[17:46:51.932]                             ns <- base::getNamespace("future")
[17:46:51.932]                             version <- ns[[".package"]][["version"]]
[17:46:51.932]                             if (is.null(version)) 
[17:46:51.932]                               version <- utils::packageVersion("future")
[17:46:51.932]                           }
[17:46:51.932]                           else {
[17:46:51.932]                             version <- NULL
[17:46:51.932]                           }
[17:46:51.932]                           if (!has_future || version < "1.8.0") {
[17:46:51.932]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.932]                               "", base::R.version$version.string), 
[17:46:51.932]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:51.932]                                 base::R.version$platform, 8 * 
[17:46:51.932]                                   base::.Machine$sizeof.pointer), 
[17:46:51.932]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.932]                                 "release", "version")], collapse = " "), 
[17:46:51.932]                               hostname = base::Sys.info()[["nodename"]])
[17:46:51.932]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.932]                               info)
[17:46:51.932]                             info <- base::paste(info, collapse = "; ")
[17:46:51.932]                             if (!has_future) {
[17:46:51.932]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.932]                                 info)
[17:46:51.932]                             }
[17:46:51.932]                             else {
[17:46:51.932]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.932]                                 info, version)
[17:46:51.932]                             }
[17:46:51.932]                             base::stop(msg)
[17:46:51.932]                           }
[17:46:51.932]                         })
[17:46:51.932]                       }
[17:46:51.932]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:51.932]                       base::options(mc.cores = 1L)
[17:46:51.932]                     }
[17:46:51.932]                     base::local({
[17:46:51.932]                       for (pkg in c("stats", "datasets")) {
[17:46:51.932]                         base::loadNamespace(pkg)
[17:46:51.932]                         base::library(pkg, character.only = TRUE)
[17:46:51.932]                       }
[17:46:51.932]                     })
[17:46:51.932]                   }
[17:46:51.932]                   ...future.strategy.old <- future::plan("list")
[17:46:51.932]                   options(future.plan = NULL)
[17:46:51.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.932]                 }
[17:46:51.932]                 ...future.workdir <- getwd()
[17:46:51.932]             }
[17:46:51.932]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.932]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.932]         }
[17:46:51.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.932]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.932]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.932]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.932]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.932]             base::names(...future.oldOptions))
[17:46:51.932]     }
[17:46:51.932]     if (FALSE) {
[17:46:51.932]     }
[17:46:51.932]     else {
[17:46:51.932]         if (TRUE) {
[17:46:51.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.932]                 open = "w")
[17:46:51.932]         }
[17:46:51.932]         else {
[17:46:51.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.932]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.932]         }
[17:46:51.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.932]             base::sink(type = "output", split = FALSE)
[17:46:51.932]             base::close(...future.stdout)
[17:46:51.932]         }, add = TRUE)
[17:46:51.932]     }
[17:46:51.932]     ...future.frame <- base::sys.nframe()
[17:46:51.932]     ...future.conditions <- base::list()
[17:46:51.932]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.932]     if (FALSE) {
[17:46:51.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.932]     }
[17:46:51.932]     ...future.result <- base::tryCatch({
[17:46:51.932]         base::withCallingHandlers({
[17:46:51.932]             ...future.value <- base::withVisible(base::local({
[17:46:51.932]                 withCallingHandlers({
[17:46:51.932]                   {
[17:46:51.932]                     lm(dist ~ . + 0, data = cars)
[17:46:51.932]                   }
[17:46:51.932]                 }, immediateCondition = function(cond) {
[17:46:51.932]                   save_rds <- function (object, pathname, ...) 
[17:46:51.932]                   {
[17:46:51.932]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:51.932]                     if (file_test("-f", pathname_tmp)) {
[17:46:51.932]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.932]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:51.932]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.932]                         fi_tmp[["mtime"]])
[17:46:51.932]                     }
[17:46:51.932]                     tryCatch({
[17:46:51.932]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:51.932]                     }, error = function(ex) {
[17:46:51.932]                       msg <- conditionMessage(ex)
[17:46:51.932]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.932]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:51.932]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.932]                         fi_tmp[["mtime"]], msg)
[17:46:51.932]                       ex$message <- msg
[17:46:51.932]                       stop(ex)
[17:46:51.932]                     })
[17:46:51.932]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:51.932]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:51.932]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:51.932]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.932]                       fi <- file.info(pathname)
[17:46:51.932]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:51.932]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.932]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:51.932]                         fi[["size"]], fi[["mtime"]])
[17:46:51.932]                       stop(msg)
[17:46:51.932]                     }
[17:46:51.932]                     invisible(pathname)
[17:46:51.932]                   }
[17:46:51.932]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:51.932]                     rootPath = tempdir()) 
[17:46:51.932]                   {
[17:46:51.932]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:51.932]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:51.932]                       tmpdir = path, fileext = ".rds")
[17:46:51.932]                     save_rds(obj, file)
[17:46:51.932]                   }
[17:46:51.932]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6A38RL/.future/immediateConditions")
[17:46:51.932]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.932]                   {
[17:46:51.932]                     inherits <- base::inherits
[17:46:51.932]                     invokeRestart <- base::invokeRestart
[17:46:51.932]                     is.null <- base::is.null
[17:46:51.932]                     muffled <- FALSE
[17:46:51.932]                     if (inherits(cond, "message")) {
[17:46:51.932]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:51.932]                       if (muffled) 
[17:46:51.932]                         invokeRestart("muffleMessage")
[17:46:51.932]                     }
[17:46:51.932]                     else if (inherits(cond, "warning")) {
[17:46:51.932]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:51.932]                       if (muffled) 
[17:46:51.932]                         invokeRestart("muffleWarning")
[17:46:51.932]                     }
[17:46:51.932]                     else if (inherits(cond, "condition")) {
[17:46:51.932]                       if (!is.null(pattern)) {
[17:46:51.932]                         computeRestarts <- base::computeRestarts
[17:46:51.932]                         grepl <- base::grepl
[17:46:51.932]                         restarts <- computeRestarts(cond)
[17:46:51.932]                         for (restart in restarts) {
[17:46:51.932]                           name <- restart$name
[17:46:51.932]                           if (is.null(name)) 
[17:46:51.932]                             next
[17:46:51.932]                           if (!grepl(pattern, name)) 
[17:46:51.932]                             next
[17:46:51.932]                           invokeRestart(restart)
[17:46:51.932]                           muffled <- TRUE
[17:46:51.932]                           break
[17:46:51.932]                         }
[17:46:51.932]                       }
[17:46:51.932]                     }
[17:46:51.932]                     invisible(muffled)
[17:46:51.932]                   }
[17:46:51.932]                   muffleCondition(cond)
[17:46:51.932]                 })
[17:46:51.932]             }))
[17:46:51.932]             future::FutureResult(value = ...future.value$value, 
[17:46:51.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.932]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.932]                     ...future.globalenv.names))
[17:46:51.932]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.932]         }, condition = base::local({
[17:46:51.932]             c <- base::c
[17:46:51.932]             inherits <- base::inherits
[17:46:51.932]             invokeRestart <- base::invokeRestart
[17:46:51.932]             length <- base::length
[17:46:51.932]             list <- base::list
[17:46:51.932]             seq.int <- base::seq.int
[17:46:51.932]             signalCondition <- base::signalCondition
[17:46:51.932]             sys.calls <- base::sys.calls
[17:46:51.932]             `[[` <- base::`[[`
[17:46:51.932]             `+` <- base::`+`
[17:46:51.932]             `<<-` <- base::`<<-`
[17:46:51.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.932]                   3L)]
[17:46:51.932]             }
[17:46:51.932]             function(cond) {
[17:46:51.932]                 is_error <- inherits(cond, "error")
[17:46:51.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.932]                   NULL)
[17:46:51.932]                 if (is_error) {
[17:46:51.932]                   sessionInformation <- function() {
[17:46:51.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.932]                       search = base::search(), system = base::Sys.info())
[17:46:51.932]                   }
[17:46:51.932]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.932]                     cond$call), session = sessionInformation(), 
[17:46:51.932]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.932]                   signalCondition(cond)
[17:46:51.932]                 }
[17:46:51.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.932]                 "immediateCondition"))) {
[17:46:51.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.932]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.932]                   if (TRUE && !signal) {
[17:46:51.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.932]                     {
[17:46:51.932]                       inherits <- base::inherits
[17:46:51.932]                       invokeRestart <- base::invokeRestart
[17:46:51.932]                       is.null <- base::is.null
[17:46:51.932]                       muffled <- FALSE
[17:46:51.932]                       if (inherits(cond, "message")) {
[17:46:51.932]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.932]                         if (muffled) 
[17:46:51.932]                           invokeRestart("muffleMessage")
[17:46:51.932]                       }
[17:46:51.932]                       else if (inherits(cond, "warning")) {
[17:46:51.932]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.932]                         if (muffled) 
[17:46:51.932]                           invokeRestart("muffleWarning")
[17:46:51.932]                       }
[17:46:51.932]                       else if (inherits(cond, "condition")) {
[17:46:51.932]                         if (!is.null(pattern)) {
[17:46:51.932]                           computeRestarts <- base::computeRestarts
[17:46:51.932]                           grepl <- base::grepl
[17:46:51.932]                           restarts <- computeRestarts(cond)
[17:46:51.932]                           for (restart in restarts) {
[17:46:51.932]                             name <- restart$name
[17:46:51.932]                             if (is.null(name)) 
[17:46:51.932]                               next
[17:46:51.932]                             if (!grepl(pattern, name)) 
[17:46:51.932]                               next
[17:46:51.932]                             invokeRestart(restart)
[17:46:51.932]                             muffled <- TRUE
[17:46:51.932]                             break
[17:46:51.932]                           }
[17:46:51.932]                         }
[17:46:51.932]                       }
[17:46:51.932]                       invisible(muffled)
[17:46:51.932]                     }
[17:46:51.932]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.932]                   }
[17:46:51.932]                 }
[17:46:51.932]                 else {
[17:46:51.932]                   if (TRUE) {
[17:46:51.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.932]                     {
[17:46:51.932]                       inherits <- base::inherits
[17:46:51.932]                       invokeRestart <- base::invokeRestart
[17:46:51.932]                       is.null <- base::is.null
[17:46:51.932]                       muffled <- FALSE
[17:46:51.932]                       if (inherits(cond, "message")) {
[17:46:51.932]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.932]                         if (muffled) 
[17:46:51.932]                           invokeRestart("muffleMessage")
[17:46:51.932]                       }
[17:46:51.932]                       else if (inherits(cond, "warning")) {
[17:46:51.932]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.932]                         if (muffled) 
[17:46:51.932]                           invokeRestart("muffleWarning")
[17:46:51.932]                       }
[17:46:51.932]                       else if (inherits(cond, "condition")) {
[17:46:51.932]                         if (!is.null(pattern)) {
[17:46:51.932]                           computeRestarts <- base::computeRestarts
[17:46:51.932]                           grepl <- base::grepl
[17:46:51.932]                           restarts <- computeRestarts(cond)
[17:46:51.932]                           for (restart in restarts) {
[17:46:51.932]                             name <- restart$name
[17:46:51.932]                             if (is.null(name)) 
[17:46:51.932]                               next
[17:46:51.932]                             if (!grepl(pattern, name)) 
[17:46:51.932]                               next
[17:46:51.932]                             invokeRestart(restart)
[17:46:51.932]                             muffled <- TRUE
[17:46:51.932]                             break
[17:46:51.932]                           }
[17:46:51.932]                         }
[17:46:51.932]                       }
[17:46:51.932]                       invisible(muffled)
[17:46:51.932]                     }
[17:46:51.932]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.932]                   }
[17:46:51.932]                 }
[17:46:51.932]             }
[17:46:51.932]         }))
[17:46:51.932]     }, error = function(ex) {
[17:46:51.932]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.932]                 ...future.rng), started = ...future.startTime, 
[17:46:51.932]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.932]             version = "1.8"), class = "FutureResult")
[17:46:51.932]     }, finally = {
[17:46:51.932]         if (!identical(...future.workdir, getwd())) 
[17:46:51.932]             setwd(...future.workdir)
[17:46:51.932]         {
[17:46:51.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.932]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.932]             }
[17:46:51.932]             base::options(...future.oldOptions)
[17:46:51.932]             if (.Platform$OS.type == "windows") {
[17:46:51.932]                 old_names <- names(...future.oldEnvVars)
[17:46:51.932]                 envs <- base::Sys.getenv()
[17:46:51.932]                 names <- names(envs)
[17:46:51.932]                 common <- intersect(names, old_names)
[17:46:51.932]                 added <- setdiff(names, old_names)
[17:46:51.932]                 removed <- setdiff(old_names, names)
[17:46:51.932]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.932]                   envs[common]]
[17:46:51.932]                 NAMES <- toupper(changed)
[17:46:51.932]                 args <- list()
[17:46:51.932]                 for (kk in seq_along(NAMES)) {
[17:46:51.932]                   name <- changed[[kk]]
[17:46:51.932]                   NAME <- NAMES[[kk]]
[17:46:51.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.932]                     next
[17:46:51.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.932]                 }
[17:46:51.932]                 NAMES <- toupper(added)
[17:46:51.932]                 for (kk in seq_along(NAMES)) {
[17:46:51.932]                   name <- added[[kk]]
[17:46:51.932]                   NAME <- NAMES[[kk]]
[17:46:51.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.932]                     next
[17:46:51.932]                   args[[name]] <- ""
[17:46:51.932]                 }
[17:46:51.932]                 NAMES <- toupper(removed)
[17:46:51.932]                 for (kk in seq_along(NAMES)) {
[17:46:51.932]                   name <- removed[[kk]]
[17:46:51.932]                   NAME <- NAMES[[kk]]
[17:46:51.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.932]                     next
[17:46:51.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.932]                 }
[17:46:51.932]                 if (length(args) > 0) 
[17:46:51.932]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.932]             }
[17:46:51.932]             else {
[17:46:51.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.932]             }
[17:46:51.932]             {
[17:46:51.932]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.932]                   0L) {
[17:46:51.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.932]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.932]                   base::options(opts)
[17:46:51.932]                 }
[17:46:51.932]                 {
[17:46:51.932]                   {
[17:46:51.932]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:51.932]                     NULL
[17:46:51.932]                   }
[17:46:51.932]                   options(future.plan = NULL)
[17:46:51.932]                   if (is.na(NA_character_)) 
[17:46:51.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.932]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.932]                     .init = FALSE)
[17:46:51.932]                 }
[17:46:51.932]             }
[17:46:51.932]         }
[17:46:51.932]     })
[17:46:51.932]     if (TRUE) {
[17:46:51.932]         base::sink(type = "output", split = FALSE)
[17:46:51.932]         if (TRUE) {
[17:46:51.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.932]         }
[17:46:51.932]         else {
[17:46:51.932]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.932]         }
[17:46:51.932]         base::close(...future.stdout)
[17:46:51.932]         ...future.stdout <- NULL
[17:46:51.932]     }
[17:46:51.932]     ...future.result$conditions <- ...future.conditions
[17:46:51.932]     ...future.result$finished <- base::Sys.time()
[17:46:51.932]     ...future.result
[17:46:51.932] }
[17:46:51.935] requestCore(): workers = 2
[17:46:51.937] MulticoreFuture started
[17:46:51.937] - Launch lazy future ... done
[17:46:51.938] run() for ‘MulticoreFuture’ ... done
[17:46:51.938] result() for MulticoreFuture ...
[17:46:51.939] plan(): Setting new future strategy stack:
[17:46:51.939] List of future strategies:
[17:46:51.939] 1. sequential:
[17:46:51.939]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.939]    - tweaked: FALSE
[17:46:51.939]    - call: NULL
[17:46:51.940] plan(): nbrOfWorkers() = 1
[17:46:51.943] plan(): Setting new future strategy stack:
[17:46:51.943] List of future strategies:
[17:46:51.943] 1. multicore:
[17:46:51.943]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:51.943]    - tweaked: FALSE
[17:46:51.943]    - call: plan(strategy)
[17:46:51.948] plan(): nbrOfWorkers() = 2
[17:46:51.950] result() for MulticoreFuture ...
[17:46:51.950] result() for MulticoreFuture ... done
[17:46:51.950] result() for MulticoreFuture ... done
[17:46:51.951] result() for MulticoreFuture ...
[17:46:51.951] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[17:46:51.954] getGlobalsAndPackages() ...
[17:46:51.954] Searching for globals...
[17:46:51.959] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[17:46:51.959] Searching for globals ... DONE
[17:46:51.959] Resolving globals: FALSE
[17:46:51.960] 
[17:46:51.960] - packages: [2] ‘stats’, ‘datasets’
[17:46:51.960] getGlobalsAndPackages() ... DONE
[17:46:51.961] run() for ‘Future’ ...
[17:46:51.961] - state: ‘created’
[17:46:51.961] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:51.965] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:51.965] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:51.965]   - Field: ‘label’
[17:46:51.965]   - Field: ‘local’
[17:46:51.966]   - Field: ‘owner’
[17:46:51.966]   - Field: ‘envir’
[17:46:51.966]   - Field: ‘workers’
[17:46:51.966]   - Field: ‘packages’
[17:46:51.966]   - Field: ‘gc’
[17:46:51.966]   - Field: ‘job’
[17:46:51.966]   - Field: ‘conditions’
[17:46:51.966]   - Field: ‘expr’
[17:46:51.966]   - Field: ‘uuid’
[17:46:51.967]   - Field: ‘seed’
[17:46:51.967]   - Field: ‘version’
[17:46:51.967]   - Field: ‘result’
[17:46:51.967]   - Field: ‘asynchronous’
[17:46:51.967]   - Field: ‘calls’
[17:46:51.967]   - Field: ‘globals’
[17:46:51.967]   - Field: ‘stdout’
[17:46:51.967]   - Field: ‘earlySignal’
[17:46:51.967]   - Field: ‘lazy’
[17:46:51.968]   - Field: ‘state’
[17:46:51.968] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:51.968] - Launch lazy future ...
[17:46:51.968] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:51.968] Packages needed by future strategies (n = 0): <none>
[17:46:51.969] {
[17:46:51.969]     {
[17:46:51.969]         {
[17:46:51.969]             ...future.startTime <- base::Sys.time()
[17:46:51.969]             {
[17:46:51.969]                 {
[17:46:51.969]                   {
[17:46:51.969]                     {
[17:46:51.969]                       {
[17:46:51.969]                         base::local({
[17:46:51.969]                           has_future <- base::requireNamespace("future", 
[17:46:51.969]                             quietly = TRUE)
[17:46:51.969]                           if (has_future) {
[17:46:51.969]                             ns <- base::getNamespace("future")
[17:46:51.969]                             version <- ns[[".package"]][["version"]]
[17:46:51.969]                             if (is.null(version)) 
[17:46:51.969]                               version <- utils::packageVersion("future")
[17:46:51.969]                           }
[17:46:51.969]                           else {
[17:46:51.969]                             version <- NULL
[17:46:51.969]                           }
[17:46:51.969]                           if (!has_future || version < "1.8.0") {
[17:46:51.969]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:51.969]                               "", base::R.version$version.string), 
[17:46:51.969]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:51.969]                                 base::R.version$platform, 8 * 
[17:46:51.969]                                   base::.Machine$sizeof.pointer), 
[17:46:51.969]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:51.969]                                 "release", "version")], collapse = " "), 
[17:46:51.969]                               hostname = base::Sys.info()[["nodename"]])
[17:46:51.969]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:51.969]                               info)
[17:46:51.969]                             info <- base::paste(info, collapse = "; ")
[17:46:51.969]                             if (!has_future) {
[17:46:51.969]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:51.969]                                 info)
[17:46:51.969]                             }
[17:46:51.969]                             else {
[17:46:51.969]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:51.969]                                 info, version)
[17:46:51.969]                             }
[17:46:51.969]                             base::stop(msg)
[17:46:51.969]                           }
[17:46:51.969]                         })
[17:46:51.969]                       }
[17:46:51.969]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:51.969]                       base::options(mc.cores = 1L)
[17:46:51.969]                     }
[17:46:51.969]                     base::local({
[17:46:51.969]                       for (pkg in c("stats", "datasets")) {
[17:46:51.969]                         base::loadNamespace(pkg)
[17:46:51.969]                         base::library(pkg, character.only = TRUE)
[17:46:51.969]                       }
[17:46:51.969]                     })
[17:46:51.969]                   }
[17:46:51.969]                   ...future.strategy.old <- future::plan("list")
[17:46:51.969]                   options(future.plan = NULL)
[17:46:51.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:51.969]                 }
[17:46:51.969]                 ...future.workdir <- getwd()
[17:46:51.969]             }
[17:46:51.969]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:51.969]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:51.969]         }
[17:46:51.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:51.969]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:51.969]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:51.969]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:51.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:51.969]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:51.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:51.969]             base::names(...future.oldOptions))
[17:46:51.969]     }
[17:46:51.969]     if (FALSE) {
[17:46:51.969]     }
[17:46:51.969]     else {
[17:46:51.969]         if (TRUE) {
[17:46:51.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:51.969]                 open = "w")
[17:46:51.969]         }
[17:46:51.969]         else {
[17:46:51.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:51.969]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:51.969]         }
[17:46:51.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:51.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:51.969]             base::sink(type = "output", split = FALSE)
[17:46:51.969]             base::close(...future.stdout)
[17:46:51.969]         }, add = TRUE)
[17:46:51.969]     }
[17:46:51.969]     ...future.frame <- base::sys.nframe()
[17:46:51.969]     ...future.conditions <- base::list()
[17:46:51.969]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:51.969]     if (FALSE) {
[17:46:51.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:51.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:51.969]     }
[17:46:51.969]     ...future.result <- base::tryCatch({
[17:46:51.969]         base::withCallingHandlers({
[17:46:51.969]             ...future.value <- base::withVisible(base::local({
[17:46:51.969]                 withCallingHandlers({
[17:46:51.969]                   {
[17:46:51.969]                     lm(dist ~ speed + speed^2, data = cars)
[17:46:51.969]                   }
[17:46:51.969]                 }, immediateCondition = function(cond) {
[17:46:51.969]                   save_rds <- function (object, pathname, ...) 
[17:46:51.969]                   {
[17:46:51.969]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:51.969]                     if (file_test("-f", pathname_tmp)) {
[17:46:51.969]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.969]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:51.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.969]                         fi_tmp[["mtime"]])
[17:46:51.969]                     }
[17:46:51.969]                     tryCatch({
[17:46:51.969]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:51.969]                     }, error = function(ex) {
[17:46:51.969]                       msg <- conditionMessage(ex)
[17:46:51.969]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.969]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:51.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.969]                         fi_tmp[["mtime"]], msg)
[17:46:51.969]                       ex$message <- msg
[17:46:51.969]                       stop(ex)
[17:46:51.969]                     })
[17:46:51.969]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:51.969]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:51.969]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:51.969]                       fi_tmp <- file.info(pathname_tmp)
[17:46:51.969]                       fi <- file.info(pathname)
[17:46:51.969]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:51.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:51.969]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:51.969]                         fi[["size"]], fi[["mtime"]])
[17:46:51.969]                       stop(msg)
[17:46:51.969]                     }
[17:46:51.969]                     invisible(pathname)
[17:46:51.969]                   }
[17:46:51.969]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:51.969]                     rootPath = tempdir()) 
[17:46:51.969]                   {
[17:46:51.969]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:51.969]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:51.969]                       tmpdir = path, fileext = ".rds")
[17:46:51.969]                     save_rds(obj, file)
[17:46:51.969]                   }
[17:46:51.969]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6A38RL/.future/immediateConditions")
[17:46:51.969]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.969]                   {
[17:46:51.969]                     inherits <- base::inherits
[17:46:51.969]                     invokeRestart <- base::invokeRestart
[17:46:51.969]                     is.null <- base::is.null
[17:46:51.969]                     muffled <- FALSE
[17:46:51.969]                     if (inherits(cond, "message")) {
[17:46:51.969]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:51.969]                       if (muffled) 
[17:46:51.969]                         invokeRestart("muffleMessage")
[17:46:51.969]                     }
[17:46:51.969]                     else if (inherits(cond, "warning")) {
[17:46:51.969]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:51.969]                       if (muffled) 
[17:46:51.969]                         invokeRestart("muffleWarning")
[17:46:51.969]                     }
[17:46:51.969]                     else if (inherits(cond, "condition")) {
[17:46:51.969]                       if (!is.null(pattern)) {
[17:46:51.969]                         computeRestarts <- base::computeRestarts
[17:46:51.969]                         grepl <- base::grepl
[17:46:51.969]                         restarts <- computeRestarts(cond)
[17:46:51.969]                         for (restart in restarts) {
[17:46:51.969]                           name <- restart$name
[17:46:51.969]                           if (is.null(name)) 
[17:46:51.969]                             next
[17:46:51.969]                           if (!grepl(pattern, name)) 
[17:46:51.969]                             next
[17:46:51.969]                           invokeRestart(restart)
[17:46:51.969]                           muffled <- TRUE
[17:46:51.969]                           break
[17:46:51.969]                         }
[17:46:51.969]                       }
[17:46:51.969]                     }
[17:46:51.969]                     invisible(muffled)
[17:46:51.969]                   }
[17:46:51.969]                   muffleCondition(cond)
[17:46:51.969]                 })
[17:46:51.969]             }))
[17:46:51.969]             future::FutureResult(value = ...future.value$value, 
[17:46:51.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.969]                   ...future.rng), globalenv = if (FALSE) 
[17:46:51.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:51.969]                     ...future.globalenv.names))
[17:46:51.969]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:51.969]         }, condition = base::local({
[17:46:51.969]             c <- base::c
[17:46:51.969]             inherits <- base::inherits
[17:46:51.969]             invokeRestart <- base::invokeRestart
[17:46:51.969]             length <- base::length
[17:46:51.969]             list <- base::list
[17:46:51.969]             seq.int <- base::seq.int
[17:46:51.969]             signalCondition <- base::signalCondition
[17:46:51.969]             sys.calls <- base::sys.calls
[17:46:51.969]             `[[` <- base::`[[`
[17:46:51.969]             `+` <- base::`+`
[17:46:51.969]             `<<-` <- base::`<<-`
[17:46:51.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:51.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:51.969]                   3L)]
[17:46:51.969]             }
[17:46:51.969]             function(cond) {
[17:46:51.969]                 is_error <- inherits(cond, "error")
[17:46:51.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:51.969]                   NULL)
[17:46:51.969]                 if (is_error) {
[17:46:51.969]                   sessionInformation <- function() {
[17:46:51.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:51.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:51.969]                       search = base::search(), system = base::Sys.info())
[17:46:51.969]                   }
[17:46:51.969]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:51.969]                     cond$call), session = sessionInformation(), 
[17:46:51.969]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:51.969]                   signalCondition(cond)
[17:46:51.969]                 }
[17:46:51.969]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:51.969]                 "immediateCondition"))) {
[17:46:51.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:51.969]                   ...future.conditions[[length(...future.conditions) + 
[17:46:51.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:51.969]                   if (TRUE && !signal) {
[17:46:51.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.969]                     {
[17:46:51.969]                       inherits <- base::inherits
[17:46:51.969]                       invokeRestart <- base::invokeRestart
[17:46:51.969]                       is.null <- base::is.null
[17:46:51.969]                       muffled <- FALSE
[17:46:51.969]                       if (inherits(cond, "message")) {
[17:46:51.969]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.969]                         if (muffled) 
[17:46:51.969]                           invokeRestart("muffleMessage")
[17:46:51.969]                       }
[17:46:51.969]                       else if (inherits(cond, "warning")) {
[17:46:51.969]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.969]                         if (muffled) 
[17:46:51.969]                           invokeRestart("muffleWarning")
[17:46:51.969]                       }
[17:46:51.969]                       else if (inherits(cond, "condition")) {
[17:46:51.969]                         if (!is.null(pattern)) {
[17:46:51.969]                           computeRestarts <- base::computeRestarts
[17:46:51.969]                           grepl <- base::grepl
[17:46:51.969]                           restarts <- computeRestarts(cond)
[17:46:51.969]                           for (restart in restarts) {
[17:46:51.969]                             name <- restart$name
[17:46:51.969]                             if (is.null(name)) 
[17:46:51.969]                               next
[17:46:51.969]                             if (!grepl(pattern, name)) 
[17:46:51.969]                               next
[17:46:51.969]                             invokeRestart(restart)
[17:46:51.969]                             muffled <- TRUE
[17:46:51.969]                             break
[17:46:51.969]                           }
[17:46:51.969]                         }
[17:46:51.969]                       }
[17:46:51.969]                       invisible(muffled)
[17:46:51.969]                     }
[17:46:51.969]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.969]                   }
[17:46:51.969]                 }
[17:46:51.969]                 else {
[17:46:51.969]                   if (TRUE) {
[17:46:51.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:51.969]                     {
[17:46:51.969]                       inherits <- base::inherits
[17:46:51.969]                       invokeRestart <- base::invokeRestart
[17:46:51.969]                       is.null <- base::is.null
[17:46:51.969]                       muffled <- FALSE
[17:46:51.969]                       if (inherits(cond, "message")) {
[17:46:51.969]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:51.969]                         if (muffled) 
[17:46:51.969]                           invokeRestart("muffleMessage")
[17:46:51.969]                       }
[17:46:51.969]                       else if (inherits(cond, "warning")) {
[17:46:51.969]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:51.969]                         if (muffled) 
[17:46:51.969]                           invokeRestart("muffleWarning")
[17:46:51.969]                       }
[17:46:51.969]                       else if (inherits(cond, "condition")) {
[17:46:51.969]                         if (!is.null(pattern)) {
[17:46:51.969]                           computeRestarts <- base::computeRestarts
[17:46:51.969]                           grepl <- base::grepl
[17:46:51.969]                           restarts <- computeRestarts(cond)
[17:46:51.969]                           for (restart in restarts) {
[17:46:51.969]                             name <- restart$name
[17:46:51.969]                             if (is.null(name)) 
[17:46:51.969]                               next
[17:46:51.969]                             if (!grepl(pattern, name)) 
[17:46:51.969]                               next
[17:46:51.969]                             invokeRestart(restart)
[17:46:51.969]                             muffled <- TRUE
[17:46:51.969]                             break
[17:46:51.969]                           }
[17:46:51.969]                         }
[17:46:51.969]                       }
[17:46:51.969]                       invisible(muffled)
[17:46:51.969]                     }
[17:46:51.969]                     muffleCondition(cond, pattern = "^muffle")
[17:46:51.969]                   }
[17:46:51.969]                 }
[17:46:51.969]             }
[17:46:51.969]         }))
[17:46:51.969]     }, error = function(ex) {
[17:46:51.969]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:51.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:51.969]                 ...future.rng), started = ...future.startTime, 
[17:46:51.969]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:51.969]             version = "1.8"), class = "FutureResult")
[17:46:51.969]     }, finally = {
[17:46:51.969]         if (!identical(...future.workdir, getwd())) 
[17:46:51.969]             setwd(...future.workdir)
[17:46:51.969]         {
[17:46:51.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:51.969]                 ...future.oldOptions$nwarnings <- NULL
[17:46:51.969]             }
[17:46:51.969]             base::options(...future.oldOptions)
[17:46:51.969]             if (.Platform$OS.type == "windows") {
[17:46:51.969]                 old_names <- names(...future.oldEnvVars)
[17:46:51.969]                 envs <- base::Sys.getenv()
[17:46:51.969]                 names <- names(envs)
[17:46:51.969]                 common <- intersect(names, old_names)
[17:46:51.969]                 added <- setdiff(names, old_names)
[17:46:51.969]                 removed <- setdiff(old_names, names)
[17:46:51.969]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:51.969]                   envs[common]]
[17:46:51.969]                 NAMES <- toupper(changed)
[17:46:51.969]                 args <- list()
[17:46:51.969]                 for (kk in seq_along(NAMES)) {
[17:46:51.969]                   name <- changed[[kk]]
[17:46:51.969]                   NAME <- NAMES[[kk]]
[17:46:51.969]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.969]                     next
[17:46:51.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.969]                 }
[17:46:51.969]                 NAMES <- toupper(added)
[17:46:51.969]                 for (kk in seq_along(NAMES)) {
[17:46:51.969]                   name <- added[[kk]]
[17:46:51.969]                   NAME <- NAMES[[kk]]
[17:46:51.969]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.969]                     next
[17:46:51.969]                   args[[name]] <- ""
[17:46:51.969]                 }
[17:46:51.969]                 NAMES <- toupper(removed)
[17:46:51.969]                 for (kk in seq_along(NAMES)) {
[17:46:51.969]                   name <- removed[[kk]]
[17:46:51.969]                   NAME <- NAMES[[kk]]
[17:46:51.969]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:51.969]                     next
[17:46:51.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:51.969]                 }
[17:46:51.969]                 if (length(args) > 0) 
[17:46:51.969]                   base::do.call(base::Sys.setenv, args = args)
[17:46:51.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:51.969]             }
[17:46:51.969]             else {
[17:46:51.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:51.969]             }
[17:46:51.969]             {
[17:46:51.969]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:51.969]                   0L) {
[17:46:51.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:51.969]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:51.969]                   base::options(opts)
[17:46:51.969]                 }
[17:46:51.969]                 {
[17:46:51.969]                   {
[17:46:51.969]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:51.969]                     NULL
[17:46:51.969]                   }
[17:46:51.969]                   options(future.plan = NULL)
[17:46:51.969]                   if (is.na(NA_character_)) 
[17:46:51.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:51.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:51.969]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:51.969]                     .init = FALSE)
[17:46:51.969]                 }
[17:46:51.969]             }
[17:46:51.969]         }
[17:46:51.969]     })
[17:46:51.969]     if (TRUE) {
[17:46:51.969]         base::sink(type = "output", split = FALSE)
[17:46:51.969]         if (TRUE) {
[17:46:51.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:51.969]         }
[17:46:51.969]         else {
[17:46:51.969]             ...future.result["stdout"] <- base::list(NULL)
[17:46:51.969]         }
[17:46:51.969]         base::close(...future.stdout)
[17:46:51.969]         ...future.stdout <- NULL
[17:46:51.969]     }
[17:46:51.969]     ...future.result$conditions <- ...future.conditions
[17:46:51.969]     ...future.result$finished <- base::Sys.time()
[17:46:51.969]     ...future.result
[17:46:51.969] }
[17:46:51.971] requestCore(): workers = 2
[17:46:51.973] MulticoreFuture started
[17:46:51.973] - Launch lazy future ... done
[17:46:51.974] run() for ‘MulticoreFuture’ ... done
[17:46:51.974] result() for MulticoreFuture ...
[17:46:51.974] plan(): Setting new future strategy stack:
[17:46:51.975] List of future strategies:
[17:46:51.975] 1. sequential:
[17:46:51.975]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:51.975]    - tweaked: FALSE
[17:46:51.975]    - call: NULL
[17:46:51.976] plan(): nbrOfWorkers() = 1
[17:46:51.979] plan(): Setting new future strategy stack:
[17:46:51.979] List of future strategies:
[17:46:51.979] 1. multicore:
[17:46:51.979]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:51.979]    - tweaked: FALSE
[17:46:51.979]    - call: plan(strategy)
[17:46:51.984] plan(): nbrOfWorkers() = 2
[17:46:51.986] result() for MulticoreFuture ...
[17:46:51.986] result() for MulticoreFuture ... done
[17:46:51.987] result() for MulticoreFuture ... done
[17:46:51.987] result() for MulticoreFuture ...
[17:46:51.987] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[17:46:51.990] getGlobalsAndPackages() ...
[17:46:51.990] Searching for globals...
[17:46:51.993] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[17:46:51.993] Searching for globals ... DONE
[17:46:51.993] Resolving globals: FALSE
[17:46:51.994] 
[17:46:51.994] - packages: [2] ‘stats’, ‘datasets’
[17:46:51.994] getGlobalsAndPackages() ... DONE
[17:46:51.995] run() for ‘Future’ ...
[17:46:51.995] - state: ‘created’
[17:46:51.995] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:51.999] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:51.999] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:51.999]   - Field: ‘label’
[17:46:51.999]   - Field: ‘local’
[17:46:51.999]   - Field: ‘owner’
[17:46:52.000]   - Field: ‘envir’
[17:46:52.000]   - Field: ‘workers’
[17:46:52.000]   - Field: ‘packages’
[17:46:52.000]   - Field: ‘gc’
[17:46:52.000]   - Field: ‘job’
[17:46:52.000]   - Field: ‘conditions’
[17:46:52.000]   - Field: ‘expr’
[17:46:52.000]   - Field: ‘uuid’
[17:46:52.000]   - Field: ‘seed’
[17:46:52.001]   - Field: ‘version’
[17:46:52.001]   - Field: ‘result’
[17:46:52.001]   - Field: ‘asynchronous’
[17:46:52.001]   - Field: ‘calls’
[17:46:52.001]   - Field: ‘globals’
[17:46:52.001]   - Field: ‘stdout’
[17:46:52.001]   - Field: ‘earlySignal’
[17:46:52.001]   - Field: ‘lazy’
[17:46:52.001]   - Field: ‘state’
[17:46:52.001] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:52.002] - Launch lazy future ...
[17:46:52.002] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:52.002] Packages needed by future strategies (n = 0): <none>
[17:46:52.039] {
[17:46:52.039]     {
[17:46:52.039]         {
[17:46:52.039]             ...future.startTime <- base::Sys.time()
[17:46:52.039]             {
[17:46:52.039]                 {
[17:46:52.039]                   {
[17:46:52.039]                     {
[17:46:52.039]                       {
[17:46:52.039]                         base::local({
[17:46:52.039]                           has_future <- base::requireNamespace("future", 
[17:46:52.039]                             quietly = TRUE)
[17:46:52.039]                           if (has_future) {
[17:46:52.039]                             ns <- base::getNamespace("future")
[17:46:52.039]                             version <- ns[[".package"]][["version"]]
[17:46:52.039]                             if (is.null(version)) 
[17:46:52.039]                               version <- utils::packageVersion("future")
[17:46:52.039]                           }
[17:46:52.039]                           else {
[17:46:52.039]                             version <- NULL
[17:46:52.039]                           }
[17:46:52.039]                           if (!has_future || version < "1.8.0") {
[17:46:52.039]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:52.039]                               "", base::R.version$version.string), 
[17:46:52.039]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:52.039]                                 base::R.version$platform, 8 * 
[17:46:52.039]                                   base::.Machine$sizeof.pointer), 
[17:46:52.039]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:52.039]                                 "release", "version")], collapse = " "), 
[17:46:52.039]                               hostname = base::Sys.info()[["nodename"]])
[17:46:52.039]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:52.039]                               info)
[17:46:52.039]                             info <- base::paste(info, collapse = "; ")
[17:46:52.039]                             if (!has_future) {
[17:46:52.039]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:52.039]                                 info)
[17:46:52.039]                             }
[17:46:52.039]                             else {
[17:46:52.039]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:52.039]                                 info, version)
[17:46:52.039]                             }
[17:46:52.039]                             base::stop(msg)
[17:46:52.039]                           }
[17:46:52.039]                         })
[17:46:52.039]                       }
[17:46:52.039]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:52.039]                       base::options(mc.cores = 1L)
[17:46:52.039]                     }
[17:46:52.039]                     base::local({
[17:46:52.039]                       for (pkg in c("stats", "datasets")) {
[17:46:52.039]                         base::loadNamespace(pkg)
[17:46:52.039]                         base::library(pkg, character.only = TRUE)
[17:46:52.039]                       }
[17:46:52.039]                     })
[17:46:52.039]                   }
[17:46:52.039]                   ...future.strategy.old <- future::plan("list")
[17:46:52.039]                   options(future.plan = NULL)
[17:46:52.039]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.039]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:52.039]                 }
[17:46:52.039]                 ...future.workdir <- getwd()
[17:46:52.039]             }
[17:46:52.039]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:52.039]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:52.039]         }
[17:46:52.039]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:52.039]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:52.039]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:52.039]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:52.039]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:52.039]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:52.039]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:52.039]             base::names(...future.oldOptions))
[17:46:52.039]     }
[17:46:52.039]     if (FALSE) {
[17:46:52.039]     }
[17:46:52.039]     else {
[17:46:52.039]         if (TRUE) {
[17:46:52.039]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:52.039]                 open = "w")
[17:46:52.039]         }
[17:46:52.039]         else {
[17:46:52.039]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:52.039]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:52.039]         }
[17:46:52.039]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:52.039]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:52.039]             base::sink(type = "output", split = FALSE)
[17:46:52.039]             base::close(...future.stdout)
[17:46:52.039]         }, add = TRUE)
[17:46:52.039]     }
[17:46:52.039]     ...future.frame <- base::sys.nframe()
[17:46:52.039]     ...future.conditions <- base::list()
[17:46:52.039]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:52.039]     if (FALSE) {
[17:46:52.039]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:52.039]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:52.039]     }
[17:46:52.039]     ...future.result <- base::tryCatch({
[17:46:52.039]         base::withCallingHandlers({
[17:46:52.039]             ...future.value <- base::withVisible(base::local({
[17:46:52.039]                 withCallingHandlers({
[17:46:52.039]                   {
[17:46:52.039]                     lm(dist ~ speed + I(speed^2), data = cars)
[17:46:52.039]                   }
[17:46:52.039]                 }, immediateCondition = function(cond) {
[17:46:52.039]                   save_rds <- function (object, pathname, ...) 
[17:46:52.039]                   {
[17:46:52.039]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:52.039]                     if (file_test("-f", pathname_tmp)) {
[17:46:52.039]                       fi_tmp <- file.info(pathname_tmp)
[17:46:52.039]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:52.039]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:52.039]                         fi_tmp[["mtime"]])
[17:46:52.039]                     }
[17:46:52.039]                     tryCatch({
[17:46:52.039]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:52.039]                     }, error = function(ex) {
[17:46:52.039]                       msg <- conditionMessage(ex)
[17:46:52.039]                       fi_tmp <- file.info(pathname_tmp)
[17:46:52.039]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:52.039]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:52.039]                         fi_tmp[["mtime"]], msg)
[17:46:52.039]                       ex$message <- msg
[17:46:52.039]                       stop(ex)
[17:46:52.039]                     })
[17:46:52.039]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:52.039]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:52.039]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:52.039]                       fi_tmp <- file.info(pathname_tmp)
[17:46:52.039]                       fi <- file.info(pathname)
[17:46:52.039]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:52.039]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:52.039]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:52.039]                         fi[["size"]], fi[["mtime"]])
[17:46:52.039]                       stop(msg)
[17:46:52.039]                     }
[17:46:52.039]                     invisible(pathname)
[17:46:52.039]                   }
[17:46:52.039]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:52.039]                     rootPath = tempdir()) 
[17:46:52.039]                   {
[17:46:52.039]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:52.039]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:52.039]                       tmpdir = path, fileext = ".rds")
[17:46:52.039]                     save_rds(obj, file)
[17:46:52.039]                   }
[17:46:52.039]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6A38RL/.future/immediateConditions")
[17:46:52.039]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.039]                   {
[17:46:52.039]                     inherits <- base::inherits
[17:46:52.039]                     invokeRestart <- base::invokeRestart
[17:46:52.039]                     is.null <- base::is.null
[17:46:52.039]                     muffled <- FALSE
[17:46:52.039]                     if (inherits(cond, "message")) {
[17:46:52.039]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:52.039]                       if (muffled) 
[17:46:52.039]                         invokeRestart("muffleMessage")
[17:46:52.039]                     }
[17:46:52.039]                     else if (inherits(cond, "warning")) {
[17:46:52.039]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:52.039]                       if (muffled) 
[17:46:52.039]                         invokeRestart("muffleWarning")
[17:46:52.039]                     }
[17:46:52.039]                     else if (inherits(cond, "condition")) {
[17:46:52.039]                       if (!is.null(pattern)) {
[17:46:52.039]                         computeRestarts <- base::computeRestarts
[17:46:52.039]                         grepl <- base::grepl
[17:46:52.039]                         restarts <- computeRestarts(cond)
[17:46:52.039]                         for (restart in restarts) {
[17:46:52.039]                           name <- restart$name
[17:46:52.039]                           if (is.null(name)) 
[17:46:52.039]                             next
[17:46:52.039]                           if (!grepl(pattern, name)) 
[17:46:52.039]                             next
[17:46:52.039]                           invokeRestart(restart)
[17:46:52.039]                           muffled <- TRUE
[17:46:52.039]                           break
[17:46:52.039]                         }
[17:46:52.039]                       }
[17:46:52.039]                     }
[17:46:52.039]                     invisible(muffled)
[17:46:52.039]                   }
[17:46:52.039]                   muffleCondition(cond)
[17:46:52.039]                 })
[17:46:52.039]             }))
[17:46:52.039]             future::FutureResult(value = ...future.value$value, 
[17:46:52.039]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.039]                   ...future.rng), globalenv = if (FALSE) 
[17:46:52.039]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:52.039]                     ...future.globalenv.names))
[17:46:52.039]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:52.039]         }, condition = base::local({
[17:46:52.039]             c <- base::c
[17:46:52.039]             inherits <- base::inherits
[17:46:52.039]             invokeRestart <- base::invokeRestart
[17:46:52.039]             length <- base::length
[17:46:52.039]             list <- base::list
[17:46:52.039]             seq.int <- base::seq.int
[17:46:52.039]             signalCondition <- base::signalCondition
[17:46:52.039]             sys.calls <- base::sys.calls
[17:46:52.039]             `[[` <- base::`[[`
[17:46:52.039]             `+` <- base::`+`
[17:46:52.039]             `<<-` <- base::`<<-`
[17:46:52.039]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:52.039]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:52.039]                   3L)]
[17:46:52.039]             }
[17:46:52.039]             function(cond) {
[17:46:52.039]                 is_error <- inherits(cond, "error")
[17:46:52.039]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:52.039]                   NULL)
[17:46:52.039]                 if (is_error) {
[17:46:52.039]                   sessionInformation <- function() {
[17:46:52.039]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:52.039]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:52.039]                       search = base::search(), system = base::Sys.info())
[17:46:52.039]                   }
[17:46:52.039]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.039]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:52.039]                     cond$call), session = sessionInformation(), 
[17:46:52.039]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:52.039]                   signalCondition(cond)
[17:46:52.039]                 }
[17:46:52.039]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:52.039]                 "immediateCondition"))) {
[17:46:52.039]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:52.039]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.039]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:52.039]                   if (TRUE && !signal) {
[17:46:52.039]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.039]                     {
[17:46:52.039]                       inherits <- base::inherits
[17:46:52.039]                       invokeRestart <- base::invokeRestart
[17:46:52.039]                       is.null <- base::is.null
[17:46:52.039]                       muffled <- FALSE
[17:46:52.039]                       if (inherits(cond, "message")) {
[17:46:52.039]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.039]                         if (muffled) 
[17:46:52.039]                           invokeRestart("muffleMessage")
[17:46:52.039]                       }
[17:46:52.039]                       else if (inherits(cond, "warning")) {
[17:46:52.039]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.039]                         if (muffled) 
[17:46:52.039]                           invokeRestart("muffleWarning")
[17:46:52.039]                       }
[17:46:52.039]                       else if (inherits(cond, "condition")) {
[17:46:52.039]                         if (!is.null(pattern)) {
[17:46:52.039]                           computeRestarts <- base::computeRestarts
[17:46:52.039]                           grepl <- base::grepl
[17:46:52.039]                           restarts <- computeRestarts(cond)
[17:46:52.039]                           for (restart in restarts) {
[17:46:52.039]                             name <- restart$name
[17:46:52.039]                             if (is.null(name)) 
[17:46:52.039]                               next
[17:46:52.039]                             if (!grepl(pattern, name)) 
[17:46:52.039]                               next
[17:46:52.039]                             invokeRestart(restart)
[17:46:52.039]                             muffled <- TRUE
[17:46:52.039]                             break
[17:46:52.039]                           }
[17:46:52.039]                         }
[17:46:52.039]                       }
[17:46:52.039]                       invisible(muffled)
[17:46:52.039]                     }
[17:46:52.039]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.039]                   }
[17:46:52.039]                 }
[17:46:52.039]                 else {
[17:46:52.039]                   if (TRUE) {
[17:46:52.039]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.039]                     {
[17:46:52.039]                       inherits <- base::inherits
[17:46:52.039]                       invokeRestart <- base::invokeRestart
[17:46:52.039]                       is.null <- base::is.null
[17:46:52.039]                       muffled <- FALSE
[17:46:52.039]                       if (inherits(cond, "message")) {
[17:46:52.039]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.039]                         if (muffled) 
[17:46:52.039]                           invokeRestart("muffleMessage")
[17:46:52.039]                       }
[17:46:52.039]                       else if (inherits(cond, "warning")) {
[17:46:52.039]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.039]                         if (muffled) 
[17:46:52.039]                           invokeRestart("muffleWarning")
[17:46:52.039]                       }
[17:46:52.039]                       else if (inherits(cond, "condition")) {
[17:46:52.039]                         if (!is.null(pattern)) {
[17:46:52.039]                           computeRestarts <- base::computeRestarts
[17:46:52.039]                           grepl <- base::grepl
[17:46:52.039]                           restarts <- computeRestarts(cond)
[17:46:52.039]                           for (restart in restarts) {
[17:46:52.039]                             name <- restart$name
[17:46:52.039]                             if (is.null(name)) 
[17:46:52.039]                               next
[17:46:52.039]                             if (!grepl(pattern, name)) 
[17:46:52.039]                               next
[17:46:52.039]                             invokeRestart(restart)
[17:46:52.039]                             muffled <- TRUE
[17:46:52.039]                             break
[17:46:52.039]                           }
[17:46:52.039]                         }
[17:46:52.039]                       }
[17:46:52.039]                       invisible(muffled)
[17:46:52.039]                     }
[17:46:52.039]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.039]                   }
[17:46:52.039]                 }
[17:46:52.039]             }
[17:46:52.039]         }))
[17:46:52.039]     }, error = function(ex) {
[17:46:52.039]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:52.039]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.039]                 ...future.rng), started = ...future.startTime, 
[17:46:52.039]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:52.039]             version = "1.8"), class = "FutureResult")
[17:46:52.039]     }, finally = {
[17:46:52.039]         if (!identical(...future.workdir, getwd())) 
[17:46:52.039]             setwd(...future.workdir)
[17:46:52.039]         {
[17:46:52.039]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:52.039]                 ...future.oldOptions$nwarnings <- NULL
[17:46:52.039]             }
[17:46:52.039]             base::options(...future.oldOptions)
[17:46:52.039]             if (.Platform$OS.type == "windows") {
[17:46:52.039]                 old_names <- names(...future.oldEnvVars)
[17:46:52.039]                 envs <- base::Sys.getenv()
[17:46:52.039]                 names <- names(envs)
[17:46:52.039]                 common <- intersect(names, old_names)
[17:46:52.039]                 added <- setdiff(names, old_names)
[17:46:52.039]                 removed <- setdiff(old_names, names)
[17:46:52.039]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:52.039]                   envs[common]]
[17:46:52.039]                 NAMES <- toupper(changed)
[17:46:52.039]                 args <- list()
[17:46:52.039]                 for (kk in seq_along(NAMES)) {
[17:46:52.039]                   name <- changed[[kk]]
[17:46:52.039]                   NAME <- NAMES[[kk]]
[17:46:52.039]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.039]                     next
[17:46:52.039]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.039]                 }
[17:46:52.039]                 NAMES <- toupper(added)
[17:46:52.039]                 for (kk in seq_along(NAMES)) {
[17:46:52.039]                   name <- added[[kk]]
[17:46:52.039]                   NAME <- NAMES[[kk]]
[17:46:52.039]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.039]                     next
[17:46:52.039]                   args[[name]] <- ""
[17:46:52.039]                 }
[17:46:52.039]                 NAMES <- toupper(removed)
[17:46:52.039]                 for (kk in seq_along(NAMES)) {
[17:46:52.039]                   name <- removed[[kk]]
[17:46:52.039]                   NAME <- NAMES[[kk]]
[17:46:52.039]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.039]                     next
[17:46:52.039]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.039]                 }
[17:46:52.039]                 if (length(args) > 0) 
[17:46:52.039]                   base::do.call(base::Sys.setenv, args = args)
[17:46:52.039]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:52.039]             }
[17:46:52.039]             else {
[17:46:52.039]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:52.039]             }
[17:46:52.039]             {
[17:46:52.039]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:52.039]                   0L) {
[17:46:52.039]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:52.039]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:52.039]                   base::options(opts)
[17:46:52.039]                 }
[17:46:52.039]                 {
[17:46:52.039]                   {
[17:46:52.039]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:52.039]                     NULL
[17:46:52.039]                   }
[17:46:52.039]                   options(future.plan = NULL)
[17:46:52.039]                   if (is.na(NA_character_)) 
[17:46:52.039]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.039]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:52.039]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:52.039]                     .init = FALSE)
[17:46:52.039]                 }
[17:46:52.039]             }
[17:46:52.039]         }
[17:46:52.039]     })
[17:46:52.039]     if (TRUE) {
[17:46:52.039]         base::sink(type = "output", split = FALSE)
[17:46:52.039]         if (TRUE) {
[17:46:52.039]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:52.039]         }
[17:46:52.039]         else {
[17:46:52.039]             ...future.result["stdout"] <- base::list(NULL)
[17:46:52.039]         }
[17:46:52.039]         base::close(...future.stdout)
[17:46:52.039]         ...future.stdout <- NULL
[17:46:52.039]     }
[17:46:52.039]     ...future.result$conditions <- ...future.conditions
[17:46:52.039]     ...future.result$finished <- base::Sys.time()
[17:46:52.039]     ...future.result
[17:46:52.039] }
[17:46:52.041] requestCore(): workers = 2
[17:46:52.044] MulticoreFuture started
[17:46:52.044] - Launch lazy future ... done
[17:46:52.045] run() for ‘MulticoreFuture’ ... done
[17:46:52.046] result() for MulticoreFuture ...
[17:46:52.046] plan(): Setting new future strategy stack:
[17:46:52.047] List of future strategies:
[17:46:52.047] 1. sequential:
[17:46:52.047]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:52.047]    - tweaked: FALSE
[17:46:52.047]    - call: NULL
[17:46:52.048] plan(): nbrOfWorkers() = 1
[17:46:52.053] plan(): Setting new future strategy stack:
[17:46:52.053] List of future strategies:
[17:46:52.053] 1. multicore:
[17:46:52.053]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:52.053]    - tweaked: FALSE
[17:46:52.053]    - call: plan(strategy)
[17:46:52.058] plan(): nbrOfWorkers() = 2
[17:46:52.061] result() for MulticoreFuture ...
[17:46:52.061] result() for MulticoreFuture ... done
[17:46:52.062] result() for MulticoreFuture ... done
[17:46:52.062] result() for MulticoreFuture ...
[17:46:52.062] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[17:46:52.067] getGlobalsAndPackages() ...
[17:46:52.067] Searching for globals...
[17:46:52.069] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[17:46:52.069] Searching for globals ... DONE
[17:46:52.069] Resolving globals: FALSE
[17:46:52.070] 
[17:46:52.070] - packages: [2] ‘stats’, ‘datasets’
[17:46:52.070] getGlobalsAndPackages() ... DONE
[17:46:52.070] run() for ‘Future’ ...
[17:46:52.071] - state: ‘created’
[17:46:52.071] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:52.075] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:52.075] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:52.075]   - Field: ‘label’
[17:46:52.076]   - Field: ‘local’
[17:46:52.076]   - Field: ‘owner’
[17:46:52.076]   - Field: ‘envir’
[17:46:52.076]   - Field: ‘workers’
[17:46:52.076]   - Field: ‘packages’
[17:46:52.076]   - Field: ‘gc’
[17:46:52.076]   - Field: ‘job’
[17:46:52.076]   - Field: ‘conditions’
[17:46:52.076]   - Field: ‘expr’
[17:46:52.076]   - Field: ‘uuid’
[17:46:52.077]   - Field: ‘seed’
[17:46:52.077]   - Field: ‘version’
[17:46:52.077]   - Field: ‘result’
[17:46:52.077]   - Field: ‘asynchronous’
[17:46:52.077]   - Field: ‘calls’
[17:46:52.077]   - Field: ‘globals’
[17:46:52.077]   - Field: ‘stdout’
[17:46:52.077]   - Field: ‘earlySignal’
[17:46:52.077]   - Field: ‘lazy’
[17:46:52.078]   - Field: ‘state’
[17:46:52.078] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:52.078] - Launch lazy future ...
[17:46:52.078] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:52.078] Packages needed by future strategies (n = 0): <none>
[17:46:52.079] {
[17:46:52.079]     {
[17:46:52.079]         {
[17:46:52.079]             ...future.startTime <- base::Sys.time()
[17:46:52.079]             {
[17:46:52.079]                 {
[17:46:52.079]                   {
[17:46:52.079]                     {
[17:46:52.079]                       {
[17:46:52.079]                         base::local({
[17:46:52.079]                           has_future <- base::requireNamespace("future", 
[17:46:52.079]                             quietly = TRUE)
[17:46:52.079]                           if (has_future) {
[17:46:52.079]                             ns <- base::getNamespace("future")
[17:46:52.079]                             version <- ns[[".package"]][["version"]]
[17:46:52.079]                             if (is.null(version)) 
[17:46:52.079]                               version <- utils::packageVersion("future")
[17:46:52.079]                           }
[17:46:52.079]                           else {
[17:46:52.079]                             version <- NULL
[17:46:52.079]                           }
[17:46:52.079]                           if (!has_future || version < "1.8.0") {
[17:46:52.079]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:52.079]                               "", base::R.version$version.string), 
[17:46:52.079]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:52.079]                                 base::R.version$platform, 8 * 
[17:46:52.079]                                   base::.Machine$sizeof.pointer), 
[17:46:52.079]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:52.079]                                 "release", "version")], collapse = " "), 
[17:46:52.079]                               hostname = base::Sys.info()[["nodename"]])
[17:46:52.079]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:52.079]                               info)
[17:46:52.079]                             info <- base::paste(info, collapse = "; ")
[17:46:52.079]                             if (!has_future) {
[17:46:52.079]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:52.079]                                 info)
[17:46:52.079]                             }
[17:46:52.079]                             else {
[17:46:52.079]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:52.079]                                 info, version)
[17:46:52.079]                             }
[17:46:52.079]                             base::stop(msg)
[17:46:52.079]                           }
[17:46:52.079]                         })
[17:46:52.079]                       }
[17:46:52.079]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:52.079]                       base::options(mc.cores = 1L)
[17:46:52.079]                     }
[17:46:52.079]                     base::local({
[17:46:52.079]                       for (pkg in c("stats", "datasets")) {
[17:46:52.079]                         base::loadNamespace(pkg)
[17:46:52.079]                         base::library(pkg, character.only = TRUE)
[17:46:52.079]                       }
[17:46:52.079]                     })
[17:46:52.079]                   }
[17:46:52.079]                   ...future.strategy.old <- future::plan("list")
[17:46:52.079]                   options(future.plan = NULL)
[17:46:52.079]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.079]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:52.079]                 }
[17:46:52.079]                 ...future.workdir <- getwd()
[17:46:52.079]             }
[17:46:52.079]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:52.079]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:52.079]         }
[17:46:52.079]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:52.079]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:52.079]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:52.079]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:52.079]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:52.079]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:52.079]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:52.079]             base::names(...future.oldOptions))
[17:46:52.079]     }
[17:46:52.079]     if (FALSE) {
[17:46:52.079]     }
[17:46:52.079]     else {
[17:46:52.079]         if (TRUE) {
[17:46:52.079]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:52.079]                 open = "w")
[17:46:52.079]         }
[17:46:52.079]         else {
[17:46:52.079]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:52.079]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:52.079]         }
[17:46:52.079]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:52.079]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:52.079]             base::sink(type = "output", split = FALSE)
[17:46:52.079]             base::close(...future.stdout)
[17:46:52.079]         }, add = TRUE)
[17:46:52.079]     }
[17:46:52.079]     ...future.frame <- base::sys.nframe()
[17:46:52.079]     ...future.conditions <- base::list()
[17:46:52.079]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:52.079]     if (FALSE) {
[17:46:52.079]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:52.079]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:52.079]     }
[17:46:52.079]     ...future.result <- base::tryCatch({
[17:46:52.079]         base::withCallingHandlers({
[17:46:52.079]             ...future.value <- base::withVisible(base::local({
[17:46:52.079]                 withCallingHandlers({
[17:46:52.079]                   {
[17:46:52.079]                     lm(dist ~ poly(speed, 2), data = cars)
[17:46:52.079]                   }
[17:46:52.079]                 }, immediateCondition = function(cond) {
[17:46:52.079]                   save_rds <- function (object, pathname, ...) 
[17:46:52.079]                   {
[17:46:52.079]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:52.079]                     if (file_test("-f", pathname_tmp)) {
[17:46:52.079]                       fi_tmp <- file.info(pathname_tmp)
[17:46:52.079]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:52.079]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:52.079]                         fi_tmp[["mtime"]])
[17:46:52.079]                     }
[17:46:52.079]                     tryCatch({
[17:46:52.079]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:52.079]                     }, error = function(ex) {
[17:46:52.079]                       msg <- conditionMessage(ex)
[17:46:52.079]                       fi_tmp <- file.info(pathname_tmp)
[17:46:52.079]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:52.079]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:52.079]                         fi_tmp[["mtime"]], msg)
[17:46:52.079]                       ex$message <- msg
[17:46:52.079]                       stop(ex)
[17:46:52.079]                     })
[17:46:52.079]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:52.079]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:52.079]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:52.079]                       fi_tmp <- file.info(pathname_tmp)
[17:46:52.079]                       fi <- file.info(pathname)
[17:46:52.079]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:52.079]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:52.079]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:52.079]                         fi[["size"]], fi[["mtime"]])
[17:46:52.079]                       stop(msg)
[17:46:52.079]                     }
[17:46:52.079]                     invisible(pathname)
[17:46:52.079]                   }
[17:46:52.079]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:52.079]                     rootPath = tempdir()) 
[17:46:52.079]                   {
[17:46:52.079]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:52.079]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:52.079]                       tmpdir = path, fileext = ".rds")
[17:46:52.079]                     save_rds(obj, file)
[17:46:52.079]                   }
[17:46:52.079]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6A38RL/.future/immediateConditions")
[17:46:52.079]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.079]                   {
[17:46:52.079]                     inherits <- base::inherits
[17:46:52.079]                     invokeRestart <- base::invokeRestart
[17:46:52.079]                     is.null <- base::is.null
[17:46:52.079]                     muffled <- FALSE
[17:46:52.079]                     if (inherits(cond, "message")) {
[17:46:52.079]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:52.079]                       if (muffled) 
[17:46:52.079]                         invokeRestart("muffleMessage")
[17:46:52.079]                     }
[17:46:52.079]                     else if (inherits(cond, "warning")) {
[17:46:52.079]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:52.079]                       if (muffled) 
[17:46:52.079]                         invokeRestart("muffleWarning")
[17:46:52.079]                     }
[17:46:52.079]                     else if (inherits(cond, "condition")) {
[17:46:52.079]                       if (!is.null(pattern)) {
[17:46:52.079]                         computeRestarts <- base::computeRestarts
[17:46:52.079]                         grepl <- base::grepl
[17:46:52.079]                         restarts <- computeRestarts(cond)
[17:46:52.079]                         for (restart in restarts) {
[17:46:52.079]                           name <- restart$name
[17:46:52.079]                           if (is.null(name)) 
[17:46:52.079]                             next
[17:46:52.079]                           if (!grepl(pattern, name)) 
[17:46:52.079]                             next
[17:46:52.079]                           invokeRestart(restart)
[17:46:52.079]                           muffled <- TRUE
[17:46:52.079]                           break
[17:46:52.079]                         }
[17:46:52.079]                       }
[17:46:52.079]                     }
[17:46:52.079]                     invisible(muffled)
[17:46:52.079]                   }
[17:46:52.079]                   muffleCondition(cond)
[17:46:52.079]                 })
[17:46:52.079]             }))
[17:46:52.079]             future::FutureResult(value = ...future.value$value, 
[17:46:52.079]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.079]                   ...future.rng), globalenv = if (FALSE) 
[17:46:52.079]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:52.079]                     ...future.globalenv.names))
[17:46:52.079]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:52.079]         }, condition = base::local({
[17:46:52.079]             c <- base::c
[17:46:52.079]             inherits <- base::inherits
[17:46:52.079]             invokeRestart <- base::invokeRestart
[17:46:52.079]             length <- base::length
[17:46:52.079]             list <- base::list
[17:46:52.079]             seq.int <- base::seq.int
[17:46:52.079]             signalCondition <- base::signalCondition
[17:46:52.079]             sys.calls <- base::sys.calls
[17:46:52.079]             `[[` <- base::`[[`
[17:46:52.079]             `+` <- base::`+`
[17:46:52.079]             `<<-` <- base::`<<-`
[17:46:52.079]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:52.079]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:52.079]                   3L)]
[17:46:52.079]             }
[17:46:52.079]             function(cond) {
[17:46:52.079]                 is_error <- inherits(cond, "error")
[17:46:52.079]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:52.079]                   NULL)
[17:46:52.079]                 if (is_error) {
[17:46:52.079]                   sessionInformation <- function() {
[17:46:52.079]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:52.079]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:52.079]                       search = base::search(), system = base::Sys.info())
[17:46:52.079]                   }
[17:46:52.079]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.079]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:52.079]                     cond$call), session = sessionInformation(), 
[17:46:52.079]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:52.079]                   signalCondition(cond)
[17:46:52.079]                 }
[17:46:52.079]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:52.079]                 "immediateCondition"))) {
[17:46:52.079]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:52.079]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.079]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:52.079]                   if (TRUE && !signal) {
[17:46:52.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.079]                     {
[17:46:52.079]                       inherits <- base::inherits
[17:46:52.079]                       invokeRestart <- base::invokeRestart
[17:46:52.079]                       is.null <- base::is.null
[17:46:52.079]                       muffled <- FALSE
[17:46:52.079]                       if (inherits(cond, "message")) {
[17:46:52.079]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.079]                         if (muffled) 
[17:46:52.079]                           invokeRestart("muffleMessage")
[17:46:52.079]                       }
[17:46:52.079]                       else if (inherits(cond, "warning")) {
[17:46:52.079]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.079]                         if (muffled) 
[17:46:52.079]                           invokeRestart("muffleWarning")
[17:46:52.079]                       }
[17:46:52.079]                       else if (inherits(cond, "condition")) {
[17:46:52.079]                         if (!is.null(pattern)) {
[17:46:52.079]                           computeRestarts <- base::computeRestarts
[17:46:52.079]                           grepl <- base::grepl
[17:46:52.079]                           restarts <- computeRestarts(cond)
[17:46:52.079]                           for (restart in restarts) {
[17:46:52.079]                             name <- restart$name
[17:46:52.079]                             if (is.null(name)) 
[17:46:52.079]                               next
[17:46:52.079]                             if (!grepl(pattern, name)) 
[17:46:52.079]                               next
[17:46:52.079]                             invokeRestart(restart)
[17:46:52.079]                             muffled <- TRUE
[17:46:52.079]                             break
[17:46:52.079]                           }
[17:46:52.079]                         }
[17:46:52.079]                       }
[17:46:52.079]                       invisible(muffled)
[17:46:52.079]                     }
[17:46:52.079]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.079]                   }
[17:46:52.079]                 }
[17:46:52.079]                 else {
[17:46:52.079]                   if (TRUE) {
[17:46:52.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.079]                     {
[17:46:52.079]                       inherits <- base::inherits
[17:46:52.079]                       invokeRestart <- base::invokeRestart
[17:46:52.079]                       is.null <- base::is.null
[17:46:52.079]                       muffled <- FALSE
[17:46:52.079]                       if (inherits(cond, "message")) {
[17:46:52.079]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.079]                         if (muffled) 
[17:46:52.079]                           invokeRestart("muffleMessage")
[17:46:52.079]                       }
[17:46:52.079]                       else if (inherits(cond, "warning")) {
[17:46:52.079]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.079]                         if (muffled) 
[17:46:52.079]                           invokeRestart("muffleWarning")
[17:46:52.079]                       }
[17:46:52.079]                       else if (inherits(cond, "condition")) {
[17:46:52.079]                         if (!is.null(pattern)) {
[17:46:52.079]                           computeRestarts <- base::computeRestarts
[17:46:52.079]                           grepl <- base::grepl
[17:46:52.079]                           restarts <- computeRestarts(cond)
[17:46:52.079]                           for (restart in restarts) {
[17:46:52.079]                             name <- restart$name
[17:46:52.079]                             if (is.null(name)) 
[17:46:52.079]                               next
[17:46:52.079]                             if (!grepl(pattern, name)) 
[17:46:52.079]                               next
[17:46:52.079]                             invokeRestart(restart)
[17:46:52.079]                             muffled <- TRUE
[17:46:52.079]                             break
[17:46:52.079]                           }
[17:46:52.079]                         }
[17:46:52.079]                       }
[17:46:52.079]                       invisible(muffled)
[17:46:52.079]                     }
[17:46:52.079]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.079]                   }
[17:46:52.079]                 }
[17:46:52.079]             }
[17:46:52.079]         }))
[17:46:52.079]     }, error = function(ex) {
[17:46:52.079]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:52.079]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.079]                 ...future.rng), started = ...future.startTime, 
[17:46:52.079]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:52.079]             version = "1.8"), class = "FutureResult")
[17:46:52.079]     }, finally = {
[17:46:52.079]         if (!identical(...future.workdir, getwd())) 
[17:46:52.079]             setwd(...future.workdir)
[17:46:52.079]         {
[17:46:52.079]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:52.079]                 ...future.oldOptions$nwarnings <- NULL
[17:46:52.079]             }
[17:46:52.079]             base::options(...future.oldOptions)
[17:46:52.079]             if (.Platform$OS.type == "windows") {
[17:46:52.079]                 old_names <- names(...future.oldEnvVars)
[17:46:52.079]                 envs <- base::Sys.getenv()
[17:46:52.079]                 names <- names(envs)
[17:46:52.079]                 common <- intersect(names, old_names)
[17:46:52.079]                 added <- setdiff(names, old_names)
[17:46:52.079]                 removed <- setdiff(old_names, names)
[17:46:52.079]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:52.079]                   envs[common]]
[17:46:52.079]                 NAMES <- toupper(changed)
[17:46:52.079]                 args <- list()
[17:46:52.079]                 for (kk in seq_along(NAMES)) {
[17:46:52.079]                   name <- changed[[kk]]
[17:46:52.079]                   NAME <- NAMES[[kk]]
[17:46:52.079]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.079]                     next
[17:46:52.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.079]                 }
[17:46:52.079]                 NAMES <- toupper(added)
[17:46:52.079]                 for (kk in seq_along(NAMES)) {
[17:46:52.079]                   name <- added[[kk]]
[17:46:52.079]                   NAME <- NAMES[[kk]]
[17:46:52.079]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.079]                     next
[17:46:52.079]                   args[[name]] <- ""
[17:46:52.079]                 }
[17:46:52.079]                 NAMES <- toupper(removed)
[17:46:52.079]                 for (kk in seq_along(NAMES)) {
[17:46:52.079]                   name <- removed[[kk]]
[17:46:52.079]                   NAME <- NAMES[[kk]]
[17:46:52.079]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.079]                     next
[17:46:52.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.079]                 }
[17:46:52.079]                 if (length(args) > 0) 
[17:46:52.079]                   base::do.call(base::Sys.setenv, args = args)
[17:46:52.079]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:52.079]             }
[17:46:52.079]             else {
[17:46:52.079]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:52.079]             }
[17:46:52.079]             {
[17:46:52.079]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:52.079]                   0L) {
[17:46:52.079]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:52.079]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:52.079]                   base::options(opts)
[17:46:52.079]                 }
[17:46:52.079]                 {
[17:46:52.079]                   {
[17:46:52.079]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:52.079]                     NULL
[17:46:52.079]                   }
[17:46:52.079]                   options(future.plan = NULL)
[17:46:52.079]                   if (is.na(NA_character_)) 
[17:46:52.079]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.079]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:52.079]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:52.079]                     .init = FALSE)
[17:46:52.079]                 }
[17:46:52.079]             }
[17:46:52.079]         }
[17:46:52.079]     })
[17:46:52.079]     if (TRUE) {
[17:46:52.079]         base::sink(type = "output", split = FALSE)
[17:46:52.079]         if (TRUE) {
[17:46:52.079]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:52.079]         }
[17:46:52.079]         else {
[17:46:52.079]             ...future.result["stdout"] <- base::list(NULL)
[17:46:52.079]         }
[17:46:52.079]         base::close(...future.stdout)
[17:46:52.079]         ...future.stdout <- NULL
[17:46:52.079]     }
[17:46:52.079]     ...future.result$conditions <- ...future.conditions
[17:46:52.079]     ...future.result$finished <- base::Sys.time()
[17:46:52.079]     ...future.result
[17:46:52.079] }
[17:46:52.082] requestCore(): workers = 2
[17:46:52.084] MulticoreFuture started
[17:46:52.084] - Launch lazy future ... done
[17:46:52.084] run() for ‘MulticoreFuture’ ... done
[17:46:52.084] result() for MulticoreFuture ...
[17:46:52.085] plan(): Setting new future strategy stack:
[17:46:52.085] List of future strategies:
[17:46:52.085] 1. sequential:
[17:46:52.085]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:52.085]    - tweaked: FALSE
[17:46:52.085]    - call: NULL
[17:46:52.086] plan(): nbrOfWorkers() = 1
[17:46:52.090] plan(): Setting new future strategy stack:
[17:46:52.091] List of future strategies:
[17:46:52.091] 1. multicore:
[17:46:52.091]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:52.091]    - tweaked: FALSE
[17:46:52.091]    - call: plan(strategy)
[17:46:52.096] plan(): nbrOfWorkers() = 2
[17:46:52.098] result() for MulticoreFuture ...
[17:46:52.098] result() for MulticoreFuture ... done
[17:46:52.098] result() for MulticoreFuture ... done
[17:46:52.098] result() for MulticoreFuture ...
[17:46:52.098] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[17:46:52.101] getGlobalsAndPackages() ...
[17:46:52.101] Searching for globals...
[17:46:52.107] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:46:52.107] Searching for globals ... DONE
[17:46:52.107] Resolving globals: FALSE
[17:46:52.108] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:46:52.111] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:46:52.111] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:46:52.111] 
[17:46:52.111] getGlobalsAndPackages() ... DONE
[17:46:52.112] run() for ‘Future’ ...
[17:46:52.112] - state: ‘created’
[17:46:52.112] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:52.116] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:52.117] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:52.117]   - Field: ‘label’
[17:46:52.117]   - Field: ‘local’
[17:46:52.117]   - Field: ‘owner’
[17:46:52.117]   - Field: ‘envir’
[17:46:52.117]   - Field: ‘workers’
[17:46:52.117]   - Field: ‘packages’
[17:46:52.118]   - Field: ‘gc’
[17:46:52.118]   - Field: ‘job’
[17:46:52.118]   - Field: ‘conditions’
[17:46:52.118]   - Field: ‘expr’
[17:46:52.118]   - Field: ‘uuid’
[17:46:52.118]   - Field: ‘seed’
[17:46:52.118]   - Field: ‘version’
[17:46:52.118]   - Field: ‘result’
[17:46:52.118]   - Field: ‘asynchronous’
[17:46:52.118]   - Field: ‘calls’
[17:46:52.119]   - Field: ‘globals’
[17:46:52.119]   - Field: ‘stdout’
[17:46:52.119]   - Field: ‘earlySignal’
[17:46:52.119]   - Field: ‘lazy’
[17:46:52.119]   - Field: ‘state’
[17:46:52.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:52.119] - Launch lazy future ...
[17:46:52.120] Packages needed by the future expression (n = 0): <none>
[17:46:52.120] Packages needed by future strategies (n = 0): <none>
[17:46:52.120] {
[17:46:52.120]     {
[17:46:52.120]         {
[17:46:52.120]             ...future.startTime <- base::Sys.time()
[17:46:52.120]             {
[17:46:52.120]                 {
[17:46:52.120]                   {
[17:46:52.120]                     {
[17:46:52.120]                       base::local({
[17:46:52.120]                         has_future <- base::requireNamespace("future", 
[17:46:52.120]                           quietly = TRUE)
[17:46:52.120]                         if (has_future) {
[17:46:52.120]                           ns <- base::getNamespace("future")
[17:46:52.120]                           version <- ns[[".package"]][["version"]]
[17:46:52.120]                           if (is.null(version)) 
[17:46:52.120]                             version <- utils::packageVersion("future")
[17:46:52.120]                         }
[17:46:52.120]                         else {
[17:46:52.120]                           version <- NULL
[17:46:52.120]                         }
[17:46:52.120]                         if (!has_future || version < "1.8.0") {
[17:46:52.120]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:52.120]                             "", base::R.version$version.string), 
[17:46:52.120]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:52.120]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:52.120]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:52.120]                               "release", "version")], collapse = " "), 
[17:46:52.120]                             hostname = base::Sys.info()[["nodename"]])
[17:46:52.120]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:52.120]                             info)
[17:46:52.120]                           info <- base::paste(info, collapse = "; ")
[17:46:52.120]                           if (!has_future) {
[17:46:52.120]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:52.120]                               info)
[17:46:52.120]                           }
[17:46:52.120]                           else {
[17:46:52.120]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:52.120]                               info, version)
[17:46:52.120]                           }
[17:46:52.120]                           base::stop(msg)
[17:46:52.120]                         }
[17:46:52.120]                       })
[17:46:52.120]                     }
[17:46:52.120]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:52.120]                     base::options(mc.cores = 1L)
[17:46:52.120]                   }
[17:46:52.120]                   ...future.strategy.old <- future::plan("list")
[17:46:52.120]                   options(future.plan = NULL)
[17:46:52.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:52.120]                 }
[17:46:52.120]                 ...future.workdir <- getwd()
[17:46:52.120]             }
[17:46:52.120]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:52.120]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:52.120]         }
[17:46:52.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:52.120]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:52.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:52.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:52.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:52.120]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:52.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:52.120]             base::names(...future.oldOptions))
[17:46:52.120]     }
[17:46:52.120]     if (FALSE) {
[17:46:52.120]     }
[17:46:52.120]     else {
[17:46:52.120]         if (TRUE) {
[17:46:52.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:52.120]                 open = "w")
[17:46:52.120]         }
[17:46:52.120]         else {
[17:46:52.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:52.120]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:52.120]         }
[17:46:52.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:52.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:52.120]             base::sink(type = "output", split = FALSE)
[17:46:52.120]             base::close(...future.stdout)
[17:46:52.120]         }, add = TRUE)
[17:46:52.120]     }
[17:46:52.120]     ...future.frame <- base::sys.nframe()
[17:46:52.120]     ...future.conditions <- base::list()
[17:46:52.120]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:52.120]     if (FALSE) {
[17:46:52.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:52.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:52.120]     }
[17:46:52.120]     ...future.result <- base::tryCatch({
[17:46:52.120]         base::withCallingHandlers({
[17:46:52.120]             ...future.value <- base::withVisible(base::local({
[17:46:52.120]                 withCallingHandlers({
[17:46:52.120]                   {
[17:46:52.120]                     outer_function(1L)
[17:46:52.120]                   }
[17:46:52.120]                 }, immediateCondition = function(cond) {
[17:46:52.120]                   save_rds <- function (object, pathname, ...) 
[17:46:52.120]                   {
[17:46:52.120]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:52.120]                     if (file_test("-f", pathname_tmp)) {
[17:46:52.120]                       fi_tmp <- file.info(pathname_tmp)
[17:46:52.120]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:52.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:52.120]                         fi_tmp[["mtime"]])
[17:46:52.120]                     }
[17:46:52.120]                     tryCatch({
[17:46:52.120]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:52.120]                     }, error = function(ex) {
[17:46:52.120]                       msg <- conditionMessage(ex)
[17:46:52.120]                       fi_tmp <- file.info(pathname_tmp)
[17:46:52.120]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:52.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:52.120]                         fi_tmp[["mtime"]], msg)
[17:46:52.120]                       ex$message <- msg
[17:46:52.120]                       stop(ex)
[17:46:52.120]                     })
[17:46:52.120]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:52.120]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:52.120]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:52.120]                       fi_tmp <- file.info(pathname_tmp)
[17:46:52.120]                       fi <- file.info(pathname)
[17:46:52.120]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:52.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:52.120]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:52.120]                         fi[["size"]], fi[["mtime"]])
[17:46:52.120]                       stop(msg)
[17:46:52.120]                     }
[17:46:52.120]                     invisible(pathname)
[17:46:52.120]                   }
[17:46:52.120]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:52.120]                     rootPath = tempdir()) 
[17:46:52.120]                   {
[17:46:52.120]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:52.120]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:52.120]                       tmpdir = path, fileext = ".rds")
[17:46:52.120]                     save_rds(obj, file)
[17:46:52.120]                   }
[17:46:52.120]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6A38RL/.future/immediateConditions")
[17:46:52.120]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.120]                   {
[17:46:52.120]                     inherits <- base::inherits
[17:46:52.120]                     invokeRestart <- base::invokeRestart
[17:46:52.120]                     is.null <- base::is.null
[17:46:52.120]                     muffled <- FALSE
[17:46:52.120]                     if (inherits(cond, "message")) {
[17:46:52.120]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:52.120]                       if (muffled) 
[17:46:52.120]                         invokeRestart("muffleMessage")
[17:46:52.120]                     }
[17:46:52.120]                     else if (inherits(cond, "warning")) {
[17:46:52.120]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:52.120]                       if (muffled) 
[17:46:52.120]                         invokeRestart("muffleWarning")
[17:46:52.120]                     }
[17:46:52.120]                     else if (inherits(cond, "condition")) {
[17:46:52.120]                       if (!is.null(pattern)) {
[17:46:52.120]                         computeRestarts <- base::computeRestarts
[17:46:52.120]                         grepl <- base::grepl
[17:46:52.120]                         restarts <- computeRestarts(cond)
[17:46:52.120]                         for (restart in restarts) {
[17:46:52.120]                           name <- restart$name
[17:46:52.120]                           if (is.null(name)) 
[17:46:52.120]                             next
[17:46:52.120]                           if (!grepl(pattern, name)) 
[17:46:52.120]                             next
[17:46:52.120]                           invokeRestart(restart)
[17:46:52.120]                           muffled <- TRUE
[17:46:52.120]                           break
[17:46:52.120]                         }
[17:46:52.120]                       }
[17:46:52.120]                     }
[17:46:52.120]                     invisible(muffled)
[17:46:52.120]                   }
[17:46:52.120]                   muffleCondition(cond)
[17:46:52.120]                 })
[17:46:52.120]             }))
[17:46:52.120]             future::FutureResult(value = ...future.value$value, 
[17:46:52.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.120]                   ...future.rng), globalenv = if (FALSE) 
[17:46:52.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:52.120]                     ...future.globalenv.names))
[17:46:52.120]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:52.120]         }, condition = base::local({
[17:46:52.120]             c <- base::c
[17:46:52.120]             inherits <- base::inherits
[17:46:52.120]             invokeRestart <- base::invokeRestart
[17:46:52.120]             length <- base::length
[17:46:52.120]             list <- base::list
[17:46:52.120]             seq.int <- base::seq.int
[17:46:52.120]             signalCondition <- base::signalCondition
[17:46:52.120]             sys.calls <- base::sys.calls
[17:46:52.120]             `[[` <- base::`[[`
[17:46:52.120]             `+` <- base::`+`
[17:46:52.120]             `<<-` <- base::`<<-`
[17:46:52.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:52.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:52.120]                   3L)]
[17:46:52.120]             }
[17:46:52.120]             function(cond) {
[17:46:52.120]                 is_error <- inherits(cond, "error")
[17:46:52.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:52.120]                   NULL)
[17:46:52.120]                 if (is_error) {
[17:46:52.120]                   sessionInformation <- function() {
[17:46:52.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:52.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:52.120]                       search = base::search(), system = base::Sys.info())
[17:46:52.120]                   }
[17:46:52.120]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:52.120]                     cond$call), session = sessionInformation(), 
[17:46:52.120]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:52.120]                   signalCondition(cond)
[17:46:52.120]                 }
[17:46:52.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:52.120]                 "immediateCondition"))) {
[17:46:52.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:52.120]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:52.120]                   if (TRUE && !signal) {
[17:46:52.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.120]                     {
[17:46:52.120]                       inherits <- base::inherits
[17:46:52.120]                       invokeRestart <- base::invokeRestart
[17:46:52.120]                       is.null <- base::is.null
[17:46:52.120]                       muffled <- FALSE
[17:46:52.120]                       if (inherits(cond, "message")) {
[17:46:52.120]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.120]                         if (muffled) 
[17:46:52.120]                           invokeRestart("muffleMessage")
[17:46:52.120]                       }
[17:46:52.120]                       else if (inherits(cond, "warning")) {
[17:46:52.120]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.120]                         if (muffled) 
[17:46:52.120]                           invokeRestart("muffleWarning")
[17:46:52.120]                       }
[17:46:52.120]                       else if (inherits(cond, "condition")) {
[17:46:52.120]                         if (!is.null(pattern)) {
[17:46:52.120]                           computeRestarts <- base::computeRestarts
[17:46:52.120]                           grepl <- base::grepl
[17:46:52.120]                           restarts <- computeRestarts(cond)
[17:46:52.120]                           for (restart in restarts) {
[17:46:52.120]                             name <- restart$name
[17:46:52.120]                             if (is.null(name)) 
[17:46:52.120]                               next
[17:46:52.120]                             if (!grepl(pattern, name)) 
[17:46:52.120]                               next
[17:46:52.120]                             invokeRestart(restart)
[17:46:52.120]                             muffled <- TRUE
[17:46:52.120]                             break
[17:46:52.120]                           }
[17:46:52.120]                         }
[17:46:52.120]                       }
[17:46:52.120]                       invisible(muffled)
[17:46:52.120]                     }
[17:46:52.120]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.120]                   }
[17:46:52.120]                 }
[17:46:52.120]                 else {
[17:46:52.120]                   if (TRUE) {
[17:46:52.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.120]                     {
[17:46:52.120]                       inherits <- base::inherits
[17:46:52.120]                       invokeRestart <- base::invokeRestart
[17:46:52.120]                       is.null <- base::is.null
[17:46:52.120]                       muffled <- FALSE
[17:46:52.120]                       if (inherits(cond, "message")) {
[17:46:52.120]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.120]                         if (muffled) 
[17:46:52.120]                           invokeRestart("muffleMessage")
[17:46:52.120]                       }
[17:46:52.120]                       else if (inherits(cond, "warning")) {
[17:46:52.120]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.120]                         if (muffled) 
[17:46:52.120]                           invokeRestart("muffleWarning")
[17:46:52.120]                       }
[17:46:52.120]                       else if (inherits(cond, "condition")) {
[17:46:52.120]                         if (!is.null(pattern)) {
[17:46:52.120]                           computeRestarts <- base::computeRestarts
[17:46:52.120]                           grepl <- base::grepl
[17:46:52.120]                           restarts <- computeRestarts(cond)
[17:46:52.120]                           for (restart in restarts) {
[17:46:52.120]                             name <- restart$name
[17:46:52.120]                             if (is.null(name)) 
[17:46:52.120]                               next
[17:46:52.120]                             if (!grepl(pattern, name)) 
[17:46:52.120]                               next
[17:46:52.120]                             invokeRestart(restart)
[17:46:52.120]                             muffled <- TRUE
[17:46:52.120]                             break
[17:46:52.120]                           }
[17:46:52.120]                         }
[17:46:52.120]                       }
[17:46:52.120]                       invisible(muffled)
[17:46:52.120]                     }
[17:46:52.120]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.120]                   }
[17:46:52.120]                 }
[17:46:52.120]             }
[17:46:52.120]         }))
[17:46:52.120]     }, error = function(ex) {
[17:46:52.120]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:52.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.120]                 ...future.rng), started = ...future.startTime, 
[17:46:52.120]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:52.120]             version = "1.8"), class = "FutureResult")
[17:46:52.120]     }, finally = {
[17:46:52.120]         if (!identical(...future.workdir, getwd())) 
[17:46:52.120]             setwd(...future.workdir)
[17:46:52.120]         {
[17:46:52.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:52.120]                 ...future.oldOptions$nwarnings <- NULL
[17:46:52.120]             }
[17:46:52.120]             base::options(...future.oldOptions)
[17:46:52.120]             if (.Platform$OS.type == "windows") {
[17:46:52.120]                 old_names <- names(...future.oldEnvVars)
[17:46:52.120]                 envs <- base::Sys.getenv()
[17:46:52.120]                 names <- names(envs)
[17:46:52.120]                 common <- intersect(names, old_names)
[17:46:52.120]                 added <- setdiff(names, old_names)
[17:46:52.120]                 removed <- setdiff(old_names, names)
[17:46:52.120]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:52.120]                   envs[common]]
[17:46:52.120]                 NAMES <- toupper(changed)
[17:46:52.120]                 args <- list()
[17:46:52.120]                 for (kk in seq_along(NAMES)) {
[17:46:52.120]                   name <- changed[[kk]]
[17:46:52.120]                   NAME <- NAMES[[kk]]
[17:46:52.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.120]                     next
[17:46:52.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.120]                 }
[17:46:52.120]                 NAMES <- toupper(added)
[17:46:52.120]                 for (kk in seq_along(NAMES)) {
[17:46:52.120]                   name <- added[[kk]]
[17:46:52.120]                   NAME <- NAMES[[kk]]
[17:46:52.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.120]                     next
[17:46:52.120]                   args[[name]] <- ""
[17:46:52.120]                 }
[17:46:52.120]                 NAMES <- toupper(removed)
[17:46:52.120]                 for (kk in seq_along(NAMES)) {
[17:46:52.120]                   name <- removed[[kk]]
[17:46:52.120]                   NAME <- NAMES[[kk]]
[17:46:52.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.120]                     next
[17:46:52.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.120]                 }
[17:46:52.120]                 if (length(args) > 0) 
[17:46:52.120]                   base::do.call(base::Sys.setenv, args = args)
[17:46:52.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:52.120]             }
[17:46:52.120]             else {
[17:46:52.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:52.120]             }
[17:46:52.120]             {
[17:46:52.120]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:52.120]                   0L) {
[17:46:52.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:52.120]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:52.120]                   base::options(opts)
[17:46:52.120]                 }
[17:46:52.120]                 {
[17:46:52.120]                   {
[17:46:52.120]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:52.120]                     NULL
[17:46:52.120]                   }
[17:46:52.120]                   options(future.plan = NULL)
[17:46:52.120]                   if (is.na(NA_character_)) 
[17:46:52.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:52.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:52.120]                     .init = FALSE)
[17:46:52.120]                 }
[17:46:52.120]             }
[17:46:52.120]         }
[17:46:52.120]     })
[17:46:52.120]     if (TRUE) {
[17:46:52.120]         base::sink(type = "output", split = FALSE)
[17:46:52.120]         if (TRUE) {
[17:46:52.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:52.120]         }
[17:46:52.120]         else {
[17:46:52.120]             ...future.result["stdout"] <- base::list(NULL)
[17:46:52.120]         }
[17:46:52.120]         base::close(...future.stdout)
[17:46:52.120]         ...future.stdout <- NULL
[17:46:52.120]     }
[17:46:52.120]     ...future.result$conditions <- ...future.conditions
[17:46:52.120]     ...future.result$finished <- base::Sys.time()
[17:46:52.120]     ...future.result
[17:46:52.120] }
[17:46:52.122] assign_globals() ...
[17:46:52.123] List of 3
[17:46:52.123]  $ outer_function:function (x)  
[17:46:52.123]  $ map           :function (.x, .f, ...)  
[17:46:52.123]  $ inner_function:function (x)  
[17:46:52.123]  - attr(*, "where")=List of 3
[17:46:52.123]   ..$ outer_function:<environment: R_EmptyEnv> 
[17:46:52.123]   ..$ map           :<environment: R_EmptyEnv> 
[17:46:52.123]   ..$ inner_function:<environment: R_EmptyEnv> 
[17:46:52.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:52.123]  - attr(*, "resolved")= logi FALSE
[17:46:52.123]  - attr(*, "total_size")= num 7704
[17:46:52.123]  - attr(*, "already-done")= logi TRUE
[17:46:52.126] - reassign environment for ‘outer_function’
[17:46:52.126] - copied ‘outer_function’ to environment
[17:46:52.126] - reassign environment for ‘map’
[17:46:52.127] - copied ‘map’ to environment
[17:46:52.127] - reassign environment for ‘inner_function’
[17:46:52.127] - copied ‘inner_function’ to environment
[17:46:52.127] assign_globals() ... done
[17:46:52.127] requestCore(): workers = 2
[17:46:52.129] MulticoreFuture started
[17:46:52.129] - Launch lazy future ... done
[17:46:52.130] run() for ‘MulticoreFuture’ ... done
[17:46:52.130] result() for MulticoreFuture ...
[17:46:52.130] plan(): Setting new future strategy stack:
[17:46:52.130] List of future strategies:
[17:46:52.130] 1. sequential:
[17:46:52.130]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:52.130]    - tweaked: FALSE
[17:46:52.130]    - call: NULL
[17:46:52.131] plan(): nbrOfWorkers() = 1
[17:46:52.134] plan(): Setting new future strategy stack:
[17:46:52.134] List of future strategies:
[17:46:52.134] 1. multicore:
[17:46:52.134]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:52.134]    - tweaked: FALSE
[17:46:52.134]    - call: plan(strategy)
[17:46:52.139] plan(): nbrOfWorkers() = 2
[17:46:52.140] result() for MulticoreFuture ...
[17:46:52.140] result() for MulticoreFuture ... done
[17:46:52.140] result() for MulticoreFuture ... done
[17:46:52.140] result() for MulticoreFuture ...
[17:46:52.140] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[17:46:52.142] getGlobalsAndPackages() ...
[17:46:52.142] Searching for globals...
[17:46:52.148] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:46:52.148] Searching for globals ... DONE
[17:46:52.148] Resolving globals: FALSE
[17:46:52.149] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:46:52.150] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:46:52.150] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:46:52.150] 
[17:46:52.150] getGlobalsAndPackages() ... DONE
[17:46:52.150] run() for ‘Future’ ...
[17:46:52.151] - state: ‘created’
[17:46:52.151] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:52.155] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:52.155] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:52.155]   - Field: ‘label’
[17:46:52.155]   - Field: ‘local’
[17:46:52.155]   - Field: ‘owner’
[17:46:52.155]   - Field: ‘envir’
[17:46:52.155]   - Field: ‘workers’
[17:46:52.156]   - Field: ‘packages’
[17:46:52.156]   - Field: ‘gc’
[17:46:52.156]   - Field: ‘job’
[17:46:52.156]   - Field: ‘conditions’
[17:46:52.156]   - Field: ‘expr’
[17:46:52.156]   - Field: ‘uuid’
[17:46:52.156]   - Field: ‘seed’
[17:46:52.156]   - Field: ‘version’
[17:46:52.156]   - Field: ‘result’
[17:46:52.157]   - Field: ‘asynchronous’
[17:46:52.157]   - Field: ‘calls’
[17:46:52.159]   - Field: ‘globals’
[17:46:52.159]   - Field: ‘stdout’
[17:46:52.159]   - Field: ‘earlySignal’
[17:46:52.159]   - Field: ‘lazy’
[17:46:52.159]   - Field: ‘state’
[17:46:52.159] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:52.160] - Launch lazy future ...
[17:46:52.160] Packages needed by the future expression (n = 0): <none>
[17:46:52.160] Packages needed by future strategies (n = 0): <none>
[17:46:52.161] {
[17:46:52.161]     {
[17:46:52.161]         {
[17:46:52.161]             ...future.startTime <- base::Sys.time()
[17:46:52.161]             {
[17:46:52.161]                 {
[17:46:52.161]                   {
[17:46:52.161]                     {
[17:46:52.161]                       base::local({
[17:46:52.161]                         has_future <- base::requireNamespace("future", 
[17:46:52.161]                           quietly = TRUE)
[17:46:52.161]                         if (has_future) {
[17:46:52.161]                           ns <- base::getNamespace("future")
[17:46:52.161]                           version <- ns[[".package"]][["version"]]
[17:46:52.161]                           if (is.null(version)) 
[17:46:52.161]                             version <- utils::packageVersion("future")
[17:46:52.161]                         }
[17:46:52.161]                         else {
[17:46:52.161]                           version <- NULL
[17:46:52.161]                         }
[17:46:52.161]                         if (!has_future || version < "1.8.0") {
[17:46:52.161]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:52.161]                             "", base::R.version$version.string), 
[17:46:52.161]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:52.161]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:52.161]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:52.161]                               "release", "version")], collapse = " "), 
[17:46:52.161]                             hostname = base::Sys.info()[["nodename"]])
[17:46:52.161]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:52.161]                             info)
[17:46:52.161]                           info <- base::paste(info, collapse = "; ")
[17:46:52.161]                           if (!has_future) {
[17:46:52.161]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:52.161]                               info)
[17:46:52.161]                           }
[17:46:52.161]                           else {
[17:46:52.161]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:52.161]                               info, version)
[17:46:52.161]                           }
[17:46:52.161]                           base::stop(msg)
[17:46:52.161]                         }
[17:46:52.161]                       })
[17:46:52.161]                     }
[17:46:52.161]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:52.161]                     base::options(mc.cores = 1L)
[17:46:52.161]                   }
[17:46:52.161]                   ...future.strategy.old <- future::plan("list")
[17:46:52.161]                   options(future.plan = NULL)
[17:46:52.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:52.161]                 }
[17:46:52.161]                 ...future.workdir <- getwd()
[17:46:52.161]             }
[17:46:52.161]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:52.161]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:52.161]         }
[17:46:52.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:52.161]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:52.161]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:52.161]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:52.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:52.161]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:52.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:52.161]             base::names(...future.oldOptions))
[17:46:52.161]     }
[17:46:52.161]     if (FALSE) {
[17:46:52.161]     }
[17:46:52.161]     else {
[17:46:52.161]         if (TRUE) {
[17:46:52.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:52.161]                 open = "w")
[17:46:52.161]         }
[17:46:52.161]         else {
[17:46:52.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:52.161]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:52.161]         }
[17:46:52.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:52.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:52.161]             base::sink(type = "output", split = FALSE)
[17:46:52.161]             base::close(...future.stdout)
[17:46:52.161]         }, add = TRUE)
[17:46:52.161]     }
[17:46:52.161]     ...future.frame <- base::sys.nframe()
[17:46:52.161]     ...future.conditions <- base::list()
[17:46:52.161]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:52.161]     if (FALSE) {
[17:46:52.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:52.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:52.161]     }
[17:46:52.161]     ...future.result <- base::tryCatch({
[17:46:52.161]         base::withCallingHandlers({
[17:46:52.161]             ...future.value <- base::withVisible(base::local({
[17:46:52.161]                 withCallingHandlers({
[17:46:52.161]                   {
[17:46:52.161]                     outer_function(1L)
[17:46:52.161]                   }
[17:46:52.161]                 }, immediateCondition = function(cond) {
[17:46:52.161]                   save_rds <- function (object, pathname, ...) 
[17:46:52.161]                   {
[17:46:52.161]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:52.161]                     if (file_test("-f", pathname_tmp)) {
[17:46:52.161]                       fi_tmp <- file.info(pathname_tmp)
[17:46:52.161]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:52.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:52.161]                         fi_tmp[["mtime"]])
[17:46:52.161]                     }
[17:46:52.161]                     tryCatch({
[17:46:52.161]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:52.161]                     }, error = function(ex) {
[17:46:52.161]                       msg <- conditionMessage(ex)
[17:46:52.161]                       fi_tmp <- file.info(pathname_tmp)
[17:46:52.161]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:52.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:52.161]                         fi_tmp[["mtime"]], msg)
[17:46:52.161]                       ex$message <- msg
[17:46:52.161]                       stop(ex)
[17:46:52.161]                     })
[17:46:52.161]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:52.161]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:52.161]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:52.161]                       fi_tmp <- file.info(pathname_tmp)
[17:46:52.161]                       fi <- file.info(pathname)
[17:46:52.161]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:52.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:52.161]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:52.161]                         fi[["size"]], fi[["mtime"]])
[17:46:52.161]                       stop(msg)
[17:46:52.161]                     }
[17:46:52.161]                     invisible(pathname)
[17:46:52.161]                   }
[17:46:52.161]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:52.161]                     rootPath = tempdir()) 
[17:46:52.161]                   {
[17:46:52.161]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:52.161]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:52.161]                       tmpdir = path, fileext = ".rds")
[17:46:52.161]                     save_rds(obj, file)
[17:46:52.161]                   }
[17:46:52.161]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6A38RL/.future/immediateConditions")
[17:46:52.161]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.161]                   {
[17:46:52.161]                     inherits <- base::inherits
[17:46:52.161]                     invokeRestart <- base::invokeRestart
[17:46:52.161]                     is.null <- base::is.null
[17:46:52.161]                     muffled <- FALSE
[17:46:52.161]                     if (inherits(cond, "message")) {
[17:46:52.161]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:52.161]                       if (muffled) 
[17:46:52.161]                         invokeRestart("muffleMessage")
[17:46:52.161]                     }
[17:46:52.161]                     else if (inherits(cond, "warning")) {
[17:46:52.161]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:52.161]                       if (muffled) 
[17:46:52.161]                         invokeRestart("muffleWarning")
[17:46:52.161]                     }
[17:46:52.161]                     else if (inherits(cond, "condition")) {
[17:46:52.161]                       if (!is.null(pattern)) {
[17:46:52.161]                         computeRestarts <- base::computeRestarts
[17:46:52.161]                         grepl <- base::grepl
[17:46:52.161]                         restarts <- computeRestarts(cond)
[17:46:52.161]                         for (restart in restarts) {
[17:46:52.161]                           name <- restart$name
[17:46:52.161]                           if (is.null(name)) 
[17:46:52.161]                             next
[17:46:52.161]                           if (!grepl(pattern, name)) 
[17:46:52.161]                             next
[17:46:52.161]                           invokeRestart(restart)
[17:46:52.161]                           muffled <- TRUE
[17:46:52.161]                           break
[17:46:52.161]                         }
[17:46:52.161]                       }
[17:46:52.161]                     }
[17:46:52.161]                     invisible(muffled)
[17:46:52.161]                   }
[17:46:52.161]                   muffleCondition(cond)
[17:46:52.161]                 })
[17:46:52.161]             }))
[17:46:52.161]             future::FutureResult(value = ...future.value$value, 
[17:46:52.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.161]                   ...future.rng), globalenv = if (FALSE) 
[17:46:52.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:52.161]                     ...future.globalenv.names))
[17:46:52.161]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:52.161]         }, condition = base::local({
[17:46:52.161]             c <- base::c
[17:46:52.161]             inherits <- base::inherits
[17:46:52.161]             invokeRestart <- base::invokeRestart
[17:46:52.161]             length <- base::length
[17:46:52.161]             list <- base::list
[17:46:52.161]             seq.int <- base::seq.int
[17:46:52.161]             signalCondition <- base::signalCondition
[17:46:52.161]             sys.calls <- base::sys.calls
[17:46:52.161]             `[[` <- base::`[[`
[17:46:52.161]             `+` <- base::`+`
[17:46:52.161]             `<<-` <- base::`<<-`
[17:46:52.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:52.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:52.161]                   3L)]
[17:46:52.161]             }
[17:46:52.161]             function(cond) {
[17:46:52.161]                 is_error <- inherits(cond, "error")
[17:46:52.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:52.161]                   NULL)
[17:46:52.161]                 if (is_error) {
[17:46:52.161]                   sessionInformation <- function() {
[17:46:52.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:52.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:52.161]                       search = base::search(), system = base::Sys.info())
[17:46:52.161]                   }
[17:46:52.161]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:52.161]                     cond$call), session = sessionInformation(), 
[17:46:52.161]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:52.161]                   signalCondition(cond)
[17:46:52.161]                 }
[17:46:52.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:52.161]                 "immediateCondition"))) {
[17:46:52.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:52.161]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:52.161]                   if (TRUE && !signal) {
[17:46:52.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.161]                     {
[17:46:52.161]                       inherits <- base::inherits
[17:46:52.161]                       invokeRestart <- base::invokeRestart
[17:46:52.161]                       is.null <- base::is.null
[17:46:52.161]                       muffled <- FALSE
[17:46:52.161]                       if (inherits(cond, "message")) {
[17:46:52.161]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.161]                         if (muffled) 
[17:46:52.161]                           invokeRestart("muffleMessage")
[17:46:52.161]                       }
[17:46:52.161]                       else if (inherits(cond, "warning")) {
[17:46:52.161]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.161]                         if (muffled) 
[17:46:52.161]                           invokeRestart("muffleWarning")
[17:46:52.161]                       }
[17:46:52.161]                       else if (inherits(cond, "condition")) {
[17:46:52.161]                         if (!is.null(pattern)) {
[17:46:52.161]                           computeRestarts <- base::computeRestarts
[17:46:52.161]                           grepl <- base::grepl
[17:46:52.161]                           restarts <- computeRestarts(cond)
[17:46:52.161]                           for (restart in restarts) {
[17:46:52.161]                             name <- restart$name
[17:46:52.161]                             if (is.null(name)) 
[17:46:52.161]                               next
[17:46:52.161]                             if (!grepl(pattern, name)) 
[17:46:52.161]                               next
[17:46:52.161]                             invokeRestart(restart)
[17:46:52.161]                             muffled <- TRUE
[17:46:52.161]                             break
[17:46:52.161]                           }
[17:46:52.161]                         }
[17:46:52.161]                       }
[17:46:52.161]                       invisible(muffled)
[17:46:52.161]                     }
[17:46:52.161]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.161]                   }
[17:46:52.161]                 }
[17:46:52.161]                 else {
[17:46:52.161]                   if (TRUE) {
[17:46:52.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.161]                     {
[17:46:52.161]                       inherits <- base::inherits
[17:46:52.161]                       invokeRestart <- base::invokeRestart
[17:46:52.161]                       is.null <- base::is.null
[17:46:52.161]                       muffled <- FALSE
[17:46:52.161]                       if (inherits(cond, "message")) {
[17:46:52.161]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.161]                         if (muffled) 
[17:46:52.161]                           invokeRestart("muffleMessage")
[17:46:52.161]                       }
[17:46:52.161]                       else if (inherits(cond, "warning")) {
[17:46:52.161]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.161]                         if (muffled) 
[17:46:52.161]                           invokeRestart("muffleWarning")
[17:46:52.161]                       }
[17:46:52.161]                       else if (inherits(cond, "condition")) {
[17:46:52.161]                         if (!is.null(pattern)) {
[17:46:52.161]                           computeRestarts <- base::computeRestarts
[17:46:52.161]                           grepl <- base::grepl
[17:46:52.161]                           restarts <- computeRestarts(cond)
[17:46:52.161]                           for (restart in restarts) {
[17:46:52.161]                             name <- restart$name
[17:46:52.161]                             if (is.null(name)) 
[17:46:52.161]                               next
[17:46:52.161]                             if (!grepl(pattern, name)) 
[17:46:52.161]                               next
[17:46:52.161]                             invokeRestart(restart)
[17:46:52.161]                             muffled <- TRUE
[17:46:52.161]                             break
[17:46:52.161]                           }
[17:46:52.161]                         }
[17:46:52.161]                       }
[17:46:52.161]                       invisible(muffled)
[17:46:52.161]                     }
[17:46:52.161]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.161]                   }
[17:46:52.161]                 }
[17:46:52.161]             }
[17:46:52.161]         }))
[17:46:52.161]     }, error = function(ex) {
[17:46:52.161]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:52.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.161]                 ...future.rng), started = ...future.startTime, 
[17:46:52.161]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:52.161]             version = "1.8"), class = "FutureResult")
[17:46:52.161]     }, finally = {
[17:46:52.161]         if (!identical(...future.workdir, getwd())) 
[17:46:52.161]             setwd(...future.workdir)
[17:46:52.161]         {
[17:46:52.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:52.161]                 ...future.oldOptions$nwarnings <- NULL
[17:46:52.161]             }
[17:46:52.161]             base::options(...future.oldOptions)
[17:46:52.161]             if (.Platform$OS.type == "windows") {
[17:46:52.161]                 old_names <- names(...future.oldEnvVars)
[17:46:52.161]                 envs <- base::Sys.getenv()
[17:46:52.161]                 names <- names(envs)
[17:46:52.161]                 common <- intersect(names, old_names)
[17:46:52.161]                 added <- setdiff(names, old_names)
[17:46:52.161]                 removed <- setdiff(old_names, names)
[17:46:52.161]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:52.161]                   envs[common]]
[17:46:52.161]                 NAMES <- toupper(changed)
[17:46:52.161]                 args <- list()
[17:46:52.161]                 for (kk in seq_along(NAMES)) {
[17:46:52.161]                   name <- changed[[kk]]
[17:46:52.161]                   NAME <- NAMES[[kk]]
[17:46:52.161]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.161]                     next
[17:46:52.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.161]                 }
[17:46:52.161]                 NAMES <- toupper(added)
[17:46:52.161]                 for (kk in seq_along(NAMES)) {
[17:46:52.161]                   name <- added[[kk]]
[17:46:52.161]                   NAME <- NAMES[[kk]]
[17:46:52.161]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.161]                     next
[17:46:52.161]                   args[[name]] <- ""
[17:46:52.161]                 }
[17:46:52.161]                 NAMES <- toupper(removed)
[17:46:52.161]                 for (kk in seq_along(NAMES)) {
[17:46:52.161]                   name <- removed[[kk]]
[17:46:52.161]                   NAME <- NAMES[[kk]]
[17:46:52.161]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.161]                     next
[17:46:52.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.161]                 }
[17:46:52.161]                 if (length(args) > 0) 
[17:46:52.161]                   base::do.call(base::Sys.setenv, args = args)
[17:46:52.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:52.161]             }
[17:46:52.161]             else {
[17:46:52.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:52.161]             }
[17:46:52.161]             {
[17:46:52.161]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:52.161]                   0L) {
[17:46:52.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:52.161]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:52.161]                   base::options(opts)
[17:46:52.161]                 }
[17:46:52.161]                 {
[17:46:52.161]                   {
[17:46:52.161]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:52.161]                     NULL
[17:46:52.161]                   }
[17:46:52.161]                   options(future.plan = NULL)
[17:46:52.161]                   if (is.na(NA_character_)) 
[17:46:52.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:52.161]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:52.161]                     .init = FALSE)
[17:46:52.161]                 }
[17:46:52.161]             }
[17:46:52.161]         }
[17:46:52.161]     })
[17:46:52.161]     if (TRUE) {
[17:46:52.161]         base::sink(type = "output", split = FALSE)
[17:46:52.161]         if (TRUE) {
[17:46:52.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:52.161]         }
[17:46:52.161]         else {
[17:46:52.161]             ...future.result["stdout"] <- base::list(NULL)
[17:46:52.161]         }
[17:46:52.161]         base::close(...future.stdout)
[17:46:52.161]         ...future.stdout <- NULL
[17:46:52.161]     }
[17:46:52.161]     ...future.result$conditions <- ...future.conditions
[17:46:52.161]     ...future.result$finished <- base::Sys.time()
[17:46:52.161]     ...future.result
[17:46:52.161] }
[17:46:52.163] assign_globals() ...
[17:46:52.163] List of 3
[17:46:52.163]  $ outer_function:function (x)  
[17:46:52.163]  $ map           :function (.x, .f, ...)  
[17:46:52.163]  $ inner_function:function (x)  
[17:46:52.163]  - attr(*, "where")=List of 3
[17:46:52.163]   ..$ outer_function:<environment: R_EmptyEnv> 
[17:46:52.163]   ..$ map           :<environment: R_EmptyEnv> 
[17:46:52.163]   ..$ inner_function:<environment: R_EmptyEnv> 
[17:46:52.163]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:52.163]  - attr(*, "resolved")= logi FALSE
[17:46:52.163]  - attr(*, "total_size")= num 7704
[17:46:52.163]  - attr(*, "already-done")= logi TRUE
[17:46:52.167] - reassign environment for ‘outer_function’
[17:46:52.167] - copied ‘outer_function’ to environment
[17:46:52.167] - reassign environment for ‘map’
[17:46:52.168] - copied ‘map’ to environment
[17:46:52.168] - reassign environment for ‘inner_function’
[17:46:52.168] - copied ‘inner_function’ to environment
[17:46:52.168] assign_globals() ... done
[17:46:52.168] requestCore(): workers = 2
[17:46:52.170] MulticoreFuture started
[17:46:52.170] - Launch lazy future ... done
[17:46:52.171] run() for ‘MulticoreFuture’ ... done
[17:46:52.171] result() for MulticoreFuture ...
[17:46:52.171] plan(): Setting new future strategy stack:
[17:46:52.171] List of future strategies:
[17:46:52.171] 1. sequential:
[17:46:52.171]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:52.171]    - tweaked: FALSE
[17:46:52.171]    - call: NULL
[17:46:52.173] plan(): nbrOfWorkers() = 1
[17:46:52.175] plan(): Setting new future strategy stack:
[17:46:52.175] List of future strategies:
[17:46:52.175] 1. multicore:
[17:46:52.175]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:52.175]    - tweaked: FALSE
[17:46:52.175]    - call: plan(strategy)
[17:46:52.181] plan(): nbrOfWorkers() = 2
[17:46:52.181] result() for MulticoreFuture ...
[17:46:52.182] result() for MulticoreFuture ... done
[17:46:52.182] result() for MulticoreFuture ... done
[17:46:52.182] result() for MulticoreFuture ...
[17:46:52.182] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[17:46:52.184] plan(): Setting new future strategy stack:
[17:46:52.184] List of future strategies:
[17:46:52.184] 1. multisession:
[17:46:52.184]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:46:52.184]    - tweaked: FALSE
[17:46:52.184]    - call: plan(strategy)
[17:46:52.185] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:46:52.185] multisession:
[17:46:52.185] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:46:52.185] - tweaked: FALSE
[17:46:52.185] - call: plan(strategy)
[17:46:52.192] getGlobalsAndPackages() ...
[17:46:52.192] Not searching for globals
[17:46:52.192] - globals: [0] <none>
[17:46:52.192] getGlobalsAndPackages() ... DONE
[17:46:52.193] [local output] makeClusterPSOCK() ...
[17:46:52.239] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:46:52.240] [local output] Base port: 11318
[17:46:52.241] [local output] Getting setup options for 2 cluster nodes ...
[17:46:52.241] [local output]  - Node 1 of 2 ...
[17:46:52.241] [local output] localMachine=TRUE => revtunnel=FALSE

[17:46:52.242] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp6A38RL/worker.rank=1.parallelly.parent=42757.a7056486ab7b.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp6A38RL/worker.rank=1.parallelly.parent=42757.a7056486ab7b.pid")'’
[17:46:52.430] - Possible to infer worker's PID: TRUE
[17:46:52.430] [local output] Rscript port: 11318

[17:46:52.431] [local output]  - Node 2 of 2 ...
[17:46:52.431] [local output] localMachine=TRUE => revtunnel=FALSE

[17:46:52.432] [local output] Rscript port: 11318

[17:46:52.432] [local output] Getting setup options for 2 cluster nodes ... done
[17:46:52.432] [local output]  - Parallel setup requested for some PSOCK nodes
[17:46:52.433] [local output] Setting up PSOCK nodes in parallel
[17:46:52.433] List of 36
[17:46:52.433]  $ worker          : chr "localhost"
[17:46:52.433]   ..- attr(*, "localhost")= logi TRUE
[17:46:52.433]  $ master          : chr "localhost"
[17:46:52.433]  $ port            : int 11318
[17:46:52.433]  $ connectTimeout  : num 120
[17:46:52.433]  $ timeout         : num 2592000
[17:46:52.433]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:46:52.433]  $ homogeneous     : logi TRUE
[17:46:52.433]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:46:52.433]  $ rscript_envs    : NULL
[17:46:52.433]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:46:52.433]  $ rscript_startup : NULL
[17:46:52.433]  $ rscript_sh      : chr "sh"
[17:46:52.433]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:46:52.433]  $ methods         : logi TRUE
[17:46:52.433]  $ socketOptions   : chr "no-delay"
[17:46:52.433]  $ useXDR          : logi FALSE
[17:46:52.433]  $ outfile         : chr "/dev/null"
[17:46:52.433]  $ renice          : int NA
[17:46:52.433]  $ rshcmd          : NULL
[17:46:52.433]  $ user            : chr(0) 
[17:46:52.433]  $ revtunnel       : logi FALSE
[17:46:52.433]  $ rshlogfile      : NULL
[17:46:52.433]  $ rshopts         : chr(0) 
[17:46:52.433]  $ rank            : int 1
[17:46:52.433]  $ manual          : logi FALSE
[17:46:52.433]  $ dryrun          : logi FALSE
[17:46:52.433]  $ quiet           : logi FALSE
[17:46:52.433]  $ setup_strategy  : chr "parallel"
[17:46:52.433]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:46:52.433]  $ pidfile         : chr "/tmp/Rtmp6A38RL/worker.rank=1.parallelly.parent=42757.a7056486ab7b.pid"
[17:46:52.433]  $ rshcmd_label    : NULL
[17:46:52.433]  $ rsh_call        : NULL
[17:46:52.433]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:46:52.433]  $ localMachine    : logi TRUE
[17:46:52.433]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:46:52.433]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:46:52.433]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:46:52.433]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:46:52.433]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:46:52.433]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:46:52.433]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:46:52.433]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:46:52.433]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:46:52.433]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:46:52.433]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:46:52.433]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:46:52.433]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:46:52.433]  $ arguments       :List of 28
[17:46:52.433]   ..$ worker          : chr "localhost"
[17:46:52.433]   ..$ master          : NULL
[17:46:52.433]   ..$ port            : int 11318
[17:46:52.433]   ..$ connectTimeout  : num 120
[17:46:52.433]   ..$ timeout         : num 2592000
[17:46:52.433]   ..$ rscript         : NULL
[17:46:52.433]   ..$ homogeneous     : NULL
[17:46:52.433]   ..$ rscript_args    : NULL
[17:46:52.433]   ..$ rscript_envs    : NULL
[17:46:52.433]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:46:52.433]   ..$ rscript_startup : NULL
[17:46:52.433]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:46:52.433]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:46:52.433]   ..$ methods         : logi TRUE
[17:46:52.433]   ..$ socketOptions   : chr "no-delay"
[17:46:52.433]   ..$ useXDR          : logi FALSE
[17:46:52.433]   ..$ outfile         : chr "/dev/null"
[17:46:52.433]   ..$ renice          : int NA
[17:46:52.433]   ..$ rshcmd          : NULL
[17:46:52.433]   ..$ user            : NULL
[17:46:52.433]   ..$ revtunnel       : logi NA
[17:46:52.433]   ..$ rshlogfile      : NULL
[17:46:52.433]   ..$ rshopts         : NULL
[17:46:52.433]   ..$ rank            : int 1
[17:46:52.433]   ..$ manual          : logi FALSE
[17:46:52.433]   ..$ dryrun          : logi FALSE
[17:46:52.433]   ..$ quiet           : logi FALSE
[17:46:52.433]   ..$ setup_strategy  : chr "parallel"
[17:46:52.433]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:46:52.449] [local output] System call to launch all workers:
[17:46:52.449] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp6A38RL/worker.rank=1.parallelly.parent=42757.a7056486ab7b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11318 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:46:52.449] [local output] Starting PSOCK main server
[17:46:52.455] [local output] Workers launched
[17:46:52.455] [local output] Waiting for workers to connect back
[17:46:52.455]  - [local output] 0 workers out of 2 ready
[17:46:52.698]  - [local output] 0 workers out of 2 ready
[17:46:52.698]  - [local output] 1 workers out of 2 ready
[17:46:52.698]  - [local output] 2 workers out of 2 ready
[17:46:52.698] [local output] Launching of workers completed
[17:46:52.699] [local output] Collecting session information from workers
[17:46:52.700] [local output]  - Worker #1 of 2
[17:46:52.700] [local output]  - Worker #2 of 2
[17:46:52.700] [local output] makeClusterPSOCK() ... done
[17:46:52.711] Packages needed by the future expression (n = 0): <none>
[17:46:52.711] Packages needed by future strategies (n = 0): <none>
[17:46:52.712] {
[17:46:52.712]     {
[17:46:52.712]         {
[17:46:52.712]             ...future.startTime <- base::Sys.time()
[17:46:52.712]             {
[17:46:52.712]                 {
[17:46:52.712]                   {
[17:46:52.712]                     {
[17:46:52.712]                       base::local({
[17:46:52.712]                         has_future <- base::requireNamespace("future", 
[17:46:52.712]                           quietly = TRUE)
[17:46:52.712]                         if (has_future) {
[17:46:52.712]                           ns <- base::getNamespace("future")
[17:46:52.712]                           version <- ns[[".package"]][["version"]]
[17:46:52.712]                           if (is.null(version)) 
[17:46:52.712]                             version <- utils::packageVersion("future")
[17:46:52.712]                         }
[17:46:52.712]                         else {
[17:46:52.712]                           version <- NULL
[17:46:52.712]                         }
[17:46:52.712]                         if (!has_future || version < "1.8.0") {
[17:46:52.712]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:52.712]                             "", base::R.version$version.string), 
[17:46:52.712]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:52.712]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:52.712]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:52.712]                               "release", "version")], collapse = " "), 
[17:46:52.712]                             hostname = base::Sys.info()[["nodename"]])
[17:46:52.712]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:52.712]                             info)
[17:46:52.712]                           info <- base::paste(info, collapse = "; ")
[17:46:52.712]                           if (!has_future) {
[17:46:52.712]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:52.712]                               info)
[17:46:52.712]                           }
[17:46:52.712]                           else {
[17:46:52.712]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:52.712]                               info, version)
[17:46:52.712]                           }
[17:46:52.712]                           base::stop(msg)
[17:46:52.712]                         }
[17:46:52.712]                       })
[17:46:52.712]                     }
[17:46:52.712]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:52.712]                     base::options(mc.cores = 1L)
[17:46:52.712]                   }
[17:46:52.712]                   ...future.strategy.old <- future::plan("list")
[17:46:52.712]                   options(future.plan = NULL)
[17:46:52.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:52.712]                 }
[17:46:52.712]                 ...future.workdir <- getwd()
[17:46:52.712]             }
[17:46:52.712]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:52.712]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:52.712]         }
[17:46:52.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:52.712]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:52.712]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:52.712]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:52.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:52.712]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:52.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:52.712]             base::names(...future.oldOptions))
[17:46:52.712]     }
[17:46:52.712]     if (FALSE) {
[17:46:52.712]     }
[17:46:52.712]     else {
[17:46:52.712]         if (TRUE) {
[17:46:52.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:52.712]                 open = "w")
[17:46:52.712]         }
[17:46:52.712]         else {
[17:46:52.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:52.712]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:52.712]         }
[17:46:52.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:52.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:52.712]             base::sink(type = "output", split = FALSE)
[17:46:52.712]             base::close(...future.stdout)
[17:46:52.712]         }, add = TRUE)
[17:46:52.712]     }
[17:46:52.712]     ...future.frame <- base::sys.nframe()
[17:46:52.712]     ...future.conditions <- base::list()
[17:46:52.712]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:52.712]     if (FALSE) {
[17:46:52.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:52.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:52.712]     }
[17:46:52.712]     ...future.result <- base::tryCatch({
[17:46:52.712]         base::withCallingHandlers({
[17:46:52.712]             ...future.value <- base::withVisible(base::local({
[17:46:52.712]                 ...future.makeSendCondition <- base::local({
[17:46:52.712]                   sendCondition <- NULL
[17:46:52.712]                   function(frame = 1L) {
[17:46:52.712]                     if (is.function(sendCondition)) 
[17:46:52.712]                       return(sendCondition)
[17:46:52.712]                     ns <- getNamespace("parallel")
[17:46:52.712]                     if (exists("sendData", mode = "function", 
[17:46:52.712]                       envir = ns)) {
[17:46:52.712]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:52.712]                         envir = ns)
[17:46:52.712]                       envir <- sys.frame(frame)
[17:46:52.712]                       master <- NULL
[17:46:52.712]                       while (!identical(envir, .GlobalEnv) && 
[17:46:52.712]                         !identical(envir, emptyenv())) {
[17:46:52.712]                         if (exists("master", mode = "list", envir = envir, 
[17:46:52.712]                           inherits = FALSE)) {
[17:46:52.712]                           master <- get("master", mode = "list", 
[17:46:52.712]                             envir = envir, inherits = FALSE)
[17:46:52.712]                           if (inherits(master, c("SOCKnode", 
[17:46:52.712]                             "SOCK0node"))) {
[17:46:52.712]                             sendCondition <<- function(cond) {
[17:46:52.712]                               data <- list(type = "VALUE", value = cond, 
[17:46:52.712]                                 success = TRUE)
[17:46:52.712]                               parallel_sendData(master, data)
[17:46:52.712]                             }
[17:46:52.712]                             return(sendCondition)
[17:46:52.712]                           }
[17:46:52.712]                         }
[17:46:52.712]                         frame <- frame + 1L
[17:46:52.712]                         envir <- sys.frame(frame)
[17:46:52.712]                       }
[17:46:52.712]                     }
[17:46:52.712]                     sendCondition <<- function(cond) NULL
[17:46:52.712]                   }
[17:46:52.712]                 })
[17:46:52.712]                 withCallingHandlers({
[17:46:52.712]                   NA
[17:46:52.712]                 }, immediateCondition = function(cond) {
[17:46:52.712]                   sendCondition <- ...future.makeSendCondition()
[17:46:52.712]                   sendCondition(cond)
[17:46:52.712]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.712]                   {
[17:46:52.712]                     inherits <- base::inherits
[17:46:52.712]                     invokeRestart <- base::invokeRestart
[17:46:52.712]                     is.null <- base::is.null
[17:46:52.712]                     muffled <- FALSE
[17:46:52.712]                     if (inherits(cond, "message")) {
[17:46:52.712]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:52.712]                       if (muffled) 
[17:46:52.712]                         invokeRestart("muffleMessage")
[17:46:52.712]                     }
[17:46:52.712]                     else if (inherits(cond, "warning")) {
[17:46:52.712]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:52.712]                       if (muffled) 
[17:46:52.712]                         invokeRestart("muffleWarning")
[17:46:52.712]                     }
[17:46:52.712]                     else if (inherits(cond, "condition")) {
[17:46:52.712]                       if (!is.null(pattern)) {
[17:46:52.712]                         computeRestarts <- base::computeRestarts
[17:46:52.712]                         grepl <- base::grepl
[17:46:52.712]                         restarts <- computeRestarts(cond)
[17:46:52.712]                         for (restart in restarts) {
[17:46:52.712]                           name <- restart$name
[17:46:52.712]                           if (is.null(name)) 
[17:46:52.712]                             next
[17:46:52.712]                           if (!grepl(pattern, name)) 
[17:46:52.712]                             next
[17:46:52.712]                           invokeRestart(restart)
[17:46:52.712]                           muffled <- TRUE
[17:46:52.712]                           break
[17:46:52.712]                         }
[17:46:52.712]                       }
[17:46:52.712]                     }
[17:46:52.712]                     invisible(muffled)
[17:46:52.712]                   }
[17:46:52.712]                   muffleCondition(cond)
[17:46:52.712]                 })
[17:46:52.712]             }))
[17:46:52.712]             future::FutureResult(value = ...future.value$value, 
[17:46:52.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.712]                   ...future.rng), globalenv = if (FALSE) 
[17:46:52.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:52.712]                     ...future.globalenv.names))
[17:46:52.712]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:52.712]         }, condition = base::local({
[17:46:52.712]             c <- base::c
[17:46:52.712]             inherits <- base::inherits
[17:46:52.712]             invokeRestart <- base::invokeRestart
[17:46:52.712]             length <- base::length
[17:46:52.712]             list <- base::list
[17:46:52.712]             seq.int <- base::seq.int
[17:46:52.712]             signalCondition <- base::signalCondition
[17:46:52.712]             sys.calls <- base::sys.calls
[17:46:52.712]             `[[` <- base::`[[`
[17:46:52.712]             `+` <- base::`+`
[17:46:52.712]             `<<-` <- base::`<<-`
[17:46:52.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:52.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:52.712]                   3L)]
[17:46:52.712]             }
[17:46:52.712]             function(cond) {
[17:46:52.712]                 is_error <- inherits(cond, "error")
[17:46:52.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:52.712]                   NULL)
[17:46:52.712]                 if (is_error) {
[17:46:52.712]                   sessionInformation <- function() {
[17:46:52.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:52.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:52.712]                       search = base::search(), system = base::Sys.info())
[17:46:52.712]                   }
[17:46:52.712]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:52.712]                     cond$call), session = sessionInformation(), 
[17:46:52.712]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:52.712]                   signalCondition(cond)
[17:46:52.712]                 }
[17:46:52.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:52.712]                 "immediateCondition"))) {
[17:46:52.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:52.712]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:52.712]                   if (TRUE && !signal) {
[17:46:52.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.712]                     {
[17:46:52.712]                       inherits <- base::inherits
[17:46:52.712]                       invokeRestart <- base::invokeRestart
[17:46:52.712]                       is.null <- base::is.null
[17:46:52.712]                       muffled <- FALSE
[17:46:52.712]                       if (inherits(cond, "message")) {
[17:46:52.712]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.712]                         if (muffled) 
[17:46:52.712]                           invokeRestart("muffleMessage")
[17:46:52.712]                       }
[17:46:52.712]                       else if (inherits(cond, "warning")) {
[17:46:52.712]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.712]                         if (muffled) 
[17:46:52.712]                           invokeRestart("muffleWarning")
[17:46:52.712]                       }
[17:46:52.712]                       else if (inherits(cond, "condition")) {
[17:46:52.712]                         if (!is.null(pattern)) {
[17:46:52.712]                           computeRestarts <- base::computeRestarts
[17:46:52.712]                           grepl <- base::grepl
[17:46:52.712]                           restarts <- computeRestarts(cond)
[17:46:52.712]                           for (restart in restarts) {
[17:46:52.712]                             name <- restart$name
[17:46:52.712]                             if (is.null(name)) 
[17:46:52.712]                               next
[17:46:52.712]                             if (!grepl(pattern, name)) 
[17:46:52.712]                               next
[17:46:52.712]                             invokeRestart(restart)
[17:46:52.712]                             muffled <- TRUE
[17:46:52.712]                             break
[17:46:52.712]                           }
[17:46:52.712]                         }
[17:46:52.712]                       }
[17:46:52.712]                       invisible(muffled)
[17:46:52.712]                     }
[17:46:52.712]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.712]                   }
[17:46:52.712]                 }
[17:46:52.712]                 else {
[17:46:52.712]                   if (TRUE) {
[17:46:52.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.712]                     {
[17:46:52.712]                       inherits <- base::inherits
[17:46:52.712]                       invokeRestart <- base::invokeRestart
[17:46:52.712]                       is.null <- base::is.null
[17:46:52.712]                       muffled <- FALSE
[17:46:52.712]                       if (inherits(cond, "message")) {
[17:46:52.712]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.712]                         if (muffled) 
[17:46:52.712]                           invokeRestart("muffleMessage")
[17:46:52.712]                       }
[17:46:52.712]                       else if (inherits(cond, "warning")) {
[17:46:52.712]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.712]                         if (muffled) 
[17:46:52.712]                           invokeRestart("muffleWarning")
[17:46:52.712]                       }
[17:46:52.712]                       else if (inherits(cond, "condition")) {
[17:46:52.712]                         if (!is.null(pattern)) {
[17:46:52.712]                           computeRestarts <- base::computeRestarts
[17:46:52.712]                           grepl <- base::grepl
[17:46:52.712]                           restarts <- computeRestarts(cond)
[17:46:52.712]                           for (restart in restarts) {
[17:46:52.712]                             name <- restart$name
[17:46:52.712]                             if (is.null(name)) 
[17:46:52.712]                               next
[17:46:52.712]                             if (!grepl(pattern, name)) 
[17:46:52.712]                               next
[17:46:52.712]                             invokeRestart(restart)
[17:46:52.712]                             muffled <- TRUE
[17:46:52.712]                             break
[17:46:52.712]                           }
[17:46:52.712]                         }
[17:46:52.712]                       }
[17:46:52.712]                       invisible(muffled)
[17:46:52.712]                     }
[17:46:52.712]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.712]                   }
[17:46:52.712]                 }
[17:46:52.712]             }
[17:46:52.712]         }))
[17:46:52.712]     }, error = function(ex) {
[17:46:52.712]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:52.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.712]                 ...future.rng), started = ...future.startTime, 
[17:46:52.712]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:52.712]             version = "1.8"), class = "FutureResult")
[17:46:52.712]     }, finally = {
[17:46:52.712]         if (!identical(...future.workdir, getwd())) 
[17:46:52.712]             setwd(...future.workdir)
[17:46:52.712]         {
[17:46:52.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:52.712]                 ...future.oldOptions$nwarnings <- NULL
[17:46:52.712]             }
[17:46:52.712]             base::options(...future.oldOptions)
[17:46:52.712]             if (.Platform$OS.type == "windows") {
[17:46:52.712]                 old_names <- names(...future.oldEnvVars)
[17:46:52.712]                 envs <- base::Sys.getenv()
[17:46:52.712]                 names <- names(envs)
[17:46:52.712]                 common <- intersect(names, old_names)
[17:46:52.712]                 added <- setdiff(names, old_names)
[17:46:52.712]                 removed <- setdiff(old_names, names)
[17:46:52.712]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:52.712]                   envs[common]]
[17:46:52.712]                 NAMES <- toupper(changed)
[17:46:52.712]                 args <- list()
[17:46:52.712]                 for (kk in seq_along(NAMES)) {
[17:46:52.712]                   name <- changed[[kk]]
[17:46:52.712]                   NAME <- NAMES[[kk]]
[17:46:52.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.712]                     next
[17:46:52.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.712]                 }
[17:46:52.712]                 NAMES <- toupper(added)
[17:46:52.712]                 for (kk in seq_along(NAMES)) {
[17:46:52.712]                   name <- added[[kk]]
[17:46:52.712]                   NAME <- NAMES[[kk]]
[17:46:52.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.712]                     next
[17:46:52.712]                   args[[name]] <- ""
[17:46:52.712]                 }
[17:46:52.712]                 NAMES <- toupper(removed)
[17:46:52.712]                 for (kk in seq_along(NAMES)) {
[17:46:52.712]                   name <- removed[[kk]]
[17:46:52.712]                   NAME <- NAMES[[kk]]
[17:46:52.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.712]                     next
[17:46:52.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.712]                 }
[17:46:52.712]                 if (length(args) > 0) 
[17:46:52.712]                   base::do.call(base::Sys.setenv, args = args)
[17:46:52.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:52.712]             }
[17:46:52.712]             else {
[17:46:52.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:52.712]             }
[17:46:52.712]             {
[17:46:52.712]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:52.712]                   0L) {
[17:46:52.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:52.712]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:52.712]                   base::options(opts)
[17:46:52.712]                 }
[17:46:52.712]                 {
[17:46:52.712]                   {
[17:46:52.712]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:52.712]                     NULL
[17:46:52.712]                   }
[17:46:52.712]                   options(future.plan = NULL)
[17:46:52.712]                   if (is.na(NA_character_)) 
[17:46:52.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:52.712]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:52.712]                     .init = FALSE)
[17:46:52.712]                 }
[17:46:52.712]             }
[17:46:52.712]         }
[17:46:52.712]     })
[17:46:52.712]     if (TRUE) {
[17:46:52.712]         base::sink(type = "output", split = FALSE)
[17:46:52.712]         if (TRUE) {
[17:46:52.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:52.712]         }
[17:46:52.712]         else {
[17:46:52.712]             ...future.result["stdout"] <- base::list(NULL)
[17:46:52.712]         }
[17:46:52.712]         base::close(...future.stdout)
[17:46:52.712]         ...future.stdout <- NULL
[17:46:52.712]     }
[17:46:52.712]     ...future.result$conditions <- ...future.conditions
[17:46:52.712]     ...future.result$finished <- base::Sys.time()
[17:46:52.712]     ...future.result
[17:46:52.712] }
[17:46:52.763] MultisessionFuture started
[17:46:52.764] result() for ClusterFuture ...
[17:46:52.764] receiveMessageFromWorker() for ClusterFuture ...
[17:46:52.765] - Validating connection of MultisessionFuture
[17:46:52.796] - received message: FutureResult
[17:46:52.796] - Received FutureResult
[17:46:52.796] - Erased future from FutureRegistry
[17:46:52.796] result() for ClusterFuture ...
[17:46:52.796] - result already collected: FutureResult
[17:46:52.796] result() for ClusterFuture ... done
[17:46:52.796] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:52.797] result() for ClusterFuture ... done
[17:46:52.797] result() for ClusterFuture ...
[17:46:52.797] - result already collected: FutureResult
[17:46:52.797] result() for ClusterFuture ... done
[17:46:52.797] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:46:52.801] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[17:46:52.801] getGlobalsAndPackages() ...
[17:46:52.801] Searching for globals...
[17:46:52.803] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:52.804] Searching for globals ... DONE
[17:46:52.804] Resolving globals: FALSE
[17:46:52.804] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:52.805] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:52.805] - globals: [2] ‘weight’, ‘group’
[17:46:52.805] - packages: [1] ‘stats’
[17:46:52.805] getGlobalsAndPackages() ... DONE
[17:46:52.805] run() for ‘Future’ ...
[17:46:52.806] - state: ‘created’
[17:46:52.806] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:52.820] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:52.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:52.820]   - Field: ‘node’
[17:46:52.821]   - Field: ‘label’
[17:46:52.821]   - Field: ‘local’
[17:46:52.821]   - Field: ‘owner’
[17:46:52.821]   - Field: ‘envir’
[17:46:52.821]   - Field: ‘workers’
[17:46:52.821]   - Field: ‘packages’
[17:46:52.821]   - Field: ‘gc’
[17:46:52.821]   - Field: ‘conditions’
[17:46:52.821]   - Field: ‘persistent’
[17:46:52.821]   - Field: ‘expr’
[17:46:52.822]   - Field: ‘uuid’
[17:46:52.822]   - Field: ‘seed’
[17:46:52.822]   - Field: ‘version’
[17:46:52.822]   - Field: ‘result’
[17:46:52.822]   - Field: ‘asynchronous’
[17:46:52.822]   - Field: ‘calls’
[17:46:52.822]   - Field: ‘globals’
[17:46:52.822]   - Field: ‘stdout’
[17:46:52.822]   - Field: ‘earlySignal’
[17:46:52.823]   - Field: ‘lazy’
[17:46:52.823]   - Field: ‘state’
[17:46:52.823] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:52.823] - Launch lazy future ...
[17:46:52.823] Packages needed by the future expression (n = 1): ‘stats’
[17:46:52.823] Packages needed by future strategies (n = 0): <none>
[17:46:52.824] {
[17:46:52.824]     {
[17:46:52.824]         {
[17:46:52.824]             ...future.startTime <- base::Sys.time()
[17:46:52.824]             {
[17:46:52.824]                 {
[17:46:52.824]                   {
[17:46:52.824]                     {
[17:46:52.824]                       {
[17:46:52.824]                         base::local({
[17:46:52.824]                           has_future <- base::requireNamespace("future", 
[17:46:52.824]                             quietly = TRUE)
[17:46:52.824]                           if (has_future) {
[17:46:52.824]                             ns <- base::getNamespace("future")
[17:46:52.824]                             version <- ns[[".package"]][["version"]]
[17:46:52.824]                             if (is.null(version)) 
[17:46:52.824]                               version <- utils::packageVersion("future")
[17:46:52.824]                           }
[17:46:52.824]                           else {
[17:46:52.824]                             version <- NULL
[17:46:52.824]                           }
[17:46:52.824]                           if (!has_future || version < "1.8.0") {
[17:46:52.824]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:52.824]                               "", base::R.version$version.string), 
[17:46:52.824]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:52.824]                                 base::R.version$platform, 8 * 
[17:46:52.824]                                   base::.Machine$sizeof.pointer), 
[17:46:52.824]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:52.824]                                 "release", "version")], collapse = " "), 
[17:46:52.824]                               hostname = base::Sys.info()[["nodename"]])
[17:46:52.824]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:52.824]                               info)
[17:46:52.824]                             info <- base::paste(info, collapse = "; ")
[17:46:52.824]                             if (!has_future) {
[17:46:52.824]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:52.824]                                 info)
[17:46:52.824]                             }
[17:46:52.824]                             else {
[17:46:52.824]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:52.824]                                 info, version)
[17:46:52.824]                             }
[17:46:52.824]                             base::stop(msg)
[17:46:52.824]                           }
[17:46:52.824]                         })
[17:46:52.824]                       }
[17:46:52.824]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:52.824]                       base::options(mc.cores = 1L)
[17:46:52.824]                     }
[17:46:52.824]                     base::local({
[17:46:52.824]                       for (pkg in "stats") {
[17:46:52.824]                         base::loadNamespace(pkg)
[17:46:52.824]                         base::library(pkg, character.only = TRUE)
[17:46:52.824]                       }
[17:46:52.824]                     })
[17:46:52.824]                   }
[17:46:52.824]                   ...future.strategy.old <- future::plan("list")
[17:46:52.824]                   options(future.plan = NULL)
[17:46:52.824]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.824]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:52.824]                 }
[17:46:52.824]                 ...future.workdir <- getwd()
[17:46:52.824]             }
[17:46:52.824]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:52.824]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:52.824]         }
[17:46:52.824]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:52.824]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:52.824]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:52.824]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:52.824]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:52.824]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:52.824]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:52.824]             base::names(...future.oldOptions))
[17:46:52.824]     }
[17:46:52.824]     if (FALSE) {
[17:46:52.824]     }
[17:46:52.824]     else {
[17:46:52.824]         if (TRUE) {
[17:46:52.824]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:52.824]                 open = "w")
[17:46:52.824]         }
[17:46:52.824]         else {
[17:46:52.824]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:52.824]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:52.824]         }
[17:46:52.824]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:52.824]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:52.824]             base::sink(type = "output", split = FALSE)
[17:46:52.824]             base::close(...future.stdout)
[17:46:52.824]         }, add = TRUE)
[17:46:52.824]     }
[17:46:52.824]     ...future.frame <- base::sys.nframe()
[17:46:52.824]     ...future.conditions <- base::list()
[17:46:52.824]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:52.824]     if (FALSE) {
[17:46:52.824]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:52.824]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:52.824]     }
[17:46:52.824]     ...future.result <- base::tryCatch({
[17:46:52.824]         base::withCallingHandlers({
[17:46:52.824]             ...future.value <- base::withVisible(base::local({
[17:46:52.824]                 ...future.makeSendCondition <- base::local({
[17:46:52.824]                   sendCondition <- NULL
[17:46:52.824]                   function(frame = 1L) {
[17:46:52.824]                     if (is.function(sendCondition)) 
[17:46:52.824]                       return(sendCondition)
[17:46:52.824]                     ns <- getNamespace("parallel")
[17:46:52.824]                     if (exists("sendData", mode = "function", 
[17:46:52.824]                       envir = ns)) {
[17:46:52.824]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:52.824]                         envir = ns)
[17:46:52.824]                       envir <- sys.frame(frame)
[17:46:52.824]                       master <- NULL
[17:46:52.824]                       while (!identical(envir, .GlobalEnv) && 
[17:46:52.824]                         !identical(envir, emptyenv())) {
[17:46:52.824]                         if (exists("master", mode = "list", envir = envir, 
[17:46:52.824]                           inherits = FALSE)) {
[17:46:52.824]                           master <- get("master", mode = "list", 
[17:46:52.824]                             envir = envir, inherits = FALSE)
[17:46:52.824]                           if (inherits(master, c("SOCKnode", 
[17:46:52.824]                             "SOCK0node"))) {
[17:46:52.824]                             sendCondition <<- function(cond) {
[17:46:52.824]                               data <- list(type = "VALUE", value = cond, 
[17:46:52.824]                                 success = TRUE)
[17:46:52.824]                               parallel_sendData(master, data)
[17:46:52.824]                             }
[17:46:52.824]                             return(sendCondition)
[17:46:52.824]                           }
[17:46:52.824]                         }
[17:46:52.824]                         frame <- frame + 1L
[17:46:52.824]                         envir <- sys.frame(frame)
[17:46:52.824]                       }
[17:46:52.824]                     }
[17:46:52.824]                     sendCondition <<- function(cond) NULL
[17:46:52.824]                   }
[17:46:52.824]                 })
[17:46:52.824]                 withCallingHandlers({
[17:46:52.824]                   {
[17:46:52.824]                     lm(weight ~ group - 1)
[17:46:52.824]                   }
[17:46:52.824]                 }, immediateCondition = function(cond) {
[17:46:52.824]                   sendCondition <- ...future.makeSendCondition()
[17:46:52.824]                   sendCondition(cond)
[17:46:52.824]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.824]                   {
[17:46:52.824]                     inherits <- base::inherits
[17:46:52.824]                     invokeRestart <- base::invokeRestart
[17:46:52.824]                     is.null <- base::is.null
[17:46:52.824]                     muffled <- FALSE
[17:46:52.824]                     if (inherits(cond, "message")) {
[17:46:52.824]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:52.824]                       if (muffled) 
[17:46:52.824]                         invokeRestart("muffleMessage")
[17:46:52.824]                     }
[17:46:52.824]                     else if (inherits(cond, "warning")) {
[17:46:52.824]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:52.824]                       if (muffled) 
[17:46:52.824]                         invokeRestart("muffleWarning")
[17:46:52.824]                     }
[17:46:52.824]                     else if (inherits(cond, "condition")) {
[17:46:52.824]                       if (!is.null(pattern)) {
[17:46:52.824]                         computeRestarts <- base::computeRestarts
[17:46:52.824]                         grepl <- base::grepl
[17:46:52.824]                         restarts <- computeRestarts(cond)
[17:46:52.824]                         for (restart in restarts) {
[17:46:52.824]                           name <- restart$name
[17:46:52.824]                           if (is.null(name)) 
[17:46:52.824]                             next
[17:46:52.824]                           if (!grepl(pattern, name)) 
[17:46:52.824]                             next
[17:46:52.824]                           invokeRestart(restart)
[17:46:52.824]                           muffled <- TRUE
[17:46:52.824]                           break
[17:46:52.824]                         }
[17:46:52.824]                       }
[17:46:52.824]                     }
[17:46:52.824]                     invisible(muffled)
[17:46:52.824]                   }
[17:46:52.824]                   muffleCondition(cond)
[17:46:52.824]                 })
[17:46:52.824]             }))
[17:46:52.824]             future::FutureResult(value = ...future.value$value, 
[17:46:52.824]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.824]                   ...future.rng), globalenv = if (FALSE) 
[17:46:52.824]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:52.824]                     ...future.globalenv.names))
[17:46:52.824]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:52.824]         }, condition = base::local({
[17:46:52.824]             c <- base::c
[17:46:52.824]             inherits <- base::inherits
[17:46:52.824]             invokeRestart <- base::invokeRestart
[17:46:52.824]             length <- base::length
[17:46:52.824]             list <- base::list
[17:46:52.824]             seq.int <- base::seq.int
[17:46:52.824]             signalCondition <- base::signalCondition
[17:46:52.824]             sys.calls <- base::sys.calls
[17:46:52.824]             `[[` <- base::`[[`
[17:46:52.824]             `+` <- base::`+`
[17:46:52.824]             `<<-` <- base::`<<-`
[17:46:52.824]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:52.824]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:52.824]                   3L)]
[17:46:52.824]             }
[17:46:52.824]             function(cond) {
[17:46:52.824]                 is_error <- inherits(cond, "error")
[17:46:52.824]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:52.824]                   NULL)
[17:46:52.824]                 if (is_error) {
[17:46:52.824]                   sessionInformation <- function() {
[17:46:52.824]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:52.824]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:52.824]                       search = base::search(), system = base::Sys.info())
[17:46:52.824]                   }
[17:46:52.824]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.824]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:52.824]                     cond$call), session = sessionInformation(), 
[17:46:52.824]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:52.824]                   signalCondition(cond)
[17:46:52.824]                 }
[17:46:52.824]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:52.824]                 "immediateCondition"))) {
[17:46:52.824]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:52.824]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.824]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:52.824]                   if (TRUE && !signal) {
[17:46:52.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.824]                     {
[17:46:52.824]                       inherits <- base::inherits
[17:46:52.824]                       invokeRestart <- base::invokeRestart
[17:46:52.824]                       is.null <- base::is.null
[17:46:52.824]                       muffled <- FALSE
[17:46:52.824]                       if (inherits(cond, "message")) {
[17:46:52.824]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.824]                         if (muffled) 
[17:46:52.824]                           invokeRestart("muffleMessage")
[17:46:52.824]                       }
[17:46:52.824]                       else if (inherits(cond, "warning")) {
[17:46:52.824]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.824]                         if (muffled) 
[17:46:52.824]                           invokeRestart("muffleWarning")
[17:46:52.824]                       }
[17:46:52.824]                       else if (inherits(cond, "condition")) {
[17:46:52.824]                         if (!is.null(pattern)) {
[17:46:52.824]                           computeRestarts <- base::computeRestarts
[17:46:52.824]                           grepl <- base::grepl
[17:46:52.824]                           restarts <- computeRestarts(cond)
[17:46:52.824]                           for (restart in restarts) {
[17:46:52.824]                             name <- restart$name
[17:46:52.824]                             if (is.null(name)) 
[17:46:52.824]                               next
[17:46:52.824]                             if (!grepl(pattern, name)) 
[17:46:52.824]                               next
[17:46:52.824]                             invokeRestart(restart)
[17:46:52.824]                             muffled <- TRUE
[17:46:52.824]                             break
[17:46:52.824]                           }
[17:46:52.824]                         }
[17:46:52.824]                       }
[17:46:52.824]                       invisible(muffled)
[17:46:52.824]                     }
[17:46:52.824]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.824]                   }
[17:46:52.824]                 }
[17:46:52.824]                 else {
[17:46:52.824]                   if (TRUE) {
[17:46:52.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.824]                     {
[17:46:52.824]                       inherits <- base::inherits
[17:46:52.824]                       invokeRestart <- base::invokeRestart
[17:46:52.824]                       is.null <- base::is.null
[17:46:52.824]                       muffled <- FALSE
[17:46:52.824]                       if (inherits(cond, "message")) {
[17:46:52.824]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.824]                         if (muffled) 
[17:46:52.824]                           invokeRestart("muffleMessage")
[17:46:52.824]                       }
[17:46:52.824]                       else if (inherits(cond, "warning")) {
[17:46:52.824]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.824]                         if (muffled) 
[17:46:52.824]                           invokeRestart("muffleWarning")
[17:46:52.824]                       }
[17:46:52.824]                       else if (inherits(cond, "condition")) {
[17:46:52.824]                         if (!is.null(pattern)) {
[17:46:52.824]                           computeRestarts <- base::computeRestarts
[17:46:52.824]                           grepl <- base::grepl
[17:46:52.824]                           restarts <- computeRestarts(cond)
[17:46:52.824]                           for (restart in restarts) {
[17:46:52.824]                             name <- restart$name
[17:46:52.824]                             if (is.null(name)) 
[17:46:52.824]                               next
[17:46:52.824]                             if (!grepl(pattern, name)) 
[17:46:52.824]                               next
[17:46:52.824]                             invokeRestart(restart)
[17:46:52.824]                             muffled <- TRUE
[17:46:52.824]                             break
[17:46:52.824]                           }
[17:46:52.824]                         }
[17:46:52.824]                       }
[17:46:52.824]                       invisible(muffled)
[17:46:52.824]                     }
[17:46:52.824]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.824]                   }
[17:46:52.824]                 }
[17:46:52.824]             }
[17:46:52.824]         }))
[17:46:52.824]     }, error = function(ex) {
[17:46:52.824]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:52.824]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.824]                 ...future.rng), started = ...future.startTime, 
[17:46:52.824]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:52.824]             version = "1.8"), class = "FutureResult")
[17:46:52.824]     }, finally = {
[17:46:52.824]         if (!identical(...future.workdir, getwd())) 
[17:46:52.824]             setwd(...future.workdir)
[17:46:52.824]         {
[17:46:52.824]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:52.824]                 ...future.oldOptions$nwarnings <- NULL
[17:46:52.824]             }
[17:46:52.824]             base::options(...future.oldOptions)
[17:46:52.824]             if (.Platform$OS.type == "windows") {
[17:46:52.824]                 old_names <- names(...future.oldEnvVars)
[17:46:52.824]                 envs <- base::Sys.getenv()
[17:46:52.824]                 names <- names(envs)
[17:46:52.824]                 common <- intersect(names, old_names)
[17:46:52.824]                 added <- setdiff(names, old_names)
[17:46:52.824]                 removed <- setdiff(old_names, names)
[17:46:52.824]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:52.824]                   envs[common]]
[17:46:52.824]                 NAMES <- toupper(changed)
[17:46:52.824]                 args <- list()
[17:46:52.824]                 for (kk in seq_along(NAMES)) {
[17:46:52.824]                   name <- changed[[kk]]
[17:46:52.824]                   NAME <- NAMES[[kk]]
[17:46:52.824]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.824]                     next
[17:46:52.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.824]                 }
[17:46:52.824]                 NAMES <- toupper(added)
[17:46:52.824]                 for (kk in seq_along(NAMES)) {
[17:46:52.824]                   name <- added[[kk]]
[17:46:52.824]                   NAME <- NAMES[[kk]]
[17:46:52.824]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.824]                     next
[17:46:52.824]                   args[[name]] <- ""
[17:46:52.824]                 }
[17:46:52.824]                 NAMES <- toupper(removed)
[17:46:52.824]                 for (kk in seq_along(NAMES)) {
[17:46:52.824]                   name <- removed[[kk]]
[17:46:52.824]                   NAME <- NAMES[[kk]]
[17:46:52.824]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.824]                     next
[17:46:52.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.824]                 }
[17:46:52.824]                 if (length(args) > 0) 
[17:46:52.824]                   base::do.call(base::Sys.setenv, args = args)
[17:46:52.824]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:52.824]             }
[17:46:52.824]             else {
[17:46:52.824]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:52.824]             }
[17:46:52.824]             {
[17:46:52.824]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:52.824]                   0L) {
[17:46:52.824]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:52.824]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:52.824]                   base::options(opts)
[17:46:52.824]                 }
[17:46:52.824]                 {
[17:46:52.824]                   {
[17:46:52.824]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:52.824]                     NULL
[17:46:52.824]                   }
[17:46:52.824]                   options(future.plan = NULL)
[17:46:52.824]                   if (is.na(NA_character_)) 
[17:46:52.824]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.824]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:52.824]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:52.824]                     .init = FALSE)
[17:46:52.824]                 }
[17:46:52.824]             }
[17:46:52.824]         }
[17:46:52.824]     })
[17:46:52.824]     if (TRUE) {
[17:46:52.824]         base::sink(type = "output", split = FALSE)
[17:46:52.824]         if (TRUE) {
[17:46:52.824]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:52.824]         }
[17:46:52.824]         else {
[17:46:52.824]             ...future.result["stdout"] <- base::list(NULL)
[17:46:52.824]         }
[17:46:52.824]         base::close(...future.stdout)
[17:46:52.824]         ...future.stdout <- NULL
[17:46:52.824]     }
[17:46:52.824]     ...future.result$conditions <- ...future.conditions
[17:46:52.824]     ...future.result$finished <- base::Sys.time()
[17:46:52.824]     ...future.result
[17:46:52.824] }
[17:46:52.827] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:46:52.827] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:46:52.828] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:46:52.828] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:46:52.828] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:46:52.828] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:46:52.829] MultisessionFuture started
[17:46:52.829] - Launch lazy future ... done
[17:46:52.829] run() for ‘MultisessionFuture’ ... done
[17:46:52.829] result() for ClusterFuture ...
[17:46:52.830] receiveMessageFromWorker() for ClusterFuture ...
[17:46:52.830] - Validating connection of MultisessionFuture
[17:46:52.880] - received message: FutureResult
[17:46:52.880] - Received FutureResult
[17:46:52.880] - Erased future from FutureRegistry
[17:46:52.880] result() for ClusterFuture ...
[17:46:52.880] - result already collected: FutureResult
[17:46:52.880] result() for ClusterFuture ... done
[17:46:52.881] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:52.881] result() for ClusterFuture ... done
[17:46:52.881] result() for ClusterFuture ...
[17:46:52.881] - result already collected: FutureResult
[17:46:52.881] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:46:52.883] getGlobalsAndPackages() ...
[17:46:52.883] Searching for globals...
[17:46:52.885] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:52.885] Searching for globals ... DONE
[17:46:52.885] Resolving globals: FALSE
[17:46:52.886] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:52.886] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:52.887] - globals: [2] ‘weight’, ‘group’
[17:46:52.887] - packages: [1] ‘stats’
[17:46:52.887] getGlobalsAndPackages() ... DONE
[17:46:52.887] run() for ‘Future’ ...
[17:46:52.887] - state: ‘created’
[17:46:52.887] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:52.902] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:52.902] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:52.902]   - Field: ‘node’
[17:46:52.902]   - Field: ‘label’
[17:46:52.902]   - Field: ‘local’
[17:46:52.902]   - Field: ‘owner’
[17:46:52.902]   - Field: ‘envir’
[17:46:52.902]   - Field: ‘workers’
[17:46:52.903]   - Field: ‘packages’
[17:46:52.903]   - Field: ‘gc’
[17:46:52.903]   - Field: ‘conditions’
[17:46:52.903]   - Field: ‘persistent’
[17:46:52.903]   - Field: ‘expr’
[17:46:52.903]   - Field: ‘uuid’
[17:46:52.903]   - Field: ‘seed’
[17:46:52.903]   - Field: ‘version’
[17:46:52.904]   - Field: ‘result’
[17:46:52.904]   - Field: ‘asynchronous’
[17:46:52.904]   - Field: ‘calls’
[17:46:52.904]   - Field: ‘globals’
[17:46:52.904]   - Field: ‘stdout’
[17:46:52.904]   - Field: ‘earlySignal’
[17:46:52.904]   - Field: ‘lazy’
[17:46:52.904]   - Field: ‘state’
[17:46:52.904] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:52.905] - Launch lazy future ...
[17:46:52.905] Packages needed by the future expression (n = 1): ‘stats’
[17:46:52.905] Packages needed by future strategies (n = 0): <none>
[17:46:52.906] {
[17:46:52.906]     {
[17:46:52.906]         {
[17:46:52.906]             ...future.startTime <- base::Sys.time()
[17:46:52.906]             {
[17:46:52.906]                 {
[17:46:52.906]                   {
[17:46:52.906]                     {
[17:46:52.906]                       {
[17:46:52.906]                         base::local({
[17:46:52.906]                           has_future <- base::requireNamespace("future", 
[17:46:52.906]                             quietly = TRUE)
[17:46:52.906]                           if (has_future) {
[17:46:52.906]                             ns <- base::getNamespace("future")
[17:46:52.906]                             version <- ns[[".package"]][["version"]]
[17:46:52.906]                             if (is.null(version)) 
[17:46:52.906]                               version <- utils::packageVersion("future")
[17:46:52.906]                           }
[17:46:52.906]                           else {
[17:46:52.906]                             version <- NULL
[17:46:52.906]                           }
[17:46:52.906]                           if (!has_future || version < "1.8.0") {
[17:46:52.906]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:52.906]                               "", base::R.version$version.string), 
[17:46:52.906]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:52.906]                                 base::R.version$platform, 8 * 
[17:46:52.906]                                   base::.Machine$sizeof.pointer), 
[17:46:52.906]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:52.906]                                 "release", "version")], collapse = " "), 
[17:46:52.906]                               hostname = base::Sys.info()[["nodename"]])
[17:46:52.906]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:52.906]                               info)
[17:46:52.906]                             info <- base::paste(info, collapse = "; ")
[17:46:52.906]                             if (!has_future) {
[17:46:52.906]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:52.906]                                 info)
[17:46:52.906]                             }
[17:46:52.906]                             else {
[17:46:52.906]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:52.906]                                 info, version)
[17:46:52.906]                             }
[17:46:52.906]                             base::stop(msg)
[17:46:52.906]                           }
[17:46:52.906]                         })
[17:46:52.906]                       }
[17:46:52.906]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:52.906]                       base::options(mc.cores = 1L)
[17:46:52.906]                     }
[17:46:52.906]                     base::local({
[17:46:52.906]                       for (pkg in "stats") {
[17:46:52.906]                         base::loadNamespace(pkg)
[17:46:52.906]                         base::library(pkg, character.only = TRUE)
[17:46:52.906]                       }
[17:46:52.906]                     })
[17:46:52.906]                   }
[17:46:52.906]                   ...future.strategy.old <- future::plan("list")
[17:46:52.906]                   options(future.plan = NULL)
[17:46:52.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:52.906]                 }
[17:46:52.906]                 ...future.workdir <- getwd()
[17:46:52.906]             }
[17:46:52.906]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:52.906]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:52.906]         }
[17:46:52.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:52.906]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:52.906]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:52.906]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:52.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:52.906]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:52.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:52.906]             base::names(...future.oldOptions))
[17:46:52.906]     }
[17:46:52.906]     if (FALSE) {
[17:46:52.906]     }
[17:46:52.906]     else {
[17:46:52.906]         if (TRUE) {
[17:46:52.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:52.906]                 open = "w")
[17:46:52.906]         }
[17:46:52.906]         else {
[17:46:52.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:52.906]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:52.906]         }
[17:46:52.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:52.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:52.906]             base::sink(type = "output", split = FALSE)
[17:46:52.906]             base::close(...future.stdout)
[17:46:52.906]         }, add = TRUE)
[17:46:52.906]     }
[17:46:52.906]     ...future.frame <- base::sys.nframe()
[17:46:52.906]     ...future.conditions <- base::list()
[17:46:52.906]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:52.906]     if (FALSE) {
[17:46:52.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:52.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:52.906]     }
[17:46:52.906]     ...future.result <- base::tryCatch({
[17:46:52.906]         base::withCallingHandlers({
[17:46:52.906]             ...future.value <- base::withVisible(base::local({
[17:46:52.906]                 ...future.makeSendCondition <- base::local({
[17:46:52.906]                   sendCondition <- NULL
[17:46:52.906]                   function(frame = 1L) {
[17:46:52.906]                     if (is.function(sendCondition)) 
[17:46:52.906]                       return(sendCondition)
[17:46:52.906]                     ns <- getNamespace("parallel")
[17:46:52.906]                     if (exists("sendData", mode = "function", 
[17:46:52.906]                       envir = ns)) {
[17:46:52.906]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:52.906]                         envir = ns)
[17:46:52.906]                       envir <- sys.frame(frame)
[17:46:52.906]                       master <- NULL
[17:46:52.906]                       while (!identical(envir, .GlobalEnv) && 
[17:46:52.906]                         !identical(envir, emptyenv())) {
[17:46:52.906]                         if (exists("master", mode = "list", envir = envir, 
[17:46:52.906]                           inherits = FALSE)) {
[17:46:52.906]                           master <- get("master", mode = "list", 
[17:46:52.906]                             envir = envir, inherits = FALSE)
[17:46:52.906]                           if (inherits(master, c("SOCKnode", 
[17:46:52.906]                             "SOCK0node"))) {
[17:46:52.906]                             sendCondition <<- function(cond) {
[17:46:52.906]                               data <- list(type = "VALUE", value = cond, 
[17:46:52.906]                                 success = TRUE)
[17:46:52.906]                               parallel_sendData(master, data)
[17:46:52.906]                             }
[17:46:52.906]                             return(sendCondition)
[17:46:52.906]                           }
[17:46:52.906]                         }
[17:46:52.906]                         frame <- frame + 1L
[17:46:52.906]                         envir <- sys.frame(frame)
[17:46:52.906]                       }
[17:46:52.906]                     }
[17:46:52.906]                     sendCondition <<- function(cond) NULL
[17:46:52.906]                   }
[17:46:52.906]                 })
[17:46:52.906]                 withCallingHandlers({
[17:46:52.906]                   {
[17:46:52.906]                     lm(weight ~ group - 1)
[17:46:52.906]                   }
[17:46:52.906]                 }, immediateCondition = function(cond) {
[17:46:52.906]                   sendCondition <- ...future.makeSendCondition()
[17:46:52.906]                   sendCondition(cond)
[17:46:52.906]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.906]                   {
[17:46:52.906]                     inherits <- base::inherits
[17:46:52.906]                     invokeRestart <- base::invokeRestart
[17:46:52.906]                     is.null <- base::is.null
[17:46:52.906]                     muffled <- FALSE
[17:46:52.906]                     if (inherits(cond, "message")) {
[17:46:52.906]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:52.906]                       if (muffled) 
[17:46:52.906]                         invokeRestart("muffleMessage")
[17:46:52.906]                     }
[17:46:52.906]                     else if (inherits(cond, "warning")) {
[17:46:52.906]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:52.906]                       if (muffled) 
[17:46:52.906]                         invokeRestart("muffleWarning")
[17:46:52.906]                     }
[17:46:52.906]                     else if (inherits(cond, "condition")) {
[17:46:52.906]                       if (!is.null(pattern)) {
[17:46:52.906]                         computeRestarts <- base::computeRestarts
[17:46:52.906]                         grepl <- base::grepl
[17:46:52.906]                         restarts <- computeRestarts(cond)
[17:46:52.906]                         for (restart in restarts) {
[17:46:52.906]                           name <- restart$name
[17:46:52.906]                           if (is.null(name)) 
[17:46:52.906]                             next
[17:46:52.906]                           if (!grepl(pattern, name)) 
[17:46:52.906]                             next
[17:46:52.906]                           invokeRestart(restart)
[17:46:52.906]                           muffled <- TRUE
[17:46:52.906]                           break
[17:46:52.906]                         }
[17:46:52.906]                       }
[17:46:52.906]                     }
[17:46:52.906]                     invisible(muffled)
[17:46:52.906]                   }
[17:46:52.906]                   muffleCondition(cond)
[17:46:52.906]                 })
[17:46:52.906]             }))
[17:46:52.906]             future::FutureResult(value = ...future.value$value, 
[17:46:52.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.906]                   ...future.rng), globalenv = if (FALSE) 
[17:46:52.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:52.906]                     ...future.globalenv.names))
[17:46:52.906]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:52.906]         }, condition = base::local({
[17:46:52.906]             c <- base::c
[17:46:52.906]             inherits <- base::inherits
[17:46:52.906]             invokeRestart <- base::invokeRestart
[17:46:52.906]             length <- base::length
[17:46:52.906]             list <- base::list
[17:46:52.906]             seq.int <- base::seq.int
[17:46:52.906]             signalCondition <- base::signalCondition
[17:46:52.906]             sys.calls <- base::sys.calls
[17:46:52.906]             `[[` <- base::`[[`
[17:46:52.906]             `+` <- base::`+`
[17:46:52.906]             `<<-` <- base::`<<-`
[17:46:52.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:52.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:52.906]                   3L)]
[17:46:52.906]             }
[17:46:52.906]             function(cond) {
[17:46:52.906]                 is_error <- inherits(cond, "error")
[17:46:52.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:52.906]                   NULL)
[17:46:52.906]                 if (is_error) {
[17:46:52.906]                   sessionInformation <- function() {
[17:46:52.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:52.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:52.906]                       search = base::search(), system = base::Sys.info())
[17:46:52.906]                   }
[17:46:52.906]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:52.906]                     cond$call), session = sessionInformation(), 
[17:46:52.906]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:52.906]                   signalCondition(cond)
[17:46:52.906]                 }
[17:46:52.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:52.906]                 "immediateCondition"))) {
[17:46:52.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:52.906]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:52.906]                   if (TRUE && !signal) {
[17:46:52.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.906]                     {
[17:46:52.906]                       inherits <- base::inherits
[17:46:52.906]                       invokeRestart <- base::invokeRestart
[17:46:52.906]                       is.null <- base::is.null
[17:46:52.906]                       muffled <- FALSE
[17:46:52.906]                       if (inherits(cond, "message")) {
[17:46:52.906]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.906]                         if (muffled) 
[17:46:52.906]                           invokeRestart("muffleMessage")
[17:46:52.906]                       }
[17:46:52.906]                       else if (inherits(cond, "warning")) {
[17:46:52.906]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.906]                         if (muffled) 
[17:46:52.906]                           invokeRestart("muffleWarning")
[17:46:52.906]                       }
[17:46:52.906]                       else if (inherits(cond, "condition")) {
[17:46:52.906]                         if (!is.null(pattern)) {
[17:46:52.906]                           computeRestarts <- base::computeRestarts
[17:46:52.906]                           grepl <- base::grepl
[17:46:52.906]                           restarts <- computeRestarts(cond)
[17:46:52.906]                           for (restart in restarts) {
[17:46:52.906]                             name <- restart$name
[17:46:52.906]                             if (is.null(name)) 
[17:46:52.906]                               next
[17:46:52.906]                             if (!grepl(pattern, name)) 
[17:46:52.906]                               next
[17:46:52.906]                             invokeRestart(restart)
[17:46:52.906]                             muffled <- TRUE
[17:46:52.906]                             break
[17:46:52.906]                           }
[17:46:52.906]                         }
[17:46:52.906]                       }
[17:46:52.906]                       invisible(muffled)
[17:46:52.906]                     }
[17:46:52.906]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.906]                   }
[17:46:52.906]                 }
[17:46:52.906]                 else {
[17:46:52.906]                   if (TRUE) {
[17:46:52.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.906]                     {
[17:46:52.906]                       inherits <- base::inherits
[17:46:52.906]                       invokeRestart <- base::invokeRestart
[17:46:52.906]                       is.null <- base::is.null
[17:46:52.906]                       muffled <- FALSE
[17:46:52.906]                       if (inherits(cond, "message")) {
[17:46:52.906]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.906]                         if (muffled) 
[17:46:52.906]                           invokeRestart("muffleMessage")
[17:46:52.906]                       }
[17:46:52.906]                       else if (inherits(cond, "warning")) {
[17:46:52.906]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.906]                         if (muffled) 
[17:46:52.906]                           invokeRestart("muffleWarning")
[17:46:52.906]                       }
[17:46:52.906]                       else if (inherits(cond, "condition")) {
[17:46:52.906]                         if (!is.null(pattern)) {
[17:46:52.906]                           computeRestarts <- base::computeRestarts
[17:46:52.906]                           grepl <- base::grepl
[17:46:52.906]                           restarts <- computeRestarts(cond)
[17:46:52.906]                           for (restart in restarts) {
[17:46:52.906]                             name <- restart$name
[17:46:52.906]                             if (is.null(name)) 
[17:46:52.906]                               next
[17:46:52.906]                             if (!grepl(pattern, name)) 
[17:46:52.906]                               next
[17:46:52.906]                             invokeRestart(restart)
[17:46:52.906]                             muffled <- TRUE
[17:46:52.906]                             break
[17:46:52.906]                           }
[17:46:52.906]                         }
[17:46:52.906]                       }
[17:46:52.906]                       invisible(muffled)
[17:46:52.906]                     }
[17:46:52.906]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.906]                   }
[17:46:52.906]                 }
[17:46:52.906]             }
[17:46:52.906]         }))
[17:46:52.906]     }, error = function(ex) {
[17:46:52.906]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:52.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.906]                 ...future.rng), started = ...future.startTime, 
[17:46:52.906]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:52.906]             version = "1.8"), class = "FutureResult")
[17:46:52.906]     }, finally = {
[17:46:52.906]         if (!identical(...future.workdir, getwd())) 
[17:46:52.906]             setwd(...future.workdir)
[17:46:52.906]         {
[17:46:52.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:52.906]                 ...future.oldOptions$nwarnings <- NULL
[17:46:52.906]             }
[17:46:52.906]             base::options(...future.oldOptions)
[17:46:52.906]             if (.Platform$OS.type == "windows") {
[17:46:52.906]                 old_names <- names(...future.oldEnvVars)
[17:46:52.906]                 envs <- base::Sys.getenv()
[17:46:52.906]                 names <- names(envs)
[17:46:52.906]                 common <- intersect(names, old_names)
[17:46:52.906]                 added <- setdiff(names, old_names)
[17:46:52.906]                 removed <- setdiff(old_names, names)
[17:46:52.906]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:52.906]                   envs[common]]
[17:46:52.906]                 NAMES <- toupper(changed)
[17:46:52.906]                 args <- list()
[17:46:52.906]                 for (kk in seq_along(NAMES)) {
[17:46:52.906]                   name <- changed[[kk]]
[17:46:52.906]                   NAME <- NAMES[[kk]]
[17:46:52.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.906]                     next
[17:46:52.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.906]                 }
[17:46:52.906]                 NAMES <- toupper(added)
[17:46:52.906]                 for (kk in seq_along(NAMES)) {
[17:46:52.906]                   name <- added[[kk]]
[17:46:52.906]                   NAME <- NAMES[[kk]]
[17:46:52.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.906]                     next
[17:46:52.906]                   args[[name]] <- ""
[17:46:52.906]                 }
[17:46:52.906]                 NAMES <- toupper(removed)
[17:46:52.906]                 for (kk in seq_along(NAMES)) {
[17:46:52.906]                   name <- removed[[kk]]
[17:46:52.906]                   NAME <- NAMES[[kk]]
[17:46:52.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.906]                     next
[17:46:52.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.906]                 }
[17:46:52.906]                 if (length(args) > 0) 
[17:46:52.906]                   base::do.call(base::Sys.setenv, args = args)
[17:46:52.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:52.906]             }
[17:46:52.906]             else {
[17:46:52.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:52.906]             }
[17:46:52.906]             {
[17:46:52.906]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:52.906]                   0L) {
[17:46:52.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:52.906]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:52.906]                   base::options(opts)
[17:46:52.906]                 }
[17:46:52.906]                 {
[17:46:52.906]                   {
[17:46:52.906]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:52.906]                     NULL
[17:46:52.906]                   }
[17:46:52.906]                   options(future.plan = NULL)
[17:46:52.906]                   if (is.na(NA_character_)) 
[17:46:52.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:52.906]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:52.906]                     .init = FALSE)
[17:46:52.906]                 }
[17:46:52.906]             }
[17:46:52.906]         }
[17:46:52.906]     })
[17:46:52.906]     if (TRUE) {
[17:46:52.906]         base::sink(type = "output", split = FALSE)
[17:46:52.906]         if (TRUE) {
[17:46:52.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:52.906]         }
[17:46:52.906]         else {
[17:46:52.906]             ...future.result["stdout"] <- base::list(NULL)
[17:46:52.906]         }
[17:46:52.906]         base::close(...future.stdout)
[17:46:52.906]         ...future.stdout <- NULL
[17:46:52.906]     }
[17:46:52.906]     ...future.result$conditions <- ...future.conditions
[17:46:52.906]     ...future.result$finished <- base::Sys.time()
[17:46:52.906]     ...future.result
[17:46:52.906] }
[17:46:52.909] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:46:52.909] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:46:52.909] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:46:52.909] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:46:52.910] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:46:52.910] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:46:52.910] MultisessionFuture started
[17:46:52.911] - Launch lazy future ... done
[17:46:52.911] run() for ‘MultisessionFuture’ ... done
[17:46:52.911] result() for ClusterFuture ...
[17:46:52.911] receiveMessageFromWorker() for ClusterFuture ...
[17:46:52.911] - Validating connection of MultisessionFuture
[17:46:52.954] - received message: FutureResult
[17:46:52.954] - Received FutureResult
[17:46:52.954] - Erased future from FutureRegistry
[17:46:52.954] result() for ClusterFuture ...
[17:46:52.954] - result already collected: FutureResult
[17:46:52.954] result() for ClusterFuture ... done
[17:46:52.955] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:52.955] result() for ClusterFuture ... done
[17:46:52.955] result() for ClusterFuture ...
[17:46:52.955] - result already collected: FutureResult
[17:46:52.955] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:46:52.957] getGlobalsAndPackages() ...
[17:46:52.957] Searching for globals...
[17:46:52.959] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:52.959] Searching for globals ... DONE
[17:46:52.959] Resolving globals: FALSE
[17:46:52.960] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:52.960] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:52.961] - globals: [2] ‘weight’, ‘group’
[17:46:52.961] - packages: [1] ‘stats’
[17:46:52.961] getGlobalsAndPackages() ... DONE
[17:46:52.961] run() for ‘Future’ ...
[17:46:52.961] - state: ‘created’
[17:46:52.962] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:52.976] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:52.976] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:52.976]   - Field: ‘node’
[17:46:52.976]   - Field: ‘label’
[17:46:52.976]   - Field: ‘local’
[17:46:52.977]   - Field: ‘owner’
[17:46:52.977]   - Field: ‘envir’
[17:46:52.977]   - Field: ‘workers’
[17:46:52.977]   - Field: ‘packages’
[17:46:52.977]   - Field: ‘gc’
[17:46:52.977]   - Field: ‘conditions’
[17:46:52.977]   - Field: ‘persistent’
[17:46:52.977]   - Field: ‘expr’
[17:46:52.977]   - Field: ‘uuid’
[17:46:52.978]   - Field: ‘seed’
[17:46:52.978]   - Field: ‘version’
[17:46:52.978]   - Field: ‘result’
[17:46:52.978]   - Field: ‘asynchronous’
[17:46:52.978]   - Field: ‘calls’
[17:46:52.978]   - Field: ‘globals’
[17:46:52.978]   - Field: ‘stdout’
[17:46:52.978]   - Field: ‘earlySignal’
[17:46:52.978]   - Field: ‘lazy’
[17:46:52.979]   - Field: ‘state’
[17:46:52.979] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:52.979] - Launch lazy future ...
[17:46:52.979] Packages needed by the future expression (n = 1): ‘stats’
[17:46:52.979] Packages needed by future strategies (n = 0): <none>
[17:46:52.980] {
[17:46:52.980]     {
[17:46:52.980]         {
[17:46:52.980]             ...future.startTime <- base::Sys.time()
[17:46:52.980]             {
[17:46:52.980]                 {
[17:46:52.980]                   {
[17:46:52.980]                     {
[17:46:52.980]                       {
[17:46:52.980]                         base::local({
[17:46:52.980]                           has_future <- base::requireNamespace("future", 
[17:46:52.980]                             quietly = TRUE)
[17:46:52.980]                           if (has_future) {
[17:46:52.980]                             ns <- base::getNamespace("future")
[17:46:52.980]                             version <- ns[[".package"]][["version"]]
[17:46:52.980]                             if (is.null(version)) 
[17:46:52.980]                               version <- utils::packageVersion("future")
[17:46:52.980]                           }
[17:46:52.980]                           else {
[17:46:52.980]                             version <- NULL
[17:46:52.980]                           }
[17:46:52.980]                           if (!has_future || version < "1.8.0") {
[17:46:52.980]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:52.980]                               "", base::R.version$version.string), 
[17:46:52.980]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:52.980]                                 base::R.version$platform, 8 * 
[17:46:52.980]                                   base::.Machine$sizeof.pointer), 
[17:46:52.980]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:52.980]                                 "release", "version")], collapse = " "), 
[17:46:52.980]                               hostname = base::Sys.info()[["nodename"]])
[17:46:52.980]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:52.980]                               info)
[17:46:52.980]                             info <- base::paste(info, collapse = "; ")
[17:46:52.980]                             if (!has_future) {
[17:46:52.980]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:52.980]                                 info)
[17:46:52.980]                             }
[17:46:52.980]                             else {
[17:46:52.980]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:52.980]                                 info, version)
[17:46:52.980]                             }
[17:46:52.980]                             base::stop(msg)
[17:46:52.980]                           }
[17:46:52.980]                         })
[17:46:52.980]                       }
[17:46:52.980]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:52.980]                       base::options(mc.cores = 1L)
[17:46:52.980]                     }
[17:46:52.980]                     base::local({
[17:46:52.980]                       for (pkg in "stats") {
[17:46:52.980]                         base::loadNamespace(pkg)
[17:46:52.980]                         base::library(pkg, character.only = TRUE)
[17:46:52.980]                       }
[17:46:52.980]                     })
[17:46:52.980]                   }
[17:46:52.980]                   ...future.strategy.old <- future::plan("list")
[17:46:52.980]                   options(future.plan = NULL)
[17:46:52.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:52.980]                 }
[17:46:52.980]                 ...future.workdir <- getwd()
[17:46:52.980]             }
[17:46:52.980]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:52.980]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:52.980]         }
[17:46:52.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:52.980]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:52.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:52.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:52.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:52.980]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:52.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:52.980]             base::names(...future.oldOptions))
[17:46:52.980]     }
[17:46:52.980]     if (FALSE) {
[17:46:52.980]     }
[17:46:52.980]     else {
[17:46:52.980]         if (TRUE) {
[17:46:52.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:52.980]                 open = "w")
[17:46:52.980]         }
[17:46:52.980]         else {
[17:46:52.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:52.980]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:52.980]         }
[17:46:52.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:52.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:52.980]             base::sink(type = "output", split = FALSE)
[17:46:52.980]             base::close(...future.stdout)
[17:46:52.980]         }, add = TRUE)
[17:46:52.980]     }
[17:46:52.980]     ...future.frame <- base::sys.nframe()
[17:46:52.980]     ...future.conditions <- base::list()
[17:46:52.980]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:52.980]     if (FALSE) {
[17:46:52.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:52.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:52.980]     }
[17:46:52.980]     ...future.result <- base::tryCatch({
[17:46:52.980]         base::withCallingHandlers({
[17:46:52.980]             ...future.value <- base::withVisible(base::local({
[17:46:52.980]                 ...future.makeSendCondition <- base::local({
[17:46:52.980]                   sendCondition <- NULL
[17:46:52.980]                   function(frame = 1L) {
[17:46:52.980]                     if (is.function(sendCondition)) 
[17:46:52.980]                       return(sendCondition)
[17:46:52.980]                     ns <- getNamespace("parallel")
[17:46:52.980]                     if (exists("sendData", mode = "function", 
[17:46:52.980]                       envir = ns)) {
[17:46:52.980]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:52.980]                         envir = ns)
[17:46:52.980]                       envir <- sys.frame(frame)
[17:46:52.980]                       master <- NULL
[17:46:52.980]                       while (!identical(envir, .GlobalEnv) && 
[17:46:52.980]                         !identical(envir, emptyenv())) {
[17:46:52.980]                         if (exists("master", mode = "list", envir = envir, 
[17:46:52.980]                           inherits = FALSE)) {
[17:46:52.980]                           master <- get("master", mode = "list", 
[17:46:52.980]                             envir = envir, inherits = FALSE)
[17:46:52.980]                           if (inherits(master, c("SOCKnode", 
[17:46:52.980]                             "SOCK0node"))) {
[17:46:52.980]                             sendCondition <<- function(cond) {
[17:46:52.980]                               data <- list(type = "VALUE", value = cond, 
[17:46:52.980]                                 success = TRUE)
[17:46:52.980]                               parallel_sendData(master, data)
[17:46:52.980]                             }
[17:46:52.980]                             return(sendCondition)
[17:46:52.980]                           }
[17:46:52.980]                         }
[17:46:52.980]                         frame <- frame + 1L
[17:46:52.980]                         envir <- sys.frame(frame)
[17:46:52.980]                       }
[17:46:52.980]                     }
[17:46:52.980]                     sendCondition <<- function(cond) NULL
[17:46:52.980]                   }
[17:46:52.980]                 })
[17:46:52.980]                 withCallingHandlers({
[17:46:52.980]                   {
[17:46:52.980]                     lm(weight ~ group - 1)
[17:46:52.980]                   }
[17:46:52.980]                 }, immediateCondition = function(cond) {
[17:46:52.980]                   sendCondition <- ...future.makeSendCondition()
[17:46:52.980]                   sendCondition(cond)
[17:46:52.980]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.980]                   {
[17:46:52.980]                     inherits <- base::inherits
[17:46:52.980]                     invokeRestart <- base::invokeRestart
[17:46:52.980]                     is.null <- base::is.null
[17:46:52.980]                     muffled <- FALSE
[17:46:52.980]                     if (inherits(cond, "message")) {
[17:46:52.980]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:52.980]                       if (muffled) 
[17:46:52.980]                         invokeRestart("muffleMessage")
[17:46:52.980]                     }
[17:46:52.980]                     else if (inherits(cond, "warning")) {
[17:46:52.980]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:52.980]                       if (muffled) 
[17:46:52.980]                         invokeRestart("muffleWarning")
[17:46:52.980]                     }
[17:46:52.980]                     else if (inherits(cond, "condition")) {
[17:46:52.980]                       if (!is.null(pattern)) {
[17:46:52.980]                         computeRestarts <- base::computeRestarts
[17:46:52.980]                         grepl <- base::grepl
[17:46:52.980]                         restarts <- computeRestarts(cond)
[17:46:52.980]                         for (restart in restarts) {
[17:46:52.980]                           name <- restart$name
[17:46:52.980]                           if (is.null(name)) 
[17:46:52.980]                             next
[17:46:52.980]                           if (!grepl(pattern, name)) 
[17:46:52.980]                             next
[17:46:52.980]                           invokeRestart(restart)
[17:46:52.980]                           muffled <- TRUE
[17:46:52.980]                           break
[17:46:52.980]                         }
[17:46:52.980]                       }
[17:46:52.980]                     }
[17:46:52.980]                     invisible(muffled)
[17:46:52.980]                   }
[17:46:52.980]                   muffleCondition(cond)
[17:46:52.980]                 })
[17:46:52.980]             }))
[17:46:52.980]             future::FutureResult(value = ...future.value$value, 
[17:46:52.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.980]                   ...future.rng), globalenv = if (FALSE) 
[17:46:52.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:52.980]                     ...future.globalenv.names))
[17:46:52.980]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:52.980]         }, condition = base::local({
[17:46:52.980]             c <- base::c
[17:46:52.980]             inherits <- base::inherits
[17:46:52.980]             invokeRestart <- base::invokeRestart
[17:46:52.980]             length <- base::length
[17:46:52.980]             list <- base::list
[17:46:52.980]             seq.int <- base::seq.int
[17:46:52.980]             signalCondition <- base::signalCondition
[17:46:52.980]             sys.calls <- base::sys.calls
[17:46:52.980]             `[[` <- base::`[[`
[17:46:52.980]             `+` <- base::`+`
[17:46:52.980]             `<<-` <- base::`<<-`
[17:46:52.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:52.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:52.980]                   3L)]
[17:46:52.980]             }
[17:46:52.980]             function(cond) {
[17:46:52.980]                 is_error <- inherits(cond, "error")
[17:46:52.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:52.980]                   NULL)
[17:46:52.980]                 if (is_error) {
[17:46:52.980]                   sessionInformation <- function() {
[17:46:52.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:52.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:52.980]                       search = base::search(), system = base::Sys.info())
[17:46:52.980]                   }
[17:46:52.980]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:52.980]                     cond$call), session = sessionInformation(), 
[17:46:52.980]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:52.980]                   signalCondition(cond)
[17:46:52.980]                 }
[17:46:52.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:52.980]                 "immediateCondition"))) {
[17:46:52.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:52.980]                   ...future.conditions[[length(...future.conditions) + 
[17:46:52.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:52.980]                   if (TRUE && !signal) {
[17:46:52.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.980]                     {
[17:46:52.980]                       inherits <- base::inherits
[17:46:52.980]                       invokeRestart <- base::invokeRestart
[17:46:52.980]                       is.null <- base::is.null
[17:46:52.980]                       muffled <- FALSE
[17:46:52.980]                       if (inherits(cond, "message")) {
[17:46:52.980]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.980]                         if (muffled) 
[17:46:52.980]                           invokeRestart("muffleMessage")
[17:46:52.980]                       }
[17:46:52.980]                       else if (inherits(cond, "warning")) {
[17:46:52.980]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.980]                         if (muffled) 
[17:46:52.980]                           invokeRestart("muffleWarning")
[17:46:52.980]                       }
[17:46:52.980]                       else if (inherits(cond, "condition")) {
[17:46:52.980]                         if (!is.null(pattern)) {
[17:46:52.980]                           computeRestarts <- base::computeRestarts
[17:46:52.980]                           grepl <- base::grepl
[17:46:52.980]                           restarts <- computeRestarts(cond)
[17:46:52.980]                           for (restart in restarts) {
[17:46:52.980]                             name <- restart$name
[17:46:52.980]                             if (is.null(name)) 
[17:46:52.980]                               next
[17:46:52.980]                             if (!grepl(pattern, name)) 
[17:46:52.980]                               next
[17:46:52.980]                             invokeRestart(restart)
[17:46:52.980]                             muffled <- TRUE
[17:46:52.980]                             break
[17:46:52.980]                           }
[17:46:52.980]                         }
[17:46:52.980]                       }
[17:46:52.980]                       invisible(muffled)
[17:46:52.980]                     }
[17:46:52.980]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.980]                   }
[17:46:52.980]                 }
[17:46:52.980]                 else {
[17:46:52.980]                   if (TRUE) {
[17:46:52.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:52.980]                     {
[17:46:52.980]                       inherits <- base::inherits
[17:46:52.980]                       invokeRestart <- base::invokeRestart
[17:46:52.980]                       is.null <- base::is.null
[17:46:52.980]                       muffled <- FALSE
[17:46:52.980]                       if (inherits(cond, "message")) {
[17:46:52.980]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:52.980]                         if (muffled) 
[17:46:52.980]                           invokeRestart("muffleMessage")
[17:46:52.980]                       }
[17:46:52.980]                       else if (inherits(cond, "warning")) {
[17:46:52.980]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:52.980]                         if (muffled) 
[17:46:52.980]                           invokeRestart("muffleWarning")
[17:46:52.980]                       }
[17:46:52.980]                       else if (inherits(cond, "condition")) {
[17:46:52.980]                         if (!is.null(pattern)) {
[17:46:52.980]                           computeRestarts <- base::computeRestarts
[17:46:52.980]                           grepl <- base::grepl
[17:46:52.980]                           restarts <- computeRestarts(cond)
[17:46:52.980]                           for (restart in restarts) {
[17:46:52.980]                             name <- restart$name
[17:46:52.980]                             if (is.null(name)) 
[17:46:52.980]                               next
[17:46:52.980]                             if (!grepl(pattern, name)) 
[17:46:52.980]                               next
[17:46:52.980]                             invokeRestart(restart)
[17:46:52.980]                             muffled <- TRUE
[17:46:52.980]                             break
[17:46:52.980]                           }
[17:46:52.980]                         }
[17:46:52.980]                       }
[17:46:52.980]                       invisible(muffled)
[17:46:52.980]                     }
[17:46:52.980]                     muffleCondition(cond, pattern = "^muffle")
[17:46:52.980]                   }
[17:46:52.980]                 }
[17:46:52.980]             }
[17:46:52.980]         }))
[17:46:52.980]     }, error = function(ex) {
[17:46:52.980]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:52.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:52.980]                 ...future.rng), started = ...future.startTime, 
[17:46:52.980]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:52.980]             version = "1.8"), class = "FutureResult")
[17:46:52.980]     }, finally = {
[17:46:52.980]         if (!identical(...future.workdir, getwd())) 
[17:46:52.980]             setwd(...future.workdir)
[17:46:52.980]         {
[17:46:52.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:52.980]                 ...future.oldOptions$nwarnings <- NULL
[17:46:52.980]             }
[17:46:52.980]             base::options(...future.oldOptions)
[17:46:52.980]             if (.Platform$OS.type == "windows") {
[17:46:52.980]                 old_names <- names(...future.oldEnvVars)
[17:46:52.980]                 envs <- base::Sys.getenv()
[17:46:52.980]                 names <- names(envs)
[17:46:52.980]                 common <- intersect(names, old_names)
[17:46:52.980]                 added <- setdiff(names, old_names)
[17:46:52.980]                 removed <- setdiff(old_names, names)
[17:46:52.980]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:52.980]                   envs[common]]
[17:46:52.980]                 NAMES <- toupper(changed)
[17:46:52.980]                 args <- list()
[17:46:52.980]                 for (kk in seq_along(NAMES)) {
[17:46:52.980]                   name <- changed[[kk]]
[17:46:52.980]                   NAME <- NAMES[[kk]]
[17:46:52.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.980]                     next
[17:46:52.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.980]                 }
[17:46:52.980]                 NAMES <- toupper(added)
[17:46:52.980]                 for (kk in seq_along(NAMES)) {
[17:46:52.980]                   name <- added[[kk]]
[17:46:52.980]                   NAME <- NAMES[[kk]]
[17:46:52.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.980]                     next
[17:46:52.980]                   args[[name]] <- ""
[17:46:52.980]                 }
[17:46:52.980]                 NAMES <- toupper(removed)
[17:46:52.980]                 for (kk in seq_along(NAMES)) {
[17:46:52.980]                   name <- removed[[kk]]
[17:46:52.980]                   NAME <- NAMES[[kk]]
[17:46:52.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:52.980]                     next
[17:46:52.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:52.980]                 }
[17:46:52.980]                 if (length(args) > 0) 
[17:46:52.980]                   base::do.call(base::Sys.setenv, args = args)
[17:46:52.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:52.980]             }
[17:46:52.980]             else {
[17:46:52.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:52.980]             }
[17:46:52.980]             {
[17:46:52.980]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:52.980]                   0L) {
[17:46:52.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:52.980]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:52.980]                   base::options(opts)
[17:46:52.980]                 }
[17:46:52.980]                 {
[17:46:52.980]                   {
[17:46:52.980]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:52.980]                     NULL
[17:46:52.980]                   }
[17:46:52.980]                   options(future.plan = NULL)
[17:46:52.980]                   if (is.na(NA_character_)) 
[17:46:52.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:52.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:52.980]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:52.980]                     .init = FALSE)
[17:46:52.980]                 }
[17:46:52.980]             }
[17:46:52.980]         }
[17:46:52.980]     })
[17:46:52.980]     if (TRUE) {
[17:46:52.980]         base::sink(type = "output", split = FALSE)
[17:46:52.980]         if (TRUE) {
[17:46:52.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:52.980]         }
[17:46:52.980]         else {
[17:46:52.980]             ...future.result["stdout"] <- base::list(NULL)
[17:46:52.980]         }
[17:46:52.980]         base::close(...future.stdout)
[17:46:52.980]         ...future.stdout <- NULL
[17:46:52.980]     }
[17:46:52.980]     ...future.result$conditions <- ...future.conditions
[17:46:52.980]     ...future.result$finished <- base::Sys.time()
[17:46:52.980]     ...future.result
[17:46:52.980] }
[17:46:52.983] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:46:52.983] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:46:52.983] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:46:52.984] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:46:52.984] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:46:52.984] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:46:52.985] MultisessionFuture started
[17:46:52.985] - Launch lazy future ... done
[17:46:52.985] run() for ‘MultisessionFuture’ ... done
[17:46:52.985] result() for ClusterFuture ...
[17:46:52.988] receiveMessageFromWorker() for ClusterFuture ...
[17:46:52.988] - Validating connection of MultisessionFuture
[17:46:53.030] - received message: FutureResult
[17:46:53.030] - Received FutureResult
[17:46:53.030] - Erased future from FutureRegistry
[17:46:53.030] result() for ClusterFuture ...
[17:46:53.030] - result already collected: FutureResult
[17:46:53.030] result() for ClusterFuture ... done
[17:46:53.030] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:53.030] result() for ClusterFuture ... done
[17:46:53.031] result() for ClusterFuture ...
[17:46:53.031] - result already collected: FutureResult
[17:46:53.031] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:46:53.033] getGlobalsAndPackages() ...
[17:46:53.033] Searching for globals...
[17:46:53.034] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:53.034] Searching for globals ... DONE
[17:46:53.034] Resolving globals: FALSE
[17:46:53.035] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:53.035] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:53.035] - globals: [2] ‘weight’, ‘group’
[17:46:53.035] - packages: [1] ‘stats’
[17:46:53.035] getGlobalsAndPackages() ... DONE
[17:46:53.036] run() for ‘Future’ ...
[17:46:53.036] - state: ‘created’
[17:46:53.036] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:53.049] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:53.050] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:53.050]   - Field: ‘node’
[17:46:53.050]   - Field: ‘label’
[17:46:53.050]   - Field: ‘local’
[17:46:53.050]   - Field: ‘owner’
[17:46:53.050]   - Field: ‘envir’
[17:46:53.050]   - Field: ‘workers’
[17:46:53.050]   - Field: ‘packages’
[17:46:53.050]   - Field: ‘gc’
[17:46:53.050]   - Field: ‘conditions’
[17:46:53.050]   - Field: ‘persistent’
[17:46:53.051]   - Field: ‘expr’
[17:46:53.051]   - Field: ‘uuid’
[17:46:53.051]   - Field: ‘seed’
[17:46:53.051]   - Field: ‘version’
[17:46:53.051]   - Field: ‘result’
[17:46:53.051]   - Field: ‘asynchronous’
[17:46:53.051]   - Field: ‘calls’
[17:46:53.051]   - Field: ‘globals’
[17:46:53.051]   - Field: ‘stdout’
[17:46:53.051]   - Field: ‘earlySignal’
[17:46:53.052]   - Field: ‘lazy’
[17:46:53.052]   - Field: ‘state’
[17:46:53.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:53.052] - Launch lazy future ...
[17:46:53.052] Packages needed by the future expression (n = 1): ‘stats’
[17:46:53.052] Packages needed by future strategies (n = 0): <none>
[17:46:53.053] {
[17:46:53.053]     {
[17:46:53.053]         {
[17:46:53.053]             ...future.startTime <- base::Sys.time()
[17:46:53.053]             {
[17:46:53.053]                 {
[17:46:53.053]                   {
[17:46:53.053]                     {
[17:46:53.053]                       {
[17:46:53.053]                         base::local({
[17:46:53.053]                           has_future <- base::requireNamespace("future", 
[17:46:53.053]                             quietly = TRUE)
[17:46:53.053]                           if (has_future) {
[17:46:53.053]                             ns <- base::getNamespace("future")
[17:46:53.053]                             version <- ns[[".package"]][["version"]]
[17:46:53.053]                             if (is.null(version)) 
[17:46:53.053]                               version <- utils::packageVersion("future")
[17:46:53.053]                           }
[17:46:53.053]                           else {
[17:46:53.053]                             version <- NULL
[17:46:53.053]                           }
[17:46:53.053]                           if (!has_future || version < "1.8.0") {
[17:46:53.053]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:53.053]                               "", base::R.version$version.string), 
[17:46:53.053]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:53.053]                                 base::R.version$platform, 8 * 
[17:46:53.053]                                   base::.Machine$sizeof.pointer), 
[17:46:53.053]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:53.053]                                 "release", "version")], collapse = " "), 
[17:46:53.053]                               hostname = base::Sys.info()[["nodename"]])
[17:46:53.053]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:53.053]                               info)
[17:46:53.053]                             info <- base::paste(info, collapse = "; ")
[17:46:53.053]                             if (!has_future) {
[17:46:53.053]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:53.053]                                 info)
[17:46:53.053]                             }
[17:46:53.053]                             else {
[17:46:53.053]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:53.053]                                 info, version)
[17:46:53.053]                             }
[17:46:53.053]                             base::stop(msg)
[17:46:53.053]                           }
[17:46:53.053]                         })
[17:46:53.053]                       }
[17:46:53.053]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:53.053]                       base::options(mc.cores = 1L)
[17:46:53.053]                     }
[17:46:53.053]                     base::local({
[17:46:53.053]                       for (pkg in "stats") {
[17:46:53.053]                         base::loadNamespace(pkg)
[17:46:53.053]                         base::library(pkg, character.only = TRUE)
[17:46:53.053]                       }
[17:46:53.053]                     })
[17:46:53.053]                   }
[17:46:53.053]                   ...future.strategy.old <- future::plan("list")
[17:46:53.053]                   options(future.plan = NULL)
[17:46:53.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:53.053]                 }
[17:46:53.053]                 ...future.workdir <- getwd()
[17:46:53.053]             }
[17:46:53.053]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:53.053]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:53.053]         }
[17:46:53.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:53.053]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:53.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:53.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:53.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:53.053]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:53.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:53.053]             base::names(...future.oldOptions))
[17:46:53.053]     }
[17:46:53.053]     if (FALSE) {
[17:46:53.053]     }
[17:46:53.053]     else {
[17:46:53.053]         if (TRUE) {
[17:46:53.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:53.053]                 open = "w")
[17:46:53.053]         }
[17:46:53.053]         else {
[17:46:53.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:53.053]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:53.053]         }
[17:46:53.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:53.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:53.053]             base::sink(type = "output", split = FALSE)
[17:46:53.053]             base::close(...future.stdout)
[17:46:53.053]         }, add = TRUE)
[17:46:53.053]     }
[17:46:53.053]     ...future.frame <- base::sys.nframe()
[17:46:53.053]     ...future.conditions <- base::list()
[17:46:53.053]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:53.053]     if (FALSE) {
[17:46:53.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:53.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:53.053]     }
[17:46:53.053]     ...future.result <- base::tryCatch({
[17:46:53.053]         base::withCallingHandlers({
[17:46:53.053]             ...future.value <- base::withVisible(base::local({
[17:46:53.053]                 ...future.makeSendCondition <- base::local({
[17:46:53.053]                   sendCondition <- NULL
[17:46:53.053]                   function(frame = 1L) {
[17:46:53.053]                     if (is.function(sendCondition)) 
[17:46:53.053]                       return(sendCondition)
[17:46:53.053]                     ns <- getNamespace("parallel")
[17:46:53.053]                     if (exists("sendData", mode = "function", 
[17:46:53.053]                       envir = ns)) {
[17:46:53.053]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:53.053]                         envir = ns)
[17:46:53.053]                       envir <- sys.frame(frame)
[17:46:53.053]                       master <- NULL
[17:46:53.053]                       while (!identical(envir, .GlobalEnv) && 
[17:46:53.053]                         !identical(envir, emptyenv())) {
[17:46:53.053]                         if (exists("master", mode = "list", envir = envir, 
[17:46:53.053]                           inherits = FALSE)) {
[17:46:53.053]                           master <- get("master", mode = "list", 
[17:46:53.053]                             envir = envir, inherits = FALSE)
[17:46:53.053]                           if (inherits(master, c("SOCKnode", 
[17:46:53.053]                             "SOCK0node"))) {
[17:46:53.053]                             sendCondition <<- function(cond) {
[17:46:53.053]                               data <- list(type = "VALUE", value = cond, 
[17:46:53.053]                                 success = TRUE)
[17:46:53.053]                               parallel_sendData(master, data)
[17:46:53.053]                             }
[17:46:53.053]                             return(sendCondition)
[17:46:53.053]                           }
[17:46:53.053]                         }
[17:46:53.053]                         frame <- frame + 1L
[17:46:53.053]                         envir <- sys.frame(frame)
[17:46:53.053]                       }
[17:46:53.053]                     }
[17:46:53.053]                     sendCondition <<- function(cond) NULL
[17:46:53.053]                   }
[17:46:53.053]                 })
[17:46:53.053]                 withCallingHandlers({
[17:46:53.053]                   {
[17:46:53.053]                     lm(weight ~ group - 1)
[17:46:53.053]                   }
[17:46:53.053]                 }, immediateCondition = function(cond) {
[17:46:53.053]                   sendCondition <- ...future.makeSendCondition()
[17:46:53.053]                   sendCondition(cond)
[17:46:53.053]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.053]                   {
[17:46:53.053]                     inherits <- base::inherits
[17:46:53.053]                     invokeRestart <- base::invokeRestart
[17:46:53.053]                     is.null <- base::is.null
[17:46:53.053]                     muffled <- FALSE
[17:46:53.053]                     if (inherits(cond, "message")) {
[17:46:53.053]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:53.053]                       if (muffled) 
[17:46:53.053]                         invokeRestart("muffleMessage")
[17:46:53.053]                     }
[17:46:53.053]                     else if (inherits(cond, "warning")) {
[17:46:53.053]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:53.053]                       if (muffled) 
[17:46:53.053]                         invokeRestart("muffleWarning")
[17:46:53.053]                     }
[17:46:53.053]                     else if (inherits(cond, "condition")) {
[17:46:53.053]                       if (!is.null(pattern)) {
[17:46:53.053]                         computeRestarts <- base::computeRestarts
[17:46:53.053]                         grepl <- base::grepl
[17:46:53.053]                         restarts <- computeRestarts(cond)
[17:46:53.053]                         for (restart in restarts) {
[17:46:53.053]                           name <- restart$name
[17:46:53.053]                           if (is.null(name)) 
[17:46:53.053]                             next
[17:46:53.053]                           if (!grepl(pattern, name)) 
[17:46:53.053]                             next
[17:46:53.053]                           invokeRestart(restart)
[17:46:53.053]                           muffled <- TRUE
[17:46:53.053]                           break
[17:46:53.053]                         }
[17:46:53.053]                       }
[17:46:53.053]                     }
[17:46:53.053]                     invisible(muffled)
[17:46:53.053]                   }
[17:46:53.053]                   muffleCondition(cond)
[17:46:53.053]                 })
[17:46:53.053]             }))
[17:46:53.053]             future::FutureResult(value = ...future.value$value, 
[17:46:53.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.053]                   ...future.rng), globalenv = if (FALSE) 
[17:46:53.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:53.053]                     ...future.globalenv.names))
[17:46:53.053]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:53.053]         }, condition = base::local({
[17:46:53.053]             c <- base::c
[17:46:53.053]             inherits <- base::inherits
[17:46:53.053]             invokeRestart <- base::invokeRestart
[17:46:53.053]             length <- base::length
[17:46:53.053]             list <- base::list
[17:46:53.053]             seq.int <- base::seq.int
[17:46:53.053]             signalCondition <- base::signalCondition
[17:46:53.053]             sys.calls <- base::sys.calls
[17:46:53.053]             `[[` <- base::`[[`
[17:46:53.053]             `+` <- base::`+`
[17:46:53.053]             `<<-` <- base::`<<-`
[17:46:53.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:53.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:53.053]                   3L)]
[17:46:53.053]             }
[17:46:53.053]             function(cond) {
[17:46:53.053]                 is_error <- inherits(cond, "error")
[17:46:53.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:53.053]                   NULL)
[17:46:53.053]                 if (is_error) {
[17:46:53.053]                   sessionInformation <- function() {
[17:46:53.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:53.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:53.053]                       search = base::search(), system = base::Sys.info())
[17:46:53.053]                   }
[17:46:53.053]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:53.053]                     cond$call), session = sessionInformation(), 
[17:46:53.053]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:53.053]                   signalCondition(cond)
[17:46:53.053]                 }
[17:46:53.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:53.053]                 "immediateCondition"))) {
[17:46:53.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:53.053]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:53.053]                   if (TRUE && !signal) {
[17:46:53.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.053]                     {
[17:46:53.053]                       inherits <- base::inherits
[17:46:53.053]                       invokeRestart <- base::invokeRestart
[17:46:53.053]                       is.null <- base::is.null
[17:46:53.053]                       muffled <- FALSE
[17:46:53.053]                       if (inherits(cond, "message")) {
[17:46:53.053]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.053]                         if (muffled) 
[17:46:53.053]                           invokeRestart("muffleMessage")
[17:46:53.053]                       }
[17:46:53.053]                       else if (inherits(cond, "warning")) {
[17:46:53.053]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.053]                         if (muffled) 
[17:46:53.053]                           invokeRestart("muffleWarning")
[17:46:53.053]                       }
[17:46:53.053]                       else if (inherits(cond, "condition")) {
[17:46:53.053]                         if (!is.null(pattern)) {
[17:46:53.053]                           computeRestarts <- base::computeRestarts
[17:46:53.053]                           grepl <- base::grepl
[17:46:53.053]                           restarts <- computeRestarts(cond)
[17:46:53.053]                           for (restart in restarts) {
[17:46:53.053]                             name <- restart$name
[17:46:53.053]                             if (is.null(name)) 
[17:46:53.053]                               next
[17:46:53.053]                             if (!grepl(pattern, name)) 
[17:46:53.053]                               next
[17:46:53.053]                             invokeRestart(restart)
[17:46:53.053]                             muffled <- TRUE
[17:46:53.053]                             break
[17:46:53.053]                           }
[17:46:53.053]                         }
[17:46:53.053]                       }
[17:46:53.053]                       invisible(muffled)
[17:46:53.053]                     }
[17:46:53.053]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.053]                   }
[17:46:53.053]                 }
[17:46:53.053]                 else {
[17:46:53.053]                   if (TRUE) {
[17:46:53.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.053]                     {
[17:46:53.053]                       inherits <- base::inherits
[17:46:53.053]                       invokeRestart <- base::invokeRestart
[17:46:53.053]                       is.null <- base::is.null
[17:46:53.053]                       muffled <- FALSE
[17:46:53.053]                       if (inherits(cond, "message")) {
[17:46:53.053]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.053]                         if (muffled) 
[17:46:53.053]                           invokeRestart("muffleMessage")
[17:46:53.053]                       }
[17:46:53.053]                       else if (inherits(cond, "warning")) {
[17:46:53.053]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.053]                         if (muffled) 
[17:46:53.053]                           invokeRestart("muffleWarning")
[17:46:53.053]                       }
[17:46:53.053]                       else if (inherits(cond, "condition")) {
[17:46:53.053]                         if (!is.null(pattern)) {
[17:46:53.053]                           computeRestarts <- base::computeRestarts
[17:46:53.053]                           grepl <- base::grepl
[17:46:53.053]                           restarts <- computeRestarts(cond)
[17:46:53.053]                           for (restart in restarts) {
[17:46:53.053]                             name <- restart$name
[17:46:53.053]                             if (is.null(name)) 
[17:46:53.053]                               next
[17:46:53.053]                             if (!grepl(pattern, name)) 
[17:46:53.053]                               next
[17:46:53.053]                             invokeRestart(restart)
[17:46:53.053]                             muffled <- TRUE
[17:46:53.053]                             break
[17:46:53.053]                           }
[17:46:53.053]                         }
[17:46:53.053]                       }
[17:46:53.053]                       invisible(muffled)
[17:46:53.053]                     }
[17:46:53.053]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.053]                   }
[17:46:53.053]                 }
[17:46:53.053]             }
[17:46:53.053]         }))
[17:46:53.053]     }, error = function(ex) {
[17:46:53.053]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:53.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.053]                 ...future.rng), started = ...future.startTime, 
[17:46:53.053]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:53.053]             version = "1.8"), class = "FutureResult")
[17:46:53.053]     }, finally = {
[17:46:53.053]         if (!identical(...future.workdir, getwd())) 
[17:46:53.053]             setwd(...future.workdir)
[17:46:53.053]         {
[17:46:53.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:53.053]                 ...future.oldOptions$nwarnings <- NULL
[17:46:53.053]             }
[17:46:53.053]             base::options(...future.oldOptions)
[17:46:53.053]             if (.Platform$OS.type == "windows") {
[17:46:53.053]                 old_names <- names(...future.oldEnvVars)
[17:46:53.053]                 envs <- base::Sys.getenv()
[17:46:53.053]                 names <- names(envs)
[17:46:53.053]                 common <- intersect(names, old_names)
[17:46:53.053]                 added <- setdiff(names, old_names)
[17:46:53.053]                 removed <- setdiff(old_names, names)
[17:46:53.053]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:53.053]                   envs[common]]
[17:46:53.053]                 NAMES <- toupper(changed)
[17:46:53.053]                 args <- list()
[17:46:53.053]                 for (kk in seq_along(NAMES)) {
[17:46:53.053]                   name <- changed[[kk]]
[17:46:53.053]                   NAME <- NAMES[[kk]]
[17:46:53.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.053]                     next
[17:46:53.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.053]                 }
[17:46:53.053]                 NAMES <- toupper(added)
[17:46:53.053]                 for (kk in seq_along(NAMES)) {
[17:46:53.053]                   name <- added[[kk]]
[17:46:53.053]                   NAME <- NAMES[[kk]]
[17:46:53.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.053]                     next
[17:46:53.053]                   args[[name]] <- ""
[17:46:53.053]                 }
[17:46:53.053]                 NAMES <- toupper(removed)
[17:46:53.053]                 for (kk in seq_along(NAMES)) {
[17:46:53.053]                   name <- removed[[kk]]
[17:46:53.053]                   NAME <- NAMES[[kk]]
[17:46:53.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.053]                     next
[17:46:53.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.053]                 }
[17:46:53.053]                 if (length(args) > 0) 
[17:46:53.053]                   base::do.call(base::Sys.setenv, args = args)
[17:46:53.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:53.053]             }
[17:46:53.053]             else {
[17:46:53.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:53.053]             }
[17:46:53.053]             {
[17:46:53.053]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:53.053]                   0L) {
[17:46:53.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:53.053]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:53.053]                   base::options(opts)
[17:46:53.053]                 }
[17:46:53.053]                 {
[17:46:53.053]                   {
[17:46:53.053]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:53.053]                     NULL
[17:46:53.053]                   }
[17:46:53.053]                   options(future.plan = NULL)
[17:46:53.053]                   if (is.na(NA_character_)) 
[17:46:53.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:53.053]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:53.053]                     .init = FALSE)
[17:46:53.053]                 }
[17:46:53.053]             }
[17:46:53.053]         }
[17:46:53.053]     })
[17:46:53.053]     if (TRUE) {
[17:46:53.053]         base::sink(type = "output", split = FALSE)
[17:46:53.053]         if (TRUE) {
[17:46:53.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:53.053]         }
[17:46:53.053]         else {
[17:46:53.053]             ...future.result["stdout"] <- base::list(NULL)
[17:46:53.053]         }
[17:46:53.053]         base::close(...future.stdout)
[17:46:53.053]         ...future.stdout <- NULL
[17:46:53.053]     }
[17:46:53.053]     ...future.result$conditions <- ...future.conditions
[17:46:53.053]     ...future.result$finished <- base::Sys.time()
[17:46:53.053]     ...future.result
[17:46:53.053] }
[17:46:53.055] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:46:53.055] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:46:53.056] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:46:53.056] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:46:53.056] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:46:53.056] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:46:53.057] MultisessionFuture started
[17:46:53.057] - Launch lazy future ... done
[17:46:53.057] run() for ‘MultisessionFuture’ ... done
[17:46:53.057] result() for ClusterFuture ...
[17:46:53.058] receiveMessageFromWorker() for ClusterFuture ...
[17:46:53.058] - Validating connection of MultisessionFuture
[17:46:53.102] - received message: FutureResult
[17:46:53.102] - Received FutureResult
[17:46:53.102] - Erased future from FutureRegistry
[17:46:53.103] result() for ClusterFuture ...
[17:46:53.103] - result already collected: FutureResult
[17:46:53.103] result() for ClusterFuture ... done
[17:46:53.103] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:53.103] result() for ClusterFuture ... done
[17:46:53.103] result() for ClusterFuture ...
[17:46:53.103] - result already collected: FutureResult
[17:46:53.103] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:46:53.105] getGlobalsAndPackages() ...
[17:46:53.105] Searching for globals...
[17:46:53.107] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:46:53.107] Searching for globals ... DONE
[17:46:53.107] Resolving globals: FALSE
[17:46:53.107] The total size of the 2 globals is 896 bytes (896 bytes)
[17:46:53.108] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:46:53.108] - globals: [2] ‘weight’, ‘group’
[17:46:53.108] - packages: [1] ‘stats’
[17:46:53.108] getGlobalsAndPackages() ... DONE
[17:46:53.108] run() for ‘Future’ ...
[17:46:53.109] - state: ‘created’
[17:46:53.109] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:53.123] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:53.123] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:53.124]   - Field: ‘node’
[17:46:53.124]   - Field: ‘label’
[17:46:53.124]   - Field: ‘local’
[17:46:53.124]   - Field: ‘owner’
[17:46:53.124]   - Field: ‘envir’
[17:46:53.124]   - Field: ‘workers’
[17:46:53.124]   - Field: ‘packages’
[17:46:53.124]   - Field: ‘gc’
[17:46:53.124]   - Field: ‘conditions’
[17:46:53.124]   - Field: ‘persistent’
[17:46:53.125]   - Field: ‘expr’
[17:46:53.125]   - Field: ‘uuid’
[17:46:53.125]   - Field: ‘seed’
[17:46:53.125]   - Field: ‘version’
[17:46:53.125]   - Field: ‘result’
[17:46:53.125]   - Field: ‘asynchronous’
[17:46:53.125]   - Field: ‘calls’
[17:46:53.125]   - Field: ‘globals’
[17:46:53.125]   - Field: ‘stdout’
[17:46:53.125]   - Field: ‘earlySignal’
[17:46:53.125]   - Field: ‘lazy’
[17:46:53.125]   - Field: ‘state’
[17:46:53.126] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:53.126] - Launch lazy future ...
[17:46:53.126] Packages needed by the future expression (n = 1): ‘stats’
[17:46:53.126] Packages needed by future strategies (n = 0): <none>
[17:46:53.127] {
[17:46:53.127]     {
[17:46:53.127]         {
[17:46:53.127]             ...future.startTime <- base::Sys.time()
[17:46:53.127]             {
[17:46:53.127]                 {
[17:46:53.127]                   {
[17:46:53.127]                     {
[17:46:53.127]                       {
[17:46:53.127]                         base::local({
[17:46:53.127]                           has_future <- base::requireNamespace("future", 
[17:46:53.127]                             quietly = TRUE)
[17:46:53.127]                           if (has_future) {
[17:46:53.127]                             ns <- base::getNamespace("future")
[17:46:53.127]                             version <- ns[[".package"]][["version"]]
[17:46:53.127]                             if (is.null(version)) 
[17:46:53.127]                               version <- utils::packageVersion("future")
[17:46:53.127]                           }
[17:46:53.127]                           else {
[17:46:53.127]                             version <- NULL
[17:46:53.127]                           }
[17:46:53.127]                           if (!has_future || version < "1.8.0") {
[17:46:53.127]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:53.127]                               "", base::R.version$version.string), 
[17:46:53.127]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:53.127]                                 base::R.version$platform, 8 * 
[17:46:53.127]                                   base::.Machine$sizeof.pointer), 
[17:46:53.127]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:53.127]                                 "release", "version")], collapse = " "), 
[17:46:53.127]                               hostname = base::Sys.info()[["nodename"]])
[17:46:53.127]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:53.127]                               info)
[17:46:53.127]                             info <- base::paste(info, collapse = "; ")
[17:46:53.127]                             if (!has_future) {
[17:46:53.127]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:53.127]                                 info)
[17:46:53.127]                             }
[17:46:53.127]                             else {
[17:46:53.127]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:53.127]                                 info, version)
[17:46:53.127]                             }
[17:46:53.127]                             base::stop(msg)
[17:46:53.127]                           }
[17:46:53.127]                         })
[17:46:53.127]                       }
[17:46:53.127]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:53.127]                       base::options(mc.cores = 1L)
[17:46:53.127]                     }
[17:46:53.127]                     base::local({
[17:46:53.127]                       for (pkg in "stats") {
[17:46:53.127]                         base::loadNamespace(pkg)
[17:46:53.127]                         base::library(pkg, character.only = TRUE)
[17:46:53.127]                       }
[17:46:53.127]                     })
[17:46:53.127]                   }
[17:46:53.127]                   ...future.strategy.old <- future::plan("list")
[17:46:53.127]                   options(future.plan = NULL)
[17:46:53.127]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.127]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:53.127]                 }
[17:46:53.127]                 ...future.workdir <- getwd()
[17:46:53.127]             }
[17:46:53.127]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:53.127]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:53.127]         }
[17:46:53.127]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:53.127]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:53.127]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:53.127]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:53.127]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:53.127]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:53.127]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:53.127]             base::names(...future.oldOptions))
[17:46:53.127]     }
[17:46:53.127]     if (FALSE) {
[17:46:53.127]     }
[17:46:53.127]     else {
[17:46:53.127]         if (TRUE) {
[17:46:53.127]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:53.127]                 open = "w")
[17:46:53.127]         }
[17:46:53.127]         else {
[17:46:53.127]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:53.127]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:53.127]         }
[17:46:53.127]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:53.127]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:53.127]             base::sink(type = "output", split = FALSE)
[17:46:53.127]             base::close(...future.stdout)
[17:46:53.127]         }, add = TRUE)
[17:46:53.127]     }
[17:46:53.127]     ...future.frame <- base::sys.nframe()
[17:46:53.127]     ...future.conditions <- base::list()
[17:46:53.127]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:53.127]     if (FALSE) {
[17:46:53.127]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:53.127]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:53.127]     }
[17:46:53.127]     ...future.result <- base::tryCatch({
[17:46:53.127]         base::withCallingHandlers({
[17:46:53.127]             ...future.value <- base::withVisible(base::local({
[17:46:53.127]                 ...future.makeSendCondition <- base::local({
[17:46:53.127]                   sendCondition <- NULL
[17:46:53.127]                   function(frame = 1L) {
[17:46:53.127]                     if (is.function(sendCondition)) 
[17:46:53.127]                       return(sendCondition)
[17:46:53.127]                     ns <- getNamespace("parallel")
[17:46:53.127]                     if (exists("sendData", mode = "function", 
[17:46:53.127]                       envir = ns)) {
[17:46:53.127]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:53.127]                         envir = ns)
[17:46:53.127]                       envir <- sys.frame(frame)
[17:46:53.127]                       master <- NULL
[17:46:53.127]                       while (!identical(envir, .GlobalEnv) && 
[17:46:53.127]                         !identical(envir, emptyenv())) {
[17:46:53.127]                         if (exists("master", mode = "list", envir = envir, 
[17:46:53.127]                           inherits = FALSE)) {
[17:46:53.127]                           master <- get("master", mode = "list", 
[17:46:53.127]                             envir = envir, inherits = FALSE)
[17:46:53.127]                           if (inherits(master, c("SOCKnode", 
[17:46:53.127]                             "SOCK0node"))) {
[17:46:53.127]                             sendCondition <<- function(cond) {
[17:46:53.127]                               data <- list(type = "VALUE", value = cond, 
[17:46:53.127]                                 success = TRUE)
[17:46:53.127]                               parallel_sendData(master, data)
[17:46:53.127]                             }
[17:46:53.127]                             return(sendCondition)
[17:46:53.127]                           }
[17:46:53.127]                         }
[17:46:53.127]                         frame <- frame + 1L
[17:46:53.127]                         envir <- sys.frame(frame)
[17:46:53.127]                       }
[17:46:53.127]                     }
[17:46:53.127]                     sendCondition <<- function(cond) NULL
[17:46:53.127]                   }
[17:46:53.127]                 })
[17:46:53.127]                 withCallingHandlers({
[17:46:53.127]                   {
[17:46:53.127]                     lm(weight ~ group - 1)
[17:46:53.127]                   }
[17:46:53.127]                 }, immediateCondition = function(cond) {
[17:46:53.127]                   sendCondition <- ...future.makeSendCondition()
[17:46:53.127]                   sendCondition(cond)
[17:46:53.127]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.127]                   {
[17:46:53.127]                     inherits <- base::inherits
[17:46:53.127]                     invokeRestart <- base::invokeRestart
[17:46:53.127]                     is.null <- base::is.null
[17:46:53.127]                     muffled <- FALSE
[17:46:53.127]                     if (inherits(cond, "message")) {
[17:46:53.127]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:53.127]                       if (muffled) 
[17:46:53.127]                         invokeRestart("muffleMessage")
[17:46:53.127]                     }
[17:46:53.127]                     else if (inherits(cond, "warning")) {
[17:46:53.127]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:53.127]                       if (muffled) 
[17:46:53.127]                         invokeRestart("muffleWarning")
[17:46:53.127]                     }
[17:46:53.127]                     else if (inherits(cond, "condition")) {
[17:46:53.127]                       if (!is.null(pattern)) {
[17:46:53.127]                         computeRestarts <- base::computeRestarts
[17:46:53.127]                         grepl <- base::grepl
[17:46:53.127]                         restarts <- computeRestarts(cond)
[17:46:53.127]                         for (restart in restarts) {
[17:46:53.127]                           name <- restart$name
[17:46:53.127]                           if (is.null(name)) 
[17:46:53.127]                             next
[17:46:53.127]                           if (!grepl(pattern, name)) 
[17:46:53.127]                             next
[17:46:53.127]                           invokeRestart(restart)
[17:46:53.127]                           muffled <- TRUE
[17:46:53.127]                           break
[17:46:53.127]                         }
[17:46:53.127]                       }
[17:46:53.127]                     }
[17:46:53.127]                     invisible(muffled)
[17:46:53.127]                   }
[17:46:53.127]                   muffleCondition(cond)
[17:46:53.127]                 })
[17:46:53.127]             }))
[17:46:53.127]             future::FutureResult(value = ...future.value$value, 
[17:46:53.127]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.127]                   ...future.rng), globalenv = if (FALSE) 
[17:46:53.127]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:53.127]                     ...future.globalenv.names))
[17:46:53.127]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:53.127]         }, condition = base::local({
[17:46:53.127]             c <- base::c
[17:46:53.127]             inherits <- base::inherits
[17:46:53.127]             invokeRestart <- base::invokeRestart
[17:46:53.127]             length <- base::length
[17:46:53.127]             list <- base::list
[17:46:53.127]             seq.int <- base::seq.int
[17:46:53.127]             signalCondition <- base::signalCondition
[17:46:53.127]             sys.calls <- base::sys.calls
[17:46:53.127]             `[[` <- base::`[[`
[17:46:53.127]             `+` <- base::`+`
[17:46:53.127]             `<<-` <- base::`<<-`
[17:46:53.127]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:53.127]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:53.127]                   3L)]
[17:46:53.127]             }
[17:46:53.127]             function(cond) {
[17:46:53.127]                 is_error <- inherits(cond, "error")
[17:46:53.127]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:53.127]                   NULL)
[17:46:53.127]                 if (is_error) {
[17:46:53.127]                   sessionInformation <- function() {
[17:46:53.127]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:53.127]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:53.127]                       search = base::search(), system = base::Sys.info())
[17:46:53.127]                   }
[17:46:53.127]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.127]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:53.127]                     cond$call), session = sessionInformation(), 
[17:46:53.127]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:53.127]                   signalCondition(cond)
[17:46:53.127]                 }
[17:46:53.127]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:53.127]                 "immediateCondition"))) {
[17:46:53.127]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:53.127]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.127]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:53.127]                   if (TRUE && !signal) {
[17:46:53.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.127]                     {
[17:46:53.127]                       inherits <- base::inherits
[17:46:53.127]                       invokeRestart <- base::invokeRestart
[17:46:53.127]                       is.null <- base::is.null
[17:46:53.127]                       muffled <- FALSE
[17:46:53.127]                       if (inherits(cond, "message")) {
[17:46:53.127]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.127]                         if (muffled) 
[17:46:53.127]                           invokeRestart("muffleMessage")
[17:46:53.127]                       }
[17:46:53.127]                       else if (inherits(cond, "warning")) {
[17:46:53.127]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.127]                         if (muffled) 
[17:46:53.127]                           invokeRestart("muffleWarning")
[17:46:53.127]                       }
[17:46:53.127]                       else if (inherits(cond, "condition")) {
[17:46:53.127]                         if (!is.null(pattern)) {
[17:46:53.127]                           computeRestarts <- base::computeRestarts
[17:46:53.127]                           grepl <- base::grepl
[17:46:53.127]                           restarts <- computeRestarts(cond)
[17:46:53.127]                           for (restart in restarts) {
[17:46:53.127]                             name <- restart$name
[17:46:53.127]                             if (is.null(name)) 
[17:46:53.127]                               next
[17:46:53.127]                             if (!grepl(pattern, name)) 
[17:46:53.127]                               next
[17:46:53.127]                             invokeRestart(restart)
[17:46:53.127]                             muffled <- TRUE
[17:46:53.127]                             break
[17:46:53.127]                           }
[17:46:53.127]                         }
[17:46:53.127]                       }
[17:46:53.127]                       invisible(muffled)
[17:46:53.127]                     }
[17:46:53.127]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.127]                   }
[17:46:53.127]                 }
[17:46:53.127]                 else {
[17:46:53.127]                   if (TRUE) {
[17:46:53.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.127]                     {
[17:46:53.127]                       inherits <- base::inherits
[17:46:53.127]                       invokeRestart <- base::invokeRestart
[17:46:53.127]                       is.null <- base::is.null
[17:46:53.127]                       muffled <- FALSE
[17:46:53.127]                       if (inherits(cond, "message")) {
[17:46:53.127]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.127]                         if (muffled) 
[17:46:53.127]                           invokeRestart("muffleMessage")
[17:46:53.127]                       }
[17:46:53.127]                       else if (inherits(cond, "warning")) {
[17:46:53.127]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.127]                         if (muffled) 
[17:46:53.127]                           invokeRestart("muffleWarning")
[17:46:53.127]                       }
[17:46:53.127]                       else if (inherits(cond, "condition")) {
[17:46:53.127]                         if (!is.null(pattern)) {
[17:46:53.127]                           computeRestarts <- base::computeRestarts
[17:46:53.127]                           grepl <- base::grepl
[17:46:53.127]                           restarts <- computeRestarts(cond)
[17:46:53.127]                           for (restart in restarts) {
[17:46:53.127]                             name <- restart$name
[17:46:53.127]                             if (is.null(name)) 
[17:46:53.127]                               next
[17:46:53.127]                             if (!grepl(pattern, name)) 
[17:46:53.127]                               next
[17:46:53.127]                             invokeRestart(restart)
[17:46:53.127]                             muffled <- TRUE
[17:46:53.127]                             break
[17:46:53.127]                           }
[17:46:53.127]                         }
[17:46:53.127]                       }
[17:46:53.127]                       invisible(muffled)
[17:46:53.127]                     }
[17:46:53.127]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.127]                   }
[17:46:53.127]                 }
[17:46:53.127]             }
[17:46:53.127]         }))
[17:46:53.127]     }, error = function(ex) {
[17:46:53.127]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:53.127]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.127]                 ...future.rng), started = ...future.startTime, 
[17:46:53.127]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:53.127]             version = "1.8"), class = "FutureResult")
[17:46:53.127]     }, finally = {
[17:46:53.127]         if (!identical(...future.workdir, getwd())) 
[17:46:53.127]             setwd(...future.workdir)
[17:46:53.127]         {
[17:46:53.127]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:53.127]                 ...future.oldOptions$nwarnings <- NULL
[17:46:53.127]             }
[17:46:53.127]             base::options(...future.oldOptions)
[17:46:53.127]             if (.Platform$OS.type == "windows") {
[17:46:53.127]                 old_names <- names(...future.oldEnvVars)
[17:46:53.127]                 envs <- base::Sys.getenv()
[17:46:53.127]                 names <- names(envs)
[17:46:53.127]                 common <- intersect(names, old_names)
[17:46:53.127]                 added <- setdiff(names, old_names)
[17:46:53.127]                 removed <- setdiff(old_names, names)
[17:46:53.127]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:53.127]                   envs[common]]
[17:46:53.127]                 NAMES <- toupper(changed)
[17:46:53.127]                 args <- list()
[17:46:53.127]                 for (kk in seq_along(NAMES)) {
[17:46:53.127]                   name <- changed[[kk]]
[17:46:53.127]                   NAME <- NAMES[[kk]]
[17:46:53.127]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.127]                     next
[17:46:53.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.127]                 }
[17:46:53.127]                 NAMES <- toupper(added)
[17:46:53.127]                 for (kk in seq_along(NAMES)) {
[17:46:53.127]                   name <- added[[kk]]
[17:46:53.127]                   NAME <- NAMES[[kk]]
[17:46:53.127]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.127]                     next
[17:46:53.127]                   args[[name]] <- ""
[17:46:53.127]                 }
[17:46:53.127]                 NAMES <- toupper(removed)
[17:46:53.127]                 for (kk in seq_along(NAMES)) {
[17:46:53.127]                   name <- removed[[kk]]
[17:46:53.127]                   NAME <- NAMES[[kk]]
[17:46:53.127]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.127]                     next
[17:46:53.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.127]                 }
[17:46:53.127]                 if (length(args) > 0) 
[17:46:53.127]                   base::do.call(base::Sys.setenv, args = args)
[17:46:53.127]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:53.127]             }
[17:46:53.127]             else {
[17:46:53.127]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:53.127]             }
[17:46:53.127]             {
[17:46:53.127]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:53.127]                   0L) {
[17:46:53.127]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:53.127]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:53.127]                   base::options(opts)
[17:46:53.127]                 }
[17:46:53.127]                 {
[17:46:53.127]                   {
[17:46:53.127]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:53.127]                     NULL
[17:46:53.127]                   }
[17:46:53.127]                   options(future.plan = NULL)
[17:46:53.127]                   if (is.na(NA_character_)) 
[17:46:53.127]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.127]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:53.127]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:53.127]                     .init = FALSE)
[17:46:53.127]                 }
[17:46:53.127]             }
[17:46:53.127]         }
[17:46:53.127]     })
[17:46:53.127]     if (TRUE) {
[17:46:53.127]         base::sink(type = "output", split = FALSE)
[17:46:53.127]         if (TRUE) {
[17:46:53.127]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:53.127]         }
[17:46:53.127]         else {
[17:46:53.127]             ...future.result["stdout"] <- base::list(NULL)
[17:46:53.127]         }
[17:46:53.127]         base::close(...future.stdout)
[17:46:53.127]         ...future.stdout <- NULL
[17:46:53.127]     }
[17:46:53.127]     ...future.result$conditions <- ...future.conditions
[17:46:53.127]     ...future.result$finished <- base::Sys.time()
[17:46:53.127]     ...future.result
[17:46:53.127] }
[17:46:53.129] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:46:53.129] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:46:53.130] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:46:53.130] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:46:53.130] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:46:53.130] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:46:53.131] MultisessionFuture started
[17:46:53.131] - Launch lazy future ... done
[17:46:53.131] run() for ‘MultisessionFuture’ ... done
[17:46:53.131] result() for ClusterFuture ...
[17:46:53.132] receiveMessageFromWorker() for ClusterFuture ...
[17:46:53.132] - Validating connection of MultisessionFuture
[17:46:53.174] - received message: FutureResult
[17:46:53.174] - Received FutureResult
[17:46:53.174] - Erased future from FutureRegistry
[17:46:53.174] result() for ClusterFuture ...
[17:46:53.174] - result already collected: FutureResult
[17:46:53.175] result() for ClusterFuture ... done
[17:46:53.175] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:53.175] result() for ClusterFuture ... done
[17:46:53.175] result() for ClusterFuture ...
[17:46:53.175] - result already collected: FutureResult
[17:46:53.175] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[17:46:53.177] getGlobalsAndPackages() ...
[17:46:53.177] Searching for globals...
[17:46:53.178] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:46:53.178] Searching for globals ... DONE
[17:46:53.178] Resolving globals: FALSE
[17:46:53.179] The total size of the 1 globals is 96 bytes (96 bytes)
[17:46:53.179] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:46:53.179] - globals: [1] ‘x’
[17:46:53.179] - packages: [1] ‘stats’
[17:46:53.179] getGlobalsAndPackages() ... DONE
[17:46:53.179] run() for ‘Future’ ...
[17:46:53.180] - state: ‘created’
[17:46:53.180] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:53.193] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:53.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:53.194]   - Field: ‘node’
[17:46:53.194]   - Field: ‘label’
[17:46:53.194]   - Field: ‘local’
[17:46:53.194]   - Field: ‘owner’
[17:46:53.194]   - Field: ‘envir’
[17:46:53.194]   - Field: ‘workers’
[17:46:53.194]   - Field: ‘packages’
[17:46:53.194]   - Field: ‘gc’
[17:46:53.194]   - Field: ‘conditions’
[17:46:53.195]   - Field: ‘persistent’
[17:46:53.195]   - Field: ‘expr’
[17:46:53.195]   - Field: ‘uuid’
[17:46:53.195]   - Field: ‘seed’
[17:46:53.195]   - Field: ‘version’
[17:46:53.195]   - Field: ‘result’
[17:46:53.195]   - Field: ‘asynchronous’
[17:46:53.195]   - Field: ‘calls’
[17:46:53.195]   - Field: ‘globals’
[17:46:53.195]   - Field: ‘stdout’
[17:46:53.195]   - Field: ‘earlySignal’
[17:46:53.196]   - Field: ‘lazy’
[17:46:53.196]   - Field: ‘state’
[17:46:53.196] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:53.196] - Launch lazy future ...
[17:46:53.196] Packages needed by the future expression (n = 1): ‘stats’
[17:46:53.196] Packages needed by future strategies (n = 0): <none>
[17:46:53.197] {
[17:46:53.197]     {
[17:46:53.197]         {
[17:46:53.197]             ...future.startTime <- base::Sys.time()
[17:46:53.197]             {
[17:46:53.197]                 {
[17:46:53.197]                   {
[17:46:53.197]                     {
[17:46:53.197]                       {
[17:46:53.197]                         base::local({
[17:46:53.197]                           has_future <- base::requireNamespace("future", 
[17:46:53.197]                             quietly = TRUE)
[17:46:53.197]                           if (has_future) {
[17:46:53.197]                             ns <- base::getNamespace("future")
[17:46:53.197]                             version <- ns[[".package"]][["version"]]
[17:46:53.197]                             if (is.null(version)) 
[17:46:53.197]                               version <- utils::packageVersion("future")
[17:46:53.197]                           }
[17:46:53.197]                           else {
[17:46:53.197]                             version <- NULL
[17:46:53.197]                           }
[17:46:53.197]                           if (!has_future || version < "1.8.0") {
[17:46:53.197]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:53.197]                               "", base::R.version$version.string), 
[17:46:53.197]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:53.197]                                 base::R.version$platform, 8 * 
[17:46:53.197]                                   base::.Machine$sizeof.pointer), 
[17:46:53.197]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:53.197]                                 "release", "version")], collapse = " "), 
[17:46:53.197]                               hostname = base::Sys.info()[["nodename"]])
[17:46:53.197]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:53.197]                               info)
[17:46:53.197]                             info <- base::paste(info, collapse = "; ")
[17:46:53.197]                             if (!has_future) {
[17:46:53.197]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:53.197]                                 info)
[17:46:53.197]                             }
[17:46:53.197]                             else {
[17:46:53.197]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:53.197]                                 info, version)
[17:46:53.197]                             }
[17:46:53.197]                             base::stop(msg)
[17:46:53.197]                           }
[17:46:53.197]                         })
[17:46:53.197]                       }
[17:46:53.197]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:53.197]                       base::options(mc.cores = 1L)
[17:46:53.197]                     }
[17:46:53.197]                     base::local({
[17:46:53.197]                       for (pkg in "stats") {
[17:46:53.197]                         base::loadNamespace(pkg)
[17:46:53.197]                         base::library(pkg, character.only = TRUE)
[17:46:53.197]                       }
[17:46:53.197]                     })
[17:46:53.197]                   }
[17:46:53.197]                   ...future.strategy.old <- future::plan("list")
[17:46:53.197]                   options(future.plan = NULL)
[17:46:53.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:53.197]                 }
[17:46:53.197]                 ...future.workdir <- getwd()
[17:46:53.197]             }
[17:46:53.197]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:53.197]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:53.197]         }
[17:46:53.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:53.197]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:53.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:53.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:53.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:53.197]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:53.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:53.197]             base::names(...future.oldOptions))
[17:46:53.197]     }
[17:46:53.197]     if (FALSE) {
[17:46:53.197]     }
[17:46:53.197]     else {
[17:46:53.197]         if (TRUE) {
[17:46:53.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:53.197]                 open = "w")
[17:46:53.197]         }
[17:46:53.197]         else {
[17:46:53.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:53.197]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:53.197]         }
[17:46:53.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:53.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:53.197]             base::sink(type = "output", split = FALSE)
[17:46:53.197]             base::close(...future.stdout)
[17:46:53.197]         }, add = TRUE)
[17:46:53.197]     }
[17:46:53.197]     ...future.frame <- base::sys.nframe()
[17:46:53.197]     ...future.conditions <- base::list()
[17:46:53.197]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:53.197]     if (FALSE) {
[17:46:53.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:53.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:53.197]     }
[17:46:53.197]     ...future.result <- base::tryCatch({
[17:46:53.197]         base::withCallingHandlers({
[17:46:53.197]             ...future.value <- base::withVisible(base::local({
[17:46:53.197]                 ...future.makeSendCondition <- base::local({
[17:46:53.197]                   sendCondition <- NULL
[17:46:53.197]                   function(frame = 1L) {
[17:46:53.197]                     if (is.function(sendCondition)) 
[17:46:53.197]                       return(sendCondition)
[17:46:53.197]                     ns <- getNamespace("parallel")
[17:46:53.197]                     if (exists("sendData", mode = "function", 
[17:46:53.197]                       envir = ns)) {
[17:46:53.197]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:53.197]                         envir = ns)
[17:46:53.197]                       envir <- sys.frame(frame)
[17:46:53.197]                       master <- NULL
[17:46:53.197]                       while (!identical(envir, .GlobalEnv) && 
[17:46:53.197]                         !identical(envir, emptyenv())) {
[17:46:53.197]                         if (exists("master", mode = "list", envir = envir, 
[17:46:53.197]                           inherits = FALSE)) {
[17:46:53.197]                           master <- get("master", mode = "list", 
[17:46:53.197]                             envir = envir, inherits = FALSE)
[17:46:53.197]                           if (inherits(master, c("SOCKnode", 
[17:46:53.197]                             "SOCK0node"))) {
[17:46:53.197]                             sendCondition <<- function(cond) {
[17:46:53.197]                               data <- list(type = "VALUE", value = cond, 
[17:46:53.197]                                 success = TRUE)
[17:46:53.197]                               parallel_sendData(master, data)
[17:46:53.197]                             }
[17:46:53.197]                             return(sendCondition)
[17:46:53.197]                           }
[17:46:53.197]                         }
[17:46:53.197]                         frame <- frame + 1L
[17:46:53.197]                         envir <- sys.frame(frame)
[17:46:53.197]                       }
[17:46:53.197]                     }
[17:46:53.197]                     sendCondition <<- function(cond) NULL
[17:46:53.197]                   }
[17:46:53.197]                 })
[17:46:53.197]                 withCallingHandlers({
[17:46:53.197]                   {
[17:46:53.197]                     xtabs(~x)
[17:46:53.197]                   }
[17:46:53.197]                 }, immediateCondition = function(cond) {
[17:46:53.197]                   sendCondition <- ...future.makeSendCondition()
[17:46:53.197]                   sendCondition(cond)
[17:46:53.197]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.197]                   {
[17:46:53.197]                     inherits <- base::inherits
[17:46:53.197]                     invokeRestart <- base::invokeRestart
[17:46:53.197]                     is.null <- base::is.null
[17:46:53.197]                     muffled <- FALSE
[17:46:53.197]                     if (inherits(cond, "message")) {
[17:46:53.197]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:53.197]                       if (muffled) 
[17:46:53.197]                         invokeRestart("muffleMessage")
[17:46:53.197]                     }
[17:46:53.197]                     else if (inherits(cond, "warning")) {
[17:46:53.197]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:53.197]                       if (muffled) 
[17:46:53.197]                         invokeRestart("muffleWarning")
[17:46:53.197]                     }
[17:46:53.197]                     else if (inherits(cond, "condition")) {
[17:46:53.197]                       if (!is.null(pattern)) {
[17:46:53.197]                         computeRestarts <- base::computeRestarts
[17:46:53.197]                         grepl <- base::grepl
[17:46:53.197]                         restarts <- computeRestarts(cond)
[17:46:53.197]                         for (restart in restarts) {
[17:46:53.197]                           name <- restart$name
[17:46:53.197]                           if (is.null(name)) 
[17:46:53.197]                             next
[17:46:53.197]                           if (!grepl(pattern, name)) 
[17:46:53.197]                             next
[17:46:53.197]                           invokeRestart(restart)
[17:46:53.197]                           muffled <- TRUE
[17:46:53.197]                           break
[17:46:53.197]                         }
[17:46:53.197]                       }
[17:46:53.197]                     }
[17:46:53.197]                     invisible(muffled)
[17:46:53.197]                   }
[17:46:53.197]                   muffleCondition(cond)
[17:46:53.197]                 })
[17:46:53.197]             }))
[17:46:53.197]             future::FutureResult(value = ...future.value$value, 
[17:46:53.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.197]                   ...future.rng), globalenv = if (FALSE) 
[17:46:53.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:53.197]                     ...future.globalenv.names))
[17:46:53.197]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:53.197]         }, condition = base::local({
[17:46:53.197]             c <- base::c
[17:46:53.197]             inherits <- base::inherits
[17:46:53.197]             invokeRestart <- base::invokeRestart
[17:46:53.197]             length <- base::length
[17:46:53.197]             list <- base::list
[17:46:53.197]             seq.int <- base::seq.int
[17:46:53.197]             signalCondition <- base::signalCondition
[17:46:53.197]             sys.calls <- base::sys.calls
[17:46:53.197]             `[[` <- base::`[[`
[17:46:53.197]             `+` <- base::`+`
[17:46:53.197]             `<<-` <- base::`<<-`
[17:46:53.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:53.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:53.197]                   3L)]
[17:46:53.197]             }
[17:46:53.197]             function(cond) {
[17:46:53.197]                 is_error <- inherits(cond, "error")
[17:46:53.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:53.197]                   NULL)
[17:46:53.197]                 if (is_error) {
[17:46:53.197]                   sessionInformation <- function() {
[17:46:53.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:53.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:53.197]                       search = base::search(), system = base::Sys.info())
[17:46:53.197]                   }
[17:46:53.197]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:53.197]                     cond$call), session = sessionInformation(), 
[17:46:53.197]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:53.197]                   signalCondition(cond)
[17:46:53.197]                 }
[17:46:53.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:53.197]                 "immediateCondition"))) {
[17:46:53.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:53.197]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:53.197]                   if (TRUE && !signal) {
[17:46:53.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.197]                     {
[17:46:53.197]                       inherits <- base::inherits
[17:46:53.197]                       invokeRestart <- base::invokeRestart
[17:46:53.197]                       is.null <- base::is.null
[17:46:53.197]                       muffled <- FALSE
[17:46:53.197]                       if (inherits(cond, "message")) {
[17:46:53.197]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.197]                         if (muffled) 
[17:46:53.197]                           invokeRestart("muffleMessage")
[17:46:53.197]                       }
[17:46:53.197]                       else if (inherits(cond, "warning")) {
[17:46:53.197]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.197]                         if (muffled) 
[17:46:53.197]                           invokeRestart("muffleWarning")
[17:46:53.197]                       }
[17:46:53.197]                       else if (inherits(cond, "condition")) {
[17:46:53.197]                         if (!is.null(pattern)) {
[17:46:53.197]                           computeRestarts <- base::computeRestarts
[17:46:53.197]                           grepl <- base::grepl
[17:46:53.197]                           restarts <- computeRestarts(cond)
[17:46:53.197]                           for (restart in restarts) {
[17:46:53.197]                             name <- restart$name
[17:46:53.197]                             if (is.null(name)) 
[17:46:53.197]                               next
[17:46:53.197]                             if (!grepl(pattern, name)) 
[17:46:53.197]                               next
[17:46:53.197]                             invokeRestart(restart)
[17:46:53.197]                             muffled <- TRUE
[17:46:53.197]                             break
[17:46:53.197]                           }
[17:46:53.197]                         }
[17:46:53.197]                       }
[17:46:53.197]                       invisible(muffled)
[17:46:53.197]                     }
[17:46:53.197]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.197]                   }
[17:46:53.197]                 }
[17:46:53.197]                 else {
[17:46:53.197]                   if (TRUE) {
[17:46:53.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.197]                     {
[17:46:53.197]                       inherits <- base::inherits
[17:46:53.197]                       invokeRestart <- base::invokeRestart
[17:46:53.197]                       is.null <- base::is.null
[17:46:53.197]                       muffled <- FALSE
[17:46:53.197]                       if (inherits(cond, "message")) {
[17:46:53.197]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.197]                         if (muffled) 
[17:46:53.197]                           invokeRestart("muffleMessage")
[17:46:53.197]                       }
[17:46:53.197]                       else if (inherits(cond, "warning")) {
[17:46:53.197]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.197]                         if (muffled) 
[17:46:53.197]                           invokeRestart("muffleWarning")
[17:46:53.197]                       }
[17:46:53.197]                       else if (inherits(cond, "condition")) {
[17:46:53.197]                         if (!is.null(pattern)) {
[17:46:53.197]                           computeRestarts <- base::computeRestarts
[17:46:53.197]                           grepl <- base::grepl
[17:46:53.197]                           restarts <- computeRestarts(cond)
[17:46:53.197]                           for (restart in restarts) {
[17:46:53.197]                             name <- restart$name
[17:46:53.197]                             if (is.null(name)) 
[17:46:53.197]                               next
[17:46:53.197]                             if (!grepl(pattern, name)) 
[17:46:53.197]                               next
[17:46:53.197]                             invokeRestart(restart)
[17:46:53.197]                             muffled <- TRUE
[17:46:53.197]                             break
[17:46:53.197]                           }
[17:46:53.197]                         }
[17:46:53.197]                       }
[17:46:53.197]                       invisible(muffled)
[17:46:53.197]                     }
[17:46:53.197]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.197]                   }
[17:46:53.197]                 }
[17:46:53.197]             }
[17:46:53.197]         }))
[17:46:53.197]     }, error = function(ex) {
[17:46:53.197]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:53.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.197]                 ...future.rng), started = ...future.startTime, 
[17:46:53.197]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:53.197]             version = "1.8"), class = "FutureResult")
[17:46:53.197]     }, finally = {
[17:46:53.197]         if (!identical(...future.workdir, getwd())) 
[17:46:53.197]             setwd(...future.workdir)
[17:46:53.197]         {
[17:46:53.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:53.197]                 ...future.oldOptions$nwarnings <- NULL
[17:46:53.197]             }
[17:46:53.197]             base::options(...future.oldOptions)
[17:46:53.197]             if (.Platform$OS.type == "windows") {
[17:46:53.197]                 old_names <- names(...future.oldEnvVars)
[17:46:53.197]                 envs <- base::Sys.getenv()
[17:46:53.197]                 names <- names(envs)
[17:46:53.197]                 common <- intersect(names, old_names)
[17:46:53.197]                 added <- setdiff(names, old_names)
[17:46:53.197]                 removed <- setdiff(old_names, names)
[17:46:53.197]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:53.197]                   envs[common]]
[17:46:53.197]                 NAMES <- toupper(changed)
[17:46:53.197]                 args <- list()
[17:46:53.197]                 for (kk in seq_along(NAMES)) {
[17:46:53.197]                   name <- changed[[kk]]
[17:46:53.197]                   NAME <- NAMES[[kk]]
[17:46:53.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.197]                     next
[17:46:53.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.197]                 }
[17:46:53.197]                 NAMES <- toupper(added)
[17:46:53.197]                 for (kk in seq_along(NAMES)) {
[17:46:53.197]                   name <- added[[kk]]
[17:46:53.197]                   NAME <- NAMES[[kk]]
[17:46:53.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.197]                     next
[17:46:53.197]                   args[[name]] <- ""
[17:46:53.197]                 }
[17:46:53.197]                 NAMES <- toupper(removed)
[17:46:53.197]                 for (kk in seq_along(NAMES)) {
[17:46:53.197]                   name <- removed[[kk]]
[17:46:53.197]                   NAME <- NAMES[[kk]]
[17:46:53.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.197]                     next
[17:46:53.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.197]                 }
[17:46:53.197]                 if (length(args) > 0) 
[17:46:53.197]                   base::do.call(base::Sys.setenv, args = args)
[17:46:53.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:53.197]             }
[17:46:53.197]             else {
[17:46:53.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:53.197]             }
[17:46:53.197]             {
[17:46:53.197]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:53.197]                   0L) {
[17:46:53.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:53.197]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:53.197]                   base::options(opts)
[17:46:53.197]                 }
[17:46:53.197]                 {
[17:46:53.197]                   {
[17:46:53.197]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:53.197]                     NULL
[17:46:53.197]                   }
[17:46:53.197]                   options(future.plan = NULL)
[17:46:53.197]                   if (is.na(NA_character_)) 
[17:46:53.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:53.197]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:53.197]                     .init = FALSE)
[17:46:53.197]                 }
[17:46:53.197]             }
[17:46:53.197]         }
[17:46:53.197]     })
[17:46:53.197]     if (TRUE) {
[17:46:53.197]         base::sink(type = "output", split = FALSE)
[17:46:53.197]         if (TRUE) {
[17:46:53.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:53.197]         }
[17:46:53.197]         else {
[17:46:53.197]             ...future.result["stdout"] <- base::list(NULL)
[17:46:53.197]         }
[17:46:53.197]         base::close(...future.stdout)
[17:46:53.197]         ...future.stdout <- NULL
[17:46:53.197]     }
[17:46:53.197]     ...future.result$conditions <- ...future.conditions
[17:46:53.197]     ...future.result$finished <- base::Sys.time()
[17:46:53.197]     ...future.result
[17:46:53.197] }
[17:46:53.199] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[17:46:53.199] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[17:46:53.200] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[17:46:53.200] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[17:46:53.200] MultisessionFuture started
[17:46:53.201] - Launch lazy future ... done
[17:46:53.201] run() for ‘MultisessionFuture’ ... done
[17:46:53.201] result() for ClusterFuture ...
[17:46:53.201] receiveMessageFromWorker() for ClusterFuture ...
[17:46:53.201] - Validating connection of MultisessionFuture
[17:46:53.246] - received message: FutureResult
[17:46:53.246] - Received FutureResult
[17:46:53.246] - Erased future from FutureRegistry
[17:46:53.246] result() for ClusterFuture ...
[17:46:53.246] - result already collected: FutureResult
[17:46:53.246] result() for ClusterFuture ... done
[17:46:53.247] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:53.247] result() for ClusterFuture ... done
[17:46:53.247] result() for ClusterFuture ...
[17:46:53.247] - result already collected: FutureResult
[17:46:53.247] result() for ClusterFuture ... done
x
1 2 
2 3 
[17:46:53.248] getGlobalsAndPackages() ...
[17:46:53.248] Searching for globals...
[17:46:53.249] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:46:53.249] Searching for globals ... DONE
[17:46:53.249] Resolving globals: FALSE
[17:46:53.249] The total size of the 1 globals is 96 bytes (96 bytes)
[17:46:53.250] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:46:53.250] - globals: [1] ‘x’
[17:46:53.250] - packages: [1] ‘stats’
[17:46:53.250] getGlobalsAndPackages() ... DONE
[17:46:53.250] run() for ‘Future’ ...
[17:46:53.250] - state: ‘created’
[17:46:53.251] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:53.264] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:53.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:53.264]   - Field: ‘node’
[17:46:53.264]   - Field: ‘label’
[17:46:53.264]   - Field: ‘local’
[17:46:53.265]   - Field: ‘owner’
[17:46:53.265]   - Field: ‘envir’
[17:46:53.265]   - Field: ‘workers’
[17:46:53.265]   - Field: ‘packages’
[17:46:53.265]   - Field: ‘gc’
[17:46:53.265]   - Field: ‘conditions’
[17:46:53.265]   - Field: ‘persistent’
[17:46:53.265]   - Field: ‘expr’
[17:46:53.265]   - Field: ‘uuid’
[17:46:53.265]   - Field: ‘seed’
[17:46:53.265]   - Field: ‘version’
[17:46:53.266]   - Field: ‘result’
[17:46:53.266]   - Field: ‘asynchronous’
[17:46:53.266]   - Field: ‘calls’
[17:46:53.266]   - Field: ‘globals’
[17:46:53.266]   - Field: ‘stdout’
[17:46:53.266]   - Field: ‘earlySignal’
[17:46:53.266]   - Field: ‘lazy’
[17:46:53.266]   - Field: ‘state’
[17:46:53.266] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:53.266] - Launch lazy future ...
[17:46:53.267] Packages needed by the future expression (n = 1): ‘stats’
[17:46:53.267] Packages needed by future strategies (n = 0): <none>
[17:46:53.267] {
[17:46:53.267]     {
[17:46:53.267]         {
[17:46:53.267]             ...future.startTime <- base::Sys.time()
[17:46:53.267]             {
[17:46:53.267]                 {
[17:46:53.267]                   {
[17:46:53.267]                     {
[17:46:53.267]                       {
[17:46:53.267]                         base::local({
[17:46:53.267]                           has_future <- base::requireNamespace("future", 
[17:46:53.267]                             quietly = TRUE)
[17:46:53.267]                           if (has_future) {
[17:46:53.267]                             ns <- base::getNamespace("future")
[17:46:53.267]                             version <- ns[[".package"]][["version"]]
[17:46:53.267]                             if (is.null(version)) 
[17:46:53.267]                               version <- utils::packageVersion("future")
[17:46:53.267]                           }
[17:46:53.267]                           else {
[17:46:53.267]                             version <- NULL
[17:46:53.267]                           }
[17:46:53.267]                           if (!has_future || version < "1.8.0") {
[17:46:53.267]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:53.267]                               "", base::R.version$version.string), 
[17:46:53.267]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:53.267]                                 base::R.version$platform, 8 * 
[17:46:53.267]                                   base::.Machine$sizeof.pointer), 
[17:46:53.267]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:53.267]                                 "release", "version")], collapse = " "), 
[17:46:53.267]                               hostname = base::Sys.info()[["nodename"]])
[17:46:53.267]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:53.267]                               info)
[17:46:53.267]                             info <- base::paste(info, collapse = "; ")
[17:46:53.267]                             if (!has_future) {
[17:46:53.267]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:53.267]                                 info)
[17:46:53.267]                             }
[17:46:53.267]                             else {
[17:46:53.267]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:53.267]                                 info, version)
[17:46:53.267]                             }
[17:46:53.267]                             base::stop(msg)
[17:46:53.267]                           }
[17:46:53.267]                         })
[17:46:53.267]                       }
[17:46:53.267]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:53.267]                       base::options(mc.cores = 1L)
[17:46:53.267]                     }
[17:46:53.267]                     base::local({
[17:46:53.267]                       for (pkg in "stats") {
[17:46:53.267]                         base::loadNamespace(pkg)
[17:46:53.267]                         base::library(pkg, character.only = TRUE)
[17:46:53.267]                       }
[17:46:53.267]                     })
[17:46:53.267]                   }
[17:46:53.267]                   ...future.strategy.old <- future::plan("list")
[17:46:53.267]                   options(future.plan = NULL)
[17:46:53.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:53.267]                 }
[17:46:53.267]                 ...future.workdir <- getwd()
[17:46:53.267]             }
[17:46:53.267]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:53.267]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:53.267]         }
[17:46:53.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:53.267]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:53.267]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:53.267]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:53.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:53.267]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:53.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:53.267]             base::names(...future.oldOptions))
[17:46:53.267]     }
[17:46:53.267]     if (FALSE) {
[17:46:53.267]     }
[17:46:53.267]     else {
[17:46:53.267]         if (TRUE) {
[17:46:53.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:53.267]                 open = "w")
[17:46:53.267]         }
[17:46:53.267]         else {
[17:46:53.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:53.267]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:53.267]         }
[17:46:53.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:53.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:53.267]             base::sink(type = "output", split = FALSE)
[17:46:53.267]             base::close(...future.stdout)
[17:46:53.267]         }, add = TRUE)
[17:46:53.267]     }
[17:46:53.267]     ...future.frame <- base::sys.nframe()
[17:46:53.267]     ...future.conditions <- base::list()
[17:46:53.267]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:53.267]     if (FALSE) {
[17:46:53.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:53.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:53.267]     }
[17:46:53.267]     ...future.result <- base::tryCatch({
[17:46:53.267]         base::withCallingHandlers({
[17:46:53.267]             ...future.value <- base::withVisible(base::local({
[17:46:53.267]                 ...future.makeSendCondition <- base::local({
[17:46:53.267]                   sendCondition <- NULL
[17:46:53.267]                   function(frame = 1L) {
[17:46:53.267]                     if (is.function(sendCondition)) 
[17:46:53.267]                       return(sendCondition)
[17:46:53.267]                     ns <- getNamespace("parallel")
[17:46:53.267]                     if (exists("sendData", mode = "function", 
[17:46:53.267]                       envir = ns)) {
[17:46:53.267]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:53.267]                         envir = ns)
[17:46:53.267]                       envir <- sys.frame(frame)
[17:46:53.267]                       master <- NULL
[17:46:53.267]                       while (!identical(envir, .GlobalEnv) && 
[17:46:53.267]                         !identical(envir, emptyenv())) {
[17:46:53.267]                         if (exists("master", mode = "list", envir = envir, 
[17:46:53.267]                           inherits = FALSE)) {
[17:46:53.267]                           master <- get("master", mode = "list", 
[17:46:53.267]                             envir = envir, inherits = FALSE)
[17:46:53.267]                           if (inherits(master, c("SOCKnode", 
[17:46:53.267]                             "SOCK0node"))) {
[17:46:53.267]                             sendCondition <<- function(cond) {
[17:46:53.267]                               data <- list(type = "VALUE", value = cond, 
[17:46:53.267]                                 success = TRUE)
[17:46:53.267]                               parallel_sendData(master, data)
[17:46:53.267]                             }
[17:46:53.267]                             return(sendCondition)
[17:46:53.267]                           }
[17:46:53.267]                         }
[17:46:53.267]                         frame <- frame + 1L
[17:46:53.267]                         envir <- sys.frame(frame)
[17:46:53.267]                       }
[17:46:53.267]                     }
[17:46:53.267]                     sendCondition <<- function(cond) NULL
[17:46:53.267]                   }
[17:46:53.267]                 })
[17:46:53.267]                 withCallingHandlers({
[17:46:53.267]                   {
[17:46:53.267]                     xtabs(~x)
[17:46:53.267]                   }
[17:46:53.267]                 }, immediateCondition = function(cond) {
[17:46:53.267]                   sendCondition <- ...future.makeSendCondition()
[17:46:53.267]                   sendCondition(cond)
[17:46:53.267]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.267]                   {
[17:46:53.267]                     inherits <- base::inherits
[17:46:53.267]                     invokeRestart <- base::invokeRestart
[17:46:53.267]                     is.null <- base::is.null
[17:46:53.267]                     muffled <- FALSE
[17:46:53.267]                     if (inherits(cond, "message")) {
[17:46:53.267]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:53.267]                       if (muffled) 
[17:46:53.267]                         invokeRestart("muffleMessage")
[17:46:53.267]                     }
[17:46:53.267]                     else if (inherits(cond, "warning")) {
[17:46:53.267]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:53.267]                       if (muffled) 
[17:46:53.267]                         invokeRestart("muffleWarning")
[17:46:53.267]                     }
[17:46:53.267]                     else if (inherits(cond, "condition")) {
[17:46:53.267]                       if (!is.null(pattern)) {
[17:46:53.267]                         computeRestarts <- base::computeRestarts
[17:46:53.267]                         grepl <- base::grepl
[17:46:53.267]                         restarts <- computeRestarts(cond)
[17:46:53.267]                         for (restart in restarts) {
[17:46:53.267]                           name <- restart$name
[17:46:53.267]                           if (is.null(name)) 
[17:46:53.267]                             next
[17:46:53.267]                           if (!grepl(pattern, name)) 
[17:46:53.267]                             next
[17:46:53.267]                           invokeRestart(restart)
[17:46:53.267]                           muffled <- TRUE
[17:46:53.267]                           break
[17:46:53.267]                         }
[17:46:53.267]                       }
[17:46:53.267]                     }
[17:46:53.267]                     invisible(muffled)
[17:46:53.267]                   }
[17:46:53.267]                   muffleCondition(cond)
[17:46:53.267]                 })
[17:46:53.267]             }))
[17:46:53.267]             future::FutureResult(value = ...future.value$value, 
[17:46:53.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.267]                   ...future.rng), globalenv = if (FALSE) 
[17:46:53.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:53.267]                     ...future.globalenv.names))
[17:46:53.267]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:53.267]         }, condition = base::local({
[17:46:53.267]             c <- base::c
[17:46:53.267]             inherits <- base::inherits
[17:46:53.267]             invokeRestart <- base::invokeRestart
[17:46:53.267]             length <- base::length
[17:46:53.267]             list <- base::list
[17:46:53.267]             seq.int <- base::seq.int
[17:46:53.267]             signalCondition <- base::signalCondition
[17:46:53.267]             sys.calls <- base::sys.calls
[17:46:53.267]             `[[` <- base::`[[`
[17:46:53.267]             `+` <- base::`+`
[17:46:53.267]             `<<-` <- base::`<<-`
[17:46:53.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:53.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:53.267]                   3L)]
[17:46:53.267]             }
[17:46:53.267]             function(cond) {
[17:46:53.267]                 is_error <- inherits(cond, "error")
[17:46:53.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:53.267]                   NULL)
[17:46:53.267]                 if (is_error) {
[17:46:53.267]                   sessionInformation <- function() {
[17:46:53.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:53.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:53.267]                       search = base::search(), system = base::Sys.info())
[17:46:53.267]                   }
[17:46:53.267]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:53.267]                     cond$call), session = sessionInformation(), 
[17:46:53.267]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:53.267]                   signalCondition(cond)
[17:46:53.267]                 }
[17:46:53.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:53.267]                 "immediateCondition"))) {
[17:46:53.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:53.267]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:53.267]                   if (TRUE && !signal) {
[17:46:53.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.267]                     {
[17:46:53.267]                       inherits <- base::inherits
[17:46:53.267]                       invokeRestart <- base::invokeRestart
[17:46:53.267]                       is.null <- base::is.null
[17:46:53.267]                       muffled <- FALSE
[17:46:53.267]                       if (inherits(cond, "message")) {
[17:46:53.267]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.267]                         if (muffled) 
[17:46:53.267]                           invokeRestart("muffleMessage")
[17:46:53.267]                       }
[17:46:53.267]                       else if (inherits(cond, "warning")) {
[17:46:53.267]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.267]                         if (muffled) 
[17:46:53.267]                           invokeRestart("muffleWarning")
[17:46:53.267]                       }
[17:46:53.267]                       else if (inherits(cond, "condition")) {
[17:46:53.267]                         if (!is.null(pattern)) {
[17:46:53.267]                           computeRestarts <- base::computeRestarts
[17:46:53.267]                           grepl <- base::grepl
[17:46:53.267]                           restarts <- computeRestarts(cond)
[17:46:53.267]                           for (restart in restarts) {
[17:46:53.267]                             name <- restart$name
[17:46:53.267]                             if (is.null(name)) 
[17:46:53.267]                               next
[17:46:53.267]                             if (!grepl(pattern, name)) 
[17:46:53.267]                               next
[17:46:53.267]                             invokeRestart(restart)
[17:46:53.267]                             muffled <- TRUE
[17:46:53.267]                             break
[17:46:53.267]                           }
[17:46:53.267]                         }
[17:46:53.267]                       }
[17:46:53.267]                       invisible(muffled)
[17:46:53.267]                     }
[17:46:53.267]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.267]                   }
[17:46:53.267]                 }
[17:46:53.267]                 else {
[17:46:53.267]                   if (TRUE) {
[17:46:53.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.267]                     {
[17:46:53.267]                       inherits <- base::inherits
[17:46:53.267]                       invokeRestart <- base::invokeRestart
[17:46:53.267]                       is.null <- base::is.null
[17:46:53.267]                       muffled <- FALSE
[17:46:53.267]                       if (inherits(cond, "message")) {
[17:46:53.267]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.267]                         if (muffled) 
[17:46:53.267]                           invokeRestart("muffleMessage")
[17:46:53.267]                       }
[17:46:53.267]                       else if (inherits(cond, "warning")) {
[17:46:53.267]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.267]                         if (muffled) 
[17:46:53.267]                           invokeRestart("muffleWarning")
[17:46:53.267]                       }
[17:46:53.267]                       else if (inherits(cond, "condition")) {
[17:46:53.267]                         if (!is.null(pattern)) {
[17:46:53.267]                           computeRestarts <- base::computeRestarts
[17:46:53.267]                           grepl <- base::grepl
[17:46:53.267]                           restarts <- computeRestarts(cond)
[17:46:53.267]                           for (restart in restarts) {
[17:46:53.267]                             name <- restart$name
[17:46:53.267]                             if (is.null(name)) 
[17:46:53.267]                               next
[17:46:53.267]                             if (!grepl(pattern, name)) 
[17:46:53.267]                               next
[17:46:53.267]                             invokeRestart(restart)
[17:46:53.267]                             muffled <- TRUE
[17:46:53.267]                             break
[17:46:53.267]                           }
[17:46:53.267]                         }
[17:46:53.267]                       }
[17:46:53.267]                       invisible(muffled)
[17:46:53.267]                     }
[17:46:53.267]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.267]                   }
[17:46:53.267]                 }
[17:46:53.267]             }
[17:46:53.267]         }))
[17:46:53.267]     }, error = function(ex) {
[17:46:53.267]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:53.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.267]                 ...future.rng), started = ...future.startTime, 
[17:46:53.267]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:53.267]             version = "1.8"), class = "FutureResult")
[17:46:53.267]     }, finally = {
[17:46:53.267]         if (!identical(...future.workdir, getwd())) 
[17:46:53.267]             setwd(...future.workdir)
[17:46:53.267]         {
[17:46:53.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:53.267]                 ...future.oldOptions$nwarnings <- NULL
[17:46:53.267]             }
[17:46:53.267]             base::options(...future.oldOptions)
[17:46:53.267]             if (.Platform$OS.type == "windows") {
[17:46:53.267]                 old_names <- names(...future.oldEnvVars)
[17:46:53.267]                 envs <- base::Sys.getenv()
[17:46:53.267]                 names <- names(envs)
[17:46:53.267]                 common <- intersect(names, old_names)
[17:46:53.267]                 added <- setdiff(names, old_names)
[17:46:53.267]                 removed <- setdiff(old_names, names)
[17:46:53.267]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:53.267]                   envs[common]]
[17:46:53.267]                 NAMES <- toupper(changed)
[17:46:53.267]                 args <- list()
[17:46:53.267]                 for (kk in seq_along(NAMES)) {
[17:46:53.267]                   name <- changed[[kk]]
[17:46:53.267]                   NAME <- NAMES[[kk]]
[17:46:53.267]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.267]                     next
[17:46:53.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.267]                 }
[17:46:53.267]                 NAMES <- toupper(added)
[17:46:53.267]                 for (kk in seq_along(NAMES)) {
[17:46:53.267]                   name <- added[[kk]]
[17:46:53.267]                   NAME <- NAMES[[kk]]
[17:46:53.267]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.267]                     next
[17:46:53.267]                   args[[name]] <- ""
[17:46:53.267]                 }
[17:46:53.267]                 NAMES <- toupper(removed)
[17:46:53.267]                 for (kk in seq_along(NAMES)) {
[17:46:53.267]                   name <- removed[[kk]]
[17:46:53.267]                   NAME <- NAMES[[kk]]
[17:46:53.267]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.267]                     next
[17:46:53.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.267]                 }
[17:46:53.267]                 if (length(args) > 0) 
[17:46:53.267]                   base::do.call(base::Sys.setenv, args = args)
[17:46:53.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:53.267]             }
[17:46:53.267]             else {
[17:46:53.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:53.267]             }
[17:46:53.267]             {
[17:46:53.267]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:53.267]                   0L) {
[17:46:53.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:53.267]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:53.267]                   base::options(opts)
[17:46:53.267]                 }
[17:46:53.267]                 {
[17:46:53.267]                   {
[17:46:53.267]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:53.267]                     NULL
[17:46:53.267]                   }
[17:46:53.267]                   options(future.plan = NULL)
[17:46:53.267]                   if (is.na(NA_character_)) 
[17:46:53.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:53.267]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:53.267]                     .init = FALSE)
[17:46:53.267]                 }
[17:46:53.267]             }
[17:46:53.267]         }
[17:46:53.267]     })
[17:46:53.267]     if (TRUE) {
[17:46:53.267]         base::sink(type = "output", split = FALSE)
[17:46:53.267]         if (TRUE) {
[17:46:53.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:53.267]         }
[17:46:53.267]         else {
[17:46:53.267]             ...future.result["stdout"] <- base::list(NULL)
[17:46:53.267]         }
[17:46:53.267]         base::close(...future.stdout)
[17:46:53.267]         ...future.stdout <- NULL
[17:46:53.267]     }
[17:46:53.267]     ...future.result$conditions <- ...future.conditions
[17:46:53.267]     ...future.result$finished <- base::Sys.time()
[17:46:53.267]     ...future.result
[17:46:53.267] }
[17:46:53.270] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[17:46:53.270] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[17:46:53.270] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[17:46:53.270] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[17:46:53.271] MultisessionFuture started
[17:46:53.271] - Launch lazy future ... done
[17:46:53.271] run() for ‘MultisessionFuture’ ... done
[17:46:53.271] result() for ClusterFuture ...
[17:46:53.272] receiveMessageFromWorker() for ClusterFuture ...
[17:46:53.272] - Validating connection of MultisessionFuture
[17:46:53.313] - received message: FutureResult
[17:46:53.314] - Received FutureResult
[17:46:53.314] - Erased future from FutureRegistry
[17:46:53.314] result() for ClusterFuture ...
[17:46:53.314] - result already collected: FutureResult
[17:46:53.314] result() for ClusterFuture ... done
[17:46:53.314] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:53.314] result() for ClusterFuture ... done
[17:46:53.314] result() for ClusterFuture ...
[17:46:53.314] - result already collected: FutureResult
[17:46:53.314] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[17:46:53.316] getGlobalsAndPackages() ...
[17:46:53.316] Searching for globals...
[17:46:53.317] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[17:46:53.318] Searching for globals ... DONE
[17:46:53.318] Resolving globals: FALSE
[17:46:53.318] 
[17:46:53.318] - packages: [2] ‘stats’, ‘datasets’
[17:46:53.318] getGlobalsAndPackages() ... DONE
[17:46:53.319] run() for ‘Future’ ...
[17:46:53.319] - state: ‘created’
[17:46:53.319] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:53.333] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:53.333] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:53.333]   - Field: ‘node’
[17:46:53.333]   - Field: ‘label’
[17:46:53.333]   - Field: ‘local’
[17:46:53.333]   - Field: ‘owner’
[17:46:53.334]   - Field: ‘envir’
[17:46:53.334]   - Field: ‘workers’
[17:46:53.334]   - Field: ‘packages’
[17:46:53.334]   - Field: ‘gc’
[17:46:53.334]   - Field: ‘conditions’
[17:46:53.334]   - Field: ‘persistent’
[17:46:53.334]   - Field: ‘expr’
[17:46:53.334]   - Field: ‘uuid’
[17:46:53.334]   - Field: ‘seed’
[17:46:53.334]   - Field: ‘version’
[17:46:53.334]   - Field: ‘result’
[17:46:53.335]   - Field: ‘asynchronous’
[17:46:53.335]   - Field: ‘calls’
[17:46:53.335]   - Field: ‘globals’
[17:46:53.335]   - Field: ‘stdout’
[17:46:53.335]   - Field: ‘earlySignal’
[17:46:53.335]   - Field: ‘lazy’
[17:46:53.335]   - Field: ‘state’
[17:46:53.335] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:53.335] - Launch lazy future ...
[17:46:53.336] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:53.336] Packages needed by future strategies (n = 0): <none>
[17:46:53.336] {
[17:46:53.336]     {
[17:46:53.336]         {
[17:46:53.336]             ...future.startTime <- base::Sys.time()
[17:46:53.336]             {
[17:46:53.336]                 {
[17:46:53.336]                   {
[17:46:53.336]                     {
[17:46:53.336]                       {
[17:46:53.336]                         base::local({
[17:46:53.336]                           has_future <- base::requireNamespace("future", 
[17:46:53.336]                             quietly = TRUE)
[17:46:53.336]                           if (has_future) {
[17:46:53.336]                             ns <- base::getNamespace("future")
[17:46:53.336]                             version <- ns[[".package"]][["version"]]
[17:46:53.336]                             if (is.null(version)) 
[17:46:53.336]                               version <- utils::packageVersion("future")
[17:46:53.336]                           }
[17:46:53.336]                           else {
[17:46:53.336]                             version <- NULL
[17:46:53.336]                           }
[17:46:53.336]                           if (!has_future || version < "1.8.0") {
[17:46:53.336]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:53.336]                               "", base::R.version$version.string), 
[17:46:53.336]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:53.336]                                 base::R.version$platform, 8 * 
[17:46:53.336]                                   base::.Machine$sizeof.pointer), 
[17:46:53.336]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:53.336]                                 "release", "version")], collapse = " "), 
[17:46:53.336]                               hostname = base::Sys.info()[["nodename"]])
[17:46:53.336]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:53.336]                               info)
[17:46:53.336]                             info <- base::paste(info, collapse = "; ")
[17:46:53.336]                             if (!has_future) {
[17:46:53.336]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:53.336]                                 info)
[17:46:53.336]                             }
[17:46:53.336]                             else {
[17:46:53.336]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:53.336]                                 info, version)
[17:46:53.336]                             }
[17:46:53.336]                             base::stop(msg)
[17:46:53.336]                           }
[17:46:53.336]                         })
[17:46:53.336]                       }
[17:46:53.336]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:53.336]                       base::options(mc.cores = 1L)
[17:46:53.336]                     }
[17:46:53.336]                     base::local({
[17:46:53.336]                       for (pkg in c("stats", "datasets")) {
[17:46:53.336]                         base::loadNamespace(pkg)
[17:46:53.336]                         base::library(pkg, character.only = TRUE)
[17:46:53.336]                       }
[17:46:53.336]                     })
[17:46:53.336]                   }
[17:46:53.336]                   ...future.strategy.old <- future::plan("list")
[17:46:53.336]                   options(future.plan = NULL)
[17:46:53.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:53.336]                 }
[17:46:53.336]                 ...future.workdir <- getwd()
[17:46:53.336]             }
[17:46:53.336]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:53.336]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:53.336]         }
[17:46:53.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:53.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:53.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:53.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:53.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:53.336]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:53.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:53.336]             base::names(...future.oldOptions))
[17:46:53.336]     }
[17:46:53.336]     if (FALSE) {
[17:46:53.336]     }
[17:46:53.336]     else {
[17:46:53.336]         if (TRUE) {
[17:46:53.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:53.336]                 open = "w")
[17:46:53.336]         }
[17:46:53.336]         else {
[17:46:53.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:53.336]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:53.336]         }
[17:46:53.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:53.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:53.336]             base::sink(type = "output", split = FALSE)
[17:46:53.336]             base::close(...future.stdout)
[17:46:53.336]         }, add = TRUE)
[17:46:53.336]     }
[17:46:53.336]     ...future.frame <- base::sys.nframe()
[17:46:53.336]     ...future.conditions <- base::list()
[17:46:53.336]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:53.336]     if (FALSE) {
[17:46:53.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:53.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:53.336]     }
[17:46:53.336]     ...future.result <- base::tryCatch({
[17:46:53.336]         base::withCallingHandlers({
[17:46:53.336]             ...future.value <- base::withVisible(base::local({
[17:46:53.336]                 ...future.makeSendCondition <- base::local({
[17:46:53.336]                   sendCondition <- NULL
[17:46:53.336]                   function(frame = 1L) {
[17:46:53.336]                     if (is.function(sendCondition)) 
[17:46:53.336]                       return(sendCondition)
[17:46:53.336]                     ns <- getNamespace("parallel")
[17:46:53.336]                     if (exists("sendData", mode = "function", 
[17:46:53.336]                       envir = ns)) {
[17:46:53.336]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:53.336]                         envir = ns)
[17:46:53.336]                       envir <- sys.frame(frame)
[17:46:53.336]                       master <- NULL
[17:46:53.336]                       while (!identical(envir, .GlobalEnv) && 
[17:46:53.336]                         !identical(envir, emptyenv())) {
[17:46:53.336]                         if (exists("master", mode = "list", envir = envir, 
[17:46:53.336]                           inherits = FALSE)) {
[17:46:53.336]                           master <- get("master", mode = "list", 
[17:46:53.336]                             envir = envir, inherits = FALSE)
[17:46:53.336]                           if (inherits(master, c("SOCKnode", 
[17:46:53.336]                             "SOCK0node"))) {
[17:46:53.336]                             sendCondition <<- function(cond) {
[17:46:53.336]                               data <- list(type = "VALUE", value = cond, 
[17:46:53.336]                                 success = TRUE)
[17:46:53.336]                               parallel_sendData(master, data)
[17:46:53.336]                             }
[17:46:53.336]                             return(sendCondition)
[17:46:53.336]                           }
[17:46:53.336]                         }
[17:46:53.336]                         frame <- frame + 1L
[17:46:53.336]                         envir <- sys.frame(frame)
[17:46:53.336]                       }
[17:46:53.336]                     }
[17:46:53.336]                     sendCondition <<- function(cond) NULL
[17:46:53.336]                   }
[17:46:53.336]                 })
[17:46:53.336]                 withCallingHandlers({
[17:46:53.336]                   {
[17:46:53.336]                     lm(dist ~ . - 1, data = cars)
[17:46:53.336]                   }
[17:46:53.336]                 }, immediateCondition = function(cond) {
[17:46:53.336]                   sendCondition <- ...future.makeSendCondition()
[17:46:53.336]                   sendCondition(cond)
[17:46:53.336]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.336]                   {
[17:46:53.336]                     inherits <- base::inherits
[17:46:53.336]                     invokeRestart <- base::invokeRestart
[17:46:53.336]                     is.null <- base::is.null
[17:46:53.336]                     muffled <- FALSE
[17:46:53.336]                     if (inherits(cond, "message")) {
[17:46:53.336]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:53.336]                       if (muffled) 
[17:46:53.336]                         invokeRestart("muffleMessage")
[17:46:53.336]                     }
[17:46:53.336]                     else if (inherits(cond, "warning")) {
[17:46:53.336]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:53.336]                       if (muffled) 
[17:46:53.336]                         invokeRestart("muffleWarning")
[17:46:53.336]                     }
[17:46:53.336]                     else if (inherits(cond, "condition")) {
[17:46:53.336]                       if (!is.null(pattern)) {
[17:46:53.336]                         computeRestarts <- base::computeRestarts
[17:46:53.336]                         grepl <- base::grepl
[17:46:53.336]                         restarts <- computeRestarts(cond)
[17:46:53.336]                         for (restart in restarts) {
[17:46:53.336]                           name <- restart$name
[17:46:53.336]                           if (is.null(name)) 
[17:46:53.336]                             next
[17:46:53.336]                           if (!grepl(pattern, name)) 
[17:46:53.336]                             next
[17:46:53.336]                           invokeRestart(restart)
[17:46:53.336]                           muffled <- TRUE
[17:46:53.336]                           break
[17:46:53.336]                         }
[17:46:53.336]                       }
[17:46:53.336]                     }
[17:46:53.336]                     invisible(muffled)
[17:46:53.336]                   }
[17:46:53.336]                   muffleCondition(cond)
[17:46:53.336]                 })
[17:46:53.336]             }))
[17:46:53.336]             future::FutureResult(value = ...future.value$value, 
[17:46:53.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.336]                   ...future.rng), globalenv = if (FALSE) 
[17:46:53.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:53.336]                     ...future.globalenv.names))
[17:46:53.336]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:53.336]         }, condition = base::local({
[17:46:53.336]             c <- base::c
[17:46:53.336]             inherits <- base::inherits
[17:46:53.336]             invokeRestart <- base::invokeRestart
[17:46:53.336]             length <- base::length
[17:46:53.336]             list <- base::list
[17:46:53.336]             seq.int <- base::seq.int
[17:46:53.336]             signalCondition <- base::signalCondition
[17:46:53.336]             sys.calls <- base::sys.calls
[17:46:53.336]             `[[` <- base::`[[`
[17:46:53.336]             `+` <- base::`+`
[17:46:53.336]             `<<-` <- base::`<<-`
[17:46:53.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:53.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:53.336]                   3L)]
[17:46:53.336]             }
[17:46:53.336]             function(cond) {
[17:46:53.336]                 is_error <- inherits(cond, "error")
[17:46:53.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:53.336]                   NULL)
[17:46:53.336]                 if (is_error) {
[17:46:53.336]                   sessionInformation <- function() {
[17:46:53.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:53.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:53.336]                       search = base::search(), system = base::Sys.info())
[17:46:53.336]                   }
[17:46:53.336]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:53.336]                     cond$call), session = sessionInformation(), 
[17:46:53.336]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:53.336]                   signalCondition(cond)
[17:46:53.336]                 }
[17:46:53.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:53.336]                 "immediateCondition"))) {
[17:46:53.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:53.336]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:53.336]                   if (TRUE && !signal) {
[17:46:53.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.336]                     {
[17:46:53.336]                       inherits <- base::inherits
[17:46:53.336]                       invokeRestart <- base::invokeRestart
[17:46:53.336]                       is.null <- base::is.null
[17:46:53.336]                       muffled <- FALSE
[17:46:53.336]                       if (inherits(cond, "message")) {
[17:46:53.336]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.336]                         if (muffled) 
[17:46:53.336]                           invokeRestart("muffleMessage")
[17:46:53.336]                       }
[17:46:53.336]                       else if (inherits(cond, "warning")) {
[17:46:53.336]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.336]                         if (muffled) 
[17:46:53.336]                           invokeRestart("muffleWarning")
[17:46:53.336]                       }
[17:46:53.336]                       else if (inherits(cond, "condition")) {
[17:46:53.336]                         if (!is.null(pattern)) {
[17:46:53.336]                           computeRestarts <- base::computeRestarts
[17:46:53.336]                           grepl <- base::grepl
[17:46:53.336]                           restarts <- computeRestarts(cond)
[17:46:53.336]                           for (restart in restarts) {
[17:46:53.336]                             name <- restart$name
[17:46:53.336]                             if (is.null(name)) 
[17:46:53.336]                               next
[17:46:53.336]                             if (!grepl(pattern, name)) 
[17:46:53.336]                               next
[17:46:53.336]                             invokeRestart(restart)
[17:46:53.336]                             muffled <- TRUE
[17:46:53.336]                             break
[17:46:53.336]                           }
[17:46:53.336]                         }
[17:46:53.336]                       }
[17:46:53.336]                       invisible(muffled)
[17:46:53.336]                     }
[17:46:53.336]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.336]                   }
[17:46:53.336]                 }
[17:46:53.336]                 else {
[17:46:53.336]                   if (TRUE) {
[17:46:53.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.336]                     {
[17:46:53.336]                       inherits <- base::inherits
[17:46:53.336]                       invokeRestart <- base::invokeRestart
[17:46:53.336]                       is.null <- base::is.null
[17:46:53.336]                       muffled <- FALSE
[17:46:53.336]                       if (inherits(cond, "message")) {
[17:46:53.336]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.336]                         if (muffled) 
[17:46:53.336]                           invokeRestart("muffleMessage")
[17:46:53.336]                       }
[17:46:53.336]                       else if (inherits(cond, "warning")) {
[17:46:53.336]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.336]                         if (muffled) 
[17:46:53.336]                           invokeRestart("muffleWarning")
[17:46:53.336]                       }
[17:46:53.336]                       else if (inherits(cond, "condition")) {
[17:46:53.336]                         if (!is.null(pattern)) {
[17:46:53.336]                           computeRestarts <- base::computeRestarts
[17:46:53.336]                           grepl <- base::grepl
[17:46:53.336]                           restarts <- computeRestarts(cond)
[17:46:53.336]                           for (restart in restarts) {
[17:46:53.336]                             name <- restart$name
[17:46:53.336]                             if (is.null(name)) 
[17:46:53.336]                               next
[17:46:53.336]                             if (!grepl(pattern, name)) 
[17:46:53.336]                               next
[17:46:53.336]                             invokeRestart(restart)
[17:46:53.336]                             muffled <- TRUE
[17:46:53.336]                             break
[17:46:53.336]                           }
[17:46:53.336]                         }
[17:46:53.336]                       }
[17:46:53.336]                       invisible(muffled)
[17:46:53.336]                     }
[17:46:53.336]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.336]                   }
[17:46:53.336]                 }
[17:46:53.336]             }
[17:46:53.336]         }))
[17:46:53.336]     }, error = function(ex) {
[17:46:53.336]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:53.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.336]                 ...future.rng), started = ...future.startTime, 
[17:46:53.336]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:53.336]             version = "1.8"), class = "FutureResult")
[17:46:53.336]     }, finally = {
[17:46:53.336]         if (!identical(...future.workdir, getwd())) 
[17:46:53.336]             setwd(...future.workdir)
[17:46:53.336]         {
[17:46:53.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:53.336]                 ...future.oldOptions$nwarnings <- NULL
[17:46:53.336]             }
[17:46:53.336]             base::options(...future.oldOptions)
[17:46:53.336]             if (.Platform$OS.type == "windows") {
[17:46:53.336]                 old_names <- names(...future.oldEnvVars)
[17:46:53.336]                 envs <- base::Sys.getenv()
[17:46:53.336]                 names <- names(envs)
[17:46:53.336]                 common <- intersect(names, old_names)
[17:46:53.336]                 added <- setdiff(names, old_names)
[17:46:53.336]                 removed <- setdiff(old_names, names)
[17:46:53.336]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:53.336]                   envs[common]]
[17:46:53.336]                 NAMES <- toupper(changed)
[17:46:53.336]                 args <- list()
[17:46:53.336]                 for (kk in seq_along(NAMES)) {
[17:46:53.336]                   name <- changed[[kk]]
[17:46:53.336]                   NAME <- NAMES[[kk]]
[17:46:53.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.336]                     next
[17:46:53.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.336]                 }
[17:46:53.336]                 NAMES <- toupper(added)
[17:46:53.336]                 for (kk in seq_along(NAMES)) {
[17:46:53.336]                   name <- added[[kk]]
[17:46:53.336]                   NAME <- NAMES[[kk]]
[17:46:53.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.336]                     next
[17:46:53.336]                   args[[name]] <- ""
[17:46:53.336]                 }
[17:46:53.336]                 NAMES <- toupper(removed)
[17:46:53.336]                 for (kk in seq_along(NAMES)) {
[17:46:53.336]                   name <- removed[[kk]]
[17:46:53.336]                   NAME <- NAMES[[kk]]
[17:46:53.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.336]                     next
[17:46:53.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.336]                 }
[17:46:53.336]                 if (length(args) > 0) 
[17:46:53.336]                   base::do.call(base::Sys.setenv, args = args)
[17:46:53.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:53.336]             }
[17:46:53.336]             else {
[17:46:53.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:53.336]             }
[17:46:53.336]             {
[17:46:53.336]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:53.336]                   0L) {
[17:46:53.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:53.336]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:53.336]                   base::options(opts)
[17:46:53.336]                 }
[17:46:53.336]                 {
[17:46:53.336]                   {
[17:46:53.336]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:53.336]                     NULL
[17:46:53.336]                   }
[17:46:53.336]                   options(future.plan = NULL)
[17:46:53.336]                   if (is.na(NA_character_)) 
[17:46:53.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:53.336]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:53.336]                     .init = FALSE)
[17:46:53.336]                 }
[17:46:53.336]             }
[17:46:53.336]         }
[17:46:53.336]     })
[17:46:53.336]     if (TRUE) {
[17:46:53.336]         base::sink(type = "output", split = FALSE)
[17:46:53.336]         if (TRUE) {
[17:46:53.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:53.336]         }
[17:46:53.336]         else {
[17:46:53.336]             ...future.result["stdout"] <- base::list(NULL)
[17:46:53.336]         }
[17:46:53.336]         base::close(...future.stdout)
[17:46:53.336]         ...future.stdout <- NULL
[17:46:53.336]     }
[17:46:53.336]     ...future.result$conditions <- ...future.conditions
[17:46:53.336]     ...future.result$finished <- base::Sys.time()
[17:46:53.336]     ...future.result
[17:46:53.336] }
[17:46:53.339] MultisessionFuture started
[17:46:53.340] - Launch lazy future ... done
[17:46:53.340] run() for ‘MultisessionFuture’ ... done
[17:46:53.340] result() for ClusterFuture ...
[17:46:53.340] receiveMessageFromWorker() for ClusterFuture ...
[17:46:53.340] - Validating connection of MultisessionFuture
[17:46:53.382] - received message: FutureResult
[17:46:53.382] - Received FutureResult
[17:46:53.382] - Erased future from FutureRegistry
[17:46:53.382] result() for ClusterFuture ...
[17:46:53.382] - result already collected: FutureResult
[17:46:53.383] result() for ClusterFuture ... done
[17:46:53.383] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:53.383] result() for ClusterFuture ... done
[17:46:53.383] result() for ClusterFuture ...
[17:46:53.383] - result already collected: FutureResult
[17:46:53.383] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[17:46:53.388] getGlobalsAndPackages() ...
[17:46:53.388] Searching for globals...
[17:46:53.389] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[17:46:53.390] Searching for globals ... DONE
[17:46:53.390] Resolving globals: FALSE
[17:46:53.390] 
[17:46:53.390] - packages: [2] ‘stats’, ‘datasets’
[17:46:53.390] getGlobalsAndPackages() ... DONE
[17:46:53.391] run() for ‘Future’ ...
[17:46:53.391] - state: ‘created’
[17:46:53.391] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:53.405] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:53.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:53.405]   - Field: ‘node’
[17:46:53.405]   - Field: ‘label’
[17:46:53.405]   - Field: ‘local’
[17:46:53.405]   - Field: ‘owner’
[17:46:53.405]   - Field: ‘envir’
[17:46:53.405]   - Field: ‘workers’
[17:46:53.405]   - Field: ‘packages’
[17:46:53.406]   - Field: ‘gc’
[17:46:53.406]   - Field: ‘conditions’
[17:46:53.406]   - Field: ‘persistent’
[17:46:53.406]   - Field: ‘expr’
[17:46:53.406]   - Field: ‘uuid’
[17:46:53.406]   - Field: ‘seed’
[17:46:53.406]   - Field: ‘version’
[17:46:53.406]   - Field: ‘result’
[17:46:53.406]   - Field: ‘asynchronous’
[17:46:53.406]   - Field: ‘calls’
[17:46:53.406]   - Field: ‘globals’
[17:46:53.406]   - Field: ‘stdout’
[17:46:53.407]   - Field: ‘earlySignal’
[17:46:53.407]   - Field: ‘lazy’
[17:46:53.407]   - Field: ‘state’
[17:46:53.407] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:53.407] - Launch lazy future ...
[17:46:53.407] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:53.407] Packages needed by future strategies (n = 0): <none>
[17:46:53.408] {
[17:46:53.408]     {
[17:46:53.408]         {
[17:46:53.408]             ...future.startTime <- base::Sys.time()
[17:46:53.408]             {
[17:46:53.408]                 {
[17:46:53.408]                   {
[17:46:53.408]                     {
[17:46:53.408]                       {
[17:46:53.408]                         base::local({
[17:46:53.408]                           has_future <- base::requireNamespace("future", 
[17:46:53.408]                             quietly = TRUE)
[17:46:53.408]                           if (has_future) {
[17:46:53.408]                             ns <- base::getNamespace("future")
[17:46:53.408]                             version <- ns[[".package"]][["version"]]
[17:46:53.408]                             if (is.null(version)) 
[17:46:53.408]                               version <- utils::packageVersion("future")
[17:46:53.408]                           }
[17:46:53.408]                           else {
[17:46:53.408]                             version <- NULL
[17:46:53.408]                           }
[17:46:53.408]                           if (!has_future || version < "1.8.0") {
[17:46:53.408]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:53.408]                               "", base::R.version$version.string), 
[17:46:53.408]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:53.408]                                 base::R.version$platform, 8 * 
[17:46:53.408]                                   base::.Machine$sizeof.pointer), 
[17:46:53.408]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:53.408]                                 "release", "version")], collapse = " "), 
[17:46:53.408]                               hostname = base::Sys.info()[["nodename"]])
[17:46:53.408]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:53.408]                               info)
[17:46:53.408]                             info <- base::paste(info, collapse = "; ")
[17:46:53.408]                             if (!has_future) {
[17:46:53.408]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:53.408]                                 info)
[17:46:53.408]                             }
[17:46:53.408]                             else {
[17:46:53.408]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:53.408]                                 info, version)
[17:46:53.408]                             }
[17:46:53.408]                             base::stop(msg)
[17:46:53.408]                           }
[17:46:53.408]                         })
[17:46:53.408]                       }
[17:46:53.408]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:53.408]                       base::options(mc.cores = 1L)
[17:46:53.408]                     }
[17:46:53.408]                     base::local({
[17:46:53.408]                       for (pkg in c("stats", "datasets")) {
[17:46:53.408]                         base::loadNamespace(pkg)
[17:46:53.408]                         base::library(pkg, character.only = TRUE)
[17:46:53.408]                       }
[17:46:53.408]                     })
[17:46:53.408]                   }
[17:46:53.408]                   ...future.strategy.old <- future::plan("list")
[17:46:53.408]                   options(future.plan = NULL)
[17:46:53.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:53.408]                 }
[17:46:53.408]                 ...future.workdir <- getwd()
[17:46:53.408]             }
[17:46:53.408]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:53.408]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:53.408]         }
[17:46:53.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:53.408]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:53.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:53.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:53.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:53.408]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:53.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:53.408]             base::names(...future.oldOptions))
[17:46:53.408]     }
[17:46:53.408]     if (FALSE) {
[17:46:53.408]     }
[17:46:53.408]     else {
[17:46:53.408]         if (TRUE) {
[17:46:53.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:53.408]                 open = "w")
[17:46:53.408]         }
[17:46:53.408]         else {
[17:46:53.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:53.408]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:53.408]         }
[17:46:53.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:53.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:53.408]             base::sink(type = "output", split = FALSE)
[17:46:53.408]             base::close(...future.stdout)
[17:46:53.408]         }, add = TRUE)
[17:46:53.408]     }
[17:46:53.408]     ...future.frame <- base::sys.nframe()
[17:46:53.408]     ...future.conditions <- base::list()
[17:46:53.408]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:53.408]     if (FALSE) {
[17:46:53.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:53.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:53.408]     }
[17:46:53.408]     ...future.result <- base::tryCatch({
[17:46:53.408]         base::withCallingHandlers({
[17:46:53.408]             ...future.value <- base::withVisible(base::local({
[17:46:53.408]                 ...future.makeSendCondition <- base::local({
[17:46:53.408]                   sendCondition <- NULL
[17:46:53.408]                   function(frame = 1L) {
[17:46:53.408]                     if (is.function(sendCondition)) 
[17:46:53.408]                       return(sendCondition)
[17:46:53.408]                     ns <- getNamespace("parallel")
[17:46:53.408]                     if (exists("sendData", mode = "function", 
[17:46:53.408]                       envir = ns)) {
[17:46:53.408]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:53.408]                         envir = ns)
[17:46:53.408]                       envir <- sys.frame(frame)
[17:46:53.408]                       master <- NULL
[17:46:53.408]                       while (!identical(envir, .GlobalEnv) && 
[17:46:53.408]                         !identical(envir, emptyenv())) {
[17:46:53.408]                         if (exists("master", mode = "list", envir = envir, 
[17:46:53.408]                           inherits = FALSE)) {
[17:46:53.408]                           master <- get("master", mode = "list", 
[17:46:53.408]                             envir = envir, inherits = FALSE)
[17:46:53.408]                           if (inherits(master, c("SOCKnode", 
[17:46:53.408]                             "SOCK0node"))) {
[17:46:53.408]                             sendCondition <<- function(cond) {
[17:46:53.408]                               data <- list(type = "VALUE", value = cond, 
[17:46:53.408]                                 success = TRUE)
[17:46:53.408]                               parallel_sendData(master, data)
[17:46:53.408]                             }
[17:46:53.408]                             return(sendCondition)
[17:46:53.408]                           }
[17:46:53.408]                         }
[17:46:53.408]                         frame <- frame + 1L
[17:46:53.408]                         envir <- sys.frame(frame)
[17:46:53.408]                       }
[17:46:53.408]                     }
[17:46:53.408]                     sendCondition <<- function(cond) NULL
[17:46:53.408]                   }
[17:46:53.408]                 })
[17:46:53.408]                 withCallingHandlers({
[17:46:53.408]                   {
[17:46:53.408]                     lm(dist ~ . + 0, data = cars)
[17:46:53.408]                   }
[17:46:53.408]                 }, immediateCondition = function(cond) {
[17:46:53.408]                   sendCondition <- ...future.makeSendCondition()
[17:46:53.408]                   sendCondition(cond)
[17:46:53.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.408]                   {
[17:46:53.408]                     inherits <- base::inherits
[17:46:53.408]                     invokeRestart <- base::invokeRestart
[17:46:53.408]                     is.null <- base::is.null
[17:46:53.408]                     muffled <- FALSE
[17:46:53.408]                     if (inherits(cond, "message")) {
[17:46:53.408]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:53.408]                       if (muffled) 
[17:46:53.408]                         invokeRestart("muffleMessage")
[17:46:53.408]                     }
[17:46:53.408]                     else if (inherits(cond, "warning")) {
[17:46:53.408]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:53.408]                       if (muffled) 
[17:46:53.408]                         invokeRestart("muffleWarning")
[17:46:53.408]                     }
[17:46:53.408]                     else if (inherits(cond, "condition")) {
[17:46:53.408]                       if (!is.null(pattern)) {
[17:46:53.408]                         computeRestarts <- base::computeRestarts
[17:46:53.408]                         grepl <- base::grepl
[17:46:53.408]                         restarts <- computeRestarts(cond)
[17:46:53.408]                         for (restart in restarts) {
[17:46:53.408]                           name <- restart$name
[17:46:53.408]                           if (is.null(name)) 
[17:46:53.408]                             next
[17:46:53.408]                           if (!grepl(pattern, name)) 
[17:46:53.408]                             next
[17:46:53.408]                           invokeRestart(restart)
[17:46:53.408]                           muffled <- TRUE
[17:46:53.408]                           break
[17:46:53.408]                         }
[17:46:53.408]                       }
[17:46:53.408]                     }
[17:46:53.408]                     invisible(muffled)
[17:46:53.408]                   }
[17:46:53.408]                   muffleCondition(cond)
[17:46:53.408]                 })
[17:46:53.408]             }))
[17:46:53.408]             future::FutureResult(value = ...future.value$value, 
[17:46:53.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.408]                   ...future.rng), globalenv = if (FALSE) 
[17:46:53.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:53.408]                     ...future.globalenv.names))
[17:46:53.408]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:53.408]         }, condition = base::local({
[17:46:53.408]             c <- base::c
[17:46:53.408]             inherits <- base::inherits
[17:46:53.408]             invokeRestart <- base::invokeRestart
[17:46:53.408]             length <- base::length
[17:46:53.408]             list <- base::list
[17:46:53.408]             seq.int <- base::seq.int
[17:46:53.408]             signalCondition <- base::signalCondition
[17:46:53.408]             sys.calls <- base::sys.calls
[17:46:53.408]             `[[` <- base::`[[`
[17:46:53.408]             `+` <- base::`+`
[17:46:53.408]             `<<-` <- base::`<<-`
[17:46:53.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:53.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:53.408]                   3L)]
[17:46:53.408]             }
[17:46:53.408]             function(cond) {
[17:46:53.408]                 is_error <- inherits(cond, "error")
[17:46:53.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:53.408]                   NULL)
[17:46:53.408]                 if (is_error) {
[17:46:53.408]                   sessionInformation <- function() {
[17:46:53.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:53.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:53.408]                       search = base::search(), system = base::Sys.info())
[17:46:53.408]                   }
[17:46:53.408]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:53.408]                     cond$call), session = sessionInformation(), 
[17:46:53.408]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:53.408]                   signalCondition(cond)
[17:46:53.408]                 }
[17:46:53.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:53.408]                 "immediateCondition"))) {
[17:46:53.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:53.408]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:53.408]                   if (TRUE && !signal) {
[17:46:53.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.408]                     {
[17:46:53.408]                       inherits <- base::inherits
[17:46:53.408]                       invokeRestart <- base::invokeRestart
[17:46:53.408]                       is.null <- base::is.null
[17:46:53.408]                       muffled <- FALSE
[17:46:53.408]                       if (inherits(cond, "message")) {
[17:46:53.408]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.408]                         if (muffled) 
[17:46:53.408]                           invokeRestart("muffleMessage")
[17:46:53.408]                       }
[17:46:53.408]                       else if (inherits(cond, "warning")) {
[17:46:53.408]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.408]                         if (muffled) 
[17:46:53.408]                           invokeRestart("muffleWarning")
[17:46:53.408]                       }
[17:46:53.408]                       else if (inherits(cond, "condition")) {
[17:46:53.408]                         if (!is.null(pattern)) {
[17:46:53.408]                           computeRestarts <- base::computeRestarts
[17:46:53.408]                           grepl <- base::grepl
[17:46:53.408]                           restarts <- computeRestarts(cond)
[17:46:53.408]                           for (restart in restarts) {
[17:46:53.408]                             name <- restart$name
[17:46:53.408]                             if (is.null(name)) 
[17:46:53.408]                               next
[17:46:53.408]                             if (!grepl(pattern, name)) 
[17:46:53.408]                               next
[17:46:53.408]                             invokeRestart(restart)
[17:46:53.408]                             muffled <- TRUE
[17:46:53.408]                             break
[17:46:53.408]                           }
[17:46:53.408]                         }
[17:46:53.408]                       }
[17:46:53.408]                       invisible(muffled)
[17:46:53.408]                     }
[17:46:53.408]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.408]                   }
[17:46:53.408]                 }
[17:46:53.408]                 else {
[17:46:53.408]                   if (TRUE) {
[17:46:53.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.408]                     {
[17:46:53.408]                       inherits <- base::inherits
[17:46:53.408]                       invokeRestart <- base::invokeRestart
[17:46:53.408]                       is.null <- base::is.null
[17:46:53.408]                       muffled <- FALSE
[17:46:53.408]                       if (inherits(cond, "message")) {
[17:46:53.408]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.408]                         if (muffled) 
[17:46:53.408]                           invokeRestart("muffleMessage")
[17:46:53.408]                       }
[17:46:53.408]                       else if (inherits(cond, "warning")) {
[17:46:53.408]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.408]                         if (muffled) 
[17:46:53.408]                           invokeRestart("muffleWarning")
[17:46:53.408]                       }
[17:46:53.408]                       else if (inherits(cond, "condition")) {
[17:46:53.408]                         if (!is.null(pattern)) {
[17:46:53.408]                           computeRestarts <- base::computeRestarts
[17:46:53.408]                           grepl <- base::grepl
[17:46:53.408]                           restarts <- computeRestarts(cond)
[17:46:53.408]                           for (restart in restarts) {
[17:46:53.408]                             name <- restart$name
[17:46:53.408]                             if (is.null(name)) 
[17:46:53.408]                               next
[17:46:53.408]                             if (!grepl(pattern, name)) 
[17:46:53.408]                               next
[17:46:53.408]                             invokeRestart(restart)
[17:46:53.408]                             muffled <- TRUE
[17:46:53.408]                             break
[17:46:53.408]                           }
[17:46:53.408]                         }
[17:46:53.408]                       }
[17:46:53.408]                       invisible(muffled)
[17:46:53.408]                     }
[17:46:53.408]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.408]                   }
[17:46:53.408]                 }
[17:46:53.408]             }
[17:46:53.408]         }))
[17:46:53.408]     }, error = function(ex) {
[17:46:53.408]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:53.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.408]                 ...future.rng), started = ...future.startTime, 
[17:46:53.408]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:53.408]             version = "1.8"), class = "FutureResult")
[17:46:53.408]     }, finally = {
[17:46:53.408]         if (!identical(...future.workdir, getwd())) 
[17:46:53.408]             setwd(...future.workdir)
[17:46:53.408]         {
[17:46:53.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:53.408]                 ...future.oldOptions$nwarnings <- NULL
[17:46:53.408]             }
[17:46:53.408]             base::options(...future.oldOptions)
[17:46:53.408]             if (.Platform$OS.type == "windows") {
[17:46:53.408]                 old_names <- names(...future.oldEnvVars)
[17:46:53.408]                 envs <- base::Sys.getenv()
[17:46:53.408]                 names <- names(envs)
[17:46:53.408]                 common <- intersect(names, old_names)
[17:46:53.408]                 added <- setdiff(names, old_names)
[17:46:53.408]                 removed <- setdiff(old_names, names)
[17:46:53.408]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:53.408]                   envs[common]]
[17:46:53.408]                 NAMES <- toupper(changed)
[17:46:53.408]                 args <- list()
[17:46:53.408]                 for (kk in seq_along(NAMES)) {
[17:46:53.408]                   name <- changed[[kk]]
[17:46:53.408]                   NAME <- NAMES[[kk]]
[17:46:53.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.408]                     next
[17:46:53.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.408]                 }
[17:46:53.408]                 NAMES <- toupper(added)
[17:46:53.408]                 for (kk in seq_along(NAMES)) {
[17:46:53.408]                   name <- added[[kk]]
[17:46:53.408]                   NAME <- NAMES[[kk]]
[17:46:53.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.408]                     next
[17:46:53.408]                   args[[name]] <- ""
[17:46:53.408]                 }
[17:46:53.408]                 NAMES <- toupper(removed)
[17:46:53.408]                 for (kk in seq_along(NAMES)) {
[17:46:53.408]                   name <- removed[[kk]]
[17:46:53.408]                   NAME <- NAMES[[kk]]
[17:46:53.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.408]                     next
[17:46:53.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.408]                 }
[17:46:53.408]                 if (length(args) > 0) 
[17:46:53.408]                   base::do.call(base::Sys.setenv, args = args)
[17:46:53.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:53.408]             }
[17:46:53.408]             else {
[17:46:53.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:53.408]             }
[17:46:53.408]             {
[17:46:53.408]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:53.408]                   0L) {
[17:46:53.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:53.408]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:53.408]                   base::options(opts)
[17:46:53.408]                 }
[17:46:53.408]                 {
[17:46:53.408]                   {
[17:46:53.408]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:53.408]                     NULL
[17:46:53.408]                   }
[17:46:53.408]                   options(future.plan = NULL)
[17:46:53.408]                   if (is.na(NA_character_)) 
[17:46:53.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:53.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:53.408]                     .init = FALSE)
[17:46:53.408]                 }
[17:46:53.408]             }
[17:46:53.408]         }
[17:46:53.408]     })
[17:46:53.408]     if (TRUE) {
[17:46:53.408]         base::sink(type = "output", split = FALSE)
[17:46:53.408]         if (TRUE) {
[17:46:53.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:53.408]         }
[17:46:53.408]         else {
[17:46:53.408]             ...future.result["stdout"] <- base::list(NULL)
[17:46:53.408]         }
[17:46:53.408]         base::close(...future.stdout)
[17:46:53.408]         ...future.stdout <- NULL
[17:46:53.408]     }
[17:46:53.408]     ...future.result$conditions <- ...future.conditions
[17:46:53.408]     ...future.result$finished <- base::Sys.time()
[17:46:53.408]     ...future.result
[17:46:53.408] }
[17:46:53.411] MultisessionFuture started
[17:46:53.411] - Launch lazy future ... done
[17:46:53.411] run() for ‘MultisessionFuture’ ... done
[17:46:53.411] result() for ClusterFuture ...
[17:46:53.411] receiveMessageFromWorker() for ClusterFuture ...
[17:46:53.411] - Validating connection of MultisessionFuture
[17:46:53.454] - received message: FutureResult
[17:46:53.454] - Received FutureResult
[17:46:53.454] - Erased future from FutureRegistry
[17:46:53.454] result() for ClusterFuture ...
[17:46:53.454] - result already collected: FutureResult
[17:46:53.454] result() for ClusterFuture ... done
[17:46:53.455] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:53.455] result() for ClusterFuture ... done
[17:46:53.455] result() for ClusterFuture ...
[17:46:53.455] - result already collected: FutureResult
[17:46:53.455] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[17:46:53.457] getGlobalsAndPackages() ...
[17:46:53.457] Searching for globals...
[17:46:53.459] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[17:46:53.459] Searching for globals ... DONE
[17:46:53.459] Resolving globals: FALSE
[17:46:53.460] 
[17:46:53.460] - packages: [2] ‘stats’, ‘datasets’
[17:46:53.460] getGlobalsAndPackages() ... DONE
[17:46:53.460] run() for ‘Future’ ...
[17:46:53.460] - state: ‘created’
[17:46:53.460] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:53.474] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:53.474] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:53.475]   - Field: ‘node’
[17:46:53.475]   - Field: ‘label’
[17:46:53.475]   - Field: ‘local’
[17:46:53.475]   - Field: ‘owner’
[17:46:53.475]   - Field: ‘envir’
[17:46:53.475]   - Field: ‘workers’
[17:46:53.475]   - Field: ‘packages’
[17:46:53.475]   - Field: ‘gc’
[17:46:53.475]   - Field: ‘conditions’
[17:46:53.475]   - Field: ‘persistent’
[17:46:53.475]   - Field: ‘expr’
[17:46:53.476]   - Field: ‘uuid’
[17:46:53.476]   - Field: ‘seed’
[17:46:53.476]   - Field: ‘version’
[17:46:53.476]   - Field: ‘result’
[17:46:53.476]   - Field: ‘asynchronous’
[17:46:53.476]   - Field: ‘calls’
[17:46:53.476]   - Field: ‘globals’
[17:46:53.476]   - Field: ‘stdout’
[17:46:53.476]   - Field: ‘earlySignal’
[17:46:53.476]   - Field: ‘lazy’
[17:46:53.476]   - Field: ‘state’
[17:46:53.477] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:53.477] - Launch lazy future ...
[17:46:53.477] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:53.477] Packages needed by future strategies (n = 0): <none>
[17:46:53.478] {
[17:46:53.478]     {
[17:46:53.478]         {
[17:46:53.478]             ...future.startTime <- base::Sys.time()
[17:46:53.478]             {
[17:46:53.478]                 {
[17:46:53.478]                   {
[17:46:53.478]                     {
[17:46:53.478]                       {
[17:46:53.478]                         base::local({
[17:46:53.478]                           has_future <- base::requireNamespace("future", 
[17:46:53.478]                             quietly = TRUE)
[17:46:53.478]                           if (has_future) {
[17:46:53.478]                             ns <- base::getNamespace("future")
[17:46:53.478]                             version <- ns[[".package"]][["version"]]
[17:46:53.478]                             if (is.null(version)) 
[17:46:53.478]                               version <- utils::packageVersion("future")
[17:46:53.478]                           }
[17:46:53.478]                           else {
[17:46:53.478]                             version <- NULL
[17:46:53.478]                           }
[17:46:53.478]                           if (!has_future || version < "1.8.0") {
[17:46:53.478]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:53.478]                               "", base::R.version$version.string), 
[17:46:53.478]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:53.478]                                 base::R.version$platform, 8 * 
[17:46:53.478]                                   base::.Machine$sizeof.pointer), 
[17:46:53.478]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:53.478]                                 "release", "version")], collapse = " "), 
[17:46:53.478]                               hostname = base::Sys.info()[["nodename"]])
[17:46:53.478]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:53.478]                               info)
[17:46:53.478]                             info <- base::paste(info, collapse = "; ")
[17:46:53.478]                             if (!has_future) {
[17:46:53.478]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:53.478]                                 info)
[17:46:53.478]                             }
[17:46:53.478]                             else {
[17:46:53.478]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:53.478]                                 info, version)
[17:46:53.478]                             }
[17:46:53.478]                             base::stop(msg)
[17:46:53.478]                           }
[17:46:53.478]                         })
[17:46:53.478]                       }
[17:46:53.478]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:53.478]                       base::options(mc.cores = 1L)
[17:46:53.478]                     }
[17:46:53.478]                     base::local({
[17:46:53.478]                       for (pkg in c("stats", "datasets")) {
[17:46:53.478]                         base::loadNamespace(pkg)
[17:46:53.478]                         base::library(pkg, character.only = TRUE)
[17:46:53.478]                       }
[17:46:53.478]                     })
[17:46:53.478]                   }
[17:46:53.478]                   ...future.strategy.old <- future::plan("list")
[17:46:53.478]                   options(future.plan = NULL)
[17:46:53.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:53.478]                 }
[17:46:53.478]                 ...future.workdir <- getwd()
[17:46:53.478]             }
[17:46:53.478]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:53.478]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:53.478]         }
[17:46:53.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:53.478]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:53.478]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:53.478]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:53.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:53.478]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:53.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:53.478]             base::names(...future.oldOptions))
[17:46:53.478]     }
[17:46:53.478]     if (FALSE) {
[17:46:53.478]     }
[17:46:53.478]     else {
[17:46:53.478]         if (TRUE) {
[17:46:53.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:53.478]                 open = "w")
[17:46:53.478]         }
[17:46:53.478]         else {
[17:46:53.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:53.478]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:53.478]         }
[17:46:53.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:53.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:53.478]             base::sink(type = "output", split = FALSE)
[17:46:53.478]             base::close(...future.stdout)
[17:46:53.478]         }, add = TRUE)
[17:46:53.478]     }
[17:46:53.478]     ...future.frame <- base::sys.nframe()
[17:46:53.478]     ...future.conditions <- base::list()
[17:46:53.478]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:53.478]     if (FALSE) {
[17:46:53.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:53.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:53.478]     }
[17:46:53.478]     ...future.result <- base::tryCatch({
[17:46:53.478]         base::withCallingHandlers({
[17:46:53.478]             ...future.value <- base::withVisible(base::local({
[17:46:53.478]                 ...future.makeSendCondition <- base::local({
[17:46:53.478]                   sendCondition <- NULL
[17:46:53.478]                   function(frame = 1L) {
[17:46:53.478]                     if (is.function(sendCondition)) 
[17:46:53.478]                       return(sendCondition)
[17:46:53.478]                     ns <- getNamespace("parallel")
[17:46:53.478]                     if (exists("sendData", mode = "function", 
[17:46:53.478]                       envir = ns)) {
[17:46:53.478]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:53.478]                         envir = ns)
[17:46:53.478]                       envir <- sys.frame(frame)
[17:46:53.478]                       master <- NULL
[17:46:53.478]                       while (!identical(envir, .GlobalEnv) && 
[17:46:53.478]                         !identical(envir, emptyenv())) {
[17:46:53.478]                         if (exists("master", mode = "list", envir = envir, 
[17:46:53.478]                           inherits = FALSE)) {
[17:46:53.478]                           master <- get("master", mode = "list", 
[17:46:53.478]                             envir = envir, inherits = FALSE)
[17:46:53.478]                           if (inherits(master, c("SOCKnode", 
[17:46:53.478]                             "SOCK0node"))) {
[17:46:53.478]                             sendCondition <<- function(cond) {
[17:46:53.478]                               data <- list(type = "VALUE", value = cond, 
[17:46:53.478]                                 success = TRUE)
[17:46:53.478]                               parallel_sendData(master, data)
[17:46:53.478]                             }
[17:46:53.478]                             return(sendCondition)
[17:46:53.478]                           }
[17:46:53.478]                         }
[17:46:53.478]                         frame <- frame + 1L
[17:46:53.478]                         envir <- sys.frame(frame)
[17:46:53.478]                       }
[17:46:53.478]                     }
[17:46:53.478]                     sendCondition <<- function(cond) NULL
[17:46:53.478]                   }
[17:46:53.478]                 })
[17:46:53.478]                 withCallingHandlers({
[17:46:53.478]                   {
[17:46:53.478]                     lm(dist ~ speed + speed^2, data = cars)
[17:46:53.478]                   }
[17:46:53.478]                 }, immediateCondition = function(cond) {
[17:46:53.478]                   sendCondition <- ...future.makeSendCondition()
[17:46:53.478]                   sendCondition(cond)
[17:46:53.478]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.478]                   {
[17:46:53.478]                     inherits <- base::inherits
[17:46:53.478]                     invokeRestart <- base::invokeRestart
[17:46:53.478]                     is.null <- base::is.null
[17:46:53.478]                     muffled <- FALSE
[17:46:53.478]                     if (inherits(cond, "message")) {
[17:46:53.478]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:53.478]                       if (muffled) 
[17:46:53.478]                         invokeRestart("muffleMessage")
[17:46:53.478]                     }
[17:46:53.478]                     else if (inherits(cond, "warning")) {
[17:46:53.478]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:53.478]                       if (muffled) 
[17:46:53.478]                         invokeRestart("muffleWarning")
[17:46:53.478]                     }
[17:46:53.478]                     else if (inherits(cond, "condition")) {
[17:46:53.478]                       if (!is.null(pattern)) {
[17:46:53.478]                         computeRestarts <- base::computeRestarts
[17:46:53.478]                         grepl <- base::grepl
[17:46:53.478]                         restarts <- computeRestarts(cond)
[17:46:53.478]                         for (restart in restarts) {
[17:46:53.478]                           name <- restart$name
[17:46:53.478]                           if (is.null(name)) 
[17:46:53.478]                             next
[17:46:53.478]                           if (!grepl(pattern, name)) 
[17:46:53.478]                             next
[17:46:53.478]                           invokeRestart(restart)
[17:46:53.478]                           muffled <- TRUE
[17:46:53.478]                           break
[17:46:53.478]                         }
[17:46:53.478]                       }
[17:46:53.478]                     }
[17:46:53.478]                     invisible(muffled)
[17:46:53.478]                   }
[17:46:53.478]                   muffleCondition(cond)
[17:46:53.478]                 })
[17:46:53.478]             }))
[17:46:53.478]             future::FutureResult(value = ...future.value$value, 
[17:46:53.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.478]                   ...future.rng), globalenv = if (FALSE) 
[17:46:53.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:53.478]                     ...future.globalenv.names))
[17:46:53.478]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:53.478]         }, condition = base::local({
[17:46:53.478]             c <- base::c
[17:46:53.478]             inherits <- base::inherits
[17:46:53.478]             invokeRestart <- base::invokeRestart
[17:46:53.478]             length <- base::length
[17:46:53.478]             list <- base::list
[17:46:53.478]             seq.int <- base::seq.int
[17:46:53.478]             signalCondition <- base::signalCondition
[17:46:53.478]             sys.calls <- base::sys.calls
[17:46:53.478]             `[[` <- base::`[[`
[17:46:53.478]             `+` <- base::`+`
[17:46:53.478]             `<<-` <- base::`<<-`
[17:46:53.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:53.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:53.478]                   3L)]
[17:46:53.478]             }
[17:46:53.478]             function(cond) {
[17:46:53.478]                 is_error <- inherits(cond, "error")
[17:46:53.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:53.478]                   NULL)
[17:46:53.478]                 if (is_error) {
[17:46:53.478]                   sessionInformation <- function() {
[17:46:53.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:53.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:53.478]                       search = base::search(), system = base::Sys.info())
[17:46:53.478]                   }
[17:46:53.478]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:53.478]                     cond$call), session = sessionInformation(), 
[17:46:53.478]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:53.478]                   signalCondition(cond)
[17:46:53.478]                 }
[17:46:53.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:53.478]                 "immediateCondition"))) {
[17:46:53.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:53.478]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:53.478]                   if (TRUE && !signal) {
[17:46:53.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.478]                     {
[17:46:53.478]                       inherits <- base::inherits
[17:46:53.478]                       invokeRestart <- base::invokeRestart
[17:46:53.478]                       is.null <- base::is.null
[17:46:53.478]                       muffled <- FALSE
[17:46:53.478]                       if (inherits(cond, "message")) {
[17:46:53.478]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.478]                         if (muffled) 
[17:46:53.478]                           invokeRestart("muffleMessage")
[17:46:53.478]                       }
[17:46:53.478]                       else if (inherits(cond, "warning")) {
[17:46:53.478]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.478]                         if (muffled) 
[17:46:53.478]                           invokeRestart("muffleWarning")
[17:46:53.478]                       }
[17:46:53.478]                       else if (inherits(cond, "condition")) {
[17:46:53.478]                         if (!is.null(pattern)) {
[17:46:53.478]                           computeRestarts <- base::computeRestarts
[17:46:53.478]                           grepl <- base::grepl
[17:46:53.478]                           restarts <- computeRestarts(cond)
[17:46:53.478]                           for (restart in restarts) {
[17:46:53.478]                             name <- restart$name
[17:46:53.478]                             if (is.null(name)) 
[17:46:53.478]                               next
[17:46:53.478]                             if (!grepl(pattern, name)) 
[17:46:53.478]                               next
[17:46:53.478]                             invokeRestart(restart)
[17:46:53.478]                             muffled <- TRUE
[17:46:53.478]                             break
[17:46:53.478]                           }
[17:46:53.478]                         }
[17:46:53.478]                       }
[17:46:53.478]                       invisible(muffled)
[17:46:53.478]                     }
[17:46:53.478]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.478]                   }
[17:46:53.478]                 }
[17:46:53.478]                 else {
[17:46:53.478]                   if (TRUE) {
[17:46:53.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.478]                     {
[17:46:53.478]                       inherits <- base::inherits
[17:46:53.478]                       invokeRestart <- base::invokeRestart
[17:46:53.478]                       is.null <- base::is.null
[17:46:53.478]                       muffled <- FALSE
[17:46:53.478]                       if (inherits(cond, "message")) {
[17:46:53.478]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.478]                         if (muffled) 
[17:46:53.478]                           invokeRestart("muffleMessage")
[17:46:53.478]                       }
[17:46:53.478]                       else if (inherits(cond, "warning")) {
[17:46:53.478]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.478]                         if (muffled) 
[17:46:53.478]                           invokeRestart("muffleWarning")
[17:46:53.478]                       }
[17:46:53.478]                       else if (inherits(cond, "condition")) {
[17:46:53.478]                         if (!is.null(pattern)) {
[17:46:53.478]                           computeRestarts <- base::computeRestarts
[17:46:53.478]                           grepl <- base::grepl
[17:46:53.478]                           restarts <- computeRestarts(cond)
[17:46:53.478]                           for (restart in restarts) {
[17:46:53.478]                             name <- restart$name
[17:46:53.478]                             if (is.null(name)) 
[17:46:53.478]                               next
[17:46:53.478]                             if (!grepl(pattern, name)) 
[17:46:53.478]                               next
[17:46:53.478]                             invokeRestart(restart)
[17:46:53.478]                             muffled <- TRUE
[17:46:53.478]                             break
[17:46:53.478]                           }
[17:46:53.478]                         }
[17:46:53.478]                       }
[17:46:53.478]                       invisible(muffled)
[17:46:53.478]                     }
[17:46:53.478]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.478]                   }
[17:46:53.478]                 }
[17:46:53.478]             }
[17:46:53.478]         }))
[17:46:53.478]     }, error = function(ex) {
[17:46:53.478]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:53.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.478]                 ...future.rng), started = ...future.startTime, 
[17:46:53.478]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:53.478]             version = "1.8"), class = "FutureResult")
[17:46:53.478]     }, finally = {
[17:46:53.478]         if (!identical(...future.workdir, getwd())) 
[17:46:53.478]             setwd(...future.workdir)
[17:46:53.478]         {
[17:46:53.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:53.478]                 ...future.oldOptions$nwarnings <- NULL
[17:46:53.478]             }
[17:46:53.478]             base::options(...future.oldOptions)
[17:46:53.478]             if (.Platform$OS.type == "windows") {
[17:46:53.478]                 old_names <- names(...future.oldEnvVars)
[17:46:53.478]                 envs <- base::Sys.getenv()
[17:46:53.478]                 names <- names(envs)
[17:46:53.478]                 common <- intersect(names, old_names)
[17:46:53.478]                 added <- setdiff(names, old_names)
[17:46:53.478]                 removed <- setdiff(old_names, names)
[17:46:53.478]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:53.478]                   envs[common]]
[17:46:53.478]                 NAMES <- toupper(changed)
[17:46:53.478]                 args <- list()
[17:46:53.478]                 for (kk in seq_along(NAMES)) {
[17:46:53.478]                   name <- changed[[kk]]
[17:46:53.478]                   NAME <- NAMES[[kk]]
[17:46:53.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.478]                     next
[17:46:53.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.478]                 }
[17:46:53.478]                 NAMES <- toupper(added)
[17:46:53.478]                 for (kk in seq_along(NAMES)) {
[17:46:53.478]                   name <- added[[kk]]
[17:46:53.478]                   NAME <- NAMES[[kk]]
[17:46:53.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.478]                     next
[17:46:53.478]                   args[[name]] <- ""
[17:46:53.478]                 }
[17:46:53.478]                 NAMES <- toupper(removed)
[17:46:53.478]                 for (kk in seq_along(NAMES)) {
[17:46:53.478]                   name <- removed[[kk]]
[17:46:53.478]                   NAME <- NAMES[[kk]]
[17:46:53.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.478]                     next
[17:46:53.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.478]                 }
[17:46:53.478]                 if (length(args) > 0) 
[17:46:53.478]                   base::do.call(base::Sys.setenv, args = args)
[17:46:53.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:53.478]             }
[17:46:53.478]             else {
[17:46:53.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:53.478]             }
[17:46:53.478]             {
[17:46:53.478]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:53.478]                   0L) {
[17:46:53.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:53.478]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:53.478]                   base::options(opts)
[17:46:53.478]                 }
[17:46:53.478]                 {
[17:46:53.478]                   {
[17:46:53.478]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:53.478]                     NULL
[17:46:53.478]                   }
[17:46:53.478]                   options(future.plan = NULL)
[17:46:53.478]                   if (is.na(NA_character_)) 
[17:46:53.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:53.478]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:53.478]                     .init = FALSE)
[17:46:53.478]                 }
[17:46:53.478]             }
[17:46:53.478]         }
[17:46:53.478]     })
[17:46:53.478]     if (TRUE) {
[17:46:53.478]         base::sink(type = "output", split = FALSE)
[17:46:53.478]         if (TRUE) {
[17:46:53.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:53.478]         }
[17:46:53.478]         else {
[17:46:53.478]             ...future.result["stdout"] <- base::list(NULL)
[17:46:53.478]         }
[17:46:53.478]         base::close(...future.stdout)
[17:46:53.478]         ...future.stdout <- NULL
[17:46:53.478]     }
[17:46:53.478]     ...future.result$conditions <- ...future.conditions
[17:46:53.478]     ...future.result$finished <- base::Sys.time()
[17:46:53.478]     ...future.result
[17:46:53.478] }
[17:46:53.480] MultisessionFuture started
[17:46:53.481] - Launch lazy future ... done
[17:46:53.481] run() for ‘MultisessionFuture’ ... done
[17:46:53.481] result() for ClusterFuture ...
[17:46:53.481] receiveMessageFromWorker() for ClusterFuture ...
[17:46:53.481] - Validating connection of MultisessionFuture
[17:46:53.526] - received message: FutureResult
[17:46:53.526] - Received FutureResult
[17:46:53.526] - Erased future from FutureRegistry
[17:46:53.526] result() for ClusterFuture ...
[17:46:53.526] - result already collected: FutureResult
[17:46:53.526] result() for ClusterFuture ... done
[17:46:53.526] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:53.526] result() for ClusterFuture ... done
[17:46:53.527] result() for ClusterFuture ...
[17:46:53.527] - result already collected: FutureResult
[17:46:53.527] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[17:46:53.529] getGlobalsAndPackages() ...
[17:46:53.529] Searching for globals...
[17:46:53.531] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[17:46:53.531] Searching for globals ... DONE
[17:46:53.531] Resolving globals: FALSE
[17:46:53.532] 
[17:46:53.532] - packages: [2] ‘stats’, ‘datasets’
[17:46:53.532] getGlobalsAndPackages() ... DONE
[17:46:53.532] run() for ‘Future’ ...
[17:46:53.532] - state: ‘created’
[17:46:53.532] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:53.546] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:53.546] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:53.546]   - Field: ‘node’
[17:46:53.546]   - Field: ‘label’
[17:46:53.546]   - Field: ‘local’
[17:46:53.547]   - Field: ‘owner’
[17:46:53.547]   - Field: ‘envir’
[17:46:53.547]   - Field: ‘workers’
[17:46:53.547]   - Field: ‘packages’
[17:46:53.547]   - Field: ‘gc’
[17:46:53.547]   - Field: ‘conditions’
[17:46:53.547]   - Field: ‘persistent’
[17:46:53.547]   - Field: ‘expr’
[17:46:53.547]   - Field: ‘uuid’
[17:46:53.547]   - Field: ‘seed’
[17:46:53.547]   - Field: ‘version’
[17:46:53.548]   - Field: ‘result’
[17:46:53.548]   - Field: ‘asynchronous’
[17:46:53.548]   - Field: ‘calls’
[17:46:53.548]   - Field: ‘globals’
[17:46:53.548]   - Field: ‘stdout’
[17:46:53.548]   - Field: ‘earlySignal’
[17:46:53.548]   - Field: ‘lazy’
[17:46:53.548]   - Field: ‘state’
[17:46:53.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:53.548] - Launch lazy future ...
[17:46:53.549] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:53.549] Packages needed by future strategies (n = 0): <none>
[17:46:53.549] {
[17:46:53.549]     {
[17:46:53.549]         {
[17:46:53.549]             ...future.startTime <- base::Sys.time()
[17:46:53.549]             {
[17:46:53.549]                 {
[17:46:53.549]                   {
[17:46:53.549]                     {
[17:46:53.549]                       {
[17:46:53.549]                         base::local({
[17:46:53.549]                           has_future <- base::requireNamespace("future", 
[17:46:53.549]                             quietly = TRUE)
[17:46:53.549]                           if (has_future) {
[17:46:53.549]                             ns <- base::getNamespace("future")
[17:46:53.549]                             version <- ns[[".package"]][["version"]]
[17:46:53.549]                             if (is.null(version)) 
[17:46:53.549]                               version <- utils::packageVersion("future")
[17:46:53.549]                           }
[17:46:53.549]                           else {
[17:46:53.549]                             version <- NULL
[17:46:53.549]                           }
[17:46:53.549]                           if (!has_future || version < "1.8.0") {
[17:46:53.549]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:53.549]                               "", base::R.version$version.string), 
[17:46:53.549]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:53.549]                                 base::R.version$platform, 8 * 
[17:46:53.549]                                   base::.Machine$sizeof.pointer), 
[17:46:53.549]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:53.549]                                 "release", "version")], collapse = " "), 
[17:46:53.549]                               hostname = base::Sys.info()[["nodename"]])
[17:46:53.549]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:53.549]                               info)
[17:46:53.549]                             info <- base::paste(info, collapse = "; ")
[17:46:53.549]                             if (!has_future) {
[17:46:53.549]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:53.549]                                 info)
[17:46:53.549]                             }
[17:46:53.549]                             else {
[17:46:53.549]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:53.549]                                 info, version)
[17:46:53.549]                             }
[17:46:53.549]                             base::stop(msg)
[17:46:53.549]                           }
[17:46:53.549]                         })
[17:46:53.549]                       }
[17:46:53.549]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:53.549]                       base::options(mc.cores = 1L)
[17:46:53.549]                     }
[17:46:53.549]                     base::local({
[17:46:53.549]                       for (pkg in c("stats", "datasets")) {
[17:46:53.549]                         base::loadNamespace(pkg)
[17:46:53.549]                         base::library(pkg, character.only = TRUE)
[17:46:53.549]                       }
[17:46:53.549]                     })
[17:46:53.549]                   }
[17:46:53.549]                   ...future.strategy.old <- future::plan("list")
[17:46:53.549]                   options(future.plan = NULL)
[17:46:53.549]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.549]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:53.549]                 }
[17:46:53.549]                 ...future.workdir <- getwd()
[17:46:53.549]             }
[17:46:53.549]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:53.549]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:53.549]         }
[17:46:53.549]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:53.549]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:53.549]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:53.549]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:53.549]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:53.549]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:53.549]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:53.549]             base::names(...future.oldOptions))
[17:46:53.549]     }
[17:46:53.549]     if (FALSE) {
[17:46:53.549]     }
[17:46:53.549]     else {
[17:46:53.549]         if (TRUE) {
[17:46:53.549]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:53.549]                 open = "w")
[17:46:53.549]         }
[17:46:53.549]         else {
[17:46:53.549]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:53.549]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:53.549]         }
[17:46:53.549]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:53.549]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:53.549]             base::sink(type = "output", split = FALSE)
[17:46:53.549]             base::close(...future.stdout)
[17:46:53.549]         }, add = TRUE)
[17:46:53.549]     }
[17:46:53.549]     ...future.frame <- base::sys.nframe()
[17:46:53.549]     ...future.conditions <- base::list()
[17:46:53.549]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:53.549]     if (FALSE) {
[17:46:53.549]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:53.549]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:53.549]     }
[17:46:53.549]     ...future.result <- base::tryCatch({
[17:46:53.549]         base::withCallingHandlers({
[17:46:53.549]             ...future.value <- base::withVisible(base::local({
[17:46:53.549]                 ...future.makeSendCondition <- base::local({
[17:46:53.549]                   sendCondition <- NULL
[17:46:53.549]                   function(frame = 1L) {
[17:46:53.549]                     if (is.function(sendCondition)) 
[17:46:53.549]                       return(sendCondition)
[17:46:53.549]                     ns <- getNamespace("parallel")
[17:46:53.549]                     if (exists("sendData", mode = "function", 
[17:46:53.549]                       envir = ns)) {
[17:46:53.549]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:53.549]                         envir = ns)
[17:46:53.549]                       envir <- sys.frame(frame)
[17:46:53.549]                       master <- NULL
[17:46:53.549]                       while (!identical(envir, .GlobalEnv) && 
[17:46:53.549]                         !identical(envir, emptyenv())) {
[17:46:53.549]                         if (exists("master", mode = "list", envir = envir, 
[17:46:53.549]                           inherits = FALSE)) {
[17:46:53.549]                           master <- get("master", mode = "list", 
[17:46:53.549]                             envir = envir, inherits = FALSE)
[17:46:53.549]                           if (inherits(master, c("SOCKnode", 
[17:46:53.549]                             "SOCK0node"))) {
[17:46:53.549]                             sendCondition <<- function(cond) {
[17:46:53.549]                               data <- list(type = "VALUE", value = cond, 
[17:46:53.549]                                 success = TRUE)
[17:46:53.549]                               parallel_sendData(master, data)
[17:46:53.549]                             }
[17:46:53.549]                             return(sendCondition)
[17:46:53.549]                           }
[17:46:53.549]                         }
[17:46:53.549]                         frame <- frame + 1L
[17:46:53.549]                         envir <- sys.frame(frame)
[17:46:53.549]                       }
[17:46:53.549]                     }
[17:46:53.549]                     sendCondition <<- function(cond) NULL
[17:46:53.549]                   }
[17:46:53.549]                 })
[17:46:53.549]                 withCallingHandlers({
[17:46:53.549]                   {
[17:46:53.549]                     lm(dist ~ speed + I(speed^2), data = cars)
[17:46:53.549]                   }
[17:46:53.549]                 }, immediateCondition = function(cond) {
[17:46:53.549]                   sendCondition <- ...future.makeSendCondition()
[17:46:53.549]                   sendCondition(cond)
[17:46:53.549]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.549]                   {
[17:46:53.549]                     inherits <- base::inherits
[17:46:53.549]                     invokeRestart <- base::invokeRestart
[17:46:53.549]                     is.null <- base::is.null
[17:46:53.549]                     muffled <- FALSE
[17:46:53.549]                     if (inherits(cond, "message")) {
[17:46:53.549]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:53.549]                       if (muffled) 
[17:46:53.549]                         invokeRestart("muffleMessage")
[17:46:53.549]                     }
[17:46:53.549]                     else if (inherits(cond, "warning")) {
[17:46:53.549]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:53.549]                       if (muffled) 
[17:46:53.549]                         invokeRestart("muffleWarning")
[17:46:53.549]                     }
[17:46:53.549]                     else if (inherits(cond, "condition")) {
[17:46:53.549]                       if (!is.null(pattern)) {
[17:46:53.549]                         computeRestarts <- base::computeRestarts
[17:46:53.549]                         grepl <- base::grepl
[17:46:53.549]                         restarts <- computeRestarts(cond)
[17:46:53.549]                         for (restart in restarts) {
[17:46:53.549]                           name <- restart$name
[17:46:53.549]                           if (is.null(name)) 
[17:46:53.549]                             next
[17:46:53.549]                           if (!grepl(pattern, name)) 
[17:46:53.549]                             next
[17:46:53.549]                           invokeRestart(restart)
[17:46:53.549]                           muffled <- TRUE
[17:46:53.549]                           break
[17:46:53.549]                         }
[17:46:53.549]                       }
[17:46:53.549]                     }
[17:46:53.549]                     invisible(muffled)
[17:46:53.549]                   }
[17:46:53.549]                   muffleCondition(cond)
[17:46:53.549]                 })
[17:46:53.549]             }))
[17:46:53.549]             future::FutureResult(value = ...future.value$value, 
[17:46:53.549]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.549]                   ...future.rng), globalenv = if (FALSE) 
[17:46:53.549]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:53.549]                     ...future.globalenv.names))
[17:46:53.549]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:53.549]         }, condition = base::local({
[17:46:53.549]             c <- base::c
[17:46:53.549]             inherits <- base::inherits
[17:46:53.549]             invokeRestart <- base::invokeRestart
[17:46:53.549]             length <- base::length
[17:46:53.549]             list <- base::list
[17:46:53.549]             seq.int <- base::seq.int
[17:46:53.549]             signalCondition <- base::signalCondition
[17:46:53.549]             sys.calls <- base::sys.calls
[17:46:53.549]             `[[` <- base::`[[`
[17:46:53.549]             `+` <- base::`+`
[17:46:53.549]             `<<-` <- base::`<<-`
[17:46:53.549]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:53.549]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:53.549]                   3L)]
[17:46:53.549]             }
[17:46:53.549]             function(cond) {
[17:46:53.549]                 is_error <- inherits(cond, "error")
[17:46:53.549]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:53.549]                   NULL)
[17:46:53.549]                 if (is_error) {
[17:46:53.549]                   sessionInformation <- function() {
[17:46:53.549]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:53.549]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:53.549]                       search = base::search(), system = base::Sys.info())
[17:46:53.549]                   }
[17:46:53.549]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.549]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:53.549]                     cond$call), session = sessionInformation(), 
[17:46:53.549]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:53.549]                   signalCondition(cond)
[17:46:53.549]                 }
[17:46:53.549]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:53.549]                 "immediateCondition"))) {
[17:46:53.549]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:53.549]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.549]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:53.549]                   if (TRUE && !signal) {
[17:46:53.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.549]                     {
[17:46:53.549]                       inherits <- base::inherits
[17:46:53.549]                       invokeRestart <- base::invokeRestart
[17:46:53.549]                       is.null <- base::is.null
[17:46:53.549]                       muffled <- FALSE
[17:46:53.549]                       if (inherits(cond, "message")) {
[17:46:53.549]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.549]                         if (muffled) 
[17:46:53.549]                           invokeRestart("muffleMessage")
[17:46:53.549]                       }
[17:46:53.549]                       else if (inherits(cond, "warning")) {
[17:46:53.549]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.549]                         if (muffled) 
[17:46:53.549]                           invokeRestart("muffleWarning")
[17:46:53.549]                       }
[17:46:53.549]                       else if (inherits(cond, "condition")) {
[17:46:53.549]                         if (!is.null(pattern)) {
[17:46:53.549]                           computeRestarts <- base::computeRestarts
[17:46:53.549]                           grepl <- base::grepl
[17:46:53.549]                           restarts <- computeRestarts(cond)
[17:46:53.549]                           for (restart in restarts) {
[17:46:53.549]                             name <- restart$name
[17:46:53.549]                             if (is.null(name)) 
[17:46:53.549]                               next
[17:46:53.549]                             if (!grepl(pattern, name)) 
[17:46:53.549]                               next
[17:46:53.549]                             invokeRestart(restart)
[17:46:53.549]                             muffled <- TRUE
[17:46:53.549]                             break
[17:46:53.549]                           }
[17:46:53.549]                         }
[17:46:53.549]                       }
[17:46:53.549]                       invisible(muffled)
[17:46:53.549]                     }
[17:46:53.549]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.549]                   }
[17:46:53.549]                 }
[17:46:53.549]                 else {
[17:46:53.549]                   if (TRUE) {
[17:46:53.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.549]                     {
[17:46:53.549]                       inherits <- base::inherits
[17:46:53.549]                       invokeRestart <- base::invokeRestart
[17:46:53.549]                       is.null <- base::is.null
[17:46:53.549]                       muffled <- FALSE
[17:46:53.549]                       if (inherits(cond, "message")) {
[17:46:53.549]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.549]                         if (muffled) 
[17:46:53.549]                           invokeRestart("muffleMessage")
[17:46:53.549]                       }
[17:46:53.549]                       else if (inherits(cond, "warning")) {
[17:46:53.549]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.549]                         if (muffled) 
[17:46:53.549]                           invokeRestart("muffleWarning")
[17:46:53.549]                       }
[17:46:53.549]                       else if (inherits(cond, "condition")) {
[17:46:53.549]                         if (!is.null(pattern)) {
[17:46:53.549]                           computeRestarts <- base::computeRestarts
[17:46:53.549]                           grepl <- base::grepl
[17:46:53.549]                           restarts <- computeRestarts(cond)
[17:46:53.549]                           for (restart in restarts) {
[17:46:53.549]                             name <- restart$name
[17:46:53.549]                             if (is.null(name)) 
[17:46:53.549]                               next
[17:46:53.549]                             if (!grepl(pattern, name)) 
[17:46:53.549]                               next
[17:46:53.549]                             invokeRestart(restart)
[17:46:53.549]                             muffled <- TRUE
[17:46:53.549]                             break
[17:46:53.549]                           }
[17:46:53.549]                         }
[17:46:53.549]                       }
[17:46:53.549]                       invisible(muffled)
[17:46:53.549]                     }
[17:46:53.549]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.549]                   }
[17:46:53.549]                 }
[17:46:53.549]             }
[17:46:53.549]         }))
[17:46:53.549]     }, error = function(ex) {
[17:46:53.549]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:53.549]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.549]                 ...future.rng), started = ...future.startTime, 
[17:46:53.549]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:53.549]             version = "1.8"), class = "FutureResult")
[17:46:53.549]     }, finally = {
[17:46:53.549]         if (!identical(...future.workdir, getwd())) 
[17:46:53.549]             setwd(...future.workdir)
[17:46:53.549]         {
[17:46:53.549]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:53.549]                 ...future.oldOptions$nwarnings <- NULL
[17:46:53.549]             }
[17:46:53.549]             base::options(...future.oldOptions)
[17:46:53.549]             if (.Platform$OS.type == "windows") {
[17:46:53.549]                 old_names <- names(...future.oldEnvVars)
[17:46:53.549]                 envs <- base::Sys.getenv()
[17:46:53.549]                 names <- names(envs)
[17:46:53.549]                 common <- intersect(names, old_names)
[17:46:53.549]                 added <- setdiff(names, old_names)
[17:46:53.549]                 removed <- setdiff(old_names, names)
[17:46:53.549]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:53.549]                   envs[common]]
[17:46:53.549]                 NAMES <- toupper(changed)
[17:46:53.549]                 args <- list()
[17:46:53.549]                 for (kk in seq_along(NAMES)) {
[17:46:53.549]                   name <- changed[[kk]]
[17:46:53.549]                   NAME <- NAMES[[kk]]
[17:46:53.549]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.549]                     next
[17:46:53.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.549]                 }
[17:46:53.549]                 NAMES <- toupper(added)
[17:46:53.549]                 for (kk in seq_along(NAMES)) {
[17:46:53.549]                   name <- added[[kk]]
[17:46:53.549]                   NAME <- NAMES[[kk]]
[17:46:53.549]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.549]                     next
[17:46:53.549]                   args[[name]] <- ""
[17:46:53.549]                 }
[17:46:53.549]                 NAMES <- toupper(removed)
[17:46:53.549]                 for (kk in seq_along(NAMES)) {
[17:46:53.549]                   name <- removed[[kk]]
[17:46:53.549]                   NAME <- NAMES[[kk]]
[17:46:53.549]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.549]                     next
[17:46:53.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.549]                 }
[17:46:53.549]                 if (length(args) > 0) 
[17:46:53.549]                   base::do.call(base::Sys.setenv, args = args)
[17:46:53.549]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:53.549]             }
[17:46:53.549]             else {
[17:46:53.549]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:53.549]             }
[17:46:53.549]             {
[17:46:53.549]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:53.549]                   0L) {
[17:46:53.549]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:53.549]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:53.549]                   base::options(opts)
[17:46:53.549]                 }
[17:46:53.549]                 {
[17:46:53.549]                   {
[17:46:53.549]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:53.549]                     NULL
[17:46:53.549]                   }
[17:46:53.549]                   options(future.plan = NULL)
[17:46:53.549]                   if (is.na(NA_character_)) 
[17:46:53.549]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.549]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:53.549]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:53.549]                     .init = FALSE)
[17:46:53.549]                 }
[17:46:53.549]             }
[17:46:53.549]         }
[17:46:53.549]     })
[17:46:53.549]     if (TRUE) {
[17:46:53.549]         base::sink(type = "output", split = FALSE)
[17:46:53.549]         if (TRUE) {
[17:46:53.549]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:53.549]         }
[17:46:53.549]         else {
[17:46:53.549]             ...future.result["stdout"] <- base::list(NULL)
[17:46:53.549]         }
[17:46:53.549]         base::close(...future.stdout)
[17:46:53.549]         ...future.stdout <- NULL
[17:46:53.549]     }
[17:46:53.549]     ...future.result$conditions <- ...future.conditions
[17:46:53.549]     ...future.result$finished <- base::Sys.time()
[17:46:53.549]     ...future.result
[17:46:53.549] }
[17:46:53.552] MultisessionFuture started
[17:46:53.552] - Launch lazy future ... done
[17:46:53.552] run() for ‘MultisessionFuture’ ... done
[17:46:53.553] result() for ClusterFuture ...
[17:46:53.553] receiveMessageFromWorker() for ClusterFuture ...
[17:46:53.553] - Validating connection of MultisessionFuture
[17:46:53.598] - received message: FutureResult
[17:46:53.598] - Received FutureResult
[17:46:53.598] - Erased future from FutureRegistry
[17:46:53.598] result() for ClusterFuture ...
[17:46:53.598] - result already collected: FutureResult
[17:46:53.598] result() for ClusterFuture ... done
[17:46:53.599] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:53.599] result() for ClusterFuture ... done
[17:46:53.599] result() for ClusterFuture ...
[17:46:53.599] - result already collected: FutureResult
[17:46:53.599] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[17:46:53.602] getGlobalsAndPackages() ...
[17:46:53.602] Searching for globals...
[17:46:53.603] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[17:46:53.603] Searching for globals ... DONE
[17:46:53.603] Resolving globals: FALSE
[17:46:53.604] 
[17:46:53.604] - packages: [2] ‘stats’, ‘datasets’
[17:46:53.604] getGlobalsAndPackages() ... DONE
[17:46:53.604] run() for ‘Future’ ...
[17:46:53.604] - state: ‘created’
[17:46:53.605] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:53.618] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:53.618] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:53.618]   - Field: ‘node’
[17:46:53.618]   - Field: ‘label’
[17:46:53.619]   - Field: ‘local’
[17:46:53.619]   - Field: ‘owner’
[17:46:53.619]   - Field: ‘envir’
[17:46:53.619]   - Field: ‘workers’
[17:46:53.619]   - Field: ‘packages’
[17:46:53.619]   - Field: ‘gc’
[17:46:53.619]   - Field: ‘conditions’
[17:46:53.619]   - Field: ‘persistent’
[17:46:53.619]   - Field: ‘expr’
[17:46:53.619]   - Field: ‘uuid’
[17:46:53.619]   - Field: ‘seed’
[17:46:53.620]   - Field: ‘version’
[17:46:53.620]   - Field: ‘result’
[17:46:53.620]   - Field: ‘asynchronous’
[17:46:53.620]   - Field: ‘calls’
[17:46:53.620]   - Field: ‘globals’
[17:46:53.620]   - Field: ‘stdout’
[17:46:53.620]   - Field: ‘earlySignal’
[17:46:53.620]   - Field: ‘lazy’
[17:46:53.620]   - Field: ‘state’
[17:46:53.620] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:53.620] - Launch lazy future ...
[17:46:53.621] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:46:53.621] Packages needed by future strategies (n = 0): <none>
[17:46:53.621] {
[17:46:53.621]     {
[17:46:53.621]         {
[17:46:53.621]             ...future.startTime <- base::Sys.time()
[17:46:53.621]             {
[17:46:53.621]                 {
[17:46:53.621]                   {
[17:46:53.621]                     {
[17:46:53.621]                       {
[17:46:53.621]                         base::local({
[17:46:53.621]                           has_future <- base::requireNamespace("future", 
[17:46:53.621]                             quietly = TRUE)
[17:46:53.621]                           if (has_future) {
[17:46:53.621]                             ns <- base::getNamespace("future")
[17:46:53.621]                             version <- ns[[".package"]][["version"]]
[17:46:53.621]                             if (is.null(version)) 
[17:46:53.621]                               version <- utils::packageVersion("future")
[17:46:53.621]                           }
[17:46:53.621]                           else {
[17:46:53.621]                             version <- NULL
[17:46:53.621]                           }
[17:46:53.621]                           if (!has_future || version < "1.8.0") {
[17:46:53.621]                             info <- base::c(r_version = base::gsub("R version ", 
[17:46:53.621]                               "", base::R.version$version.string), 
[17:46:53.621]                               platform = base::sprintf("%s (%s-bit)", 
[17:46:53.621]                                 base::R.version$platform, 8 * 
[17:46:53.621]                                   base::.Machine$sizeof.pointer), 
[17:46:53.621]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:53.621]                                 "release", "version")], collapse = " "), 
[17:46:53.621]                               hostname = base::Sys.info()[["nodename"]])
[17:46:53.621]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:46:53.621]                               info)
[17:46:53.621]                             info <- base::paste(info, collapse = "; ")
[17:46:53.621]                             if (!has_future) {
[17:46:53.621]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:53.621]                                 info)
[17:46:53.621]                             }
[17:46:53.621]                             else {
[17:46:53.621]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:53.621]                                 info, version)
[17:46:53.621]                             }
[17:46:53.621]                             base::stop(msg)
[17:46:53.621]                           }
[17:46:53.621]                         })
[17:46:53.621]                       }
[17:46:53.621]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:53.621]                       base::options(mc.cores = 1L)
[17:46:53.621]                     }
[17:46:53.621]                     base::local({
[17:46:53.621]                       for (pkg in c("stats", "datasets")) {
[17:46:53.621]                         base::loadNamespace(pkg)
[17:46:53.621]                         base::library(pkg, character.only = TRUE)
[17:46:53.621]                       }
[17:46:53.621]                     })
[17:46:53.621]                   }
[17:46:53.621]                   ...future.strategy.old <- future::plan("list")
[17:46:53.621]                   options(future.plan = NULL)
[17:46:53.621]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.621]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:53.621]                 }
[17:46:53.621]                 ...future.workdir <- getwd()
[17:46:53.621]             }
[17:46:53.621]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:53.621]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:53.621]         }
[17:46:53.621]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:53.621]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:53.621]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:53.621]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:53.621]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:53.621]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:53.621]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:53.621]             base::names(...future.oldOptions))
[17:46:53.621]     }
[17:46:53.621]     if (FALSE) {
[17:46:53.621]     }
[17:46:53.621]     else {
[17:46:53.621]         if (TRUE) {
[17:46:53.621]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:53.621]                 open = "w")
[17:46:53.621]         }
[17:46:53.621]         else {
[17:46:53.621]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:53.621]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:53.621]         }
[17:46:53.621]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:53.621]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:53.621]             base::sink(type = "output", split = FALSE)
[17:46:53.621]             base::close(...future.stdout)
[17:46:53.621]         }, add = TRUE)
[17:46:53.621]     }
[17:46:53.621]     ...future.frame <- base::sys.nframe()
[17:46:53.621]     ...future.conditions <- base::list()
[17:46:53.621]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:53.621]     if (FALSE) {
[17:46:53.621]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:53.621]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:53.621]     }
[17:46:53.621]     ...future.result <- base::tryCatch({
[17:46:53.621]         base::withCallingHandlers({
[17:46:53.621]             ...future.value <- base::withVisible(base::local({
[17:46:53.621]                 ...future.makeSendCondition <- base::local({
[17:46:53.621]                   sendCondition <- NULL
[17:46:53.621]                   function(frame = 1L) {
[17:46:53.621]                     if (is.function(sendCondition)) 
[17:46:53.621]                       return(sendCondition)
[17:46:53.621]                     ns <- getNamespace("parallel")
[17:46:53.621]                     if (exists("sendData", mode = "function", 
[17:46:53.621]                       envir = ns)) {
[17:46:53.621]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:53.621]                         envir = ns)
[17:46:53.621]                       envir <- sys.frame(frame)
[17:46:53.621]                       master <- NULL
[17:46:53.621]                       while (!identical(envir, .GlobalEnv) && 
[17:46:53.621]                         !identical(envir, emptyenv())) {
[17:46:53.621]                         if (exists("master", mode = "list", envir = envir, 
[17:46:53.621]                           inherits = FALSE)) {
[17:46:53.621]                           master <- get("master", mode = "list", 
[17:46:53.621]                             envir = envir, inherits = FALSE)
[17:46:53.621]                           if (inherits(master, c("SOCKnode", 
[17:46:53.621]                             "SOCK0node"))) {
[17:46:53.621]                             sendCondition <<- function(cond) {
[17:46:53.621]                               data <- list(type = "VALUE", value = cond, 
[17:46:53.621]                                 success = TRUE)
[17:46:53.621]                               parallel_sendData(master, data)
[17:46:53.621]                             }
[17:46:53.621]                             return(sendCondition)
[17:46:53.621]                           }
[17:46:53.621]                         }
[17:46:53.621]                         frame <- frame + 1L
[17:46:53.621]                         envir <- sys.frame(frame)
[17:46:53.621]                       }
[17:46:53.621]                     }
[17:46:53.621]                     sendCondition <<- function(cond) NULL
[17:46:53.621]                   }
[17:46:53.621]                 })
[17:46:53.621]                 withCallingHandlers({
[17:46:53.621]                   {
[17:46:53.621]                     lm(dist ~ poly(speed, 2), data = cars)
[17:46:53.621]                   }
[17:46:53.621]                 }, immediateCondition = function(cond) {
[17:46:53.621]                   sendCondition <- ...future.makeSendCondition()
[17:46:53.621]                   sendCondition(cond)
[17:46:53.621]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.621]                   {
[17:46:53.621]                     inherits <- base::inherits
[17:46:53.621]                     invokeRestart <- base::invokeRestart
[17:46:53.621]                     is.null <- base::is.null
[17:46:53.621]                     muffled <- FALSE
[17:46:53.621]                     if (inherits(cond, "message")) {
[17:46:53.621]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:53.621]                       if (muffled) 
[17:46:53.621]                         invokeRestart("muffleMessage")
[17:46:53.621]                     }
[17:46:53.621]                     else if (inherits(cond, "warning")) {
[17:46:53.621]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:53.621]                       if (muffled) 
[17:46:53.621]                         invokeRestart("muffleWarning")
[17:46:53.621]                     }
[17:46:53.621]                     else if (inherits(cond, "condition")) {
[17:46:53.621]                       if (!is.null(pattern)) {
[17:46:53.621]                         computeRestarts <- base::computeRestarts
[17:46:53.621]                         grepl <- base::grepl
[17:46:53.621]                         restarts <- computeRestarts(cond)
[17:46:53.621]                         for (restart in restarts) {
[17:46:53.621]                           name <- restart$name
[17:46:53.621]                           if (is.null(name)) 
[17:46:53.621]                             next
[17:46:53.621]                           if (!grepl(pattern, name)) 
[17:46:53.621]                             next
[17:46:53.621]                           invokeRestart(restart)
[17:46:53.621]                           muffled <- TRUE
[17:46:53.621]                           break
[17:46:53.621]                         }
[17:46:53.621]                       }
[17:46:53.621]                     }
[17:46:53.621]                     invisible(muffled)
[17:46:53.621]                   }
[17:46:53.621]                   muffleCondition(cond)
[17:46:53.621]                 })
[17:46:53.621]             }))
[17:46:53.621]             future::FutureResult(value = ...future.value$value, 
[17:46:53.621]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.621]                   ...future.rng), globalenv = if (FALSE) 
[17:46:53.621]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:53.621]                     ...future.globalenv.names))
[17:46:53.621]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:53.621]         }, condition = base::local({
[17:46:53.621]             c <- base::c
[17:46:53.621]             inherits <- base::inherits
[17:46:53.621]             invokeRestart <- base::invokeRestart
[17:46:53.621]             length <- base::length
[17:46:53.621]             list <- base::list
[17:46:53.621]             seq.int <- base::seq.int
[17:46:53.621]             signalCondition <- base::signalCondition
[17:46:53.621]             sys.calls <- base::sys.calls
[17:46:53.621]             `[[` <- base::`[[`
[17:46:53.621]             `+` <- base::`+`
[17:46:53.621]             `<<-` <- base::`<<-`
[17:46:53.621]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:53.621]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:53.621]                   3L)]
[17:46:53.621]             }
[17:46:53.621]             function(cond) {
[17:46:53.621]                 is_error <- inherits(cond, "error")
[17:46:53.621]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:53.621]                   NULL)
[17:46:53.621]                 if (is_error) {
[17:46:53.621]                   sessionInformation <- function() {
[17:46:53.621]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:53.621]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:53.621]                       search = base::search(), system = base::Sys.info())
[17:46:53.621]                   }
[17:46:53.621]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.621]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:53.621]                     cond$call), session = sessionInformation(), 
[17:46:53.621]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:53.621]                   signalCondition(cond)
[17:46:53.621]                 }
[17:46:53.621]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:53.621]                 "immediateCondition"))) {
[17:46:53.621]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:53.621]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.621]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:53.621]                   if (TRUE && !signal) {
[17:46:53.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.621]                     {
[17:46:53.621]                       inherits <- base::inherits
[17:46:53.621]                       invokeRestart <- base::invokeRestart
[17:46:53.621]                       is.null <- base::is.null
[17:46:53.621]                       muffled <- FALSE
[17:46:53.621]                       if (inherits(cond, "message")) {
[17:46:53.621]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.621]                         if (muffled) 
[17:46:53.621]                           invokeRestart("muffleMessage")
[17:46:53.621]                       }
[17:46:53.621]                       else if (inherits(cond, "warning")) {
[17:46:53.621]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.621]                         if (muffled) 
[17:46:53.621]                           invokeRestart("muffleWarning")
[17:46:53.621]                       }
[17:46:53.621]                       else if (inherits(cond, "condition")) {
[17:46:53.621]                         if (!is.null(pattern)) {
[17:46:53.621]                           computeRestarts <- base::computeRestarts
[17:46:53.621]                           grepl <- base::grepl
[17:46:53.621]                           restarts <- computeRestarts(cond)
[17:46:53.621]                           for (restart in restarts) {
[17:46:53.621]                             name <- restart$name
[17:46:53.621]                             if (is.null(name)) 
[17:46:53.621]                               next
[17:46:53.621]                             if (!grepl(pattern, name)) 
[17:46:53.621]                               next
[17:46:53.621]                             invokeRestart(restart)
[17:46:53.621]                             muffled <- TRUE
[17:46:53.621]                             break
[17:46:53.621]                           }
[17:46:53.621]                         }
[17:46:53.621]                       }
[17:46:53.621]                       invisible(muffled)
[17:46:53.621]                     }
[17:46:53.621]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.621]                   }
[17:46:53.621]                 }
[17:46:53.621]                 else {
[17:46:53.621]                   if (TRUE) {
[17:46:53.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.621]                     {
[17:46:53.621]                       inherits <- base::inherits
[17:46:53.621]                       invokeRestart <- base::invokeRestart
[17:46:53.621]                       is.null <- base::is.null
[17:46:53.621]                       muffled <- FALSE
[17:46:53.621]                       if (inherits(cond, "message")) {
[17:46:53.621]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.621]                         if (muffled) 
[17:46:53.621]                           invokeRestart("muffleMessage")
[17:46:53.621]                       }
[17:46:53.621]                       else if (inherits(cond, "warning")) {
[17:46:53.621]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.621]                         if (muffled) 
[17:46:53.621]                           invokeRestart("muffleWarning")
[17:46:53.621]                       }
[17:46:53.621]                       else if (inherits(cond, "condition")) {
[17:46:53.621]                         if (!is.null(pattern)) {
[17:46:53.621]                           computeRestarts <- base::computeRestarts
[17:46:53.621]                           grepl <- base::grepl
[17:46:53.621]                           restarts <- computeRestarts(cond)
[17:46:53.621]                           for (restart in restarts) {
[17:46:53.621]                             name <- restart$name
[17:46:53.621]                             if (is.null(name)) 
[17:46:53.621]                               next
[17:46:53.621]                             if (!grepl(pattern, name)) 
[17:46:53.621]                               next
[17:46:53.621]                             invokeRestart(restart)
[17:46:53.621]                             muffled <- TRUE
[17:46:53.621]                             break
[17:46:53.621]                           }
[17:46:53.621]                         }
[17:46:53.621]                       }
[17:46:53.621]                       invisible(muffled)
[17:46:53.621]                     }
[17:46:53.621]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.621]                   }
[17:46:53.621]                 }
[17:46:53.621]             }
[17:46:53.621]         }))
[17:46:53.621]     }, error = function(ex) {
[17:46:53.621]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:53.621]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.621]                 ...future.rng), started = ...future.startTime, 
[17:46:53.621]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:53.621]             version = "1.8"), class = "FutureResult")
[17:46:53.621]     }, finally = {
[17:46:53.621]         if (!identical(...future.workdir, getwd())) 
[17:46:53.621]             setwd(...future.workdir)
[17:46:53.621]         {
[17:46:53.621]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:53.621]                 ...future.oldOptions$nwarnings <- NULL
[17:46:53.621]             }
[17:46:53.621]             base::options(...future.oldOptions)
[17:46:53.621]             if (.Platform$OS.type == "windows") {
[17:46:53.621]                 old_names <- names(...future.oldEnvVars)
[17:46:53.621]                 envs <- base::Sys.getenv()
[17:46:53.621]                 names <- names(envs)
[17:46:53.621]                 common <- intersect(names, old_names)
[17:46:53.621]                 added <- setdiff(names, old_names)
[17:46:53.621]                 removed <- setdiff(old_names, names)
[17:46:53.621]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:53.621]                   envs[common]]
[17:46:53.621]                 NAMES <- toupper(changed)
[17:46:53.621]                 args <- list()
[17:46:53.621]                 for (kk in seq_along(NAMES)) {
[17:46:53.621]                   name <- changed[[kk]]
[17:46:53.621]                   NAME <- NAMES[[kk]]
[17:46:53.621]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.621]                     next
[17:46:53.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.621]                 }
[17:46:53.621]                 NAMES <- toupper(added)
[17:46:53.621]                 for (kk in seq_along(NAMES)) {
[17:46:53.621]                   name <- added[[kk]]
[17:46:53.621]                   NAME <- NAMES[[kk]]
[17:46:53.621]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.621]                     next
[17:46:53.621]                   args[[name]] <- ""
[17:46:53.621]                 }
[17:46:53.621]                 NAMES <- toupper(removed)
[17:46:53.621]                 for (kk in seq_along(NAMES)) {
[17:46:53.621]                   name <- removed[[kk]]
[17:46:53.621]                   NAME <- NAMES[[kk]]
[17:46:53.621]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.621]                     next
[17:46:53.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.621]                 }
[17:46:53.621]                 if (length(args) > 0) 
[17:46:53.621]                   base::do.call(base::Sys.setenv, args = args)
[17:46:53.621]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:53.621]             }
[17:46:53.621]             else {
[17:46:53.621]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:53.621]             }
[17:46:53.621]             {
[17:46:53.621]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:53.621]                   0L) {
[17:46:53.621]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:53.621]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:53.621]                   base::options(opts)
[17:46:53.621]                 }
[17:46:53.621]                 {
[17:46:53.621]                   {
[17:46:53.621]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:53.621]                     NULL
[17:46:53.621]                   }
[17:46:53.621]                   options(future.plan = NULL)
[17:46:53.621]                   if (is.na(NA_character_)) 
[17:46:53.621]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.621]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:53.621]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:53.621]                     .init = FALSE)
[17:46:53.621]                 }
[17:46:53.621]             }
[17:46:53.621]         }
[17:46:53.621]     })
[17:46:53.621]     if (TRUE) {
[17:46:53.621]         base::sink(type = "output", split = FALSE)
[17:46:53.621]         if (TRUE) {
[17:46:53.621]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:53.621]         }
[17:46:53.621]         else {
[17:46:53.621]             ...future.result["stdout"] <- base::list(NULL)
[17:46:53.621]         }
[17:46:53.621]         base::close(...future.stdout)
[17:46:53.621]         ...future.stdout <- NULL
[17:46:53.621]     }
[17:46:53.621]     ...future.result$conditions <- ...future.conditions
[17:46:53.621]     ...future.result$finished <- base::Sys.time()
[17:46:53.621]     ...future.result
[17:46:53.621] }
[17:46:53.624] MultisessionFuture started
[17:46:53.624] - Launch lazy future ... done
[17:46:53.625] run() for ‘MultisessionFuture’ ... done
[17:46:53.625] result() for ClusterFuture ...
[17:46:53.625] receiveMessageFromWorker() for ClusterFuture ...
[17:46:53.625] - Validating connection of MultisessionFuture
[17:46:53.671] - received message: FutureResult
[17:46:53.671] - Received FutureResult
[17:46:53.671] - Erased future from FutureRegistry
[17:46:53.671] result() for ClusterFuture ...
[17:46:53.671] - result already collected: FutureResult
[17:46:53.671] result() for ClusterFuture ... done
[17:46:53.671] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:53.672] result() for ClusterFuture ... done
[17:46:53.672] result() for ClusterFuture ...
[17:46:53.672] - result already collected: FutureResult
[17:46:53.672] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[17:46:53.674] getGlobalsAndPackages() ...
[17:46:53.674] Searching for globals...
[17:46:53.678] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:46:53.678] Searching for globals ... DONE
[17:46:53.678] Resolving globals: FALSE
[17:46:53.679] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:46:53.679] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:46:53.679] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:46:53.679] 
[17:46:53.679] getGlobalsAndPackages() ... DONE
[17:46:53.680] run() for ‘Future’ ...
[17:46:53.680] - state: ‘created’
[17:46:53.680] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:53.693] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:53.694] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:53.694]   - Field: ‘node’
[17:46:53.694]   - Field: ‘label’
[17:46:53.694]   - Field: ‘local’
[17:46:53.694]   - Field: ‘owner’
[17:46:53.694]   - Field: ‘envir’
[17:46:53.694]   - Field: ‘workers’
[17:46:53.694]   - Field: ‘packages’
[17:46:53.694]   - Field: ‘gc’
[17:46:53.694]   - Field: ‘conditions’
[17:46:53.695]   - Field: ‘persistent’
[17:46:53.695]   - Field: ‘expr’
[17:46:53.695]   - Field: ‘uuid’
[17:46:53.695]   - Field: ‘seed’
[17:46:53.695]   - Field: ‘version’
[17:46:53.695]   - Field: ‘result’
[17:46:53.695]   - Field: ‘asynchronous’
[17:46:53.695]   - Field: ‘calls’
[17:46:53.695]   - Field: ‘globals’
[17:46:53.695]   - Field: ‘stdout’
[17:46:53.695]   - Field: ‘earlySignal’
[17:46:53.696]   - Field: ‘lazy’
[17:46:53.696]   - Field: ‘state’
[17:46:53.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:53.696] - Launch lazy future ...
[17:46:53.696] Packages needed by the future expression (n = 0): <none>
[17:46:53.696] Packages needed by future strategies (n = 0): <none>
[17:46:53.697] {
[17:46:53.697]     {
[17:46:53.697]         {
[17:46:53.697]             ...future.startTime <- base::Sys.time()
[17:46:53.697]             {
[17:46:53.697]                 {
[17:46:53.697]                   {
[17:46:53.697]                     {
[17:46:53.697]                       base::local({
[17:46:53.697]                         has_future <- base::requireNamespace("future", 
[17:46:53.697]                           quietly = TRUE)
[17:46:53.697]                         if (has_future) {
[17:46:53.697]                           ns <- base::getNamespace("future")
[17:46:53.697]                           version <- ns[[".package"]][["version"]]
[17:46:53.697]                           if (is.null(version)) 
[17:46:53.697]                             version <- utils::packageVersion("future")
[17:46:53.697]                         }
[17:46:53.697]                         else {
[17:46:53.697]                           version <- NULL
[17:46:53.697]                         }
[17:46:53.697]                         if (!has_future || version < "1.8.0") {
[17:46:53.697]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:53.697]                             "", base::R.version$version.string), 
[17:46:53.697]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:53.697]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:53.697]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:53.697]                               "release", "version")], collapse = " "), 
[17:46:53.697]                             hostname = base::Sys.info()[["nodename"]])
[17:46:53.697]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:53.697]                             info)
[17:46:53.697]                           info <- base::paste(info, collapse = "; ")
[17:46:53.697]                           if (!has_future) {
[17:46:53.697]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:53.697]                               info)
[17:46:53.697]                           }
[17:46:53.697]                           else {
[17:46:53.697]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:53.697]                               info, version)
[17:46:53.697]                           }
[17:46:53.697]                           base::stop(msg)
[17:46:53.697]                         }
[17:46:53.697]                       })
[17:46:53.697]                     }
[17:46:53.697]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:53.697]                     base::options(mc.cores = 1L)
[17:46:53.697]                   }
[17:46:53.697]                   ...future.strategy.old <- future::plan("list")
[17:46:53.697]                   options(future.plan = NULL)
[17:46:53.697]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.697]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:53.697]                 }
[17:46:53.697]                 ...future.workdir <- getwd()
[17:46:53.697]             }
[17:46:53.697]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:53.697]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:53.697]         }
[17:46:53.697]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:53.697]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:53.697]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:53.697]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:53.697]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:53.697]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:53.697]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:53.697]             base::names(...future.oldOptions))
[17:46:53.697]     }
[17:46:53.697]     if (FALSE) {
[17:46:53.697]     }
[17:46:53.697]     else {
[17:46:53.697]         if (TRUE) {
[17:46:53.697]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:53.697]                 open = "w")
[17:46:53.697]         }
[17:46:53.697]         else {
[17:46:53.697]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:53.697]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:53.697]         }
[17:46:53.697]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:53.697]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:53.697]             base::sink(type = "output", split = FALSE)
[17:46:53.697]             base::close(...future.stdout)
[17:46:53.697]         }, add = TRUE)
[17:46:53.697]     }
[17:46:53.697]     ...future.frame <- base::sys.nframe()
[17:46:53.697]     ...future.conditions <- base::list()
[17:46:53.697]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:53.697]     if (FALSE) {
[17:46:53.697]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:53.697]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:53.697]     }
[17:46:53.697]     ...future.result <- base::tryCatch({
[17:46:53.697]         base::withCallingHandlers({
[17:46:53.697]             ...future.value <- base::withVisible(base::local({
[17:46:53.697]                 ...future.makeSendCondition <- base::local({
[17:46:53.697]                   sendCondition <- NULL
[17:46:53.697]                   function(frame = 1L) {
[17:46:53.697]                     if (is.function(sendCondition)) 
[17:46:53.697]                       return(sendCondition)
[17:46:53.697]                     ns <- getNamespace("parallel")
[17:46:53.697]                     if (exists("sendData", mode = "function", 
[17:46:53.697]                       envir = ns)) {
[17:46:53.697]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:53.697]                         envir = ns)
[17:46:53.697]                       envir <- sys.frame(frame)
[17:46:53.697]                       master <- NULL
[17:46:53.697]                       while (!identical(envir, .GlobalEnv) && 
[17:46:53.697]                         !identical(envir, emptyenv())) {
[17:46:53.697]                         if (exists("master", mode = "list", envir = envir, 
[17:46:53.697]                           inherits = FALSE)) {
[17:46:53.697]                           master <- get("master", mode = "list", 
[17:46:53.697]                             envir = envir, inherits = FALSE)
[17:46:53.697]                           if (inherits(master, c("SOCKnode", 
[17:46:53.697]                             "SOCK0node"))) {
[17:46:53.697]                             sendCondition <<- function(cond) {
[17:46:53.697]                               data <- list(type = "VALUE", value = cond, 
[17:46:53.697]                                 success = TRUE)
[17:46:53.697]                               parallel_sendData(master, data)
[17:46:53.697]                             }
[17:46:53.697]                             return(sendCondition)
[17:46:53.697]                           }
[17:46:53.697]                         }
[17:46:53.697]                         frame <- frame + 1L
[17:46:53.697]                         envir <- sys.frame(frame)
[17:46:53.697]                       }
[17:46:53.697]                     }
[17:46:53.697]                     sendCondition <<- function(cond) NULL
[17:46:53.697]                   }
[17:46:53.697]                 })
[17:46:53.697]                 withCallingHandlers({
[17:46:53.697]                   {
[17:46:53.697]                     outer_function(1L)
[17:46:53.697]                   }
[17:46:53.697]                 }, immediateCondition = function(cond) {
[17:46:53.697]                   sendCondition <- ...future.makeSendCondition()
[17:46:53.697]                   sendCondition(cond)
[17:46:53.697]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.697]                   {
[17:46:53.697]                     inherits <- base::inherits
[17:46:53.697]                     invokeRestart <- base::invokeRestart
[17:46:53.697]                     is.null <- base::is.null
[17:46:53.697]                     muffled <- FALSE
[17:46:53.697]                     if (inherits(cond, "message")) {
[17:46:53.697]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:53.697]                       if (muffled) 
[17:46:53.697]                         invokeRestart("muffleMessage")
[17:46:53.697]                     }
[17:46:53.697]                     else if (inherits(cond, "warning")) {
[17:46:53.697]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:53.697]                       if (muffled) 
[17:46:53.697]                         invokeRestart("muffleWarning")
[17:46:53.697]                     }
[17:46:53.697]                     else if (inherits(cond, "condition")) {
[17:46:53.697]                       if (!is.null(pattern)) {
[17:46:53.697]                         computeRestarts <- base::computeRestarts
[17:46:53.697]                         grepl <- base::grepl
[17:46:53.697]                         restarts <- computeRestarts(cond)
[17:46:53.697]                         for (restart in restarts) {
[17:46:53.697]                           name <- restart$name
[17:46:53.697]                           if (is.null(name)) 
[17:46:53.697]                             next
[17:46:53.697]                           if (!grepl(pattern, name)) 
[17:46:53.697]                             next
[17:46:53.697]                           invokeRestart(restart)
[17:46:53.697]                           muffled <- TRUE
[17:46:53.697]                           break
[17:46:53.697]                         }
[17:46:53.697]                       }
[17:46:53.697]                     }
[17:46:53.697]                     invisible(muffled)
[17:46:53.697]                   }
[17:46:53.697]                   muffleCondition(cond)
[17:46:53.697]                 })
[17:46:53.697]             }))
[17:46:53.697]             future::FutureResult(value = ...future.value$value, 
[17:46:53.697]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.697]                   ...future.rng), globalenv = if (FALSE) 
[17:46:53.697]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:53.697]                     ...future.globalenv.names))
[17:46:53.697]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:53.697]         }, condition = base::local({
[17:46:53.697]             c <- base::c
[17:46:53.697]             inherits <- base::inherits
[17:46:53.697]             invokeRestart <- base::invokeRestart
[17:46:53.697]             length <- base::length
[17:46:53.697]             list <- base::list
[17:46:53.697]             seq.int <- base::seq.int
[17:46:53.697]             signalCondition <- base::signalCondition
[17:46:53.697]             sys.calls <- base::sys.calls
[17:46:53.697]             `[[` <- base::`[[`
[17:46:53.697]             `+` <- base::`+`
[17:46:53.697]             `<<-` <- base::`<<-`
[17:46:53.697]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:53.697]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:53.697]                   3L)]
[17:46:53.697]             }
[17:46:53.697]             function(cond) {
[17:46:53.697]                 is_error <- inherits(cond, "error")
[17:46:53.697]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:53.697]                   NULL)
[17:46:53.697]                 if (is_error) {
[17:46:53.697]                   sessionInformation <- function() {
[17:46:53.697]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:53.697]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:53.697]                       search = base::search(), system = base::Sys.info())
[17:46:53.697]                   }
[17:46:53.697]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.697]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:53.697]                     cond$call), session = sessionInformation(), 
[17:46:53.697]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:53.697]                   signalCondition(cond)
[17:46:53.697]                 }
[17:46:53.697]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:53.697]                 "immediateCondition"))) {
[17:46:53.697]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:53.697]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.697]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:53.697]                   if (TRUE && !signal) {
[17:46:53.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.697]                     {
[17:46:53.697]                       inherits <- base::inherits
[17:46:53.697]                       invokeRestart <- base::invokeRestart
[17:46:53.697]                       is.null <- base::is.null
[17:46:53.697]                       muffled <- FALSE
[17:46:53.697]                       if (inherits(cond, "message")) {
[17:46:53.697]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.697]                         if (muffled) 
[17:46:53.697]                           invokeRestart("muffleMessage")
[17:46:53.697]                       }
[17:46:53.697]                       else if (inherits(cond, "warning")) {
[17:46:53.697]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.697]                         if (muffled) 
[17:46:53.697]                           invokeRestart("muffleWarning")
[17:46:53.697]                       }
[17:46:53.697]                       else if (inherits(cond, "condition")) {
[17:46:53.697]                         if (!is.null(pattern)) {
[17:46:53.697]                           computeRestarts <- base::computeRestarts
[17:46:53.697]                           grepl <- base::grepl
[17:46:53.697]                           restarts <- computeRestarts(cond)
[17:46:53.697]                           for (restart in restarts) {
[17:46:53.697]                             name <- restart$name
[17:46:53.697]                             if (is.null(name)) 
[17:46:53.697]                               next
[17:46:53.697]                             if (!grepl(pattern, name)) 
[17:46:53.697]                               next
[17:46:53.697]                             invokeRestart(restart)
[17:46:53.697]                             muffled <- TRUE
[17:46:53.697]                             break
[17:46:53.697]                           }
[17:46:53.697]                         }
[17:46:53.697]                       }
[17:46:53.697]                       invisible(muffled)
[17:46:53.697]                     }
[17:46:53.697]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.697]                   }
[17:46:53.697]                 }
[17:46:53.697]                 else {
[17:46:53.697]                   if (TRUE) {
[17:46:53.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.697]                     {
[17:46:53.697]                       inherits <- base::inherits
[17:46:53.697]                       invokeRestart <- base::invokeRestart
[17:46:53.697]                       is.null <- base::is.null
[17:46:53.697]                       muffled <- FALSE
[17:46:53.697]                       if (inherits(cond, "message")) {
[17:46:53.697]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.697]                         if (muffled) 
[17:46:53.697]                           invokeRestart("muffleMessage")
[17:46:53.697]                       }
[17:46:53.697]                       else if (inherits(cond, "warning")) {
[17:46:53.697]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.697]                         if (muffled) 
[17:46:53.697]                           invokeRestart("muffleWarning")
[17:46:53.697]                       }
[17:46:53.697]                       else if (inherits(cond, "condition")) {
[17:46:53.697]                         if (!is.null(pattern)) {
[17:46:53.697]                           computeRestarts <- base::computeRestarts
[17:46:53.697]                           grepl <- base::grepl
[17:46:53.697]                           restarts <- computeRestarts(cond)
[17:46:53.697]                           for (restart in restarts) {
[17:46:53.697]                             name <- restart$name
[17:46:53.697]                             if (is.null(name)) 
[17:46:53.697]                               next
[17:46:53.697]                             if (!grepl(pattern, name)) 
[17:46:53.697]                               next
[17:46:53.697]                             invokeRestart(restart)
[17:46:53.697]                             muffled <- TRUE
[17:46:53.697]                             break
[17:46:53.697]                           }
[17:46:53.697]                         }
[17:46:53.697]                       }
[17:46:53.697]                       invisible(muffled)
[17:46:53.697]                     }
[17:46:53.697]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.697]                   }
[17:46:53.697]                 }
[17:46:53.697]             }
[17:46:53.697]         }))
[17:46:53.697]     }, error = function(ex) {
[17:46:53.697]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:53.697]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.697]                 ...future.rng), started = ...future.startTime, 
[17:46:53.697]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:53.697]             version = "1.8"), class = "FutureResult")
[17:46:53.697]     }, finally = {
[17:46:53.697]         if (!identical(...future.workdir, getwd())) 
[17:46:53.697]             setwd(...future.workdir)
[17:46:53.697]         {
[17:46:53.697]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:53.697]                 ...future.oldOptions$nwarnings <- NULL
[17:46:53.697]             }
[17:46:53.697]             base::options(...future.oldOptions)
[17:46:53.697]             if (.Platform$OS.type == "windows") {
[17:46:53.697]                 old_names <- names(...future.oldEnvVars)
[17:46:53.697]                 envs <- base::Sys.getenv()
[17:46:53.697]                 names <- names(envs)
[17:46:53.697]                 common <- intersect(names, old_names)
[17:46:53.697]                 added <- setdiff(names, old_names)
[17:46:53.697]                 removed <- setdiff(old_names, names)
[17:46:53.697]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:53.697]                   envs[common]]
[17:46:53.697]                 NAMES <- toupper(changed)
[17:46:53.697]                 args <- list()
[17:46:53.697]                 for (kk in seq_along(NAMES)) {
[17:46:53.697]                   name <- changed[[kk]]
[17:46:53.697]                   NAME <- NAMES[[kk]]
[17:46:53.697]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.697]                     next
[17:46:53.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.697]                 }
[17:46:53.697]                 NAMES <- toupper(added)
[17:46:53.697]                 for (kk in seq_along(NAMES)) {
[17:46:53.697]                   name <- added[[kk]]
[17:46:53.697]                   NAME <- NAMES[[kk]]
[17:46:53.697]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.697]                     next
[17:46:53.697]                   args[[name]] <- ""
[17:46:53.697]                 }
[17:46:53.697]                 NAMES <- toupper(removed)
[17:46:53.697]                 for (kk in seq_along(NAMES)) {
[17:46:53.697]                   name <- removed[[kk]]
[17:46:53.697]                   NAME <- NAMES[[kk]]
[17:46:53.697]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.697]                     next
[17:46:53.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.697]                 }
[17:46:53.697]                 if (length(args) > 0) 
[17:46:53.697]                   base::do.call(base::Sys.setenv, args = args)
[17:46:53.697]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:53.697]             }
[17:46:53.697]             else {
[17:46:53.697]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:53.697]             }
[17:46:53.697]             {
[17:46:53.697]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:53.697]                   0L) {
[17:46:53.697]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:53.697]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:53.697]                   base::options(opts)
[17:46:53.697]                 }
[17:46:53.697]                 {
[17:46:53.697]                   {
[17:46:53.697]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:53.697]                     NULL
[17:46:53.697]                   }
[17:46:53.697]                   options(future.plan = NULL)
[17:46:53.697]                   if (is.na(NA_character_)) 
[17:46:53.697]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.697]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:53.697]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:53.697]                     .init = FALSE)
[17:46:53.697]                 }
[17:46:53.697]             }
[17:46:53.697]         }
[17:46:53.697]     })
[17:46:53.697]     if (TRUE) {
[17:46:53.697]         base::sink(type = "output", split = FALSE)
[17:46:53.697]         if (TRUE) {
[17:46:53.697]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:53.697]         }
[17:46:53.697]         else {
[17:46:53.697]             ...future.result["stdout"] <- base::list(NULL)
[17:46:53.697]         }
[17:46:53.697]         base::close(...future.stdout)
[17:46:53.697]         ...future.stdout <- NULL
[17:46:53.697]     }
[17:46:53.697]     ...future.result$conditions <- ...future.conditions
[17:46:53.697]     ...future.result$finished <- base::Sys.time()
[17:46:53.697]     ...future.result
[17:46:53.697] }
[17:46:53.701] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[17:46:53.701] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[17:46:53.702] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[17:46:53.702] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[17:46:53.702] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[17:46:53.703] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[17:46:53.703] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[17:46:53.703] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[17:46:53.704] MultisessionFuture started
[17:46:53.704] - Launch lazy future ... done
[17:46:53.704] run() for ‘MultisessionFuture’ ... done
[17:46:53.704] result() for ClusterFuture ...
[17:46:53.704] receiveMessageFromWorker() for ClusterFuture ...
[17:46:53.704] - Validating connection of MultisessionFuture
[17:46:53.710] - received message: FutureResult
[17:46:53.710] - Received FutureResult
[17:46:53.710] - Erased future from FutureRegistry
[17:46:53.710] result() for ClusterFuture ...
[17:46:53.710] - result already collected: FutureResult
[17:46:53.710] result() for ClusterFuture ... done
[17:46:53.711] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:53.711] result() for ClusterFuture ... done
[17:46:53.711] result() for ClusterFuture ...
[17:46:53.711] - result already collected: FutureResult
[17:46:53.711] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[17:46:53.712] getGlobalsAndPackages() ...
[17:46:53.712] Searching for globals...
[17:46:53.716] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:46:53.716] Searching for globals ... DONE
[17:46:53.716] Resolving globals: FALSE
[17:46:53.717] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:46:53.717] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:46:53.717] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:46:53.718] 
[17:46:53.718] getGlobalsAndPackages() ... DONE
[17:46:53.718] run() for ‘Future’ ...
[17:46:53.718] - state: ‘created’
[17:46:53.718] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:53.733] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:53.733] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:53.733]   - Field: ‘node’
[17:46:53.733]   - Field: ‘label’
[17:46:53.733]   - Field: ‘local’
[17:46:53.733]   - Field: ‘owner’
[17:46:53.734]   - Field: ‘envir’
[17:46:53.734]   - Field: ‘workers’
[17:46:53.734]   - Field: ‘packages’
[17:46:53.734]   - Field: ‘gc’
[17:46:53.734]   - Field: ‘conditions’
[17:46:53.734]   - Field: ‘persistent’
[17:46:53.734]   - Field: ‘expr’
[17:46:53.734]   - Field: ‘uuid’
[17:46:53.734]   - Field: ‘seed’
[17:46:53.734]   - Field: ‘version’
[17:46:53.734]   - Field: ‘result’
[17:46:53.734]   - Field: ‘asynchronous’
[17:46:53.735]   - Field: ‘calls’
[17:46:53.735]   - Field: ‘globals’
[17:46:53.735]   - Field: ‘stdout’
[17:46:53.735]   - Field: ‘earlySignal’
[17:46:53.735]   - Field: ‘lazy’
[17:46:53.735]   - Field: ‘state’
[17:46:53.735] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:53.735] - Launch lazy future ...
[17:46:53.735] Packages needed by the future expression (n = 0): <none>
[17:46:53.736] Packages needed by future strategies (n = 0): <none>
[17:46:53.736] {
[17:46:53.736]     {
[17:46:53.736]         {
[17:46:53.736]             ...future.startTime <- base::Sys.time()
[17:46:53.736]             {
[17:46:53.736]                 {
[17:46:53.736]                   {
[17:46:53.736]                     {
[17:46:53.736]                       base::local({
[17:46:53.736]                         has_future <- base::requireNamespace("future", 
[17:46:53.736]                           quietly = TRUE)
[17:46:53.736]                         if (has_future) {
[17:46:53.736]                           ns <- base::getNamespace("future")
[17:46:53.736]                           version <- ns[[".package"]][["version"]]
[17:46:53.736]                           if (is.null(version)) 
[17:46:53.736]                             version <- utils::packageVersion("future")
[17:46:53.736]                         }
[17:46:53.736]                         else {
[17:46:53.736]                           version <- NULL
[17:46:53.736]                         }
[17:46:53.736]                         if (!has_future || version < "1.8.0") {
[17:46:53.736]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:53.736]                             "", base::R.version$version.string), 
[17:46:53.736]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:53.736]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:53.736]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:53.736]                               "release", "version")], collapse = " "), 
[17:46:53.736]                             hostname = base::Sys.info()[["nodename"]])
[17:46:53.736]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:53.736]                             info)
[17:46:53.736]                           info <- base::paste(info, collapse = "; ")
[17:46:53.736]                           if (!has_future) {
[17:46:53.736]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:53.736]                               info)
[17:46:53.736]                           }
[17:46:53.736]                           else {
[17:46:53.736]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:53.736]                               info, version)
[17:46:53.736]                           }
[17:46:53.736]                           base::stop(msg)
[17:46:53.736]                         }
[17:46:53.736]                       })
[17:46:53.736]                     }
[17:46:53.736]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:53.736]                     base::options(mc.cores = 1L)
[17:46:53.736]                   }
[17:46:53.736]                   ...future.strategy.old <- future::plan("list")
[17:46:53.736]                   options(future.plan = NULL)
[17:46:53.736]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.736]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:53.736]                 }
[17:46:53.736]                 ...future.workdir <- getwd()
[17:46:53.736]             }
[17:46:53.736]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:53.736]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:53.736]         }
[17:46:53.736]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:53.736]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:53.736]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:53.736]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:53.736]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:53.736]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:53.736]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:53.736]             base::names(...future.oldOptions))
[17:46:53.736]     }
[17:46:53.736]     if (FALSE) {
[17:46:53.736]     }
[17:46:53.736]     else {
[17:46:53.736]         if (TRUE) {
[17:46:53.736]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:53.736]                 open = "w")
[17:46:53.736]         }
[17:46:53.736]         else {
[17:46:53.736]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:53.736]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:53.736]         }
[17:46:53.736]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:53.736]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:53.736]             base::sink(type = "output", split = FALSE)
[17:46:53.736]             base::close(...future.stdout)
[17:46:53.736]         }, add = TRUE)
[17:46:53.736]     }
[17:46:53.736]     ...future.frame <- base::sys.nframe()
[17:46:53.736]     ...future.conditions <- base::list()
[17:46:53.736]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:53.736]     if (FALSE) {
[17:46:53.736]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:53.736]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:53.736]     }
[17:46:53.736]     ...future.result <- base::tryCatch({
[17:46:53.736]         base::withCallingHandlers({
[17:46:53.736]             ...future.value <- base::withVisible(base::local({
[17:46:53.736]                 ...future.makeSendCondition <- base::local({
[17:46:53.736]                   sendCondition <- NULL
[17:46:53.736]                   function(frame = 1L) {
[17:46:53.736]                     if (is.function(sendCondition)) 
[17:46:53.736]                       return(sendCondition)
[17:46:53.736]                     ns <- getNamespace("parallel")
[17:46:53.736]                     if (exists("sendData", mode = "function", 
[17:46:53.736]                       envir = ns)) {
[17:46:53.736]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:53.736]                         envir = ns)
[17:46:53.736]                       envir <- sys.frame(frame)
[17:46:53.736]                       master <- NULL
[17:46:53.736]                       while (!identical(envir, .GlobalEnv) && 
[17:46:53.736]                         !identical(envir, emptyenv())) {
[17:46:53.736]                         if (exists("master", mode = "list", envir = envir, 
[17:46:53.736]                           inherits = FALSE)) {
[17:46:53.736]                           master <- get("master", mode = "list", 
[17:46:53.736]                             envir = envir, inherits = FALSE)
[17:46:53.736]                           if (inherits(master, c("SOCKnode", 
[17:46:53.736]                             "SOCK0node"))) {
[17:46:53.736]                             sendCondition <<- function(cond) {
[17:46:53.736]                               data <- list(type = "VALUE", value = cond, 
[17:46:53.736]                                 success = TRUE)
[17:46:53.736]                               parallel_sendData(master, data)
[17:46:53.736]                             }
[17:46:53.736]                             return(sendCondition)
[17:46:53.736]                           }
[17:46:53.736]                         }
[17:46:53.736]                         frame <- frame + 1L
[17:46:53.736]                         envir <- sys.frame(frame)
[17:46:53.736]                       }
[17:46:53.736]                     }
[17:46:53.736]                     sendCondition <<- function(cond) NULL
[17:46:53.736]                   }
[17:46:53.736]                 })
[17:46:53.736]                 withCallingHandlers({
[17:46:53.736]                   {
[17:46:53.736]                     outer_function(1L)
[17:46:53.736]                   }
[17:46:53.736]                 }, immediateCondition = function(cond) {
[17:46:53.736]                   sendCondition <- ...future.makeSendCondition()
[17:46:53.736]                   sendCondition(cond)
[17:46:53.736]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.736]                   {
[17:46:53.736]                     inherits <- base::inherits
[17:46:53.736]                     invokeRestart <- base::invokeRestart
[17:46:53.736]                     is.null <- base::is.null
[17:46:53.736]                     muffled <- FALSE
[17:46:53.736]                     if (inherits(cond, "message")) {
[17:46:53.736]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:53.736]                       if (muffled) 
[17:46:53.736]                         invokeRestart("muffleMessage")
[17:46:53.736]                     }
[17:46:53.736]                     else if (inherits(cond, "warning")) {
[17:46:53.736]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:53.736]                       if (muffled) 
[17:46:53.736]                         invokeRestart("muffleWarning")
[17:46:53.736]                     }
[17:46:53.736]                     else if (inherits(cond, "condition")) {
[17:46:53.736]                       if (!is.null(pattern)) {
[17:46:53.736]                         computeRestarts <- base::computeRestarts
[17:46:53.736]                         grepl <- base::grepl
[17:46:53.736]                         restarts <- computeRestarts(cond)
[17:46:53.736]                         for (restart in restarts) {
[17:46:53.736]                           name <- restart$name
[17:46:53.736]                           if (is.null(name)) 
[17:46:53.736]                             next
[17:46:53.736]                           if (!grepl(pattern, name)) 
[17:46:53.736]                             next
[17:46:53.736]                           invokeRestart(restart)
[17:46:53.736]                           muffled <- TRUE
[17:46:53.736]                           break
[17:46:53.736]                         }
[17:46:53.736]                       }
[17:46:53.736]                     }
[17:46:53.736]                     invisible(muffled)
[17:46:53.736]                   }
[17:46:53.736]                   muffleCondition(cond)
[17:46:53.736]                 })
[17:46:53.736]             }))
[17:46:53.736]             future::FutureResult(value = ...future.value$value, 
[17:46:53.736]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.736]                   ...future.rng), globalenv = if (FALSE) 
[17:46:53.736]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:53.736]                     ...future.globalenv.names))
[17:46:53.736]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:53.736]         }, condition = base::local({
[17:46:53.736]             c <- base::c
[17:46:53.736]             inherits <- base::inherits
[17:46:53.736]             invokeRestart <- base::invokeRestart
[17:46:53.736]             length <- base::length
[17:46:53.736]             list <- base::list
[17:46:53.736]             seq.int <- base::seq.int
[17:46:53.736]             signalCondition <- base::signalCondition
[17:46:53.736]             sys.calls <- base::sys.calls
[17:46:53.736]             `[[` <- base::`[[`
[17:46:53.736]             `+` <- base::`+`
[17:46:53.736]             `<<-` <- base::`<<-`
[17:46:53.736]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:53.736]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:53.736]                   3L)]
[17:46:53.736]             }
[17:46:53.736]             function(cond) {
[17:46:53.736]                 is_error <- inherits(cond, "error")
[17:46:53.736]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:53.736]                   NULL)
[17:46:53.736]                 if (is_error) {
[17:46:53.736]                   sessionInformation <- function() {
[17:46:53.736]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:53.736]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:53.736]                       search = base::search(), system = base::Sys.info())
[17:46:53.736]                   }
[17:46:53.736]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.736]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:53.736]                     cond$call), session = sessionInformation(), 
[17:46:53.736]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:53.736]                   signalCondition(cond)
[17:46:53.736]                 }
[17:46:53.736]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:53.736]                 "immediateCondition"))) {
[17:46:53.736]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:53.736]                   ...future.conditions[[length(...future.conditions) + 
[17:46:53.736]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:53.736]                   if (TRUE && !signal) {
[17:46:53.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.736]                     {
[17:46:53.736]                       inherits <- base::inherits
[17:46:53.736]                       invokeRestart <- base::invokeRestart
[17:46:53.736]                       is.null <- base::is.null
[17:46:53.736]                       muffled <- FALSE
[17:46:53.736]                       if (inherits(cond, "message")) {
[17:46:53.736]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.736]                         if (muffled) 
[17:46:53.736]                           invokeRestart("muffleMessage")
[17:46:53.736]                       }
[17:46:53.736]                       else if (inherits(cond, "warning")) {
[17:46:53.736]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.736]                         if (muffled) 
[17:46:53.736]                           invokeRestart("muffleWarning")
[17:46:53.736]                       }
[17:46:53.736]                       else if (inherits(cond, "condition")) {
[17:46:53.736]                         if (!is.null(pattern)) {
[17:46:53.736]                           computeRestarts <- base::computeRestarts
[17:46:53.736]                           grepl <- base::grepl
[17:46:53.736]                           restarts <- computeRestarts(cond)
[17:46:53.736]                           for (restart in restarts) {
[17:46:53.736]                             name <- restart$name
[17:46:53.736]                             if (is.null(name)) 
[17:46:53.736]                               next
[17:46:53.736]                             if (!grepl(pattern, name)) 
[17:46:53.736]                               next
[17:46:53.736]                             invokeRestart(restart)
[17:46:53.736]                             muffled <- TRUE
[17:46:53.736]                             break
[17:46:53.736]                           }
[17:46:53.736]                         }
[17:46:53.736]                       }
[17:46:53.736]                       invisible(muffled)
[17:46:53.736]                     }
[17:46:53.736]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.736]                   }
[17:46:53.736]                 }
[17:46:53.736]                 else {
[17:46:53.736]                   if (TRUE) {
[17:46:53.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:53.736]                     {
[17:46:53.736]                       inherits <- base::inherits
[17:46:53.736]                       invokeRestart <- base::invokeRestart
[17:46:53.736]                       is.null <- base::is.null
[17:46:53.736]                       muffled <- FALSE
[17:46:53.736]                       if (inherits(cond, "message")) {
[17:46:53.736]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:53.736]                         if (muffled) 
[17:46:53.736]                           invokeRestart("muffleMessage")
[17:46:53.736]                       }
[17:46:53.736]                       else if (inherits(cond, "warning")) {
[17:46:53.736]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:53.736]                         if (muffled) 
[17:46:53.736]                           invokeRestart("muffleWarning")
[17:46:53.736]                       }
[17:46:53.736]                       else if (inherits(cond, "condition")) {
[17:46:53.736]                         if (!is.null(pattern)) {
[17:46:53.736]                           computeRestarts <- base::computeRestarts
[17:46:53.736]                           grepl <- base::grepl
[17:46:53.736]                           restarts <- computeRestarts(cond)
[17:46:53.736]                           for (restart in restarts) {
[17:46:53.736]                             name <- restart$name
[17:46:53.736]                             if (is.null(name)) 
[17:46:53.736]                               next
[17:46:53.736]                             if (!grepl(pattern, name)) 
[17:46:53.736]                               next
[17:46:53.736]                             invokeRestart(restart)
[17:46:53.736]                             muffled <- TRUE
[17:46:53.736]                             break
[17:46:53.736]                           }
[17:46:53.736]                         }
[17:46:53.736]                       }
[17:46:53.736]                       invisible(muffled)
[17:46:53.736]                     }
[17:46:53.736]                     muffleCondition(cond, pattern = "^muffle")
[17:46:53.736]                   }
[17:46:53.736]                 }
[17:46:53.736]             }
[17:46:53.736]         }))
[17:46:53.736]     }, error = function(ex) {
[17:46:53.736]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:53.736]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:53.736]                 ...future.rng), started = ...future.startTime, 
[17:46:53.736]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:53.736]             version = "1.8"), class = "FutureResult")
[17:46:53.736]     }, finally = {
[17:46:53.736]         if (!identical(...future.workdir, getwd())) 
[17:46:53.736]             setwd(...future.workdir)
[17:46:53.736]         {
[17:46:53.736]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:53.736]                 ...future.oldOptions$nwarnings <- NULL
[17:46:53.736]             }
[17:46:53.736]             base::options(...future.oldOptions)
[17:46:53.736]             if (.Platform$OS.type == "windows") {
[17:46:53.736]                 old_names <- names(...future.oldEnvVars)
[17:46:53.736]                 envs <- base::Sys.getenv()
[17:46:53.736]                 names <- names(envs)
[17:46:53.736]                 common <- intersect(names, old_names)
[17:46:53.736]                 added <- setdiff(names, old_names)
[17:46:53.736]                 removed <- setdiff(old_names, names)
[17:46:53.736]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:53.736]                   envs[common]]
[17:46:53.736]                 NAMES <- toupper(changed)
[17:46:53.736]                 args <- list()
[17:46:53.736]                 for (kk in seq_along(NAMES)) {
[17:46:53.736]                   name <- changed[[kk]]
[17:46:53.736]                   NAME <- NAMES[[kk]]
[17:46:53.736]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.736]                     next
[17:46:53.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.736]                 }
[17:46:53.736]                 NAMES <- toupper(added)
[17:46:53.736]                 for (kk in seq_along(NAMES)) {
[17:46:53.736]                   name <- added[[kk]]
[17:46:53.736]                   NAME <- NAMES[[kk]]
[17:46:53.736]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.736]                     next
[17:46:53.736]                   args[[name]] <- ""
[17:46:53.736]                 }
[17:46:53.736]                 NAMES <- toupper(removed)
[17:46:53.736]                 for (kk in seq_along(NAMES)) {
[17:46:53.736]                   name <- removed[[kk]]
[17:46:53.736]                   NAME <- NAMES[[kk]]
[17:46:53.736]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:53.736]                     next
[17:46:53.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:53.736]                 }
[17:46:53.736]                 if (length(args) > 0) 
[17:46:53.736]                   base::do.call(base::Sys.setenv, args = args)
[17:46:53.736]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:53.736]             }
[17:46:53.736]             else {
[17:46:53.736]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:53.736]             }
[17:46:53.736]             {
[17:46:53.736]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:53.736]                   0L) {
[17:46:53.736]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:53.736]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:53.736]                   base::options(opts)
[17:46:53.736]                 }
[17:46:53.736]                 {
[17:46:53.736]                   {
[17:46:53.736]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:53.736]                     NULL
[17:46:53.736]                   }
[17:46:53.736]                   options(future.plan = NULL)
[17:46:53.736]                   if (is.na(NA_character_)) 
[17:46:53.736]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:53.736]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:53.736]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:53.736]                     .init = FALSE)
[17:46:53.736]                 }
[17:46:53.736]             }
[17:46:53.736]         }
[17:46:53.736]     })
[17:46:53.736]     if (TRUE) {
[17:46:53.736]         base::sink(type = "output", split = FALSE)
[17:46:53.736]         if (TRUE) {
[17:46:53.736]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:53.736]         }
[17:46:53.736]         else {
[17:46:53.736]             ...future.result["stdout"] <- base::list(NULL)
[17:46:53.736]         }
[17:46:53.736]         base::close(...future.stdout)
[17:46:53.736]         ...future.stdout <- NULL
[17:46:53.736]     }
[17:46:53.736]     ...future.result$conditions <- ...future.conditions
[17:46:53.736]     ...future.result$finished <- base::Sys.time()
[17:46:53.736]     ...future.result
[17:46:53.736] }
[17:46:53.738] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[17:46:53.739] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[17:46:53.739] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[17:46:53.739] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[17:46:53.739] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[17:46:53.740] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[17:46:53.740] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[17:46:53.740] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[17:46:53.741] MultisessionFuture started
[17:46:53.741] - Launch lazy future ... done
[17:46:53.741] run() for ‘MultisessionFuture’ ... done
[17:46:53.741] result() for ClusterFuture ...
[17:46:53.741] receiveMessageFromWorker() for ClusterFuture ...
[17:46:53.741] - Validating connection of MultisessionFuture
[17:46:53.743] - received message: FutureResult
[17:46:53.743] - Received FutureResult
[17:46:53.743] - Erased future from FutureRegistry
[17:46:53.743] result() for ClusterFuture ...
[17:46:53.743] - result already collected: FutureResult
[17:46:53.743] result() for ClusterFuture ... done
[17:46:53.743] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:53.743] result() for ClusterFuture ... done
[17:46:53.743] result() for ClusterFuture ...
[17:46:53.743] - result already collected: FutureResult
[17:46:53.744] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[17:46:53.745] plan(): Setting new future strategy stack:
[17:46:53.745] List of future strategies:
[17:46:53.745] 1. FutureStrategy:
[17:46:53.745]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:53.745]    - tweaked: FALSE
[17:46:53.745]    - call: future::plan(oplan)
[17:46:53.746] plan(): nbrOfWorkers() = 1
> 
