
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[18:04:26.425] plan(): Setting new future strategy stack:
[18:04:26.426] List of future strategies:
[18:04:26.426] 1. sequential:
[18:04:26.426]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.426]    - tweaked: FALSE
[18:04:26.426]    - call: future::plan("sequential")
[18:04:26.449] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[18:04:26.568] plan(): Setting new future strategy stack:
[18:04:26.569] List of future strategies:
[18:04:26.569] 1. sequential:
[18:04:26.569]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.569]    - tweaked: FALSE
[18:04:26.569]    - call: plan(strategy)
[18:04:26.594] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[18:04:26.596] getGlobalsAndPackages() ...
[18:04:26.596] Searching for globals...
[18:04:26.609] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:26.609] Searching for globals ... DONE
[18:04:26.609] Resolving globals: FALSE
[18:04:26.611] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:26.612] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:26.613] - globals: [2] ‘weight’, ‘group’
[18:04:26.613] - packages: [1] ‘stats’
[18:04:26.613] getGlobalsAndPackages() ... DONE
[18:04:26.614] run() for ‘Future’ ...
[18:04:26.614] - state: ‘created’
[18:04:26.615] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:26.615] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:26.616] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:26.616]   - Field: ‘label’
[18:04:26.616]   - Field: ‘local’
[18:04:26.616]   - Field: ‘owner’
[18:04:26.616]   - Field: ‘envir’
[18:04:26.617]   - Field: ‘packages’
[18:04:26.617]   - Field: ‘gc’
[18:04:26.617]   - Field: ‘conditions’
[18:04:26.617]   - Field: ‘expr’
[18:04:26.617]   - Field: ‘uuid’
[18:04:26.618]   - Field: ‘seed’
[18:04:26.618]   - Field: ‘version’
[18:04:26.618]   - Field: ‘result’
[18:04:26.618]   - Field: ‘asynchronous’
[18:04:26.618]   - Field: ‘calls’
[18:04:26.619]   - Field: ‘globals’
[18:04:26.619]   - Field: ‘stdout’
[18:04:26.619]   - Field: ‘earlySignal’
[18:04:26.619]   - Field: ‘lazy’
[18:04:26.619]   - Field: ‘state’
[18:04:26.620] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:26.620] - Launch lazy future ...
[18:04:26.621] Packages needed by the future expression (n = 1): ‘stats’
[18:04:26.621] Packages needed by future strategies (n = 0): <none>
[18:04:26.623] {
[18:04:26.623]     {
[18:04:26.623]         {
[18:04:26.623]             ...future.startTime <- base::Sys.time()
[18:04:26.623]             {
[18:04:26.623]                 {
[18:04:26.623]                   {
[18:04:26.623]                     {
[18:04:26.623]                       base::local({
[18:04:26.623]                         has_future <- base::requireNamespace("future", 
[18:04:26.623]                           quietly = TRUE)
[18:04:26.623]                         if (has_future) {
[18:04:26.623]                           ns <- base::getNamespace("future")
[18:04:26.623]                           version <- ns[[".package"]][["version"]]
[18:04:26.623]                           if (is.null(version)) 
[18:04:26.623]                             version <- utils::packageVersion("future")
[18:04:26.623]                         }
[18:04:26.623]                         else {
[18:04:26.623]                           version <- NULL
[18:04:26.623]                         }
[18:04:26.623]                         if (!has_future || version < "1.8.0") {
[18:04:26.623]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:26.623]                             "", base::R.version$version.string), 
[18:04:26.623]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:26.623]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:26.623]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:26.623]                               "release", "version")], collapse = " "), 
[18:04:26.623]                             hostname = base::Sys.info()[["nodename"]])
[18:04:26.623]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:26.623]                             info)
[18:04:26.623]                           info <- base::paste(info, collapse = "; ")
[18:04:26.623]                           if (!has_future) {
[18:04:26.623]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:26.623]                               info)
[18:04:26.623]                           }
[18:04:26.623]                           else {
[18:04:26.623]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:26.623]                               info, version)
[18:04:26.623]                           }
[18:04:26.623]                           base::stop(msg)
[18:04:26.623]                         }
[18:04:26.623]                       })
[18:04:26.623]                     }
[18:04:26.623]                     base::local({
[18:04:26.623]                       for (pkg in "stats") {
[18:04:26.623]                         base::loadNamespace(pkg)
[18:04:26.623]                         base::library(pkg, character.only = TRUE)
[18:04:26.623]                       }
[18:04:26.623]                     })
[18:04:26.623]                   }
[18:04:26.623]                   ...future.strategy.old <- future::plan("list")
[18:04:26.623]                   options(future.plan = NULL)
[18:04:26.623]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.623]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:26.623]                 }
[18:04:26.623]                 ...future.workdir <- getwd()
[18:04:26.623]             }
[18:04:26.623]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:26.623]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:26.623]         }
[18:04:26.623]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:26.623]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:26.623]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:26.623]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:26.623]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:26.623]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:26.623]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:26.623]             base::names(...future.oldOptions))
[18:04:26.623]     }
[18:04:26.623]     if (FALSE) {
[18:04:26.623]     }
[18:04:26.623]     else {
[18:04:26.623]         if (TRUE) {
[18:04:26.623]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:26.623]                 open = "w")
[18:04:26.623]         }
[18:04:26.623]         else {
[18:04:26.623]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:26.623]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:26.623]         }
[18:04:26.623]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:26.623]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:26.623]             base::sink(type = "output", split = FALSE)
[18:04:26.623]             base::close(...future.stdout)
[18:04:26.623]         }, add = TRUE)
[18:04:26.623]     }
[18:04:26.623]     ...future.frame <- base::sys.nframe()
[18:04:26.623]     ...future.conditions <- base::list()
[18:04:26.623]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:26.623]     if (FALSE) {
[18:04:26.623]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:26.623]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:26.623]     }
[18:04:26.623]     ...future.result <- base::tryCatch({
[18:04:26.623]         base::withCallingHandlers({
[18:04:26.623]             ...future.value <- base::withVisible(base::local({
[18:04:26.623]                 lm(weight ~ group - 1)
[18:04:26.623]             }))
[18:04:26.623]             future::FutureResult(value = ...future.value$value, 
[18:04:26.623]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.623]                   ...future.rng), globalenv = if (FALSE) 
[18:04:26.623]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:26.623]                     ...future.globalenv.names))
[18:04:26.623]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:26.623]         }, condition = base::local({
[18:04:26.623]             c <- base::c
[18:04:26.623]             inherits <- base::inherits
[18:04:26.623]             invokeRestart <- base::invokeRestart
[18:04:26.623]             length <- base::length
[18:04:26.623]             list <- base::list
[18:04:26.623]             seq.int <- base::seq.int
[18:04:26.623]             signalCondition <- base::signalCondition
[18:04:26.623]             sys.calls <- base::sys.calls
[18:04:26.623]             `[[` <- base::`[[`
[18:04:26.623]             `+` <- base::`+`
[18:04:26.623]             `<<-` <- base::`<<-`
[18:04:26.623]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:26.623]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:26.623]                   3L)]
[18:04:26.623]             }
[18:04:26.623]             function(cond) {
[18:04:26.623]                 is_error <- inherits(cond, "error")
[18:04:26.623]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:26.623]                   NULL)
[18:04:26.623]                 if (is_error) {
[18:04:26.623]                   sessionInformation <- function() {
[18:04:26.623]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:26.623]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:26.623]                       search = base::search(), system = base::Sys.info())
[18:04:26.623]                   }
[18:04:26.623]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.623]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:26.623]                     cond$call), session = sessionInformation(), 
[18:04:26.623]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:26.623]                   signalCondition(cond)
[18:04:26.623]                 }
[18:04:26.623]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:26.623]                 "immediateCondition"))) {
[18:04:26.623]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:26.623]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.623]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:26.623]                   if (TRUE && !signal) {
[18:04:26.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.623]                     {
[18:04:26.623]                       inherits <- base::inherits
[18:04:26.623]                       invokeRestart <- base::invokeRestart
[18:04:26.623]                       is.null <- base::is.null
[18:04:26.623]                       muffled <- FALSE
[18:04:26.623]                       if (inherits(cond, "message")) {
[18:04:26.623]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.623]                         if (muffled) 
[18:04:26.623]                           invokeRestart("muffleMessage")
[18:04:26.623]                       }
[18:04:26.623]                       else if (inherits(cond, "warning")) {
[18:04:26.623]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.623]                         if (muffled) 
[18:04:26.623]                           invokeRestart("muffleWarning")
[18:04:26.623]                       }
[18:04:26.623]                       else if (inherits(cond, "condition")) {
[18:04:26.623]                         if (!is.null(pattern)) {
[18:04:26.623]                           computeRestarts <- base::computeRestarts
[18:04:26.623]                           grepl <- base::grepl
[18:04:26.623]                           restarts <- computeRestarts(cond)
[18:04:26.623]                           for (restart in restarts) {
[18:04:26.623]                             name <- restart$name
[18:04:26.623]                             if (is.null(name)) 
[18:04:26.623]                               next
[18:04:26.623]                             if (!grepl(pattern, name)) 
[18:04:26.623]                               next
[18:04:26.623]                             invokeRestart(restart)
[18:04:26.623]                             muffled <- TRUE
[18:04:26.623]                             break
[18:04:26.623]                           }
[18:04:26.623]                         }
[18:04:26.623]                       }
[18:04:26.623]                       invisible(muffled)
[18:04:26.623]                     }
[18:04:26.623]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.623]                   }
[18:04:26.623]                 }
[18:04:26.623]                 else {
[18:04:26.623]                   if (TRUE) {
[18:04:26.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.623]                     {
[18:04:26.623]                       inherits <- base::inherits
[18:04:26.623]                       invokeRestart <- base::invokeRestart
[18:04:26.623]                       is.null <- base::is.null
[18:04:26.623]                       muffled <- FALSE
[18:04:26.623]                       if (inherits(cond, "message")) {
[18:04:26.623]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.623]                         if (muffled) 
[18:04:26.623]                           invokeRestart("muffleMessage")
[18:04:26.623]                       }
[18:04:26.623]                       else if (inherits(cond, "warning")) {
[18:04:26.623]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.623]                         if (muffled) 
[18:04:26.623]                           invokeRestart("muffleWarning")
[18:04:26.623]                       }
[18:04:26.623]                       else if (inherits(cond, "condition")) {
[18:04:26.623]                         if (!is.null(pattern)) {
[18:04:26.623]                           computeRestarts <- base::computeRestarts
[18:04:26.623]                           grepl <- base::grepl
[18:04:26.623]                           restarts <- computeRestarts(cond)
[18:04:26.623]                           for (restart in restarts) {
[18:04:26.623]                             name <- restart$name
[18:04:26.623]                             if (is.null(name)) 
[18:04:26.623]                               next
[18:04:26.623]                             if (!grepl(pattern, name)) 
[18:04:26.623]                               next
[18:04:26.623]                             invokeRestart(restart)
[18:04:26.623]                             muffled <- TRUE
[18:04:26.623]                             break
[18:04:26.623]                           }
[18:04:26.623]                         }
[18:04:26.623]                       }
[18:04:26.623]                       invisible(muffled)
[18:04:26.623]                     }
[18:04:26.623]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.623]                   }
[18:04:26.623]                 }
[18:04:26.623]             }
[18:04:26.623]         }))
[18:04:26.623]     }, error = function(ex) {
[18:04:26.623]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:26.623]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.623]                 ...future.rng), started = ...future.startTime, 
[18:04:26.623]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:26.623]             version = "1.8"), class = "FutureResult")
[18:04:26.623]     }, finally = {
[18:04:26.623]         if (!identical(...future.workdir, getwd())) 
[18:04:26.623]             setwd(...future.workdir)
[18:04:26.623]         {
[18:04:26.623]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:26.623]                 ...future.oldOptions$nwarnings <- NULL
[18:04:26.623]             }
[18:04:26.623]             base::options(...future.oldOptions)
[18:04:26.623]             if (.Platform$OS.type == "windows") {
[18:04:26.623]                 old_names <- names(...future.oldEnvVars)
[18:04:26.623]                 envs <- base::Sys.getenv()
[18:04:26.623]                 names <- names(envs)
[18:04:26.623]                 common <- intersect(names, old_names)
[18:04:26.623]                 added <- setdiff(names, old_names)
[18:04:26.623]                 removed <- setdiff(old_names, names)
[18:04:26.623]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:26.623]                   envs[common]]
[18:04:26.623]                 NAMES <- toupper(changed)
[18:04:26.623]                 args <- list()
[18:04:26.623]                 for (kk in seq_along(NAMES)) {
[18:04:26.623]                   name <- changed[[kk]]
[18:04:26.623]                   NAME <- NAMES[[kk]]
[18:04:26.623]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.623]                     next
[18:04:26.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.623]                 }
[18:04:26.623]                 NAMES <- toupper(added)
[18:04:26.623]                 for (kk in seq_along(NAMES)) {
[18:04:26.623]                   name <- added[[kk]]
[18:04:26.623]                   NAME <- NAMES[[kk]]
[18:04:26.623]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.623]                     next
[18:04:26.623]                   args[[name]] <- ""
[18:04:26.623]                 }
[18:04:26.623]                 NAMES <- toupper(removed)
[18:04:26.623]                 for (kk in seq_along(NAMES)) {
[18:04:26.623]                   name <- removed[[kk]]
[18:04:26.623]                   NAME <- NAMES[[kk]]
[18:04:26.623]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.623]                     next
[18:04:26.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.623]                 }
[18:04:26.623]                 if (length(args) > 0) 
[18:04:26.623]                   base::do.call(base::Sys.setenv, args = args)
[18:04:26.623]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:26.623]             }
[18:04:26.623]             else {
[18:04:26.623]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:26.623]             }
[18:04:26.623]             {
[18:04:26.623]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:26.623]                   0L) {
[18:04:26.623]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:26.623]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:26.623]                   base::options(opts)
[18:04:26.623]                 }
[18:04:26.623]                 {
[18:04:26.623]                   {
[18:04:26.623]                     NULL
[18:04:26.623]                     RNGkind("Mersenne-Twister")
[18:04:26.623]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:26.623]                       inherits = FALSE)
[18:04:26.623]                   }
[18:04:26.623]                   options(future.plan = NULL)
[18:04:26.623]                   if (is.na(NA_character_)) 
[18:04:26.623]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.623]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:26.623]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:26.623]                     .init = FALSE)
[18:04:26.623]                 }
[18:04:26.623]             }
[18:04:26.623]         }
[18:04:26.623]     })
[18:04:26.623]     if (TRUE) {
[18:04:26.623]         base::sink(type = "output", split = FALSE)
[18:04:26.623]         if (TRUE) {
[18:04:26.623]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:26.623]         }
[18:04:26.623]         else {
[18:04:26.623]             ...future.result["stdout"] <- base::list(NULL)
[18:04:26.623]         }
[18:04:26.623]         base::close(...future.stdout)
[18:04:26.623]         ...future.stdout <- NULL
[18:04:26.623]     }
[18:04:26.623]     ...future.result$conditions <- ...future.conditions
[18:04:26.623]     ...future.result$finished <- base::Sys.time()
[18:04:26.623]     ...future.result
[18:04:26.623] }
[18:04:26.626] assign_globals() ...
[18:04:26.627] List of 2
[18:04:26.627]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[18:04:26.627]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[18:04:26.627]  - attr(*, "where")=List of 2
[18:04:26.627]   ..$ weight:<environment: R_EmptyEnv> 
[18:04:26.627]   ..$ group :<environment: R_EmptyEnv> 
[18:04:26.627]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:26.627]  - attr(*, "resolved")= logi FALSE
[18:04:26.627]  - attr(*, "total_size")= num 896
[18:04:26.627]  - attr(*, "already-done")= logi TRUE
[18:04:26.633] - copied ‘weight’ to environment
[18:04:26.633] - copied ‘group’ to environment
[18:04:26.633] assign_globals() ... done
[18:04:26.634] plan(): Setting new future strategy stack:
[18:04:26.634] List of future strategies:
[18:04:26.634] 1. sequential:
[18:04:26.634]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.634]    - tweaked: FALSE
[18:04:26.634]    - call: NULL
[18:04:26.635] plan(): nbrOfWorkers() = 1
[18:04:26.639] plan(): Setting new future strategy stack:
[18:04:26.639] List of future strategies:
[18:04:26.639] 1. sequential:
[18:04:26.639]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.639]    - tweaked: FALSE
[18:04:26.639]    - call: plan(strategy)
[18:04:26.640] plan(): nbrOfWorkers() = 1
[18:04:26.640] SequentialFuture started (and completed)
[18:04:26.641] - Launch lazy future ... done
[18:04:26.641] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[18:04:26.646] getGlobalsAndPackages() ...
[18:04:26.647] Searching for globals...
[18:04:26.649] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:26.650] Searching for globals ... DONE
[18:04:26.650] Resolving globals: FALSE
[18:04:26.651] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:26.652] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:26.652] - globals: [2] ‘weight’, ‘group’
[18:04:26.652] - packages: [1] ‘stats’
[18:04:26.652] getGlobalsAndPackages() ... DONE
[18:04:26.653] run() for ‘Future’ ...
[18:04:26.653] - state: ‘created’
[18:04:26.653] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:26.654] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:26.654] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:26.654]   - Field: ‘label’
[18:04:26.655]   - Field: ‘local’
[18:04:26.655]   - Field: ‘owner’
[18:04:26.655]   - Field: ‘envir’
[18:04:26.655]   - Field: ‘packages’
[18:04:26.655]   - Field: ‘gc’
[18:04:26.656]   - Field: ‘conditions’
[18:04:26.656]   - Field: ‘expr’
[18:04:26.656]   - Field: ‘uuid’
[18:04:26.656]   - Field: ‘seed’
[18:04:26.656]   - Field: ‘version’
[18:04:26.657]   - Field: ‘result’
[18:04:26.657]   - Field: ‘asynchronous’
[18:04:26.661]   - Field: ‘calls’
[18:04:26.661]   - Field: ‘globals’
[18:04:26.661]   - Field: ‘stdout’
[18:04:26.661]   - Field: ‘earlySignal’
[18:04:26.661]   - Field: ‘lazy’
[18:04:26.662]   - Field: ‘state’
[18:04:26.662] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:26.662] - Launch lazy future ...
[18:04:26.662] Packages needed by the future expression (n = 1): ‘stats’
[18:04:26.663] Packages needed by future strategies (n = 0): <none>
[18:04:26.664] {
[18:04:26.664]     {
[18:04:26.664]         {
[18:04:26.664]             ...future.startTime <- base::Sys.time()
[18:04:26.664]             {
[18:04:26.664]                 {
[18:04:26.664]                   {
[18:04:26.664]                     {
[18:04:26.664]                       base::local({
[18:04:26.664]                         has_future <- base::requireNamespace("future", 
[18:04:26.664]                           quietly = TRUE)
[18:04:26.664]                         if (has_future) {
[18:04:26.664]                           ns <- base::getNamespace("future")
[18:04:26.664]                           version <- ns[[".package"]][["version"]]
[18:04:26.664]                           if (is.null(version)) 
[18:04:26.664]                             version <- utils::packageVersion("future")
[18:04:26.664]                         }
[18:04:26.664]                         else {
[18:04:26.664]                           version <- NULL
[18:04:26.664]                         }
[18:04:26.664]                         if (!has_future || version < "1.8.0") {
[18:04:26.664]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:26.664]                             "", base::R.version$version.string), 
[18:04:26.664]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:26.664]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:26.664]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:26.664]                               "release", "version")], collapse = " "), 
[18:04:26.664]                             hostname = base::Sys.info()[["nodename"]])
[18:04:26.664]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:26.664]                             info)
[18:04:26.664]                           info <- base::paste(info, collapse = "; ")
[18:04:26.664]                           if (!has_future) {
[18:04:26.664]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:26.664]                               info)
[18:04:26.664]                           }
[18:04:26.664]                           else {
[18:04:26.664]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:26.664]                               info, version)
[18:04:26.664]                           }
[18:04:26.664]                           base::stop(msg)
[18:04:26.664]                         }
[18:04:26.664]                       })
[18:04:26.664]                     }
[18:04:26.664]                     base::local({
[18:04:26.664]                       for (pkg in "stats") {
[18:04:26.664]                         base::loadNamespace(pkg)
[18:04:26.664]                         base::library(pkg, character.only = TRUE)
[18:04:26.664]                       }
[18:04:26.664]                     })
[18:04:26.664]                   }
[18:04:26.664]                   ...future.strategy.old <- future::plan("list")
[18:04:26.664]                   options(future.plan = NULL)
[18:04:26.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:26.664]                 }
[18:04:26.664]                 ...future.workdir <- getwd()
[18:04:26.664]             }
[18:04:26.664]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:26.664]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:26.664]         }
[18:04:26.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:26.664]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:26.664]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:26.664]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:26.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:26.664]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:26.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:26.664]             base::names(...future.oldOptions))
[18:04:26.664]     }
[18:04:26.664]     if (FALSE) {
[18:04:26.664]     }
[18:04:26.664]     else {
[18:04:26.664]         if (TRUE) {
[18:04:26.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:26.664]                 open = "w")
[18:04:26.664]         }
[18:04:26.664]         else {
[18:04:26.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:26.664]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:26.664]         }
[18:04:26.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:26.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:26.664]             base::sink(type = "output", split = FALSE)
[18:04:26.664]             base::close(...future.stdout)
[18:04:26.664]         }, add = TRUE)
[18:04:26.664]     }
[18:04:26.664]     ...future.frame <- base::sys.nframe()
[18:04:26.664]     ...future.conditions <- base::list()
[18:04:26.664]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:26.664]     if (FALSE) {
[18:04:26.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:26.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:26.664]     }
[18:04:26.664]     ...future.result <- base::tryCatch({
[18:04:26.664]         base::withCallingHandlers({
[18:04:26.664]             ...future.value <- base::withVisible(base::local({
[18:04:26.664]                 lm(weight ~ group - 1)
[18:04:26.664]             }))
[18:04:26.664]             future::FutureResult(value = ...future.value$value, 
[18:04:26.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.664]                   ...future.rng), globalenv = if (FALSE) 
[18:04:26.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:26.664]                     ...future.globalenv.names))
[18:04:26.664]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:26.664]         }, condition = base::local({
[18:04:26.664]             c <- base::c
[18:04:26.664]             inherits <- base::inherits
[18:04:26.664]             invokeRestart <- base::invokeRestart
[18:04:26.664]             length <- base::length
[18:04:26.664]             list <- base::list
[18:04:26.664]             seq.int <- base::seq.int
[18:04:26.664]             signalCondition <- base::signalCondition
[18:04:26.664]             sys.calls <- base::sys.calls
[18:04:26.664]             `[[` <- base::`[[`
[18:04:26.664]             `+` <- base::`+`
[18:04:26.664]             `<<-` <- base::`<<-`
[18:04:26.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:26.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:26.664]                   3L)]
[18:04:26.664]             }
[18:04:26.664]             function(cond) {
[18:04:26.664]                 is_error <- inherits(cond, "error")
[18:04:26.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:26.664]                   NULL)
[18:04:26.664]                 if (is_error) {
[18:04:26.664]                   sessionInformation <- function() {
[18:04:26.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:26.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:26.664]                       search = base::search(), system = base::Sys.info())
[18:04:26.664]                   }
[18:04:26.664]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:26.664]                     cond$call), session = sessionInformation(), 
[18:04:26.664]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:26.664]                   signalCondition(cond)
[18:04:26.664]                 }
[18:04:26.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:26.664]                 "immediateCondition"))) {
[18:04:26.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:26.664]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:26.664]                   if (TRUE && !signal) {
[18:04:26.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.664]                     {
[18:04:26.664]                       inherits <- base::inherits
[18:04:26.664]                       invokeRestart <- base::invokeRestart
[18:04:26.664]                       is.null <- base::is.null
[18:04:26.664]                       muffled <- FALSE
[18:04:26.664]                       if (inherits(cond, "message")) {
[18:04:26.664]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.664]                         if (muffled) 
[18:04:26.664]                           invokeRestart("muffleMessage")
[18:04:26.664]                       }
[18:04:26.664]                       else if (inherits(cond, "warning")) {
[18:04:26.664]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.664]                         if (muffled) 
[18:04:26.664]                           invokeRestart("muffleWarning")
[18:04:26.664]                       }
[18:04:26.664]                       else if (inherits(cond, "condition")) {
[18:04:26.664]                         if (!is.null(pattern)) {
[18:04:26.664]                           computeRestarts <- base::computeRestarts
[18:04:26.664]                           grepl <- base::grepl
[18:04:26.664]                           restarts <- computeRestarts(cond)
[18:04:26.664]                           for (restart in restarts) {
[18:04:26.664]                             name <- restart$name
[18:04:26.664]                             if (is.null(name)) 
[18:04:26.664]                               next
[18:04:26.664]                             if (!grepl(pattern, name)) 
[18:04:26.664]                               next
[18:04:26.664]                             invokeRestart(restart)
[18:04:26.664]                             muffled <- TRUE
[18:04:26.664]                             break
[18:04:26.664]                           }
[18:04:26.664]                         }
[18:04:26.664]                       }
[18:04:26.664]                       invisible(muffled)
[18:04:26.664]                     }
[18:04:26.664]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.664]                   }
[18:04:26.664]                 }
[18:04:26.664]                 else {
[18:04:26.664]                   if (TRUE) {
[18:04:26.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.664]                     {
[18:04:26.664]                       inherits <- base::inherits
[18:04:26.664]                       invokeRestart <- base::invokeRestart
[18:04:26.664]                       is.null <- base::is.null
[18:04:26.664]                       muffled <- FALSE
[18:04:26.664]                       if (inherits(cond, "message")) {
[18:04:26.664]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.664]                         if (muffled) 
[18:04:26.664]                           invokeRestart("muffleMessage")
[18:04:26.664]                       }
[18:04:26.664]                       else if (inherits(cond, "warning")) {
[18:04:26.664]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.664]                         if (muffled) 
[18:04:26.664]                           invokeRestart("muffleWarning")
[18:04:26.664]                       }
[18:04:26.664]                       else if (inherits(cond, "condition")) {
[18:04:26.664]                         if (!is.null(pattern)) {
[18:04:26.664]                           computeRestarts <- base::computeRestarts
[18:04:26.664]                           grepl <- base::grepl
[18:04:26.664]                           restarts <- computeRestarts(cond)
[18:04:26.664]                           for (restart in restarts) {
[18:04:26.664]                             name <- restart$name
[18:04:26.664]                             if (is.null(name)) 
[18:04:26.664]                               next
[18:04:26.664]                             if (!grepl(pattern, name)) 
[18:04:26.664]                               next
[18:04:26.664]                             invokeRestart(restart)
[18:04:26.664]                             muffled <- TRUE
[18:04:26.664]                             break
[18:04:26.664]                           }
[18:04:26.664]                         }
[18:04:26.664]                       }
[18:04:26.664]                       invisible(muffled)
[18:04:26.664]                     }
[18:04:26.664]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.664]                   }
[18:04:26.664]                 }
[18:04:26.664]             }
[18:04:26.664]         }))
[18:04:26.664]     }, error = function(ex) {
[18:04:26.664]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:26.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.664]                 ...future.rng), started = ...future.startTime, 
[18:04:26.664]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:26.664]             version = "1.8"), class = "FutureResult")
[18:04:26.664]     }, finally = {
[18:04:26.664]         if (!identical(...future.workdir, getwd())) 
[18:04:26.664]             setwd(...future.workdir)
[18:04:26.664]         {
[18:04:26.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:26.664]                 ...future.oldOptions$nwarnings <- NULL
[18:04:26.664]             }
[18:04:26.664]             base::options(...future.oldOptions)
[18:04:26.664]             if (.Platform$OS.type == "windows") {
[18:04:26.664]                 old_names <- names(...future.oldEnvVars)
[18:04:26.664]                 envs <- base::Sys.getenv()
[18:04:26.664]                 names <- names(envs)
[18:04:26.664]                 common <- intersect(names, old_names)
[18:04:26.664]                 added <- setdiff(names, old_names)
[18:04:26.664]                 removed <- setdiff(old_names, names)
[18:04:26.664]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:26.664]                   envs[common]]
[18:04:26.664]                 NAMES <- toupper(changed)
[18:04:26.664]                 args <- list()
[18:04:26.664]                 for (kk in seq_along(NAMES)) {
[18:04:26.664]                   name <- changed[[kk]]
[18:04:26.664]                   NAME <- NAMES[[kk]]
[18:04:26.664]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.664]                     next
[18:04:26.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.664]                 }
[18:04:26.664]                 NAMES <- toupper(added)
[18:04:26.664]                 for (kk in seq_along(NAMES)) {
[18:04:26.664]                   name <- added[[kk]]
[18:04:26.664]                   NAME <- NAMES[[kk]]
[18:04:26.664]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.664]                     next
[18:04:26.664]                   args[[name]] <- ""
[18:04:26.664]                 }
[18:04:26.664]                 NAMES <- toupper(removed)
[18:04:26.664]                 for (kk in seq_along(NAMES)) {
[18:04:26.664]                   name <- removed[[kk]]
[18:04:26.664]                   NAME <- NAMES[[kk]]
[18:04:26.664]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.664]                     next
[18:04:26.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.664]                 }
[18:04:26.664]                 if (length(args) > 0) 
[18:04:26.664]                   base::do.call(base::Sys.setenv, args = args)
[18:04:26.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:26.664]             }
[18:04:26.664]             else {
[18:04:26.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:26.664]             }
[18:04:26.664]             {
[18:04:26.664]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:26.664]                   0L) {
[18:04:26.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:26.664]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:26.664]                   base::options(opts)
[18:04:26.664]                 }
[18:04:26.664]                 {
[18:04:26.664]                   {
[18:04:26.664]                     NULL
[18:04:26.664]                     RNGkind("Mersenne-Twister")
[18:04:26.664]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:26.664]                       inherits = FALSE)
[18:04:26.664]                   }
[18:04:26.664]                   options(future.plan = NULL)
[18:04:26.664]                   if (is.na(NA_character_)) 
[18:04:26.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:26.664]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:26.664]                     .init = FALSE)
[18:04:26.664]                 }
[18:04:26.664]             }
[18:04:26.664]         }
[18:04:26.664]     })
[18:04:26.664]     if (TRUE) {
[18:04:26.664]         base::sink(type = "output", split = FALSE)
[18:04:26.664]         if (TRUE) {
[18:04:26.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:26.664]         }
[18:04:26.664]         else {
[18:04:26.664]             ...future.result["stdout"] <- base::list(NULL)
[18:04:26.664]         }
[18:04:26.664]         base::close(...future.stdout)
[18:04:26.664]         ...future.stdout <- NULL
[18:04:26.664]     }
[18:04:26.664]     ...future.result$conditions <- ...future.conditions
[18:04:26.664]     ...future.result$finished <- base::Sys.time()
[18:04:26.664]     ...future.result
[18:04:26.664] }
[18:04:26.667] assign_globals() ...
[18:04:26.667] List of 2
[18:04:26.667]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[18:04:26.667]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[18:04:26.667]  - attr(*, "where")=List of 2
[18:04:26.667]   ..$ weight:<environment: R_EmptyEnv> 
[18:04:26.667]   ..$ group :<environment: R_EmptyEnv> 
[18:04:26.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:26.667]  - attr(*, "resolved")= logi FALSE
[18:04:26.667]  - attr(*, "total_size")= num 896
[18:04:26.667]  - attr(*, "already-done")= logi TRUE
[18:04:26.674] - copied ‘weight’ to environment
[18:04:26.674] - copied ‘group’ to environment
[18:04:26.674] assign_globals() ... done
[18:04:26.675] plan(): Setting new future strategy stack:
[18:04:26.675] List of future strategies:
[18:04:26.675] 1. sequential:
[18:04:26.675]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.675]    - tweaked: FALSE
[18:04:26.675]    - call: NULL
[18:04:26.676] plan(): nbrOfWorkers() = 1
[18:04:26.679] plan(): Setting new future strategy stack:
[18:04:26.679] List of future strategies:
[18:04:26.679] 1. sequential:
[18:04:26.679]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.679]    - tweaked: FALSE
[18:04:26.679]    - call: plan(strategy)
[18:04:26.680] plan(): nbrOfWorkers() = 1
[18:04:26.680] SequentialFuture started (and completed)
[18:04:26.680] - Launch lazy future ... done
[18:04:26.681] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[18:04:26.685] getGlobalsAndPackages() ...
[18:04:26.686] Searching for globals...
[18:04:26.689] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:26.689] Searching for globals ... DONE
[18:04:26.689] Resolving globals: FALSE
[18:04:26.690] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:26.691] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:26.691] - globals: [2] ‘weight’, ‘group’
[18:04:26.691] - packages: [1] ‘stats’
[18:04:26.691] getGlobalsAndPackages() ... DONE
[18:04:26.692] run() for ‘Future’ ...
[18:04:26.692] - state: ‘created’
[18:04:26.692] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:26.693] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:26.693] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:26.693]   - Field: ‘label’
[18:04:26.694]   - Field: ‘local’
[18:04:26.694]   - Field: ‘owner’
[18:04:26.694]   - Field: ‘envir’
[18:04:26.694]   - Field: ‘packages’
[18:04:26.694]   - Field: ‘gc’
[18:04:26.695]   - Field: ‘conditions’
[18:04:26.695]   - Field: ‘expr’
[18:04:26.695]   - Field: ‘uuid’
[18:04:26.695]   - Field: ‘seed’
[18:04:26.695]   - Field: ‘version’
[18:04:26.696]   - Field: ‘result’
[18:04:26.696]   - Field: ‘asynchronous’
[18:04:26.696]   - Field: ‘calls’
[18:04:26.696]   - Field: ‘globals’
[18:04:26.696]   - Field: ‘stdout’
[18:04:26.697]   - Field: ‘earlySignal’
[18:04:26.697]   - Field: ‘lazy’
[18:04:26.697]   - Field: ‘state’
[18:04:26.697] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:26.697] - Launch lazy future ...
[18:04:26.698] Packages needed by the future expression (n = 1): ‘stats’
[18:04:26.698] Packages needed by future strategies (n = 0): <none>
[18:04:26.699] {
[18:04:26.699]     {
[18:04:26.699]         {
[18:04:26.699]             ...future.startTime <- base::Sys.time()
[18:04:26.699]             {
[18:04:26.699]                 {
[18:04:26.699]                   {
[18:04:26.699]                     {
[18:04:26.699]                       base::local({
[18:04:26.699]                         has_future <- base::requireNamespace("future", 
[18:04:26.699]                           quietly = TRUE)
[18:04:26.699]                         if (has_future) {
[18:04:26.699]                           ns <- base::getNamespace("future")
[18:04:26.699]                           version <- ns[[".package"]][["version"]]
[18:04:26.699]                           if (is.null(version)) 
[18:04:26.699]                             version <- utils::packageVersion("future")
[18:04:26.699]                         }
[18:04:26.699]                         else {
[18:04:26.699]                           version <- NULL
[18:04:26.699]                         }
[18:04:26.699]                         if (!has_future || version < "1.8.0") {
[18:04:26.699]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:26.699]                             "", base::R.version$version.string), 
[18:04:26.699]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:26.699]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:26.699]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:26.699]                               "release", "version")], collapse = " "), 
[18:04:26.699]                             hostname = base::Sys.info()[["nodename"]])
[18:04:26.699]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:26.699]                             info)
[18:04:26.699]                           info <- base::paste(info, collapse = "; ")
[18:04:26.699]                           if (!has_future) {
[18:04:26.699]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:26.699]                               info)
[18:04:26.699]                           }
[18:04:26.699]                           else {
[18:04:26.699]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:26.699]                               info, version)
[18:04:26.699]                           }
[18:04:26.699]                           base::stop(msg)
[18:04:26.699]                         }
[18:04:26.699]                       })
[18:04:26.699]                     }
[18:04:26.699]                     base::local({
[18:04:26.699]                       for (pkg in "stats") {
[18:04:26.699]                         base::loadNamespace(pkg)
[18:04:26.699]                         base::library(pkg, character.only = TRUE)
[18:04:26.699]                       }
[18:04:26.699]                     })
[18:04:26.699]                   }
[18:04:26.699]                   ...future.strategy.old <- future::plan("list")
[18:04:26.699]                   options(future.plan = NULL)
[18:04:26.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:26.699]                 }
[18:04:26.699]                 ...future.workdir <- getwd()
[18:04:26.699]             }
[18:04:26.699]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:26.699]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:26.699]         }
[18:04:26.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:26.699]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:26.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:26.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:26.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:26.699]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:26.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:26.699]             base::names(...future.oldOptions))
[18:04:26.699]     }
[18:04:26.699]     if (FALSE) {
[18:04:26.699]     }
[18:04:26.699]     else {
[18:04:26.699]         if (TRUE) {
[18:04:26.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:26.699]                 open = "w")
[18:04:26.699]         }
[18:04:26.699]         else {
[18:04:26.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:26.699]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:26.699]         }
[18:04:26.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:26.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:26.699]             base::sink(type = "output", split = FALSE)
[18:04:26.699]             base::close(...future.stdout)
[18:04:26.699]         }, add = TRUE)
[18:04:26.699]     }
[18:04:26.699]     ...future.frame <- base::sys.nframe()
[18:04:26.699]     ...future.conditions <- base::list()
[18:04:26.699]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:26.699]     if (FALSE) {
[18:04:26.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:26.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:26.699]     }
[18:04:26.699]     ...future.result <- base::tryCatch({
[18:04:26.699]         base::withCallingHandlers({
[18:04:26.699]             ...future.value <- base::withVisible(base::local({
[18:04:26.699]                 lm(weight ~ group - 1)
[18:04:26.699]             }))
[18:04:26.699]             future::FutureResult(value = ...future.value$value, 
[18:04:26.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.699]                   ...future.rng), globalenv = if (FALSE) 
[18:04:26.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:26.699]                     ...future.globalenv.names))
[18:04:26.699]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:26.699]         }, condition = base::local({
[18:04:26.699]             c <- base::c
[18:04:26.699]             inherits <- base::inherits
[18:04:26.699]             invokeRestart <- base::invokeRestart
[18:04:26.699]             length <- base::length
[18:04:26.699]             list <- base::list
[18:04:26.699]             seq.int <- base::seq.int
[18:04:26.699]             signalCondition <- base::signalCondition
[18:04:26.699]             sys.calls <- base::sys.calls
[18:04:26.699]             `[[` <- base::`[[`
[18:04:26.699]             `+` <- base::`+`
[18:04:26.699]             `<<-` <- base::`<<-`
[18:04:26.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:26.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:26.699]                   3L)]
[18:04:26.699]             }
[18:04:26.699]             function(cond) {
[18:04:26.699]                 is_error <- inherits(cond, "error")
[18:04:26.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:26.699]                   NULL)
[18:04:26.699]                 if (is_error) {
[18:04:26.699]                   sessionInformation <- function() {
[18:04:26.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:26.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:26.699]                       search = base::search(), system = base::Sys.info())
[18:04:26.699]                   }
[18:04:26.699]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:26.699]                     cond$call), session = sessionInformation(), 
[18:04:26.699]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:26.699]                   signalCondition(cond)
[18:04:26.699]                 }
[18:04:26.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:26.699]                 "immediateCondition"))) {
[18:04:26.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:26.699]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:26.699]                   if (TRUE && !signal) {
[18:04:26.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.699]                     {
[18:04:26.699]                       inherits <- base::inherits
[18:04:26.699]                       invokeRestart <- base::invokeRestart
[18:04:26.699]                       is.null <- base::is.null
[18:04:26.699]                       muffled <- FALSE
[18:04:26.699]                       if (inherits(cond, "message")) {
[18:04:26.699]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.699]                         if (muffled) 
[18:04:26.699]                           invokeRestart("muffleMessage")
[18:04:26.699]                       }
[18:04:26.699]                       else if (inherits(cond, "warning")) {
[18:04:26.699]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.699]                         if (muffled) 
[18:04:26.699]                           invokeRestart("muffleWarning")
[18:04:26.699]                       }
[18:04:26.699]                       else if (inherits(cond, "condition")) {
[18:04:26.699]                         if (!is.null(pattern)) {
[18:04:26.699]                           computeRestarts <- base::computeRestarts
[18:04:26.699]                           grepl <- base::grepl
[18:04:26.699]                           restarts <- computeRestarts(cond)
[18:04:26.699]                           for (restart in restarts) {
[18:04:26.699]                             name <- restart$name
[18:04:26.699]                             if (is.null(name)) 
[18:04:26.699]                               next
[18:04:26.699]                             if (!grepl(pattern, name)) 
[18:04:26.699]                               next
[18:04:26.699]                             invokeRestart(restart)
[18:04:26.699]                             muffled <- TRUE
[18:04:26.699]                             break
[18:04:26.699]                           }
[18:04:26.699]                         }
[18:04:26.699]                       }
[18:04:26.699]                       invisible(muffled)
[18:04:26.699]                     }
[18:04:26.699]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.699]                   }
[18:04:26.699]                 }
[18:04:26.699]                 else {
[18:04:26.699]                   if (TRUE) {
[18:04:26.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.699]                     {
[18:04:26.699]                       inherits <- base::inherits
[18:04:26.699]                       invokeRestart <- base::invokeRestart
[18:04:26.699]                       is.null <- base::is.null
[18:04:26.699]                       muffled <- FALSE
[18:04:26.699]                       if (inherits(cond, "message")) {
[18:04:26.699]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.699]                         if (muffled) 
[18:04:26.699]                           invokeRestart("muffleMessage")
[18:04:26.699]                       }
[18:04:26.699]                       else if (inherits(cond, "warning")) {
[18:04:26.699]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.699]                         if (muffled) 
[18:04:26.699]                           invokeRestart("muffleWarning")
[18:04:26.699]                       }
[18:04:26.699]                       else if (inherits(cond, "condition")) {
[18:04:26.699]                         if (!is.null(pattern)) {
[18:04:26.699]                           computeRestarts <- base::computeRestarts
[18:04:26.699]                           grepl <- base::grepl
[18:04:26.699]                           restarts <- computeRestarts(cond)
[18:04:26.699]                           for (restart in restarts) {
[18:04:26.699]                             name <- restart$name
[18:04:26.699]                             if (is.null(name)) 
[18:04:26.699]                               next
[18:04:26.699]                             if (!grepl(pattern, name)) 
[18:04:26.699]                               next
[18:04:26.699]                             invokeRestart(restart)
[18:04:26.699]                             muffled <- TRUE
[18:04:26.699]                             break
[18:04:26.699]                           }
[18:04:26.699]                         }
[18:04:26.699]                       }
[18:04:26.699]                       invisible(muffled)
[18:04:26.699]                     }
[18:04:26.699]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.699]                   }
[18:04:26.699]                 }
[18:04:26.699]             }
[18:04:26.699]         }))
[18:04:26.699]     }, error = function(ex) {
[18:04:26.699]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:26.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.699]                 ...future.rng), started = ...future.startTime, 
[18:04:26.699]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:26.699]             version = "1.8"), class = "FutureResult")
[18:04:26.699]     }, finally = {
[18:04:26.699]         if (!identical(...future.workdir, getwd())) 
[18:04:26.699]             setwd(...future.workdir)
[18:04:26.699]         {
[18:04:26.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:26.699]                 ...future.oldOptions$nwarnings <- NULL
[18:04:26.699]             }
[18:04:26.699]             base::options(...future.oldOptions)
[18:04:26.699]             if (.Platform$OS.type == "windows") {
[18:04:26.699]                 old_names <- names(...future.oldEnvVars)
[18:04:26.699]                 envs <- base::Sys.getenv()
[18:04:26.699]                 names <- names(envs)
[18:04:26.699]                 common <- intersect(names, old_names)
[18:04:26.699]                 added <- setdiff(names, old_names)
[18:04:26.699]                 removed <- setdiff(old_names, names)
[18:04:26.699]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:26.699]                   envs[common]]
[18:04:26.699]                 NAMES <- toupper(changed)
[18:04:26.699]                 args <- list()
[18:04:26.699]                 for (kk in seq_along(NAMES)) {
[18:04:26.699]                   name <- changed[[kk]]
[18:04:26.699]                   NAME <- NAMES[[kk]]
[18:04:26.699]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.699]                     next
[18:04:26.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.699]                 }
[18:04:26.699]                 NAMES <- toupper(added)
[18:04:26.699]                 for (kk in seq_along(NAMES)) {
[18:04:26.699]                   name <- added[[kk]]
[18:04:26.699]                   NAME <- NAMES[[kk]]
[18:04:26.699]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.699]                     next
[18:04:26.699]                   args[[name]] <- ""
[18:04:26.699]                 }
[18:04:26.699]                 NAMES <- toupper(removed)
[18:04:26.699]                 for (kk in seq_along(NAMES)) {
[18:04:26.699]                   name <- removed[[kk]]
[18:04:26.699]                   NAME <- NAMES[[kk]]
[18:04:26.699]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.699]                     next
[18:04:26.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.699]                 }
[18:04:26.699]                 if (length(args) > 0) 
[18:04:26.699]                   base::do.call(base::Sys.setenv, args = args)
[18:04:26.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:26.699]             }
[18:04:26.699]             else {
[18:04:26.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:26.699]             }
[18:04:26.699]             {
[18:04:26.699]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:26.699]                   0L) {
[18:04:26.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:26.699]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:26.699]                   base::options(opts)
[18:04:26.699]                 }
[18:04:26.699]                 {
[18:04:26.699]                   {
[18:04:26.699]                     NULL
[18:04:26.699]                     RNGkind("Mersenne-Twister")
[18:04:26.699]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:26.699]                       inherits = FALSE)
[18:04:26.699]                   }
[18:04:26.699]                   options(future.plan = NULL)
[18:04:26.699]                   if (is.na(NA_character_)) 
[18:04:26.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:26.699]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:26.699]                     .init = FALSE)
[18:04:26.699]                 }
[18:04:26.699]             }
[18:04:26.699]         }
[18:04:26.699]     })
[18:04:26.699]     if (TRUE) {
[18:04:26.699]         base::sink(type = "output", split = FALSE)
[18:04:26.699]         if (TRUE) {
[18:04:26.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:26.699]         }
[18:04:26.699]         else {
[18:04:26.699]             ...future.result["stdout"] <- base::list(NULL)
[18:04:26.699]         }
[18:04:26.699]         base::close(...future.stdout)
[18:04:26.699]         ...future.stdout <- NULL
[18:04:26.699]     }
[18:04:26.699]     ...future.result$conditions <- ...future.conditions
[18:04:26.699]     ...future.result$finished <- base::Sys.time()
[18:04:26.699]     ...future.result
[18:04:26.699] }
[18:04:26.702] assign_globals() ...
[18:04:26.702] List of 2
[18:04:26.702]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[18:04:26.702]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[18:04:26.702]  - attr(*, "where")=List of 2
[18:04:26.702]   ..$ weight:<environment: R_EmptyEnv> 
[18:04:26.702]   ..$ group :<environment: R_EmptyEnv> 
[18:04:26.702]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:26.702]  - attr(*, "resolved")= logi FALSE
[18:04:26.702]  - attr(*, "total_size")= num 896
[18:04:26.702]  - attr(*, "already-done")= logi TRUE
[18:04:26.708] - copied ‘weight’ to environment
[18:04:26.708] - copied ‘group’ to environment
[18:04:26.709] assign_globals() ... done
[18:04:26.709] plan(): Setting new future strategy stack:
[18:04:26.710] List of future strategies:
[18:04:26.710] 1. sequential:
[18:04:26.710]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.710]    - tweaked: FALSE
[18:04:26.710]    - call: NULL
[18:04:26.710] plan(): nbrOfWorkers() = 1
[18:04:26.713] plan(): Setting new future strategy stack:
[18:04:26.713] List of future strategies:
[18:04:26.713] 1. sequential:
[18:04:26.713]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.713]    - tweaked: FALSE
[18:04:26.713]    - call: plan(strategy)
[18:04:26.715] plan(): nbrOfWorkers() = 1
[18:04:26.715] SequentialFuture started (and completed)
[18:04:26.716] - Launch lazy future ... done
[18:04:26.716] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[18:04:26.722] getGlobalsAndPackages() ...
[18:04:26.722] Searching for globals...
[18:04:26.725] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:26.725] Searching for globals ... DONE
[18:04:26.726] Resolving globals: FALSE
[18:04:26.727] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:26.727] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:26.728] - globals: [2] ‘weight’, ‘group’
[18:04:26.728] - packages: [1] ‘stats’
[18:04:26.728] getGlobalsAndPackages() ... DONE
[18:04:26.729] run() for ‘Future’ ...
[18:04:26.729] - state: ‘created’
[18:04:26.729] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:26.730] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:26.730] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:26.730]   - Field: ‘label’
[18:04:26.730]   - Field: ‘local’
[18:04:26.730]   - Field: ‘owner’
[18:04:26.731]   - Field: ‘envir’
[18:04:26.731]   - Field: ‘packages’
[18:04:26.731]   - Field: ‘gc’
[18:04:26.731]   - Field: ‘conditions’
[18:04:26.731]   - Field: ‘expr’
[18:04:26.732]   - Field: ‘uuid’
[18:04:26.732]   - Field: ‘seed’
[18:04:26.732]   - Field: ‘version’
[18:04:26.732]   - Field: ‘result’
[18:04:26.732]   - Field: ‘asynchronous’
[18:04:26.732]   - Field: ‘calls’
[18:04:26.733]   - Field: ‘globals’
[18:04:26.733]   - Field: ‘stdout’
[18:04:26.733]   - Field: ‘earlySignal’
[18:04:26.733]   - Field: ‘lazy’
[18:04:26.733]   - Field: ‘state’
[18:04:26.734] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:26.734] - Launch lazy future ...
[18:04:26.734] Packages needed by the future expression (n = 1): ‘stats’
[18:04:26.734] Packages needed by future strategies (n = 0): <none>
[18:04:26.735] {
[18:04:26.735]     {
[18:04:26.735]         {
[18:04:26.735]             ...future.startTime <- base::Sys.time()
[18:04:26.735]             {
[18:04:26.735]                 {
[18:04:26.735]                   {
[18:04:26.735]                     {
[18:04:26.735]                       base::local({
[18:04:26.735]                         has_future <- base::requireNamespace("future", 
[18:04:26.735]                           quietly = TRUE)
[18:04:26.735]                         if (has_future) {
[18:04:26.735]                           ns <- base::getNamespace("future")
[18:04:26.735]                           version <- ns[[".package"]][["version"]]
[18:04:26.735]                           if (is.null(version)) 
[18:04:26.735]                             version <- utils::packageVersion("future")
[18:04:26.735]                         }
[18:04:26.735]                         else {
[18:04:26.735]                           version <- NULL
[18:04:26.735]                         }
[18:04:26.735]                         if (!has_future || version < "1.8.0") {
[18:04:26.735]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:26.735]                             "", base::R.version$version.string), 
[18:04:26.735]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:26.735]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:26.735]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:26.735]                               "release", "version")], collapse = " "), 
[18:04:26.735]                             hostname = base::Sys.info()[["nodename"]])
[18:04:26.735]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:26.735]                             info)
[18:04:26.735]                           info <- base::paste(info, collapse = "; ")
[18:04:26.735]                           if (!has_future) {
[18:04:26.735]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:26.735]                               info)
[18:04:26.735]                           }
[18:04:26.735]                           else {
[18:04:26.735]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:26.735]                               info, version)
[18:04:26.735]                           }
[18:04:26.735]                           base::stop(msg)
[18:04:26.735]                         }
[18:04:26.735]                       })
[18:04:26.735]                     }
[18:04:26.735]                     base::local({
[18:04:26.735]                       for (pkg in "stats") {
[18:04:26.735]                         base::loadNamespace(pkg)
[18:04:26.735]                         base::library(pkg, character.only = TRUE)
[18:04:26.735]                       }
[18:04:26.735]                     })
[18:04:26.735]                   }
[18:04:26.735]                   ...future.strategy.old <- future::plan("list")
[18:04:26.735]                   options(future.plan = NULL)
[18:04:26.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:26.735]                 }
[18:04:26.735]                 ...future.workdir <- getwd()
[18:04:26.735]             }
[18:04:26.735]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:26.735]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:26.735]         }
[18:04:26.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:26.735]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:26.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:26.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:26.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:26.735]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:26.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:26.735]             base::names(...future.oldOptions))
[18:04:26.735]     }
[18:04:26.735]     if (FALSE) {
[18:04:26.735]     }
[18:04:26.735]     else {
[18:04:26.735]         if (TRUE) {
[18:04:26.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:26.735]                 open = "w")
[18:04:26.735]         }
[18:04:26.735]         else {
[18:04:26.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:26.735]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:26.735]         }
[18:04:26.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:26.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:26.735]             base::sink(type = "output", split = FALSE)
[18:04:26.735]             base::close(...future.stdout)
[18:04:26.735]         }, add = TRUE)
[18:04:26.735]     }
[18:04:26.735]     ...future.frame <- base::sys.nframe()
[18:04:26.735]     ...future.conditions <- base::list()
[18:04:26.735]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:26.735]     if (FALSE) {
[18:04:26.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:26.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:26.735]     }
[18:04:26.735]     ...future.result <- base::tryCatch({
[18:04:26.735]         base::withCallingHandlers({
[18:04:26.735]             ...future.value <- base::withVisible(base::local({
[18:04:26.735]                 lm(weight ~ group - 1)
[18:04:26.735]             }))
[18:04:26.735]             future::FutureResult(value = ...future.value$value, 
[18:04:26.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.735]                   ...future.rng), globalenv = if (FALSE) 
[18:04:26.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:26.735]                     ...future.globalenv.names))
[18:04:26.735]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:26.735]         }, condition = base::local({
[18:04:26.735]             c <- base::c
[18:04:26.735]             inherits <- base::inherits
[18:04:26.735]             invokeRestart <- base::invokeRestart
[18:04:26.735]             length <- base::length
[18:04:26.735]             list <- base::list
[18:04:26.735]             seq.int <- base::seq.int
[18:04:26.735]             signalCondition <- base::signalCondition
[18:04:26.735]             sys.calls <- base::sys.calls
[18:04:26.735]             `[[` <- base::`[[`
[18:04:26.735]             `+` <- base::`+`
[18:04:26.735]             `<<-` <- base::`<<-`
[18:04:26.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:26.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:26.735]                   3L)]
[18:04:26.735]             }
[18:04:26.735]             function(cond) {
[18:04:26.735]                 is_error <- inherits(cond, "error")
[18:04:26.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:26.735]                   NULL)
[18:04:26.735]                 if (is_error) {
[18:04:26.735]                   sessionInformation <- function() {
[18:04:26.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:26.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:26.735]                       search = base::search(), system = base::Sys.info())
[18:04:26.735]                   }
[18:04:26.735]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:26.735]                     cond$call), session = sessionInformation(), 
[18:04:26.735]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:26.735]                   signalCondition(cond)
[18:04:26.735]                 }
[18:04:26.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:26.735]                 "immediateCondition"))) {
[18:04:26.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:26.735]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:26.735]                   if (TRUE && !signal) {
[18:04:26.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.735]                     {
[18:04:26.735]                       inherits <- base::inherits
[18:04:26.735]                       invokeRestart <- base::invokeRestart
[18:04:26.735]                       is.null <- base::is.null
[18:04:26.735]                       muffled <- FALSE
[18:04:26.735]                       if (inherits(cond, "message")) {
[18:04:26.735]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.735]                         if (muffled) 
[18:04:26.735]                           invokeRestart("muffleMessage")
[18:04:26.735]                       }
[18:04:26.735]                       else if (inherits(cond, "warning")) {
[18:04:26.735]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.735]                         if (muffled) 
[18:04:26.735]                           invokeRestart("muffleWarning")
[18:04:26.735]                       }
[18:04:26.735]                       else if (inherits(cond, "condition")) {
[18:04:26.735]                         if (!is.null(pattern)) {
[18:04:26.735]                           computeRestarts <- base::computeRestarts
[18:04:26.735]                           grepl <- base::grepl
[18:04:26.735]                           restarts <- computeRestarts(cond)
[18:04:26.735]                           for (restart in restarts) {
[18:04:26.735]                             name <- restart$name
[18:04:26.735]                             if (is.null(name)) 
[18:04:26.735]                               next
[18:04:26.735]                             if (!grepl(pattern, name)) 
[18:04:26.735]                               next
[18:04:26.735]                             invokeRestart(restart)
[18:04:26.735]                             muffled <- TRUE
[18:04:26.735]                             break
[18:04:26.735]                           }
[18:04:26.735]                         }
[18:04:26.735]                       }
[18:04:26.735]                       invisible(muffled)
[18:04:26.735]                     }
[18:04:26.735]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.735]                   }
[18:04:26.735]                 }
[18:04:26.735]                 else {
[18:04:26.735]                   if (TRUE) {
[18:04:26.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.735]                     {
[18:04:26.735]                       inherits <- base::inherits
[18:04:26.735]                       invokeRestart <- base::invokeRestart
[18:04:26.735]                       is.null <- base::is.null
[18:04:26.735]                       muffled <- FALSE
[18:04:26.735]                       if (inherits(cond, "message")) {
[18:04:26.735]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.735]                         if (muffled) 
[18:04:26.735]                           invokeRestart("muffleMessage")
[18:04:26.735]                       }
[18:04:26.735]                       else if (inherits(cond, "warning")) {
[18:04:26.735]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.735]                         if (muffled) 
[18:04:26.735]                           invokeRestart("muffleWarning")
[18:04:26.735]                       }
[18:04:26.735]                       else if (inherits(cond, "condition")) {
[18:04:26.735]                         if (!is.null(pattern)) {
[18:04:26.735]                           computeRestarts <- base::computeRestarts
[18:04:26.735]                           grepl <- base::grepl
[18:04:26.735]                           restarts <- computeRestarts(cond)
[18:04:26.735]                           for (restart in restarts) {
[18:04:26.735]                             name <- restart$name
[18:04:26.735]                             if (is.null(name)) 
[18:04:26.735]                               next
[18:04:26.735]                             if (!grepl(pattern, name)) 
[18:04:26.735]                               next
[18:04:26.735]                             invokeRestart(restart)
[18:04:26.735]                             muffled <- TRUE
[18:04:26.735]                             break
[18:04:26.735]                           }
[18:04:26.735]                         }
[18:04:26.735]                       }
[18:04:26.735]                       invisible(muffled)
[18:04:26.735]                     }
[18:04:26.735]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.735]                   }
[18:04:26.735]                 }
[18:04:26.735]             }
[18:04:26.735]         }))
[18:04:26.735]     }, error = function(ex) {
[18:04:26.735]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:26.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.735]                 ...future.rng), started = ...future.startTime, 
[18:04:26.735]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:26.735]             version = "1.8"), class = "FutureResult")
[18:04:26.735]     }, finally = {
[18:04:26.735]         if (!identical(...future.workdir, getwd())) 
[18:04:26.735]             setwd(...future.workdir)
[18:04:26.735]         {
[18:04:26.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:26.735]                 ...future.oldOptions$nwarnings <- NULL
[18:04:26.735]             }
[18:04:26.735]             base::options(...future.oldOptions)
[18:04:26.735]             if (.Platform$OS.type == "windows") {
[18:04:26.735]                 old_names <- names(...future.oldEnvVars)
[18:04:26.735]                 envs <- base::Sys.getenv()
[18:04:26.735]                 names <- names(envs)
[18:04:26.735]                 common <- intersect(names, old_names)
[18:04:26.735]                 added <- setdiff(names, old_names)
[18:04:26.735]                 removed <- setdiff(old_names, names)
[18:04:26.735]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:26.735]                   envs[common]]
[18:04:26.735]                 NAMES <- toupper(changed)
[18:04:26.735]                 args <- list()
[18:04:26.735]                 for (kk in seq_along(NAMES)) {
[18:04:26.735]                   name <- changed[[kk]]
[18:04:26.735]                   NAME <- NAMES[[kk]]
[18:04:26.735]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.735]                     next
[18:04:26.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.735]                 }
[18:04:26.735]                 NAMES <- toupper(added)
[18:04:26.735]                 for (kk in seq_along(NAMES)) {
[18:04:26.735]                   name <- added[[kk]]
[18:04:26.735]                   NAME <- NAMES[[kk]]
[18:04:26.735]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.735]                     next
[18:04:26.735]                   args[[name]] <- ""
[18:04:26.735]                 }
[18:04:26.735]                 NAMES <- toupper(removed)
[18:04:26.735]                 for (kk in seq_along(NAMES)) {
[18:04:26.735]                   name <- removed[[kk]]
[18:04:26.735]                   NAME <- NAMES[[kk]]
[18:04:26.735]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.735]                     next
[18:04:26.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.735]                 }
[18:04:26.735]                 if (length(args) > 0) 
[18:04:26.735]                   base::do.call(base::Sys.setenv, args = args)
[18:04:26.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:26.735]             }
[18:04:26.735]             else {
[18:04:26.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:26.735]             }
[18:04:26.735]             {
[18:04:26.735]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:26.735]                   0L) {
[18:04:26.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:26.735]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:26.735]                   base::options(opts)
[18:04:26.735]                 }
[18:04:26.735]                 {
[18:04:26.735]                   {
[18:04:26.735]                     NULL
[18:04:26.735]                     RNGkind("Mersenne-Twister")
[18:04:26.735]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:26.735]                       inherits = FALSE)
[18:04:26.735]                   }
[18:04:26.735]                   options(future.plan = NULL)
[18:04:26.735]                   if (is.na(NA_character_)) 
[18:04:26.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:26.735]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:26.735]                     .init = FALSE)
[18:04:26.735]                 }
[18:04:26.735]             }
[18:04:26.735]         }
[18:04:26.735]     })
[18:04:26.735]     if (TRUE) {
[18:04:26.735]         base::sink(type = "output", split = FALSE)
[18:04:26.735]         if (TRUE) {
[18:04:26.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:26.735]         }
[18:04:26.735]         else {
[18:04:26.735]             ...future.result["stdout"] <- base::list(NULL)
[18:04:26.735]         }
[18:04:26.735]         base::close(...future.stdout)
[18:04:26.735]         ...future.stdout <- NULL
[18:04:26.735]     }
[18:04:26.735]     ...future.result$conditions <- ...future.conditions
[18:04:26.735]     ...future.result$finished <- base::Sys.time()
[18:04:26.735]     ...future.result
[18:04:26.735] }
[18:04:26.739] assign_globals() ...
[18:04:26.739] List of 2
[18:04:26.739]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[18:04:26.739]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[18:04:26.739]  - attr(*, "where")=List of 2
[18:04:26.739]   ..$ weight:<environment: R_EmptyEnv> 
[18:04:26.739]   ..$ group :<environment: R_EmptyEnv> 
[18:04:26.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:26.739]  - attr(*, "resolved")= logi FALSE
[18:04:26.739]  - attr(*, "total_size")= num 896
[18:04:26.739]  - attr(*, "already-done")= logi TRUE
[18:04:26.745] - copied ‘weight’ to environment
[18:04:26.745] - copied ‘group’ to environment
[18:04:26.745] assign_globals() ... done
[18:04:26.746] plan(): Setting new future strategy stack:
[18:04:26.747] List of future strategies:
[18:04:26.747] 1. sequential:
[18:04:26.747]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.747]    - tweaked: FALSE
[18:04:26.747]    - call: NULL
[18:04:26.748] plan(): nbrOfWorkers() = 1
[18:04:26.751] plan(): Setting new future strategy stack:
[18:04:26.751] List of future strategies:
[18:04:26.751] 1. sequential:
[18:04:26.751]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.751]    - tweaked: FALSE
[18:04:26.751]    - call: plan(strategy)
[18:04:26.752] plan(): nbrOfWorkers() = 1
[18:04:26.752] SequentialFuture started (and completed)
[18:04:26.753] - Launch lazy future ... done
[18:04:26.753] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[18:04:26.757] getGlobalsAndPackages() ...
[18:04:26.757] Searching for globals...
[18:04:26.760] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:26.760] Searching for globals ... DONE
[18:04:26.760] Resolving globals: FALSE
[18:04:26.761] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:26.762] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:26.762] - globals: [2] ‘weight’, ‘group’
[18:04:26.762] - packages: [1] ‘stats’
[18:04:26.763] getGlobalsAndPackages() ... DONE
[18:04:26.763] run() for ‘Future’ ...
[18:04:26.763] - state: ‘created’
[18:04:26.764] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:26.764] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:26.764] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:26.765]   - Field: ‘label’
[18:04:26.765]   - Field: ‘local’
[18:04:26.765]   - Field: ‘owner’
[18:04:26.765]   - Field: ‘envir’
[18:04:26.765]   - Field: ‘packages’
[18:04:26.766]   - Field: ‘gc’
[18:04:26.766]   - Field: ‘conditions’
[18:04:26.766]   - Field: ‘expr’
[18:04:26.766]   - Field: ‘uuid’
[18:04:26.766]   - Field: ‘seed’
[18:04:26.767]   - Field: ‘version’
[18:04:26.767]   - Field: ‘result’
[18:04:26.767]   - Field: ‘asynchronous’
[18:04:26.767]   - Field: ‘calls’
[18:04:26.767]   - Field: ‘globals’
[18:04:26.768]   - Field: ‘stdout’
[18:04:26.768]   - Field: ‘earlySignal’
[18:04:26.768]   - Field: ‘lazy’
[18:04:26.768]   - Field: ‘state’
[18:04:26.768] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:26.769] - Launch lazy future ...
[18:04:26.769] Packages needed by the future expression (n = 1): ‘stats’
[18:04:26.769] Packages needed by future strategies (n = 0): <none>
[18:04:26.772] {
[18:04:26.772]     {
[18:04:26.772]         {
[18:04:26.772]             ...future.startTime <- base::Sys.time()
[18:04:26.772]             {
[18:04:26.772]                 {
[18:04:26.772]                   {
[18:04:26.772]                     {
[18:04:26.772]                       base::local({
[18:04:26.772]                         has_future <- base::requireNamespace("future", 
[18:04:26.772]                           quietly = TRUE)
[18:04:26.772]                         if (has_future) {
[18:04:26.772]                           ns <- base::getNamespace("future")
[18:04:26.772]                           version <- ns[[".package"]][["version"]]
[18:04:26.772]                           if (is.null(version)) 
[18:04:26.772]                             version <- utils::packageVersion("future")
[18:04:26.772]                         }
[18:04:26.772]                         else {
[18:04:26.772]                           version <- NULL
[18:04:26.772]                         }
[18:04:26.772]                         if (!has_future || version < "1.8.0") {
[18:04:26.772]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:26.772]                             "", base::R.version$version.string), 
[18:04:26.772]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:26.772]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:26.772]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:26.772]                               "release", "version")], collapse = " "), 
[18:04:26.772]                             hostname = base::Sys.info()[["nodename"]])
[18:04:26.772]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:26.772]                             info)
[18:04:26.772]                           info <- base::paste(info, collapse = "; ")
[18:04:26.772]                           if (!has_future) {
[18:04:26.772]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:26.772]                               info)
[18:04:26.772]                           }
[18:04:26.772]                           else {
[18:04:26.772]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:26.772]                               info, version)
[18:04:26.772]                           }
[18:04:26.772]                           base::stop(msg)
[18:04:26.772]                         }
[18:04:26.772]                       })
[18:04:26.772]                     }
[18:04:26.772]                     base::local({
[18:04:26.772]                       for (pkg in "stats") {
[18:04:26.772]                         base::loadNamespace(pkg)
[18:04:26.772]                         base::library(pkg, character.only = TRUE)
[18:04:26.772]                       }
[18:04:26.772]                     })
[18:04:26.772]                   }
[18:04:26.772]                   ...future.strategy.old <- future::plan("list")
[18:04:26.772]                   options(future.plan = NULL)
[18:04:26.772]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.772]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:26.772]                 }
[18:04:26.772]                 ...future.workdir <- getwd()
[18:04:26.772]             }
[18:04:26.772]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:26.772]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:26.772]         }
[18:04:26.772]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:26.772]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:26.772]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:26.772]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:26.772]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:26.772]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:26.772]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:26.772]             base::names(...future.oldOptions))
[18:04:26.772]     }
[18:04:26.772]     if (FALSE) {
[18:04:26.772]     }
[18:04:26.772]     else {
[18:04:26.772]         if (TRUE) {
[18:04:26.772]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:26.772]                 open = "w")
[18:04:26.772]         }
[18:04:26.772]         else {
[18:04:26.772]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:26.772]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:26.772]         }
[18:04:26.772]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:26.772]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:26.772]             base::sink(type = "output", split = FALSE)
[18:04:26.772]             base::close(...future.stdout)
[18:04:26.772]         }, add = TRUE)
[18:04:26.772]     }
[18:04:26.772]     ...future.frame <- base::sys.nframe()
[18:04:26.772]     ...future.conditions <- base::list()
[18:04:26.772]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:26.772]     if (FALSE) {
[18:04:26.772]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:26.772]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:26.772]     }
[18:04:26.772]     ...future.result <- base::tryCatch({
[18:04:26.772]         base::withCallingHandlers({
[18:04:26.772]             ...future.value <- base::withVisible(base::local({
[18:04:26.772]                 lm(weight ~ group - 1)
[18:04:26.772]             }))
[18:04:26.772]             future::FutureResult(value = ...future.value$value, 
[18:04:26.772]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.772]                   ...future.rng), globalenv = if (FALSE) 
[18:04:26.772]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:26.772]                     ...future.globalenv.names))
[18:04:26.772]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:26.772]         }, condition = base::local({
[18:04:26.772]             c <- base::c
[18:04:26.772]             inherits <- base::inherits
[18:04:26.772]             invokeRestart <- base::invokeRestart
[18:04:26.772]             length <- base::length
[18:04:26.772]             list <- base::list
[18:04:26.772]             seq.int <- base::seq.int
[18:04:26.772]             signalCondition <- base::signalCondition
[18:04:26.772]             sys.calls <- base::sys.calls
[18:04:26.772]             `[[` <- base::`[[`
[18:04:26.772]             `+` <- base::`+`
[18:04:26.772]             `<<-` <- base::`<<-`
[18:04:26.772]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:26.772]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:26.772]                   3L)]
[18:04:26.772]             }
[18:04:26.772]             function(cond) {
[18:04:26.772]                 is_error <- inherits(cond, "error")
[18:04:26.772]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:26.772]                   NULL)
[18:04:26.772]                 if (is_error) {
[18:04:26.772]                   sessionInformation <- function() {
[18:04:26.772]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:26.772]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:26.772]                       search = base::search(), system = base::Sys.info())
[18:04:26.772]                   }
[18:04:26.772]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.772]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:26.772]                     cond$call), session = sessionInformation(), 
[18:04:26.772]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:26.772]                   signalCondition(cond)
[18:04:26.772]                 }
[18:04:26.772]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:26.772]                 "immediateCondition"))) {
[18:04:26.772]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:26.772]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.772]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:26.772]                   if (TRUE && !signal) {
[18:04:26.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.772]                     {
[18:04:26.772]                       inherits <- base::inherits
[18:04:26.772]                       invokeRestart <- base::invokeRestart
[18:04:26.772]                       is.null <- base::is.null
[18:04:26.772]                       muffled <- FALSE
[18:04:26.772]                       if (inherits(cond, "message")) {
[18:04:26.772]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.772]                         if (muffled) 
[18:04:26.772]                           invokeRestart("muffleMessage")
[18:04:26.772]                       }
[18:04:26.772]                       else if (inherits(cond, "warning")) {
[18:04:26.772]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.772]                         if (muffled) 
[18:04:26.772]                           invokeRestart("muffleWarning")
[18:04:26.772]                       }
[18:04:26.772]                       else if (inherits(cond, "condition")) {
[18:04:26.772]                         if (!is.null(pattern)) {
[18:04:26.772]                           computeRestarts <- base::computeRestarts
[18:04:26.772]                           grepl <- base::grepl
[18:04:26.772]                           restarts <- computeRestarts(cond)
[18:04:26.772]                           for (restart in restarts) {
[18:04:26.772]                             name <- restart$name
[18:04:26.772]                             if (is.null(name)) 
[18:04:26.772]                               next
[18:04:26.772]                             if (!grepl(pattern, name)) 
[18:04:26.772]                               next
[18:04:26.772]                             invokeRestart(restart)
[18:04:26.772]                             muffled <- TRUE
[18:04:26.772]                             break
[18:04:26.772]                           }
[18:04:26.772]                         }
[18:04:26.772]                       }
[18:04:26.772]                       invisible(muffled)
[18:04:26.772]                     }
[18:04:26.772]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.772]                   }
[18:04:26.772]                 }
[18:04:26.772]                 else {
[18:04:26.772]                   if (TRUE) {
[18:04:26.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.772]                     {
[18:04:26.772]                       inherits <- base::inherits
[18:04:26.772]                       invokeRestart <- base::invokeRestart
[18:04:26.772]                       is.null <- base::is.null
[18:04:26.772]                       muffled <- FALSE
[18:04:26.772]                       if (inherits(cond, "message")) {
[18:04:26.772]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.772]                         if (muffled) 
[18:04:26.772]                           invokeRestart("muffleMessage")
[18:04:26.772]                       }
[18:04:26.772]                       else if (inherits(cond, "warning")) {
[18:04:26.772]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.772]                         if (muffled) 
[18:04:26.772]                           invokeRestart("muffleWarning")
[18:04:26.772]                       }
[18:04:26.772]                       else if (inherits(cond, "condition")) {
[18:04:26.772]                         if (!is.null(pattern)) {
[18:04:26.772]                           computeRestarts <- base::computeRestarts
[18:04:26.772]                           grepl <- base::grepl
[18:04:26.772]                           restarts <- computeRestarts(cond)
[18:04:26.772]                           for (restart in restarts) {
[18:04:26.772]                             name <- restart$name
[18:04:26.772]                             if (is.null(name)) 
[18:04:26.772]                               next
[18:04:26.772]                             if (!grepl(pattern, name)) 
[18:04:26.772]                               next
[18:04:26.772]                             invokeRestart(restart)
[18:04:26.772]                             muffled <- TRUE
[18:04:26.772]                             break
[18:04:26.772]                           }
[18:04:26.772]                         }
[18:04:26.772]                       }
[18:04:26.772]                       invisible(muffled)
[18:04:26.772]                     }
[18:04:26.772]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.772]                   }
[18:04:26.772]                 }
[18:04:26.772]             }
[18:04:26.772]         }))
[18:04:26.772]     }, error = function(ex) {
[18:04:26.772]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:26.772]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.772]                 ...future.rng), started = ...future.startTime, 
[18:04:26.772]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:26.772]             version = "1.8"), class = "FutureResult")
[18:04:26.772]     }, finally = {
[18:04:26.772]         if (!identical(...future.workdir, getwd())) 
[18:04:26.772]             setwd(...future.workdir)
[18:04:26.772]         {
[18:04:26.772]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:26.772]                 ...future.oldOptions$nwarnings <- NULL
[18:04:26.772]             }
[18:04:26.772]             base::options(...future.oldOptions)
[18:04:26.772]             if (.Platform$OS.type == "windows") {
[18:04:26.772]                 old_names <- names(...future.oldEnvVars)
[18:04:26.772]                 envs <- base::Sys.getenv()
[18:04:26.772]                 names <- names(envs)
[18:04:26.772]                 common <- intersect(names, old_names)
[18:04:26.772]                 added <- setdiff(names, old_names)
[18:04:26.772]                 removed <- setdiff(old_names, names)
[18:04:26.772]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:26.772]                   envs[common]]
[18:04:26.772]                 NAMES <- toupper(changed)
[18:04:26.772]                 args <- list()
[18:04:26.772]                 for (kk in seq_along(NAMES)) {
[18:04:26.772]                   name <- changed[[kk]]
[18:04:26.772]                   NAME <- NAMES[[kk]]
[18:04:26.772]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.772]                     next
[18:04:26.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.772]                 }
[18:04:26.772]                 NAMES <- toupper(added)
[18:04:26.772]                 for (kk in seq_along(NAMES)) {
[18:04:26.772]                   name <- added[[kk]]
[18:04:26.772]                   NAME <- NAMES[[kk]]
[18:04:26.772]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.772]                     next
[18:04:26.772]                   args[[name]] <- ""
[18:04:26.772]                 }
[18:04:26.772]                 NAMES <- toupper(removed)
[18:04:26.772]                 for (kk in seq_along(NAMES)) {
[18:04:26.772]                   name <- removed[[kk]]
[18:04:26.772]                   NAME <- NAMES[[kk]]
[18:04:26.772]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.772]                     next
[18:04:26.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.772]                 }
[18:04:26.772]                 if (length(args) > 0) 
[18:04:26.772]                   base::do.call(base::Sys.setenv, args = args)
[18:04:26.772]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:26.772]             }
[18:04:26.772]             else {
[18:04:26.772]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:26.772]             }
[18:04:26.772]             {
[18:04:26.772]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:26.772]                   0L) {
[18:04:26.772]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:26.772]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:26.772]                   base::options(opts)
[18:04:26.772]                 }
[18:04:26.772]                 {
[18:04:26.772]                   {
[18:04:26.772]                     NULL
[18:04:26.772]                     RNGkind("Mersenne-Twister")
[18:04:26.772]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:26.772]                       inherits = FALSE)
[18:04:26.772]                   }
[18:04:26.772]                   options(future.plan = NULL)
[18:04:26.772]                   if (is.na(NA_character_)) 
[18:04:26.772]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.772]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:26.772]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:26.772]                     .init = FALSE)
[18:04:26.772]                 }
[18:04:26.772]             }
[18:04:26.772]         }
[18:04:26.772]     })
[18:04:26.772]     if (TRUE) {
[18:04:26.772]         base::sink(type = "output", split = FALSE)
[18:04:26.772]         if (TRUE) {
[18:04:26.772]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:26.772]         }
[18:04:26.772]         else {
[18:04:26.772]             ...future.result["stdout"] <- base::list(NULL)
[18:04:26.772]         }
[18:04:26.772]         base::close(...future.stdout)
[18:04:26.772]         ...future.stdout <- NULL
[18:04:26.772]     }
[18:04:26.772]     ...future.result$conditions <- ...future.conditions
[18:04:26.772]     ...future.result$finished <- base::Sys.time()
[18:04:26.772]     ...future.result
[18:04:26.772] }
[18:04:26.776] assign_globals() ...
[18:04:26.776] List of 2
[18:04:26.776]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[18:04:26.776]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[18:04:26.776]  - attr(*, "where")=List of 2
[18:04:26.776]   ..$ weight:<environment: R_EmptyEnv> 
[18:04:26.776]   ..$ group :<environment: R_EmptyEnv> 
[18:04:26.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:26.776]  - attr(*, "resolved")= logi FALSE
[18:04:26.776]  - attr(*, "total_size")= num 896
[18:04:26.776]  - attr(*, "already-done")= logi TRUE
[18:04:26.783] - copied ‘weight’ to environment
[18:04:26.783] - copied ‘group’ to environment
[18:04:26.783] assign_globals() ... done
[18:04:26.784] plan(): Setting new future strategy stack:
[18:04:26.784] List of future strategies:
[18:04:26.784] 1. sequential:
[18:04:26.784]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.784]    - tweaked: FALSE
[18:04:26.784]    - call: NULL
[18:04:26.785] plan(): nbrOfWorkers() = 1
[18:04:26.789] plan(): Setting new future strategy stack:
[18:04:26.789] List of future strategies:
[18:04:26.789] 1. sequential:
[18:04:26.789]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.789]    - tweaked: FALSE
[18:04:26.789]    - call: plan(strategy)
[18:04:26.790] plan(): nbrOfWorkers() = 1
[18:04:26.790] SequentialFuture started (and completed)
[18:04:26.791] - Launch lazy future ... done
[18:04:26.791] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[18:04:26.795] getGlobalsAndPackages() ...
[18:04:26.795] Searching for globals...
[18:04:26.797] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[18:04:26.798] Searching for globals ... DONE
[18:04:26.798] Resolving globals: FALSE
[18:04:26.799] The total size of the 1 globals is 96 bytes (96 bytes)
[18:04:26.799] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[18:04:26.800] - globals: [1] ‘x’
[18:04:26.800] - packages: [1] ‘stats’
[18:04:26.800] getGlobalsAndPackages() ... DONE
[18:04:26.801] run() for ‘Future’ ...
[18:04:26.801] - state: ‘created’
[18:04:26.801] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:26.802] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:26.802] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:26.802]   - Field: ‘label’
[18:04:26.803]   - Field: ‘local’
[18:04:26.803]   - Field: ‘owner’
[18:04:26.803]   - Field: ‘envir’
[18:04:26.803]   - Field: ‘packages’
[18:04:26.803]   - Field: ‘gc’
[18:04:26.804]   - Field: ‘conditions’
[18:04:26.804]   - Field: ‘expr’
[18:04:26.804]   - Field: ‘uuid’
[18:04:26.804]   - Field: ‘seed’
[18:04:26.804]   - Field: ‘version’
[18:04:26.805]   - Field: ‘result’
[18:04:26.805]   - Field: ‘asynchronous’
[18:04:26.805]   - Field: ‘calls’
[18:04:26.805]   - Field: ‘globals’
[18:04:26.805]   - Field: ‘stdout’
[18:04:26.806]   - Field: ‘earlySignal’
[18:04:26.806]   - Field: ‘lazy’
[18:04:26.806]   - Field: ‘state’
[18:04:26.806] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:26.806] - Launch lazy future ...
[18:04:26.807] Packages needed by the future expression (n = 1): ‘stats’
[18:04:26.807] Packages needed by future strategies (n = 0): <none>
[18:04:26.808] {
[18:04:26.808]     {
[18:04:26.808]         {
[18:04:26.808]             ...future.startTime <- base::Sys.time()
[18:04:26.808]             {
[18:04:26.808]                 {
[18:04:26.808]                   {
[18:04:26.808]                     {
[18:04:26.808]                       base::local({
[18:04:26.808]                         has_future <- base::requireNamespace("future", 
[18:04:26.808]                           quietly = TRUE)
[18:04:26.808]                         if (has_future) {
[18:04:26.808]                           ns <- base::getNamespace("future")
[18:04:26.808]                           version <- ns[[".package"]][["version"]]
[18:04:26.808]                           if (is.null(version)) 
[18:04:26.808]                             version <- utils::packageVersion("future")
[18:04:26.808]                         }
[18:04:26.808]                         else {
[18:04:26.808]                           version <- NULL
[18:04:26.808]                         }
[18:04:26.808]                         if (!has_future || version < "1.8.0") {
[18:04:26.808]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:26.808]                             "", base::R.version$version.string), 
[18:04:26.808]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:26.808]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:26.808]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:26.808]                               "release", "version")], collapse = " "), 
[18:04:26.808]                             hostname = base::Sys.info()[["nodename"]])
[18:04:26.808]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:26.808]                             info)
[18:04:26.808]                           info <- base::paste(info, collapse = "; ")
[18:04:26.808]                           if (!has_future) {
[18:04:26.808]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:26.808]                               info)
[18:04:26.808]                           }
[18:04:26.808]                           else {
[18:04:26.808]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:26.808]                               info, version)
[18:04:26.808]                           }
[18:04:26.808]                           base::stop(msg)
[18:04:26.808]                         }
[18:04:26.808]                       })
[18:04:26.808]                     }
[18:04:26.808]                     base::local({
[18:04:26.808]                       for (pkg in "stats") {
[18:04:26.808]                         base::loadNamespace(pkg)
[18:04:26.808]                         base::library(pkg, character.only = TRUE)
[18:04:26.808]                       }
[18:04:26.808]                     })
[18:04:26.808]                   }
[18:04:26.808]                   ...future.strategy.old <- future::plan("list")
[18:04:26.808]                   options(future.plan = NULL)
[18:04:26.808]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.808]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:26.808]                 }
[18:04:26.808]                 ...future.workdir <- getwd()
[18:04:26.808]             }
[18:04:26.808]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:26.808]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:26.808]         }
[18:04:26.808]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:26.808]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:26.808]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:26.808]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:26.808]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:26.808]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:26.808]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:26.808]             base::names(...future.oldOptions))
[18:04:26.808]     }
[18:04:26.808]     if (FALSE) {
[18:04:26.808]     }
[18:04:26.808]     else {
[18:04:26.808]         if (TRUE) {
[18:04:26.808]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:26.808]                 open = "w")
[18:04:26.808]         }
[18:04:26.808]         else {
[18:04:26.808]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:26.808]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:26.808]         }
[18:04:26.808]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:26.808]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:26.808]             base::sink(type = "output", split = FALSE)
[18:04:26.808]             base::close(...future.stdout)
[18:04:26.808]         }, add = TRUE)
[18:04:26.808]     }
[18:04:26.808]     ...future.frame <- base::sys.nframe()
[18:04:26.808]     ...future.conditions <- base::list()
[18:04:26.808]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:26.808]     if (FALSE) {
[18:04:26.808]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:26.808]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:26.808]     }
[18:04:26.808]     ...future.result <- base::tryCatch({
[18:04:26.808]         base::withCallingHandlers({
[18:04:26.808]             ...future.value <- base::withVisible(base::local({
[18:04:26.808]                 xtabs(~x)
[18:04:26.808]             }))
[18:04:26.808]             future::FutureResult(value = ...future.value$value, 
[18:04:26.808]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.808]                   ...future.rng), globalenv = if (FALSE) 
[18:04:26.808]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:26.808]                     ...future.globalenv.names))
[18:04:26.808]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:26.808]         }, condition = base::local({
[18:04:26.808]             c <- base::c
[18:04:26.808]             inherits <- base::inherits
[18:04:26.808]             invokeRestart <- base::invokeRestart
[18:04:26.808]             length <- base::length
[18:04:26.808]             list <- base::list
[18:04:26.808]             seq.int <- base::seq.int
[18:04:26.808]             signalCondition <- base::signalCondition
[18:04:26.808]             sys.calls <- base::sys.calls
[18:04:26.808]             `[[` <- base::`[[`
[18:04:26.808]             `+` <- base::`+`
[18:04:26.808]             `<<-` <- base::`<<-`
[18:04:26.808]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:26.808]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:26.808]                   3L)]
[18:04:26.808]             }
[18:04:26.808]             function(cond) {
[18:04:26.808]                 is_error <- inherits(cond, "error")
[18:04:26.808]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:26.808]                   NULL)
[18:04:26.808]                 if (is_error) {
[18:04:26.808]                   sessionInformation <- function() {
[18:04:26.808]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:26.808]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:26.808]                       search = base::search(), system = base::Sys.info())
[18:04:26.808]                   }
[18:04:26.808]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.808]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:26.808]                     cond$call), session = sessionInformation(), 
[18:04:26.808]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:26.808]                   signalCondition(cond)
[18:04:26.808]                 }
[18:04:26.808]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:26.808]                 "immediateCondition"))) {
[18:04:26.808]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:26.808]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.808]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:26.808]                   if (TRUE && !signal) {
[18:04:26.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.808]                     {
[18:04:26.808]                       inherits <- base::inherits
[18:04:26.808]                       invokeRestart <- base::invokeRestart
[18:04:26.808]                       is.null <- base::is.null
[18:04:26.808]                       muffled <- FALSE
[18:04:26.808]                       if (inherits(cond, "message")) {
[18:04:26.808]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.808]                         if (muffled) 
[18:04:26.808]                           invokeRestart("muffleMessage")
[18:04:26.808]                       }
[18:04:26.808]                       else if (inherits(cond, "warning")) {
[18:04:26.808]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.808]                         if (muffled) 
[18:04:26.808]                           invokeRestart("muffleWarning")
[18:04:26.808]                       }
[18:04:26.808]                       else if (inherits(cond, "condition")) {
[18:04:26.808]                         if (!is.null(pattern)) {
[18:04:26.808]                           computeRestarts <- base::computeRestarts
[18:04:26.808]                           grepl <- base::grepl
[18:04:26.808]                           restarts <- computeRestarts(cond)
[18:04:26.808]                           for (restart in restarts) {
[18:04:26.808]                             name <- restart$name
[18:04:26.808]                             if (is.null(name)) 
[18:04:26.808]                               next
[18:04:26.808]                             if (!grepl(pattern, name)) 
[18:04:26.808]                               next
[18:04:26.808]                             invokeRestart(restart)
[18:04:26.808]                             muffled <- TRUE
[18:04:26.808]                             break
[18:04:26.808]                           }
[18:04:26.808]                         }
[18:04:26.808]                       }
[18:04:26.808]                       invisible(muffled)
[18:04:26.808]                     }
[18:04:26.808]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.808]                   }
[18:04:26.808]                 }
[18:04:26.808]                 else {
[18:04:26.808]                   if (TRUE) {
[18:04:26.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.808]                     {
[18:04:26.808]                       inherits <- base::inherits
[18:04:26.808]                       invokeRestart <- base::invokeRestart
[18:04:26.808]                       is.null <- base::is.null
[18:04:26.808]                       muffled <- FALSE
[18:04:26.808]                       if (inherits(cond, "message")) {
[18:04:26.808]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.808]                         if (muffled) 
[18:04:26.808]                           invokeRestart("muffleMessage")
[18:04:26.808]                       }
[18:04:26.808]                       else if (inherits(cond, "warning")) {
[18:04:26.808]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.808]                         if (muffled) 
[18:04:26.808]                           invokeRestart("muffleWarning")
[18:04:26.808]                       }
[18:04:26.808]                       else if (inherits(cond, "condition")) {
[18:04:26.808]                         if (!is.null(pattern)) {
[18:04:26.808]                           computeRestarts <- base::computeRestarts
[18:04:26.808]                           grepl <- base::grepl
[18:04:26.808]                           restarts <- computeRestarts(cond)
[18:04:26.808]                           for (restart in restarts) {
[18:04:26.808]                             name <- restart$name
[18:04:26.808]                             if (is.null(name)) 
[18:04:26.808]                               next
[18:04:26.808]                             if (!grepl(pattern, name)) 
[18:04:26.808]                               next
[18:04:26.808]                             invokeRestart(restart)
[18:04:26.808]                             muffled <- TRUE
[18:04:26.808]                             break
[18:04:26.808]                           }
[18:04:26.808]                         }
[18:04:26.808]                       }
[18:04:26.808]                       invisible(muffled)
[18:04:26.808]                     }
[18:04:26.808]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.808]                   }
[18:04:26.808]                 }
[18:04:26.808]             }
[18:04:26.808]         }))
[18:04:26.808]     }, error = function(ex) {
[18:04:26.808]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:26.808]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.808]                 ...future.rng), started = ...future.startTime, 
[18:04:26.808]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:26.808]             version = "1.8"), class = "FutureResult")
[18:04:26.808]     }, finally = {
[18:04:26.808]         if (!identical(...future.workdir, getwd())) 
[18:04:26.808]             setwd(...future.workdir)
[18:04:26.808]         {
[18:04:26.808]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:26.808]                 ...future.oldOptions$nwarnings <- NULL
[18:04:26.808]             }
[18:04:26.808]             base::options(...future.oldOptions)
[18:04:26.808]             if (.Platform$OS.type == "windows") {
[18:04:26.808]                 old_names <- names(...future.oldEnvVars)
[18:04:26.808]                 envs <- base::Sys.getenv()
[18:04:26.808]                 names <- names(envs)
[18:04:26.808]                 common <- intersect(names, old_names)
[18:04:26.808]                 added <- setdiff(names, old_names)
[18:04:26.808]                 removed <- setdiff(old_names, names)
[18:04:26.808]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:26.808]                   envs[common]]
[18:04:26.808]                 NAMES <- toupper(changed)
[18:04:26.808]                 args <- list()
[18:04:26.808]                 for (kk in seq_along(NAMES)) {
[18:04:26.808]                   name <- changed[[kk]]
[18:04:26.808]                   NAME <- NAMES[[kk]]
[18:04:26.808]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.808]                     next
[18:04:26.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.808]                 }
[18:04:26.808]                 NAMES <- toupper(added)
[18:04:26.808]                 for (kk in seq_along(NAMES)) {
[18:04:26.808]                   name <- added[[kk]]
[18:04:26.808]                   NAME <- NAMES[[kk]]
[18:04:26.808]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.808]                     next
[18:04:26.808]                   args[[name]] <- ""
[18:04:26.808]                 }
[18:04:26.808]                 NAMES <- toupper(removed)
[18:04:26.808]                 for (kk in seq_along(NAMES)) {
[18:04:26.808]                   name <- removed[[kk]]
[18:04:26.808]                   NAME <- NAMES[[kk]]
[18:04:26.808]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.808]                     next
[18:04:26.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.808]                 }
[18:04:26.808]                 if (length(args) > 0) 
[18:04:26.808]                   base::do.call(base::Sys.setenv, args = args)
[18:04:26.808]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:26.808]             }
[18:04:26.808]             else {
[18:04:26.808]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:26.808]             }
[18:04:26.808]             {
[18:04:26.808]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:26.808]                   0L) {
[18:04:26.808]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:26.808]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:26.808]                   base::options(opts)
[18:04:26.808]                 }
[18:04:26.808]                 {
[18:04:26.808]                   {
[18:04:26.808]                     NULL
[18:04:26.808]                     RNGkind("Mersenne-Twister")
[18:04:26.808]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:26.808]                       inherits = FALSE)
[18:04:26.808]                   }
[18:04:26.808]                   options(future.plan = NULL)
[18:04:26.808]                   if (is.na(NA_character_)) 
[18:04:26.808]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.808]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:26.808]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:26.808]                     .init = FALSE)
[18:04:26.808]                 }
[18:04:26.808]             }
[18:04:26.808]         }
[18:04:26.808]     })
[18:04:26.808]     if (TRUE) {
[18:04:26.808]         base::sink(type = "output", split = FALSE)
[18:04:26.808]         if (TRUE) {
[18:04:26.808]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:26.808]         }
[18:04:26.808]         else {
[18:04:26.808]             ...future.result["stdout"] <- base::list(NULL)
[18:04:26.808]         }
[18:04:26.808]         base::close(...future.stdout)
[18:04:26.808]         ...future.stdout <- NULL
[18:04:26.808]     }
[18:04:26.808]     ...future.result$conditions <- ...future.conditions
[18:04:26.808]     ...future.result$finished <- base::Sys.time()
[18:04:26.808]     ...future.result
[18:04:26.808] }
[18:04:26.812] assign_globals() ...
[18:04:26.812] List of 1
[18:04:26.812]  $ x: num [1:5] 1 1 2 2 2
[18:04:26.812]  - attr(*, "where")=List of 1
[18:04:26.812]   ..$ x:<environment: R_EmptyEnv> 
[18:04:26.812]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:26.812]  - attr(*, "resolved")= logi FALSE
[18:04:26.812]  - attr(*, "total_size")= num 96
[18:04:26.812]  - attr(*, "already-done")= logi TRUE
[18:04:26.818] - copied ‘x’ to environment
[18:04:26.818] assign_globals() ... done
[18:04:26.819] plan(): Setting new future strategy stack:
[18:04:26.819] List of future strategies:
[18:04:26.819] 1. sequential:
[18:04:26.819]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.819]    - tweaked: FALSE
[18:04:26.819]    - call: NULL
[18:04:26.820] plan(): nbrOfWorkers() = 1
[18:04:26.822] plan(): Setting new future strategy stack:
[18:04:26.822] List of future strategies:
[18:04:26.822] 1. sequential:
[18:04:26.822]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.822]    - tweaked: FALSE
[18:04:26.822]    - call: plan(strategy)
[18:04:26.823] plan(): nbrOfWorkers() = 1
[18:04:26.824] SequentialFuture started (and completed)
[18:04:26.824] - Launch lazy future ... done
[18:04:26.824] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[18:04:26.826] getGlobalsAndPackages() ...
[18:04:26.826] Searching for globals...
[18:04:26.829] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[18:04:26.829] Searching for globals ... DONE
[18:04:26.829] Resolving globals: FALSE
[18:04:26.830] The total size of the 1 globals is 96 bytes (96 bytes)
[18:04:26.831] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[18:04:26.834] - globals: [1] ‘x’
[18:04:26.834] - packages: [1] ‘stats’
[18:04:26.834] getGlobalsAndPackages() ... DONE
[18:04:26.835] run() for ‘Future’ ...
[18:04:26.835] - state: ‘created’
[18:04:26.835] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:26.836] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:26.836] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:26.836]   - Field: ‘label’
[18:04:26.837]   - Field: ‘local’
[18:04:26.837]   - Field: ‘owner’
[18:04:26.837]   - Field: ‘envir’
[18:04:26.837]   - Field: ‘packages’
[18:04:26.837]   - Field: ‘gc’
[18:04:26.838]   - Field: ‘conditions’
[18:04:26.838]   - Field: ‘expr’
[18:04:26.838]   - Field: ‘uuid’
[18:04:26.838]   - Field: ‘seed’
[18:04:26.838]   - Field: ‘version’
[18:04:26.839]   - Field: ‘result’
[18:04:26.839]   - Field: ‘asynchronous’
[18:04:26.839]   - Field: ‘calls’
[18:04:26.839]   - Field: ‘globals’
[18:04:26.839]   - Field: ‘stdout’
[18:04:26.840]   - Field: ‘earlySignal’
[18:04:26.840]   - Field: ‘lazy’
[18:04:26.840]   - Field: ‘state’
[18:04:26.840] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:26.840] - Launch lazy future ...
[18:04:26.841] Packages needed by the future expression (n = 1): ‘stats’
[18:04:26.841] Packages needed by future strategies (n = 0): <none>
[18:04:26.842] {
[18:04:26.842]     {
[18:04:26.842]         {
[18:04:26.842]             ...future.startTime <- base::Sys.time()
[18:04:26.842]             {
[18:04:26.842]                 {
[18:04:26.842]                   {
[18:04:26.842]                     {
[18:04:26.842]                       base::local({
[18:04:26.842]                         has_future <- base::requireNamespace("future", 
[18:04:26.842]                           quietly = TRUE)
[18:04:26.842]                         if (has_future) {
[18:04:26.842]                           ns <- base::getNamespace("future")
[18:04:26.842]                           version <- ns[[".package"]][["version"]]
[18:04:26.842]                           if (is.null(version)) 
[18:04:26.842]                             version <- utils::packageVersion("future")
[18:04:26.842]                         }
[18:04:26.842]                         else {
[18:04:26.842]                           version <- NULL
[18:04:26.842]                         }
[18:04:26.842]                         if (!has_future || version < "1.8.0") {
[18:04:26.842]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:26.842]                             "", base::R.version$version.string), 
[18:04:26.842]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:26.842]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:26.842]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:26.842]                               "release", "version")], collapse = " "), 
[18:04:26.842]                             hostname = base::Sys.info()[["nodename"]])
[18:04:26.842]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:26.842]                             info)
[18:04:26.842]                           info <- base::paste(info, collapse = "; ")
[18:04:26.842]                           if (!has_future) {
[18:04:26.842]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:26.842]                               info)
[18:04:26.842]                           }
[18:04:26.842]                           else {
[18:04:26.842]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:26.842]                               info, version)
[18:04:26.842]                           }
[18:04:26.842]                           base::stop(msg)
[18:04:26.842]                         }
[18:04:26.842]                       })
[18:04:26.842]                     }
[18:04:26.842]                     base::local({
[18:04:26.842]                       for (pkg in "stats") {
[18:04:26.842]                         base::loadNamespace(pkg)
[18:04:26.842]                         base::library(pkg, character.only = TRUE)
[18:04:26.842]                       }
[18:04:26.842]                     })
[18:04:26.842]                   }
[18:04:26.842]                   ...future.strategy.old <- future::plan("list")
[18:04:26.842]                   options(future.plan = NULL)
[18:04:26.842]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.842]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:26.842]                 }
[18:04:26.842]                 ...future.workdir <- getwd()
[18:04:26.842]             }
[18:04:26.842]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:26.842]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:26.842]         }
[18:04:26.842]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:26.842]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:26.842]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:26.842]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:26.842]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:26.842]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:26.842]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:26.842]             base::names(...future.oldOptions))
[18:04:26.842]     }
[18:04:26.842]     if (FALSE) {
[18:04:26.842]     }
[18:04:26.842]     else {
[18:04:26.842]         if (TRUE) {
[18:04:26.842]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:26.842]                 open = "w")
[18:04:26.842]         }
[18:04:26.842]         else {
[18:04:26.842]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:26.842]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:26.842]         }
[18:04:26.842]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:26.842]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:26.842]             base::sink(type = "output", split = FALSE)
[18:04:26.842]             base::close(...future.stdout)
[18:04:26.842]         }, add = TRUE)
[18:04:26.842]     }
[18:04:26.842]     ...future.frame <- base::sys.nframe()
[18:04:26.842]     ...future.conditions <- base::list()
[18:04:26.842]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:26.842]     if (FALSE) {
[18:04:26.842]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:26.842]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:26.842]     }
[18:04:26.842]     ...future.result <- base::tryCatch({
[18:04:26.842]         base::withCallingHandlers({
[18:04:26.842]             ...future.value <- base::withVisible(base::local({
[18:04:26.842]                 xtabs(~x)
[18:04:26.842]             }))
[18:04:26.842]             future::FutureResult(value = ...future.value$value, 
[18:04:26.842]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.842]                   ...future.rng), globalenv = if (FALSE) 
[18:04:26.842]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:26.842]                     ...future.globalenv.names))
[18:04:26.842]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:26.842]         }, condition = base::local({
[18:04:26.842]             c <- base::c
[18:04:26.842]             inherits <- base::inherits
[18:04:26.842]             invokeRestart <- base::invokeRestart
[18:04:26.842]             length <- base::length
[18:04:26.842]             list <- base::list
[18:04:26.842]             seq.int <- base::seq.int
[18:04:26.842]             signalCondition <- base::signalCondition
[18:04:26.842]             sys.calls <- base::sys.calls
[18:04:26.842]             `[[` <- base::`[[`
[18:04:26.842]             `+` <- base::`+`
[18:04:26.842]             `<<-` <- base::`<<-`
[18:04:26.842]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:26.842]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:26.842]                   3L)]
[18:04:26.842]             }
[18:04:26.842]             function(cond) {
[18:04:26.842]                 is_error <- inherits(cond, "error")
[18:04:26.842]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:26.842]                   NULL)
[18:04:26.842]                 if (is_error) {
[18:04:26.842]                   sessionInformation <- function() {
[18:04:26.842]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:26.842]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:26.842]                       search = base::search(), system = base::Sys.info())
[18:04:26.842]                   }
[18:04:26.842]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.842]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:26.842]                     cond$call), session = sessionInformation(), 
[18:04:26.842]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:26.842]                   signalCondition(cond)
[18:04:26.842]                 }
[18:04:26.842]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:26.842]                 "immediateCondition"))) {
[18:04:26.842]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:26.842]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.842]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:26.842]                   if (TRUE && !signal) {
[18:04:26.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.842]                     {
[18:04:26.842]                       inherits <- base::inherits
[18:04:26.842]                       invokeRestart <- base::invokeRestart
[18:04:26.842]                       is.null <- base::is.null
[18:04:26.842]                       muffled <- FALSE
[18:04:26.842]                       if (inherits(cond, "message")) {
[18:04:26.842]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.842]                         if (muffled) 
[18:04:26.842]                           invokeRestart("muffleMessage")
[18:04:26.842]                       }
[18:04:26.842]                       else if (inherits(cond, "warning")) {
[18:04:26.842]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.842]                         if (muffled) 
[18:04:26.842]                           invokeRestart("muffleWarning")
[18:04:26.842]                       }
[18:04:26.842]                       else if (inherits(cond, "condition")) {
[18:04:26.842]                         if (!is.null(pattern)) {
[18:04:26.842]                           computeRestarts <- base::computeRestarts
[18:04:26.842]                           grepl <- base::grepl
[18:04:26.842]                           restarts <- computeRestarts(cond)
[18:04:26.842]                           for (restart in restarts) {
[18:04:26.842]                             name <- restart$name
[18:04:26.842]                             if (is.null(name)) 
[18:04:26.842]                               next
[18:04:26.842]                             if (!grepl(pattern, name)) 
[18:04:26.842]                               next
[18:04:26.842]                             invokeRestart(restart)
[18:04:26.842]                             muffled <- TRUE
[18:04:26.842]                             break
[18:04:26.842]                           }
[18:04:26.842]                         }
[18:04:26.842]                       }
[18:04:26.842]                       invisible(muffled)
[18:04:26.842]                     }
[18:04:26.842]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.842]                   }
[18:04:26.842]                 }
[18:04:26.842]                 else {
[18:04:26.842]                   if (TRUE) {
[18:04:26.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.842]                     {
[18:04:26.842]                       inherits <- base::inherits
[18:04:26.842]                       invokeRestart <- base::invokeRestart
[18:04:26.842]                       is.null <- base::is.null
[18:04:26.842]                       muffled <- FALSE
[18:04:26.842]                       if (inherits(cond, "message")) {
[18:04:26.842]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.842]                         if (muffled) 
[18:04:26.842]                           invokeRestart("muffleMessage")
[18:04:26.842]                       }
[18:04:26.842]                       else if (inherits(cond, "warning")) {
[18:04:26.842]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.842]                         if (muffled) 
[18:04:26.842]                           invokeRestart("muffleWarning")
[18:04:26.842]                       }
[18:04:26.842]                       else if (inherits(cond, "condition")) {
[18:04:26.842]                         if (!is.null(pattern)) {
[18:04:26.842]                           computeRestarts <- base::computeRestarts
[18:04:26.842]                           grepl <- base::grepl
[18:04:26.842]                           restarts <- computeRestarts(cond)
[18:04:26.842]                           for (restart in restarts) {
[18:04:26.842]                             name <- restart$name
[18:04:26.842]                             if (is.null(name)) 
[18:04:26.842]                               next
[18:04:26.842]                             if (!grepl(pattern, name)) 
[18:04:26.842]                               next
[18:04:26.842]                             invokeRestart(restart)
[18:04:26.842]                             muffled <- TRUE
[18:04:26.842]                             break
[18:04:26.842]                           }
[18:04:26.842]                         }
[18:04:26.842]                       }
[18:04:26.842]                       invisible(muffled)
[18:04:26.842]                     }
[18:04:26.842]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.842]                   }
[18:04:26.842]                 }
[18:04:26.842]             }
[18:04:26.842]         }))
[18:04:26.842]     }, error = function(ex) {
[18:04:26.842]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:26.842]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.842]                 ...future.rng), started = ...future.startTime, 
[18:04:26.842]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:26.842]             version = "1.8"), class = "FutureResult")
[18:04:26.842]     }, finally = {
[18:04:26.842]         if (!identical(...future.workdir, getwd())) 
[18:04:26.842]             setwd(...future.workdir)
[18:04:26.842]         {
[18:04:26.842]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:26.842]                 ...future.oldOptions$nwarnings <- NULL
[18:04:26.842]             }
[18:04:26.842]             base::options(...future.oldOptions)
[18:04:26.842]             if (.Platform$OS.type == "windows") {
[18:04:26.842]                 old_names <- names(...future.oldEnvVars)
[18:04:26.842]                 envs <- base::Sys.getenv()
[18:04:26.842]                 names <- names(envs)
[18:04:26.842]                 common <- intersect(names, old_names)
[18:04:26.842]                 added <- setdiff(names, old_names)
[18:04:26.842]                 removed <- setdiff(old_names, names)
[18:04:26.842]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:26.842]                   envs[common]]
[18:04:26.842]                 NAMES <- toupper(changed)
[18:04:26.842]                 args <- list()
[18:04:26.842]                 for (kk in seq_along(NAMES)) {
[18:04:26.842]                   name <- changed[[kk]]
[18:04:26.842]                   NAME <- NAMES[[kk]]
[18:04:26.842]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.842]                     next
[18:04:26.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.842]                 }
[18:04:26.842]                 NAMES <- toupper(added)
[18:04:26.842]                 for (kk in seq_along(NAMES)) {
[18:04:26.842]                   name <- added[[kk]]
[18:04:26.842]                   NAME <- NAMES[[kk]]
[18:04:26.842]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.842]                     next
[18:04:26.842]                   args[[name]] <- ""
[18:04:26.842]                 }
[18:04:26.842]                 NAMES <- toupper(removed)
[18:04:26.842]                 for (kk in seq_along(NAMES)) {
[18:04:26.842]                   name <- removed[[kk]]
[18:04:26.842]                   NAME <- NAMES[[kk]]
[18:04:26.842]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.842]                     next
[18:04:26.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.842]                 }
[18:04:26.842]                 if (length(args) > 0) 
[18:04:26.842]                   base::do.call(base::Sys.setenv, args = args)
[18:04:26.842]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:26.842]             }
[18:04:26.842]             else {
[18:04:26.842]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:26.842]             }
[18:04:26.842]             {
[18:04:26.842]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:26.842]                   0L) {
[18:04:26.842]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:26.842]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:26.842]                   base::options(opts)
[18:04:26.842]                 }
[18:04:26.842]                 {
[18:04:26.842]                   {
[18:04:26.842]                     NULL
[18:04:26.842]                     RNGkind("Mersenne-Twister")
[18:04:26.842]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:26.842]                       inherits = FALSE)
[18:04:26.842]                   }
[18:04:26.842]                   options(future.plan = NULL)
[18:04:26.842]                   if (is.na(NA_character_)) 
[18:04:26.842]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.842]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:26.842]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:26.842]                     .init = FALSE)
[18:04:26.842]                 }
[18:04:26.842]             }
[18:04:26.842]         }
[18:04:26.842]     })
[18:04:26.842]     if (TRUE) {
[18:04:26.842]         base::sink(type = "output", split = FALSE)
[18:04:26.842]         if (TRUE) {
[18:04:26.842]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:26.842]         }
[18:04:26.842]         else {
[18:04:26.842]             ...future.result["stdout"] <- base::list(NULL)
[18:04:26.842]         }
[18:04:26.842]         base::close(...future.stdout)
[18:04:26.842]         ...future.stdout <- NULL
[18:04:26.842]     }
[18:04:26.842]     ...future.result$conditions <- ...future.conditions
[18:04:26.842]     ...future.result$finished <- base::Sys.time()
[18:04:26.842]     ...future.result
[18:04:26.842] }
[18:04:26.846] assign_globals() ...
[18:04:26.846] List of 1
[18:04:26.846]  $ x: num [1:5] 1 1 2 2 2
[18:04:26.846]  - attr(*, "where")=List of 1
[18:04:26.846]   ..$ x:<environment: R_EmptyEnv> 
[18:04:26.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:26.846]  - attr(*, "resolved")= logi FALSE
[18:04:26.846]  - attr(*, "total_size")= num 96
[18:04:26.846]  - attr(*, "already-done")= logi TRUE
[18:04:26.851] - copied ‘x’ to environment
[18:04:26.851] assign_globals() ... done
[18:04:26.852] plan(): Setting new future strategy stack:
[18:04:26.853] List of future strategies:
[18:04:26.853] 1. sequential:
[18:04:26.853]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.853]    - tweaked: FALSE
[18:04:26.853]    - call: NULL
[18:04:26.854] plan(): nbrOfWorkers() = 1
[18:04:26.856] plan(): Setting new future strategy stack:
[18:04:26.856] List of future strategies:
[18:04:26.856] 1. sequential:
[18:04:26.856]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.856]    - tweaked: FALSE
[18:04:26.856]    - call: plan(strategy)
[18:04:26.857] plan(): nbrOfWorkers() = 1
[18:04:26.857] SequentialFuture started (and completed)
[18:04:26.858] - Launch lazy future ... done
[18:04:26.858] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[18:04:26.862] getGlobalsAndPackages() ...
[18:04:26.862] Searching for globals...
[18:04:26.866] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[18:04:26.866] Searching for globals ... DONE
[18:04:26.867] Resolving globals: FALSE
[18:04:26.868] 
[18:04:26.868] - packages: [2] ‘stats’, ‘datasets’
[18:04:26.868] getGlobalsAndPackages() ... DONE
[18:04:26.869] run() for ‘Future’ ...
[18:04:26.869] - state: ‘created’
[18:04:26.869] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:26.870] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:26.870] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:26.870]   - Field: ‘label’
[18:04:26.871]   - Field: ‘local’
[18:04:26.871]   - Field: ‘owner’
[18:04:26.871]   - Field: ‘envir’
[18:04:26.871]   - Field: ‘packages’
[18:04:26.871]   - Field: ‘gc’
[18:04:26.872]   - Field: ‘conditions’
[18:04:26.872]   - Field: ‘expr’
[18:04:26.872]   - Field: ‘uuid’
[18:04:26.872]   - Field: ‘seed’
[18:04:26.872]   - Field: ‘version’
[18:04:26.873]   - Field: ‘result’
[18:04:26.873]   - Field: ‘asynchronous’
[18:04:26.873]   - Field: ‘calls’
[18:04:26.873]   - Field: ‘globals’
[18:04:26.873]   - Field: ‘stdout’
[18:04:26.874]   - Field: ‘earlySignal’
[18:04:26.874]   - Field: ‘lazy’
[18:04:26.874]   - Field: ‘state’
[18:04:26.874] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:26.874] - Launch lazy future ...
[18:04:26.875] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:26.875] Packages needed by future strategies (n = 0): <none>
[18:04:26.876] {
[18:04:26.876]     {
[18:04:26.876]         {
[18:04:26.876]             ...future.startTime <- base::Sys.time()
[18:04:26.876]             {
[18:04:26.876]                 {
[18:04:26.876]                   {
[18:04:26.876]                     {
[18:04:26.876]                       base::local({
[18:04:26.876]                         has_future <- base::requireNamespace("future", 
[18:04:26.876]                           quietly = TRUE)
[18:04:26.876]                         if (has_future) {
[18:04:26.876]                           ns <- base::getNamespace("future")
[18:04:26.876]                           version <- ns[[".package"]][["version"]]
[18:04:26.876]                           if (is.null(version)) 
[18:04:26.876]                             version <- utils::packageVersion("future")
[18:04:26.876]                         }
[18:04:26.876]                         else {
[18:04:26.876]                           version <- NULL
[18:04:26.876]                         }
[18:04:26.876]                         if (!has_future || version < "1.8.0") {
[18:04:26.876]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:26.876]                             "", base::R.version$version.string), 
[18:04:26.876]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:26.876]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:26.876]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:26.876]                               "release", "version")], collapse = " "), 
[18:04:26.876]                             hostname = base::Sys.info()[["nodename"]])
[18:04:26.876]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:26.876]                             info)
[18:04:26.876]                           info <- base::paste(info, collapse = "; ")
[18:04:26.876]                           if (!has_future) {
[18:04:26.876]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:26.876]                               info)
[18:04:26.876]                           }
[18:04:26.876]                           else {
[18:04:26.876]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:26.876]                               info, version)
[18:04:26.876]                           }
[18:04:26.876]                           base::stop(msg)
[18:04:26.876]                         }
[18:04:26.876]                       })
[18:04:26.876]                     }
[18:04:26.876]                     base::local({
[18:04:26.876]                       for (pkg in c("stats", "datasets")) {
[18:04:26.876]                         base::loadNamespace(pkg)
[18:04:26.876]                         base::library(pkg, character.only = TRUE)
[18:04:26.876]                       }
[18:04:26.876]                     })
[18:04:26.876]                   }
[18:04:26.876]                   ...future.strategy.old <- future::plan("list")
[18:04:26.876]                   options(future.plan = NULL)
[18:04:26.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:26.876]                 }
[18:04:26.876]                 ...future.workdir <- getwd()
[18:04:26.876]             }
[18:04:26.876]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:26.876]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:26.876]         }
[18:04:26.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:26.876]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:26.876]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:26.876]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:26.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:26.876]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:26.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:26.876]             base::names(...future.oldOptions))
[18:04:26.876]     }
[18:04:26.876]     if (FALSE) {
[18:04:26.876]     }
[18:04:26.876]     else {
[18:04:26.876]         if (TRUE) {
[18:04:26.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:26.876]                 open = "w")
[18:04:26.876]         }
[18:04:26.876]         else {
[18:04:26.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:26.876]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:26.876]         }
[18:04:26.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:26.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:26.876]             base::sink(type = "output", split = FALSE)
[18:04:26.876]             base::close(...future.stdout)
[18:04:26.876]         }, add = TRUE)
[18:04:26.876]     }
[18:04:26.876]     ...future.frame <- base::sys.nframe()
[18:04:26.876]     ...future.conditions <- base::list()
[18:04:26.876]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:26.876]     if (FALSE) {
[18:04:26.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:26.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:26.876]     }
[18:04:26.876]     ...future.result <- base::tryCatch({
[18:04:26.876]         base::withCallingHandlers({
[18:04:26.876]             ...future.value <- base::withVisible(base::local({
[18:04:26.876]                 lm(dist ~ . - 1, data = cars)
[18:04:26.876]             }))
[18:04:26.876]             future::FutureResult(value = ...future.value$value, 
[18:04:26.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.876]                   ...future.rng), globalenv = if (FALSE) 
[18:04:26.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:26.876]                     ...future.globalenv.names))
[18:04:26.876]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:26.876]         }, condition = base::local({
[18:04:26.876]             c <- base::c
[18:04:26.876]             inherits <- base::inherits
[18:04:26.876]             invokeRestart <- base::invokeRestart
[18:04:26.876]             length <- base::length
[18:04:26.876]             list <- base::list
[18:04:26.876]             seq.int <- base::seq.int
[18:04:26.876]             signalCondition <- base::signalCondition
[18:04:26.876]             sys.calls <- base::sys.calls
[18:04:26.876]             `[[` <- base::`[[`
[18:04:26.876]             `+` <- base::`+`
[18:04:26.876]             `<<-` <- base::`<<-`
[18:04:26.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:26.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:26.876]                   3L)]
[18:04:26.876]             }
[18:04:26.876]             function(cond) {
[18:04:26.876]                 is_error <- inherits(cond, "error")
[18:04:26.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:26.876]                   NULL)
[18:04:26.876]                 if (is_error) {
[18:04:26.876]                   sessionInformation <- function() {
[18:04:26.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:26.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:26.876]                       search = base::search(), system = base::Sys.info())
[18:04:26.876]                   }
[18:04:26.876]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:26.876]                     cond$call), session = sessionInformation(), 
[18:04:26.876]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:26.876]                   signalCondition(cond)
[18:04:26.876]                 }
[18:04:26.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:26.876]                 "immediateCondition"))) {
[18:04:26.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:26.876]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:26.876]                   if (TRUE && !signal) {
[18:04:26.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.876]                     {
[18:04:26.876]                       inherits <- base::inherits
[18:04:26.876]                       invokeRestart <- base::invokeRestart
[18:04:26.876]                       is.null <- base::is.null
[18:04:26.876]                       muffled <- FALSE
[18:04:26.876]                       if (inherits(cond, "message")) {
[18:04:26.876]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.876]                         if (muffled) 
[18:04:26.876]                           invokeRestart("muffleMessage")
[18:04:26.876]                       }
[18:04:26.876]                       else if (inherits(cond, "warning")) {
[18:04:26.876]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.876]                         if (muffled) 
[18:04:26.876]                           invokeRestart("muffleWarning")
[18:04:26.876]                       }
[18:04:26.876]                       else if (inherits(cond, "condition")) {
[18:04:26.876]                         if (!is.null(pattern)) {
[18:04:26.876]                           computeRestarts <- base::computeRestarts
[18:04:26.876]                           grepl <- base::grepl
[18:04:26.876]                           restarts <- computeRestarts(cond)
[18:04:26.876]                           for (restart in restarts) {
[18:04:26.876]                             name <- restart$name
[18:04:26.876]                             if (is.null(name)) 
[18:04:26.876]                               next
[18:04:26.876]                             if (!grepl(pattern, name)) 
[18:04:26.876]                               next
[18:04:26.876]                             invokeRestart(restart)
[18:04:26.876]                             muffled <- TRUE
[18:04:26.876]                             break
[18:04:26.876]                           }
[18:04:26.876]                         }
[18:04:26.876]                       }
[18:04:26.876]                       invisible(muffled)
[18:04:26.876]                     }
[18:04:26.876]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.876]                   }
[18:04:26.876]                 }
[18:04:26.876]                 else {
[18:04:26.876]                   if (TRUE) {
[18:04:26.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.876]                     {
[18:04:26.876]                       inherits <- base::inherits
[18:04:26.876]                       invokeRestart <- base::invokeRestart
[18:04:26.876]                       is.null <- base::is.null
[18:04:26.876]                       muffled <- FALSE
[18:04:26.876]                       if (inherits(cond, "message")) {
[18:04:26.876]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.876]                         if (muffled) 
[18:04:26.876]                           invokeRestart("muffleMessage")
[18:04:26.876]                       }
[18:04:26.876]                       else if (inherits(cond, "warning")) {
[18:04:26.876]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.876]                         if (muffled) 
[18:04:26.876]                           invokeRestart("muffleWarning")
[18:04:26.876]                       }
[18:04:26.876]                       else if (inherits(cond, "condition")) {
[18:04:26.876]                         if (!is.null(pattern)) {
[18:04:26.876]                           computeRestarts <- base::computeRestarts
[18:04:26.876]                           grepl <- base::grepl
[18:04:26.876]                           restarts <- computeRestarts(cond)
[18:04:26.876]                           for (restart in restarts) {
[18:04:26.876]                             name <- restart$name
[18:04:26.876]                             if (is.null(name)) 
[18:04:26.876]                               next
[18:04:26.876]                             if (!grepl(pattern, name)) 
[18:04:26.876]                               next
[18:04:26.876]                             invokeRestart(restart)
[18:04:26.876]                             muffled <- TRUE
[18:04:26.876]                             break
[18:04:26.876]                           }
[18:04:26.876]                         }
[18:04:26.876]                       }
[18:04:26.876]                       invisible(muffled)
[18:04:26.876]                     }
[18:04:26.876]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.876]                   }
[18:04:26.876]                 }
[18:04:26.876]             }
[18:04:26.876]         }))
[18:04:26.876]     }, error = function(ex) {
[18:04:26.876]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:26.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.876]                 ...future.rng), started = ...future.startTime, 
[18:04:26.876]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:26.876]             version = "1.8"), class = "FutureResult")
[18:04:26.876]     }, finally = {
[18:04:26.876]         if (!identical(...future.workdir, getwd())) 
[18:04:26.876]             setwd(...future.workdir)
[18:04:26.876]         {
[18:04:26.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:26.876]                 ...future.oldOptions$nwarnings <- NULL
[18:04:26.876]             }
[18:04:26.876]             base::options(...future.oldOptions)
[18:04:26.876]             if (.Platform$OS.type == "windows") {
[18:04:26.876]                 old_names <- names(...future.oldEnvVars)
[18:04:26.876]                 envs <- base::Sys.getenv()
[18:04:26.876]                 names <- names(envs)
[18:04:26.876]                 common <- intersect(names, old_names)
[18:04:26.876]                 added <- setdiff(names, old_names)
[18:04:26.876]                 removed <- setdiff(old_names, names)
[18:04:26.876]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:26.876]                   envs[common]]
[18:04:26.876]                 NAMES <- toupper(changed)
[18:04:26.876]                 args <- list()
[18:04:26.876]                 for (kk in seq_along(NAMES)) {
[18:04:26.876]                   name <- changed[[kk]]
[18:04:26.876]                   NAME <- NAMES[[kk]]
[18:04:26.876]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.876]                     next
[18:04:26.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.876]                 }
[18:04:26.876]                 NAMES <- toupper(added)
[18:04:26.876]                 for (kk in seq_along(NAMES)) {
[18:04:26.876]                   name <- added[[kk]]
[18:04:26.876]                   NAME <- NAMES[[kk]]
[18:04:26.876]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.876]                     next
[18:04:26.876]                   args[[name]] <- ""
[18:04:26.876]                 }
[18:04:26.876]                 NAMES <- toupper(removed)
[18:04:26.876]                 for (kk in seq_along(NAMES)) {
[18:04:26.876]                   name <- removed[[kk]]
[18:04:26.876]                   NAME <- NAMES[[kk]]
[18:04:26.876]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.876]                     next
[18:04:26.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.876]                 }
[18:04:26.876]                 if (length(args) > 0) 
[18:04:26.876]                   base::do.call(base::Sys.setenv, args = args)
[18:04:26.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:26.876]             }
[18:04:26.876]             else {
[18:04:26.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:26.876]             }
[18:04:26.876]             {
[18:04:26.876]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:26.876]                   0L) {
[18:04:26.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:26.876]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:26.876]                   base::options(opts)
[18:04:26.876]                 }
[18:04:26.876]                 {
[18:04:26.876]                   {
[18:04:26.876]                     NULL
[18:04:26.876]                     RNGkind("Mersenne-Twister")
[18:04:26.876]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:26.876]                       inherits = FALSE)
[18:04:26.876]                   }
[18:04:26.876]                   options(future.plan = NULL)
[18:04:26.876]                   if (is.na(NA_character_)) 
[18:04:26.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:26.876]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:26.876]                     .init = FALSE)
[18:04:26.876]                 }
[18:04:26.876]             }
[18:04:26.876]         }
[18:04:26.876]     })
[18:04:26.876]     if (TRUE) {
[18:04:26.876]         base::sink(type = "output", split = FALSE)
[18:04:26.876]         if (TRUE) {
[18:04:26.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:26.876]         }
[18:04:26.876]         else {
[18:04:26.876]             ...future.result["stdout"] <- base::list(NULL)
[18:04:26.876]         }
[18:04:26.876]         base::close(...future.stdout)
[18:04:26.876]         ...future.stdout <- NULL
[18:04:26.876]     }
[18:04:26.876]     ...future.result$conditions <- ...future.conditions
[18:04:26.876]     ...future.result$finished <- base::Sys.time()
[18:04:26.876]     ...future.result
[18:04:26.876] }
[18:04:26.880] plan(): Setting new future strategy stack:
[18:04:26.880] List of future strategies:
[18:04:26.880] 1. sequential:
[18:04:26.880]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.880]    - tweaked: FALSE
[18:04:26.880]    - call: NULL
[18:04:26.882] plan(): nbrOfWorkers() = 1
[18:04:26.884] plan(): Setting new future strategy stack:
[18:04:26.885] List of future strategies:
[18:04:26.885] 1. sequential:
[18:04:26.885]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.885]    - tweaked: FALSE
[18:04:26.885]    - call: plan(strategy)
[18:04:26.886] plan(): nbrOfWorkers() = 1
[18:04:26.886] SequentialFuture started (and completed)
[18:04:26.886] - Launch lazy future ... done
[18:04:26.887] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[18:04:26.892] getGlobalsAndPackages() ...
[18:04:26.892] Searching for globals...
[18:04:26.898] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[18:04:26.898] Searching for globals ... DONE
[18:04:26.899] Resolving globals: FALSE
[18:04:26.900] 
[18:04:26.900] - packages: [2] ‘stats’, ‘datasets’
[18:04:26.900] getGlobalsAndPackages() ... DONE
[18:04:26.901] run() for ‘Future’ ...
[18:04:26.901] - state: ‘created’
[18:04:26.901] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:26.902] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:26.902] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:26.902]   - Field: ‘label’
[18:04:26.903]   - Field: ‘local’
[18:04:26.903]   - Field: ‘owner’
[18:04:26.903]   - Field: ‘envir’
[18:04:26.903]   - Field: ‘packages’
[18:04:26.903]   - Field: ‘gc’
[18:04:26.904]   - Field: ‘conditions’
[18:04:26.904]   - Field: ‘expr’
[18:04:26.904]   - Field: ‘uuid’
[18:04:26.904]   - Field: ‘seed’
[18:04:26.904]   - Field: ‘version’
[18:04:26.905]   - Field: ‘result’
[18:04:26.905]   - Field: ‘asynchronous’
[18:04:26.905]   - Field: ‘calls’
[18:04:26.905]   - Field: ‘globals’
[18:04:26.905]   - Field: ‘stdout’
[18:04:26.906]   - Field: ‘earlySignal’
[18:04:26.906]   - Field: ‘lazy’
[18:04:26.906]   - Field: ‘state’
[18:04:26.906] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:26.907] - Launch lazy future ...
[18:04:26.907] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:26.907] Packages needed by future strategies (n = 0): <none>
[18:04:26.908] {
[18:04:26.908]     {
[18:04:26.908]         {
[18:04:26.908]             ...future.startTime <- base::Sys.time()
[18:04:26.908]             {
[18:04:26.908]                 {
[18:04:26.908]                   {
[18:04:26.908]                     {
[18:04:26.908]                       base::local({
[18:04:26.908]                         has_future <- base::requireNamespace("future", 
[18:04:26.908]                           quietly = TRUE)
[18:04:26.908]                         if (has_future) {
[18:04:26.908]                           ns <- base::getNamespace("future")
[18:04:26.908]                           version <- ns[[".package"]][["version"]]
[18:04:26.908]                           if (is.null(version)) 
[18:04:26.908]                             version <- utils::packageVersion("future")
[18:04:26.908]                         }
[18:04:26.908]                         else {
[18:04:26.908]                           version <- NULL
[18:04:26.908]                         }
[18:04:26.908]                         if (!has_future || version < "1.8.0") {
[18:04:26.908]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:26.908]                             "", base::R.version$version.string), 
[18:04:26.908]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:26.908]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:26.908]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:26.908]                               "release", "version")], collapse = " "), 
[18:04:26.908]                             hostname = base::Sys.info()[["nodename"]])
[18:04:26.908]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:26.908]                             info)
[18:04:26.908]                           info <- base::paste(info, collapse = "; ")
[18:04:26.908]                           if (!has_future) {
[18:04:26.908]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:26.908]                               info)
[18:04:26.908]                           }
[18:04:26.908]                           else {
[18:04:26.908]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:26.908]                               info, version)
[18:04:26.908]                           }
[18:04:26.908]                           base::stop(msg)
[18:04:26.908]                         }
[18:04:26.908]                       })
[18:04:26.908]                     }
[18:04:26.908]                     base::local({
[18:04:26.908]                       for (pkg in c("stats", "datasets")) {
[18:04:26.908]                         base::loadNamespace(pkg)
[18:04:26.908]                         base::library(pkg, character.only = TRUE)
[18:04:26.908]                       }
[18:04:26.908]                     })
[18:04:26.908]                   }
[18:04:26.908]                   ...future.strategy.old <- future::plan("list")
[18:04:26.908]                   options(future.plan = NULL)
[18:04:26.908]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.908]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:26.908]                 }
[18:04:26.908]                 ...future.workdir <- getwd()
[18:04:26.908]             }
[18:04:26.908]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:26.908]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:26.908]         }
[18:04:26.908]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:26.908]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:26.908]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:26.908]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:26.908]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:26.908]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:26.908]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:26.908]             base::names(...future.oldOptions))
[18:04:26.908]     }
[18:04:26.908]     if (FALSE) {
[18:04:26.908]     }
[18:04:26.908]     else {
[18:04:26.908]         if (TRUE) {
[18:04:26.908]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:26.908]                 open = "w")
[18:04:26.908]         }
[18:04:26.908]         else {
[18:04:26.908]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:26.908]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:26.908]         }
[18:04:26.908]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:26.908]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:26.908]             base::sink(type = "output", split = FALSE)
[18:04:26.908]             base::close(...future.stdout)
[18:04:26.908]         }, add = TRUE)
[18:04:26.908]     }
[18:04:26.908]     ...future.frame <- base::sys.nframe()
[18:04:26.908]     ...future.conditions <- base::list()
[18:04:26.908]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:26.908]     if (FALSE) {
[18:04:26.908]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:26.908]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:26.908]     }
[18:04:26.908]     ...future.result <- base::tryCatch({
[18:04:26.908]         base::withCallingHandlers({
[18:04:26.908]             ...future.value <- base::withVisible(base::local({
[18:04:26.908]                 lm(dist ~ . + 0, data = cars)
[18:04:26.908]             }))
[18:04:26.908]             future::FutureResult(value = ...future.value$value, 
[18:04:26.908]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.908]                   ...future.rng), globalenv = if (FALSE) 
[18:04:26.908]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:26.908]                     ...future.globalenv.names))
[18:04:26.908]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:26.908]         }, condition = base::local({
[18:04:26.908]             c <- base::c
[18:04:26.908]             inherits <- base::inherits
[18:04:26.908]             invokeRestart <- base::invokeRestart
[18:04:26.908]             length <- base::length
[18:04:26.908]             list <- base::list
[18:04:26.908]             seq.int <- base::seq.int
[18:04:26.908]             signalCondition <- base::signalCondition
[18:04:26.908]             sys.calls <- base::sys.calls
[18:04:26.908]             `[[` <- base::`[[`
[18:04:26.908]             `+` <- base::`+`
[18:04:26.908]             `<<-` <- base::`<<-`
[18:04:26.908]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:26.908]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:26.908]                   3L)]
[18:04:26.908]             }
[18:04:26.908]             function(cond) {
[18:04:26.908]                 is_error <- inherits(cond, "error")
[18:04:26.908]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:26.908]                   NULL)
[18:04:26.908]                 if (is_error) {
[18:04:26.908]                   sessionInformation <- function() {
[18:04:26.908]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:26.908]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:26.908]                       search = base::search(), system = base::Sys.info())
[18:04:26.908]                   }
[18:04:26.908]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.908]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:26.908]                     cond$call), session = sessionInformation(), 
[18:04:26.908]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:26.908]                   signalCondition(cond)
[18:04:26.908]                 }
[18:04:26.908]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:26.908]                 "immediateCondition"))) {
[18:04:26.908]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:26.908]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.908]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:26.908]                   if (TRUE && !signal) {
[18:04:26.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.908]                     {
[18:04:26.908]                       inherits <- base::inherits
[18:04:26.908]                       invokeRestart <- base::invokeRestart
[18:04:26.908]                       is.null <- base::is.null
[18:04:26.908]                       muffled <- FALSE
[18:04:26.908]                       if (inherits(cond, "message")) {
[18:04:26.908]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.908]                         if (muffled) 
[18:04:26.908]                           invokeRestart("muffleMessage")
[18:04:26.908]                       }
[18:04:26.908]                       else if (inherits(cond, "warning")) {
[18:04:26.908]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.908]                         if (muffled) 
[18:04:26.908]                           invokeRestart("muffleWarning")
[18:04:26.908]                       }
[18:04:26.908]                       else if (inherits(cond, "condition")) {
[18:04:26.908]                         if (!is.null(pattern)) {
[18:04:26.908]                           computeRestarts <- base::computeRestarts
[18:04:26.908]                           grepl <- base::grepl
[18:04:26.908]                           restarts <- computeRestarts(cond)
[18:04:26.908]                           for (restart in restarts) {
[18:04:26.908]                             name <- restart$name
[18:04:26.908]                             if (is.null(name)) 
[18:04:26.908]                               next
[18:04:26.908]                             if (!grepl(pattern, name)) 
[18:04:26.908]                               next
[18:04:26.908]                             invokeRestart(restart)
[18:04:26.908]                             muffled <- TRUE
[18:04:26.908]                             break
[18:04:26.908]                           }
[18:04:26.908]                         }
[18:04:26.908]                       }
[18:04:26.908]                       invisible(muffled)
[18:04:26.908]                     }
[18:04:26.908]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.908]                   }
[18:04:26.908]                 }
[18:04:26.908]                 else {
[18:04:26.908]                   if (TRUE) {
[18:04:26.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.908]                     {
[18:04:26.908]                       inherits <- base::inherits
[18:04:26.908]                       invokeRestart <- base::invokeRestart
[18:04:26.908]                       is.null <- base::is.null
[18:04:26.908]                       muffled <- FALSE
[18:04:26.908]                       if (inherits(cond, "message")) {
[18:04:26.908]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.908]                         if (muffled) 
[18:04:26.908]                           invokeRestart("muffleMessage")
[18:04:26.908]                       }
[18:04:26.908]                       else if (inherits(cond, "warning")) {
[18:04:26.908]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.908]                         if (muffled) 
[18:04:26.908]                           invokeRestart("muffleWarning")
[18:04:26.908]                       }
[18:04:26.908]                       else if (inherits(cond, "condition")) {
[18:04:26.908]                         if (!is.null(pattern)) {
[18:04:26.908]                           computeRestarts <- base::computeRestarts
[18:04:26.908]                           grepl <- base::grepl
[18:04:26.908]                           restarts <- computeRestarts(cond)
[18:04:26.908]                           for (restart in restarts) {
[18:04:26.908]                             name <- restart$name
[18:04:26.908]                             if (is.null(name)) 
[18:04:26.908]                               next
[18:04:26.908]                             if (!grepl(pattern, name)) 
[18:04:26.908]                               next
[18:04:26.908]                             invokeRestart(restart)
[18:04:26.908]                             muffled <- TRUE
[18:04:26.908]                             break
[18:04:26.908]                           }
[18:04:26.908]                         }
[18:04:26.908]                       }
[18:04:26.908]                       invisible(muffled)
[18:04:26.908]                     }
[18:04:26.908]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.908]                   }
[18:04:26.908]                 }
[18:04:26.908]             }
[18:04:26.908]         }))
[18:04:26.908]     }, error = function(ex) {
[18:04:26.908]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:26.908]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.908]                 ...future.rng), started = ...future.startTime, 
[18:04:26.908]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:26.908]             version = "1.8"), class = "FutureResult")
[18:04:26.908]     }, finally = {
[18:04:26.908]         if (!identical(...future.workdir, getwd())) 
[18:04:26.908]             setwd(...future.workdir)
[18:04:26.908]         {
[18:04:26.908]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:26.908]                 ...future.oldOptions$nwarnings <- NULL
[18:04:26.908]             }
[18:04:26.908]             base::options(...future.oldOptions)
[18:04:26.908]             if (.Platform$OS.type == "windows") {
[18:04:26.908]                 old_names <- names(...future.oldEnvVars)
[18:04:26.908]                 envs <- base::Sys.getenv()
[18:04:26.908]                 names <- names(envs)
[18:04:26.908]                 common <- intersect(names, old_names)
[18:04:26.908]                 added <- setdiff(names, old_names)
[18:04:26.908]                 removed <- setdiff(old_names, names)
[18:04:26.908]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:26.908]                   envs[common]]
[18:04:26.908]                 NAMES <- toupper(changed)
[18:04:26.908]                 args <- list()
[18:04:26.908]                 for (kk in seq_along(NAMES)) {
[18:04:26.908]                   name <- changed[[kk]]
[18:04:26.908]                   NAME <- NAMES[[kk]]
[18:04:26.908]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.908]                     next
[18:04:26.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.908]                 }
[18:04:26.908]                 NAMES <- toupper(added)
[18:04:26.908]                 for (kk in seq_along(NAMES)) {
[18:04:26.908]                   name <- added[[kk]]
[18:04:26.908]                   NAME <- NAMES[[kk]]
[18:04:26.908]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.908]                     next
[18:04:26.908]                   args[[name]] <- ""
[18:04:26.908]                 }
[18:04:26.908]                 NAMES <- toupper(removed)
[18:04:26.908]                 for (kk in seq_along(NAMES)) {
[18:04:26.908]                   name <- removed[[kk]]
[18:04:26.908]                   NAME <- NAMES[[kk]]
[18:04:26.908]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.908]                     next
[18:04:26.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.908]                 }
[18:04:26.908]                 if (length(args) > 0) 
[18:04:26.908]                   base::do.call(base::Sys.setenv, args = args)
[18:04:26.908]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:26.908]             }
[18:04:26.908]             else {
[18:04:26.908]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:26.908]             }
[18:04:26.908]             {
[18:04:26.908]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:26.908]                   0L) {
[18:04:26.908]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:26.908]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:26.908]                   base::options(opts)
[18:04:26.908]                 }
[18:04:26.908]                 {
[18:04:26.908]                   {
[18:04:26.908]                     NULL
[18:04:26.908]                     RNGkind("Mersenne-Twister")
[18:04:26.908]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:26.908]                       inherits = FALSE)
[18:04:26.908]                   }
[18:04:26.908]                   options(future.plan = NULL)
[18:04:26.908]                   if (is.na(NA_character_)) 
[18:04:26.908]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.908]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:26.908]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:26.908]                     .init = FALSE)
[18:04:26.908]                 }
[18:04:26.908]             }
[18:04:26.908]         }
[18:04:26.908]     })
[18:04:26.908]     if (TRUE) {
[18:04:26.908]         base::sink(type = "output", split = FALSE)
[18:04:26.908]         if (TRUE) {
[18:04:26.908]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:26.908]         }
[18:04:26.908]         else {
[18:04:26.908]             ...future.result["stdout"] <- base::list(NULL)
[18:04:26.908]         }
[18:04:26.908]         base::close(...future.stdout)
[18:04:26.908]         ...future.stdout <- NULL
[18:04:26.908]     }
[18:04:26.908]     ...future.result$conditions <- ...future.conditions
[18:04:26.908]     ...future.result$finished <- base::Sys.time()
[18:04:26.908]     ...future.result
[18:04:26.908] }
[18:04:26.912] plan(): Setting new future strategy stack:
[18:04:26.913] List of future strategies:
[18:04:26.913] 1. sequential:
[18:04:26.913]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.913]    - tweaked: FALSE
[18:04:26.913]    - call: NULL
[18:04:26.914] plan(): nbrOfWorkers() = 1
[18:04:26.917] plan(): Setting new future strategy stack:
[18:04:26.917] List of future strategies:
[18:04:26.917] 1. sequential:
[18:04:26.917]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.917]    - tweaked: FALSE
[18:04:26.917]    - call: plan(strategy)
[18:04:26.918] plan(): nbrOfWorkers() = 1
[18:04:26.918] SequentialFuture started (and completed)
[18:04:26.919] - Launch lazy future ... done
[18:04:26.919] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[18:04:26.924] getGlobalsAndPackages() ...
[18:04:26.924] Searching for globals...
[18:04:26.928] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[18:04:26.929] Searching for globals ... DONE
[18:04:26.929] Resolving globals: FALSE
[18:04:26.930] 
[18:04:26.930] - packages: [2] ‘stats’, ‘datasets’
[18:04:26.930] getGlobalsAndPackages() ... DONE
[18:04:26.931] run() for ‘Future’ ...
[18:04:26.931] - state: ‘created’
[18:04:26.931] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:26.932] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:26.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:26.933]   - Field: ‘label’
[18:04:26.933]   - Field: ‘local’
[18:04:26.933]   - Field: ‘owner’
[18:04:26.933]   - Field: ‘envir’
[18:04:26.934]   - Field: ‘packages’
[18:04:26.934]   - Field: ‘gc’
[18:04:26.934]   - Field: ‘conditions’
[18:04:26.934]   - Field: ‘expr’
[18:04:26.934]   - Field: ‘uuid’
[18:04:26.935]   - Field: ‘seed’
[18:04:26.935]   - Field: ‘version’
[18:04:26.935]   - Field: ‘result’
[18:04:26.935]   - Field: ‘asynchronous’
[18:04:26.935]   - Field: ‘calls’
[18:04:26.936]   - Field: ‘globals’
[18:04:26.936]   - Field: ‘stdout’
[18:04:26.936]   - Field: ‘earlySignal’
[18:04:26.936]   - Field: ‘lazy’
[18:04:26.936]   - Field: ‘state’
[18:04:26.937] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:26.937] - Launch lazy future ...
[18:04:26.937] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:26.937] Packages needed by future strategies (n = 0): <none>
[18:04:26.939] {
[18:04:26.939]     {
[18:04:26.939]         {
[18:04:26.939]             ...future.startTime <- base::Sys.time()
[18:04:26.939]             {
[18:04:26.939]                 {
[18:04:26.939]                   {
[18:04:26.939]                     {
[18:04:26.939]                       base::local({
[18:04:26.939]                         has_future <- base::requireNamespace("future", 
[18:04:26.939]                           quietly = TRUE)
[18:04:26.939]                         if (has_future) {
[18:04:26.939]                           ns <- base::getNamespace("future")
[18:04:26.939]                           version <- ns[[".package"]][["version"]]
[18:04:26.939]                           if (is.null(version)) 
[18:04:26.939]                             version <- utils::packageVersion("future")
[18:04:26.939]                         }
[18:04:26.939]                         else {
[18:04:26.939]                           version <- NULL
[18:04:26.939]                         }
[18:04:26.939]                         if (!has_future || version < "1.8.0") {
[18:04:26.939]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:26.939]                             "", base::R.version$version.string), 
[18:04:26.939]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:26.939]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:26.939]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:26.939]                               "release", "version")], collapse = " "), 
[18:04:26.939]                             hostname = base::Sys.info()[["nodename"]])
[18:04:26.939]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:26.939]                             info)
[18:04:26.939]                           info <- base::paste(info, collapse = "; ")
[18:04:26.939]                           if (!has_future) {
[18:04:26.939]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:26.939]                               info)
[18:04:26.939]                           }
[18:04:26.939]                           else {
[18:04:26.939]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:26.939]                               info, version)
[18:04:26.939]                           }
[18:04:26.939]                           base::stop(msg)
[18:04:26.939]                         }
[18:04:26.939]                       })
[18:04:26.939]                     }
[18:04:26.939]                     base::local({
[18:04:26.939]                       for (pkg in c("stats", "datasets")) {
[18:04:26.939]                         base::loadNamespace(pkg)
[18:04:26.939]                         base::library(pkg, character.only = TRUE)
[18:04:26.939]                       }
[18:04:26.939]                     })
[18:04:26.939]                   }
[18:04:26.939]                   ...future.strategy.old <- future::plan("list")
[18:04:26.939]                   options(future.plan = NULL)
[18:04:26.939]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.939]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:26.939]                 }
[18:04:26.939]                 ...future.workdir <- getwd()
[18:04:26.939]             }
[18:04:26.939]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:26.939]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:26.939]         }
[18:04:26.939]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:26.939]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:26.939]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:26.939]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:26.939]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:26.939]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:26.939]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:26.939]             base::names(...future.oldOptions))
[18:04:26.939]     }
[18:04:26.939]     if (FALSE) {
[18:04:26.939]     }
[18:04:26.939]     else {
[18:04:26.939]         if (TRUE) {
[18:04:26.939]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:26.939]                 open = "w")
[18:04:26.939]         }
[18:04:26.939]         else {
[18:04:26.939]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:26.939]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:26.939]         }
[18:04:26.939]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:26.939]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:26.939]             base::sink(type = "output", split = FALSE)
[18:04:26.939]             base::close(...future.stdout)
[18:04:26.939]         }, add = TRUE)
[18:04:26.939]     }
[18:04:26.939]     ...future.frame <- base::sys.nframe()
[18:04:26.939]     ...future.conditions <- base::list()
[18:04:26.939]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:26.939]     if (FALSE) {
[18:04:26.939]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:26.939]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:26.939]     }
[18:04:26.939]     ...future.result <- base::tryCatch({
[18:04:26.939]         base::withCallingHandlers({
[18:04:26.939]             ...future.value <- base::withVisible(base::local({
[18:04:26.939]                 lm(dist ~ speed + speed^2, data = cars)
[18:04:26.939]             }))
[18:04:26.939]             future::FutureResult(value = ...future.value$value, 
[18:04:26.939]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.939]                   ...future.rng), globalenv = if (FALSE) 
[18:04:26.939]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:26.939]                     ...future.globalenv.names))
[18:04:26.939]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:26.939]         }, condition = base::local({
[18:04:26.939]             c <- base::c
[18:04:26.939]             inherits <- base::inherits
[18:04:26.939]             invokeRestart <- base::invokeRestart
[18:04:26.939]             length <- base::length
[18:04:26.939]             list <- base::list
[18:04:26.939]             seq.int <- base::seq.int
[18:04:26.939]             signalCondition <- base::signalCondition
[18:04:26.939]             sys.calls <- base::sys.calls
[18:04:26.939]             `[[` <- base::`[[`
[18:04:26.939]             `+` <- base::`+`
[18:04:26.939]             `<<-` <- base::`<<-`
[18:04:26.939]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:26.939]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:26.939]                   3L)]
[18:04:26.939]             }
[18:04:26.939]             function(cond) {
[18:04:26.939]                 is_error <- inherits(cond, "error")
[18:04:26.939]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:26.939]                   NULL)
[18:04:26.939]                 if (is_error) {
[18:04:26.939]                   sessionInformation <- function() {
[18:04:26.939]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:26.939]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:26.939]                       search = base::search(), system = base::Sys.info())
[18:04:26.939]                   }
[18:04:26.939]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.939]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:26.939]                     cond$call), session = sessionInformation(), 
[18:04:26.939]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:26.939]                   signalCondition(cond)
[18:04:26.939]                 }
[18:04:26.939]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:26.939]                 "immediateCondition"))) {
[18:04:26.939]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:26.939]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.939]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:26.939]                   if (TRUE && !signal) {
[18:04:26.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.939]                     {
[18:04:26.939]                       inherits <- base::inherits
[18:04:26.939]                       invokeRestart <- base::invokeRestart
[18:04:26.939]                       is.null <- base::is.null
[18:04:26.939]                       muffled <- FALSE
[18:04:26.939]                       if (inherits(cond, "message")) {
[18:04:26.939]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.939]                         if (muffled) 
[18:04:26.939]                           invokeRestart("muffleMessage")
[18:04:26.939]                       }
[18:04:26.939]                       else if (inherits(cond, "warning")) {
[18:04:26.939]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.939]                         if (muffled) 
[18:04:26.939]                           invokeRestart("muffleWarning")
[18:04:26.939]                       }
[18:04:26.939]                       else if (inherits(cond, "condition")) {
[18:04:26.939]                         if (!is.null(pattern)) {
[18:04:26.939]                           computeRestarts <- base::computeRestarts
[18:04:26.939]                           grepl <- base::grepl
[18:04:26.939]                           restarts <- computeRestarts(cond)
[18:04:26.939]                           for (restart in restarts) {
[18:04:26.939]                             name <- restart$name
[18:04:26.939]                             if (is.null(name)) 
[18:04:26.939]                               next
[18:04:26.939]                             if (!grepl(pattern, name)) 
[18:04:26.939]                               next
[18:04:26.939]                             invokeRestart(restart)
[18:04:26.939]                             muffled <- TRUE
[18:04:26.939]                             break
[18:04:26.939]                           }
[18:04:26.939]                         }
[18:04:26.939]                       }
[18:04:26.939]                       invisible(muffled)
[18:04:26.939]                     }
[18:04:26.939]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.939]                   }
[18:04:26.939]                 }
[18:04:26.939]                 else {
[18:04:26.939]                   if (TRUE) {
[18:04:26.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.939]                     {
[18:04:26.939]                       inherits <- base::inherits
[18:04:26.939]                       invokeRestart <- base::invokeRestart
[18:04:26.939]                       is.null <- base::is.null
[18:04:26.939]                       muffled <- FALSE
[18:04:26.939]                       if (inherits(cond, "message")) {
[18:04:26.939]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.939]                         if (muffled) 
[18:04:26.939]                           invokeRestart("muffleMessage")
[18:04:26.939]                       }
[18:04:26.939]                       else if (inherits(cond, "warning")) {
[18:04:26.939]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.939]                         if (muffled) 
[18:04:26.939]                           invokeRestart("muffleWarning")
[18:04:26.939]                       }
[18:04:26.939]                       else if (inherits(cond, "condition")) {
[18:04:26.939]                         if (!is.null(pattern)) {
[18:04:26.939]                           computeRestarts <- base::computeRestarts
[18:04:26.939]                           grepl <- base::grepl
[18:04:26.939]                           restarts <- computeRestarts(cond)
[18:04:26.939]                           for (restart in restarts) {
[18:04:26.939]                             name <- restart$name
[18:04:26.939]                             if (is.null(name)) 
[18:04:26.939]                               next
[18:04:26.939]                             if (!grepl(pattern, name)) 
[18:04:26.939]                               next
[18:04:26.939]                             invokeRestart(restart)
[18:04:26.939]                             muffled <- TRUE
[18:04:26.939]                             break
[18:04:26.939]                           }
[18:04:26.939]                         }
[18:04:26.939]                       }
[18:04:26.939]                       invisible(muffled)
[18:04:26.939]                     }
[18:04:26.939]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.939]                   }
[18:04:26.939]                 }
[18:04:26.939]             }
[18:04:26.939]         }))
[18:04:26.939]     }, error = function(ex) {
[18:04:26.939]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:26.939]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.939]                 ...future.rng), started = ...future.startTime, 
[18:04:26.939]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:26.939]             version = "1.8"), class = "FutureResult")
[18:04:26.939]     }, finally = {
[18:04:26.939]         if (!identical(...future.workdir, getwd())) 
[18:04:26.939]             setwd(...future.workdir)
[18:04:26.939]         {
[18:04:26.939]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:26.939]                 ...future.oldOptions$nwarnings <- NULL
[18:04:26.939]             }
[18:04:26.939]             base::options(...future.oldOptions)
[18:04:26.939]             if (.Platform$OS.type == "windows") {
[18:04:26.939]                 old_names <- names(...future.oldEnvVars)
[18:04:26.939]                 envs <- base::Sys.getenv()
[18:04:26.939]                 names <- names(envs)
[18:04:26.939]                 common <- intersect(names, old_names)
[18:04:26.939]                 added <- setdiff(names, old_names)
[18:04:26.939]                 removed <- setdiff(old_names, names)
[18:04:26.939]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:26.939]                   envs[common]]
[18:04:26.939]                 NAMES <- toupper(changed)
[18:04:26.939]                 args <- list()
[18:04:26.939]                 for (kk in seq_along(NAMES)) {
[18:04:26.939]                   name <- changed[[kk]]
[18:04:26.939]                   NAME <- NAMES[[kk]]
[18:04:26.939]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.939]                     next
[18:04:26.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.939]                 }
[18:04:26.939]                 NAMES <- toupper(added)
[18:04:26.939]                 for (kk in seq_along(NAMES)) {
[18:04:26.939]                   name <- added[[kk]]
[18:04:26.939]                   NAME <- NAMES[[kk]]
[18:04:26.939]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.939]                     next
[18:04:26.939]                   args[[name]] <- ""
[18:04:26.939]                 }
[18:04:26.939]                 NAMES <- toupper(removed)
[18:04:26.939]                 for (kk in seq_along(NAMES)) {
[18:04:26.939]                   name <- removed[[kk]]
[18:04:26.939]                   NAME <- NAMES[[kk]]
[18:04:26.939]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.939]                     next
[18:04:26.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.939]                 }
[18:04:26.939]                 if (length(args) > 0) 
[18:04:26.939]                   base::do.call(base::Sys.setenv, args = args)
[18:04:26.939]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:26.939]             }
[18:04:26.939]             else {
[18:04:26.939]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:26.939]             }
[18:04:26.939]             {
[18:04:26.939]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:26.939]                   0L) {
[18:04:26.939]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:26.939]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:26.939]                   base::options(opts)
[18:04:26.939]                 }
[18:04:26.939]                 {
[18:04:26.939]                   {
[18:04:26.939]                     NULL
[18:04:26.939]                     RNGkind("Mersenne-Twister")
[18:04:26.939]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:26.939]                       inherits = FALSE)
[18:04:26.939]                   }
[18:04:26.939]                   options(future.plan = NULL)
[18:04:26.939]                   if (is.na(NA_character_)) 
[18:04:26.939]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.939]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:26.939]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:26.939]                     .init = FALSE)
[18:04:26.939]                 }
[18:04:26.939]             }
[18:04:26.939]         }
[18:04:26.939]     })
[18:04:26.939]     if (TRUE) {
[18:04:26.939]         base::sink(type = "output", split = FALSE)
[18:04:26.939]         if (TRUE) {
[18:04:26.939]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:26.939]         }
[18:04:26.939]         else {
[18:04:26.939]             ...future.result["stdout"] <- base::list(NULL)
[18:04:26.939]         }
[18:04:26.939]         base::close(...future.stdout)
[18:04:26.939]         ...future.stdout <- NULL
[18:04:26.939]     }
[18:04:26.939]     ...future.result$conditions <- ...future.conditions
[18:04:26.939]     ...future.result$finished <- base::Sys.time()
[18:04:26.939]     ...future.result
[18:04:26.939] }
[18:04:26.943] plan(): Setting new future strategy stack:
[18:04:26.943] List of future strategies:
[18:04:26.943] 1. sequential:
[18:04:26.943]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.943]    - tweaked: FALSE
[18:04:26.943]    - call: NULL
[18:04:26.944] plan(): nbrOfWorkers() = 1
[18:04:26.947] plan(): Setting new future strategy stack:
[18:04:26.947] List of future strategies:
[18:04:26.947] 1. sequential:
[18:04:26.947]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.947]    - tweaked: FALSE
[18:04:26.947]    - call: plan(strategy)
[18:04:26.948] plan(): nbrOfWorkers() = 1
[18:04:26.949] SequentialFuture started (and completed)
[18:04:26.949] - Launch lazy future ... done
[18:04:26.949] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[18:04:26.957] getGlobalsAndPackages() ...
[18:04:26.958] Searching for globals...
[18:04:26.962] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[18:04:26.962] Searching for globals ... DONE
[18:04:26.963] Resolving globals: FALSE
[18:04:26.964] 
[18:04:26.964] - packages: [2] ‘stats’, ‘datasets’
[18:04:26.964] getGlobalsAndPackages() ... DONE
[18:04:26.965] run() for ‘Future’ ...
[18:04:26.965] - state: ‘created’
[18:04:26.965] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:26.966] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:26.966] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:26.966]   - Field: ‘label’
[18:04:26.967]   - Field: ‘local’
[18:04:26.967]   - Field: ‘owner’
[18:04:26.967]   - Field: ‘envir’
[18:04:26.967]   - Field: ‘packages’
[18:04:26.967]   - Field: ‘gc’
[18:04:26.968]   - Field: ‘conditions’
[18:04:26.968]   - Field: ‘expr’
[18:04:26.968]   - Field: ‘uuid’
[18:04:26.968]   - Field: ‘seed’
[18:04:26.968]   - Field: ‘version’
[18:04:26.969]   - Field: ‘result’
[18:04:26.969]   - Field: ‘asynchronous’
[18:04:26.969]   - Field: ‘calls’
[18:04:26.969]   - Field: ‘globals’
[18:04:26.969]   - Field: ‘stdout’
[18:04:26.970]   - Field: ‘earlySignal’
[18:04:26.970]   - Field: ‘lazy’
[18:04:26.970]   - Field: ‘state’
[18:04:26.970] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:26.970] - Launch lazy future ...
[18:04:26.971] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:26.971] Packages needed by future strategies (n = 0): <none>
[18:04:26.972] {
[18:04:26.972]     {
[18:04:26.972]         {
[18:04:26.972]             ...future.startTime <- base::Sys.time()
[18:04:26.972]             {
[18:04:26.972]                 {
[18:04:26.972]                   {
[18:04:26.972]                     {
[18:04:26.972]                       base::local({
[18:04:26.972]                         has_future <- base::requireNamespace("future", 
[18:04:26.972]                           quietly = TRUE)
[18:04:26.972]                         if (has_future) {
[18:04:26.972]                           ns <- base::getNamespace("future")
[18:04:26.972]                           version <- ns[[".package"]][["version"]]
[18:04:26.972]                           if (is.null(version)) 
[18:04:26.972]                             version <- utils::packageVersion("future")
[18:04:26.972]                         }
[18:04:26.972]                         else {
[18:04:26.972]                           version <- NULL
[18:04:26.972]                         }
[18:04:26.972]                         if (!has_future || version < "1.8.0") {
[18:04:26.972]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:26.972]                             "", base::R.version$version.string), 
[18:04:26.972]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:26.972]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:26.972]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:26.972]                               "release", "version")], collapse = " "), 
[18:04:26.972]                             hostname = base::Sys.info()[["nodename"]])
[18:04:26.972]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:26.972]                             info)
[18:04:26.972]                           info <- base::paste(info, collapse = "; ")
[18:04:26.972]                           if (!has_future) {
[18:04:26.972]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:26.972]                               info)
[18:04:26.972]                           }
[18:04:26.972]                           else {
[18:04:26.972]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:26.972]                               info, version)
[18:04:26.972]                           }
[18:04:26.972]                           base::stop(msg)
[18:04:26.972]                         }
[18:04:26.972]                       })
[18:04:26.972]                     }
[18:04:26.972]                     base::local({
[18:04:26.972]                       for (pkg in c("stats", "datasets")) {
[18:04:26.972]                         base::loadNamespace(pkg)
[18:04:26.972]                         base::library(pkg, character.only = TRUE)
[18:04:26.972]                       }
[18:04:26.972]                     })
[18:04:26.972]                   }
[18:04:26.972]                   ...future.strategy.old <- future::plan("list")
[18:04:26.972]                   options(future.plan = NULL)
[18:04:26.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.972]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:26.972]                 }
[18:04:26.972]                 ...future.workdir <- getwd()
[18:04:26.972]             }
[18:04:26.972]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:26.972]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:26.972]         }
[18:04:26.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:26.972]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:26.972]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:26.972]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:26.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:26.972]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:26.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:26.972]             base::names(...future.oldOptions))
[18:04:26.972]     }
[18:04:26.972]     if (FALSE) {
[18:04:26.972]     }
[18:04:26.972]     else {
[18:04:26.972]         if (TRUE) {
[18:04:26.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:26.972]                 open = "w")
[18:04:26.972]         }
[18:04:26.972]         else {
[18:04:26.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:26.972]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:26.972]         }
[18:04:26.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:26.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:26.972]             base::sink(type = "output", split = FALSE)
[18:04:26.972]             base::close(...future.stdout)
[18:04:26.972]         }, add = TRUE)
[18:04:26.972]     }
[18:04:26.972]     ...future.frame <- base::sys.nframe()
[18:04:26.972]     ...future.conditions <- base::list()
[18:04:26.972]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:26.972]     if (FALSE) {
[18:04:26.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:26.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:26.972]     }
[18:04:26.972]     ...future.result <- base::tryCatch({
[18:04:26.972]         base::withCallingHandlers({
[18:04:26.972]             ...future.value <- base::withVisible(base::local({
[18:04:26.972]                 lm(dist ~ speed + I(speed^2), data = cars)
[18:04:26.972]             }))
[18:04:26.972]             future::FutureResult(value = ...future.value$value, 
[18:04:26.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.972]                   ...future.rng), globalenv = if (FALSE) 
[18:04:26.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:26.972]                     ...future.globalenv.names))
[18:04:26.972]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:26.972]         }, condition = base::local({
[18:04:26.972]             c <- base::c
[18:04:26.972]             inherits <- base::inherits
[18:04:26.972]             invokeRestart <- base::invokeRestart
[18:04:26.972]             length <- base::length
[18:04:26.972]             list <- base::list
[18:04:26.972]             seq.int <- base::seq.int
[18:04:26.972]             signalCondition <- base::signalCondition
[18:04:26.972]             sys.calls <- base::sys.calls
[18:04:26.972]             `[[` <- base::`[[`
[18:04:26.972]             `+` <- base::`+`
[18:04:26.972]             `<<-` <- base::`<<-`
[18:04:26.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:26.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:26.972]                   3L)]
[18:04:26.972]             }
[18:04:26.972]             function(cond) {
[18:04:26.972]                 is_error <- inherits(cond, "error")
[18:04:26.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:26.972]                   NULL)
[18:04:26.972]                 if (is_error) {
[18:04:26.972]                   sessionInformation <- function() {
[18:04:26.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:26.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:26.972]                       search = base::search(), system = base::Sys.info())
[18:04:26.972]                   }
[18:04:26.972]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:26.972]                     cond$call), session = sessionInformation(), 
[18:04:26.972]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:26.972]                   signalCondition(cond)
[18:04:26.972]                 }
[18:04:26.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:26.972]                 "immediateCondition"))) {
[18:04:26.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:26.972]                   ...future.conditions[[length(...future.conditions) + 
[18:04:26.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:26.972]                   if (TRUE && !signal) {
[18:04:26.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.972]                     {
[18:04:26.972]                       inherits <- base::inherits
[18:04:26.972]                       invokeRestart <- base::invokeRestart
[18:04:26.972]                       is.null <- base::is.null
[18:04:26.972]                       muffled <- FALSE
[18:04:26.972]                       if (inherits(cond, "message")) {
[18:04:26.972]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.972]                         if (muffled) 
[18:04:26.972]                           invokeRestart("muffleMessage")
[18:04:26.972]                       }
[18:04:26.972]                       else if (inherits(cond, "warning")) {
[18:04:26.972]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.972]                         if (muffled) 
[18:04:26.972]                           invokeRestart("muffleWarning")
[18:04:26.972]                       }
[18:04:26.972]                       else if (inherits(cond, "condition")) {
[18:04:26.972]                         if (!is.null(pattern)) {
[18:04:26.972]                           computeRestarts <- base::computeRestarts
[18:04:26.972]                           grepl <- base::grepl
[18:04:26.972]                           restarts <- computeRestarts(cond)
[18:04:26.972]                           for (restart in restarts) {
[18:04:26.972]                             name <- restart$name
[18:04:26.972]                             if (is.null(name)) 
[18:04:26.972]                               next
[18:04:26.972]                             if (!grepl(pattern, name)) 
[18:04:26.972]                               next
[18:04:26.972]                             invokeRestart(restart)
[18:04:26.972]                             muffled <- TRUE
[18:04:26.972]                             break
[18:04:26.972]                           }
[18:04:26.972]                         }
[18:04:26.972]                       }
[18:04:26.972]                       invisible(muffled)
[18:04:26.972]                     }
[18:04:26.972]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.972]                   }
[18:04:26.972]                 }
[18:04:26.972]                 else {
[18:04:26.972]                   if (TRUE) {
[18:04:26.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:26.972]                     {
[18:04:26.972]                       inherits <- base::inherits
[18:04:26.972]                       invokeRestart <- base::invokeRestart
[18:04:26.972]                       is.null <- base::is.null
[18:04:26.972]                       muffled <- FALSE
[18:04:26.972]                       if (inherits(cond, "message")) {
[18:04:26.972]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:26.972]                         if (muffled) 
[18:04:26.972]                           invokeRestart("muffleMessage")
[18:04:26.972]                       }
[18:04:26.972]                       else if (inherits(cond, "warning")) {
[18:04:26.972]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:26.972]                         if (muffled) 
[18:04:26.972]                           invokeRestart("muffleWarning")
[18:04:26.972]                       }
[18:04:26.972]                       else if (inherits(cond, "condition")) {
[18:04:26.972]                         if (!is.null(pattern)) {
[18:04:26.972]                           computeRestarts <- base::computeRestarts
[18:04:26.972]                           grepl <- base::grepl
[18:04:26.972]                           restarts <- computeRestarts(cond)
[18:04:26.972]                           for (restart in restarts) {
[18:04:26.972]                             name <- restart$name
[18:04:26.972]                             if (is.null(name)) 
[18:04:26.972]                               next
[18:04:26.972]                             if (!grepl(pattern, name)) 
[18:04:26.972]                               next
[18:04:26.972]                             invokeRestart(restart)
[18:04:26.972]                             muffled <- TRUE
[18:04:26.972]                             break
[18:04:26.972]                           }
[18:04:26.972]                         }
[18:04:26.972]                       }
[18:04:26.972]                       invisible(muffled)
[18:04:26.972]                     }
[18:04:26.972]                     muffleCondition(cond, pattern = "^muffle")
[18:04:26.972]                   }
[18:04:26.972]                 }
[18:04:26.972]             }
[18:04:26.972]         }))
[18:04:26.972]     }, error = function(ex) {
[18:04:26.972]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:26.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:26.972]                 ...future.rng), started = ...future.startTime, 
[18:04:26.972]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:26.972]             version = "1.8"), class = "FutureResult")
[18:04:26.972]     }, finally = {
[18:04:26.972]         if (!identical(...future.workdir, getwd())) 
[18:04:26.972]             setwd(...future.workdir)
[18:04:26.972]         {
[18:04:26.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:26.972]                 ...future.oldOptions$nwarnings <- NULL
[18:04:26.972]             }
[18:04:26.972]             base::options(...future.oldOptions)
[18:04:26.972]             if (.Platform$OS.type == "windows") {
[18:04:26.972]                 old_names <- names(...future.oldEnvVars)
[18:04:26.972]                 envs <- base::Sys.getenv()
[18:04:26.972]                 names <- names(envs)
[18:04:26.972]                 common <- intersect(names, old_names)
[18:04:26.972]                 added <- setdiff(names, old_names)
[18:04:26.972]                 removed <- setdiff(old_names, names)
[18:04:26.972]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:26.972]                   envs[common]]
[18:04:26.972]                 NAMES <- toupper(changed)
[18:04:26.972]                 args <- list()
[18:04:26.972]                 for (kk in seq_along(NAMES)) {
[18:04:26.972]                   name <- changed[[kk]]
[18:04:26.972]                   NAME <- NAMES[[kk]]
[18:04:26.972]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.972]                     next
[18:04:26.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.972]                 }
[18:04:26.972]                 NAMES <- toupper(added)
[18:04:26.972]                 for (kk in seq_along(NAMES)) {
[18:04:26.972]                   name <- added[[kk]]
[18:04:26.972]                   NAME <- NAMES[[kk]]
[18:04:26.972]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.972]                     next
[18:04:26.972]                   args[[name]] <- ""
[18:04:26.972]                 }
[18:04:26.972]                 NAMES <- toupper(removed)
[18:04:26.972]                 for (kk in seq_along(NAMES)) {
[18:04:26.972]                   name <- removed[[kk]]
[18:04:26.972]                   NAME <- NAMES[[kk]]
[18:04:26.972]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:26.972]                     next
[18:04:26.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:26.972]                 }
[18:04:26.972]                 if (length(args) > 0) 
[18:04:26.972]                   base::do.call(base::Sys.setenv, args = args)
[18:04:26.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:26.972]             }
[18:04:26.972]             else {
[18:04:26.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:26.972]             }
[18:04:26.972]             {
[18:04:26.972]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:26.972]                   0L) {
[18:04:26.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:26.972]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:26.972]                   base::options(opts)
[18:04:26.972]                 }
[18:04:26.972]                 {
[18:04:26.972]                   {
[18:04:26.972]                     NULL
[18:04:26.972]                     RNGkind("Mersenne-Twister")
[18:04:26.972]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:26.972]                       inherits = FALSE)
[18:04:26.972]                   }
[18:04:26.972]                   options(future.plan = NULL)
[18:04:26.972]                   if (is.na(NA_character_)) 
[18:04:26.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:26.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:26.972]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:26.972]                     .init = FALSE)
[18:04:26.972]                 }
[18:04:26.972]             }
[18:04:26.972]         }
[18:04:26.972]     })
[18:04:26.972]     if (TRUE) {
[18:04:26.972]         base::sink(type = "output", split = FALSE)
[18:04:26.972]         if (TRUE) {
[18:04:26.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:26.972]         }
[18:04:26.972]         else {
[18:04:26.972]             ...future.result["stdout"] <- base::list(NULL)
[18:04:26.972]         }
[18:04:26.972]         base::close(...future.stdout)
[18:04:26.972]         ...future.stdout <- NULL
[18:04:26.972]     }
[18:04:26.972]     ...future.result$conditions <- ...future.conditions
[18:04:26.972]     ...future.result$finished <- base::Sys.time()
[18:04:26.972]     ...future.result
[18:04:26.972] }
[18:04:26.976] plan(): Setting new future strategy stack:
[18:04:26.977] List of future strategies:
[18:04:26.977] 1. sequential:
[18:04:26.977]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.977]    - tweaked: FALSE
[18:04:26.977]    - call: NULL
[18:04:26.978] plan(): nbrOfWorkers() = 1
[18:04:26.981] plan(): Setting new future strategy stack:
[18:04:26.981] List of future strategies:
[18:04:26.981] 1. sequential:
[18:04:26.981]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:26.981]    - tweaked: FALSE
[18:04:26.981]    - call: plan(strategy)
[18:04:26.982] plan(): nbrOfWorkers() = 1
[18:04:26.982] SequentialFuture started (and completed)
[18:04:26.983] - Launch lazy future ... done
[18:04:26.983] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[18:04:26.990] getGlobalsAndPackages() ...
[18:04:26.991] Searching for globals...
[18:04:26.994] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[18:04:26.994] Searching for globals ... DONE
[18:04:26.994] Resolving globals: FALSE
[18:04:26.995] 
[18:04:26.996] - packages: [2] ‘stats’, ‘datasets’
[18:04:26.996] getGlobalsAndPackages() ... DONE
[18:04:26.997] run() for ‘Future’ ...
[18:04:26.997] - state: ‘created’
[18:04:26.997] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:26.998] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:26.998] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:26.998]   - Field: ‘label’
[18:04:26.998]   - Field: ‘local’
[18:04:26.999]   - Field: ‘owner’
[18:04:26.999]   - Field: ‘envir’
[18:04:26.999]   - Field: ‘packages’
[18:04:26.999]   - Field: ‘gc’
[18:04:26.999]   - Field: ‘conditions’
[18:04:27.000]   - Field: ‘expr’
[18:04:27.000]   - Field: ‘uuid’
[18:04:27.000]   - Field: ‘seed’
[18:04:27.000]   - Field: ‘version’
[18:04:27.000]   - Field: ‘result’
[18:04:27.001]   - Field: ‘asynchronous’
[18:04:27.001]   - Field: ‘calls’
[18:04:27.001]   - Field: ‘globals’
[18:04:27.001]   - Field: ‘stdout’
[18:04:27.001]   - Field: ‘earlySignal’
[18:04:27.002]   - Field: ‘lazy’
[18:04:27.002]   - Field: ‘state’
[18:04:27.002] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:27.002] - Launch lazy future ...
[18:04:27.003] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:27.003] Packages needed by future strategies (n = 0): <none>
[18:04:27.004] {
[18:04:27.004]     {
[18:04:27.004]         {
[18:04:27.004]             ...future.startTime <- base::Sys.time()
[18:04:27.004]             {
[18:04:27.004]                 {
[18:04:27.004]                   {
[18:04:27.004]                     {
[18:04:27.004]                       base::local({
[18:04:27.004]                         has_future <- base::requireNamespace("future", 
[18:04:27.004]                           quietly = TRUE)
[18:04:27.004]                         if (has_future) {
[18:04:27.004]                           ns <- base::getNamespace("future")
[18:04:27.004]                           version <- ns[[".package"]][["version"]]
[18:04:27.004]                           if (is.null(version)) 
[18:04:27.004]                             version <- utils::packageVersion("future")
[18:04:27.004]                         }
[18:04:27.004]                         else {
[18:04:27.004]                           version <- NULL
[18:04:27.004]                         }
[18:04:27.004]                         if (!has_future || version < "1.8.0") {
[18:04:27.004]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:27.004]                             "", base::R.version$version.string), 
[18:04:27.004]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:27.004]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:27.004]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:27.004]                               "release", "version")], collapse = " "), 
[18:04:27.004]                             hostname = base::Sys.info()[["nodename"]])
[18:04:27.004]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:27.004]                             info)
[18:04:27.004]                           info <- base::paste(info, collapse = "; ")
[18:04:27.004]                           if (!has_future) {
[18:04:27.004]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:27.004]                               info)
[18:04:27.004]                           }
[18:04:27.004]                           else {
[18:04:27.004]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:27.004]                               info, version)
[18:04:27.004]                           }
[18:04:27.004]                           base::stop(msg)
[18:04:27.004]                         }
[18:04:27.004]                       })
[18:04:27.004]                     }
[18:04:27.004]                     base::local({
[18:04:27.004]                       for (pkg in c("stats", "datasets")) {
[18:04:27.004]                         base::loadNamespace(pkg)
[18:04:27.004]                         base::library(pkg, character.only = TRUE)
[18:04:27.004]                       }
[18:04:27.004]                     })
[18:04:27.004]                   }
[18:04:27.004]                   ...future.strategy.old <- future::plan("list")
[18:04:27.004]                   options(future.plan = NULL)
[18:04:27.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:27.004]                 }
[18:04:27.004]                 ...future.workdir <- getwd()
[18:04:27.004]             }
[18:04:27.004]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:27.004]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:27.004]         }
[18:04:27.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:27.004]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:27.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:27.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:27.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:27.004]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:27.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:27.004]             base::names(...future.oldOptions))
[18:04:27.004]     }
[18:04:27.004]     if (FALSE) {
[18:04:27.004]     }
[18:04:27.004]     else {
[18:04:27.004]         if (TRUE) {
[18:04:27.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:27.004]                 open = "w")
[18:04:27.004]         }
[18:04:27.004]         else {
[18:04:27.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:27.004]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:27.004]         }
[18:04:27.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:27.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:27.004]             base::sink(type = "output", split = FALSE)
[18:04:27.004]             base::close(...future.stdout)
[18:04:27.004]         }, add = TRUE)
[18:04:27.004]     }
[18:04:27.004]     ...future.frame <- base::sys.nframe()
[18:04:27.004]     ...future.conditions <- base::list()
[18:04:27.004]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:27.004]     if (FALSE) {
[18:04:27.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:27.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:27.004]     }
[18:04:27.004]     ...future.result <- base::tryCatch({
[18:04:27.004]         base::withCallingHandlers({
[18:04:27.004]             ...future.value <- base::withVisible(base::local({
[18:04:27.004]                 lm(dist ~ poly(speed, 2), data = cars)
[18:04:27.004]             }))
[18:04:27.004]             future::FutureResult(value = ...future.value$value, 
[18:04:27.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.004]                   ...future.rng), globalenv = if (FALSE) 
[18:04:27.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:27.004]                     ...future.globalenv.names))
[18:04:27.004]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:27.004]         }, condition = base::local({
[18:04:27.004]             c <- base::c
[18:04:27.004]             inherits <- base::inherits
[18:04:27.004]             invokeRestart <- base::invokeRestart
[18:04:27.004]             length <- base::length
[18:04:27.004]             list <- base::list
[18:04:27.004]             seq.int <- base::seq.int
[18:04:27.004]             signalCondition <- base::signalCondition
[18:04:27.004]             sys.calls <- base::sys.calls
[18:04:27.004]             `[[` <- base::`[[`
[18:04:27.004]             `+` <- base::`+`
[18:04:27.004]             `<<-` <- base::`<<-`
[18:04:27.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:27.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:27.004]                   3L)]
[18:04:27.004]             }
[18:04:27.004]             function(cond) {
[18:04:27.004]                 is_error <- inherits(cond, "error")
[18:04:27.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:27.004]                   NULL)
[18:04:27.004]                 if (is_error) {
[18:04:27.004]                   sessionInformation <- function() {
[18:04:27.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:27.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:27.004]                       search = base::search(), system = base::Sys.info())
[18:04:27.004]                   }
[18:04:27.004]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:27.004]                     cond$call), session = sessionInformation(), 
[18:04:27.004]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:27.004]                   signalCondition(cond)
[18:04:27.004]                 }
[18:04:27.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:27.004]                 "immediateCondition"))) {
[18:04:27.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:27.004]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:27.004]                   if (TRUE && !signal) {
[18:04:27.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.004]                     {
[18:04:27.004]                       inherits <- base::inherits
[18:04:27.004]                       invokeRestart <- base::invokeRestart
[18:04:27.004]                       is.null <- base::is.null
[18:04:27.004]                       muffled <- FALSE
[18:04:27.004]                       if (inherits(cond, "message")) {
[18:04:27.004]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.004]                         if (muffled) 
[18:04:27.004]                           invokeRestart("muffleMessage")
[18:04:27.004]                       }
[18:04:27.004]                       else if (inherits(cond, "warning")) {
[18:04:27.004]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.004]                         if (muffled) 
[18:04:27.004]                           invokeRestart("muffleWarning")
[18:04:27.004]                       }
[18:04:27.004]                       else if (inherits(cond, "condition")) {
[18:04:27.004]                         if (!is.null(pattern)) {
[18:04:27.004]                           computeRestarts <- base::computeRestarts
[18:04:27.004]                           grepl <- base::grepl
[18:04:27.004]                           restarts <- computeRestarts(cond)
[18:04:27.004]                           for (restart in restarts) {
[18:04:27.004]                             name <- restart$name
[18:04:27.004]                             if (is.null(name)) 
[18:04:27.004]                               next
[18:04:27.004]                             if (!grepl(pattern, name)) 
[18:04:27.004]                               next
[18:04:27.004]                             invokeRestart(restart)
[18:04:27.004]                             muffled <- TRUE
[18:04:27.004]                             break
[18:04:27.004]                           }
[18:04:27.004]                         }
[18:04:27.004]                       }
[18:04:27.004]                       invisible(muffled)
[18:04:27.004]                     }
[18:04:27.004]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.004]                   }
[18:04:27.004]                 }
[18:04:27.004]                 else {
[18:04:27.004]                   if (TRUE) {
[18:04:27.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.004]                     {
[18:04:27.004]                       inherits <- base::inherits
[18:04:27.004]                       invokeRestart <- base::invokeRestart
[18:04:27.004]                       is.null <- base::is.null
[18:04:27.004]                       muffled <- FALSE
[18:04:27.004]                       if (inherits(cond, "message")) {
[18:04:27.004]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.004]                         if (muffled) 
[18:04:27.004]                           invokeRestart("muffleMessage")
[18:04:27.004]                       }
[18:04:27.004]                       else if (inherits(cond, "warning")) {
[18:04:27.004]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.004]                         if (muffled) 
[18:04:27.004]                           invokeRestart("muffleWarning")
[18:04:27.004]                       }
[18:04:27.004]                       else if (inherits(cond, "condition")) {
[18:04:27.004]                         if (!is.null(pattern)) {
[18:04:27.004]                           computeRestarts <- base::computeRestarts
[18:04:27.004]                           grepl <- base::grepl
[18:04:27.004]                           restarts <- computeRestarts(cond)
[18:04:27.004]                           for (restart in restarts) {
[18:04:27.004]                             name <- restart$name
[18:04:27.004]                             if (is.null(name)) 
[18:04:27.004]                               next
[18:04:27.004]                             if (!grepl(pattern, name)) 
[18:04:27.004]                               next
[18:04:27.004]                             invokeRestart(restart)
[18:04:27.004]                             muffled <- TRUE
[18:04:27.004]                             break
[18:04:27.004]                           }
[18:04:27.004]                         }
[18:04:27.004]                       }
[18:04:27.004]                       invisible(muffled)
[18:04:27.004]                     }
[18:04:27.004]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.004]                   }
[18:04:27.004]                 }
[18:04:27.004]             }
[18:04:27.004]         }))
[18:04:27.004]     }, error = function(ex) {
[18:04:27.004]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:27.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.004]                 ...future.rng), started = ...future.startTime, 
[18:04:27.004]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:27.004]             version = "1.8"), class = "FutureResult")
[18:04:27.004]     }, finally = {
[18:04:27.004]         if (!identical(...future.workdir, getwd())) 
[18:04:27.004]             setwd(...future.workdir)
[18:04:27.004]         {
[18:04:27.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:27.004]                 ...future.oldOptions$nwarnings <- NULL
[18:04:27.004]             }
[18:04:27.004]             base::options(...future.oldOptions)
[18:04:27.004]             if (.Platform$OS.type == "windows") {
[18:04:27.004]                 old_names <- names(...future.oldEnvVars)
[18:04:27.004]                 envs <- base::Sys.getenv()
[18:04:27.004]                 names <- names(envs)
[18:04:27.004]                 common <- intersect(names, old_names)
[18:04:27.004]                 added <- setdiff(names, old_names)
[18:04:27.004]                 removed <- setdiff(old_names, names)
[18:04:27.004]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:27.004]                   envs[common]]
[18:04:27.004]                 NAMES <- toupper(changed)
[18:04:27.004]                 args <- list()
[18:04:27.004]                 for (kk in seq_along(NAMES)) {
[18:04:27.004]                   name <- changed[[kk]]
[18:04:27.004]                   NAME <- NAMES[[kk]]
[18:04:27.004]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.004]                     next
[18:04:27.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.004]                 }
[18:04:27.004]                 NAMES <- toupper(added)
[18:04:27.004]                 for (kk in seq_along(NAMES)) {
[18:04:27.004]                   name <- added[[kk]]
[18:04:27.004]                   NAME <- NAMES[[kk]]
[18:04:27.004]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.004]                     next
[18:04:27.004]                   args[[name]] <- ""
[18:04:27.004]                 }
[18:04:27.004]                 NAMES <- toupper(removed)
[18:04:27.004]                 for (kk in seq_along(NAMES)) {
[18:04:27.004]                   name <- removed[[kk]]
[18:04:27.004]                   NAME <- NAMES[[kk]]
[18:04:27.004]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.004]                     next
[18:04:27.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.004]                 }
[18:04:27.004]                 if (length(args) > 0) 
[18:04:27.004]                   base::do.call(base::Sys.setenv, args = args)
[18:04:27.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:27.004]             }
[18:04:27.004]             else {
[18:04:27.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:27.004]             }
[18:04:27.004]             {
[18:04:27.004]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:27.004]                   0L) {
[18:04:27.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:27.004]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:27.004]                   base::options(opts)
[18:04:27.004]                 }
[18:04:27.004]                 {
[18:04:27.004]                   {
[18:04:27.004]                     NULL
[18:04:27.004]                     RNGkind("Mersenne-Twister")
[18:04:27.004]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:27.004]                       inherits = FALSE)
[18:04:27.004]                   }
[18:04:27.004]                   options(future.plan = NULL)
[18:04:27.004]                   if (is.na(NA_character_)) 
[18:04:27.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:27.004]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:27.004]                     .init = FALSE)
[18:04:27.004]                 }
[18:04:27.004]             }
[18:04:27.004]         }
[18:04:27.004]     })
[18:04:27.004]     if (TRUE) {
[18:04:27.004]         base::sink(type = "output", split = FALSE)
[18:04:27.004]         if (TRUE) {
[18:04:27.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:27.004]         }
[18:04:27.004]         else {
[18:04:27.004]             ...future.result["stdout"] <- base::list(NULL)
[18:04:27.004]         }
[18:04:27.004]         base::close(...future.stdout)
[18:04:27.004]         ...future.stdout <- NULL
[18:04:27.004]     }
[18:04:27.004]     ...future.result$conditions <- ...future.conditions
[18:04:27.004]     ...future.result$finished <- base::Sys.time()
[18:04:27.004]     ...future.result
[18:04:27.004] }
[18:04:27.008] plan(): Setting new future strategy stack:
[18:04:27.008] List of future strategies:
[18:04:27.008] 1. sequential:
[18:04:27.008]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.008]    - tweaked: FALSE
[18:04:27.008]    - call: NULL
[18:04:27.009] plan(): nbrOfWorkers() = 1
[18:04:27.015] plan(): Setting new future strategy stack:
[18:04:27.016] List of future strategies:
[18:04:27.016] 1. sequential:
[18:04:27.016]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.016]    - tweaked: FALSE
[18:04:27.016]    - call: plan(strategy)
[18:04:27.017] plan(): nbrOfWorkers() = 1
[18:04:27.017] SequentialFuture started (and completed)
[18:04:27.018] - Launch lazy future ... done
[18:04:27.018] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[18:04:27.022] getGlobalsAndPackages() ...
[18:04:27.022] Searching for globals...
[18:04:27.033] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[18:04:27.033] Searching for globals ... DONE
[18:04:27.033] Resolving globals: FALSE
[18:04:27.035] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[18:04:27.036] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[18:04:27.036] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[18:04:27.036] 
[18:04:27.037] getGlobalsAndPackages() ... DONE
[18:04:27.037] run() for ‘Future’ ...
[18:04:27.037] - state: ‘created’
[18:04:27.038] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:27.038] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:27.038] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:27.039]   - Field: ‘label’
[18:04:27.039]   - Field: ‘local’
[18:04:27.039]   - Field: ‘owner’
[18:04:27.039]   - Field: ‘envir’
[18:04:27.040]   - Field: ‘packages’
[18:04:27.040]   - Field: ‘gc’
[18:04:27.040]   - Field: ‘conditions’
[18:04:27.040]   - Field: ‘expr’
[18:04:27.040]   - Field: ‘uuid’
[18:04:27.041]   - Field: ‘seed’
[18:04:27.041]   - Field: ‘version’
[18:04:27.041]   - Field: ‘result’
[18:04:27.041]   - Field: ‘asynchronous’
[18:04:27.041]   - Field: ‘calls’
[18:04:27.042]   - Field: ‘globals’
[18:04:27.042]   - Field: ‘stdout’
[18:04:27.042]   - Field: ‘earlySignal’
[18:04:27.042]   - Field: ‘lazy’
[18:04:27.042]   - Field: ‘state’
[18:04:27.043] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:27.043] - Launch lazy future ...
[18:04:27.043] Packages needed by the future expression (n = 0): <none>
[18:04:27.043] Packages needed by future strategies (n = 0): <none>
[18:04:27.044] {
[18:04:27.044]     {
[18:04:27.044]         {
[18:04:27.044]             ...future.startTime <- base::Sys.time()
[18:04:27.044]             {
[18:04:27.044]                 {
[18:04:27.044]                   {
[18:04:27.044]                     base::local({
[18:04:27.044]                       has_future <- base::requireNamespace("future", 
[18:04:27.044]                         quietly = TRUE)
[18:04:27.044]                       if (has_future) {
[18:04:27.044]                         ns <- base::getNamespace("future")
[18:04:27.044]                         version <- ns[[".package"]][["version"]]
[18:04:27.044]                         if (is.null(version)) 
[18:04:27.044]                           version <- utils::packageVersion("future")
[18:04:27.044]                       }
[18:04:27.044]                       else {
[18:04:27.044]                         version <- NULL
[18:04:27.044]                       }
[18:04:27.044]                       if (!has_future || version < "1.8.0") {
[18:04:27.044]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:27.044]                           "", base::R.version$version.string), 
[18:04:27.044]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:27.044]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:27.044]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:27.044]                             "release", "version")], collapse = " "), 
[18:04:27.044]                           hostname = base::Sys.info()[["nodename"]])
[18:04:27.044]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:27.044]                           info)
[18:04:27.044]                         info <- base::paste(info, collapse = "; ")
[18:04:27.044]                         if (!has_future) {
[18:04:27.044]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:27.044]                             info)
[18:04:27.044]                         }
[18:04:27.044]                         else {
[18:04:27.044]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:27.044]                             info, version)
[18:04:27.044]                         }
[18:04:27.044]                         base::stop(msg)
[18:04:27.044]                       }
[18:04:27.044]                     })
[18:04:27.044]                   }
[18:04:27.044]                   ...future.strategy.old <- future::plan("list")
[18:04:27.044]                   options(future.plan = NULL)
[18:04:27.044]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.044]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:27.044]                 }
[18:04:27.044]                 ...future.workdir <- getwd()
[18:04:27.044]             }
[18:04:27.044]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:27.044]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:27.044]         }
[18:04:27.044]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:27.044]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:27.044]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:27.044]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:27.044]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:27.044]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:27.044]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:27.044]             base::names(...future.oldOptions))
[18:04:27.044]     }
[18:04:27.044]     if (FALSE) {
[18:04:27.044]     }
[18:04:27.044]     else {
[18:04:27.044]         if (TRUE) {
[18:04:27.044]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:27.044]                 open = "w")
[18:04:27.044]         }
[18:04:27.044]         else {
[18:04:27.044]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:27.044]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:27.044]         }
[18:04:27.044]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:27.044]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:27.044]             base::sink(type = "output", split = FALSE)
[18:04:27.044]             base::close(...future.stdout)
[18:04:27.044]         }, add = TRUE)
[18:04:27.044]     }
[18:04:27.044]     ...future.frame <- base::sys.nframe()
[18:04:27.044]     ...future.conditions <- base::list()
[18:04:27.044]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:27.044]     if (FALSE) {
[18:04:27.044]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:27.044]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:27.044]     }
[18:04:27.044]     ...future.result <- base::tryCatch({
[18:04:27.044]         base::withCallingHandlers({
[18:04:27.044]             ...future.value <- base::withVisible(base::local({
[18:04:27.044]                 outer_function(1L)
[18:04:27.044]             }))
[18:04:27.044]             future::FutureResult(value = ...future.value$value, 
[18:04:27.044]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.044]                   ...future.rng), globalenv = if (FALSE) 
[18:04:27.044]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:27.044]                     ...future.globalenv.names))
[18:04:27.044]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:27.044]         }, condition = base::local({
[18:04:27.044]             c <- base::c
[18:04:27.044]             inherits <- base::inherits
[18:04:27.044]             invokeRestart <- base::invokeRestart
[18:04:27.044]             length <- base::length
[18:04:27.044]             list <- base::list
[18:04:27.044]             seq.int <- base::seq.int
[18:04:27.044]             signalCondition <- base::signalCondition
[18:04:27.044]             sys.calls <- base::sys.calls
[18:04:27.044]             `[[` <- base::`[[`
[18:04:27.044]             `+` <- base::`+`
[18:04:27.044]             `<<-` <- base::`<<-`
[18:04:27.044]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:27.044]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:27.044]                   3L)]
[18:04:27.044]             }
[18:04:27.044]             function(cond) {
[18:04:27.044]                 is_error <- inherits(cond, "error")
[18:04:27.044]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:27.044]                   NULL)
[18:04:27.044]                 if (is_error) {
[18:04:27.044]                   sessionInformation <- function() {
[18:04:27.044]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:27.044]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:27.044]                       search = base::search(), system = base::Sys.info())
[18:04:27.044]                   }
[18:04:27.044]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.044]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:27.044]                     cond$call), session = sessionInformation(), 
[18:04:27.044]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:27.044]                   signalCondition(cond)
[18:04:27.044]                 }
[18:04:27.044]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:27.044]                 "immediateCondition"))) {
[18:04:27.044]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:27.044]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.044]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:27.044]                   if (TRUE && !signal) {
[18:04:27.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.044]                     {
[18:04:27.044]                       inherits <- base::inherits
[18:04:27.044]                       invokeRestart <- base::invokeRestart
[18:04:27.044]                       is.null <- base::is.null
[18:04:27.044]                       muffled <- FALSE
[18:04:27.044]                       if (inherits(cond, "message")) {
[18:04:27.044]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.044]                         if (muffled) 
[18:04:27.044]                           invokeRestart("muffleMessage")
[18:04:27.044]                       }
[18:04:27.044]                       else if (inherits(cond, "warning")) {
[18:04:27.044]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.044]                         if (muffled) 
[18:04:27.044]                           invokeRestart("muffleWarning")
[18:04:27.044]                       }
[18:04:27.044]                       else if (inherits(cond, "condition")) {
[18:04:27.044]                         if (!is.null(pattern)) {
[18:04:27.044]                           computeRestarts <- base::computeRestarts
[18:04:27.044]                           grepl <- base::grepl
[18:04:27.044]                           restarts <- computeRestarts(cond)
[18:04:27.044]                           for (restart in restarts) {
[18:04:27.044]                             name <- restart$name
[18:04:27.044]                             if (is.null(name)) 
[18:04:27.044]                               next
[18:04:27.044]                             if (!grepl(pattern, name)) 
[18:04:27.044]                               next
[18:04:27.044]                             invokeRestart(restart)
[18:04:27.044]                             muffled <- TRUE
[18:04:27.044]                             break
[18:04:27.044]                           }
[18:04:27.044]                         }
[18:04:27.044]                       }
[18:04:27.044]                       invisible(muffled)
[18:04:27.044]                     }
[18:04:27.044]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.044]                   }
[18:04:27.044]                 }
[18:04:27.044]                 else {
[18:04:27.044]                   if (TRUE) {
[18:04:27.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.044]                     {
[18:04:27.044]                       inherits <- base::inherits
[18:04:27.044]                       invokeRestart <- base::invokeRestart
[18:04:27.044]                       is.null <- base::is.null
[18:04:27.044]                       muffled <- FALSE
[18:04:27.044]                       if (inherits(cond, "message")) {
[18:04:27.044]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.044]                         if (muffled) 
[18:04:27.044]                           invokeRestart("muffleMessage")
[18:04:27.044]                       }
[18:04:27.044]                       else if (inherits(cond, "warning")) {
[18:04:27.044]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.044]                         if (muffled) 
[18:04:27.044]                           invokeRestart("muffleWarning")
[18:04:27.044]                       }
[18:04:27.044]                       else if (inherits(cond, "condition")) {
[18:04:27.044]                         if (!is.null(pattern)) {
[18:04:27.044]                           computeRestarts <- base::computeRestarts
[18:04:27.044]                           grepl <- base::grepl
[18:04:27.044]                           restarts <- computeRestarts(cond)
[18:04:27.044]                           for (restart in restarts) {
[18:04:27.044]                             name <- restart$name
[18:04:27.044]                             if (is.null(name)) 
[18:04:27.044]                               next
[18:04:27.044]                             if (!grepl(pattern, name)) 
[18:04:27.044]                               next
[18:04:27.044]                             invokeRestart(restart)
[18:04:27.044]                             muffled <- TRUE
[18:04:27.044]                             break
[18:04:27.044]                           }
[18:04:27.044]                         }
[18:04:27.044]                       }
[18:04:27.044]                       invisible(muffled)
[18:04:27.044]                     }
[18:04:27.044]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.044]                   }
[18:04:27.044]                 }
[18:04:27.044]             }
[18:04:27.044]         }))
[18:04:27.044]     }, error = function(ex) {
[18:04:27.044]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:27.044]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.044]                 ...future.rng), started = ...future.startTime, 
[18:04:27.044]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:27.044]             version = "1.8"), class = "FutureResult")
[18:04:27.044]     }, finally = {
[18:04:27.044]         if (!identical(...future.workdir, getwd())) 
[18:04:27.044]             setwd(...future.workdir)
[18:04:27.044]         {
[18:04:27.044]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:27.044]                 ...future.oldOptions$nwarnings <- NULL
[18:04:27.044]             }
[18:04:27.044]             base::options(...future.oldOptions)
[18:04:27.044]             if (.Platform$OS.type == "windows") {
[18:04:27.044]                 old_names <- names(...future.oldEnvVars)
[18:04:27.044]                 envs <- base::Sys.getenv()
[18:04:27.044]                 names <- names(envs)
[18:04:27.044]                 common <- intersect(names, old_names)
[18:04:27.044]                 added <- setdiff(names, old_names)
[18:04:27.044]                 removed <- setdiff(old_names, names)
[18:04:27.044]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:27.044]                   envs[common]]
[18:04:27.044]                 NAMES <- toupper(changed)
[18:04:27.044]                 args <- list()
[18:04:27.044]                 for (kk in seq_along(NAMES)) {
[18:04:27.044]                   name <- changed[[kk]]
[18:04:27.044]                   NAME <- NAMES[[kk]]
[18:04:27.044]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.044]                     next
[18:04:27.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.044]                 }
[18:04:27.044]                 NAMES <- toupper(added)
[18:04:27.044]                 for (kk in seq_along(NAMES)) {
[18:04:27.044]                   name <- added[[kk]]
[18:04:27.044]                   NAME <- NAMES[[kk]]
[18:04:27.044]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.044]                     next
[18:04:27.044]                   args[[name]] <- ""
[18:04:27.044]                 }
[18:04:27.044]                 NAMES <- toupper(removed)
[18:04:27.044]                 for (kk in seq_along(NAMES)) {
[18:04:27.044]                   name <- removed[[kk]]
[18:04:27.044]                   NAME <- NAMES[[kk]]
[18:04:27.044]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.044]                     next
[18:04:27.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.044]                 }
[18:04:27.044]                 if (length(args) > 0) 
[18:04:27.044]                   base::do.call(base::Sys.setenv, args = args)
[18:04:27.044]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:27.044]             }
[18:04:27.044]             else {
[18:04:27.044]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:27.044]             }
[18:04:27.044]             {
[18:04:27.044]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:27.044]                   0L) {
[18:04:27.044]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:27.044]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:27.044]                   base::options(opts)
[18:04:27.044]                 }
[18:04:27.044]                 {
[18:04:27.044]                   {
[18:04:27.044]                     NULL
[18:04:27.044]                     RNGkind("Mersenne-Twister")
[18:04:27.044]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:27.044]                       inherits = FALSE)
[18:04:27.044]                   }
[18:04:27.044]                   options(future.plan = NULL)
[18:04:27.044]                   if (is.na(NA_character_)) 
[18:04:27.044]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.044]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:27.044]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:27.044]                     .init = FALSE)
[18:04:27.044]                 }
[18:04:27.044]             }
[18:04:27.044]         }
[18:04:27.044]     })
[18:04:27.044]     if (TRUE) {
[18:04:27.044]         base::sink(type = "output", split = FALSE)
[18:04:27.044]         if (TRUE) {
[18:04:27.044]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:27.044]         }
[18:04:27.044]         else {
[18:04:27.044]             ...future.result["stdout"] <- base::list(NULL)
[18:04:27.044]         }
[18:04:27.044]         base::close(...future.stdout)
[18:04:27.044]         ...future.stdout <- NULL
[18:04:27.044]     }
[18:04:27.044]     ...future.result$conditions <- ...future.conditions
[18:04:27.044]     ...future.result$finished <- base::Sys.time()
[18:04:27.044]     ...future.result
[18:04:27.044] }
[18:04:27.048] assign_globals() ...
[18:04:27.048] List of 3
[18:04:27.048]  $ outer_function:function (x)  
[18:04:27.048]  $ map           :function (.x, .f, ...)  
[18:04:27.048]  $ inner_function:function (x)  
[18:04:27.048]  - attr(*, "where")=List of 3
[18:04:27.048]   ..$ outer_function:<environment: R_EmptyEnv> 
[18:04:27.048]   ..$ map           :<environment: R_EmptyEnv> 
[18:04:27.048]   ..$ inner_function:<environment: R_EmptyEnv> 
[18:04:27.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:27.048]  - attr(*, "resolved")= logi FALSE
[18:04:27.048]  - attr(*, "total_size")= num 7704
[18:04:27.048]  - attr(*, "already-done")= logi TRUE
[18:04:27.055] - reassign environment for ‘outer_function’
[18:04:27.055] - copied ‘outer_function’ to environment
[18:04:27.056] - reassign environment for ‘map’
[18:04:27.056] - copied ‘map’ to environment
[18:04:27.056] - reassign environment for ‘inner_function’
[18:04:27.056] - copied ‘inner_function’ to environment
[18:04:27.056] assign_globals() ... done
[18:04:27.057] plan(): Setting new future strategy stack:
[18:04:27.057] List of future strategies:
[18:04:27.057] 1. sequential:
[18:04:27.057]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.057]    - tweaked: FALSE
[18:04:27.057]    - call: NULL
[18:04:27.058] plan(): nbrOfWorkers() = 1
[18:04:27.072] plan(): Setting new future strategy stack:
[18:04:27.072] List of future strategies:
[18:04:27.072] 1. sequential:
[18:04:27.072]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.072]    - tweaked: FALSE
[18:04:27.072]    - call: plan(strategy)
[18:04:27.073] plan(): nbrOfWorkers() = 1
[18:04:27.073] SequentialFuture started (and completed)
[18:04:27.074] - Launch lazy future ... done
[18:04:27.074] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[18:04:27.076] getGlobalsAndPackages() ...
[18:04:27.077] Searching for globals...
[18:04:27.086] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[18:04:27.086] Searching for globals ... DONE
[18:04:27.086] Resolving globals: FALSE
[18:04:27.088] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[18:04:27.089] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[18:04:27.089] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[18:04:27.089] 
[18:04:27.090] getGlobalsAndPackages() ... DONE
[18:04:27.090] run() for ‘Future’ ...
[18:04:27.090] - state: ‘created’
[18:04:27.091] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:27.091] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:27.091] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:27.092]   - Field: ‘label’
[18:04:27.092]   - Field: ‘local’
[18:04:27.092]   - Field: ‘owner’
[18:04:27.092]   - Field: ‘envir’
[18:04:27.092]   - Field: ‘packages’
[18:04:27.093]   - Field: ‘gc’
[18:04:27.093]   - Field: ‘conditions’
[18:04:27.093]   - Field: ‘expr’
[18:04:27.093]   - Field: ‘uuid’
[18:04:27.093]   - Field: ‘seed’
[18:04:27.094]   - Field: ‘version’
[18:04:27.094]   - Field: ‘result’
[18:04:27.094]   - Field: ‘asynchronous’
[18:04:27.094]   - Field: ‘calls’
[18:04:27.094]   - Field: ‘globals’
[18:04:27.095]   - Field: ‘stdout’
[18:04:27.095]   - Field: ‘earlySignal’
[18:04:27.095]   - Field: ‘lazy’
[18:04:27.095]   - Field: ‘state’
[18:04:27.095] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:27.096] - Launch lazy future ...
[18:04:27.096] Packages needed by the future expression (n = 0): <none>
[18:04:27.096] Packages needed by future strategies (n = 0): <none>
[18:04:27.097] {
[18:04:27.097]     {
[18:04:27.097]         {
[18:04:27.097]             ...future.startTime <- base::Sys.time()
[18:04:27.097]             {
[18:04:27.097]                 {
[18:04:27.097]                   {
[18:04:27.097]                     base::local({
[18:04:27.097]                       has_future <- base::requireNamespace("future", 
[18:04:27.097]                         quietly = TRUE)
[18:04:27.097]                       if (has_future) {
[18:04:27.097]                         ns <- base::getNamespace("future")
[18:04:27.097]                         version <- ns[[".package"]][["version"]]
[18:04:27.097]                         if (is.null(version)) 
[18:04:27.097]                           version <- utils::packageVersion("future")
[18:04:27.097]                       }
[18:04:27.097]                       else {
[18:04:27.097]                         version <- NULL
[18:04:27.097]                       }
[18:04:27.097]                       if (!has_future || version < "1.8.0") {
[18:04:27.097]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:27.097]                           "", base::R.version$version.string), 
[18:04:27.097]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:27.097]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:27.097]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:27.097]                             "release", "version")], collapse = " "), 
[18:04:27.097]                           hostname = base::Sys.info()[["nodename"]])
[18:04:27.097]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:27.097]                           info)
[18:04:27.097]                         info <- base::paste(info, collapse = "; ")
[18:04:27.097]                         if (!has_future) {
[18:04:27.097]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:27.097]                             info)
[18:04:27.097]                         }
[18:04:27.097]                         else {
[18:04:27.097]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:27.097]                             info, version)
[18:04:27.097]                         }
[18:04:27.097]                         base::stop(msg)
[18:04:27.097]                       }
[18:04:27.097]                     })
[18:04:27.097]                   }
[18:04:27.097]                   ...future.strategy.old <- future::plan("list")
[18:04:27.097]                   options(future.plan = NULL)
[18:04:27.097]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.097]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:27.097]                 }
[18:04:27.097]                 ...future.workdir <- getwd()
[18:04:27.097]             }
[18:04:27.097]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:27.097]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:27.097]         }
[18:04:27.097]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:27.097]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:27.097]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:27.097]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:27.097]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:27.097]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:27.097]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:27.097]             base::names(...future.oldOptions))
[18:04:27.097]     }
[18:04:27.097]     if (FALSE) {
[18:04:27.097]     }
[18:04:27.097]     else {
[18:04:27.097]         if (TRUE) {
[18:04:27.097]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:27.097]                 open = "w")
[18:04:27.097]         }
[18:04:27.097]         else {
[18:04:27.097]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:27.097]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:27.097]         }
[18:04:27.097]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:27.097]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:27.097]             base::sink(type = "output", split = FALSE)
[18:04:27.097]             base::close(...future.stdout)
[18:04:27.097]         }, add = TRUE)
[18:04:27.097]     }
[18:04:27.097]     ...future.frame <- base::sys.nframe()
[18:04:27.097]     ...future.conditions <- base::list()
[18:04:27.097]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:27.097]     if (FALSE) {
[18:04:27.097]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:27.097]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:27.097]     }
[18:04:27.097]     ...future.result <- base::tryCatch({
[18:04:27.097]         base::withCallingHandlers({
[18:04:27.097]             ...future.value <- base::withVisible(base::local({
[18:04:27.097]                 outer_function(1L)
[18:04:27.097]             }))
[18:04:27.097]             future::FutureResult(value = ...future.value$value, 
[18:04:27.097]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.097]                   ...future.rng), globalenv = if (FALSE) 
[18:04:27.097]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:27.097]                     ...future.globalenv.names))
[18:04:27.097]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:27.097]         }, condition = base::local({
[18:04:27.097]             c <- base::c
[18:04:27.097]             inherits <- base::inherits
[18:04:27.097]             invokeRestart <- base::invokeRestart
[18:04:27.097]             length <- base::length
[18:04:27.097]             list <- base::list
[18:04:27.097]             seq.int <- base::seq.int
[18:04:27.097]             signalCondition <- base::signalCondition
[18:04:27.097]             sys.calls <- base::sys.calls
[18:04:27.097]             `[[` <- base::`[[`
[18:04:27.097]             `+` <- base::`+`
[18:04:27.097]             `<<-` <- base::`<<-`
[18:04:27.097]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:27.097]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:27.097]                   3L)]
[18:04:27.097]             }
[18:04:27.097]             function(cond) {
[18:04:27.097]                 is_error <- inherits(cond, "error")
[18:04:27.097]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:27.097]                   NULL)
[18:04:27.097]                 if (is_error) {
[18:04:27.097]                   sessionInformation <- function() {
[18:04:27.097]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:27.097]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:27.097]                       search = base::search(), system = base::Sys.info())
[18:04:27.097]                   }
[18:04:27.097]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.097]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:27.097]                     cond$call), session = sessionInformation(), 
[18:04:27.097]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:27.097]                   signalCondition(cond)
[18:04:27.097]                 }
[18:04:27.097]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:27.097]                 "immediateCondition"))) {
[18:04:27.097]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:27.097]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.097]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:27.097]                   if (TRUE && !signal) {
[18:04:27.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.097]                     {
[18:04:27.097]                       inherits <- base::inherits
[18:04:27.097]                       invokeRestart <- base::invokeRestart
[18:04:27.097]                       is.null <- base::is.null
[18:04:27.097]                       muffled <- FALSE
[18:04:27.097]                       if (inherits(cond, "message")) {
[18:04:27.097]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.097]                         if (muffled) 
[18:04:27.097]                           invokeRestart("muffleMessage")
[18:04:27.097]                       }
[18:04:27.097]                       else if (inherits(cond, "warning")) {
[18:04:27.097]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.097]                         if (muffled) 
[18:04:27.097]                           invokeRestart("muffleWarning")
[18:04:27.097]                       }
[18:04:27.097]                       else if (inherits(cond, "condition")) {
[18:04:27.097]                         if (!is.null(pattern)) {
[18:04:27.097]                           computeRestarts <- base::computeRestarts
[18:04:27.097]                           grepl <- base::grepl
[18:04:27.097]                           restarts <- computeRestarts(cond)
[18:04:27.097]                           for (restart in restarts) {
[18:04:27.097]                             name <- restart$name
[18:04:27.097]                             if (is.null(name)) 
[18:04:27.097]                               next
[18:04:27.097]                             if (!grepl(pattern, name)) 
[18:04:27.097]                               next
[18:04:27.097]                             invokeRestart(restart)
[18:04:27.097]                             muffled <- TRUE
[18:04:27.097]                             break
[18:04:27.097]                           }
[18:04:27.097]                         }
[18:04:27.097]                       }
[18:04:27.097]                       invisible(muffled)
[18:04:27.097]                     }
[18:04:27.097]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.097]                   }
[18:04:27.097]                 }
[18:04:27.097]                 else {
[18:04:27.097]                   if (TRUE) {
[18:04:27.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.097]                     {
[18:04:27.097]                       inherits <- base::inherits
[18:04:27.097]                       invokeRestart <- base::invokeRestart
[18:04:27.097]                       is.null <- base::is.null
[18:04:27.097]                       muffled <- FALSE
[18:04:27.097]                       if (inherits(cond, "message")) {
[18:04:27.097]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.097]                         if (muffled) 
[18:04:27.097]                           invokeRestart("muffleMessage")
[18:04:27.097]                       }
[18:04:27.097]                       else if (inherits(cond, "warning")) {
[18:04:27.097]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.097]                         if (muffled) 
[18:04:27.097]                           invokeRestart("muffleWarning")
[18:04:27.097]                       }
[18:04:27.097]                       else if (inherits(cond, "condition")) {
[18:04:27.097]                         if (!is.null(pattern)) {
[18:04:27.097]                           computeRestarts <- base::computeRestarts
[18:04:27.097]                           grepl <- base::grepl
[18:04:27.097]                           restarts <- computeRestarts(cond)
[18:04:27.097]                           for (restart in restarts) {
[18:04:27.097]                             name <- restart$name
[18:04:27.097]                             if (is.null(name)) 
[18:04:27.097]                               next
[18:04:27.097]                             if (!grepl(pattern, name)) 
[18:04:27.097]                               next
[18:04:27.097]                             invokeRestart(restart)
[18:04:27.097]                             muffled <- TRUE
[18:04:27.097]                             break
[18:04:27.097]                           }
[18:04:27.097]                         }
[18:04:27.097]                       }
[18:04:27.097]                       invisible(muffled)
[18:04:27.097]                     }
[18:04:27.097]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.097]                   }
[18:04:27.097]                 }
[18:04:27.097]             }
[18:04:27.097]         }))
[18:04:27.097]     }, error = function(ex) {
[18:04:27.097]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:27.097]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.097]                 ...future.rng), started = ...future.startTime, 
[18:04:27.097]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:27.097]             version = "1.8"), class = "FutureResult")
[18:04:27.097]     }, finally = {
[18:04:27.097]         if (!identical(...future.workdir, getwd())) 
[18:04:27.097]             setwd(...future.workdir)
[18:04:27.097]         {
[18:04:27.097]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:27.097]                 ...future.oldOptions$nwarnings <- NULL
[18:04:27.097]             }
[18:04:27.097]             base::options(...future.oldOptions)
[18:04:27.097]             if (.Platform$OS.type == "windows") {
[18:04:27.097]                 old_names <- names(...future.oldEnvVars)
[18:04:27.097]                 envs <- base::Sys.getenv()
[18:04:27.097]                 names <- names(envs)
[18:04:27.097]                 common <- intersect(names, old_names)
[18:04:27.097]                 added <- setdiff(names, old_names)
[18:04:27.097]                 removed <- setdiff(old_names, names)
[18:04:27.097]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:27.097]                   envs[common]]
[18:04:27.097]                 NAMES <- toupper(changed)
[18:04:27.097]                 args <- list()
[18:04:27.097]                 for (kk in seq_along(NAMES)) {
[18:04:27.097]                   name <- changed[[kk]]
[18:04:27.097]                   NAME <- NAMES[[kk]]
[18:04:27.097]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.097]                     next
[18:04:27.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.097]                 }
[18:04:27.097]                 NAMES <- toupper(added)
[18:04:27.097]                 for (kk in seq_along(NAMES)) {
[18:04:27.097]                   name <- added[[kk]]
[18:04:27.097]                   NAME <- NAMES[[kk]]
[18:04:27.097]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.097]                     next
[18:04:27.097]                   args[[name]] <- ""
[18:04:27.097]                 }
[18:04:27.097]                 NAMES <- toupper(removed)
[18:04:27.097]                 for (kk in seq_along(NAMES)) {
[18:04:27.097]                   name <- removed[[kk]]
[18:04:27.097]                   NAME <- NAMES[[kk]]
[18:04:27.097]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.097]                     next
[18:04:27.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.097]                 }
[18:04:27.097]                 if (length(args) > 0) 
[18:04:27.097]                   base::do.call(base::Sys.setenv, args = args)
[18:04:27.097]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:27.097]             }
[18:04:27.097]             else {
[18:04:27.097]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:27.097]             }
[18:04:27.097]             {
[18:04:27.097]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:27.097]                   0L) {
[18:04:27.097]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:27.097]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:27.097]                   base::options(opts)
[18:04:27.097]                 }
[18:04:27.097]                 {
[18:04:27.097]                   {
[18:04:27.097]                     NULL
[18:04:27.097]                     RNGkind("Mersenne-Twister")
[18:04:27.097]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:27.097]                       inherits = FALSE)
[18:04:27.097]                   }
[18:04:27.097]                   options(future.plan = NULL)
[18:04:27.097]                   if (is.na(NA_character_)) 
[18:04:27.097]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.097]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:27.097]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:27.097]                     .init = FALSE)
[18:04:27.097]                 }
[18:04:27.097]             }
[18:04:27.097]         }
[18:04:27.097]     })
[18:04:27.097]     if (TRUE) {
[18:04:27.097]         base::sink(type = "output", split = FALSE)
[18:04:27.097]         if (TRUE) {
[18:04:27.097]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:27.097]         }
[18:04:27.097]         else {
[18:04:27.097]             ...future.result["stdout"] <- base::list(NULL)
[18:04:27.097]         }
[18:04:27.097]         base::close(...future.stdout)
[18:04:27.097]         ...future.stdout <- NULL
[18:04:27.097]     }
[18:04:27.097]     ...future.result$conditions <- ...future.conditions
[18:04:27.097]     ...future.result$finished <- base::Sys.time()
[18:04:27.097]     ...future.result
[18:04:27.097] }
[18:04:27.101] assign_globals() ...
[18:04:27.101] List of 3
[18:04:27.101]  $ outer_function:function (x)  
[18:04:27.101]  $ map           :function (.x, .f, ...)  
[18:04:27.101]  $ inner_function:function (x)  
[18:04:27.101]  - attr(*, "where")=List of 3
[18:04:27.101]   ..$ outer_function:<environment: R_EmptyEnv> 
[18:04:27.101]   ..$ map           :<environment: R_EmptyEnv> 
[18:04:27.101]   ..$ inner_function:<environment: R_EmptyEnv> 
[18:04:27.101]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:27.101]  - attr(*, "resolved")= logi FALSE
[18:04:27.101]  - attr(*, "total_size")= num 7704
[18:04:27.101]  - attr(*, "already-done")= logi TRUE
[18:04:27.107] - reassign environment for ‘outer_function’
[18:04:27.108] - copied ‘outer_function’ to environment
[18:04:27.108] - reassign environment for ‘map’
[18:04:27.108] - copied ‘map’ to environment
[18:04:27.108] - reassign environment for ‘inner_function’
[18:04:27.109] - copied ‘inner_function’ to environment
[18:04:27.109] assign_globals() ... done
[18:04:27.109] plan(): Setting new future strategy stack:
[18:04:27.109] List of future strategies:
[18:04:27.109] 1. sequential:
[18:04:27.109]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.109]    - tweaked: FALSE
[18:04:27.109]    - call: NULL
[18:04:27.110] plan(): nbrOfWorkers() = 1
[18:04:27.112] plan(): Setting new future strategy stack:
[18:04:27.112] List of future strategies:
[18:04:27.112] 1. sequential:
[18:04:27.112]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.112]    - tweaked: FALSE
[18:04:27.112]    - call: plan(strategy)
[18:04:27.113] plan(): nbrOfWorkers() = 1
[18:04:27.113] SequentialFuture started (and completed)
[18:04:27.114] - Launch lazy future ... done
[18:04:27.114] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[18:04:27.136] plan(): Setting new future strategy stack:
[18:04:27.136] List of future strategies:
[18:04:27.136] 1. multicore:
[18:04:27.136]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:27.136]    - tweaked: FALSE
[18:04:27.136]    - call: plan(strategy)
[18:04:27.142] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[18:04:27.143] getGlobalsAndPackages() ...
[18:04:27.143] Searching for globals...
[18:04:27.146] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:27.146] Searching for globals ... DONE
[18:04:27.147] Resolving globals: FALSE
[18:04:27.147] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:27.148] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:27.148] - globals: [2] ‘weight’, ‘group’
[18:04:27.149] - packages: [1] ‘stats’
[18:04:27.149] getGlobalsAndPackages() ... DONE
[18:04:27.149] run() for ‘Future’ ...
[18:04:27.150] - state: ‘created’
[18:04:27.150] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:27.156] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:27.156] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:27.157]   - Field: ‘label’
[18:04:27.157]   - Field: ‘local’
[18:04:27.157]   - Field: ‘owner’
[18:04:27.157]   - Field: ‘envir’
[18:04:27.157]   - Field: ‘workers’
[18:04:27.158]   - Field: ‘packages’
[18:04:27.158]   - Field: ‘gc’
[18:04:27.158]   - Field: ‘job’
[18:04:27.158]   - Field: ‘conditions’
[18:04:27.158]   - Field: ‘expr’
[18:04:27.159]   - Field: ‘uuid’
[18:04:27.159]   - Field: ‘seed’
[18:04:27.159]   - Field: ‘version’
[18:04:27.159]   - Field: ‘result’
[18:04:27.159]   - Field: ‘asynchronous’
[18:04:27.160]   - Field: ‘calls’
[18:04:27.160]   - Field: ‘globals’
[18:04:27.160]   - Field: ‘stdout’
[18:04:27.160]   - Field: ‘earlySignal’
[18:04:27.160]   - Field: ‘lazy’
[18:04:27.161]   - Field: ‘state’
[18:04:27.161] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:27.161] - Launch lazy future ...
[18:04:27.163] Packages needed by the future expression (n = 1): ‘stats’
[18:04:27.163] Packages needed by future strategies (n = 0): <none>
[18:04:27.164] {
[18:04:27.164]     {
[18:04:27.164]         {
[18:04:27.164]             ...future.startTime <- base::Sys.time()
[18:04:27.164]             {
[18:04:27.164]                 {
[18:04:27.164]                   {
[18:04:27.164]                     {
[18:04:27.164]                       {
[18:04:27.164]                         base::local({
[18:04:27.164]                           has_future <- base::requireNamespace("future", 
[18:04:27.164]                             quietly = TRUE)
[18:04:27.164]                           if (has_future) {
[18:04:27.164]                             ns <- base::getNamespace("future")
[18:04:27.164]                             version <- ns[[".package"]][["version"]]
[18:04:27.164]                             if (is.null(version)) 
[18:04:27.164]                               version <- utils::packageVersion("future")
[18:04:27.164]                           }
[18:04:27.164]                           else {
[18:04:27.164]                             version <- NULL
[18:04:27.164]                           }
[18:04:27.164]                           if (!has_future || version < "1.8.0") {
[18:04:27.164]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:27.164]                               "", base::R.version$version.string), 
[18:04:27.164]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:27.164]                                 base::R.version$platform, 8 * 
[18:04:27.164]                                   base::.Machine$sizeof.pointer), 
[18:04:27.164]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:27.164]                                 "release", "version")], collapse = " "), 
[18:04:27.164]                               hostname = base::Sys.info()[["nodename"]])
[18:04:27.164]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:27.164]                               info)
[18:04:27.164]                             info <- base::paste(info, collapse = "; ")
[18:04:27.164]                             if (!has_future) {
[18:04:27.164]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:27.164]                                 info)
[18:04:27.164]                             }
[18:04:27.164]                             else {
[18:04:27.164]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:27.164]                                 info, version)
[18:04:27.164]                             }
[18:04:27.164]                             base::stop(msg)
[18:04:27.164]                           }
[18:04:27.164]                         })
[18:04:27.164]                       }
[18:04:27.164]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:27.164]                       base::options(mc.cores = 1L)
[18:04:27.164]                     }
[18:04:27.164]                     base::local({
[18:04:27.164]                       for (pkg in "stats") {
[18:04:27.164]                         base::loadNamespace(pkg)
[18:04:27.164]                         base::library(pkg, character.only = TRUE)
[18:04:27.164]                       }
[18:04:27.164]                     })
[18:04:27.164]                   }
[18:04:27.164]                   ...future.strategy.old <- future::plan("list")
[18:04:27.164]                   options(future.plan = NULL)
[18:04:27.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:27.164]                 }
[18:04:27.164]                 ...future.workdir <- getwd()
[18:04:27.164]             }
[18:04:27.164]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:27.164]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:27.164]         }
[18:04:27.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:27.164]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:27.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:27.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:27.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:27.164]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:27.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:27.164]             base::names(...future.oldOptions))
[18:04:27.164]     }
[18:04:27.164]     if (FALSE) {
[18:04:27.164]     }
[18:04:27.164]     else {
[18:04:27.164]         if (TRUE) {
[18:04:27.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:27.164]                 open = "w")
[18:04:27.164]         }
[18:04:27.164]         else {
[18:04:27.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:27.164]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:27.164]         }
[18:04:27.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:27.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:27.164]             base::sink(type = "output", split = FALSE)
[18:04:27.164]             base::close(...future.stdout)
[18:04:27.164]         }, add = TRUE)
[18:04:27.164]     }
[18:04:27.164]     ...future.frame <- base::sys.nframe()
[18:04:27.164]     ...future.conditions <- base::list()
[18:04:27.164]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:27.164]     if (FALSE) {
[18:04:27.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:27.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:27.164]     }
[18:04:27.164]     ...future.result <- base::tryCatch({
[18:04:27.164]         base::withCallingHandlers({
[18:04:27.164]             ...future.value <- base::withVisible(base::local({
[18:04:27.164]                 withCallingHandlers({
[18:04:27.164]                   {
[18:04:27.164]                     lm(weight ~ group - 1)
[18:04:27.164]                   }
[18:04:27.164]                 }, immediateCondition = function(cond) {
[18:04:27.164]                   save_rds <- function (object, pathname, ...) 
[18:04:27.164]                   {
[18:04:27.164]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:27.164]                     if (file_test("-f", pathname_tmp)) {
[18:04:27.164]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.164]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:27.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.164]                         fi_tmp[["mtime"]])
[18:04:27.164]                     }
[18:04:27.164]                     tryCatch({
[18:04:27.164]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:27.164]                     }, error = function(ex) {
[18:04:27.164]                       msg <- conditionMessage(ex)
[18:04:27.164]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.164]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:27.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.164]                         fi_tmp[["mtime"]], msg)
[18:04:27.164]                       ex$message <- msg
[18:04:27.164]                       stop(ex)
[18:04:27.164]                     })
[18:04:27.164]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:27.164]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:27.164]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:27.164]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.164]                       fi <- file.info(pathname)
[18:04:27.164]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:27.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.164]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:27.164]                         fi[["size"]], fi[["mtime"]])
[18:04:27.164]                       stop(msg)
[18:04:27.164]                     }
[18:04:27.164]                     invisible(pathname)
[18:04:27.164]                   }
[18:04:27.164]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:27.164]                     rootPath = tempdir()) 
[18:04:27.164]                   {
[18:04:27.164]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:27.164]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:27.164]                       tmpdir = path, fileext = ".rds")
[18:04:27.164]                     save_rds(obj, file)
[18:04:27.164]                   }
[18:04:27.164]                   saveImmediateCondition(cond, path = "/tmp/RtmpLRNsAG/.future/immediateConditions")
[18:04:27.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.164]                   {
[18:04:27.164]                     inherits <- base::inherits
[18:04:27.164]                     invokeRestart <- base::invokeRestart
[18:04:27.164]                     is.null <- base::is.null
[18:04:27.164]                     muffled <- FALSE
[18:04:27.164]                     if (inherits(cond, "message")) {
[18:04:27.164]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:27.164]                       if (muffled) 
[18:04:27.164]                         invokeRestart("muffleMessage")
[18:04:27.164]                     }
[18:04:27.164]                     else if (inherits(cond, "warning")) {
[18:04:27.164]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:27.164]                       if (muffled) 
[18:04:27.164]                         invokeRestart("muffleWarning")
[18:04:27.164]                     }
[18:04:27.164]                     else if (inherits(cond, "condition")) {
[18:04:27.164]                       if (!is.null(pattern)) {
[18:04:27.164]                         computeRestarts <- base::computeRestarts
[18:04:27.164]                         grepl <- base::grepl
[18:04:27.164]                         restarts <- computeRestarts(cond)
[18:04:27.164]                         for (restart in restarts) {
[18:04:27.164]                           name <- restart$name
[18:04:27.164]                           if (is.null(name)) 
[18:04:27.164]                             next
[18:04:27.164]                           if (!grepl(pattern, name)) 
[18:04:27.164]                             next
[18:04:27.164]                           invokeRestart(restart)
[18:04:27.164]                           muffled <- TRUE
[18:04:27.164]                           break
[18:04:27.164]                         }
[18:04:27.164]                       }
[18:04:27.164]                     }
[18:04:27.164]                     invisible(muffled)
[18:04:27.164]                   }
[18:04:27.164]                   muffleCondition(cond)
[18:04:27.164]                 })
[18:04:27.164]             }))
[18:04:27.164]             future::FutureResult(value = ...future.value$value, 
[18:04:27.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.164]                   ...future.rng), globalenv = if (FALSE) 
[18:04:27.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:27.164]                     ...future.globalenv.names))
[18:04:27.164]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:27.164]         }, condition = base::local({
[18:04:27.164]             c <- base::c
[18:04:27.164]             inherits <- base::inherits
[18:04:27.164]             invokeRestart <- base::invokeRestart
[18:04:27.164]             length <- base::length
[18:04:27.164]             list <- base::list
[18:04:27.164]             seq.int <- base::seq.int
[18:04:27.164]             signalCondition <- base::signalCondition
[18:04:27.164]             sys.calls <- base::sys.calls
[18:04:27.164]             `[[` <- base::`[[`
[18:04:27.164]             `+` <- base::`+`
[18:04:27.164]             `<<-` <- base::`<<-`
[18:04:27.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:27.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:27.164]                   3L)]
[18:04:27.164]             }
[18:04:27.164]             function(cond) {
[18:04:27.164]                 is_error <- inherits(cond, "error")
[18:04:27.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:27.164]                   NULL)
[18:04:27.164]                 if (is_error) {
[18:04:27.164]                   sessionInformation <- function() {
[18:04:27.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:27.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:27.164]                       search = base::search(), system = base::Sys.info())
[18:04:27.164]                   }
[18:04:27.164]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:27.164]                     cond$call), session = sessionInformation(), 
[18:04:27.164]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:27.164]                   signalCondition(cond)
[18:04:27.164]                 }
[18:04:27.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:27.164]                 "immediateCondition"))) {
[18:04:27.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:27.164]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:27.164]                   if (TRUE && !signal) {
[18:04:27.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.164]                     {
[18:04:27.164]                       inherits <- base::inherits
[18:04:27.164]                       invokeRestart <- base::invokeRestart
[18:04:27.164]                       is.null <- base::is.null
[18:04:27.164]                       muffled <- FALSE
[18:04:27.164]                       if (inherits(cond, "message")) {
[18:04:27.164]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.164]                         if (muffled) 
[18:04:27.164]                           invokeRestart("muffleMessage")
[18:04:27.164]                       }
[18:04:27.164]                       else if (inherits(cond, "warning")) {
[18:04:27.164]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.164]                         if (muffled) 
[18:04:27.164]                           invokeRestart("muffleWarning")
[18:04:27.164]                       }
[18:04:27.164]                       else if (inherits(cond, "condition")) {
[18:04:27.164]                         if (!is.null(pattern)) {
[18:04:27.164]                           computeRestarts <- base::computeRestarts
[18:04:27.164]                           grepl <- base::grepl
[18:04:27.164]                           restarts <- computeRestarts(cond)
[18:04:27.164]                           for (restart in restarts) {
[18:04:27.164]                             name <- restart$name
[18:04:27.164]                             if (is.null(name)) 
[18:04:27.164]                               next
[18:04:27.164]                             if (!grepl(pattern, name)) 
[18:04:27.164]                               next
[18:04:27.164]                             invokeRestart(restart)
[18:04:27.164]                             muffled <- TRUE
[18:04:27.164]                             break
[18:04:27.164]                           }
[18:04:27.164]                         }
[18:04:27.164]                       }
[18:04:27.164]                       invisible(muffled)
[18:04:27.164]                     }
[18:04:27.164]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.164]                   }
[18:04:27.164]                 }
[18:04:27.164]                 else {
[18:04:27.164]                   if (TRUE) {
[18:04:27.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.164]                     {
[18:04:27.164]                       inherits <- base::inherits
[18:04:27.164]                       invokeRestart <- base::invokeRestart
[18:04:27.164]                       is.null <- base::is.null
[18:04:27.164]                       muffled <- FALSE
[18:04:27.164]                       if (inherits(cond, "message")) {
[18:04:27.164]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.164]                         if (muffled) 
[18:04:27.164]                           invokeRestart("muffleMessage")
[18:04:27.164]                       }
[18:04:27.164]                       else if (inherits(cond, "warning")) {
[18:04:27.164]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.164]                         if (muffled) 
[18:04:27.164]                           invokeRestart("muffleWarning")
[18:04:27.164]                       }
[18:04:27.164]                       else if (inherits(cond, "condition")) {
[18:04:27.164]                         if (!is.null(pattern)) {
[18:04:27.164]                           computeRestarts <- base::computeRestarts
[18:04:27.164]                           grepl <- base::grepl
[18:04:27.164]                           restarts <- computeRestarts(cond)
[18:04:27.164]                           for (restart in restarts) {
[18:04:27.164]                             name <- restart$name
[18:04:27.164]                             if (is.null(name)) 
[18:04:27.164]                               next
[18:04:27.164]                             if (!grepl(pattern, name)) 
[18:04:27.164]                               next
[18:04:27.164]                             invokeRestart(restart)
[18:04:27.164]                             muffled <- TRUE
[18:04:27.164]                             break
[18:04:27.164]                           }
[18:04:27.164]                         }
[18:04:27.164]                       }
[18:04:27.164]                       invisible(muffled)
[18:04:27.164]                     }
[18:04:27.164]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.164]                   }
[18:04:27.164]                 }
[18:04:27.164]             }
[18:04:27.164]         }))
[18:04:27.164]     }, error = function(ex) {
[18:04:27.164]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:27.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.164]                 ...future.rng), started = ...future.startTime, 
[18:04:27.164]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:27.164]             version = "1.8"), class = "FutureResult")
[18:04:27.164]     }, finally = {
[18:04:27.164]         if (!identical(...future.workdir, getwd())) 
[18:04:27.164]             setwd(...future.workdir)
[18:04:27.164]         {
[18:04:27.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:27.164]                 ...future.oldOptions$nwarnings <- NULL
[18:04:27.164]             }
[18:04:27.164]             base::options(...future.oldOptions)
[18:04:27.164]             if (.Platform$OS.type == "windows") {
[18:04:27.164]                 old_names <- names(...future.oldEnvVars)
[18:04:27.164]                 envs <- base::Sys.getenv()
[18:04:27.164]                 names <- names(envs)
[18:04:27.164]                 common <- intersect(names, old_names)
[18:04:27.164]                 added <- setdiff(names, old_names)
[18:04:27.164]                 removed <- setdiff(old_names, names)
[18:04:27.164]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:27.164]                   envs[common]]
[18:04:27.164]                 NAMES <- toupper(changed)
[18:04:27.164]                 args <- list()
[18:04:27.164]                 for (kk in seq_along(NAMES)) {
[18:04:27.164]                   name <- changed[[kk]]
[18:04:27.164]                   NAME <- NAMES[[kk]]
[18:04:27.164]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.164]                     next
[18:04:27.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.164]                 }
[18:04:27.164]                 NAMES <- toupper(added)
[18:04:27.164]                 for (kk in seq_along(NAMES)) {
[18:04:27.164]                   name <- added[[kk]]
[18:04:27.164]                   NAME <- NAMES[[kk]]
[18:04:27.164]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.164]                     next
[18:04:27.164]                   args[[name]] <- ""
[18:04:27.164]                 }
[18:04:27.164]                 NAMES <- toupper(removed)
[18:04:27.164]                 for (kk in seq_along(NAMES)) {
[18:04:27.164]                   name <- removed[[kk]]
[18:04:27.164]                   NAME <- NAMES[[kk]]
[18:04:27.164]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.164]                     next
[18:04:27.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.164]                 }
[18:04:27.164]                 if (length(args) > 0) 
[18:04:27.164]                   base::do.call(base::Sys.setenv, args = args)
[18:04:27.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:27.164]             }
[18:04:27.164]             else {
[18:04:27.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:27.164]             }
[18:04:27.164]             {
[18:04:27.164]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:27.164]                   0L) {
[18:04:27.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:27.164]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:27.164]                   base::options(opts)
[18:04:27.164]                 }
[18:04:27.164]                 {
[18:04:27.164]                   {
[18:04:27.164]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:27.164]                     NULL
[18:04:27.164]                   }
[18:04:27.164]                   options(future.plan = NULL)
[18:04:27.164]                   if (is.na(NA_character_)) 
[18:04:27.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:27.164]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:27.164]                     .init = FALSE)
[18:04:27.164]                 }
[18:04:27.164]             }
[18:04:27.164]         }
[18:04:27.164]     })
[18:04:27.164]     if (TRUE) {
[18:04:27.164]         base::sink(type = "output", split = FALSE)
[18:04:27.164]         if (TRUE) {
[18:04:27.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:27.164]         }
[18:04:27.164]         else {
[18:04:27.164]             ...future.result["stdout"] <- base::list(NULL)
[18:04:27.164]         }
[18:04:27.164]         base::close(...future.stdout)
[18:04:27.164]         ...future.stdout <- NULL
[18:04:27.164]     }
[18:04:27.164]     ...future.result$conditions <- ...future.conditions
[18:04:27.164]     ...future.result$finished <- base::Sys.time()
[18:04:27.164]     ...future.result
[18:04:27.164] }
[18:04:27.168] assign_globals() ...
[18:04:27.168] List of 2
[18:04:27.168]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[18:04:27.168]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[18:04:27.168]  - attr(*, "where")=List of 2
[18:04:27.168]   ..$ weight:<environment: R_EmptyEnv> 
[18:04:27.168]   ..$ group :<environment: R_EmptyEnv> 
[18:04:27.168]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:27.168]  - attr(*, "resolved")= logi FALSE
[18:04:27.168]  - attr(*, "total_size")= num 896
[18:04:27.168]  - attr(*, "already-done")= logi TRUE
[18:04:27.174] - copied ‘weight’ to environment
[18:04:27.175] - copied ‘group’ to environment
[18:04:27.175] assign_globals() ... done
[18:04:27.177] requestCore(): workers = 2
[18:04:27.182] MulticoreFuture started
[18:04:27.183] - Launch lazy future ... done
[18:04:27.183] run() for ‘MulticoreFuture’ ... done
[18:04:27.184] plan(): Setting new future strategy stack:
[18:04:27.185] result() for MulticoreFuture ...
[18:04:27.185] List of future strategies:
[18:04:27.185] 1. sequential:
[18:04:27.185]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.185]    - tweaked: FALSE
[18:04:27.185]    - call: NULL
[18:04:27.187] plan(): nbrOfWorkers() = 1
[18:04:27.196] plan(): Setting new future strategy stack:
[18:04:27.196] List of future strategies:
[18:04:27.196] 1. multicore:
[18:04:27.196]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:27.196]    - tweaked: FALSE
[18:04:27.196]    - call: plan(strategy)
[18:04:27.205] plan(): nbrOfWorkers() = 2
[18:04:27.216] result() for MulticoreFuture ...
[18:04:27.216] result() for MulticoreFuture ... done
[18:04:27.216] result() for MulticoreFuture ... done
[18:04:27.216] result() for MulticoreFuture ...
[18:04:27.217] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[18:04:27.221] getGlobalsAndPackages() ...
[18:04:27.221] Searching for globals...
[18:04:27.225] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:27.225] Searching for globals ... DONE
[18:04:27.226] Resolving globals: FALSE
[18:04:27.227] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:27.228] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:27.228] - globals: [2] ‘weight’, ‘group’
[18:04:27.228] - packages: [1] ‘stats’
[18:04:27.229] getGlobalsAndPackages() ... DONE
[18:04:27.229] run() for ‘Future’ ...
[18:04:27.229] - state: ‘created’
[18:04:27.230] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:27.237] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:27.237] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:27.237]   - Field: ‘label’
[18:04:27.237]   - Field: ‘local’
[18:04:27.238]   - Field: ‘owner’
[18:04:27.238]   - Field: ‘envir’
[18:04:27.238]   - Field: ‘workers’
[18:04:27.238]   - Field: ‘packages’
[18:04:27.239]   - Field: ‘gc’
[18:04:27.239]   - Field: ‘job’
[18:04:27.239]   - Field: ‘conditions’
[18:04:27.239]   - Field: ‘expr’
[18:04:27.240]   - Field: ‘uuid’
[18:04:27.240]   - Field: ‘seed’
[18:04:27.240]   - Field: ‘version’
[18:04:27.240]   - Field: ‘result’
[18:04:27.241]   - Field: ‘asynchronous’
[18:04:27.241]   - Field: ‘calls’
[18:04:27.241]   - Field: ‘globals’
[18:04:27.242]   - Field: ‘stdout’
[18:04:27.242]   - Field: ‘earlySignal’
[18:04:27.242]   - Field: ‘lazy’
[18:04:27.242]   - Field: ‘state’
[18:04:27.242] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:27.243] - Launch lazy future ...
[18:04:27.243] Packages needed by the future expression (n = 1): ‘stats’
[18:04:27.244] Packages needed by future strategies (n = 0): <none>
[18:04:27.245] {
[18:04:27.245]     {
[18:04:27.245]         {
[18:04:27.245]             ...future.startTime <- base::Sys.time()
[18:04:27.245]             {
[18:04:27.245]                 {
[18:04:27.245]                   {
[18:04:27.245]                     {
[18:04:27.245]                       {
[18:04:27.245]                         base::local({
[18:04:27.245]                           has_future <- base::requireNamespace("future", 
[18:04:27.245]                             quietly = TRUE)
[18:04:27.245]                           if (has_future) {
[18:04:27.245]                             ns <- base::getNamespace("future")
[18:04:27.245]                             version <- ns[[".package"]][["version"]]
[18:04:27.245]                             if (is.null(version)) 
[18:04:27.245]                               version <- utils::packageVersion("future")
[18:04:27.245]                           }
[18:04:27.245]                           else {
[18:04:27.245]                             version <- NULL
[18:04:27.245]                           }
[18:04:27.245]                           if (!has_future || version < "1.8.0") {
[18:04:27.245]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:27.245]                               "", base::R.version$version.string), 
[18:04:27.245]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:27.245]                                 base::R.version$platform, 8 * 
[18:04:27.245]                                   base::.Machine$sizeof.pointer), 
[18:04:27.245]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:27.245]                                 "release", "version")], collapse = " "), 
[18:04:27.245]                               hostname = base::Sys.info()[["nodename"]])
[18:04:27.245]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:27.245]                               info)
[18:04:27.245]                             info <- base::paste(info, collapse = "; ")
[18:04:27.245]                             if (!has_future) {
[18:04:27.245]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:27.245]                                 info)
[18:04:27.245]                             }
[18:04:27.245]                             else {
[18:04:27.245]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:27.245]                                 info, version)
[18:04:27.245]                             }
[18:04:27.245]                             base::stop(msg)
[18:04:27.245]                           }
[18:04:27.245]                         })
[18:04:27.245]                       }
[18:04:27.245]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:27.245]                       base::options(mc.cores = 1L)
[18:04:27.245]                     }
[18:04:27.245]                     base::local({
[18:04:27.245]                       for (pkg in "stats") {
[18:04:27.245]                         base::loadNamespace(pkg)
[18:04:27.245]                         base::library(pkg, character.only = TRUE)
[18:04:27.245]                       }
[18:04:27.245]                     })
[18:04:27.245]                   }
[18:04:27.245]                   ...future.strategy.old <- future::plan("list")
[18:04:27.245]                   options(future.plan = NULL)
[18:04:27.245]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.245]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:27.245]                 }
[18:04:27.245]                 ...future.workdir <- getwd()
[18:04:27.245]             }
[18:04:27.245]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:27.245]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:27.245]         }
[18:04:27.245]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:27.245]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:27.245]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:27.245]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:27.245]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:27.245]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:27.245]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:27.245]             base::names(...future.oldOptions))
[18:04:27.245]     }
[18:04:27.245]     if (FALSE) {
[18:04:27.245]     }
[18:04:27.245]     else {
[18:04:27.245]         if (TRUE) {
[18:04:27.245]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:27.245]                 open = "w")
[18:04:27.245]         }
[18:04:27.245]         else {
[18:04:27.245]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:27.245]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:27.245]         }
[18:04:27.245]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:27.245]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:27.245]             base::sink(type = "output", split = FALSE)
[18:04:27.245]             base::close(...future.stdout)
[18:04:27.245]         }, add = TRUE)
[18:04:27.245]     }
[18:04:27.245]     ...future.frame <- base::sys.nframe()
[18:04:27.245]     ...future.conditions <- base::list()
[18:04:27.245]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:27.245]     if (FALSE) {
[18:04:27.245]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:27.245]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:27.245]     }
[18:04:27.245]     ...future.result <- base::tryCatch({
[18:04:27.245]         base::withCallingHandlers({
[18:04:27.245]             ...future.value <- base::withVisible(base::local({
[18:04:27.245]                 withCallingHandlers({
[18:04:27.245]                   {
[18:04:27.245]                     lm(weight ~ group - 1)
[18:04:27.245]                   }
[18:04:27.245]                 }, immediateCondition = function(cond) {
[18:04:27.245]                   save_rds <- function (object, pathname, ...) 
[18:04:27.245]                   {
[18:04:27.245]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:27.245]                     if (file_test("-f", pathname_tmp)) {
[18:04:27.245]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.245]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:27.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.245]                         fi_tmp[["mtime"]])
[18:04:27.245]                     }
[18:04:27.245]                     tryCatch({
[18:04:27.245]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:27.245]                     }, error = function(ex) {
[18:04:27.245]                       msg <- conditionMessage(ex)
[18:04:27.245]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.245]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:27.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.245]                         fi_tmp[["mtime"]], msg)
[18:04:27.245]                       ex$message <- msg
[18:04:27.245]                       stop(ex)
[18:04:27.245]                     })
[18:04:27.245]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:27.245]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:27.245]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:27.245]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.245]                       fi <- file.info(pathname)
[18:04:27.245]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:27.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.245]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:27.245]                         fi[["size"]], fi[["mtime"]])
[18:04:27.245]                       stop(msg)
[18:04:27.245]                     }
[18:04:27.245]                     invisible(pathname)
[18:04:27.245]                   }
[18:04:27.245]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:27.245]                     rootPath = tempdir()) 
[18:04:27.245]                   {
[18:04:27.245]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:27.245]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:27.245]                       tmpdir = path, fileext = ".rds")
[18:04:27.245]                     save_rds(obj, file)
[18:04:27.245]                   }
[18:04:27.245]                   saveImmediateCondition(cond, path = "/tmp/RtmpLRNsAG/.future/immediateConditions")
[18:04:27.245]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.245]                   {
[18:04:27.245]                     inherits <- base::inherits
[18:04:27.245]                     invokeRestart <- base::invokeRestart
[18:04:27.245]                     is.null <- base::is.null
[18:04:27.245]                     muffled <- FALSE
[18:04:27.245]                     if (inherits(cond, "message")) {
[18:04:27.245]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:27.245]                       if (muffled) 
[18:04:27.245]                         invokeRestart("muffleMessage")
[18:04:27.245]                     }
[18:04:27.245]                     else if (inherits(cond, "warning")) {
[18:04:27.245]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:27.245]                       if (muffled) 
[18:04:27.245]                         invokeRestart("muffleWarning")
[18:04:27.245]                     }
[18:04:27.245]                     else if (inherits(cond, "condition")) {
[18:04:27.245]                       if (!is.null(pattern)) {
[18:04:27.245]                         computeRestarts <- base::computeRestarts
[18:04:27.245]                         grepl <- base::grepl
[18:04:27.245]                         restarts <- computeRestarts(cond)
[18:04:27.245]                         for (restart in restarts) {
[18:04:27.245]                           name <- restart$name
[18:04:27.245]                           if (is.null(name)) 
[18:04:27.245]                             next
[18:04:27.245]                           if (!grepl(pattern, name)) 
[18:04:27.245]                             next
[18:04:27.245]                           invokeRestart(restart)
[18:04:27.245]                           muffled <- TRUE
[18:04:27.245]                           break
[18:04:27.245]                         }
[18:04:27.245]                       }
[18:04:27.245]                     }
[18:04:27.245]                     invisible(muffled)
[18:04:27.245]                   }
[18:04:27.245]                   muffleCondition(cond)
[18:04:27.245]                 })
[18:04:27.245]             }))
[18:04:27.245]             future::FutureResult(value = ...future.value$value, 
[18:04:27.245]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.245]                   ...future.rng), globalenv = if (FALSE) 
[18:04:27.245]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:27.245]                     ...future.globalenv.names))
[18:04:27.245]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:27.245]         }, condition = base::local({
[18:04:27.245]             c <- base::c
[18:04:27.245]             inherits <- base::inherits
[18:04:27.245]             invokeRestart <- base::invokeRestart
[18:04:27.245]             length <- base::length
[18:04:27.245]             list <- base::list
[18:04:27.245]             seq.int <- base::seq.int
[18:04:27.245]             signalCondition <- base::signalCondition
[18:04:27.245]             sys.calls <- base::sys.calls
[18:04:27.245]             `[[` <- base::`[[`
[18:04:27.245]             `+` <- base::`+`
[18:04:27.245]             `<<-` <- base::`<<-`
[18:04:27.245]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:27.245]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:27.245]                   3L)]
[18:04:27.245]             }
[18:04:27.245]             function(cond) {
[18:04:27.245]                 is_error <- inherits(cond, "error")
[18:04:27.245]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:27.245]                   NULL)
[18:04:27.245]                 if (is_error) {
[18:04:27.245]                   sessionInformation <- function() {
[18:04:27.245]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:27.245]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:27.245]                       search = base::search(), system = base::Sys.info())
[18:04:27.245]                   }
[18:04:27.245]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.245]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:27.245]                     cond$call), session = sessionInformation(), 
[18:04:27.245]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:27.245]                   signalCondition(cond)
[18:04:27.245]                 }
[18:04:27.245]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:27.245]                 "immediateCondition"))) {
[18:04:27.245]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:27.245]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.245]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:27.245]                   if (TRUE && !signal) {
[18:04:27.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.245]                     {
[18:04:27.245]                       inherits <- base::inherits
[18:04:27.245]                       invokeRestart <- base::invokeRestart
[18:04:27.245]                       is.null <- base::is.null
[18:04:27.245]                       muffled <- FALSE
[18:04:27.245]                       if (inherits(cond, "message")) {
[18:04:27.245]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.245]                         if (muffled) 
[18:04:27.245]                           invokeRestart("muffleMessage")
[18:04:27.245]                       }
[18:04:27.245]                       else if (inherits(cond, "warning")) {
[18:04:27.245]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.245]                         if (muffled) 
[18:04:27.245]                           invokeRestart("muffleWarning")
[18:04:27.245]                       }
[18:04:27.245]                       else if (inherits(cond, "condition")) {
[18:04:27.245]                         if (!is.null(pattern)) {
[18:04:27.245]                           computeRestarts <- base::computeRestarts
[18:04:27.245]                           grepl <- base::grepl
[18:04:27.245]                           restarts <- computeRestarts(cond)
[18:04:27.245]                           for (restart in restarts) {
[18:04:27.245]                             name <- restart$name
[18:04:27.245]                             if (is.null(name)) 
[18:04:27.245]                               next
[18:04:27.245]                             if (!grepl(pattern, name)) 
[18:04:27.245]                               next
[18:04:27.245]                             invokeRestart(restart)
[18:04:27.245]                             muffled <- TRUE
[18:04:27.245]                             break
[18:04:27.245]                           }
[18:04:27.245]                         }
[18:04:27.245]                       }
[18:04:27.245]                       invisible(muffled)
[18:04:27.245]                     }
[18:04:27.245]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.245]                   }
[18:04:27.245]                 }
[18:04:27.245]                 else {
[18:04:27.245]                   if (TRUE) {
[18:04:27.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.245]                     {
[18:04:27.245]                       inherits <- base::inherits
[18:04:27.245]                       invokeRestart <- base::invokeRestart
[18:04:27.245]                       is.null <- base::is.null
[18:04:27.245]                       muffled <- FALSE
[18:04:27.245]                       if (inherits(cond, "message")) {
[18:04:27.245]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.245]                         if (muffled) 
[18:04:27.245]                           invokeRestart("muffleMessage")
[18:04:27.245]                       }
[18:04:27.245]                       else if (inherits(cond, "warning")) {
[18:04:27.245]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.245]                         if (muffled) 
[18:04:27.245]                           invokeRestart("muffleWarning")
[18:04:27.245]                       }
[18:04:27.245]                       else if (inherits(cond, "condition")) {
[18:04:27.245]                         if (!is.null(pattern)) {
[18:04:27.245]                           computeRestarts <- base::computeRestarts
[18:04:27.245]                           grepl <- base::grepl
[18:04:27.245]                           restarts <- computeRestarts(cond)
[18:04:27.245]                           for (restart in restarts) {
[18:04:27.245]                             name <- restart$name
[18:04:27.245]                             if (is.null(name)) 
[18:04:27.245]                               next
[18:04:27.245]                             if (!grepl(pattern, name)) 
[18:04:27.245]                               next
[18:04:27.245]                             invokeRestart(restart)
[18:04:27.245]                             muffled <- TRUE
[18:04:27.245]                             break
[18:04:27.245]                           }
[18:04:27.245]                         }
[18:04:27.245]                       }
[18:04:27.245]                       invisible(muffled)
[18:04:27.245]                     }
[18:04:27.245]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.245]                   }
[18:04:27.245]                 }
[18:04:27.245]             }
[18:04:27.245]         }))
[18:04:27.245]     }, error = function(ex) {
[18:04:27.245]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:27.245]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.245]                 ...future.rng), started = ...future.startTime, 
[18:04:27.245]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:27.245]             version = "1.8"), class = "FutureResult")
[18:04:27.245]     }, finally = {
[18:04:27.245]         if (!identical(...future.workdir, getwd())) 
[18:04:27.245]             setwd(...future.workdir)
[18:04:27.245]         {
[18:04:27.245]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:27.245]                 ...future.oldOptions$nwarnings <- NULL
[18:04:27.245]             }
[18:04:27.245]             base::options(...future.oldOptions)
[18:04:27.245]             if (.Platform$OS.type == "windows") {
[18:04:27.245]                 old_names <- names(...future.oldEnvVars)
[18:04:27.245]                 envs <- base::Sys.getenv()
[18:04:27.245]                 names <- names(envs)
[18:04:27.245]                 common <- intersect(names, old_names)
[18:04:27.245]                 added <- setdiff(names, old_names)
[18:04:27.245]                 removed <- setdiff(old_names, names)
[18:04:27.245]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:27.245]                   envs[common]]
[18:04:27.245]                 NAMES <- toupper(changed)
[18:04:27.245]                 args <- list()
[18:04:27.245]                 for (kk in seq_along(NAMES)) {
[18:04:27.245]                   name <- changed[[kk]]
[18:04:27.245]                   NAME <- NAMES[[kk]]
[18:04:27.245]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.245]                     next
[18:04:27.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.245]                 }
[18:04:27.245]                 NAMES <- toupper(added)
[18:04:27.245]                 for (kk in seq_along(NAMES)) {
[18:04:27.245]                   name <- added[[kk]]
[18:04:27.245]                   NAME <- NAMES[[kk]]
[18:04:27.245]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.245]                     next
[18:04:27.245]                   args[[name]] <- ""
[18:04:27.245]                 }
[18:04:27.245]                 NAMES <- toupper(removed)
[18:04:27.245]                 for (kk in seq_along(NAMES)) {
[18:04:27.245]                   name <- removed[[kk]]
[18:04:27.245]                   NAME <- NAMES[[kk]]
[18:04:27.245]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.245]                     next
[18:04:27.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.245]                 }
[18:04:27.245]                 if (length(args) > 0) 
[18:04:27.245]                   base::do.call(base::Sys.setenv, args = args)
[18:04:27.245]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:27.245]             }
[18:04:27.245]             else {
[18:04:27.245]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:27.245]             }
[18:04:27.245]             {
[18:04:27.245]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:27.245]                   0L) {
[18:04:27.245]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:27.245]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:27.245]                   base::options(opts)
[18:04:27.245]                 }
[18:04:27.245]                 {
[18:04:27.245]                   {
[18:04:27.245]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:27.245]                     NULL
[18:04:27.245]                   }
[18:04:27.245]                   options(future.plan = NULL)
[18:04:27.245]                   if (is.na(NA_character_)) 
[18:04:27.245]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.245]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:27.245]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:27.245]                     .init = FALSE)
[18:04:27.245]                 }
[18:04:27.245]             }
[18:04:27.245]         }
[18:04:27.245]     })
[18:04:27.245]     if (TRUE) {
[18:04:27.245]         base::sink(type = "output", split = FALSE)
[18:04:27.245]         if (TRUE) {
[18:04:27.245]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:27.245]         }
[18:04:27.245]         else {
[18:04:27.245]             ...future.result["stdout"] <- base::list(NULL)
[18:04:27.245]         }
[18:04:27.245]         base::close(...future.stdout)
[18:04:27.245]         ...future.stdout <- NULL
[18:04:27.245]     }
[18:04:27.245]     ...future.result$conditions <- ...future.conditions
[18:04:27.245]     ...future.result$finished <- base::Sys.time()
[18:04:27.245]     ...future.result
[18:04:27.245] }
[18:04:27.249] assign_globals() ...
[18:04:27.250] List of 2
[18:04:27.250]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[18:04:27.250]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[18:04:27.250]  - attr(*, "where")=List of 2
[18:04:27.250]   ..$ weight:<environment: R_EmptyEnv> 
[18:04:27.250]   ..$ group :<environment: R_EmptyEnv> 
[18:04:27.250]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:27.250]  - attr(*, "resolved")= logi FALSE
[18:04:27.250]  - attr(*, "total_size")= num 896
[18:04:27.250]  - attr(*, "already-done")= logi TRUE
[18:04:27.257] - copied ‘weight’ to environment
[18:04:27.257] - copied ‘group’ to environment
[18:04:27.257] assign_globals() ... done
[18:04:27.258] requestCore(): workers = 2
[18:04:27.261] MulticoreFuture started
[18:04:27.262] - Launch lazy future ... done
[18:04:27.262] run() for ‘MulticoreFuture’ ... done
[18:04:27.262] result() for MulticoreFuture ...
[18:04:27.263] plan(): Setting new future strategy stack:
[18:04:27.264] List of future strategies:
[18:04:27.264] 1. sequential:
[18:04:27.264]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.264]    - tweaked: FALSE
[18:04:27.264]    - call: NULL
[18:04:27.267] plan(): nbrOfWorkers() = 1
[18:04:27.275] plan(): Setting new future strategy stack:
[18:04:27.276] List of future strategies:
[18:04:27.276] 1. multicore:
[18:04:27.276]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:27.276]    - tweaked: FALSE
[18:04:27.276]    - call: plan(strategy)
[18:04:27.293] plan(): nbrOfWorkers() = 2
[18:04:27.297] result() for MulticoreFuture ...
[18:04:27.297] result() for MulticoreFuture ... done
[18:04:27.298] result() for MulticoreFuture ... done
[18:04:27.298] result() for MulticoreFuture ...
[18:04:27.298] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[18:04:27.308] getGlobalsAndPackages() ...
[18:04:27.308] Searching for globals...
[18:04:27.312] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:27.312] Searching for globals ... DONE
[18:04:27.313] Resolving globals: FALSE
[18:04:27.314] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:27.315] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:27.315] - globals: [2] ‘weight’, ‘group’
[18:04:27.315] - packages: [1] ‘stats’
[18:04:27.316] getGlobalsAndPackages() ... DONE
[18:04:27.316] run() for ‘Future’ ...
[18:04:27.317] - state: ‘created’
[18:04:27.317] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:27.324] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:27.325] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:27.325]   - Field: ‘label’
[18:04:27.325]   - Field: ‘local’
[18:04:27.325]   - Field: ‘owner’
[18:04:27.326]   - Field: ‘envir’
[18:04:27.326]   - Field: ‘workers’
[18:04:27.326]   - Field: ‘packages’
[18:04:27.326]   - Field: ‘gc’
[18:04:27.327]   - Field: ‘job’
[18:04:27.327]   - Field: ‘conditions’
[18:04:27.327]   - Field: ‘expr’
[18:04:27.327]   - Field: ‘uuid’
[18:04:27.328]   - Field: ‘seed’
[18:04:27.328]   - Field: ‘version’
[18:04:27.328]   - Field: ‘result’
[18:04:27.328]   - Field: ‘asynchronous’
[18:04:27.329]   - Field: ‘calls’
[18:04:27.329]   - Field: ‘globals’
[18:04:27.329]   - Field: ‘stdout’
[18:04:27.329]   - Field: ‘earlySignal’
[18:04:27.330]   - Field: ‘lazy’
[18:04:27.330]   - Field: ‘state’
[18:04:27.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:27.330] - Launch lazy future ...
[18:04:27.331] Packages needed by the future expression (n = 1): ‘stats’
[18:04:27.331] Packages needed by future strategies (n = 0): <none>
[18:04:27.333] {
[18:04:27.333]     {
[18:04:27.333]         {
[18:04:27.333]             ...future.startTime <- base::Sys.time()
[18:04:27.333]             {
[18:04:27.333]                 {
[18:04:27.333]                   {
[18:04:27.333]                     {
[18:04:27.333]                       {
[18:04:27.333]                         base::local({
[18:04:27.333]                           has_future <- base::requireNamespace("future", 
[18:04:27.333]                             quietly = TRUE)
[18:04:27.333]                           if (has_future) {
[18:04:27.333]                             ns <- base::getNamespace("future")
[18:04:27.333]                             version <- ns[[".package"]][["version"]]
[18:04:27.333]                             if (is.null(version)) 
[18:04:27.333]                               version <- utils::packageVersion("future")
[18:04:27.333]                           }
[18:04:27.333]                           else {
[18:04:27.333]                             version <- NULL
[18:04:27.333]                           }
[18:04:27.333]                           if (!has_future || version < "1.8.0") {
[18:04:27.333]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:27.333]                               "", base::R.version$version.string), 
[18:04:27.333]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:27.333]                                 base::R.version$platform, 8 * 
[18:04:27.333]                                   base::.Machine$sizeof.pointer), 
[18:04:27.333]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:27.333]                                 "release", "version")], collapse = " "), 
[18:04:27.333]                               hostname = base::Sys.info()[["nodename"]])
[18:04:27.333]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:27.333]                               info)
[18:04:27.333]                             info <- base::paste(info, collapse = "; ")
[18:04:27.333]                             if (!has_future) {
[18:04:27.333]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:27.333]                                 info)
[18:04:27.333]                             }
[18:04:27.333]                             else {
[18:04:27.333]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:27.333]                                 info, version)
[18:04:27.333]                             }
[18:04:27.333]                             base::stop(msg)
[18:04:27.333]                           }
[18:04:27.333]                         })
[18:04:27.333]                       }
[18:04:27.333]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:27.333]                       base::options(mc.cores = 1L)
[18:04:27.333]                     }
[18:04:27.333]                     base::local({
[18:04:27.333]                       for (pkg in "stats") {
[18:04:27.333]                         base::loadNamespace(pkg)
[18:04:27.333]                         base::library(pkg, character.only = TRUE)
[18:04:27.333]                       }
[18:04:27.333]                     })
[18:04:27.333]                   }
[18:04:27.333]                   ...future.strategy.old <- future::plan("list")
[18:04:27.333]                   options(future.plan = NULL)
[18:04:27.333]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.333]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:27.333]                 }
[18:04:27.333]                 ...future.workdir <- getwd()
[18:04:27.333]             }
[18:04:27.333]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:27.333]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:27.333]         }
[18:04:27.333]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:27.333]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:27.333]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:27.333]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:27.333]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:27.333]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:27.333]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:27.333]             base::names(...future.oldOptions))
[18:04:27.333]     }
[18:04:27.333]     if (FALSE) {
[18:04:27.333]     }
[18:04:27.333]     else {
[18:04:27.333]         if (TRUE) {
[18:04:27.333]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:27.333]                 open = "w")
[18:04:27.333]         }
[18:04:27.333]         else {
[18:04:27.333]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:27.333]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:27.333]         }
[18:04:27.333]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:27.333]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:27.333]             base::sink(type = "output", split = FALSE)
[18:04:27.333]             base::close(...future.stdout)
[18:04:27.333]         }, add = TRUE)
[18:04:27.333]     }
[18:04:27.333]     ...future.frame <- base::sys.nframe()
[18:04:27.333]     ...future.conditions <- base::list()
[18:04:27.333]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:27.333]     if (FALSE) {
[18:04:27.333]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:27.333]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:27.333]     }
[18:04:27.333]     ...future.result <- base::tryCatch({
[18:04:27.333]         base::withCallingHandlers({
[18:04:27.333]             ...future.value <- base::withVisible(base::local({
[18:04:27.333]                 withCallingHandlers({
[18:04:27.333]                   {
[18:04:27.333]                     lm(weight ~ group - 1)
[18:04:27.333]                   }
[18:04:27.333]                 }, immediateCondition = function(cond) {
[18:04:27.333]                   save_rds <- function (object, pathname, ...) 
[18:04:27.333]                   {
[18:04:27.333]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:27.333]                     if (file_test("-f", pathname_tmp)) {
[18:04:27.333]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.333]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:27.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.333]                         fi_tmp[["mtime"]])
[18:04:27.333]                     }
[18:04:27.333]                     tryCatch({
[18:04:27.333]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:27.333]                     }, error = function(ex) {
[18:04:27.333]                       msg <- conditionMessage(ex)
[18:04:27.333]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.333]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:27.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.333]                         fi_tmp[["mtime"]], msg)
[18:04:27.333]                       ex$message <- msg
[18:04:27.333]                       stop(ex)
[18:04:27.333]                     })
[18:04:27.333]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:27.333]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:27.333]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:27.333]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.333]                       fi <- file.info(pathname)
[18:04:27.333]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:27.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.333]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:27.333]                         fi[["size"]], fi[["mtime"]])
[18:04:27.333]                       stop(msg)
[18:04:27.333]                     }
[18:04:27.333]                     invisible(pathname)
[18:04:27.333]                   }
[18:04:27.333]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:27.333]                     rootPath = tempdir()) 
[18:04:27.333]                   {
[18:04:27.333]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:27.333]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:27.333]                       tmpdir = path, fileext = ".rds")
[18:04:27.333]                     save_rds(obj, file)
[18:04:27.333]                   }
[18:04:27.333]                   saveImmediateCondition(cond, path = "/tmp/RtmpLRNsAG/.future/immediateConditions")
[18:04:27.333]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.333]                   {
[18:04:27.333]                     inherits <- base::inherits
[18:04:27.333]                     invokeRestart <- base::invokeRestart
[18:04:27.333]                     is.null <- base::is.null
[18:04:27.333]                     muffled <- FALSE
[18:04:27.333]                     if (inherits(cond, "message")) {
[18:04:27.333]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:27.333]                       if (muffled) 
[18:04:27.333]                         invokeRestart("muffleMessage")
[18:04:27.333]                     }
[18:04:27.333]                     else if (inherits(cond, "warning")) {
[18:04:27.333]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:27.333]                       if (muffled) 
[18:04:27.333]                         invokeRestart("muffleWarning")
[18:04:27.333]                     }
[18:04:27.333]                     else if (inherits(cond, "condition")) {
[18:04:27.333]                       if (!is.null(pattern)) {
[18:04:27.333]                         computeRestarts <- base::computeRestarts
[18:04:27.333]                         grepl <- base::grepl
[18:04:27.333]                         restarts <- computeRestarts(cond)
[18:04:27.333]                         for (restart in restarts) {
[18:04:27.333]                           name <- restart$name
[18:04:27.333]                           if (is.null(name)) 
[18:04:27.333]                             next
[18:04:27.333]                           if (!grepl(pattern, name)) 
[18:04:27.333]                             next
[18:04:27.333]                           invokeRestart(restart)
[18:04:27.333]                           muffled <- TRUE
[18:04:27.333]                           break
[18:04:27.333]                         }
[18:04:27.333]                       }
[18:04:27.333]                     }
[18:04:27.333]                     invisible(muffled)
[18:04:27.333]                   }
[18:04:27.333]                   muffleCondition(cond)
[18:04:27.333]                 })
[18:04:27.333]             }))
[18:04:27.333]             future::FutureResult(value = ...future.value$value, 
[18:04:27.333]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.333]                   ...future.rng), globalenv = if (FALSE) 
[18:04:27.333]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:27.333]                     ...future.globalenv.names))
[18:04:27.333]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:27.333]         }, condition = base::local({
[18:04:27.333]             c <- base::c
[18:04:27.333]             inherits <- base::inherits
[18:04:27.333]             invokeRestart <- base::invokeRestart
[18:04:27.333]             length <- base::length
[18:04:27.333]             list <- base::list
[18:04:27.333]             seq.int <- base::seq.int
[18:04:27.333]             signalCondition <- base::signalCondition
[18:04:27.333]             sys.calls <- base::sys.calls
[18:04:27.333]             `[[` <- base::`[[`
[18:04:27.333]             `+` <- base::`+`
[18:04:27.333]             `<<-` <- base::`<<-`
[18:04:27.333]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:27.333]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:27.333]                   3L)]
[18:04:27.333]             }
[18:04:27.333]             function(cond) {
[18:04:27.333]                 is_error <- inherits(cond, "error")
[18:04:27.333]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:27.333]                   NULL)
[18:04:27.333]                 if (is_error) {
[18:04:27.333]                   sessionInformation <- function() {
[18:04:27.333]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:27.333]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:27.333]                       search = base::search(), system = base::Sys.info())
[18:04:27.333]                   }
[18:04:27.333]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.333]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:27.333]                     cond$call), session = sessionInformation(), 
[18:04:27.333]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:27.333]                   signalCondition(cond)
[18:04:27.333]                 }
[18:04:27.333]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:27.333]                 "immediateCondition"))) {
[18:04:27.333]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:27.333]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.333]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:27.333]                   if (TRUE && !signal) {
[18:04:27.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.333]                     {
[18:04:27.333]                       inherits <- base::inherits
[18:04:27.333]                       invokeRestart <- base::invokeRestart
[18:04:27.333]                       is.null <- base::is.null
[18:04:27.333]                       muffled <- FALSE
[18:04:27.333]                       if (inherits(cond, "message")) {
[18:04:27.333]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.333]                         if (muffled) 
[18:04:27.333]                           invokeRestart("muffleMessage")
[18:04:27.333]                       }
[18:04:27.333]                       else if (inherits(cond, "warning")) {
[18:04:27.333]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.333]                         if (muffled) 
[18:04:27.333]                           invokeRestart("muffleWarning")
[18:04:27.333]                       }
[18:04:27.333]                       else if (inherits(cond, "condition")) {
[18:04:27.333]                         if (!is.null(pattern)) {
[18:04:27.333]                           computeRestarts <- base::computeRestarts
[18:04:27.333]                           grepl <- base::grepl
[18:04:27.333]                           restarts <- computeRestarts(cond)
[18:04:27.333]                           for (restart in restarts) {
[18:04:27.333]                             name <- restart$name
[18:04:27.333]                             if (is.null(name)) 
[18:04:27.333]                               next
[18:04:27.333]                             if (!grepl(pattern, name)) 
[18:04:27.333]                               next
[18:04:27.333]                             invokeRestart(restart)
[18:04:27.333]                             muffled <- TRUE
[18:04:27.333]                             break
[18:04:27.333]                           }
[18:04:27.333]                         }
[18:04:27.333]                       }
[18:04:27.333]                       invisible(muffled)
[18:04:27.333]                     }
[18:04:27.333]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.333]                   }
[18:04:27.333]                 }
[18:04:27.333]                 else {
[18:04:27.333]                   if (TRUE) {
[18:04:27.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.333]                     {
[18:04:27.333]                       inherits <- base::inherits
[18:04:27.333]                       invokeRestart <- base::invokeRestart
[18:04:27.333]                       is.null <- base::is.null
[18:04:27.333]                       muffled <- FALSE
[18:04:27.333]                       if (inherits(cond, "message")) {
[18:04:27.333]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.333]                         if (muffled) 
[18:04:27.333]                           invokeRestart("muffleMessage")
[18:04:27.333]                       }
[18:04:27.333]                       else if (inherits(cond, "warning")) {
[18:04:27.333]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.333]                         if (muffled) 
[18:04:27.333]                           invokeRestart("muffleWarning")
[18:04:27.333]                       }
[18:04:27.333]                       else if (inherits(cond, "condition")) {
[18:04:27.333]                         if (!is.null(pattern)) {
[18:04:27.333]                           computeRestarts <- base::computeRestarts
[18:04:27.333]                           grepl <- base::grepl
[18:04:27.333]                           restarts <- computeRestarts(cond)
[18:04:27.333]                           for (restart in restarts) {
[18:04:27.333]                             name <- restart$name
[18:04:27.333]                             if (is.null(name)) 
[18:04:27.333]                               next
[18:04:27.333]                             if (!grepl(pattern, name)) 
[18:04:27.333]                               next
[18:04:27.333]                             invokeRestart(restart)
[18:04:27.333]                             muffled <- TRUE
[18:04:27.333]                             break
[18:04:27.333]                           }
[18:04:27.333]                         }
[18:04:27.333]                       }
[18:04:27.333]                       invisible(muffled)
[18:04:27.333]                     }
[18:04:27.333]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.333]                   }
[18:04:27.333]                 }
[18:04:27.333]             }
[18:04:27.333]         }))
[18:04:27.333]     }, error = function(ex) {
[18:04:27.333]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:27.333]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.333]                 ...future.rng), started = ...future.startTime, 
[18:04:27.333]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:27.333]             version = "1.8"), class = "FutureResult")
[18:04:27.333]     }, finally = {
[18:04:27.333]         if (!identical(...future.workdir, getwd())) 
[18:04:27.333]             setwd(...future.workdir)
[18:04:27.333]         {
[18:04:27.333]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:27.333]                 ...future.oldOptions$nwarnings <- NULL
[18:04:27.333]             }
[18:04:27.333]             base::options(...future.oldOptions)
[18:04:27.333]             if (.Platform$OS.type == "windows") {
[18:04:27.333]                 old_names <- names(...future.oldEnvVars)
[18:04:27.333]                 envs <- base::Sys.getenv()
[18:04:27.333]                 names <- names(envs)
[18:04:27.333]                 common <- intersect(names, old_names)
[18:04:27.333]                 added <- setdiff(names, old_names)
[18:04:27.333]                 removed <- setdiff(old_names, names)
[18:04:27.333]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:27.333]                   envs[common]]
[18:04:27.333]                 NAMES <- toupper(changed)
[18:04:27.333]                 args <- list()
[18:04:27.333]                 for (kk in seq_along(NAMES)) {
[18:04:27.333]                   name <- changed[[kk]]
[18:04:27.333]                   NAME <- NAMES[[kk]]
[18:04:27.333]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.333]                     next
[18:04:27.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.333]                 }
[18:04:27.333]                 NAMES <- toupper(added)
[18:04:27.333]                 for (kk in seq_along(NAMES)) {
[18:04:27.333]                   name <- added[[kk]]
[18:04:27.333]                   NAME <- NAMES[[kk]]
[18:04:27.333]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.333]                     next
[18:04:27.333]                   args[[name]] <- ""
[18:04:27.333]                 }
[18:04:27.333]                 NAMES <- toupper(removed)
[18:04:27.333]                 for (kk in seq_along(NAMES)) {
[18:04:27.333]                   name <- removed[[kk]]
[18:04:27.333]                   NAME <- NAMES[[kk]]
[18:04:27.333]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.333]                     next
[18:04:27.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.333]                 }
[18:04:27.333]                 if (length(args) > 0) 
[18:04:27.333]                   base::do.call(base::Sys.setenv, args = args)
[18:04:27.333]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:27.333]             }
[18:04:27.333]             else {
[18:04:27.333]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:27.333]             }
[18:04:27.333]             {
[18:04:27.333]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:27.333]                   0L) {
[18:04:27.333]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:27.333]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:27.333]                   base::options(opts)
[18:04:27.333]                 }
[18:04:27.333]                 {
[18:04:27.333]                   {
[18:04:27.333]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:27.333]                     NULL
[18:04:27.333]                   }
[18:04:27.333]                   options(future.plan = NULL)
[18:04:27.333]                   if (is.na(NA_character_)) 
[18:04:27.333]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.333]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:27.333]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:27.333]                     .init = FALSE)
[18:04:27.333]                 }
[18:04:27.333]             }
[18:04:27.333]         }
[18:04:27.333]     })
[18:04:27.333]     if (TRUE) {
[18:04:27.333]         base::sink(type = "output", split = FALSE)
[18:04:27.333]         if (TRUE) {
[18:04:27.333]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:27.333]         }
[18:04:27.333]         else {
[18:04:27.333]             ...future.result["stdout"] <- base::list(NULL)
[18:04:27.333]         }
[18:04:27.333]         base::close(...future.stdout)
[18:04:27.333]         ...future.stdout <- NULL
[18:04:27.333]     }
[18:04:27.333]     ...future.result$conditions <- ...future.conditions
[18:04:27.333]     ...future.result$finished <- base::Sys.time()
[18:04:27.333]     ...future.result
[18:04:27.333] }
[18:04:27.337] assign_globals() ...
[18:04:27.338] List of 2
[18:04:27.338]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[18:04:27.338]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[18:04:27.338]  - attr(*, "where")=List of 2
[18:04:27.338]   ..$ weight:<environment: R_EmptyEnv> 
[18:04:27.338]   ..$ group :<environment: R_EmptyEnv> 
[18:04:27.338]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:27.338]  - attr(*, "resolved")= logi FALSE
[18:04:27.338]  - attr(*, "total_size")= num 896
[18:04:27.338]  - attr(*, "already-done")= logi TRUE
[18:04:27.350] - copied ‘weight’ to environment
[18:04:27.351] - copied ‘group’ to environment
[18:04:27.351] assign_globals() ... done
[18:04:27.351] requestCore(): workers = 2
[18:04:27.355] MulticoreFuture started
[18:04:27.355] - Launch lazy future ... done
[18:04:27.356] run() for ‘MulticoreFuture’ ... done
[18:04:27.357] result() for MulticoreFuture ...
[18:04:27.357] plan(): Setting new future strategy stack:
[18:04:27.358] List of future strategies:
[18:04:27.358] 1. sequential:
[18:04:27.358]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.358]    - tweaked: FALSE
[18:04:27.358]    - call: NULL
[18:04:27.360] plan(): nbrOfWorkers() = 1
[18:04:27.367] plan(): Setting new future strategy stack:
[18:04:27.368] List of future strategies:
[18:04:27.368] 1. multicore:
[18:04:27.368]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:27.368]    - tweaked: FALSE
[18:04:27.368]    - call: plan(strategy)
[18:04:27.381] plan(): nbrOfWorkers() = 2
[18:04:27.387] result() for MulticoreFuture ...
[18:04:27.387] result() for MulticoreFuture ... done
[18:04:27.388] result() for MulticoreFuture ... done
[18:04:27.388] result() for MulticoreFuture ...
[18:04:27.388] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[18:04:27.394] getGlobalsAndPackages() ...
[18:04:27.395] Searching for globals...
[18:04:27.399] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:27.400] Searching for globals ... DONE
[18:04:27.400] Resolving globals: FALSE
[18:04:27.401] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:27.402] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:27.403] - globals: [2] ‘weight’, ‘group’
[18:04:27.403] - packages: [1] ‘stats’
[18:04:27.403] getGlobalsAndPackages() ... DONE
[18:04:27.404] run() for ‘Future’ ...
[18:04:27.404] - state: ‘created’
[18:04:27.405] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:27.414] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:27.415] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:27.415]   - Field: ‘label’
[18:04:27.415]   - Field: ‘local’
[18:04:27.416]   - Field: ‘owner’
[18:04:27.416]   - Field: ‘envir’
[18:04:27.416]   - Field: ‘workers’
[18:04:27.417]   - Field: ‘packages’
[18:04:27.417]   - Field: ‘gc’
[18:04:27.417]   - Field: ‘job’
[18:04:27.417]   - Field: ‘conditions’
[18:04:27.418]   - Field: ‘expr’
[18:04:27.418]   - Field: ‘uuid’
[18:04:27.418]   - Field: ‘seed’
[18:04:27.418]   - Field: ‘version’
[18:04:27.418]   - Field: ‘result’
[18:04:27.419]   - Field: ‘asynchronous’
[18:04:27.419]   - Field: ‘calls’
[18:04:27.419]   - Field: ‘globals’
[18:04:27.419]   - Field: ‘stdout’
[18:04:27.420]   - Field: ‘earlySignal’
[18:04:27.420]   - Field: ‘lazy’
[18:04:27.420]   - Field: ‘state’
[18:04:27.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:27.421] - Launch lazy future ...
[18:04:27.421] Packages needed by the future expression (n = 1): ‘stats’
[18:04:27.422] Packages needed by future strategies (n = 0): <none>
[18:04:27.423] {
[18:04:27.423]     {
[18:04:27.423]         {
[18:04:27.423]             ...future.startTime <- base::Sys.time()
[18:04:27.423]             {
[18:04:27.423]                 {
[18:04:27.423]                   {
[18:04:27.423]                     {
[18:04:27.423]                       {
[18:04:27.423]                         base::local({
[18:04:27.423]                           has_future <- base::requireNamespace("future", 
[18:04:27.423]                             quietly = TRUE)
[18:04:27.423]                           if (has_future) {
[18:04:27.423]                             ns <- base::getNamespace("future")
[18:04:27.423]                             version <- ns[[".package"]][["version"]]
[18:04:27.423]                             if (is.null(version)) 
[18:04:27.423]                               version <- utils::packageVersion("future")
[18:04:27.423]                           }
[18:04:27.423]                           else {
[18:04:27.423]                             version <- NULL
[18:04:27.423]                           }
[18:04:27.423]                           if (!has_future || version < "1.8.0") {
[18:04:27.423]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:27.423]                               "", base::R.version$version.string), 
[18:04:27.423]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:27.423]                                 base::R.version$platform, 8 * 
[18:04:27.423]                                   base::.Machine$sizeof.pointer), 
[18:04:27.423]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:27.423]                                 "release", "version")], collapse = " "), 
[18:04:27.423]                               hostname = base::Sys.info()[["nodename"]])
[18:04:27.423]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:27.423]                               info)
[18:04:27.423]                             info <- base::paste(info, collapse = "; ")
[18:04:27.423]                             if (!has_future) {
[18:04:27.423]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:27.423]                                 info)
[18:04:27.423]                             }
[18:04:27.423]                             else {
[18:04:27.423]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:27.423]                                 info, version)
[18:04:27.423]                             }
[18:04:27.423]                             base::stop(msg)
[18:04:27.423]                           }
[18:04:27.423]                         })
[18:04:27.423]                       }
[18:04:27.423]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:27.423]                       base::options(mc.cores = 1L)
[18:04:27.423]                     }
[18:04:27.423]                     base::local({
[18:04:27.423]                       for (pkg in "stats") {
[18:04:27.423]                         base::loadNamespace(pkg)
[18:04:27.423]                         base::library(pkg, character.only = TRUE)
[18:04:27.423]                       }
[18:04:27.423]                     })
[18:04:27.423]                   }
[18:04:27.423]                   ...future.strategy.old <- future::plan("list")
[18:04:27.423]                   options(future.plan = NULL)
[18:04:27.423]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.423]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:27.423]                 }
[18:04:27.423]                 ...future.workdir <- getwd()
[18:04:27.423]             }
[18:04:27.423]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:27.423]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:27.423]         }
[18:04:27.423]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:27.423]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:27.423]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:27.423]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:27.423]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:27.423]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:27.423]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:27.423]             base::names(...future.oldOptions))
[18:04:27.423]     }
[18:04:27.423]     if (FALSE) {
[18:04:27.423]     }
[18:04:27.423]     else {
[18:04:27.423]         if (TRUE) {
[18:04:27.423]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:27.423]                 open = "w")
[18:04:27.423]         }
[18:04:27.423]         else {
[18:04:27.423]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:27.423]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:27.423]         }
[18:04:27.423]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:27.423]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:27.423]             base::sink(type = "output", split = FALSE)
[18:04:27.423]             base::close(...future.stdout)
[18:04:27.423]         }, add = TRUE)
[18:04:27.423]     }
[18:04:27.423]     ...future.frame <- base::sys.nframe()
[18:04:27.423]     ...future.conditions <- base::list()
[18:04:27.423]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:27.423]     if (FALSE) {
[18:04:27.423]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:27.423]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:27.423]     }
[18:04:27.423]     ...future.result <- base::tryCatch({
[18:04:27.423]         base::withCallingHandlers({
[18:04:27.423]             ...future.value <- base::withVisible(base::local({
[18:04:27.423]                 withCallingHandlers({
[18:04:27.423]                   {
[18:04:27.423]                     lm(weight ~ group - 1)
[18:04:27.423]                   }
[18:04:27.423]                 }, immediateCondition = function(cond) {
[18:04:27.423]                   save_rds <- function (object, pathname, ...) 
[18:04:27.423]                   {
[18:04:27.423]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:27.423]                     if (file_test("-f", pathname_tmp)) {
[18:04:27.423]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.423]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:27.423]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.423]                         fi_tmp[["mtime"]])
[18:04:27.423]                     }
[18:04:27.423]                     tryCatch({
[18:04:27.423]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:27.423]                     }, error = function(ex) {
[18:04:27.423]                       msg <- conditionMessage(ex)
[18:04:27.423]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.423]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:27.423]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.423]                         fi_tmp[["mtime"]], msg)
[18:04:27.423]                       ex$message <- msg
[18:04:27.423]                       stop(ex)
[18:04:27.423]                     })
[18:04:27.423]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:27.423]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:27.423]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:27.423]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.423]                       fi <- file.info(pathname)
[18:04:27.423]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:27.423]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.423]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:27.423]                         fi[["size"]], fi[["mtime"]])
[18:04:27.423]                       stop(msg)
[18:04:27.423]                     }
[18:04:27.423]                     invisible(pathname)
[18:04:27.423]                   }
[18:04:27.423]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:27.423]                     rootPath = tempdir()) 
[18:04:27.423]                   {
[18:04:27.423]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:27.423]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:27.423]                       tmpdir = path, fileext = ".rds")
[18:04:27.423]                     save_rds(obj, file)
[18:04:27.423]                   }
[18:04:27.423]                   saveImmediateCondition(cond, path = "/tmp/RtmpLRNsAG/.future/immediateConditions")
[18:04:27.423]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.423]                   {
[18:04:27.423]                     inherits <- base::inherits
[18:04:27.423]                     invokeRestart <- base::invokeRestart
[18:04:27.423]                     is.null <- base::is.null
[18:04:27.423]                     muffled <- FALSE
[18:04:27.423]                     if (inherits(cond, "message")) {
[18:04:27.423]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:27.423]                       if (muffled) 
[18:04:27.423]                         invokeRestart("muffleMessage")
[18:04:27.423]                     }
[18:04:27.423]                     else if (inherits(cond, "warning")) {
[18:04:27.423]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:27.423]                       if (muffled) 
[18:04:27.423]                         invokeRestart("muffleWarning")
[18:04:27.423]                     }
[18:04:27.423]                     else if (inherits(cond, "condition")) {
[18:04:27.423]                       if (!is.null(pattern)) {
[18:04:27.423]                         computeRestarts <- base::computeRestarts
[18:04:27.423]                         grepl <- base::grepl
[18:04:27.423]                         restarts <- computeRestarts(cond)
[18:04:27.423]                         for (restart in restarts) {
[18:04:27.423]                           name <- restart$name
[18:04:27.423]                           if (is.null(name)) 
[18:04:27.423]                             next
[18:04:27.423]                           if (!grepl(pattern, name)) 
[18:04:27.423]                             next
[18:04:27.423]                           invokeRestart(restart)
[18:04:27.423]                           muffled <- TRUE
[18:04:27.423]                           break
[18:04:27.423]                         }
[18:04:27.423]                       }
[18:04:27.423]                     }
[18:04:27.423]                     invisible(muffled)
[18:04:27.423]                   }
[18:04:27.423]                   muffleCondition(cond)
[18:04:27.423]                 })
[18:04:27.423]             }))
[18:04:27.423]             future::FutureResult(value = ...future.value$value, 
[18:04:27.423]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.423]                   ...future.rng), globalenv = if (FALSE) 
[18:04:27.423]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:27.423]                     ...future.globalenv.names))
[18:04:27.423]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:27.423]         }, condition = base::local({
[18:04:27.423]             c <- base::c
[18:04:27.423]             inherits <- base::inherits
[18:04:27.423]             invokeRestart <- base::invokeRestart
[18:04:27.423]             length <- base::length
[18:04:27.423]             list <- base::list
[18:04:27.423]             seq.int <- base::seq.int
[18:04:27.423]             signalCondition <- base::signalCondition
[18:04:27.423]             sys.calls <- base::sys.calls
[18:04:27.423]             `[[` <- base::`[[`
[18:04:27.423]             `+` <- base::`+`
[18:04:27.423]             `<<-` <- base::`<<-`
[18:04:27.423]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:27.423]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:27.423]                   3L)]
[18:04:27.423]             }
[18:04:27.423]             function(cond) {
[18:04:27.423]                 is_error <- inherits(cond, "error")
[18:04:27.423]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:27.423]                   NULL)
[18:04:27.423]                 if (is_error) {
[18:04:27.423]                   sessionInformation <- function() {
[18:04:27.423]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:27.423]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:27.423]                       search = base::search(), system = base::Sys.info())
[18:04:27.423]                   }
[18:04:27.423]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.423]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:27.423]                     cond$call), session = sessionInformation(), 
[18:04:27.423]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:27.423]                   signalCondition(cond)
[18:04:27.423]                 }
[18:04:27.423]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:27.423]                 "immediateCondition"))) {
[18:04:27.423]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:27.423]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.423]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:27.423]                   if (TRUE && !signal) {
[18:04:27.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.423]                     {
[18:04:27.423]                       inherits <- base::inherits
[18:04:27.423]                       invokeRestart <- base::invokeRestart
[18:04:27.423]                       is.null <- base::is.null
[18:04:27.423]                       muffled <- FALSE
[18:04:27.423]                       if (inherits(cond, "message")) {
[18:04:27.423]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.423]                         if (muffled) 
[18:04:27.423]                           invokeRestart("muffleMessage")
[18:04:27.423]                       }
[18:04:27.423]                       else if (inherits(cond, "warning")) {
[18:04:27.423]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.423]                         if (muffled) 
[18:04:27.423]                           invokeRestart("muffleWarning")
[18:04:27.423]                       }
[18:04:27.423]                       else if (inherits(cond, "condition")) {
[18:04:27.423]                         if (!is.null(pattern)) {
[18:04:27.423]                           computeRestarts <- base::computeRestarts
[18:04:27.423]                           grepl <- base::grepl
[18:04:27.423]                           restarts <- computeRestarts(cond)
[18:04:27.423]                           for (restart in restarts) {
[18:04:27.423]                             name <- restart$name
[18:04:27.423]                             if (is.null(name)) 
[18:04:27.423]                               next
[18:04:27.423]                             if (!grepl(pattern, name)) 
[18:04:27.423]                               next
[18:04:27.423]                             invokeRestart(restart)
[18:04:27.423]                             muffled <- TRUE
[18:04:27.423]                             break
[18:04:27.423]                           }
[18:04:27.423]                         }
[18:04:27.423]                       }
[18:04:27.423]                       invisible(muffled)
[18:04:27.423]                     }
[18:04:27.423]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.423]                   }
[18:04:27.423]                 }
[18:04:27.423]                 else {
[18:04:27.423]                   if (TRUE) {
[18:04:27.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.423]                     {
[18:04:27.423]                       inherits <- base::inherits
[18:04:27.423]                       invokeRestart <- base::invokeRestart
[18:04:27.423]                       is.null <- base::is.null
[18:04:27.423]                       muffled <- FALSE
[18:04:27.423]                       if (inherits(cond, "message")) {
[18:04:27.423]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.423]                         if (muffled) 
[18:04:27.423]                           invokeRestart("muffleMessage")
[18:04:27.423]                       }
[18:04:27.423]                       else if (inherits(cond, "warning")) {
[18:04:27.423]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.423]                         if (muffled) 
[18:04:27.423]                           invokeRestart("muffleWarning")
[18:04:27.423]                       }
[18:04:27.423]                       else if (inherits(cond, "condition")) {
[18:04:27.423]                         if (!is.null(pattern)) {
[18:04:27.423]                           computeRestarts <- base::computeRestarts
[18:04:27.423]                           grepl <- base::grepl
[18:04:27.423]                           restarts <- computeRestarts(cond)
[18:04:27.423]                           for (restart in restarts) {
[18:04:27.423]                             name <- restart$name
[18:04:27.423]                             if (is.null(name)) 
[18:04:27.423]                               next
[18:04:27.423]                             if (!grepl(pattern, name)) 
[18:04:27.423]                               next
[18:04:27.423]                             invokeRestart(restart)
[18:04:27.423]                             muffled <- TRUE
[18:04:27.423]                             break
[18:04:27.423]                           }
[18:04:27.423]                         }
[18:04:27.423]                       }
[18:04:27.423]                       invisible(muffled)
[18:04:27.423]                     }
[18:04:27.423]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.423]                   }
[18:04:27.423]                 }
[18:04:27.423]             }
[18:04:27.423]         }))
[18:04:27.423]     }, error = function(ex) {
[18:04:27.423]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:27.423]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.423]                 ...future.rng), started = ...future.startTime, 
[18:04:27.423]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:27.423]             version = "1.8"), class = "FutureResult")
[18:04:27.423]     }, finally = {
[18:04:27.423]         if (!identical(...future.workdir, getwd())) 
[18:04:27.423]             setwd(...future.workdir)
[18:04:27.423]         {
[18:04:27.423]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:27.423]                 ...future.oldOptions$nwarnings <- NULL
[18:04:27.423]             }
[18:04:27.423]             base::options(...future.oldOptions)
[18:04:27.423]             if (.Platform$OS.type == "windows") {
[18:04:27.423]                 old_names <- names(...future.oldEnvVars)
[18:04:27.423]                 envs <- base::Sys.getenv()
[18:04:27.423]                 names <- names(envs)
[18:04:27.423]                 common <- intersect(names, old_names)
[18:04:27.423]                 added <- setdiff(names, old_names)
[18:04:27.423]                 removed <- setdiff(old_names, names)
[18:04:27.423]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:27.423]                   envs[common]]
[18:04:27.423]                 NAMES <- toupper(changed)
[18:04:27.423]                 args <- list()
[18:04:27.423]                 for (kk in seq_along(NAMES)) {
[18:04:27.423]                   name <- changed[[kk]]
[18:04:27.423]                   NAME <- NAMES[[kk]]
[18:04:27.423]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.423]                     next
[18:04:27.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.423]                 }
[18:04:27.423]                 NAMES <- toupper(added)
[18:04:27.423]                 for (kk in seq_along(NAMES)) {
[18:04:27.423]                   name <- added[[kk]]
[18:04:27.423]                   NAME <- NAMES[[kk]]
[18:04:27.423]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.423]                     next
[18:04:27.423]                   args[[name]] <- ""
[18:04:27.423]                 }
[18:04:27.423]                 NAMES <- toupper(removed)
[18:04:27.423]                 for (kk in seq_along(NAMES)) {
[18:04:27.423]                   name <- removed[[kk]]
[18:04:27.423]                   NAME <- NAMES[[kk]]
[18:04:27.423]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.423]                     next
[18:04:27.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.423]                 }
[18:04:27.423]                 if (length(args) > 0) 
[18:04:27.423]                   base::do.call(base::Sys.setenv, args = args)
[18:04:27.423]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:27.423]             }
[18:04:27.423]             else {
[18:04:27.423]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:27.423]             }
[18:04:27.423]             {
[18:04:27.423]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:27.423]                   0L) {
[18:04:27.423]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:27.423]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:27.423]                   base::options(opts)
[18:04:27.423]                 }
[18:04:27.423]                 {
[18:04:27.423]                   {
[18:04:27.423]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:27.423]                     NULL
[18:04:27.423]                   }
[18:04:27.423]                   options(future.plan = NULL)
[18:04:27.423]                   if (is.na(NA_character_)) 
[18:04:27.423]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.423]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:27.423]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:27.423]                     .init = FALSE)
[18:04:27.423]                 }
[18:04:27.423]             }
[18:04:27.423]         }
[18:04:27.423]     })
[18:04:27.423]     if (TRUE) {
[18:04:27.423]         base::sink(type = "output", split = FALSE)
[18:04:27.423]         if (TRUE) {
[18:04:27.423]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:27.423]         }
[18:04:27.423]         else {
[18:04:27.423]             ...future.result["stdout"] <- base::list(NULL)
[18:04:27.423]         }
[18:04:27.423]         base::close(...future.stdout)
[18:04:27.423]         ...future.stdout <- NULL
[18:04:27.423]     }
[18:04:27.423]     ...future.result$conditions <- ...future.conditions
[18:04:27.423]     ...future.result$finished <- base::Sys.time()
[18:04:27.423]     ...future.result
[18:04:27.423] }
[18:04:27.427] assign_globals() ...
[18:04:27.427] List of 2
[18:04:27.427]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[18:04:27.427]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[18:04:27.427]  - attr(*, "where")=List of 2
[18:04:27.427]   ..$ weight:<environment: R_EmptyEnv> 
[18:04:27.427]   ..$ group :<environment: R_EmptyEnv> 
[18:04:27.427]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:27.427]  - attr(*, "resolved")= logi FALSE
[18:04:27.427]  - attr(*, "total_size")= num 896
[18:04:27.427]  - attr(*, "already-done")= logi TRUE
[18:04:27.435] - copied ‘weight’ to environment
[18:04:27.435] - copied ‘group’ to environment
[18:04:27.435] assign_globals() ... done
[18:04:27.435] requestCore(): workers = 2
[18:04:27.439] MulticoreFuture started
[18:04:27.439] - Launch lazy future ... done
[18:04:27.440] run() for ‘MulticoreFuture’ ... done
[18:04:27.441] result() for MulticoreFuture ...
[18:04:27.441] plan(): Setting new future strategy stack:
[18:04:27.442] List of future strategies:
[18:04:27.442] 1. sequential:
[18:04:27.442]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.442]    - tweaked: FALSE
[18:04:27.442]    - call: NULL
[18:04:27.444] plan(): nbrOfWorkers() = 1
[18:04:27.451] plan(): Setting new future strategy stack:
[18:04:27.452] List of future strategies:
[18:04:27.452] 1. multicore:
[18:04:27.452]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:27.452]    - tweaked: FALSE
[18:04:27.452]    - call: plan(strategy)
[18:04:27.460] plan(): nbrOfWorkers() = 2
[18:04:27.464] result() for MulticoreFuture ...
[18:04:27.465] result() for MulticoreFuture ... done
[18:04:27.465] result() for MulticoreFuture ... done
[18:04:27.465] result() for MulticoreFuture ...
[18:04:27.466] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[18:04:27.470] getGlobalsAndPackages() ...
[18:04:27.471] Searching for globals...
[18:04:27.475] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:27.475] Searching for globals ... DONE
[18:04:27.475] Resolving globals: FALSE
[18:04:27.476] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:27.477] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:27.478] - globals: [2] ‘weight’, ‘group’
[18:04:27.478] - packages: [1] ‘stats’
[18:04:27.478] getGlobalsAndPackages() ... DONE
[18:04:27.479] run() for ‘Future’ ...
[18:04:27.479] - state: ‘created’
[18:04:27.480] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:27.487] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:27.487] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:27.487]   - Field: ‘label’
[18:04:27.488]   - Field: ‘local’
[18:04:27.488]   - Field: ‘owner’
[18:04:27.488]   - Field: ‘envir’
[18:04:27.488]   - Field: ‘workers’
[18:04:27.488]   - Field: ‘packages’
[18:04:27.489]   - Field: ‘gc’
[18:04:27.489]   - Field: ‘job’
[18:04:27.489]   - Field: ‘conditions’
[18:04:27.489]   - Field: ‘expr’
[18:04:27.490]   - Field: ‘uuid’
[18:04:27.490]   - Field: ‘seed’
[18:04:27.490]   - Field: ‘version’
[18:04:27.490]   - Field: ‘result’
[18:04:27.491]   - Field: ‘asynchronous’
[18:04:27.491]   - Field: ‘calls’
[18:04:27.491]   - Field: ‘globals’
[18:04:27.491]   - Field: ‘stdout’
[18:04:27.492]   - Field: ‘earlySignal’
[18:04:27.492]   - Field: ‘lazy’
[18:04:27.492]   - Field: ‘state’
[18:04:27.492] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:27.492] - Launch lazy future ...
[18:04:27.493] Packages needed by the future expression (n = 1): ‘stats’
[18:04:27.493] Packages needed by future strategies (n = 0): <none>
[18:04:27.495] {
[18:04:27.495]     {
[18:04:27.495]         {
[18:04:27.495]             ...future.startTime <- base::Sys.time()
[18:04:27.495]             {
[18:04:27.495]                 {
[18:04:27.495]                   {
[18:04:27.495]                     {
[18:04:27.495]                       {
[18:04:27.495]                         base::local({
[18:04:27.495]                           has_future <- base::requireNamespace("future", 
[18:04:27.495]                             quietly = TRUE)
[18:04:27.495]                           if (has_future) {
[18:04:27.495]                             ns <- base::getNamespace("future")
[18:04:27.495]                             version <- ns[[".package"]][["version"]]
[18:04:27.495]                             if (is.null(version)) 
[18:04:27.495]                               version <- utils::packageVersion("future")
[18:04:27.495]                           }
[18:04:27.495]                           else {
[18:04:27.495]                             version <- NULL
[18:04:27.495]                           }
[18:04:27.495]                           if (!has_future || version < "1.8.0") {
[18:04:27.495]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:27.495]                               "", base::R.version$version.string), 
[18:04:27.495]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:27.495]                                 base::R.version$platform, 8 * 
[18:04:27.495]                                   base::.Machine$sizeof.pointer), 
[18:04:27.495]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:27.495]                                 "release", "version")], collapse = " "), 
[18:04:27.495]                               hostname = base::Sys.info()[["nodename"]])
[18:04:27.495]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:27.495]                               info)
[18:04:27.495]                             info <- base::paste(info, collapse = "; ")
[18:04:27.495]                             if (!has_future) {
[18:04:27.495]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:27.495]                                 info)
[18:04:27.495]                             }
[18:04:27.495]                             else {
[18:04:27.495]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:27.495]                                 info, version)
[18:04:27.495]                             }
[18:04:27.495]                             base::stop(msg)
[18:04:27.495]                           }
[18:04:27.495]                         })
[18:04:27.495]                       }
[18:04:27.495]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:27.495]                       base::options(mc.cores = 1L)
[18:04:27.495]                     }
[18:04:27.495]                     base::local({
[18:04:27.495]                       for (pkg in "stats") {
[18:04:27.495]                         base::loadNamespace(pkg)
[18:04:27.495]                         base::library(pkg, character.only = TRUE)
[18:04:27.495]                       }
[18:04:27.495]                     })
[18:04:27.495]                   }
[18:04:27.495]                   ...future.strategy.old <- future::plan("list")
[18:04:27.495]                   options(future.plan = NULL)
[18:04:27.495]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.495]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:27.495]                 }
[18:04:27.495]                 ...future.workdir <- getwd()
[18:04:27.495]             }
[18:04:27.495]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:27.495]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:27.495]         }
[18:04:27.495]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:27.495]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:27.495]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:27.495]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:27.495]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:27.495]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:27.495]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:27.495]             base::names(...future.oldOptions))
[18:04:27.495]     }
[18:04:27.495]     if (FALSE) {
[18:04:27.495]     }
[18:04:27.495]     else {
[18:04:27.495]         if (TRUE) {
[18:04:27.495]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:27.495]                 open = "w")
[18:04:27.495]         }
[18:04:27.495]         else {
[18:04:27.495]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:27.495]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:27.495]         }
[18:04:27.495]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:27.495]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:27.495]             base::sink(type = "output", split = FALSE)
[18:04:27.495]             base::close(...future.stdout)
[18:04:27.495]         }, add = TRUE)
[18:04:27.495]     }
[18:04:27.495]     ...future.frame <- base::sys.nframe()
[18:04:27.495]     ...future.conditions <- base::list()
[18:04:27.495]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:27.495]     if (FALSE) {
[18:04:27.495]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:27.495]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:27.495]     }
[18:04:27.495]     ...future.result <- base::tryCatch({
[18:04:27.495]         base::withCallingHandlers({
[18:04:27.495]             ...future.value <- base::withVisible(base::local({
[18:04:27.495]                 withCallingHandlers({
[18:04:27.495]                   {
[18:04:27.495]                     lm(weight ~ group - 1)
[18:04:27.495]                   }
[18:04:27.495]                 }, immediateCondition = function(cond) {
[18:04:27.495]                   save_rds <- function (object, pathname, ...) 
[18:04:27.495]                   {
[18:04:27.495]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:27.495]                     if (file_test("-f", pathname_tmp)) {
[18:04:27.495]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.495]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:27.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.495]                         fi_tmp[["mtime"]])
[18:04:27.495]                     }
[18:04:27.495]                     tryCatch({
[18:04:27.495]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:27.495]                     }, error = function(ex) {
[18:04:27.495]                       msg <- conditionMessage(ex)
[18:04:27.495]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.495]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:27.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.495]                         fi_tmp[["mtime"]], msg)
[18:04:27.495]                       ex$message <- msg
[18:04:27.495]                       stop(ex)
[18:04:27.495]                     })
[18:04:27.495]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:27.495]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:27.495]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:27.495]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.495]                       fi <- file.info(pathname)
[18:04:27.495]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:27.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.495]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:27.495]                         fi[["size"]], fi[["mtime"]])
[18:04:27.495]                       stop(msg)
[18:04:27.495]                     }
[18:04:27.495]                     invisible(pathname)
[18:04:27.495]                   }
[18:04:27.495]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:27.495]                     rootPath = tempdir()) 
[18:04:27.495]                   {
[18:04:27.495]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:27.495]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:27.495]                       tmpdir = path, fileext = ".rds")
[18:04:27.495]                     save_rds(obj, file)
[18:04:27.495]                   }
[18:04:27.495]                   saveImmediateCondition(cond, path = "/tmp/RtmpLRNsAG/.future/immediateConditions")
[18:04:27.495]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.495]                   {
[18:04:27.495]                     inherits <- base::inherits
[18:04:27.495]                     invokeRestart <- base::invokeRestart
[18:04:27.495]                     is.null <- base::is.null
[18:04:27.495]                     muffled <- FALSE
[18:04:27.495]                     if (inherits(cond, "message")) {
[18:04:27.495]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:27.495]                       if (muffled) 
[18:04:27.495]                         invokeRestart("muffleMessage")
[18:04:27.495]                     }
[18:04:27.495]                     else if (inherits(cond, "warning")) {
[18:04:27.495]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:27.495]                       if (muffled) 
[18:04:27.495]                         invokeRestart("muffleWarning")
[18:04:27.495]                     }
[18:04:27.495]                     else if (inherits(cond, "condition")) {
[18:04:27.495]                       if (!is.null(pattern)) {
[18:04:27.495]                         computeRestarts <- base::computeRestarts
[18:04:27.495]                         grepl <- base::grepl
[18:04:27.495]                         restarts <- computeRestarts(cond)
[18:04:27.495]                         for (restart in restarts) {
[18:04:27.495]                           name <- restart$name
[18:04:27.495]                           if (is.null(name)) 
[18:04:27.495]                             next
[18:04:27.495]                           if (!grepl(pattern, name)) 
[18:04:27.495]                             next
[18:04:27.495]                           invokeRestart(restart)
[18:04:27.495]                           muffled <- TRUE
[18:04:27.495]                           break
[18:04:27.495]                         }
[18:04:27.495]                       }
[18:04:27.495]                     }
[18:04:27.495]                     invisible(muffled)
[18:04:27.495]                   }
[18:04:27.495]                   muffleCondition(cond)
[18:04:27.495]                 })
[18:04:27.495]             }))
[18:04:27.495]             future::FutureResult(value = ...future.value$value, 
[18:04:27.495]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.495]                   ...future.rng), globalenv = if (FALSE) 
[18:04:27.495]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:27.495]                     ...future.globalenv.names))
[18:04:27.495]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:27.495]         }, condition = base::local({
[18:04:27.495]             c <- base::c
[18:04:27.495]             inherits <- base::inherits
[18:04:27.495]             invokeRestart <- base::invokeRestart
[18:04:27.495]             length <- base::length
[18:04:27.495]             list <- base::list
[18:04:27.495]             seq.int <- base::seq.int
[18:04:27.495]             signalCondition <- base::signalCondition
[18:04:27.495]             sys.calls <- base::sys.calls
[18:04:27.495]             `[[` <- base::`[[`
[18:04:27.495]             `+` <- base::`+`
[18:04:27.495]             `<<-` <- base::`<<-`
[18:04:27.495]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:27.495]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:27.495]                   3L)]
[18:04:27.495]             }
[18:04:27.495]             function(cond) {
[18:04:27.495]                 is_error <- inherits(cond, "error")
[18:04:27.495]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:27.495]                   NULL)
[18:04:27.495]                 if (is_error) {
[18:04:27.495]                   sessionInformation <- function() {
[18:04:27.495]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:27.495]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:27.495]                       search = base::search(), system = base::Sys.info())
[18:04:27.495]                   }
[18:04:27.495]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.495]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:27.495]                     cond$call), session = sessionInformation(), 
[18:04:27.495]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:27.495]                   signalCondition(cond)
[18:04:27.495]                 }
[18:04:27.495]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:27.495]                 "immediateCondition"))) {
[18:04:27.495]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:27.495]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.495]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:27.495]                   if (TRUE && !signal) {
[18:04:27.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.495]                     {
[18:04:27.495]                       inherits <- base::inherits
[18:04:27.495]                       invokeRestart <- base::invokeRestart
[18:04:27.495]                       is.null <- base::is.null
[18:04:27.495]                       muffled <- FALSE
[18:04:27.495]                       if (inherits(cond, "message")) {
[18:04:27.495]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.495]                         if (muffled) 
[18:04:27.495]                           invokeRestart("muffleMessage")
[18:04:27.495]                       }
[18:04:27.495]                       else if (inherits(cond, "warning")) {
[18:04:27.495]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.495]                         if (muffled) 
[18:04:27.495]                           invokeRestart("muffleWarning")
[18:04:27.495]                       }
[18:04:27.495]                       else if (inherits(cond, "condition")) {
[18:04:27.495]                         if (!is.null(pattern)) {
[18:04:27.495]                           computeRestarts <- base::computeRestarts
[18:04:27.495]                           grepl <- base::grepl
[18:04:27.495]                           restarts <- computeRestarts(cond)
[18:04:27.495]                           for (restart in restarts) {
[18:04:27.495]                             name <- restart$name
[18:04:27.495]                             if (is.null(name)) 
[18:04:27.495]                               next
[18:04:27.495]                             if (!grepl(pattern, name)) 
[18:04:27.495]                               next
[18:04:27.495]                             invokeRestart(restart)
[18:04:27.495]                             muffled <- TRUE
[18:04:27.495]                             break
[18:04:27.495]                           }
[18:04:27.495]                         }
[18:04:27.495]                       }
[18:04:27.495]                       invisible(muffled)
[18:04:27.495]                     }
[18:04:27.495]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.495]                   }
[18:04:27.495]                 }
[18:04:27.495]                 else {
[18:04:27.495]                   if (TRUE) {
[18:04:27.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.495]                     {
[18:04:27.495]                       inherits <- base::inherits
[18:04:27.495]                       invokeRestart <- base::invokeRestart
[18:04:27.495]                       is.null <- base::is.null
[18:04:27.495]                       muffled <- FALSE
[18:04:27.495]                       if (inherits(cond, "message")) {
[18:04:27.495]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.495]                         if (muffled) 
[18:04:27.495]                           invokeRestart("muffleMessage")
[18:04:27.495]                       }
[18:04:27.495]                       else if (inherits(cond, "warning")) {
[18:04:27.495]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.495]                         if (muffled) 
[18:04:27.495]                           invokeRestart("muffleWarning")
[18:04:27.495]                       }
[18:04:27.495]                       else if (inherits(cond, "condition")) {
[18:04:27.495]                         if (!is.null(pattern)) {
[18:04:27.495]                           computeRestarts <- base::computeRestarts
[18:04:27.495]                           grepl <- base::grepl
[18:04:27.495]                           restarts <- computeRestarts(cond)
[18:04:27.495]                           for (restart in restarts) {
[18:04:27.495]                             name <- restart$name
[18:04:27.495]                             if (is.null(name)) 
[18:04:27.495]                               next
[18:04:27.495]                             if (!grepl(pattern, name)) 
[18:04:27.495]                               next
[18:04:27.495]                             invokeRestart(restart)
[18:04:27.495]                             muffled <- TRUE
[18:04:27.495]                             break
[18:04:27.495]                           }
[18:04:27.495]                         }
[18:04:27.495]                       }
[18:04:27.495]                       invisible(muffled)
[18:04:27.495]                     }
[18:04:27.495]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.495]                   }
[18:04:27.495]                 }
[18:04:27.495]             }
[18:04:27.495]         }))
[18:04:27.495]     }, error = function(ex) {
[18:04:27.495]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:27.495]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.495]                 ...future.rng), started = ...future.startTime, 
[18:04:27.495]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:27.495]             version = "1.8"), class = "FutureResult")
[18:04:27.495]     }, finally = {
[18:04:27.495]         if (!identical(...future.workdir, getwd())) 
[18:04:27.495]             setwd(...future.workdir)
[18:04:27.495]         {
[18:04:27.495]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:27.495]                 ...future.oldOptions$nwarnings <- NULL
[18:04:27.495]             }
[18:04:27.495]             base::options(...future.oldOptions)
[18:04:27.495]             if (.Platform$OS.type == "windows") {
[18:04:27.495]                 old_names <- names(...future.oldEnvVars)
[18:04:27.495]                 envs <- base::Sys.getenv()
[18:04:27.495]                 names <- names(envs)
[18:04:27.495]                 common <- intersect(names, old_names)
[18:04:27.495]                 added <- setdiff(names, old_names)
[18:04:27.495]                 removed <- setdiff(old_names, names)
[18:04:27.495]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:27.495]                   envs[common]]
[18:04:27.495]                 NAMES <- toupper(changed)
[18:04:27.495]                 args <- list()
[18:04:27.495]                 for (kk in seq_along(NAMES)) {
[18:04:27.495]                   name <- changed[[kk]]
[18:04:27.495]                   NAME <- NAMES[[kk]]
[18:04:27.495]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.495]                     next
[18:04:27.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.495]                 }
[18:04:27.495]                 NAMES <- toupper(added)
[18:04:27.495]                 for (kk in seq_along(NAMES)) {
[18:04:27.495]                   name <- added[[kk]]
[18:04:27.495]                   NAME <- NAMES[[kk]]
[18:04:27.495]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.495]                     next
[18:04:27.495]                   args[[name]] <- ""
[18:04:27.495]                 }
[18:04:27.495]                 NAMES <- toupper(removed)
[18:04:27.495]                 for (kk in seq_along(NAMES)) {
[18:04:27.495]                   name <- removed[[kk]]
[18:04:27.495]                   NAME <- NAMES[[kk]]
[18:04:27.495]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.495]                     next
[18:04:27.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.495]                 }
[18:04:27.495]                 if (length(args) > 0) 
[18:04:27.495]                   base::do.call(base::Sys.setenv, args = args)
[18:04:27.495]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:27.495]             }
[18:04:27.495]             else {
[18:04:27.495]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:27.495]             }
[18:04:27.495]             {
[18:04:27.495]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:27.495]                   0L) {
[18:04:27.495]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:27.495]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:27.495]                   base::options(opts)
[18:04:27.495]                 }
[18:04:27.495]                 {
[18:04:27.495]                   {
[18:04:27.495]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:27.495]                     NULL
[18:04:27.495]                   }
[18:04:27.495]                   options(future.plan = NULL)
[18:04:27.495]                   if (is.na(NA_character_)) 
[18:04:27.495]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.495]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:27.495]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:27.495]                     .init = FALSE)
[18:04:27.495]                 }
[18:04:27.495]             }
[18:04:27.495]         }
[18:04:27.495]     })
[18:04:27.495]     if (TRUE) {
[18:04:27.495]         base::sink(type = "output", split = FALSE)
[18:04:27.495]         if (TRUE) {
[18:04:27.495]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:27.495]         }
[18:04:27.495]         else {
[18:04:27.495]             ...future.result["stdout"] <- base::list(NULL)
[18:04:27.495]         }
[18:04:27.495]         base::close(...future.stdout)
[18:04:27.495]         ...future.stdout <- NULL
[18:04:27.495]     }
[18:04:27.495]     ...future.result$conditions <- ...future.conditions
[18:04:27.495]     ...future.result$finished <- base::Sys.time()
[18:04:27.495]     ...future.result
[18:04:27.495] }
[18:04:27.501] assign_globals() ...
[18:04:27.501] List of 2
[18:04:27.501]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[18:04:27.501]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[18:04:27.501]  - attr(*, "where")=List of 2
[18:04:27.501]   ..$ weight:<environment: R_EmptyEnv> 
[18:04:27.501]   ..$ group :<environment: R_EmptyEnv> 
[18:04:27.501]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:27.501]  - attr(*, "resolved")= logi FALSE
[18:04:27.501]  - attr(*, "total_size")= num 896
[18:04:27.501]  - attr(*, "already-done")= logi TRUE
[18:04:27.512] - copied ‘weight’ to environment
[18:04:27.512] - copied ‘group’ to environment
[18:04:27.512] assign_globals() ... done
[18:04:27.512] requestCore(): workers = 2
[18:04:27.516] MulticoreFuture started
[18:04:27.517] - Launch lazy future ... done
[18:04:27.517] run() for ‘MulticoreFuture’ ... done
[18:04:27.518] result() for MulticoreFuture ...
[18:04:27.518] plan(): Setting new future strategy stack:
[18:04:27.519] List of future strategies:
[18:04:27.519] 1. sequential:
[18:04:27.519]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.519]    - tweaked: FALSE
[18:04:27.519]    - call: NULL
[18:04:27.522] plan(): nbrOfWorkers() = 1
[18:04:27.530] plan(): Setting new future strategy stack:
[18:04:27.530] List of future strategies:
[18:04:27.530] 1. multicore:
[18:04:27.530]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:27.530]    - tweaked: FALSE
[18:04:27.530]    - call: plan(strategy)
[18:04:27.539] plan(): nbrOfWorkers() = 2
[18:04:27.543] result() for MulticoreFuture ...
[18:04:27.544] result() for MulticoreFuture ... done
[18:04:27.544] result() for MulticoreFuture ... done
[18:04:27.544] result() for MulticoreFuture ...
[18:04:27.545] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[18:04:27.550] getGlobalsAndPackages() ...
[18:04:27.550] Searching for globals...
[18:04:27.553] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[18:04:27.553] Searching for globals ... DONE
[18:04:27.553] Resolving globals: FALSE
[18:04:27.554] The total size of the 1 globals is 96 bytes (96 bytes)
[18:04:27.555] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[18:04:27.556] - globals: [1] ‘x’
[18:04:27.556] - packages: [1] ‘stats’
[18:04:27.556] getGlobalsAndPackages() ... DONE
[18:04:27.557] run() for ‘Future’ ...
[18:04:27.557] - state: ‘created’
[18:04:27.557] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:27.564] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:27.565] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:27.565]   - Field: ‘label’
[18:04:27.565]   - Field: ‘local’
[18:04:27.566]   - Field: ‘owner’
[18:04:27.566]   - Field: ‘envir’
[18:04:27.566]   - Field: ‘workers’
[18:04:27.566]   - Field: ‘packages’
[18:04:27.567]   - Field: ‘gc’
[18:04:27.567]   - Field: ‘job’
[18:04:27.567]   - Field: ‘conditions’
[18:04:27.567]   - Field: ‘expr’
[18:04:27.568]   - Field: ‘uuid’
[18:04:27.568]   - Field: ‘seed’
[18:04:27.568]   - Field: ‘version’
[18:04:27.568]   - Field: ‘result’
[18:04:27.568]   - Field: ‘asynchronous’
[18:04:27.569]   - Field: ‘calls’
[18:04:27.569]   - Field: ‘globals’
[18:04:27.569]   - Field: ‘stdout’
[18:04:27.569]   - Field: ‘earlySignal’
[18:04:27.570]   - Field: ‘lazy’
[18:04:27.570]   - Field: ‘state’
[18:04:27.570] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:27.570] - Launch lazy future ...
[18:04:27.571] Packages needed by the future expression (n = 1): ‘stats’
[18:04:27.571] Packages needed by future strategies (n = 0): <none>
[18:04:27.572] {
[18:04:27.572]     {
[18:04:27.572]         {
[18:04:27.572]             ...future.startTime <- base::Sys.time()
[18:04:27.572]             {
[18:04:27.572]                 {
[18:04:27.572]                   {
[18:04:27.572]                     {
[18:04:27.572]                       {
[18:04:27.572]                         base::local({
[18:04:27.572]                           has_future <- base::requireNamespace("future", 
[18:04:27.572]                             quietly = TRUE)
[18:04:27.572]                           if (has_future) {
[18:04:27.572]                             ns <- base::getNamespace("future")
[18:04:27.572]                             version <- ns[[".package"]][["version"]]
[18:04:27.572]                             if (is.null(version)) 
[18:04:27.572]                               version <- utils::packageVersion("future")
[18:04:27.572]                           }
[18:04:27.572]                           else {
[18:04:27.572]                             version <- NULL
[18:04:27.572]                           }
[18:04:27.572]                           if (!has_future || version < "1.8.0") {
[18:04:27.572]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:27.572]                               "", base::R.version$version.string), 
[18:04:27.572]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:27.572]                                 base::R.version$platform, 8 * 
[18:04:27.572]                                   base::.Machine$sizeof.pointer), 
[18:04:27.572]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:27.572]                                 "release", "version")], collapse = " "), 
[18:04:27.572]                               hostname = base::Sys.info()[["nodename"]])
[18:04:27.572]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:27.572]                               info)
[18:04:27.572]                             info <- base::paste(info, collapse = "; ")
[18:04:27.572]                             if (!has_future) {
[18:04:27.572]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:27.572]                                 info)
[18:04:27.572]                             }
[18:04:27.572]                             else {
[18:04:27.572]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:27.572]                                 info, version)
[18:04:27.572]                             }
[18:04:27.572]                             base::stop(msg)
[18:04:27.572]                           }
[18:04:27.572]                         })
[18:04:27.572]                       }
[18:04:27.572]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:27.572]                       base::options(mc.cores = 1L)
[18:04:27.572]                     }
[18:04:27.572]                     base::local({
[18:04:27.572]                       for (pkg in "stats") {
[18:04:27.572]                         base::loadNamespace(pkg)
[18:04:27.572]                         base::library(pkg, character.only = TRUE)
[18:04:27.572]                       }
[18:04:27.572]                     })
[18:04:27.572]                   }
[18:04:27.572]                   ...future.strategy.old <- future::plan("list")
[18:04:27.572]                   options(future.plan = NULL)
[18:04:27.572]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.572]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:27.572]                 }
[18:04:27.572]                 ...future.workdir <- getwd()
[18:04:27.572]             }
[18:04:27.572]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:27.572]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:27.572]         }
[18:04:27.572]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:27.572]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:27.572]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:27.572]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:27.572]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:27.572]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:27.572]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:27.572]             base::names(...future.oldOptions))
[18:04:27.572]     }
[18:04:27.572]     if (FALSE) {
[18:04:27.572]     }
[18:04:27.572]     else {
[18:04:27.572]         if (TRUE) {
[18:04:27.572]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:27.572]                 open = "w")
[18:04:27.572]         }
[18:04:27.572]         else {
[18:04:27.572]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:27.572]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:27.572]         }
[18:04:27.572]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:27.572]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:27.572]             base::sink(type = "output", split = FALSE)
[18:04:27.572]             base::close(...future.stdout)
[18:04:27.572]         }, add = TRUE)
[18:04:27.572]     }
[18:04:27.572]     ...future.frame <- base::sys.nframe()
[18:04:27.572]     ...future.conditions <- base::list()
[18:04:27.572]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:27.572]     if (FALSE) {
[18:04:27.572]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:27.572]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:27.572]     }
[18:04:27.572]     ...future.result <- base::tryCatch({
[18:04:27.572]         base::withCallingHandlers({
[18:04:27.572]             ...future.value <- base::withVisible(base::local({
[18:04:27.572]                 withCallingHandlers({
[18:04:27.572]                   {
[18:04:27.572]                     xtabs(~x)
[18:04:27.572]                   }
[18:04:27.572]                 }, immediateCondition = function(cond) {
[18:04:27.572]                   save_rds <- function (object, pathname, ...) 
[18:04:27.572]                   {
[18:04:27.572]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:27.572]                     if (file_test("-f", pathname_tmp)) {
[18:04:27.572]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.572]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:27.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.572]                         fi_tmp[["mtime"]])
[18:04:27.572]                     }
[18:04:27.572]                     tryCatch({
[18:04:27.572]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:27.572]                     }, error = function(ex) {
[18:04:27.572]                       msg <- conditionMessage(ex)
[18:04:27.572]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.572]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:27.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.572]                         fi_tmp[["mtime"]], msg)
[18:04:27.572]                       ex$message <- msg
[18:04:27.572]                       stop(ex)
[18:04:27.572]                     })
[18:04:27.572]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:27.572]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:27.572]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:27.572]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.572]                       fi <- file.info(pathname)
[18:04:27.572]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:27.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.572]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:27.572]                         fi[["size"]], fi[["mtime"]])
[18:04:27.572]                       stop(msg)
[18:04:27.572]                     }
[18:04:27.572]                     invisible(pathname)
[18:04:27.572]                   }
[18:04:27.572]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:27.572]                     rootPath = tempdir()) 
[18:04:27.572]                   {
[18:04:27.572]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:27.572]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:27.572]                       tmpdir = path, fileext = ".rds")
[18:04:27.572]                     save_rds(obj, file)
[18:04:27.572]                   }
[18:04:27.572]                   saveImmediateCondition(cond, path = "/tmp/RtmpLRNsAG/.future/immediateConditions")
[18:04:27.572]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.572]                   {
[18:04:27.572]                     inherits <- base::inherits
[18:04:27.572]                     invokeRestart <- base::invokeRestart
[18:04:27.572]                     is.null <- base::is.null
[18:04:27.572]                     muffled <- FALSE
[18:04:27.572]                     if (inherits(cond, "message")) {
[18:04:27.572]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:27.572]                       if (muffled) 
[18:04:27.572]                         invokeRestart("muffleMessage")
[18:04:27.572]                     }
[18:04:27.572]                     else if (inherits(cond, "warning")) {
[18:04:27.572]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:27.572]                       if (muffled) 
[18:04:27.572]                         invokeRestart("muffleWarning")
[18:04:27.572]                     }
[18:04:27.572]                     else if (inherits(cond, "condition")) {
[18:04:27.572]                       if (!is.null(pattern)) {
[18:04:27.572]                         computeRestarts <- base::computeRestarts
[18:04:27.572]                         grepl <- base::grepl
[18:04:27.572]                         restarts <- computeRestarts(cond)
[18:04:27.572]                         for (restart in restarts) {
[18:04:27.572]                           name <- restart$name
[18:04:27.572]                           if (is.null(name)) 
[18:04:27.572]                             next
[18:04:27.572]                           if (!grepl(pattern, name)) 
[18:04:27.572]                             next
[18:04:27.572]                           invokeRestart(restart)
[18:04:27.572]                           muffled <- TRUE
[18:04:27.572]                           break
[18:04:27.572]                         }
[18:04:27.572]                       }
[18:04:27.572]                     }
[18:04:27.572]                     invisible(muffled)
[18:04:27.572]                   }
[18:04:27.572]                   muffleCondition(cond)
[18:04:27.572]                 })
[18:04:27.572]             }))
[18:04:27.572]             future::FutureResult(value = ...future.value$value, 
[18:04:27.572]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.572]                   ...future.rng), globalenv = if (FALSE) 
[18:04:27.572]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:27.572]                     ...future.globalenv.names))
[18:04:27.572]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:27.572]         }, condition = base::local({
[18:04:27.572]             c <- base::c
[18:04:27.572]             inherits <- base::inherits
[18:04:27.572]             invokeRestart <- base::invokeRestart
[18:04:27.572]             length <- base::length
[18:04:27.572]             list <- base::list
[18:04:27.572]             seq.int <- base::seq.int
[18:04:27.572]             signalCondition <- base::signalCondition
[18:04:27.572]             sys.calls <- base::sys.calls
[18:04:27.572]             `[[` <- base::`[[`
[18:04:27.572]             `+` <- base::`+`
[18:04:27.572]             `<<-` <- base::`<<-`
[18:04:27.572]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:27.572]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:27.572]                   3L)]
[18:04:27.572]             }
[18:04:27.572]             function(cond) {
[18:04:27.572]                 is_error <- inherits(cond, "error")
[18:04:27.572]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:27.572]                   NULL)
[18:04:27.572]                 if (is_error) {
[18:04:27.572]                   sessionInformation <- function() {
[18:04:27.572]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:27.572]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:27.572]                       search = base::search(), system = base::Sys.info())
[18:04:27.572]                   }
[18:04:27.572]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.572]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:27.572]                     cond$call), session = sessionInformation(), 
[18:04:27.572]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:27.572]                   signalCondition(cond)
[18:04:27.572]                 }
[18:04:27.572]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:27.572]                 "immediateCondition"))) {
[18:04:27.572]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:27.572]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.572]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:27.572]                   if (TRUE && !signal) {
[18:04:27.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.572]                     {
[18:04:27.572]                       inherits <- base::inherits
[18:04:27.572]                       invokeRestart <- base::invokeRestart
[18:04:27.572]                       is.null <- base::is.null
[18:04:27.572]                       muffled <- FALSE
[18:04:27.572]                       if (inherits(cond, "message")) {
[18:04:27.572]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.572]                         if (muffled) 
[18:04:27.572]                           invokeRestart("muffleMessage")
[18:04:27.572]                       }
[18:04:27.572]                       else if (inherits(cond, "warning")) {
[18:04:27.572]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.572]                         if (muffled) 
[18:04:27.572]                           invokeRestart("muffleWarning")
[18:04:27.572]                       }
[18:04:27.572]                       else if (inherits(cond, "condition")) {
[18:04:27.572]                         if (!is.null(pattern)) {
[18:04:27.572]                           computeRestarts <- base::computeRestarts
[18:04:27.572]                           grepl <- base::grepl
[18:04:27.572]                           restarts <- computeRestarts(cond)
[18:04:27.572]                           for (restart in restarts) {
[18:04:27.572]                             name <- restart$name
[18:04:27.572]                             if (is.null(name)) 
[18:04:27.572]                               next
[18:04:27.572]                             if (!grepl(pattern, name)) 
[18:04:27.572]                               next
[18:04:27.572]                             invokeRestart(restart)
[18:04:27.572]                             muffled <- TRUE
[18:04:27.572]                             break
[18:04:27.572]                           }
[18:04:27.572]                         }
[18:04:27.572]                       }
[18:04:27.572]                       invisible(muffled)
[18:04:27.572]                     }
[18:04:27.572]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.572]                   }
[18:04:27.572]                 }
[18:04:27.572]                 else {
[18:04:27.572]                   if (TRUE) {
[18:04:27.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.572]                     {
[18:04:27.572]                       inherits <- base::inherits
[18:04:27.572]                       invokeRestart <- base::invokeRestart
[18:04:27.572]                       is.null <- base::is.null
[18:04:27.572]                       muffled <- FALSE
[18:04:27.572]                       if (inherits(cond, "message")) {
[18:04:27.572]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.572]                         if (muffled) 
[18:04:27.572]                           invokeRestart("muffleMessage")
[18:04:27.572]                       }
[18:04:27.572]                       else if (inherits(cond, "warning")) {
[18:04:27.572]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.572]                         if (muffled) 
[18:04:27.572]                           invokeRestart("muffleWarning")
[18:04:27.572]                       }
[18:04:27.572]                       else if (inherits(cond, "condition")) {
[18:04:27.572]                         if (!is.null(pattern)) {
[18:04:27.572]                           computeRestarts <- base::computeRestarts
[18:04:27.572]                           grepl <- base::grepl
[18:04:27.572]                           restarts <- computeRestarts(cond)
[18:04:27.572]                           for (restart in restarts) {
[18:04:27.572]                             name <- restart$name
[18:04:27.572]                             if (is.null(name)) 
[18:04:27.572]                               next
[18:04:27.572]                             if (!grepl(pattern, name)) 
[18:04:27.572]                               next
[18:04:27.572]                             invokeRestart(restart)
[18:04:27.572]                             muffled <- TRUE
[18:04:27.572]                             break
[18:04:27.572]                           }
[18:04:27.572]                         }
[18:04:27.572]                       }
[18:04:27.572]                       invisible(muffled)
[18:04:27.572]                     }
[18:04:27.572]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.572]                   }
[18:04:27.572]                 }
[18:04:27.572]             }
[18:04:27.572]         }))
[18:04:27.572]     }, error = function(ex) {
[18:04:27.572]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:27.572]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.572]                 ...future.rng), started = ...future.startTime, 
[18:04:27.572]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:27.572]             version = "1.8"), class = "FutureResult")
[18:04:27.572]     }, finally = {
[18:04:27.572]         if (!identical(...future.workdir, getwd())) 
[18:04:27.572]             setwd(...future.workdir)
[18:04:27.572]         {
[18:04:27.572]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:27.572]                 ...future.oldOptions$nwarnings <- NULL
[18:04:27.572]             }
[18:04:27.572]             base::options(...future.oldOptions)
[18:04:27.572]             if (.Platform$OS.type == "windows") {
[18:04:27.572]                 old_names <- names(...future.oldEnvVars)
[18:04:27.572]                 envs <- base::Sys.getenv()
[18:04:27.572]                 names <- names(envs)
[18:04:27.572]                 common <- intersect(names, old_names)
[18:04:27.572]                 added <- setdiff(names, old_names)
[18:04:27.572]                 removed <- setdiff(old_names, names)
[18:04:27.572]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:27.572]                   envs[common]]
[18:04:27.572]                 NAMES <- toupper(changed)
[18:04:27.572]                 args <- list()
[18:04:27.572]                 for (kk in seq_along(NAMES)) {
[18:04:27.572]                   name <- changed[[kk]]
[18:04:27.572]                   NAME <- NAMES[[kk]]
[18:04:27.572]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.572]                     next
[18:04:27.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.572]                 }
[18:04:27.572]                 NAMES <- toupper(added)
[18:04:27.572]                 for (kk in seq_along(NAMES)) {
[18:04:27.572]                   name <- added[[kk]]
[18:04:27.572]                   NAME <- NAMES[[kk]]
[18:04:27.572]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.572]                     next
[18:04:27.572]                   args[[name]] <- ""
[18:04:27.572]                 }
[18:04:27.572]                 NAMES <- toupper(removed)
[18:04:27.572]                 for (kk in seq_along(NAMES)) {
[18:04:27.572]                   name <- removed[[kk]]
[18:04:27.572]                   NAME <- NAMES[[kk]]
[18:04:27.572]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.572]                     next
[18:04:27.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.572]                 }
[18:04:27.572]                 if (length(args) > 0) 
[18:04:27.572]                   base::do.call(base::Sys.setenv, args = args)
[18:04:27.572]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:27.572]             }
[18:04:27.572]             else {
[18:04:27.572]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:27.572]             }
[18:04:27.572]             {
[18:04:27.572]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:27.572]                   0L) {
[18:04:27.572]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:27.572]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:27.572]                   base::options(opts)
[18:04:27.572]                 }
[18:04:27.572]                 {
[18:04:27.572]                   {
[18:04:27.572]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:27.572]                     NULL
[18:04:27.572]                   }
[18:04:27.572]                   options(future.plan = NULL)
[18:04:27.572]                   if (is.na(NA_character_)) 
[18:04:27.572]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.572]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:27.572]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:27.572]                     .init = FALSE)
[18:04:27.572]                 }
[18:04:27.572]             }
[18:04:27.572]         }
[18:04:27.572]     })
[18:04:27.572]     if (TRUE) {
[18:04:27.572]         base::sink(type = "output", split = FALSE)
[18:04:27.572]         if (TRUE) {
[18:04:27.572]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:27.572]         }
[18:04:27.572]         else {
[18:04:27.572]             ...future.result["stdout"] <- base::list(NULL)
[18:04:27.572]         }
[18:04:27.572]         base::close(...future.stdout)
[18:04:27.572]         ...future.stdout <- NULL
[18:04:27.572]     }
[18:04:27.572]     ...future.result$conditions <- ...future.conditions
[18:04:27.572]     ...future.result$finished <- base::Sys.time()
[18:04:27.572]     ...future.result
[18:04:27.572] }
[18:04:27.577] assign_globals() ...
[18:04:27.577] List of 1
[18:04:27.577]  $ x: num [1:5] 1 1 2 2 2
[18:04:27.577]  - attr(*, "where")=List of 1
[18:04:27.577]   ..$ x:<environment: R_EmptyEnv> 
[18:04:27.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:27.577]  - attr(*, "resolved")= logi FALSE
[18:04:27.577]  - attr(*, "total_size")= num 96
[18:04:27.577]  - attr(*, "already-done")= logi TRUE
[18:04:27.583] - copied ‘x’ to environment
[18:04:27.583] assign_globals() ... done
[18:04:27.584] requestCore(): workers = 2
[18:04:27.587] MulticoreFuture started
[18:04:27.588] - Launch lazy future ... done
[18:04:27.588] run() for ‘MulticoreFuture’ ... done
[18:04:27.589] result() for MulticoreFuture ...
[18:04:27.590] plan(): Setting new future strategy stack:
[18:04:27.590] List of future strategies:
[18:04:27.590] 1. sequential:
[18:04:27.590]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.590]    - tweaked: FALSE
[18:04:27.590]    - call: NULL
[18:04:27.593] plan(): nbrOfWorkers() = 1
[18:04:27.599] plan(): Setting new future strategy stack:
[18:04:27.599] List of future strategies:
[18:04:27.599] 1. multicore:
[18:04:27.599]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:27.599]    - tweaked: FALSE
[18:04:27.599]    - call: plan(strategy)
[18:04:27.615] plan(): nbrOfWorkers() = 2
[18:04:27.617] result() for MulticoreFuture ...
[18:04:27.617] result() for MulticoreFuture ... done
[18:04:27.617] result() for MulticoreFuture ... done
[18:04:27.618] result() for MulticoreFuture ...
[18:04:27.618] result() for MulticoreFuture ... done
x
1 2 
2 3 
[18:04:27.620] getGlobalsAndPackages() ...
[18:04:27.621] Searching for globals...
[18:04:27.627] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[18:04:27.628] Searching for globals ... DONE
[18:04:27.628] Resolving globals: FALSE
[18:04:27.629] The total size of the 1 globals is 96 bytes (96 bytes)
[18:04:27.630] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[18:04:27.630] - globals: [1] ‘x’
[18:04:27.630] - packages: [1] ‘stats’
[18:04:27.631] getGlobalsAndPackages() ... DONE
[18:04:27.631] run() for ‘Future’ ...
[18:04:27.632] - state: ‘created’
[18:04:27.632] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:27.639] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:27.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:27.640]   - Field: ‘label’
[18:04:27.640]   - Field: ‘local’
[18:04:27.641]   - Field: ‘owner’
[18:04:27.641]   - Field: ‘envir’
[18:04:27.641]   - Field: ‘workers’
[18:04:27.641]   - Field: ‘packages’
[18:04:27.642]   - Field: ‘gc’
[18:04:27.642]   - Field: ‘job’
[18:04:27.642]   - Field: ‘conditions’
[18:04:27.642]   - Field: ‘expr’
[18:04:27.642]   - Field: ‘uuid’
[18:04:27.643]   - Field: ‘seed’
[18:04:27.643]   - Field: ‘version’
[18:04:27.643]   - Field: ‘result’
[18:04:27.643]   - Field: ‘asynchronous’
[18:04:27.644]   - Field: ‘calls’
[18:04:27.644]   - Field: ‘globals’
[18:04:27.644]   - Field: ‘stdout’
[18:04:27.644]   - Field: ‘earlySignal’
[18:04:27.645]   - Field: ‘lazy’
[18:04:27.645]   - Field: ‘state’
[18:04:27.645] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:27.645] - Launch lazy future ...
[18:04:27.646] Packages needed by the future expression (n = 1): ‘stats’
[18:04:27.646] Packages needed by future strategies (n = 0): <none>
[18:04:27.648] {
[18:04:27.648]     {
[18:04:27.648]         {
[18:04:27.648]             ...future.startTime <- base::Sys.time()
[18:04:27.648]             {
[18:04:27.648]                 {
[18:04:27.648]                   {
[18:04:27.648]                     {
[18:04:27.648]                       {
[18:04:27.648]                         base::local({
[18:04:27.648]                           has_future <- base::requireNamespace("future", 
[18:04:27.648]                             quietly = TRUE)
[18:04:27.648]                           if (has_future) {
[18:04:27.648]                             ns <- base::getNamespace("future")
[18:04:27.648]                             version <- ns[[".package"]][["version"]]
[18:04:27.648]                             if (is.null(version)) 
[18:04:27.648]                               version <- utils::packageVersion("future")
[18:04:27.648]                           }
[18:04:27.648]                           else {
[18:04:27.648]                             version <- NULL
[18:04:27.648]                           }
[18:04:27.648]                           if (!has_future || version < "1.8.0") {
[18:04:27.648]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:27.648]                               "", base::R.version$version.string), 
[18:04:27.648]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:27.648]                                 base::R.version$platform, 8 * 
[18:04:27.648]                                   base::.Machine$sizeof.pointer), 
[18:04:27.648]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:27.648]                                 "release", "version")], collapse = " "), 
[18:04:27.648]                               hostname = base::Sys.info()[["nodename"]])
[18:04:27.648]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:27.648]                               info)
[18:04:27.648]                             info <- base::paste(info, collapse = "; ")
[18:04:27.648]                             if (!has_future) {
[18:04:27.648]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:27.648]                                 info)
[18:04:27.648]                             }
[18:04:27.648]                             else {
[18:04:27.648]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:27.648]                                 info, version)
[18:04:27.648]                             }
[18:04:27.648]                             base::stop(msg)
[18:04:27.648]                           }
[18:04:27.648]                         })
[18:04:27.648]                       }
[18:04:27.648]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:27.648]                       base::options(mc.cores = 1L)
[18:04:27.648]                     }
[18:04:27.648]                     base::local({
[18:04:27.648]                       for (pkg in "stats") {
[18:04:27.648]                         base::loadNamespace(pkg)
[18:04:27.648]                         base::library(pkg, character.only = TRUE)
[18:04:27.648]                       }
[18:04:27.648]                     })
[18:04:27.648]                   }
[18:04:27.648]                   ...future.strategy.old <- future::plan("list")
[18:04:27.648]                   options(future.plan = NULL)
[18:04:27.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:27.648]                 }
[18:04:27.648]                 ...future.workdir <- getwd()
[18:04:27.648]             }
[18:04:27.648]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:27.648]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:27.648]         }
[18:04:27.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:27.648]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:27.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:27.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:27.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:27.648]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:27.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:27.648]             base::names(...future.oldOptions))
[18:04:27.648]     }
[18:04:27.648]     if (FALSE) {
[18:04:27.648]     }
[18:04:27.648]     else {
[18:04:27.648]         if (TRUE) {
[18:04:27.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:27.648]                 open = "w")
[18:04:27.648]         }
[18:04:27.648]         else {
[18:04:27.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:27.648]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:27.648]         }
[18:04:27.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:27.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:27.648]             base::sink(type = "output", split = FALSE)
[18:04:27.648]             base::close(...future.stdout)
[18:04:27.648]         }, add = TRUE)
[18:04:27.648]     }
[18:04:27.648]     ...future.frame <- base::sys.nframe()
[18:04:27.648]     ...future.conditions <- base::list()
[18:04:27.648]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:27.648]     if (FALSE) {
[18:04:27.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:27.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:27.648]     }
[18:04:27.648]     ...future.result <- base::tryCatch({
[18:04:27.648]         base::withCallingHandlers({
[18:04:27.648]             ...future.value <- base::withVisible(base::local({
[18:04:27.648]                 withCallingHandlers({
[18:04:27.648]                   {
[18:04:27.648]                     xtabs(~x)
[18:04:27.648]                   }
[18:04:27.648]                 }, immediateCondition = function(cond) {
[18:04:27.648]                   save_rds <- function (object, pathname, ...) 
[18:04:27.648]                   {
[18:04:27.648]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:27.648]                     if (file_test("-f", pathname_tmp)) {
[18:04:27.648]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.648]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:27.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.648]                         fi_tmp[["mtime"]])
[18:04:27.648]                     }
[18:04:27.648]                     tryCatch({
[18:04:27.648]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:27.648]                     }, error = function(ex) {
[18:04:27.648]                       msg <- conditionMessage(ex)
[18:04:27.648]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.648]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:27.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.648]                         fi_tmp[["mtime"]], msg)
[18:04:27.648]                       ex$message <- msg
[18:04:27.648]                       stop(ex)
[18:04:27.648]                     })
[18:04:27.648]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:27.648]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:27.648]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:27.648]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.648]                       fi <- file.info(pathname)
[18:04:27.648]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:27.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.648]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:27.648]                         fi[["size"]], fi[["mtime"]])
[18:04:27.648]                       stop(msg)
[18:04:27.648]                     }
[18:04:27.648]                     invisible(pathname)
[18:04:27.648]                   }
[18:04:27.648]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:27.648]                     rootPath = tempdir()) 
[18:04:27.648]                   {
[18:04:27.648]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:27.648]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:27.648]                       tmpdir = path, fileext = ".rds")
[18:04:27.648]                     save_rds(obj, file)
[18:04:27.648]                   }
[18:04:27.648]                   saveImmediateCondition(cond, path = "/tmp/RtmpLRNsAG/.future/immediateConditions")
[18:04:27.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.648]                   {
[18:04:27.648]                     inherits <- base::inherits
[18:04:27.648]                     invokeRestart <- base::invokeRestart
[18:04:27.648]                     is.null <- base::is.null
[18:04:27.648]                     muffled <- FALSE
[18:04:27.648]                     if (inherits(cond, "message")) {
[18:04:27.648]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:27.648]                       if (muffled) 
[18:04:27.648]                         invokeRestart("muffleMessage")
[18:04:27.648]                     }
[18:04:27.648]                     else if (inherits(cond, "warning")) {
[18:04:27.648]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:27.648]                       if (muffled) 
[18:04:27.648]                         invokeRestart("muffleWarning")
[18:04:27.648]                     }
[18:04:27.648]                     else if (inherits(cond, "condition")) {
[18:04:27.648]                       if (!is.null(pattern)) {
[18:04:27.648]                         computeRestarts <- base::computeRestarts
[18:04:27.648]                         grepl <- base::grepl
[18:04:27.648]                         restarts <- computeRestarts(cond)
[18:04:27.648]                         for (restart in restarts) {
[18:04:27.648]                           name <- restart$name
[18:04:27.648]                           if (is.null(name)) 
[18:04:27.648]                             next
[18:04:27.648]                           if (!grepl(pattern, name)) 
[18:04:27.648]                             next
[18:04:27.648]                           invokeRestart(restart)
[18:04:27.648]                           muffled <- TRUE
[18:04:27.648]                           break
[18:04:27.648]                         }
[18:04:27.648]                       }
[18:04:27.648]                     }
[18:04:27.648]                     invisible(muffled)
[18:04:27.648]                   }
[18:04:27.648]                   muffleCondition(cond)
[18:04:27.648]                 })
[18:04:27.648]             }))
[18:04:27.648]             future::FutureResult(value = ...future.value$value, 
[18:04:27.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.648]                   ...future.rng), globalenv = if (FALSE) 
[18:04:27.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:27.648]                     ...future.globalenv.names))
[18:04:27.648]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:27.648]         }, condition = base::local({
[18:04:27.648]             c <- base::c
[18:04:27.648]             inherits <- base::inherits
[18:04:27.648]             invokeRestart <- base::invokeRestart
[18:04:27.648]             length <- base::length
[18:04:27.648]             list <- base::list
[18:04:27.648]             seq.int <- base::seq.int
[18:04:27.648]             signalCondition <- base::signalCondition
[18:04:27.648]             sys.calls <- base::sys.calls
[18:04:27.648]             `[[` <- base::`[[`
[18:04:27.648]             `+` <- base::`+`
[18:04:27.648]             `<<-` <- base::`<<-`
[18:04:27.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:27.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:27.648]                   3L)]
[18:04:27.648]             }
[18:04:27.648]             function(cond) {
[18:04:27.648]                 is_error <- inherits(cond, "error")
[18:04:27.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:27.648]                   NULL)
[18:04:27.648]                 if (is_error) {
[18:04:27.648]                   sessionInformation <- function() {
[18:04:27.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:27.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:27.648]                       search = base::search(), system = base::Sys.info())
[18:04:27.648]                   }
[18:04:27.648]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:27.648]                     cond$call), session = sessionInformation(), 
[18:04:27.648]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:27.648]                   signalCondition(cond)
[18:04:27.648]                 }
[18:04:27.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:27.648]                 "immediateCondition"))) {
[18:04:27.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:27.648]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:27.648]                   if (TRUE && !signal) {
[18:04:27.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.648]                     {
[18:04:27.648]                       inherits <- base::inherits
[18:04:27.648]                       invokeRestart <- base::invokeRestart
[18:04:27.648]                       is.null <- base::is.null
[18:04:27.648]                       muffled <- FALSE
[18:04:27.648]                       if (inherits(cond, "message")) {
[18:04:27.648]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.648]                         if (muffled) 
[18:04:27.648]                           invokeRestart("muffleMessage")
[18:04:27.648]                       }
[18:04:27.648]                       else if (inherits(cond, "warning")) {
[18:04:27.648]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.648]                         if (muffled) 
[18:04:27.648]                           invokeRestart("muffleWarning")
[18:04:27.648]                       }
[18:04:27.648]                       else if (inherits(cond, "condition")) {
[18:04:27.648]                         if (!is.null(pattern)) {
[18:04:27.648]                           computeRestarts <- base::computeRestarts
[18:04:27.648]                           grepl <- base::grepl
[18:04:27.648]                           restarts <- computeRestarts(cond)
[18:04:27.648]                           for (restart in restarts) {
[18:04:27.648]                             name <- restart$name
[18:04:27.648]                             if (is.null(name)) 
[18:04:27.648]                               next
[18:04:27.648]                             if (!grepl(pattern, name)) 
[18:04:27.648]                               next
[18:04:27.648]                             invokeRestart(restart)
[18:04:27.648]                             muffled <- TRUE
[18:04:27.648]                             break
[18:04:27.648]                           }
[18:04:27.648]                         }
[18:04:27.648]                       }
[18:04:27.648]                       invisible(muffled)
[18:04:27.648]                     }
[18:04:27.648]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.648]                   }
[18:04:27.648]                 }
[18:04:27.648]                 else {
[18:04:27.648]                   if (TRUE) {
[18:04:27.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.648]                     {
[18:04:27.648]                       inherits <- base::inherits
[18:04:27.648]                       invokeRestart <- base::invokeRestart
[18:04:27.648]                       is.null <- base::is.null
[18:04:27.648]                       muffled <- FALSE
[18:04:27.648]                       if (inherits(cond, "message")) {
[18:04:27.648]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.648]                         if (muffled) 
[18:04:27.648]                           invokeRestart("muffleMessage")
[18:04:27.648]                       }
[18:04:27.648]                       else if (inherits(cond, "warning")) {
[18:04:27.648]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.648]                         if (muffled) 
[18:04:27.648]                           invokeRestart("muffleWarning")
[18:04:27.648]                       }
[18:04:27.648]                       else if (inherits(cond, "condition")) {
[18:04:27.648]                         if (!is.null(pattern)) {
[18:04:27.648]                           computeRestarts <- base::computeRestarts
[18:04:27.648]                           grepl <- base::grepl
[18:04:27.648]                           restarts <- computeRestarts(cond)
[18:04:27.648]                           for (restart in restarts) {
[18:04:27.648]                             name <- restart$name
[18:04:27.648]                             if (is.null(name)) 
[18:04:27.648]                               next
[18:04:27.648]                             if (!grepl(pattern, name)) 
[18:04:27.648]                               next
[18:04:27.648]                             invokeRestart(restart)
[18:04:27.648]                             muffled <- TRUE
[18:04:27.648]                             break
[18:04:27.648]                           }
[18:04:27.648]                         }
[18:04:27.648]                       }
[18:04:27.648]                       invisible(muffled)
[18:04:27.648]                     }
[18:04:27.648]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.648]                   }
[18:04:27.648]                 }
[18:04:27.648]             }
[18:04:27.648]         }))
[18:04:27.648]     }, error = function(ex) {
[18:04:27.648]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:27.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.648]                 ...future.rng), started = ...future.startTime, 
[18:04:27.648]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:27.648]             version = "1.8"), class = "FutureResult")
[18:04:27.648]     }, finally = {
[18:04:27.648]         if (!identical(...future.workdir, getwd())) 
[18:04:27.648]             setwd(...future.workdir)
[18:04:27.648]         {
[18:04:27.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:27.648]                 ...future.oldOptions$nwarnings <- NULL
[18:04:27.648]             }
[18:04:27.648]             base::options(...future.oldOptions)
[18:04:27.648]             if (.Platform$OS.type == "windows") {
[18:04:27.648]                 old_names <- names(...future.oldEnvVars)
[18:04:27.648]                 envs <- base::Sys.getenv()
[18:04:27.648]                 names <- names(envs)
[18:04:27.648]                 common <- intersect(names, old_names)
[18:04:27.648]                 added <- setdiff(names, old_names)
[18:04:27.648]                 removed <- setdiff(old_names, names)
[18:04:27.648]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:27.648]                   envs[common]]
[18:04:27.648]                 NAMES <- toupper(changed)
[18:04:27.648]                 args <- list()
[18:04:27.648]                 for (kk in seq_along(NAMES)) {
[18:04:27.648]                   name <- changed[[kk]]
[18:04:27.648]                   NAME <- NAMES[[kk]]
[18:04:27.648]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.648]                     next
[18:04:27.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.648]                 }
[18:04:27.648]                 NAMES <- toupper(added)
[18:04:27.648]                 for (kk in seq_along(NAMES)) {
[18:04:27.648]                   name <- added[[kk]]
[18:04:27.648]                   NAME <- NAMES[[kk]]
[18:04:27.648]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.648]                     next
[18:04:27.648]                   args[[name]] <- ""
[18:04:27.648]                 }
[18:04:27.648]                 NAMES <- toupper(removed)
[18:04:27.648]                 for (kk in seq_along(NAMES)) {
[18:04:27.648]                   name <- removed[[kk]]
[18:04:27.648]                   NAME <- NAMES[[kk]]
[18:04:27.648]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.648]                     next
[18:04:27.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.648]                 }
[18:04:27.648]                 if (length(args) > 0) 
[18:04:27.648]                   base::do.call(base::Sys.setenv, args = args)
[18:04:27.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:27.648]             }
[18:04:27.648]             else {
[18:04:27.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:27.648]             }
[18:04:27.648]             {
[18:04:27.648]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:27.648]                   0L) {
[18:04:27.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:27.648]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:27.648]                   base::options(opts)
[18:04:27.648]                 }
[18:04:27.648]                 {
[18:04:27.648]                   {
[18:04:27.648]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:27.648]                     NULL
[18:04:27.648]                   }
[18:04:27.648]                   options(future.plan = NULL)
[18:04:27.648]                   if (is.na(NA_character_)) 
[18:04:27.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:27.648]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:27.648]                     .init = FALSE)
[18:04:27.648]                 }
[18:04:27.648]             }
[18:04:27.648]         }
[18:04:27.648]     })
[18:04:27.648]     if (TRUE) {
[18:04:27.648]         base::sink(type = "output", split = FALSE)
[18:04:27.648]         if (TRUE) {
[18:04:27.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:27.648]         }
[18:04:27.648]         else {
[18:04:27.648]             ...future.result["stdout"] <- base::list(NULL)
[18:04:27.648]         }
[18:04:27.648]         base::close(...future.stdout)
[18:04:27.648]         ...future.stdout <- NULL
[18:04:27.648]     }
[18:04:27.648]     ...future.result$conditions <- ...future.conditions
[18:04:27.648]     ...future.result$finished <- base::Sys.time()
[18:04:27.648]     ...future.result
[18:04:27.648] }
[18:04:27.652] assign_globals() ...
[18:04:27.652] List of 1
[18:04:27.652]  $ x: num [1:5] 1 1 2 2 2
[18:04:27.652]  - attr(*, "where")=List of 1
[18:04:27.652]   ..$ x:<environment: R_EmptyEnv> 
[18:04:27.652]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:27.652]  - attr(*, "resolved")= logi FALSE
[18:04:27.652]  - attr(*, "total_size")= num 96
[18:04:27.652]  - attr(*, "already-done")= logi TRUE
[18:04:27.658] - copied ‘x’ to environment
[18:04:27.658] assign_globals() ... done
[18:04:27.658] requestCore(): workers = 2
[18:04:27.662] MulticoreFuture started
[18:04:27.662] - Launch lazy future ... done
[18:04:27.663] run() for ‘MulticoreFuture’ ... done
[18:04:27.664] result() for MulticoreFuture ...
[18:04:27.666] plan(): Setting new future strategy stack:
[18:04:27.667] List of future strategies:
[18:04:27.667] 1. sequential:
[18:04:27.667]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.667]    - tweaked: FALSE
[18:04:27.667]    - call: NULL
[18:04:27.669] plan(): nbrOfWorkers() = 1
[18:04:27.675] plan(): Setting new future strategy stack:
[18:04:27.675] List of future strategies:
[18:04:27.675] 1. multicore:
[18:04:27.675]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:27.675]    - tweaked: FALSE
[18:04:27.675]    - call: plan(strategy)
[18:04:27.685] plan(): nbrOfWorkers() = 2
[18:04:27.688] result() for MulticoreFuture ...
[18:04:27.689] result() for MulticoreFuture ... done
[18:04:27.689] result() for MulticoreFuture ... done
[18:04:27.689] result() for MulticoreFuture ...
[18:04:27.690] result() for MulticoreFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[18:04:27.695] getGlobalsAndPackages() ...
[18:04:27.695] Searching for globals...
[18:04:27.699] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[18:04:27.700] Searching for globals ... DONE
[18:04:27.700] Resolving globals: FALSE
[18:04:27.701] 
[18:04:27.701] - packages: [2] ‘stats’, ‘datasets’
[18:04:27.702] getGlobalsAndPackages() ... DONE
[18:04:27.702] run() for ‘Future’ ...
[18:04:27.703] - state: ‘created’
[18:04:27.703] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:27.710] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:27.710] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:27.710]   - Field: ‘label’
[18:04:27.711]   - Field: ‘local’
[18:04:27.711]   - Field: ‘owner’
[18:04:27.711]   - Field: ‘envir’
[18:04:27.712]   - Field: ‘workers’
[18:04:27.712]   - Field: ‘packages’
[18:04:27.712]   - Field: ‘gc’
[18:04:27.712]   - Field: ‘job’
[18:04:27.713]   - Field: ‘conditions’
[18:04:27.713]   - Field: ‘expr’
[18:04:27.713]   - Field: ‘uuid’
[18:04:27.713]   - Field: ‘seed’
[18:04:27.714]   - Field: ‘version’
[18:04:27.714]   - Field: ‘result’
[18:04:27.714]   - Field: ‘asynchronous’
[18:04:27.714]   - Field: ‘calls’
[18:04:27.714]   - Field: ‘globals’
[18:04:27.715]   - Field: ‘stdout’
[18:04:27.715]   - Field: ‘earlySignal’
[18:04:27.715]   - Field: ‘lazy’
[18:04:27.715]   - Field: ‘state’
[18:04:27.716] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:27.719] - Launch lazy future ...
[18:04:27.720] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:27.720] Packages needed by future strategies (n = 0): <none>
[18:04:27.721] {
[18:04:27.721]     {
[18:04:27.721]         {
[18:04:27.721]             ...future.startTime <- base::Sys.time()
[18:04:27.721]             {
[18:04:27.721]                 {
[18:04:27.721]                   {
[18:04:27.721]                     {
[18:04:27.721]                       {
[18:04:27.721]                         base::local({
[18:04:27.721]                           has_future <- base::requireNamespace("future", 
[18:04:27.721]                             quietly = TRUE)
[18:04:27.721]                           if (has_future) {
[18:04:27.721]                             ns <- base::getNamespace("future")
[18:04:27.721]                             version <- ns[[".package"]][["version"]]
[18:04:27.721]                             if (is.null(version)) 
[18:04:27.721]                               version <- utils::packageVersion("future")
[18:04:27.721]                           }
[18:04:27.721]                           else {
[18:04:27.721]                             version <- NULL
[18:04:27.721]                           }
[18:04:27.721]                           if (!has_future || version < "1.8.0") {
[18:04:27.721]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:27.721]                               "", base::R.version$version.string), 
[18:04:27.721]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:27.721]                                 base::R.version$platform, 8 * 
[18:04:27.721]                                   base::.Machine$sizeof.pointer), 
[18:04:27.721]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:27.721]                                 "release", "version")], collapse = " "), 
[18:04:27.721]                               hostname = base::Sys.info()[["nodename"]])
[18:04:27.721]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:27.721]                               info)
[18:04:27.721]                             info <- base::paste(info, collapse = "; ")
[18:04:27.721]                             if (!has_future) {
[18:04:27.721]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:27.721]                                 info)
[18:04:27.721]                             }
[18:04:27.721]                             else {
[18:04:27.721]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:27.721]                                 info, version)
[18:04:27.721]                             }
[18:04:27.721]                             base::stop(msg)
[18:04:27.721]                           }
[18:04:27.721]                         })
[18:04:27.721]                       }
[18:04:27.721]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:27.721]                       base::options(mc.cores = 1L)
[18:04:27.721]                     }
[18:04:27.721]                     base::local({
[18:04:27.721]                       for (pkg in c("stats", "datasets")) {
[18:04:27.721]                         base::loadNamespace(pkg)
[18:04:27.721]                         base::library(pkg, character.only = TRUE)
[18:04:27.721]                       }
[18:04:27.721]                     })
[18:04:27.721]                   }
[18:04:27.721]                   ...future.strategy.old <- future::plan("list")
[18:04:27.721]                   options(future.plan = NULL)
[18:04:27.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:27.721]                 }
[18:04:27.721]                 ...future.workdir <- getwd()
[18:04:27.721]             }
[18:04:27.721]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:27.721]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:27.721]         }
[18:04:27.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:27.721]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:27.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:27.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:27.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:27.721]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:27.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:27.721]             base::names(...future.oldOptions))
[18:04:27.721]     }
[18:04:27.721]     if (FALSE) {
[18:04:27.721]     }
[18:04:27.721]     else {
[18:04:27.721]         if (TRUE) {
[18:04:27.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:27.721]                 open = "w")
[18:04:27.721]         }
[18:04:27.721]         else {
[18:04:27.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:27.721]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:27.721]         }
[18:04:27.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:27.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:27.721]             base::sink(type = "output", split = FALSE)
[18:04:27.721]             base::close(...future.stdout)
[18:04:27.721]         }, add = TRUE)
[18:04:27.721]     }
[18:04:27.721]     ...future.frame <- base::sys.nframe()
[18:04:27.721]     ...future.conditions <- base::list()
[18:04:27.721]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:27.721]     if (FALSE) {
[18:04:27.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:27.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:27.721]     }
[18:04:27.721]     ...future.result <- base::tryCatch({
[18:04:27.721]         base::withCallingHandlers({
[18:04:27.721]             ...future.value <- base::withVisible(base::local({
[18:04:27.721]                 withCallingHandlers({
[18:04:27.721]                   {
[18:04:27.721]                     lm(dist ~ . - 1, data = cars)
[18:04:27.721]                   }
[18:04:27.721]                 }, immediateCondition = function(cond) {
[18:04:27.721]                   save_rds <- function (object, pathname, ...) 
[18:04:27.721]                   {
[18:04:27.721]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:27.721]                     if (file_test("-f", pathname_tmp)) {
[18:04:27.721]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.721]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:27.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.721]                         fi_tmp[["mtime"]])
[18:04:27.721]                     }
[18:04:27.721]                     tryCatch({
[18:04:27.721]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:27.721]                     }, error = function(ex) {
[18:04:27.721]                       msg <- conditionMessage(ex)
[18:04:27.721]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.721]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:27.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.721]                         fi_tmp[["mtime"]], msg)
[18:04:27.721]                       ex$message <- msg
[18:04:27.721]                       stop(ex)
[18:04:27.721]                     })
[18:04:27.721]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:27.721]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:27.721]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:27.721]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.721]                       fi <- file.info(pathname)
[18:04:27.721]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:27.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.721]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:27.721]                         fi[["size"]], fi[["mtime"]])
[18:04:27.721]                       stop(msg)
[18:04:27.721]                     }
[18:04:27.721]                     invisible(pathname)
[18:04:27.721]                   }
[18:04:27.721]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:27.721]                     rootPath = tempdir()) 
[18:04:27.721]                   {
[18:04:27.721]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:27.721]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:27.721]                       tmpdir = path, fileext = ".rds")
[18:04:27.721]                     save_rds(obj, file)
[18:04:27.721]                   }
[18:04:27.721]                   saveImmediateCondition(cond, path = "/tmp/RtmpLRNsAG/.future/immediateConditions")
[18:04:27.721]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.721]                   {
[18:04:27.721]                     inherits <- base::inherits
[18:04:27.721]                     invokeRestart <- base::invokeRestart
[18:04:27.721]                     is.null <- base::is.null
[18:04:27.721]                     muffled <- FALSE
[18:04:27.721]                     if (inherits(cond, "message")) {
[18:04:27.721]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:27.721]                       if (muffled) 
[18:04:27.721]                         invokeRestart("muffleMessage")
[18:04:27.721]                     }
[18:04:27.721]                     else if (inherits(cond, "warning")) {
[18:04:27.721]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:27.721]                       if (muffled) 
[18:04:27.721]                         invokeRestart("muffleWarning")
[18:04:27.721]                     }
[18:04:27.721]                     else if (inherits(cond, "condition")) {
[18:04:27.721]                       if (!is.null(pattern)) {
[18:04:27.721]                         computeRestarts <- base::computeRestarts
[18:04:27.721]                         grepl <- base::grepl
[18:04:27.721]                         restarts <- computeRestarts(cond)
[18:04:27.721]                         for (restart in restarts) {
[18:04:27.721]                           name <- restart$name
[18:04:27.721]                           if (is.null(name)) 
[18:04:27.721]                             next
[18:04:27.721]                           if (!grepl(pattern, name)) 
[18:04:27.721]                             next
[18:04:27.721]                           invokeRestart(restart)
[18:04:27.721]                           muffled <- TRUE
[18:04:27.721]                           break
[18:04:27.721]                         }
[18:04:27.721]                       }
[18:04:27.721]                     }
[18:04:27.721]                     invisible(muffled)
[18:04:27.721]                   }
[18:04:27.721]                   muffleCondition(cond)
[18:04:27.721]                 })
[18:04:27.721]             }))
[18:04:27.721]             future::FutureResult(value = ...future.value$value, 
[18:04:27.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.721]                   ...future.rng), globalenv = if (FALSE) 
[18:04:27.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:27.721]                     ...future.globalenv.names))
[18:04:27.721]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:27.721]         }, condition = base::local({
[18:04:27.721]             c <- base::c
[18:04:27.721]             inherits <- base::inherits
[18:04:27.721]             invokeRestart <- base::invokeRestart
[18:04:27.721]             length <- base::length
[18:04:27.721]             list <- base::list
[18:04:27.721]             seq.int <- base::seq.int
[18:04:27.721]             signalCondition <- base::signalCondition
[18:04:27.721]             sys.calls <- base::sys.calls
[18:04:27.721]             `[[` <- base::`[[`
[18:04:27.721]             `+` <- base::`+`
[18:04:27.721]             `<<-` <- base::`<<-`
[18:04:27.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:27.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:27.721]                   3L)]
[18:04:27.721]             }
[18:04:27.721]             function(cond) {
[18:04:27.721]                 is_error <- inherits(cond, "error")
[18:04:27.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:27.721]                   NULL)
[18:04:27.721]                 if (is_error) {
[18:04:27.721]                   sessionInformation <- function() {
[18:04:27.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:27.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:27.721]                       search = base::search(), system = base::Sys.info())
[18:04:27.721]                   }
[18:04:27.721]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:27.721]                     cond$call), session = sessionInformation(), 
[18:04:27.721]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:27.721]                   signalCondition(cond)
[18:04:27.721]                 }
[18:04:27.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:27.721]                 "immediateCondition"))) {
[18:04:27.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:27.721]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:27.721]                   if (TRUE && !signal) {
[18:04:27.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.721]                     {
[18:04:27.721]                       inherits <- base::inherits
[18:04:27.721]                       invokeRestart <- base::invokeRestart
[18:04:27.721]                       is.null <- base::is.null
[18:04:27.721]                       muffled <- FALSE
[18:04:27.721]                       if (inherits(cond, "message")) {
[18:04:27.721]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.721]                         if (muffled) 
[18:04:27.721]                           invokeRestart("muffleMessage")
[18:04:27.721]                       }
[18:04:27.721]                       else if (inherits(cond, "warning")) {
[18:04:27.721]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.721]                         if (muffled) 
[18:04:27.721]                           invokeRestart("muffleWarning")
[18:04:27.721]                       }
[18:04:27.721]                       else if (inherits(cond, "condition")) {
[18:04:27.721]                         if (!is.null(pattern)) {
[18:04:27.721]                           computeRestarts <- base::computeRestarts
[18:04:27.721]                           grepl <- base::grepl
[18:04:27.721]                           restarts <- computeRestarts(cond)
[18:04:27.721]                           for (restart in restarts) {
[18:04:27.721]                             name <- restart$name
[18:04:27.721]                             if (is.null(name)) 
[18:04:27.721]                               next
[18:04:27.721]                             if (!grepl(pattern, name)) 
[18:04:27.721]                               next
[18:04:27.721]                             invokeRestart(restart)
[18:04:27.721]                             muffled <- TRUE
[18:04:27.721]                             break
[18:04:27.721]                           }
[18:04:27.721]                         }
[18:04:27.721]                       }
[18:04:27.721]                       invisible(muffled)
[18:04:27.721]                     }
[18:04:27.721]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.721]                   }
[18:04:27.721]                 }
[18:04:27.721]                 else {
[18:04:27.721]                   if (TRUE) {
[18:04:27.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.721]                     {
[18:04:27.721]                       inherits <- base::inherits
[18:04:27.721]                       invokeRestart <- base::invokeRestart
[18:04:27.721]                       is.null <- base::is.null
[18:04:27.721]                       muffled <- FALSE
[18:04:27.721]                       if (inherits(cond, "message")) {
[18:04:27.721]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.721]                         if (muffled) 
[18:04:27.721]                           invokeRestart("muffleMessage")
[18:04:27.721]                       }
[18:04:27.721]                       else if (inherits(cond, "warning")) {
[18:04:27.721]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.721]                         if (muffled) 
[18:04:27.721]                           invokeRestart("muffleWarning")
[18:04:27.721]                       }
[18:04:27.721]                       else if (inherits(cond, "condition")) {
[18:04:27.721]                         if (!is.null(pattern)) {
[18:04:27.721]                           computeRestarts <- base::computeRestarts
[18:04:27.721]                           grepl <- base::grepl
[18:04:27.721]                           restarts <- computeRestarts(cond)
[18:04:27.721]                           for (restart in restarts) {
[18:04:27.721]                             name <- restart$name
[18:04:27.721]                             if (is.null(name)) 
[18:04:27.721]                               next
[18:04:27.721]                             if (!grepl(pattern, name)) 
[18:04:27.721]                               next
[18:04:27.721]                             invokeRestart(restart)
[18:04:27.721]                             muffled <- TRUE
[18:04:27.721]                             break
[18:04:27.721]                           }
[18:04:27.721]                         }
[18:04:27.721]                       }
[18:04:27.721]                       invisible(muffled)
[18:04:27.721]                     }
[18:04:27.721]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.721]                   }
[18:04:27.721]                 }
[18:04:27.721]             }
[18:04:27.721]         }))
[18:04:27.721]     }, error = function(ex) {
[18:04:27.721]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:27.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.721]                 ...future.rng), started = ...future.startTime, 
[18:04:27.721]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:27.721]             version = "1.8"), class = "FutureResult")
[18:04:27.721]     }, finally = {
[18:04:27.721]         if (!identical(...future.workdir, getwd())) 
[18:04:27.721]             setwd(...future.workdir)
[18:04:27.721]         {
[18:04:27.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:27.721]                 ...future.oldOptions$nwarnings <- NULL
[18:04:27.721]             }
[18:04:27.721]             base::options(...future.oldOptions)
[18:04:27.721]             if (.Platform$OS.type == "windows") {
[18:04:27.721]                 old_names <- names(...future.oldEnvVars)
[18:04:27.721]                 envs <- base::Sys.getenv()
[18:04:27.721]                 names <- names(envs)
[18:04:27.721]                 common <- intersect(names, old_names)
[18:04:27.721]                 added <- setdiff(names, old_names)
[18:04:27.721]                 removed <- setdiff(old_names, names)
[18:04:27.721]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:27.721]                   envs[common]]
[18:04:27.721]                 NAMES <- toupper(changed)
[18:04:27.721]                 args <- list()
[18:04:27.721]                 for (kk in seq_along(NAMES)) {
[18:04:27.721]                   name <- changed[[kk]]
[18:04:27.721]                   NAME <- NAMES[[kk]]
[18:04:27.721]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.721]                     next
[18:04:27.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.721]                 }
[18:04:27.721]                 NAMES <- toupper(added)
[18:04:27.721]                 for (kk in seq_along(NAMES)) {
[18:04:27.721]                   name <- added[[kk]]
[18:04:27.721]                   NAME <- NAMES[[kk]]
[18:04:27.721]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.721]                     next
[18:04:27.721]                   args[[name]] <- ""
[18:04:27.721]                 }
[18:04:27.721]                 NAMES <- toupper(removed)
[18:04:27.721]                 for (kk in seq_along(NAMES)) {
[18:04:27.721]                   name <- removed[[kk]]
[18:04:27.721]                   NAME <- NAMES[[kk]]
[18:04:27.721]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.721]                     next
[18:04:27.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.721]                 }
[18:04:27.721]                 if (length(args) > 0) 
[18:04:27.721]                   base::do.call(base::Sys.setenv, args = args)
[18:04:27.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:27.721]             }
[18:04:27.721]             else {
[18:04:27.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:27.721]             }
[18:04:27.721]             {
[18:04:27.721]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:27.721]                   0L) {
[18:04:27.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:27.721]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:27.721]                   base::options(opts)
[18:04:27.721]                 }
[18:04:27.721]                 {
[18:04:27.721]                   {
[18:04:27.721]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:27.721]                     NULL
[18:04:27.721]                   }
[18:04:27.721]                   options(future.plan = NULL)
[18:04:27.721]                   if (is.na(NA_character_)) 
[18:04:27.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:27.721]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:27.721]                     .init = FALSE)
[18:04:27.721]                 }
[18:04:27.721]             }
[18:04:27.721]         }
[18:04:27.721]     })
[18:04:27.721]     if (TRUE) {
[18:04:27.721]         base::sink(type = "output", split = FALSE)
[18:04:27.721]         if (TRUE) {
[18:04:27.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:27.721]         }
[18:04:27.721]         else {
[18:04:27.721]             ...future.result["stdout"] <- base::list(NULL)
[18:04:27.721]         }
[18:04:27.721]         base::close(...future.stdout)
[18:04:27.721]         ...future.stdout <- NULL
[18:04:27.721]     }
[18:04:27.721]     ...future.result$conditions <- ...future.conditions
[18:04:27.721]     ...future.result$finished <- base::Sys.time()
[18:04:27.721]     ...future.result
[18:04:27.721] }
[18:04:27.726] requestCore(): workers = 2
[18:04:27.729] MulticoreFuture started
[18:04:27.730] - Launch lazy future ... done
[18:04:27.731] run() for ‘MulticoreFuture’ ... done
[18:04:27.731] result() for MulticoreFuture ...
[18:04:27.732] plan(): Setting new future strategy stack:
[18:04:27.733] List of future strategies:
[18:04:27.733] 1. sequential:
[18:04:27.733]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.733]    - tweaked: FALSE
[18:04:27.733]    - call: NULL
[18:04:27.736] plan(): nbrOfWorkers() = 1
[18:04:27.743] plan(): Setting new future strategy stack:
[18:04:27.744] List of future strategies:
[18:04:27.744] 1. multicore:
[18:04:27.744]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:27.744]    - tweaked: FALSE
[18:04:27.744]    - call: plan(strategy)
[18:04:27.754] plan(): nbrOfWorkers() = 2
[18:04:27.758] result() for MulticoreFuture ...
[18:04:27.758] result() for MulticoreFuture ... done
[18:04:27.758] result() for MulticoreFuture ... done
[18:04:27.759] result() for MulticoreFuture ...
[18:04:27.759] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[18:04:27.765] getGlobalsAndPackages() ...
[18:04:27.766] Searching for globals...
[18:04:27.770] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[18:04:27.770] Searching for globals ... DONE
[18:04:27.770] Resolving globals: FALSE
[18:04:27.772] 
[18:04:27.772] - packages: [2] ‘stats’, ‘datasets’
[18:04:27.772] getGlobalsAndPackages() ... DONE
[18:04:27.773] run() for ‘Future’ ...
[18:04:27.773] - state: ‘created’
[18:04:27.773] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:27.781] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:27.781] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:27.781]   - Field: ‘label’
[18:04:27.781]   - Field: ‘local’
[18:04:27.782]   - Field: ‘owner’
[18:04:27.782]   - Field: ‘envir’
[18:04:27.782]   - Field: ‘workers’
[18:04:27.782]   - Field: ‘packages’
[18:04:27.783]   - Field: ‘gc’
[18:04:27.783]   - Field: ‘job’
[18:04:27.783]   - Field: ‘conditions’
[18:04:27.783]   - Field: ‘expr’
[18:04:27.784]   - Field: ‘uuid’
[18:04:27.784]   - Field: ‘seed’
[18:04:27.784]   - Field: ‘version’
[18:04:27.784]   - Field: ‘result’
[18:04:27.784]   - Field: ‘asynchronous’
[18:04:27.785]   - Field: ‘calls’
[18:04:27.785]   - Field: ‘globals’
[18:04:27.785]   - Field: ‘stdout’
[18:04:27.785]   - Field: ‘earlySignal’
[18:04:27.786]   - Field: ‘lazy’
[18:04:27.786]   - Field: ‘state’
[18:04:27.786] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:27.786] - Launch lazy future ...
[18:04:27.787] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:27.787] Packages needed by future strategies (n = 0): <none>
[18:04:27.789] {
[18:04:27.789]     {
[18:04:27.789]         {
[18:04:27.789]             ...future.startTime <- base::Sys.time()
[18:04:27.789]             {
[18:04:27.789]                 {
[18:04:27.789]                   {
[18:04:27.789]                     {
[18:04:27.789]                       {
[18:04:27.789]                         base::local({
[18:04:27.789]                           has_future <- base::requireNamespace("future", 
[18:04:27.789]                             quietly = TRUE)
[18:04:27.789]                           if (has_future) {
[18:04:27.789]                             ns <- base::getNamespace("future")
[18:04:27.789]                             version <- ns[[".package"]][["version"]]
[18:04:27.789]                             if (is.null(version)) 
[18:04:27.789]                               version <- utils::packageVersion("future")
[18:04:27.789]                           }
[18:04:27.789]                           else {
[18:04:27.789]                             version <- NULL
[18:04:27.789]                           }
[18:04:27.789]                           if (!has_future || version < "1.8.0") {
[18:04:27.789]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:27.789]                               "", base::R.version$version.string), 
[18:04:27.789]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:27.789]                                 base::R.version$platform, 8 * 
[18:04:27.789]                                   base::.Machine$sizeof.pointer), 
[18:04:27.789]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:27.789]                                 "release", "version")], collapse = " "), 
[18:04:27.789]                               hostname = base::Sys.info()[["nodename"]])
[18:04:27.789]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:27.789]                               info)
[18:04:27.789]                             info <- base::paste(info, collapse = "; ")
[18:04:27.789]                             if (!has_future) {
[18:04:27.789]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:27.789]                                 info)
[18:04:27.789]                             }
[18:04:27.789]                             else {
[18:04:27.789]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:27.789]                                 info, version)
[18:04:27.789]                             }
[18:04:27.789]                             base::stop(msg)
[18:04:27.789]                           }
[18:04:27.789]                         })
[18:04:27.789]                       }
[18:04:27.789]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:27.789]                       base::options(mc.cores = 1L)
[18:04:27.789]                     }
[18:04:27.789]                     base::local({
[18:04:27.789]                       for (pkg in c("stats", "datasets")) {
[18:04:27.789]                         base::loadNamespace(pkg)
[18:04:27.789]                         base::library(pkg, character.only = TRUE)
[18:04:27.789]                       }
[18:04:27.789]                     })
[18:04:27.789]                   }
[18:04:27.789]                   ...future.strategy.old <- future::plan("list")
[18:04:27.789]                   options(future.plan = NULL)
[18:04:27.789]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.789]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:27.789]                 }
[18:04:27.789]                 ...future.workdir <- getwd()
[18:04:27.789]             }
[18:04:27.789]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:27.789]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:27.789]         }
[18:04:27.789]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:27.789]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:27.789]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:27.789]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:27.789]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:27.789]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:27.789]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:27.789]             base::names(...future.oldOptions))
[18:04:27.789]     }
[18:04:27.789]     if (FALSE) {
[18:04:27.789]     }
[18:04:27.789]     else {
[18:04:27.789]         if (TRUE) {
[18:04:27.789]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:27.789]                 open = "w")
[18:04:27.789]         }
[18:04:27.789]         else {
[18:04:27.789]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:27.789]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:27.789]         }
[18:04:27.789]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:27.789]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:27.789]             base::sink(type = "output", split = FALSE)
[18:04:27.789]             base::close(...future.stdout)
[18:04:27.789]         }, add = TRUE)
[18:04:27.789]     }
[18:04:27.789]     ...future.frame <- base::sys.nframe()
[18:04:27.789]     ...future.conditions <- base::list()
[18:04:27.789]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:27.789]     if (FALSE) {
[18:04:27.789]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:27.789]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:27.789]     }
[18:04:27.789]     ...future.result <- base::tryCatch({
[18:04:27.789]         base::withCallingHandlers({
[18:04:27.789]             ...future.value <- base::withVisible(base::local({
[18:04:27.789]                 withCallingHandlers({
[18:04:27.789]                   {
[18:04:27.789]                     lm(dist ~ . + 0, data = cars)
[18:04:27.789]                   }
[18:04:27.789]                 }, immediateCondition = function(cond) {
[18:04:27.789]                   save_rds <- function (object, pathname, ...) 
[18:04:27.789]                   {
[18:04:27.789]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:27.789]                     if (file_test("-f", pathname_tmp)) {
[18:04:27.789]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.789]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:27.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.789]                         fi_tmp[["mtime"]])
[18:04:27.789]                     }
[18:04:27.789]                     tryCatch({
[18:04:27.789]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:27.789]                     }, error = function(ex) {
[18:04:27.789]                       msg <- conditionMessage(ex)
[18:04:27.789]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.789]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:27.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.789]                         fi_tmp[["mtime"]], msg)
[18:04:27.789]                       ex$message <- msg
[18:04:27.789]                       stop(ex)
[18:04:27.789]                     })
[18:04:27.789]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:27.789]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:27.789]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:27.789]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.789]                       fi <- file.info(pathname)
[18:04:27.789]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:27.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.789]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:27.789]                         fi[["size"]], fi[["mtime"]])
[18:04:27.789]                       stop(msg)
[18:04:27.789]                     }
[18:04:27.789]                     invisible(pathname)
[18:04:27.789]                   }
[18:04:27.789]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:27.789]                     rootPath = tempdir()) 
[18:04:27.789]                   {
[18:04:27.789]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:27.789]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:27.789]                       tmpdir = path, fileext = ".rds")
[18:04:27.789]                     save_rds(obj, file)
[18:04:27.789]                   }
[18:04:27.789]                   saveImmediateCondition(cond, path = "/tmp/RtmpLRNsAG/.future/immediateConditions")
[18:04:27.789]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.789]                   {
[18:04:27.789]                     inherits <- base::inherits
[18:04:27.789]                     invokeRestart <- base::invokeRestart
[18:04:27.789]                     is.null <- base::is.null
[18:04:27.789]                     muffled <- FALSE
[18:04:27.789]                     if (inherits(cond, "message")) {
[18:04:27.789]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:27.789]                       if (muffled) 
[18:04:27.789]                         invokeRestart("muffleMessage")
[18:04:27.789]                     }
[18:04:27.789]                     else if (inherits(cond, "warning")) {
[18:04:27.789]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:27.789]                       if (muffled) 
[18:04:27.789]                         invokeRestart("muffleWarning")
[18:04:27.789]                     }
[18:04:27.789]                     else if (inherits(cond, "condition")) {
[18:04:27.789]                       if (!is.null(pattern)) {
[18:04:27.789]                         computeRestarts <- base::computeRestarts
[18:04:27.789]                         grepl <- base::grepl
[18:04:27.789]                         restarts <- computeRestarts(cond)
[18:04:27.789]                         for (restart in restarts) {
[18:04:27.789]                           name <- restart$name
[18:04:27.789]                           if (is.null(name)) 
[18:04:27.789]                             next
[18:04:27.789]                           if (!grepl(pattern, name)) 
[18:04:27.789]                             next
[18:04:27.789]                           invokeRestart(restart)
[18:04:27.789]                           muffled <- TRUE
[18:04:27.789]                           break
[18:04:27.789]                         }
[18:04:27.789]                       }
[18:04:27.789]                     }
[18:04:27.789]                     invisible(muffled)
[18:04:27.789]                   }
[18:04:27.789]                   muffleCondition(cond)
[18:04:27.789]                 })
[18:04:27.789]             }))
[18:04:27.789]             future::FutureResult(value = ...future.value$value, 
[18:04:27.789]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.789]                   ...future.rng), globalenv = if (FALSE) 
[18:04:27.789]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:27.789]                     ...future.globalenv.names))
[18:04:27.789]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:27.789]         }, condition = base::local({
[18:04:27.789]             c <- base::c
[18:04:27.789]             inherits <- base::inherits
[18:04:27.789]             invokeRestart <- base::invokeRestart
[18:04:27.789]             length <- base::length
[18:04:27.789]             list <- base::list
[18:04:27.789]             seq.int <- base::seq.int
[18:04:27.789]             signalCondition <- base::signalCondition
[18:04:27.789]             sys.calls <- base::sys.calls
[18:04:27.789]             `[[` <- base::`[[`
[18:04:27.789]             `+` <- base::`+`
[18:04:27.789]             `<<-` <- base::`<<-`
[18:04:27.789]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:27.789]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:27.789]                   3L)]
[18:04:27.789]             }
[18:04:27.789]             function(cond) {
[18:04:27.789]                 is_error <- inherits(cond, "error")
[18:04:27.789]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:27.789]                   NULL)
[18:04:27.789]                 if (is_error) {
[18:04:27.789]                   sessionInformation <- function() {
[18:04:27.789]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:27.789]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:27.789]                       search = base::search(), system = base::Sys.info())
[18:04:27.789]                   }
[18:04:27.789]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.789]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:27.789]                     cond$call), session = sessionInformation(), 
[18:04:27.789]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:27.789]                   signalCondition(cond)
[18:04:27.789]                 }
[18:04:27.789]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:27.789]                 "immediateCondition"))) {
[18:04:27.789]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:27.789]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.789]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:27.789]                   if (TRUE && !signal) {
[18:04:27.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.789]                     {
[18:04:27.789]                       inherits <- base::inherits
[18:04:27.789]                       invokeRestart <- base::invokeRestart
[18:04:27.789]                       is.null <- base::is.null
[18:04:27.789]                       muffled <- FALSE
[18:04:27.789]                       if (inherits(cond, "message")) {
[18:04:27.789]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.789]                         if (muffled) 
[18:04:27.789]                           invokeRestart("muffleMessage")
[18:04:27.789]                       }
[18:04:27.789]                       else if (inherits(cond, "warning")) {
[18:04:27.789]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.789]                         if (muffled) 
[18:04:27.789]                           invokeRestart("muffleWarning")
[18:04:27.789]                       }
[18:04:27.789]                       else if (inherits(cond, "condition")) {
[18:04:27.789]                         if (!is.null(pattern)) {
[18:04:27.789]                           computeRestarts <- base::computeRestarts
[18:04:27.789]                           grepl <- base::grepl
[18:04:27.789]                           restarts <- computeRestarts(cond)
[18:04:27.789]                           for (restart in restarts) {
[18:04:27.789]                             name <- restart$name
[18:04:27.789]                             if (is.null(name)) 
[18:04:27.789]                               next
[18:04:27.789]                             if (!grepl(pattern, name)) 
[18:04:27.789]                               next
[18:04:27.789]                             invokeRestart(restart)
[18:04:27.789]                             muffled <- TRUE
[18:04:27.789]                             break
[18:04:27.789]                           }
[18:04:27.789]                         }
[18:04:27.789]                       }
[18:04:27.789]                       invisible(muffled)
[18:04:27.789]                     }
[18:04:27.789]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.789]                   }
[18:04:27.789]                 }
[18:04:27.789]                 else {
[18:04:27.789]                   if (TRUE) {
[18:04:27.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.789]                     {
[18:04:27.789]                       inherits <- base::inherits
[18:04:27.789]                       invokeRestart <- base::invokeRestart
[18:04:27.789]                       is.null <- base::is.null
[18:04:27.789]                       muffled <- FALSE
[18:04:27.789]                       if (inherits(cond, "message")) {
[18:04:27.789]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.789]                         if (muffled) 
[18:04:27.789]                           invokeRestart("muffleMessage")
[18:04:27.789]                       }
[18:04:27.789]                       else if (inherits(cond, "warning")) {
[18:04:27.789]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.789]                         if (muffled) 
[18:04:27.789]                           invokeRestart("muffleWarning")
[18:04:27.789]                       }
[18:04:27.789]                       else if (inherits(cond, "condition")) {
[18:04:27.789]                         if (!is.null(pattern)) {
[18:04:27.789]                           computeRestarts <- base::computeRestarts
[18:04:27.789]                           grepl <- base::grepl
[18:04:27.789]                           restarts <- computeRestarts(cond)
[18:04:27.789]                           for (restart in restarts) {
[18:04:27.789]                             name <- restart$name
[18:04:27.789]                             if (is.null(name)) 
[18:04:27.789]                               next
[18:04:27.789]                             if (!grepl(pattern, name)) 
[18:04:27.789]                               next
[18:04:27.789]                             invokeRestart(restart)
[18:04:27.789]                             muffled <- TRUE
[18:04:27.789]                             break
[18:04:27.789]                           }
[18:04:27.789]                         }
[18:04:27.789]                       }
[18:04:27.789]                       invisible(muffled)
[18:04:27.789]                     }
[18:04:27.789]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.789]                   }
[18:04:27.789]                 }
[18:04:27.789]             }
[18:04:27.789]         }))
[18:04:27.789]     }, error = function(ex) {
[18:04:27.789]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:27.789]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.789]                 ...future.rng), started = ...future.startTime, 
[18:04:27.789]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:27.789]             version = "1.8"), class = "FutureResult")
[18:04:27.789]     }, finally = {
[18:04:27.789]         if (!identical(...future.workdir, getwd())) 
[18:04:27.789]             setwd(...future.workdir)
[18:04:27.789]         {
[18:04:27.789]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:27.789]                 ...future.oldOptions$nwarnings <- NULL
[18:04:27.789]             }
[18:04:27.789]             base::options(...future.oldOptions)
[18:04:27.789]             if (.Platform$OS.type == "windows") {
[18:04:27.789]                 old_names <- names(...future.oldEnvVars)
[18:04:27.789]                 envs <- base::Sys.getenv()
[18:04:27.789]                 names <- names(envs)
[18:04:27.789]                 common <- intersect(names, old_names)
[18:04:27.789]                 added <- setdiff(names, old_names)
[18:04:27.789]                 removed <- setdiff(old_names, names)
[18:04:27.789]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:27.789]                   envs[common]]
[18:04:27.789]                 NAMES <- toupper(changed)
[18:04:27.789]                 args <- list()
[18:04:27.789]                 for (kk in seq_along(NAMES)) {
[18:04:27.789]                   name <- changed[[kk]]
[18:04:27.789]                   NAME <- NAMES[[kk]]
[18:04:27.789]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.789]                     next
[18:04:27.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.789]                 }
[18:04:27.789]                 NAMES <- toupper(added)
[18:04:27.789]                 for (kk in seq_along(NAMES)) {
[18:04:27.789]                   name <- added[[kk]]
[18:04:27.789]                   NAME <- NAMES[[kk]]
[18:04:27.789]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.789]                     next
[18:04:27.789]                   args[[name]] <- ""
[18:04:27.789]                 }
[18:04:27.789]                 NAMES <- toupper(removed)
[18:04:27.789]                 for (kk in seq_along(NAMES)) {
[18:04:27.789]                   name <- removed[[kk]]
[18:04:27.789]                   NAME <- NAMES[[kk]]
[18:04:27.789]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.789]                     next
[18:04:27.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.789]                 }
[18:04:27.789]                 if (length(args) > 0) 
[18:04:27.789]                   base::do.call(base::Sys.setenv, args = args)
[18:04:27.789]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:27.789]             }
[18:04:27.789]             else {
[18:04:27.789]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:27.789]             }
[18:04:27.789]             {
[18:04:27.789]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:27.789]                   0L) {
[18:04:27.789]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:27.789]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:27.789]                   base::options(opts)
[18:04:27.789]                 }
[18:04:27.789]                 {
[18:04:27.789]                   {
[18:04:27.789]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:27.789]                     NULL
[18:04:27.789]                   }
[18:04:27.789]                   options(future.plan = NULL)
[18:04:27.789]                   if (is.na(NA_character_)) 
[18:04:27.789]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.789]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:27.789]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:27.789]                     .init = FALSE)
[18:04:27.789]                 }
[18:04:27.789]             }
[18:04:27.789]         }
[18:04:27.789]     })
[18:04:27.789]     if (TRUE) {
[18:04:27.789]         base::sink(type = "output", split = FALSE)
[18:04:27.789]         if (TRUE) {
[18:04:27.789]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:27.789]         }
[18:04:27.789]         else {
[18:04:27.789]             ...future.result["stdout"] <- base::list(NULL)
[18:04:27.789]         }
[18:04:27.789]         base::close(...future.stdout)
[18:04:27.789]         ...future.stdout <- NULL
[18:04:27.789]     }
[18:04:27.789]     ...future.result$conditions <- ...future.conditions
[18:04:27.789]     ...future.result$finished <- base::Sys.time()
[18:04:27.789]     ...future.result
[18:04:27.789] }
[18:04:27.793] requestCore(): workers = 2
[18:04:27.797] MulticoreFuture started
[18:04:27.798] - Launch lazy future ... done
[18:04:27.798] run() for ‘MulticoreFuture’ ... done
[18:04:27.799] result() for MulticoreFuture ...
[18:04:27.800] plan(): Setting new future strategy stack:
[18:04:27.800] List of future strategies:
[18:04:27.800] 1. sequential:
[18:04:27.800]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.800]    - tweaked: FALSE
[18:04:27.800]    - call: NULL
[18:04:27.803] plan(): nbrOfWorkers() = 1
[18:04:27.814] plan(): Setting new future strategy stack:
[18:04:27.814] List of future strategies:
[18:04:27.814] 1. multicore:
[18:04:27.814]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:27.814]    - tweaked: FALSE
[18:04:27.814]    - call: plan(strategy)
[18:04:27.828] plan(): nbrOfWorkers() = 2
[18:04:27.833] result() for MulticoreFuture ...
[18:04:27.833] result() for MulticoreFuture ... done
[18:04:27.833] result() for MulticoreFuture ... done
[18:04:27.834] result() for MulticoreFuture ...
[18:04:27.834] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[18:04:27.840] getGlobalsAndPackages() ...
[18:04:27.841] Searching for globals...
[18:04:27.849] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[18:04:27.850] Searching for globals ... DONE
[18:04:27.850] Resolving globals: FALSE
[18:04:27.851] 
[18:04:27.851] - packages: [2] ‘stats’, ‘datasets’
[18:04:27.852] getGlobalsAndPackages() ... DONE
[18:04:27.852] run() for ‘Future’ ...
[18:04:27.853] - state: ‘created’
[18:04:27.853] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:27.860] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:27.861] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:27.861]   - Field: ‘label’
[18:04:27.861]   - Field: ‘local’
[18:04:27.862]   - Field: ‘owner’
[18:04:27.862]   - Field: ‘envir’
[18:04:27.862]   - Field: ‘workers’
[18:04:27.862]   - Field: ‘packages’
[18:04:27.862]   - Field: ‘gc’
[18:04:27.863]   - Field: ‘job’
[18:04:27.863]   - Field: ‘conditions’
[18:04:27.863]   - Field: ‘expr’
[18:04:27.863]   - Field: ‘uuid’
[18:04:27.864]   - Field: ‘seed’
[18:04:27.864]   - Field: ‘version’
[18:04:27.864]   - Field: ‘result’
[18:04:27.864]   - Field: ‘asynchronous’
[18:04:27.865]   - Field: ‘calls’
[18:04:27.865]   - Field: ‘globals’
[18:04:27.865]   - Field: ‘stdout’
[18:04:27.865]   - Field: ‘earlySignal’
[18:04:27.866]   - Field: ‘lazy’
[18:04:27.866]   - Field: ‘state’
[18:04:27.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:27.866] - Launch lazy future ...
[18:04:27.867] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:27.867] Packages needed by future strategies (n = 0): <none>
[18:04:27.869] {
[18:04:27.869]     {
[18:04:27.869]         {
[18:04:27.869]             ...future.startTime <- base::Sys.time()
[18:04:27.869]             {
[18:04:27.869]                 {
[18:04:27.869]                   {
[18:04:27.869]                     {
[18:04:27.869]                       {
[18:04:27.869]                         base::local({
[18:04:27.869]                           has_future <- base::requireNamespace("future", 
[18:04:27.869]                             quietly = TRUE)
[18:04:27.869]                           if (has_future) {
[18:04:27.869]                             ns <- base::getNamespace("future")
[18:04:27.869]                             version <- ns[[".package"]][["version"]]
[18:04:27.869]                             if (is.null(version)) 
[18:04:27.869]                               version <- utils::packageVersion("future")
[18:04:27.869]                           }
[18:04:27.869]                           else {
[18:04:27.869]                             version <- NULL
[18:04:27.869]                           }
[18:04:27.869]                           if (!has_future || version < "1.8.0") {
[18:04:27.869]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:27.869]                               "", base::R.version$version.string), 
[18:04:27.869]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:27.869]                                 base::R.version$platform, 8 * 
[18:04:27.869]                                   base::.Machine$sizeof.pointer), 
[18:04:27.869]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:27.869]                                 "release", "version")], collapse = " "), 
[18:04:27.869]                               hostname = base::Sys.info()[["nodename"]])
[18:04:27.869]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:27.869]                               info)
[18:04:27.869]                             info <- base::paste(info, collapse = "; ")
[18:04:27.869]                             if (!has_future) {
[18:04:27.869]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:27.869]                                 info)
[18:04:27.869]                             }
[18:04:27.869]                             else {
[18:04:27.869]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:27.869]                                 info, version)
[18:04:27.869]                             }
[18:04:27.869]                             base::stop(msg)
[18:04:27.869]                           }
[18:04:27.869]                         })
[18:04:27.869]                       }
[18:04:27.869]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:27.869]                       base::options(mc.cores = 1L)
[18:04:27.869]                     }
[18:04:27.869]                     base::local({
[18:04:27.869]                       for (pkg in c("stats", "datasets")) {
[18:04:27.869]                         base::loadNamespace(pkg)
[18:04:27.869]                         base::library(pkg, character.only = TRUE)
[18:04:27.869]                       }
[18:04:27.869]                     })
[18:04:27.869]                   }
[18:04:27.869]                   ...future.strategy.old <- future::plan("list")
[18:04:27.869]                   options(future.plan = NULL)
[18:04:27.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:27.869]                 }
[18:04:27.869]                 ...future.workdir <- getwd()
[18:04:27.869]             }
[18:04:27.869]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:27.869]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:27.869]         }
[18:04:27.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:27.869]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:27.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:27.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:27.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:27.869]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:27.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:27.869]             base::names(...future.oldOptions))
[18:04:27.869]     }
[18:04:27.869]     if (FALSE) {
[18:04:27.869]     }
[18:04:27.869]     else {
[18:04:27.869]         if (TRUE) {
[18:04:27.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:27.869]                 open = "w")
[18:04:27.869]         }
[18:04:27.869]         else {
[18:04:27.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:27.869]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:27.869]         }
[18:04:27.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:27.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:27.869]             base::sink(type = "output", split = FALSE)
[18:04:27.869]             base::close(...future.stdout)
[18:04:27.869]         }, add = TRUE)
[18:04:27.869]     }
[18:04:27.869]     ...future.frame <- base::sys.nframe()
[18:04:27.869]     ...future.conditions <- base::list()
[18:04:27.869]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:27.869]     if (FALSE) {
[18:04:27.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:27.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:27.869]     }
[18:04:27.869]     ...future.result <- base::tryCatch({
[18:04:27.869]         base::withCallingHandlers({
[18:04:27.869]             ...future.value <- base::withVisible(base::local({
[18:04:27.869]                 withCallingHandlers({
[18:04:27.869]                   {
[18:04:27.869]                     lm(dist ~ speed + speed^2, data = cars)
[18:04:27.869]                   }
[18:04:27.869]                 }, immediateCondition = function(cond) {
[18:04:27.869]                   save_rds <- function (object, pathname, ...) 
[18:04:27.869]                   {
[18:04:27.869]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:27.869]                     if (file_test("-f", pathname_tmp)) {
[18:04:27.869]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.869]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:27.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.869]                         fi_tmp[["mtime"]])
[18:04:27.869]                     }
[18:04:27.869]                     tryCatch({
[18:04:27.869]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:27.869]                     }, error = function(ex) {
[18:04:27.869]                       msg <- conditionMessage(ex)
[18:04:27.869]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.869]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:27.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.869]                         fi_tmp[["mtime"]], msg)
[18:04:27.869]                       ex$message <- msg
[18:04:27.869]                       stop(ex)
[18:04:27.869]                     })
[18:04:27.869]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:27.869]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:27.869]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:27.869]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.869]                       fi <- file.info(pathname)
[18:04:27.869]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:27.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.869]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:27.869]                         fi[["size"]], fi[["mtime"]])
[18:04:27.869]                       stop(msg)
[18:04:27.869]                     }
[18:04:27.869]                     invisible(pathname)
[18:04:27.869]                   }
[18:04:27.869]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:27.869]                     rootPath = tempdir()) 
[18:04:27.869]                   {
[18:04:27.869]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:27.869]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:27.869]                       tmpdir = path, fileext = ".rds")
[18:04:27.869]                     save_rds(obj, file)
[18:04:27.869]                   }
[18:04:27.869]                   saveImmediateCondition(cond, path = "/tmp/RtmpLRNsAG/.future/immediateConditions")
[18:04:27.869]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.869]                   {
[18:04:27.869]                     inherits <- base::inherits
[18:04:27.869]                     invokeRestart <- base::invokeRestart
[18:04:27.869]                     is.null <- base::is.null
[18:04:27.869]                     muffled <- FALSE
[18:04:27.869]                     if (inherits(cond, "message")) {
[18:04:27.869]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:27.869]                       if (muffled) 
[18:04:27.869]                         invokeRestart("muffleMessage")
[18:04:27.869]                     }
[18:04:27.869]                     else if (inherits(cond, "warning")) {
[18:04:27.869]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:27.869]                       if (muffled) 
[18:04:27.869]                         invokeRestart("muffleWarning")
[18:04:27.869]                     }
[18:04:27.869]                     else if (inherits(cond, "condition")) {
[18:04:27.869]                       if (!is.null(pattern)) {
[18:04:27.869]                         computeRestarts <- base::computeRestarts
[18:04:27.869]                         grepl <- base::grepl
[18:04:27.869]                         restarts <- computeRestarts(cond)
[18:04:27.869]                         for (restart in restarts) {
[18:04:27.869]                           name <- restart$name
[18:04:27.869]                           if (is.null(name)) 
[18:04:27.869]                             next
[18:04:27.869]                           if (!grepl(pattern, name)) 
[18:04:27.869]                             next
[18:04:27.869]                           invokeRestart(restart)
[18:04:27.869]                           muffled <- TRUE
[18:04:27.869]                           break
[18:04:27.869]                         }
[18:04:27.869]                       }
[18:04:27.869]                     }
[18:04:27.869]                     invisible(muffled)
[18:04:27.869]                   }
[18:04:27.869]                   muffleCondition(cond)
[18:04:27.869]                 })
[18:04:27.869]             }))
[18:04:27.869]             future::FutureResult(value = ...future.value$value, 
[18:04:27.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.869]                   ...future.rng), globalenv = if (FALSE) 
[18:04:27.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:27.869]                     ...future.globalenv.names))
[18:04:27.869]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:27.869]         }, condition = base::local({
[18:04:27.869]             c <- base::c
[18:04:27.869]             inherits <- base::inherits
[18:04:27.869]             invokeRestart <- base::invokeRestart
[18:04:27.869]             length <- base::length
[18:04:27.869]             list <- base::list
[18:04:27.869]             seq.int <- base::seq.int
[18:04:27.869]             signalCondition <- base::signalCondition
[18:04:27.869]             sys.calls <- base::sys.calls
[18:04:27.869]             `[[` <- base::`[[`
[18:04:27.869]             `+` <- base::`+`
[18:04:27.869]             `<<-` <- base::`<<-`
[18:04:27.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:27.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:27.869]                   3L)]
[18:04:27.869]             }
[18:04:27.869]             function(cond) {
[18:04:27.869]                 is_error <- inherits(cond, "error")
[18:04:27.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:27.869]                   NULL)
[18:04:27.869]                 if (is_error) {
[18:04:27.869]                   sessionInformation <- function() {
[18:04:27.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:27.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:27.869]                       search = base::search(), system = base::Sys.info())
[18:04:27.869]                   }
[18:04:27.869]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:27.869]                     cond$call), session = sessionInformation(), 
[18:04:27.869]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:27.869]                   signalCondition(cond)
[18:04:27.869]                 }
[18:04:27.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:27.869]                 "immediateCondition"))) {
[18:04:27.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:27.869]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:27.869]                   if (TRUE && !signal) {
[18:04:27.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.869]                     {
[18:04:27.869]                       inherits <- base::inherits
[18:04:27.869]                       invokeRestart <- base::invokeRestart
[18:04:27.869]                       is.null <- base::is.null
[18:04:27.869]                       muffled <- FALSE
[18:04:27.869]                       if (inherits(cond, "message")) {
[18:04:27.869]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.869]                         if (muffled) 
[18:04:27.869]                           invokeRestart("muffleMessage")
[18:04:27.869]                       }
[18:04:27.869]                       else if (inherits(cond, "warning")) {
[18:04:27.869]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.869]                         if (muffled) 
[18:04:27.869]                           invokeRestart("muffleWarning")
[18:04:27.869]                       }
[18:04:27.869]                       else if (inherits(cond, "condition")) {
[18:04:27.869]                         if (!is.null(pattern)) {
[18:04:27.869]                           computeRestarts <- base::computeRestarts
[18:04:27.869]                           grepl <- base::grepl
[18:04:27.869]                           restarts <- computeRestarts(cond)
[18:04:27.869]                           for (restart in restarts) {
[18:04:27.869]                             name <- restart$name
[18:04:27.869]                             if (is.null(name)) 
[18:04:27.869]                               next
[18:04:27.869]                             if (!grepl(pattern, name)) 
[18:04:27.869]                               next
[18:04:27.869]                             invokeRestart(restart)
[18:04:27.869]                             muffled <- TRUE
[18:04:27.869]                             break
[18:04:27.869]                           }
[18:04:27.869]                         }
[18:04:27.869]                       }
[18:04:27.869]                       invisible(muffled)
[18:04:27.869]                     }
[18:04:27.869]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.869]                   }
[18:04:27.869]                 }
[18:04:27.869]                 else {
[18:04:27.869]                   if (TRUE) {
[18:04:27.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.869]                     {
[18:04:27.869]                       inherits <- base::inherits
[18:04:27.869]                       invokeRestart <- base::invokeRestart
[18:04:27.869]                       is.null <- base::is.null
[18:04:27.869]                       muffled <- FALSE
[18:04:27.869]                       if (inherits(cond, "message")) {
[18:04:27.869]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.869]                         if (muffled) 
[18:04:27.869]                           invokeRestart("muffleMessage")
[18:04:27.869]                       }
[18:04:27.869]                       else if (inherits(cond, "warning")) {
[18:04:27.869]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.869]                         if (muffled) 
[18:04:27.869]                           invokeRestart("muffleWarning")
[18:04:27.869]                       }
[18:04:27.869]                       else if (inherits(cond, "condition")) {
[18:04:27.869]                         if (!is.null(pattern)) {
[18:04:27.869]                           computeRestarts <- base::computeRestarts
[18:04:27.869]                           grepl <- base::grepl
[18:04:27.869]                           restarts <- computeRestarts(cond)
[18:04:27.869]                           for (restart in restarts) {
[18:04:27.869]                             name <- restart$name
[18:04:27.869]                             if (is.null(name)) 
[18:04:27.869]                               next
[18:04:27.869]                             if (!grepl(pattern, name)) 
[18:04:27.869]                               next
[18:04:27.869]                             invokeRestart(restart)
[18:04:27.869]                             muffled <- TRUE
[18:04:27.869]                             break
[18:04:27.869]                           }
[18:04:27.869]                         }
[18:04:27.869]                       }
[18:04:27.869]                       invisible(muffled)
[18:04:27.869]                     }
[18:04:27.869]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.869]                   }
[18:04:27.869]                 }
[18:04:27.869]             }
[18:04:27.869]         }))
[18:04:27.869]     }, error = function(ex) {
[18:04:27.869]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:27.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.869]                 ...future.rng), started = ...future.startTime, 
[18:04:27.869]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:27.869]             version = "1.8"), class = "FutureResult")
[18:04:27.869]     }, finally = {
[18:04:27.869]         if (!identical(...future.workdir, getwd())) 
[18:04:27.869]             setwd(...future.workdir)
[18:04:27.869]         {
[18:04:27.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:27.869]                 ...future.oldOptions$nwarnings <- NULL
[18:04:27.869]             }
[18:04:27.869]             base::options(...future.oldOptions)
[18:04:27.869]             if (.Platform$OS.type == "windows") {
[18:04:27.869]                 old_names <- names(...future.oldEnvVars)
[18:04:27.869]                 envs <- base::Sys.getenv()
[18:04:27.869]                 names <- names(envs)
[18:04:27.869]                 common <- intersect(names, old_names)
[18:04:27.869]                 added <- setdiff(names, old_names)
[18:04:27.869]                 removed <- setdiff(old_names, names)
[18:04:27.869]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:27.869]                   envs[common]]
[18:04:27.869]                 NAMES <- toupper(changed)
[18:04:27.869]                 args <- list()
[18:04:27.869]                 for (kk in seq_along(NAMES)) {
[18:04:27.869]                   name <- changed[[kk]]
[18:04:27.869]                   NAME <- NAMES[[kk]]
[18:04:27.869]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.869]                     next
[18:04:27.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.869]                 }
[18:04:27.869]                 NAMES <- toupper(added)
[18:04:27.869]                 for (kk in seq_along(NAMES)) {
[18:04:27.869]                   name <- added[[kk]]
[18:04:27.869]                   NAME <- NAMES[[kk]]
[18:04:27.869]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.869]                     next
[18:04:27.869]                   args[[name]] <- ""
[18:04:27.869]                 }
[18:04:27.869]                 NAMES <- toupper(removed)
[18:04:27.869]                 for (kk in seq_along(NAMES)) {
[18:04:27.869]                   name <- removed[[kk]]
[18:04:27.869]                   NAME <- NAMES[[kk]]
[18:04:27.869]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.869]                     next
[18:04:27.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.869]                 }
[18:04:27.869]                 if (length(args) > 0) 
[18:04:27.869]                   base::do.call(base::Sys.setenv, args = args)
[18:04:27.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:27.869]             }
[18:04:27.869]             else {
[18:04:27.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:27.869]             }
[18:04:27.869]             {
[18:04:27.869]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:27.869]                   0L) {
[18:04:27.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:27.869]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:27.869]                   base::options(opts)
[18:04:27.869]                 }
[18:04:27.869]                 {
[18:04:27.869]                   {
[18:04:27.869]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:27.869]                     NULL
[18:04:27.869]                   }
[18:04:27.869]                   options(future.plan = NULL)
[18:04:27.869]                   if (is.na(NA_character_)) 
[18:04:27.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:27.869]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:27.869]                     .init = FALSE)
[18:04:27.869]                 }
[18:04:27.869]             }
[18:04:27.869]         }
[18:04:27.869]     })
[18:04:27.869]     if (TRUE) {
[18:04:27.869]         base::sink(type = "output", split = FALSE)
[18:04:27.869]         if (TRUE) {
[18:04:27.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:27.869]         }
[18:04:27.869]         else {
[18:04:27.869]             ...future.result["stdout"] <- base::list(NULL)
[18:04:27.869]         }
[18:04:27.869]         base::close(...future.stdout)
[18:04:27.869]         ...future.stdout <- NULL
[18:04:27.869]     }
[18:04:27.869]     ...future.result$conditions <- ...future.conditions
[18:04:27.869]     ...future.result$finished <- base::Sys.time()
[18:04:27.869]     ...future.result
[18:04:27.869] }
[18:04:27.874] requestCore(): workers = 2
[18:04:27.877] MulticoreFuture started
[18:04:27.878] - Launch lazy future ... done
[18:04:27.878] run() for ‘MulticoreFuture’ ... done
[18:04:27.883] result() for MulticoreFuture ...
[18:04:27.883] plan(): Setting new future strategy stack:
[18:04:27.885] List of future strategies:
[18:04:27.885] 1. sequential:
[18:04:27.885]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:27.885]    - tweaked: FALSE
[18:04:27.885]    - call: NULL
[18:04:27.887] plan(): nbrOfWorkers() = 1
[18:04:27.895] plan(): Setting new future strategy stack:
[18:04:27.895] List of future strategies:
[18:04:27.895] 1. multicore:
[18:04:27.895]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:27.895]    - tweaked: FALSE
[18:04:27.895]    - call: plan(strategy)
[18:04:27.905] plan(): nbrOfWorkers() = 2
[18:04:27.911] result() for MulticoreFuture ...
[18:04:27.912] result() for MulticoreFuture ... done
[18:04:27.912] result() for MulticoreFuture ... done
[18:04:27.912] result() for MulticoreFuture ...
[18:04:27.913] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[18:04:27.920] getGlobalsAndPackages() ...
[18:04:27.921] Searching for globals...
[18:04:27.926] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[18:04:27.927] Searching for globals ... DONE
[18:04:27.927] Resolving globals: FALSE
[18:04:27.928] 
[18:04:27.929] - packages: [2] ‘stats’, ‘datasets’
[18:04:27.929] getGlobalsAndPackages() ... DONE
[18:04:27.930] run() for ‘Future’ ...
[18:04:27.930] - state: ‘created’
[18:04:27.930] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:27.937] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:27.938] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:27.938]   - Field: ‘label’
[18:04:27.938]   - Field: ‘local’
[18:04:27.939]   - Field: ‘owner’
[18:04:27.939]   - Field: ‘envir’
[18:04:27.939]   - Field: ‘workers’
[18:04:27.939]   - Field: ‘packages’
[18:04:27.940]   - Field: ‘gc’
[18:04:27.940]   - Field: ‘job’
[18:04:27.940]   - Field: ‘conditions’
[18:04:27.940]   - Field: ‘expr’
[18:04:27.941]   - Field: ‘uuid’
[18:04:27.941]   - Field: ‘seed’
[18:04:27.941]   - Field: ‘version’
[18:04:27.941]   - Field: ‘result’
[18:04:27.942]   - Field: ‘asynchronous’
[18:04:27.942]   - Field: ‘calls’
[18:04:27.942]   - Field: ‘globals’
[18:04:27.942]   - Field: ‘stdout’
[18:04:27.943]   - Field: ‘earlySignal’
[18:04:27.943]   - Field: ‘lazy’
[18:04:27.943]   - Field: ‘state’
[18:04:27.943] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:27.944] - Launch lazy future ...
[18:04:27.988] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:27.988] Packages needed by future strategies (n = 0): <none>
[18:04:27.989] {
[18:04:27.989]     {
[18:04:27.989]         {
[18:04:27.989]             ...future.startTime <- base::Sys.time()
[18:04:27.989]             {
[18:04:27.989]                 {
[18:04:27.989]                   {
[18:04:27.989]                     {
[18:04:27.989]                       {
[18:04:27.989]                         base::local({
[18:04:27.989]                           has_future <- base::requireNamespace("future", 
[18:04:27.989]                             quietly = TRUE)
[18:04:27.989]                           if (has_future) {
[18:04:27.989]                             ns <- base::getNamespace("future")
[18:04:27.989]                             version <- ns[[".package"]][["version"]]
[18:04:27.989]                             if (is.null(version)) 
[18:04:27.989]                               version <- utils::packageVersion("future")
[18:04:27.989]                           }
[18:04:27.989]                           else {
[18:04:27.989]                             version <- NULL
[18:04:27.989]                           }
[18:04:27.989]                           if (!has_future || version < "1.8.0") {
[18:04:27.989]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:27.989]                               "", base::R.version$version.string), 
[18:04:27.989]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:27.989]                                 base::R.version$platform, 8 * 
[18:04:27.989]                                   base::.Machine$sizeof.pointer), 
[18:04:27.989]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:27.989]                                 "release", "version")], collapse = " "), 
[18:04:27.989]                               hostname = base::Sys.info()[["nodename"]])
[18:04:27.989]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:27.989]                               info)
[18:04:27.989]                             info <- base::paste(info, collapse = "; ")
[18:04:27.989]                             if (!has_future) {
[18:04:27.989]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:27.989]                                 info)
[18:04:27.989]                             }
[18:04:27.989]                             else {
[18:04:27.989]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:27.989]                                 info, version)
[18:04:27.989]                             }
[18:04:27.989]                             base::stop(msg)
[18:04:27.989]                           }
[18:04:27.989]                         })
[18:04:27.989]                       }
[18:04:27.989]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:27.989]                       base::options(mc.cores = 1L)
[18:04:27.989]                     }
[18:04:27.989]                     base::local({
[18:04:27.989]                       for (pkg in c("stats", "datasets")) {
[18:04:27.989]                         base::loadNamespace(pkg)
[18:04:27.989]                         base::library(pkg, character.only = TRUE)
[18:04:27.989]                       }
[18:04:27.989]                     })
[18:04:27.989]                   }
[18:04:27.989]                   ...future.strategy.old <- future::plan("list")
[18:04:27.989]                   options(future.plan = NULL)
[18:04:27.989]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.989]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:27.989]                 }
[18:04:27.989]                 ...future.workdir <- getwd()
[18:04:27.989]             }
[18:04:27.989]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:27.989]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:27.989]         }
[18:04:27.989]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:27.989]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:27.989]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:27.989]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:27.989]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:27.989]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:27.989]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:27.989]             base::names(...future.oldOptions))
[18:04:27.989]     }
[18:04:27.989]     if (FALSE) {
[18:04:27.989]     }
[18:04:27.989]     else {
[18:04:27.989]         if (TRUE) {
[18:04:27.989]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:27.989]                 open = "w")
[18:04:27.989]         }
[18:04:27.989]         else {
[18:04:27.989]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:27.989]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:27.989]         }
[18:04:27.989]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:27.989]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:27.989]             base::sink(type = "output", split = FALSE)
[18:04:27.989]             base::close(...future.stdout)
[18:04:27.989]         }, add = TRUE)
[18:04:27.989]     }
[18:04:27.989]     ...future.frame <- base::sys.nframe()
[18:04:27.989]     ...future.conditions <- base::list()
[18:04:27.989]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:27.989]     if (FALSE) {
[18:04:27.989]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:27.989]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:27.989]     }
[18:04:27.989]     ...future.result <- base::tryCatch({
[18:04:27.989]         base::withCallingHandlers({
[18:04:27.989]             ...future.value <- base::withVisible(base::local({
[18:04:27.989]                 withCallingHandlers({
[18:04:27.989]                   {
[18:04:27.989]                     lm(dist ~ speed + I(speed^2), data = cars)
[18:04:27.989]                   }
[18:04:27.989]                 }, immediateCondition = function(cond) {
[18:04:27.989]                   save_rds <- function (object, pathname, ...) 
[18:04:27.989]                   {
[18:04:27.989]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:27.989]                     if (file_test("-f", pathname_tmp)) {
[18:04:27.989]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.989]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:27.989]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.989]                         fi_tmp[["mtime"]])
[18:04:27.989]                     }
[18:04:27.989]                     tryCatch({
[18:04:27.989]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:27.989]                     }, error = function(ex) {
[18:04:27.989]                       msg <- conditionMessage(ex)
[18:04:27.989]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.989]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:27.989]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.989]                         fi_tmp[["mtime"]], msg)
[18:04:27.989]                       ex$message <- msg
[18:04:27.989]                       stop(ex)
[18:04:27.989]                     })
[18:04:27.989]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:27.989]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:27.989]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:27.989]                       fi_tmp <- file.info(pathname_tmp)
[18:04:27.989]                       fi <- file.info(pathname)
[18:04:27.989]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:27.989]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:27.989]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:27.989]                         fi[["size"]], fi[["mtime"]])
[18:04:27.989]                       stop(msg)
[18:04:27.989]                     }
[18:04:27.989]                     invisible(pathname)
[18:04:27.989]                   }
[18:04:27.989]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:27.989]                     rootPath = tempdir()) 
[18:04:27.989]                   {
[18:04:27.989]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:27.989]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:27.989]                       tmpdir = path, fileext = ".rds")
[18:04:27.989]                     save_rds(obj, file)
[18:04:27.989]                   }
[18:04:27.989]                   saveImmediateCondition(cond, path = "/tmp/RtmpLRNsAG/.future/immediateConditions")
[18:04:27.989]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.989]                   {
[18:04:27.989]                     inherits <- base::inherits
[18:04:27.989]                     invokeRestart <- base::invokeRestart
[18:04:27.989]                     is.null <- base::is.null
[18:04:27.989]                     muffled <- FALSE
[18:04:27.989]                     if (inherits(cond, "message")) {
[18:04:27.989]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:27.989]                       if (muffled) 
[18:04:27.989]                         invokeRestart("muffleMessage")
[18:04:27.989]                     }
[18:04:27.989]                     else if (inherits(cond, "warning")) {
[18:04:27.989]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:27.989]                       if (muffled) 
[18:04:27.989]                         invokeRestart("muffleWarning")
[18:04:27.989]                     }
[18:04:27.989]                     else if (inherits(cond, "condition")) {
[18:04:27.989]                       if (!is.null(pattern)) {
[18:04:27.989]                         computeRestarts <- base::computeRestarts
[18:04:27.989]                         grepl <- base::grepl
[18:04:27.989]                         restarts <- computeRestarts(cond)
[18:04:27.989]                         for (restart in restarts) {
[18:04:27.989]                           name <- restart$name
[18:04:27.989]                           if (is.null(name)) 
[18:04:27.989]                             next
[18:04:27.989]                           if (!grepl(pattern, name)) 
[18:04:27.989]                             next
[18:04:27.989]                           invokeRestart(restart)
[18:04:27.989]                           muffled <- TRUE
[18:04:27.989]                           break
[18:04:27.989]                         }
[18:04:27.989]                       }
[18:04:27.989]                     }
[18:04:27.989]                     invisible(muffled)
[18:04:27.989]                   }
[18:04:27.989]                   muffleCondition(cond)
[18:04:27.989]                 })
[18:04:27.989]             }))
[18:04:27.989]             future::FutureResult(value = ...future.value$value, 
[18:04:27.989]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.989]                   ...future.rng), globalenv = if (FALSE) 
[18:04:27.989]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:27.989]                     ...future.globalenv.names))
[18:04:27.989]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:27.989]         }, condition = base::local({
[18:04:27.989]             c <- base::c
[18:04:27.989]             inherits <- base::inherits
[18:04:27.989]             invokeRestart <- base::invokeRestart
[18:04:27.989]             length <- base::length
[18:04:27.989]             list <- base::list
[18:04:27.989]             seq.int <- base::seq.int
[18:04:27.989]             signalCondition <- base::signalCondition
[18:04:27.989]             sys.calls <- base::sys.calls
[18:04:27.989]             `[[` <- base::`[[`
[18:04:27.989]             `+` <- base::`+`
[18:04:27.989]             `<<-` <- base::`<<-`
[18:04:27.989]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:27.989]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:27.989]                   3L)]
[18:04:27.989]             }
[18:04:27.989]             function(cond) {
[18:04:27.989]                 is_error <- inherits(cond, "error")
[18:04:27.989]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:27.989]                   NULL)
[18:04:27.989]                 if (is_error) {
[18:04:27.989]                   sessionInformation <- function() {
[18:04:27.989]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:27.989]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:27.989]                       search = base::search(), system = base::Sys.info())
[18:04:27.989]                   }
[18:04:27.989]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.989]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:27.989]                     cond$call), session = sessionInformation(), 
[18:04:27.989]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:27.989]                   signalCondition(cond)
[18:04:27.989]                 }
[18:04:27.989]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:27.989]                 "immediateCondition"))) {
[18:04:27.989]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:27.989]                   ...future.conditions[[length(...future.conditions) + 
[18:04:27.989]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:27.989]                   if (TRUE && !signal) {
[18:04:27.989]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.989]                     {
[18:04:27.989]                       inherits <- base::inherits
[18:04:27.989]                       invokeRestart <- base::invokeRestart
[18:04:27.989]                       is.null <- base::is.null
[18:04:27.989]                       muffled <- FALSE
[18:04:27.989]                       if (inherits(cond, "message")) {
[18:04:27.989]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.989]                         if (muffled) 
[18:04:27.989]                           invokeRestart("muffleMessage")
[18:04:27.989]                       }
[18:04:27.989]                       else if (inherits(cond, "warning")) {
[18:04:27.989]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.989]                         if (muffled) 
[18:04:27.989]                           invokeRestart("muffleWarning")
[18:04:27.989]                       }
[18:04:27.989]                       else if (inherits(cond, "condition")) {
[18:04:27.989]                         if (!is.null(pattern)) {
[18:04:27.989]                           computeRestarts <- base::computeRestarts
[18:04:27.989]                           grepl <- base::grepl
[18:04:27.989]                           restarts <- computeRestarts(cond)
[18:04:27.989]                           for (restart in restarts) {
[18:04:27.989]                             name <- restart$name
[18:04:27.989]                             if (is.null(name)) 
[18:04:27.989]                               next
[18:04:27.989]                             if (!grepl(pattern, name)) 
[18:04:27.989]                               next
[18:04:27.989]                             invokeRestart(restart)
[18:04:27.989]                             muffled <- TRUE
[18:04:27.989]                             break
[18:04:27.989]                           }
[18:04:27.989]                         }
[18:04:27.989]                       }
[18:04:27.989]                       invisible(muffled)
[18:04:27.989]                     }
[18:04:27.989]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.989]                   }
[18:04:27.989]                 }
[18:04:27.989]                 else {
[18:04:27.989]                   if (TRUE) {
[18:04:27.989]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:27.989]                     {
[18:04:27.989]                       inherits <- base::inherits
[18:04:27.989]                       invokeRestart <- base::invokeRestart
[18:04:27.989]                       is.null <- base::is.null
[18:04:27.989]                       muffled <- FALSE
[18:04:27.989]                       if (inherits(cond, "message")) {
[18:04:27.989]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:27.989]                         if (muffled) 
[18:04:27.989]                           invokeRestart("muffleMessage")
[18:04:27.989]                       }
[18:04:27.989]                       else if (inherits(cond, "warning")) {
[18:04:27.989]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:27.989]                         if (muffled) 
[18:04:27.989]                           invokeRestart("muffleWarning")
[18:04:27.989]                       }
[18:04:27.989]                       else if (inherits(cond, "condition")) {
[18:04:27.989]                         if (!is.null(pattern)) {
[18:04:27.989]                           computeRestarts <- base::computeRestarts
[18:04:27.989]                           grepl <- base::grepl
[18:04:27.989]                           restarts <- computeRestarts(cond)
[18:04:27.989]                           for (restart in restarts) {
[18:04:27.989]                             name <- restart$name
[18:04:27.989]                             if (is.null(name)) 
[18:04:27.989]                               next
[18:04:27.989]                             if (!grepl(pattern, name)) 
[18:04:27.989]                               next
[18:04:27.989]                             invokeRestart(restart)
[18:04:27.989]                             muffled <- TRUE
[18:04:27.989]                             break
[18:04:27.989]                           }
[18:04:27.989]                         }
[18:04:27.989]                       }
[18:04:27.989]                       invisible(muffled)
[18:04:27.989]                     }
[18:04:27.989]                     muffleCondition(cond, pattern = "^muffle")
[18:04:27.989]                   }
[18:04:27.989]                 }
[18:04:27.989]             }
[18:04:27.989]         }))
[18:04:27.989]     }, error = function(ex) {
[18:04:27.989]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:27.989]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:27.989]                 ...future.rng), started = ...future.startTime, 
[18:04:27.989]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:27.989]             version = "1.8"), class = "FutureResult")
[18:04:27.989]     }, finally = {
[18:04:27.989]         if (!identical(...future.workdir, getwd())) 
[18:04:27.989]             setwd(...future.workdir)
[18:04:27.989]         {
[18:04:27.989]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:27.989]                 ...future.oldOptions$nwarnings <- NULL
[18:04:27.989]             }
[18:04:27.989]             base::options(...future.oldOptions)
[18:04:27.989]             if (.Platform$OS.type == "windows") {
[18:04:27.989]                 old_names <- names(...future.oldEnvVars)
[18:04:27.989]                 envs <- base::Sys.getenv()
[18:04:27.989]                 names <- names(envs)
[18:04:27.989]                 common <- intersect(names, old_names)
[18:04:27.989]                 added <- setdiff(names, old_names)
[18:04:27.989]                 removed <- setdiff(old_names, names)
[18:04:27.989]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:27.989]                   envs[common]]
[18:04:27.989]                 NAMES <- toupper(changed)
[18:04:27.989]                 args <- list()
[18:04:27.989]                 for (kk in seq_along(NAMES)) {
[18:04:27.989]                   name <- changed[[kk]]
[18:04:27.989]                   NAME <- NAMES[[kk]]
[18:04:27.989]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.989]                     next
[18:04:27.989]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.989]                 }
[18:04:27.989]                 NAMES <- toupper(added)
[18:04:27.989]                 for (kk in seq_along(NAMES)) {
[18:04:27.989]                   name <- added[[kk]]
[18:04:27.989]                   NAME <- NAMES[[kk]]
[18:04:27.989]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.989]                     next
[18:04:27.989]                   args[[name]] <- ""
[18:04:27.989]                 }
[18:04:27.989]                 NAMES <- toupper(removed)
[18:04:27.989]                 for (kk in seq_along(NAMES)) {
[18:04:27.989]                   name <- removed[[kk]]
[18:04:27.989]                   NAME <- NAMES[[kk]]
[18:04:27.989]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:27.989]                     next
[18:04:27.989]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:27.989]                 }
[18:04:27.989]                 if (length(args) > 0) 
[18:04:27.989]                   base::do.call(base::Sys.setenv, args = args)
[18:04:27.989]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:27.989]             }
[18:04:27.989]             else {
[18:04:27.989]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:27.989]             }
[18:04:27.989]             {
[18:04:27.989]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:27.989]                   0L) {
[18:04:27.989]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:27.989]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:27.989]                   base::options(opts)
[18:04:27.989]                 }
[18:04:27.989]                 {
[18:04:27.989]                   {
[18:04:27.989]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:27.989]                     NULL
[18:04:27.989]                   }
[18:04:27.989]                   options(future.plan = NULL)
[18:04:27.989]                   if (is.na(NA_character_)) 
[18:04:27.989]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:27.989]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:27.989]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:27.989]                     .init = FALSE)
[18:04:27.989]                 }
[18:04:27.989]             }
[18:04:27.989]         }
[18:04:27.989]     })
[18:04:27.989]     if (TRUE) {
[18:04:27.989]         base::sink(type = "output", split = FALSE)
[18:04:27.989]         if (TRUE) {
[18:04:27.989]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:27.989]         }
[18:04:27.989]         else {
[18:04:27.989]             ...future.result["stdout"] <- base::list(NULL)
[18:04:27.989]         }
[18:04:27.989]         base::close(...future.stdout)
[18:04:27.989]         ...future.stdout <- NULL
[18:04:27.989]     }
[18:04:27.989]     ...future.result$conditions <- ...future.conditions
[18:04:27.989]     ...future.result$finished <- base::Sys.time()
[18:04:27.989]     ...future.result
[18:04:27.989] }
[18:04:27.994] requestCore(): workers = 2
[18:04:27.997] MulticoreFuture started
[18:04:27.999] - Launch lazy future ... done
[18:04:27.999] run() for ‘MulticoreFuture’ ... done
[18:04:28.000] result() for MulticoreFuture ...
[18:04:28.004] plan(): Setting new future strategy stack:
[18:04:28.004] List of future strategies:
[18:04:28.004] 1. sequential:
[18:04:28.004]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:28.004]    - tweaked: FALSE
[18:04:28.004]    - call: NULL
[18:04:28.007] plan(): nbrOfWorkers() = 1
[18:04:28.017] plan(): Setting new future strategy stack:
[18:04:28.017] List of future strategies:
[18:04:28.017] 1. multicore:
[18:04:28.017]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:28.017]    - tweaked: FALSE
[18:04:28.017]    - call: plan(strategy)
[18:04:28.028] plan(): nbrOfWorkers() = 2
[18:04:28.034] result() for MulticoreFuture ...
[18:04:28.034] result() for MulticoreFuture ... done
[18:04:28.035] result() for MulticoreFuture ... done
[18:04:28.035] result() for MulticoreFuture ...
[18:04:28.035] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[18:04:28.044] getGlobalsAndPackages() ...
[18:04:28.045] Searching for globals...
[18:04:28.049] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[18:04:28.049] Searching for globals ... DONE
[18:04:28.049] Resolving globals: FALSE
[18:04:28.050] 
[18:04:28.051] - packages: [2] ‘stats’, ‘datasets’
[18:04:28.051] getGlobalsAndPackages() ... DONE
[18:04:28.052] run() for ‘Future’ ...
[18:04:28.052] - state: ‘created’
[18:04:28.052] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:28.059] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:28.060] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:28.060]   - Field: ‘label’
[18:04:28.060]   - Field: ‘local’
[18:04:28.060]   - Field: ‘owner’
[18:04:28.061]   - Field: ‘envir’
[18:04:28.061]   - Field: ‘workers’
[18:04:28.061]   - Field: ‘packages’
[18:04:28.061]   - Field: ‘gc’
[18:04:28.062]   - Field: ‘job’
[18:04:28.062]   - Field: ‘conditions’
[18:04:28.062]   - Field: ‘expr’
[18:04:28.062]   - Field: ‘uuid’
[18:04:28.063]   - Field: ‘seed’
[18:04:28.063]   - Field: ‘version’
[18:04:28.063]   - Field: ‘result’
[18:04:28.063]   - Field: ‘asynchronous’
[18:04:28.063]   - Field: ‘calls’
[18:04:28.064]   - Field: ‘globals’
[18:04:28.064]   - Field: ‘stdout’
[18:04:28.064]   - Field: ‘earlySignal’
[18:04:28.064]   - Field: ‘lazy’
[18:04:28.065]   - Field: ‘state’
[18:04:28.065] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:28.065] - Launch lazy future ...
[18:04:28.066] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:28.066] Packages needed by future strategies (n = 0): <none>
[18:04:28.067] {
[18:04:28.067]     {
[18:04:28.067]         {
[18:04:28.067]             ...future.startTime <- base::Sys.time()
[18:04:28.067]             {
[18:04:28.067]                 {
[18:04:28.067]                   {
[18:04:28.067]                     {
[18:04:28.067]                       {
[18:04:28.067]                         base::local({
[18:04:28.067]                           has_future <- base::requireNamespace("future", 
[18:04:28.067]                             quietly = TRUE)
[18:04:28.067]                           if (has_future) {
[18:04:28.067]                             ns <- base::getNamespace("future")
[18:04:28.067]                             version <- ns[[".package"]][["version"]]
[18:04:28.067]                             if (is.null(version)) 
[18:04:28.067]                               version <- utils::packageVersion("future")
[18:04:28.067]                           }
[18:04:28.067]                           else {
[18:04:28.067]                             version <- NULL
[18:04:28.067]                           }
[18:04:28.067]                           if (!has_future || version < "1.8.0") {
[18:04:28.067]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:28.067]                               "", base::R.version$version.string), 
[18:04:28.067]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:28.067]                                 base::R.version$platform, 8 * 
[18:04:28.067]                                   base::.Machine$sizeof.pointer), 
[18:04:28.067]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:28.067]                                 "release", "version")], collapse = " "), 
[18:04:28.067]                               hostname = base::Sys.info()[["nodename"]])
[18:04:28.067]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:28.067]                               info)
[18:04:28.067]                             info <- base::paste(info, collapse = "; ")
[18:04:28.067]                             if (!has_future) {
[18:04:28.067]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:28.067]                                 info)
[18:04:28.067]                             }
[18:04:28.067]                             else {
[18:04:28.067]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:28.067]                                 info, version)
[18:04:28.067]                             }
[18:04:28.067]                             base::stop(msg)
[18:04:28.067]                           }
[18:04:28.067]                         })
[18:04:28.067]                       }
[18:04:28.067]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:28.067]                       base::options(mc.cores = 1L)
[18:04:28.067]                     }
[18:04:28.067]                     base::local({
[18:04:28.067]                       for (pkg in c("stats", "datasets")) {
[18:04:28.067]                         base::loadNamespace(pkg)
[18:04:28.067]                         base::library(pkg, character.only = TRUE)
[18:04:28.067]                       }
[18:04:28.067]                     })
[18:04:28.067]                   }
[18:04:28.067]                   ...future.strategy.old <- future::plan("list")
[18:04:28.067]                   options(future.plan = NULL)
[18:04:28.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:28.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:28.067]                 }
[18:04:28.067]                 ...future.workdir <- getwd()
[18:04:28.067]             }
[18:04:28.067]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:28.067]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:28.067]         }
[18:04:28.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:28.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:28.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:28.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:28.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:28.067]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:28.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:28.067]             base::names(...future.oldOptions))
[18:04:28.067]     }
[18:04:28.067]     if (FALSE) {
[18:04:28.067]     }
[18:04:28.067]     else {
[18:04:28.067]         if (TRUE) {
[18:04:28.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:28.067]                 open = "w")
[18:04:28.067]         }
[18:04:28.067]         else {
[18:04:28.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:28.067]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:28.067]         }
[18:04:28.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:28.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:28.067]             base::sink(type = "output", split = FALSE)
[18:04:28.067]             base::close(...future.stdout)
[18:04:28.067]         }, add = TRUE)
[18:04:28.067]     }
[18:04:28.067]     ...future.frame <- base::sys.nframe()
[18:04:28.067]     ...future.conditions <- base::list()
[18:04:28.067]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:28.067]     if (FALSE) {
[18:04:28.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:28.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:28.067]     }
[18:04:28.067]     ...future.result <- base::tryCatch({
[18:04:28.067]         base::withCallingHandlers({
[18:04:28.067]             ...future.value <- base::withVisible(base::local({
[18:04:28.067]                 withCallingHandlers({
[18:04:28.067]                   {
[18:04:28.067]                     lm(dist ~ poly(speed, 2), data = cars)
[18:04:28.067]                   }
[18:04:28.067]                 }, immediateCondition = function(cond) {
[18:04:28.067]                   save_rds <- function (object, pathname, ...) 
[18:04:28.067]                   {
[18:04:28.067]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:28.067]                     if (file_test("-f", pathname_tmp)) {
[18:04:28.067]                       fi_tmp <- file.info(pathname_tmp)
[18:04:28.067]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:28.067]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:28.067]                         fi_tmp[["mtime"]])
[18:04:28.067]                     }
[18:04:28.067]                     tryCatch({
[18:04:28.067]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:28.067]                     }, error = function(ex) {
[18:04:28.067]                       msg <- conditionMessage(ex)
[18:04:28.067]                       fi_tmp <- file.info(pathname_tmp)
[18:04:28.067]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:28.067]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:28.067]                         fi_tmp[["mtime"]], msg)
[18:04:28.067]                       ex$message <- msg
[18:04:28.067]                       stop(ex)
[18:04:28.067]                     })
[18:04:28.067]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:28.067]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:28.067]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:28.067]                       fi_tmp <- file.info(pathname_tmp)
[18:04:28.067]                       fi <- file.info(pathname)
[18:04:28.067]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:28.067]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:28.067]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:28.067]                         fi[["size"]], fi[["mtime"]])
[18:04:28.067]                       stop(msg)
[18:04:28.067]                     }
[18:04:28.067]                     invisible(pathname)
[18:04:28.067]                   }
[18:04:28.067]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:28.067]                     rootPath = tempdir()) 
[18:04:28.067]                   {
[18:04:28.067]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:28.067]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:28.067]                       tmpdir = path, fileext = ".rds")
[18:04:28.067]                     save_rds(obj, file)
[18:04:28.067]                   }
[18:04:28.067]                   saveImmediateCondition(cond, path = "/tmp/RtmpLRNsAG/.future/immediateConditions")
[18:04:28.067]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:28.067]                   {
[18:04:28.067]                     inherits <- base::inherits
[18:04:28.067]                     invokeRestart <- base::invokeRestart
[18:04:28.067]                     is.null <- base::is.null
[18:04:28.067]                     muffled <- FALSE
[18:04:28.067]                     if (inherits(cond, "message")) {
[18:04:28.067]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:28.067]                       if (muffled) 
[18:04:28.067]                         invokeRestart("muffleMessage")
[18:04:28.067]                     }
[18:04:28.067]                     else if (inherits(cond, "warning")) {
[18:04:28.067]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:28.067]                       if (muffled) 
[18:04:28.067]                         invokeRestart("muffleWarning")
[18:04:28.067]                     }
[18:04:28.067]                     else if (inherits(cond, "condition")) {
[18:04:28.067]                       if (!is.null(pattern)) {
[18:04:28.067]                         computeRestarts <- base::computeRestarts
[18:04:28.067]                         grepl <- base::grepl
[18:04:28.067]                         restarts <- computeRestarts(cond)
[18:04:28.067]                         for (restart in restarts) {
[18:04:28.067]                           name <- restart$name
[18:04:28.067]                           if (is.null(name)) 
[18:04:28.067]                             next
[18:04:28.067]                           if (!grepl(pattern, name)) 
[18:04:28.067]                             next
[18:04:28.067]                           invokeRestart(restart)
[18:04:28.067]                           muffled <- TRUE
[18:04:28.067]                           break
[18:04:28.067]                         }
[18:04:28.067]                       }
[18:04:28.067]                     }
[18:04:28.067]                     invisible(muffled)
[18:04:28.067]                   }
[18:04:28.067]                   muffleCondition(cond)
[18:04:28.067]                 })
[18:04:28.067]             }))
[18:04:28.067]             future::FutureResult(value = ...future.value$value, 
[18:04:28.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:28.067]                   ...future.rng), globalenv = if (FALSE) 
[18:04:28.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:28.067]                     ...future.globalenv.names))
[18:04:28.067]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:28.067]         }, condition = base::local({
[18:04:28.067]             c <- base::c
[18:04:28.067]             inherits <- base::inherits
[18:04:28.067]             invokeRestart <- base::invokeRestart
[18:04:28.067]             length <- base::length
[18:04:28.067]             list <- base::list
[18:04:28.067]             seq.int <- base::seq.int
[18:04:28.067]             signalCondition <- base::signalCondition
[18:04:28.067]             sys.calls <- base::sys.calls
[18:04:28.067]             `[[` <- base::`[[`
[18:04:28.067]             `+` <- base::`+`
[18:04:28.067]             `<<-` <- base::`<<-`
[18:04:28.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:28.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:28.067]                   3L)]
[18:04:28.067]             }
[18:04:28.067]             function(cond) {
[18:04:28.067]                 is_error <- inherits(cond, "error")
[18:04:28.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:28.067]                   NULL)
[18:04:28.067]                 if (is_error) {
[18:04:28.067]                   sessionInformation <- function() {
[18:04:28.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:28.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:28.067]                       search = base::search(), system = base::Sys.info())
[18:04:28.067]                   }
[18:04:28.067]                   ...future.conditions[[length(...future.conditions) + 
[18:04:28.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:28.067]                     cond$call), session = sessionInformation(), 
[18:04:28.067]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:28.067]                   signalCondition(cond)
[18:04:28.067]                 }
[18:04:28.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:28.067]                 "immediateCondition"))) {
[18:04:28.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:28.067]                   ...future.conditions[[length(...future.conditions) + 
[18:04:28.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:28.067]                   if (TRUE && !signal) {
[18:04:28.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:28.067]                     {
[18:04:28.067]                       inherits <- base::inherits
[18:04:28.067]                       invokeRestart <- base::invokeRestart
[18:04:28.067]                       is.null <- base::is.null
[18:04:28.067]                       muffled <- FALSE
[18:04:28.067]                       if (inherits(cond, "message")) {
[18:04:28.067]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:28.067]                         if (muffled) 
[18:04:28.067]                           invokeRestart("muffleMessage")
[18:04:28.067]                       }
[18:04:28.067]                       else if (inherits(cond, "warning")) {
[18:04:28.067]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:28.067]                         if (muffled) 
[18:04:28.067]                           invokeRestart("muffleWarning")
[18:04:28.067]                       }
[18:04:28.067]                       else if (inherits(cond, "condition")) {
[18:04:28.067]                         if (!is.null(pattern)) {
[18:04:28.067]                           computeRestarts <- base::computeRestarts
[18:04:28.067]                           grepl <- base::grepl
[18:04:28.067]                           restarts <- computeRestarts(cond)
[18:04:28.067]                           for (restart in restarts) {
[18:04:28.067]                             name <- restart$name
[18:04:28.067]                             if (is.null(name)) 
[18:04:28.067]                               next
[18:04:28.067]                             if (!grepl(pattern, name)) 
[18:04:28.067]                               next
[18:04:28.067]                             invokeRestart(restart)
[18:04:28.067]                             muffled <- TRUE
[18:04:28.067]                             break
[18:04:28.067]                           }
[18:04:28.067]                         }
[18:04:28.067]                       }
[18:04:28.067]                       invisible(muffled)
[18:04:28.067]                     }
[18:04:28.067]                     muffleCondition(cond, pattern = "^muffle")
[18:04:28.067]                   }
[18:04:28.067]                 }
[18:04:28.067]                 else {
[18:04:28.067]                   if (TRUE) {
[18:04:28.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:28.067]                     {
[18:04:28.067]                       inherits <- base::inherits
[18:04:28.067]                       invokeRestart <- base::invokeRestart
[18:04:28.067]                       is.null <- base::is.null
[18:04:28.067]                       muffled <- FALSE
[18:04:28.067]                       if (inherits(cond, "message")) {
[18:04:28.067]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:28.067]                         if (muffled) 
[18:04:28.067]                           invokeRestart("muffleMessage")
[18:04:28.067]                       }
[18:04:28.067]                       else if (inherits(cond, "warning")) {
[18:04:28.067]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:28.067]                         if (muffled) 
[18:04:28.067]                           invokeRestart("muffleWarning")
[18:04:28.067]                       }
[18:04:28.067]                       else if (inherits(cond, "condition")) {
[18:04:28.067]                         if (!is.null(pattern)) {
[18:04:28.067]                           computeRestarts <- base::computeRestarts
[18:04:28.067]                           grepl <- base::grepl
[18:04:28.067]                           restarts <- computeRestarts(cond)
[18:04:28.067]                           for (restart in restarts) {
[18:04:28.067]                             name <- restart$name
[18:04:28.067]                             if (is.null(name)) 
[18:04:28.067]                               next
[18:04:28.067]                             if (!grepl(pattern, name)) 
[18:04:28.067]                               next
[18:04:28.067]                             invokeRestart(restart)
[18:04:28.067]                             muffled <- TRUE
[18:04:28.067]                             break
[18:04:28.067]                           }
[18:04:28.067]                         }
[18:04:28.067]                       }
[18:04:28.067]                       invisible(muffled)
[18:04:28.067]                     }
[18:04:28.067]                     muffleCondition(cond, pattern = "^muffle")
[18:04:28.067]                   }
[18:04:28.067]                 }
[18:04:28.067]             }
[18:04:28.067]         }))
[18:04:28.067]     }, error = function(ex) {
[18:04:28.067]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:28.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:28.067]                 ...future.rng), started = ...future.startTime, 
[18:04:28.067]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:28.067]             version = "1.8"), class = "FutureResult")
[18:04:28.067]     }, finally = {
[18:04:28.067]         if (!identical(...future.workdir, getwd())) 
[18:04:28.067]             setwd(...future.workdir)
[18:04:28.067]         {
[18:04:28.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:28.067]                 ...future.oldOptions$nwarnings <- NULL
[18:04:28.067]             }
[18:04:28.067]             base::options(...future.oldOptions)
[18:04:28.067]             if (.Platform$OS.type == "windows") {
[18:04:28.067]                 old_names <- names(...future.oldEnvVars)
[18:04:28.067]                 envs <- base::Sys.getenv()
[18:04:28.067]                 names <- names(envs)
[18:04:28.067]                 common <- intersect(names, old_names)
[18:04:28.067]                 added <- setdiff(names, old_names)
[18:04:28.067]                 removed <- setdiff(old_names, names)
[18:04:28.067]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:28.067]                   envs[common]]
[18:04:28.067]                 NAMES <- toupper(changed)
[18:04:28.067]                 args <- list()
[18:04:28.067]                 for (kk in seq_along(NAMES)) {
[18:04:28.067]                   name <- changed[[kk]]
[18:04:28.067]                   NAME <- NAMES[[kk]]
[18:04:28.067]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:28.067]                     next
[18:04:28.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:28.067]                 }
[18:04:28.067]                 NAMES <- toupper(added)
[18:04:28.067]                 for (kk in seq_along(NAMES)) {
[18:04:28.067]                   name <- added[[kk]]
[18:04:28.067]                   NAME <- NAMES[[kk]]
[18:04:28.067]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:28.067]                     next
[18:04:28.067]                   args[[name]] <- ""
[18:04:28.067]                 }
[18:04:28.067]                 NAMES <- toupper(removed)
[18:04:28.067]                 for (kk in seq_along(NAMES)) {
[18:04:28.067]                   name <- removed[[kk]]
[18:04:28.067]                   NAME <- NAMES[[kk]]
[18:04:28.067]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:28.067]                     next
[18:04:28.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:28.067]                 }
[18:04:28.067]                 if (length(args) > 0) 
[18:04:28.067]                   base::do.call(base::Sys.setenv, args = args)
[18:04:28.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:28.067]             }
[18:04:28.067]             else {
[18:04:28.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:28.067]             }
[18:04:28.067]             {
[18:04:28.067]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:28.067]                   0L) {
[18:04:28.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:28.067]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:28.067]                   base::options(opts)
[18:04:28.067]                 }
[18:04:28.067]                 {
[18:04:28.067]                   {
[18:04:28.067]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:28.067]                     NULL
[18:04:28.067]                   }
[18:04:28.067]                   options(future.plan = NULL)
[18:04:28.067]                   if (is.na(NA_character_)) 
[18:04:28.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:28.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:28.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:28.067]                     .init = FALSE)
[18:04:28.067]                 }
[18:04:28.067]             }
[18:04:28.067]         }
[18:04:28.067]     })
[18:04:28.067]     if (TRUE) {
[18:04:28.067]         base::sink(type = "output", split = FALSE)
[18:04:28.067]         if (TRUE) {
[18:04:28.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:28.067]         }
[18:04:28.067]         else {
[18:04:28.067]             ...future.result["stdout"] <- base::list(NULL)
[18:04:28.067]         }
[18:04:28.067]         base::close(...future.stdout)
[18:04:28.067]         ...future.stdout <- NULL
[18:04:28.067]     }
[18:04:28.067]     ...future.result$conditions <- ...future.conditions
[18:04:28.067]     ...future.result$finished <- base::Sys.time()
[18:04:28.067]     ...future.result
[18:04:28.067] }
[18:04:28.072] requestCore(): workers = 2
[18:04:28.076] MulticoreFuture started
[18:04:28.076] - Launch lazy future ... done
[18:04:28.077] run() for ‘MulticoreFuture’ ... done
[18:04:28.078] result() for MulticoreFuture ...
[18:04:28.079] plan(): Setting new future strategy stack:
[18:04:28.079] List of future strategies:
[18:04:28.079] 1. sequential:
[18:04:28.079]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:28.079]    - tweaked: FALSE
[18:04:28.079]    - call: NULL
[18:04:28.082] plan(): nbrOfWorkers() = 1
[18:04:28.090] plan(): Setting new future strategy stack:
[18:04:28.091] List of future strategies:
[18:04:28.091] 1. multicore:
[18:04:28.091]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:28.091]    - tweaked: FALSE
[18:04:28.091]    - call: plan(strategy)
[18:04:28.100] plan(): nbrOfWorkers() = 2
[18:04:28.105] result() for MulticoreFuture ...
[18:04:28.105] result() for MulticoreFuture ... done
[18:04:28.105] result() for MulticoreFuture ... done
[18:04:28.106] result() for MulticoreFuture ...
[18:04:28.106] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[18:04:28.111] getGlobalsAndPackages() ...
[18:04:28.111] Searching for globals...
[18:04:28.122] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[18:04:28.122] Searching for globals ... DONE
[18:04:28.123] Resolving globals: FALSE
[18:04:28.128] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[18:04:28.130] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[18:04:28.130] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[18:04:28.130] 
[18:04:28.131] getGlobalsAndPackages() ... DONE
[18:04:28.131] run() for ‘Future’ ...
[18:04:28.131] - state: ‘created’
[18:04:28.132] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:28.139] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:28.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:28.139]   - Field: ‘label’
[18:04:28.140]   - Field: ‘local’
[18:04:28.140]   - Field: ‘owner’
[18:04:28.140]   - Field: ‘envir’
[18:04:28.140]   - Field: ‘workers’
[18:04:28.140]   - Field: ‘packages’
[18:04:28.141]   - Field: ‘gc’
[18:04:28.141]   - Field: ‘job’
[18:04:28.141]   - Field: ‘conditions’
[18:04:28.141]   - Field: ‘expr’
[18:04:28.142]   - Field: ‘uuid’
[18:04:28.142]   - Field: ‘seed’
[18:04:28.142]   - Field: ‘version’
[18:04:28.142]   - Field: ‘result’
[18:04:28.143]   - Field: ‘asynchronous’
[18:04:28.143]   - Field: ‘calls’
[18:04:28.143]   - Field: ‘globals’
[18:04:28.143]   - Field: ‘stdout’
[18:04:28.143]   - Field: ‘earlySignal’
[18:04:28.144]   - Field: ‘lazy’
[18:04:28.144]   - Field: ‘state’
[18:04:28.144] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:28.144] - Launch lazy future ...
[18:04:28.145] Packages needed by the future expression (n = 0): <none>
[18:04:28.145] Packages needed by future strategies (n = 0): <none>
[18:04:28.146] {
[18:04:28.146]     {
[18:04:28.146]         {
[18:04:28.146]             ...future.startTime <- base::Sys.time()
[18:04:28.146]             {
[18:04:28.146]                 {
[18:04:28.146]                   {
[18:04:28.146]                     {
[18:04:28.146]                       base::local({
[18:04:28.146]                         has_future <- base::requireNamespace("future", 
[18:04:28.146]                           quietly = TRUE)
[18:04:28.146]                         if (has_future) {
[18:04:28.146]                           ns <- base::getNamespace("future")
[18:04:28.146]                           version <- ns[[".package"]][["version"]]
[18:04:28.146]                           if (is.null(version)) 
[18:04:28.146]                             version <- utils::packageVersion("future")
[18:04:28.146]                         }
[18:04:28.146]                         else {
[18:04:28.146]                           version <- NULL
[18:04:28.146]                         }
[18:04:28.146]                         if (!has_future || version < "1.8.0") {
[18:04:28.146]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:28.146]                             "", base::R.version$version.string), 
[18:04:28.146]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:28.146]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:28.146]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:28.146]                               "release", "version")], collapse = " "), 
[18:04:28.146]                             hostname = base::Sys.info()[["nodename"]])
[18:04:28.146]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:28.146]                             info)
[18:04:28.146]                           info <- base::paste(info, collapse = "; ")
[18:04:28.146]                           if (!has_future) {
[18:04:28.146]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:28.146]                               info)
[18:04:28.146]                           }
[18:04:28.146]                           else {
[18:04:28.146]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:28.146]                               info, version)
[18:04:28.146]                           }
[18:04:28.146]                           base::stop(msg)
[18:04:28.146]                         }
[18:04:28.146]                       })
[18:04:28.146]                     }
[18:04:28.146]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:28.146]                     base::options(mc.cores = 1L)
[18:04:28.146]                   }
[18:04:28.146]                   ...future.strategy.old <- future::plan("list")
[18:04:28.146]                   options(future.plan = NULL)
[18:04:28.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:28.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:28.146]                 }
[18:04:28.146]                 ...future.workdir <- getwd()
[18:04:28.146]             }
[18:04:28.146]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:28.146]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:28.146]         }
[18:04:28.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:28.146]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:28.146]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:28.146]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:28.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:28.146]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:28.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:28.146]             base::names(...future.oldOptions))
[18:04:28.146]     }
[18:04:28.146]     if (FALSE) {
[18:04:28.146]     }
[18:04:28.146]     else {
[18:04:28.146]         if (TRUE) {
[18:04:28.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:28.146]                 open = "w")
[18:04:28.146]         }
[18:04:28.146]         else {
[18:04:28.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:28.146]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:28.146]         }
[18:04:28.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:28.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:28.146]             base::sink(type = "output", split = FALSE)
[18:04:28.146]             base::close(...future.stdout)
[18:04:28.146]         }, add = TRUE)
[18:04:28.146]     }
[18:04:28.146]     ...future.frame <- base::sys.nframe()
[18:04:28.146]     ...future.conditions <- base::list()
[18:04:28.146]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:28.146]     if (FALSE) {
[18:04:28.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:28.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:28.146]     }
[18:04:28.146]     ...future.result <- base::tryCatch({
[18:04:28.146]         base::withCallingHandlers({
[18:04:28.146]             ...future.value <- base::withVisible(base::local({
[18:04:28.146]                 withCallingHandlers({
[18:04:28.146]                   {
[18:04:28.146]                     outer_function(1L)
[18:04:28.146]                   }
[18:04:28.146]                 }, immediateCondition = function(cond) {
[18:04:28.146]                   save_rds <- function (object, pathname, ...) 
[18:04:28.146]                   {
[18:04:28.146]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:28.146]                     if (file_test("-f", pathname_tmp)) {
[18:04:28.146]                       fi_tmp <- file.info(pathname_tmp)
[18:04:28.146]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:28.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:28.146]                         fi_tmp[["mtime"]])
[18:04:28.146]                     }
[18:04:28.146]                     tryCatch({
[18:04:28.146]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:28.146]                     }, error = function(ex) {
[18:04:28.146]                       msg <- conditionMessage(ex)
[18:04:28.146]                       fi_tmp <- file.info(pathname_tmp)
[18:04:28.146]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:28.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:28.146]                         fi_tmp[["mtime"]], msg)
[18:04:28.146]                       ex$message <- msg
[18:04:28.146]                       stop(ex)
[18:04:28.146]                     })
[18:04:28.146]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:28.146]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:28.146]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:28.146]                       fi_tmp <- file.info(pathname_tmp)
[18:04:28.146]                       fi <- file.info(pathname)
[18:04:28.146]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:28.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:28.146]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:28.146]                         fi[["size"]], fi[["mtime"]])
[18:04:28.146]                       stop(msg)
[18:04:28.146]                     }
[18:04:28.146]                     invisible(pathname)
[18:04:28.146]                   }
[18:04:28.146]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:28.146]                     rootPath = tempdir()) 
[18:04:28.146]                   {
[18:04:28.146]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:28.146]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:28.146]                       tmpdir = path, fileext = ".rds")
[18:04:28.146]                     save_rds(obj, file)
[18:04:28.146]                   }
[18:04:28.146]                   saveImmediateCondition(cond, path = "/tmp/RtmpLRNsAG/.future/immediateConditions")
[18:04:28.146]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:28.146]                   {
[18:04:28.146]                     inherits <- base::inherits
[18:04:28.146]                     invokeRestart <- base::invokeRestart
[18:04:28.146]                     is.null <- base::is.null
[18:04:28.146]                     muffled <- FALSE
[18:04:28.146]                     if (inherits(cond, "message")) {
[18:04:28.146]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:28.146]                       if (muffled) 
[18:04:28.146]                         invokeRestart("muffleMessage")
[18:04:28.146]                     }
[18:04:28.146]                     else if (inherits(cond, "warning")) {
[18:04:28.146]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:28.146]                       if (muffled) 
[18:04:28.146]                         invokeRestart("muffleWarning")
[18:04:28.146]                     }
[18:04:28.146]                     else if (inherits(cond, "condition")) {
[18:04:28.146]                       if (!is.null(pattern)) {
[18:04:28.146]                         computeRestarts <- base::computeRestarts
[18:04:28.146]                         grepl <- base::grepl
[18:04:28.146]                         restarts <- computeRestarts(cond)
[18:04:28.146]                         for (restart in restarts) {
[18:04:28.146]                           name <- restart$name
[18:04:28.146]                           if (is.null(name)) 
[18:04:28.146]                             next
[18:04:28.146]                           if (!grepl(pattern, name)) 
[18:04:28.146]                             next
[18:04:28.146]                           invokeRestart(restart)
[18:04:28.146]                           muffled <- TRUE
[18:04:28.146]                           break
[18:04:28.146]                         }
[18:04:28.146]                       }
[18:04:28.146]                     }
[18:04:28.146]                     invisible(muffled)
[18:04:28.146]                   }
[18:04:28.146]                   muffleCondition(cond)
[18:04:28.146]                 })
[18:04:28.146]             }))
[18:04:28.146]             future::FutureResult(value = ...future.value$value, 
[18:04:28.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:28.146]                   ...future.rng), globalenv = if (FALSE) 
[18:04:28.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:28.146]                     ...future.globalenv.names))
[18:04:28.146]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:28.146]         }, condition = base::local({
[18:04:28.146]             c <- base::c
[18:04:28.146]             inherits <- base::inherits
[18:04:28.146]             invokeRestart <- base::invokeRestart
[18:04:28.146]             length <- base::length
[18:04:28.146]             list <- base::list
[18:04:28.146]             seq.int <- base::seq.int
[18:04:28.146]             signalCondition <- base::signalCondition
[18:04:28.146]             sys.calls <- base::sys.calls
[18:04:28.146]             `[[` <- base::`[[`
[18:04:28.146]             `+` <- base::`+`
[18:04:28.146]             `<<-` <- base::`<<-`
[18:04:28.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:28.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:28.146]                   3L)]
[18:04:28.146]             }
[18:04:28.146]             function(cond) {
[18:04:28.146]                 is_error <- inherits(cond, "error")
[18:04:28.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:28.146]                   NULL)
[18:04:28.146]                 if (is_error) {
[18:04:28.146]                   sessionInformation <- function() {
[18:04:28.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:28.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:28.146]                       search = base::search(), system = base::Sys.info())
[18:04:28.146]                   }
[18:04:28.146]                   ...future.conditions[[length(...future.conditions) + 
[18:04:28.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:28.146]                     cond$call), session = sessionInformation(), 
[18:04:28.146]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:28.146]                   signalCondition(cond)
[18:04:28.146]                 }
[18:04:28.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:28.146]                 "immediateCondition"))) {
[18:04:28.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:28.146]                   ...future.conditions[[length(...future.conditions) + 
[18:04:28.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:28.146]                   if (TRUE && !signal) {
[18:04:28.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:28.146]                     {
[18:04:28.146]                       inherits <- base::inherits
[18:04:28.146]                       invokeRestart <- base::invokeRestart
[18:04:28.146]                       is.null <- base::is.null
[18:04:28.146]                       muffled <- FALSE
[18:04:28.146]                       if (inherits(cond, "message")) {
[18:04:28.146]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:28.146]                         if (muffled) 
[18:04:28.146]                           invokeRestart("muffleMessage")
[18:04:28.146]                       }
[18:04:28.146]                       else if (inherits(cond, "warning")) {
[18:04:28.146]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:28.146]                         if (muffled) 
[18:04:28.146]                           invokeRestart("muffleWarning")
[18:04:28.146]                       }
[18:04:28.146]                       else if (inherits(cond, "condition")) {
[18:04:28.146]                         if (!is.null(pattern)) {
[18:04:28.146]                           computeRestarts <- base::computeRestarts
[18:04:28.146]                           grepl <- base::grepl
[18:04:28.146]                           restarts <- computeRestarts(cond)
[18:04:28.146]                           for (restart in restarts) {
[18:04:28.146]                             name <- restart$name
[18:04:28.146]                             if (is.null(name)) 
[18:04:28.146]                               next
[18:04:28.146]                             if (!grepl(pattern, name)) 
[18:04:28.146]                               next
[18:04:28.146]                             invokeRestart(restart)
[18:04:28.146]                             muffled <- TRUE
[18:04:28.146]                             break
[18:04:28.146]                           }
[18:04:28.146]                         }
[18:04:28.146]                       }
[18:04:28.146]                       invisible(muffled)
[18:04:28.146]                     }
[18:04:28.146]                     muffleCondition(cond, pattern = "^muffle")
[18:04:28.146]                   }
[18:04:28.146]                 }
[18:04:28.146]                 else {
[18:04:28.146]                   if (TRUE) {
[18:04:28.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:28.146]                     {
[18:04:28.146]                       inherits <- base::inherits
[18:04:28.146]                       invokeRestart <- base::invokeRestart
[18:04:28.146]                       is.null <- base::is.null
[18:04:28.146]                       muffled <- FALSE
[18:04:28.146]                       if (inherits(cond, "message")) {
[18:04:28.146]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:28.146]                         if (muffled) 
[18:04:28.146]                           invokeRestart("muffleMessage")
[18:04:28.146]                       }
[18:04:28.146]                       else if (inherits(cond, "warning")) {
[18:04:28.146]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:28.146]                         if (muffled) 
[18:04:28.146]                           invokeRestart("muffleWarning")
[18:04:28.146]                       }
[18:04:28.146]                       else if (inherits(cond, "condition")) {
[18:04:28.146]                         if (!is.null(pattern)) {
[18:04:28.146]                           computeRestarts <- base::computeRestarts
[18:04:28.146]                           grepl <- base::grepl
[18:04:28.146]                           restarts <- computeRestarts(cond)
[18:04:28.146]                           for (restart in restarts) {
[18:04:28.146]                             name <- restart$name
[18:04:28.146]                             if (is.null(name)) 
[18:04:28.146]                               next
[18:04:28.146]                             if (!grepl(pattern, name)) 
[18:04:28.146]                               next
[18:04:28.146]                             invokeRestart(restart)
[18:04:28.146]                             muffled <- TRUE
[18:04:28.146]                             break
[18:04:28.146]                           }
[18:04:28.146]                         }
[18:04:28.146]                       }
[18:04:28.146]                       invisible(muffled)
[18:04:28.146]                     }
[18:04:28.146]                     muffleCondition(cond, pattern = "^muffle")
[18:04:28.146]                   }
[18:04:28.146]                 }
[18:04:28.146]             }
[18:04:28.146]         }))
[18:04:28.146]     }, error = function(ex) {
[18:04:28.146]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:28.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:28.146]                 ...future.rng), started = ...future.startTime, 
[18:04:28.146]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:28.146]             version = "1.8"), class = "FutureResult")
[18:04:28.146]     }, finally = {
[18:04:28.146]         if (!identical(...future.workdir, getwd())) 
[18:04:28.146]             setwd(...future.workdir)
[18:04:28.146]         {
[18:04:28.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:28.146]                 ...future.oldOptions$nwarnings <- NULL
[18:04:28.146]             }
[18:04:28.146]             base::options(...future.oldOptions)
[18:04:28.146]             if (.Platform$OS.type == "windows") {
[18:04:28.146]                 old_names <- names(...future.oldEnvVars)
[18:04:28.146]                 envs <- base::Sys.getenv()
[18:04:28.146]                 names <- names(envs)
[18:04:28.146]                 common <- intersect(names, old_names)
[18:04:28.146]                 added <- setdiff(names, old_names)
[18:04:28.146]                 removed <- setdiff(old_names, names)
[18:04:28.146]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:28.146]                   envs[common]]
[18:04:28.146]                 NAMES <- toupper(changed)
[18:04:28.146]                 args <- list()
[18:04:28.146]                 for (kk in seq_along(NAMES)) {
[18:04:28.146]                   name <- changed[[kk]]
[18:04:28.146]                   NAME <- NAMES[[kk]]
[18:04:28.146]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:28.146]                     next
[18:04:28.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:28.146]                 }
[18:04:28.146]                 NAMES <- toupper(added)
[18:04:28.146]                 for (kk in seq_along(NAMES)) {
[18:04:28.146]                   name <- added[[kk]]
[18:04:28.146]                   NAME <- NAMES[[kk]]
[18:04:28.146]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:28.146]                     next
[18:04:28.146]                   args[[name]] <- ""
[18:04:28.146]                 }
[18:04:28.146]                 NAMES <- toupper(removed)
[18:04:28.146]                 for (kk in seq_along(NAMES)) {
[18:04:28.146]                   name <- removed[[kk]]
[18:04:28.146]                   NAME <- NAMES[[kk]]
[18:04:28.146]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:28.146]                     next
[18:04:28.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:28.146]                 }
[18:04:28.146]                 if (length(args) > 0) 
[18:04:28.146]                   base::do.call(base::Sys.setenv, args = args)
[18:04:28.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:28.146]             }
[18:04:28.146]             else {
[18:04:28.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:28.146]             }
[18:04:28.146]             {
[18:04:28.146]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:28.146]                   0L) {
[18:04:28.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:28.146]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:28.146]                   base::options(opts)
[18:04:28.146]                 }
[18:04:28.146]                 {
[18:04:28.146]                   {
[18:04:28.146]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:28.146]                     NULL
[18:04:28.146]                   }
[18:04:28.146]                   options(future.plan = NULL)
[18:04:28.146]                   if (is.na(NA_character_)) 
[18:04:28.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:28.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:28.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:28.146]                     .init = FALSE)
[18:04:28.146]                 }
[18:04:28.146]             }
[18:04:28.146]         }
[18:04:28.146]     })
[18:04:28.146]     if (TRUE) {
[18:04:28.146]         base::sink(type = "output", split = FALSE)
[18:04:28.146]         if (TRUE) {
[18:04:28.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:28.146]         }
[18:04:28.146]         else {
[18:04:28.146]             ...future.result["stdout"] <- base::list(NULL)
[18:04:28.146]         }
[18:04:28.146]         base::close(...future.stdout)
[18:04:28.146]         ...future.stdout <- NULL
[18:04:28.146]     }
[18:04:28.146]     ...future.result$conditions <- ...future.conditions
[18:04:28.146]     ...future.result$finished <- base::Sys.time()
[18:04:28.146]     ...future.result
[18:04:28.146] }
[18:04:28.150] assign_globals() ...
[18:04:28.151] List of 3
[18:04:28.151]  $ outer_function:function (x)  
[18:04:28.151]  $ map           :function (.x, .f, ...)  
[18:04:28.151]  $ inner_function:function (x)  
[18:04:28.151]  - attr(*, "where")=List of 3
[18:04:28.151]   ..$ outer_function:<environment: R_EmptyEnv> 
[18:04:28.151]   ..$ map           :<environment: R_EmptyEnv> 
[18:04:28.151]   ..$ inner_function:<environment: R_EmptyEnv> 
[18:04:28.151]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:28.151]  - attr(*, "resolved")= logi FALSE
[18:04:28.151]  - attr(*, "total_size")= num 7704
[18:04:28.151]  - attr(*, "already-done")= logi TRUE
[18:04:28.158] - reassign environment for ‘outer_function’
[18:04:28.158] - copied ‘outer_function’ to environment
[18:04:28.159] - reassign environment for ‘map’
[18:04:28.159] - copied ‘map’ to environment
[18:04:28.159] - reassign environment for ‘inner_function’
[18:04:28.159] - copied ‘inner_function’ to environment
[18:04:28.159] assign_globals() ... done
[18:04:28.160] requestCore(): workers = 2
[18:04:28.163] MulticoreFuture started
[18:04:28.164] - Launch lazy future ... done
[18:04:28.165] run() for ‘MulticoreFuture’ ... done
[18:04:28.165] result() for MulticoreFuture ...
[18:04:28.165] plan(): Setting new future strategy stack:
[18:04:28.166] List of future strategies:
[18:04:28.166] 1. sequential:
[18:04:28.166]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:28.166]    - tweaked: FALSE
[18:04:28.166]    - call: NULL
[18:04:28.168] plan(): nbrOfWorkers() = 1
[18:04:28.174] plan(): Setting new future strategy stack:
[18:04:28.174] List of future strategies:
[18:04:28.174] 1. multicore:
[18:04:28.174]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:28.174]    - tweaked: FALSE
[18:04:28.174]    - call: plan(strategy)
[18:04:28.185] plan(): nbrOfWorkers() = 2
[18:04:28.186] result() for MulticoreFuture ...
[18:04:28.187] result() for MulticoreFuture ... done
[18:04:28.187] result() for MulticoreFuture ... done
[18:04:28.187] result() for MulticoreFuture ...
[18:04:28.188] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[18:04:28.191] getGlobalsAndPackages() ...
[18:04:28.191] Searching for globals...
[18:04:28.202] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[18:04:28.203] Searching for globals ... DONE
[18:04:28.203] Resolving globals: FALSE
[18:04:28.205] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[18:04:28.206] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[18:04:28.206] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[18:04:28.206] 
[18:04:28.207] getGlobalsAndPackages() ... DONE
[18:04:28.207] run() for ‘Future’ ...
[18:04:28.208] - state: ‘created’
[18:04:28.208] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:28.217] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:28.217] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:28.217]   - Field: ‘label’
[18:04:28.218]   - Field: ‘local’
[18:04:28.218]   - Field: ‘owner’
[18:04:28.218]   - Field: ‘envir’
[18:04:28.219]   - Field: ‘workers’
[18:04:28.219]   - Field: ‘packages’
[18:04:28.219]   - Field: ‘gc’
[18:04:28.219]   - Field: ‘job’
[18:04:28.220]   - Field: ‘conditions’
[18:04:28.220]   - Field: ‘expr’
[18:04:28.223]   - Field: ‘uuid’
[18:04:28.223]   - Field: ‘seed’
[18:04:28.224]   - Field: ‘version’
[18:04:28.224]   - Field: ‘result’
[18:04:28.224]   - Field: ‘asynchronous’
[18:04:28.225]   - Field: ‘calls’
[18:04:28.225]   - Field: ‘globals’
[18:04:28.225]   - Field: ‘stdout’
[18:04:28.226]   - Field: ‘earlySignal’
[18:04:28.226]   - Field: ‘lazy’
[18:04:28.226]   - Field: ‘state’
[18:04:28.227] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:28.227] - Launch lazy future ...
[18:04:28.227] Packages needed by the future expression (n = 0): <none>
[18:04:28.228] Packages needed by future strategies (n = 0): <none>
[18:04:28.229] {
[18:04:28.229]     {
[18:04:28.229]         {
[18:04:28.229]             ...future.startTime <- base::Sys.time()
[18:04:28.229]             {
[18:04:28.229]                 {
[18:04:28.229]                   {
[18:04:28.229]                     {
[18:04:28.229]                       base::local({
[18:04:28.229]                         has_future <- base::requireNamespace("future", 
[18:04:28.229]                           quietly = TRUE)
[18:04:28.229]                         if (has_future) {
[18:04:28.229]                           ns <- base::getNamespace("future")
[18:04:28.229]                           version <- ns[[".package"]][["version"]]
[18:04:28.229]                           if (is.null(version)) 
[18:04:28.229]                             version <- utils::packageVersion("future")
[18:04:28.229]                         }
[18:04:28.229]                         else {
[18:04:28.229]                           version <- NULL
[18:04:28.229]                         }
[18:04:28.229]                         if (!has_future || version < "1.8.0") {
[18:04:28.229]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:28.229]                             "", base::R.version$version.string), 
[18:04:28.229]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:28.229]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:28.229]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:28.229]                               "release", "version")], collapse = " "), 
[18:04:28.229]                             hostname = base::Sys.info()[["nodename"]])
[18:04:28.229]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:28.229]                             info)
[18:04:28.229]                           info <- base::paste(info, collapse = "; ")
[18:04:28.229]                           if (!has_future) {
[18:04:28.229]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:28.229]                               info)
[18:04:28.229]                           }
[18:04:28.229]                           else {
[18:04:28.229]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:28.229]                               info, version)
[18:04:28.229]                           }
[18:04:28.229]                           base::stop(msg)
[18:04:28.229]                         }
[18:04:28.229]                       })
[18:04:28.229]                     }
[18:04:28.229]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:28.229]                     base::options(mc.cores = 1L)
[18:04:28.229]                   }
[18:04:28.229]                   ...future.strategy.old <- future::plan("list")
[18:04:28.229]                   options(future.plan = NULL)
[18:04:28.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:28.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:28.229]                 }
[18:04:28.229]                 ...future.workdir <- getwd()
[18:04:28.229]             }
[18:04:28.229]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:28.229]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:28.229]         }
[18:04:28.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:28.229]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:28.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:28.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:28.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:28.229]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:28.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:28.229]             base::names(...future.oldOptions))
[18:04:28.229]     }
[18:04:28.229]     if (FALSE) {
[18:04:28.229]     }
[18:04:28.229]     else {
[18:04:28.229]         if (TRUE) {
[18:04:28.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:28.229]                 open = "w")
[18:04:28.229]         }
[18:04:28.229]         else {
[18:04:28.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:28.229]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:28.229]         }
[18:04:28.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:28.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:28.229]             base::sink(type = "output", split = FALSE)
[18:04:28.229]             base::close(...future.stdout)
[18:04:28.229]         }, add = TRUE)
[18:04:28.229]     }
[18:04:28.229]     ...future.frame <- base::sys.nframe()
[18:04:28.229]     ...future.conditions <- base::list()
[18:04:28.229]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:28.229]     if (FALSE) {
[18:04:28.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:28.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:28.229]     }
[18:04:28.229]     ...future.result <- base::tryCatch({
[18:04:28.229]         base::withCallingHandlers({
[18:04:28.229]             ...future.value <- base::withVisible(base::local({
[18:04:28.229]                 withCallingHandlers({
[18:04:28.229]                   {
[18:04:28.229]                     outer_function(1L)
[18:04:28.229]                   }
[18:04:28.229]                 }, immediateCondition = function(cond) {
[18:04:28.229]                   save_rds <- function (object, pathname, ...) 
[18:04:28.229]                   {
[18:04:28.229]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:28.229]                     if (file_test("-f", pathname_tmp)) {
[18:04:28.229]                       fi_tmp <- file.info(pathname_tmp)
[18:04:28.229]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:28.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:28.229]                         fi_tmp[["mtime"]])
[18:04:28.229]                     }
[18:04:28.229]                     tryCatch({
[18:04:28.229]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:28.229]                     }, error = function(ex) {
[18:04:28.229]                       msg <- conditionMessage(ex)
[18:04:28.229]                       fi_tmp <- file.info(pathname_tmp)
[18:04:28.229]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:28.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:28.229]                         fi_tmp[["mtime"]], msg)
[18:04:28.229]                       ex$message <- msg
[18:04:28.229]                       stop(ex)
[18:04:28.229]                     })
[18:04:28.229]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:28.229]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:28.229]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:28.229]                       fi_tmp <- file.info(pathname_tmp)
[18:04:28.229]                       fi <- file.info(pathname)
[18:04:28.229]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:28.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:28.229]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:28.229]                         fi[["size"]], fi[["mtime"]])
[18:04:28.229]                       stop(msg)
[18:04:28.229]                     }
[18:04:28.229]                     invisible(pathname)
[18:04:28.229]                   }
[18:04:28.229]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:28.229]                     rootPath = tempdir()) 
[18:04:28.229]                   {
[18:04:28.229]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:28.229]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:28.229]                       tmpdir = path, fileext = ".rds")
[18:04:28.229]                     save_rds(obj, file)
[18:04:28.229]                   }
[18:04:28.229]                   saveImmediateCondition(cond, path = "/tmp/RtmpLRNsAG/.future/immediateConditions")
[18:04:28.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:28.229]                   {
[18:04:28.229]                     inherits <- base::inherits
[18:04:28.229]                     invokeRestart <- base::invokeRestart
[18:04:28.229]                     is.null <- base::is.null
[18:04:28.229]                     muffled <- FALSE
[18:04:28.229]                     if (inherits(cond, "message")) {
[18:04:28.229]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:28.229]                       if (muffled) 
[18:04:28.229]                         invokeRestart("muffleMessage")
[18:04:28.229]                     }
[18:04:28.229]                     else if (inherits(cond, "warning")) {
[18:04:28.229]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:28.229]                       if (muffled) 
[18:04:28.229]                         invokeRestart("muffleWarning")
[18:04:28.229]                     }
[18:04:28.229]                     else if (inherits(cond, "condition")) {
[18:04:28.229]                       if (!is.null(pattern)) {
[18:04:28.229]                         computeRestarts <- base::computeRestarts
[18:04:28.229]                         grepl <- base::grepl
[18:04:28.229]                         restarts <- computeRestarts(cond)
[18:04:28.229]                         for (restart in restarts) {
[18:04:28.229]                           name <- restart$name
[18:04:28.229]                           if (is.null(name)) 
[18:04:28.229]                             next
[18:04:28.229]                           if (!grepl(pattern, name)) 
[18:04:28.229]                             next
[18:04:28.229]                           invokeRestart(restart)
[18:04:28.229]                           muffled <- TRUE
[18:04:28.229]                           break
[18:04:28.229]                         }
[18:04:28.229]                       }
[18:04:28.229]                     }
[18:04:28.229]                     invisible(muffled)
[18:04:28.229]                   }
[18:04:28.229]                   muffleCondition(cond)
[18:04:28.229]                 })
[18:04:28.229]             }))
[18:04:28.229]             future::FutureResult(value = ...future.value$value, 
[18:04:28.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:28.229]                   ...future.rng), globalenv = if (FALSE) 
[18:04:28.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:28.229]                     ...future.globalenv.names))
[18:04:28.229]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:28.229]         }, condition = base::local({
[18:04:28.229]             c <- base::c
[18:04:28.229]             inherits <- base::inherits
[18:04:28.229]             invokeRestart <- base::invokeRestart
[18:04:28.229]             length <- base::length
[18:04:28.229]             list <- base::list
[18:04:28.229]             seq.int <- base::seq.int
[18:04:28.229]             signalCondition <- base::signalCondition
[18:04:28.229]             sys.calls <- base::sys.calls
[18:04:28.229]             `[[` <- base::`[[`
[18:04:28.229]             `+` <- base::`+`
[18:04:28.229]             `<<-` <- base::`<<-`
[18:04:28.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:28.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:28.229]                   3L)]
[18:04:28.229]             }
[18:04:28.229]             function(cond) {
[18:04:28.229]                 is_error <- inherits(cond, "error")
[18:04:28.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:28.229]                   NULL)
[18:04:28.229]                 if (is_error) {
[18:04:28.229]                   sessionInformation <- function() {
[18:04:28.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:28.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:28.229]                       search = base::search(), system = base::Sys.info())
[18:04:28.229]                   }
[18:04:28.229]                   ...future.conditions[[length(...future.conditions) + 
[18:04:28.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:28.229]                     cond$call), session = sessionInformation(), 
[18:04:28.229]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:28.229]                   signalCondition(cond)
[18:04:28.229]                 }
[18:04:28.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:28.229]                 "immediateCondition"))) {
[18:04:28.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:28.229]                   ...future.conditions[[length(...future.conditions) + 
[18:04:28.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:28.229]                   if (TRUE && !signal) {
[18:04:28.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:28.229]                     {
[18:04:28.229]                       inherits <- base::inherits
[18:04:28.229]                       invokeRestart <- base::invokeRestart
[18:04:28.229]                       is.null <- base::is.null
[18:04:28.229]                       muffled <- FALSE
[18:04:28.229]                       if (inherits(cond, "message")) {
[18:04:28.229]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:28.229]                         if (muffled) 
[18:04:28.229]                           invokeRestart("muffleMessage")
[18:04:28.229]                       }
[18:04:28.229]                       else if (inherits(cond, "warning")) {
[18:04:28.229]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:28.229]                         if (muffled) 
[18:04:28.229]                           invokeRestart("muffleWarning")
[18:04:28.229]                       }
[18:04:28.229]                       else if (inherits(cond, "condition")) {
[18:04:28.229]                         if (!is.null(pattern)) {
[18:04:28.229]                           computeRestarts <- base::computeRestarts
[18:04:28.229]                           grepl <- base::grepl
[18:04:28.229]                           restarts <- computeRestarts(cond)
[18:04:28.229]                           for (restart in restarts) {
[18:04:28.229]                             name <- restart$name
[18:04:28.229]                             if (is.null(name)) 
[18:04:28.229]                               next
[18:04:28.229]                             if (!grepl(pattern, name)) 
[18:04:28.229]                               next
[18:04:28.229]                             invokeRestart(restart)
[18:04:28.229]                             muffled <- TRUE
[18:04:28.229]                             break
[18:04:28.229]                           }
[18:04:28.229]                         }
[18:04:28.229]                       }
[18:04:28.229]                       invisible(muffled)
[18:04:28.229]                     }
[18:04:28.229]                     muffleCondition(cond, pattern = "^muffle")
[18:04:28.229]                   }
[18:04:28.229]                 }
[18:04:28.229]                 else {
[18:04:28.229]                   if (TRUE) {
[18:04:28.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:28.229]                     {
[18:04:28.229]                       inherits <- base::inherits
[18:04:28.229]                       invokeRestart <- base::invokeRestart
[18:04:28.229]                       is.null <- base::is.null
[18:04:28.229]                       muffled <- FALSE
[18:04:28.229]                       if (inherits(cond, "message")) {
[18:04:28.229]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:28.229]                         if (muffled) 
[18:04:28.229]                           invokeRestart("muffleMessage")
[18:04:28.229]                       }
[18:04:28.229]                       else if (inherits(cond, "warning")) {
[18:04:28.229]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:28.229]                         if (muffled) 
[18:04:28.229]                           invokeRestart("muffleWarning")
[18:04:28.229]                       }
[18:04:28.229]                       else if (inherits(cond, "condition")) {
[18:04:28.229]                         if (!is.null(pattern)) {
[18:04:28.229]                           computeRestarts <- base::computeRestarts
[18:04:28.229]                           grepl <- base::grepl
[18:04:28.229]                           restarts <- computeRestarts(cond)
[18:04:28.229]                           for (restart in restarts) {
[18:04:28.229]                             name <- restart$name
[18:04:28.229]                             if (is.null(name)) 
[18:04:28.229]                               next
[18:04:28.229]                             if (!grepl(pattern, name)) 
[18:04:28.229]                               next
[18:04:28.229]                             invokeRestart(restart)
[18:04:28.229]                             muffled <- TRUE
[18:04:28.229]                             break
[18:04:28.229]                           }
[18:04:28.229]                         }
[18:04:28.229]                       }
[18:04:28.229]                       invisible(muffled)
[18:04:28.229]                     }
[18:04:28.229]                     muffleCondition(cond, pattern = "^muffle")
[18:04:28.229]                   }
[18:04:28.229]                 }
[18:04:28.229]             }
[18:04:28.229]         }))
[18:04:28.229]     }, error = function(ex) {
[18:04:28.229]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:28.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:28.229]                 ...future.rng), started = ...future.startTime, 
[18:04:28.229]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:28.229]             version = "1.8"), class = "FutureResult")
[18:04:28.229]     }, finally = {
[18:04:28.229]         if (!identical(...future.workdir, getwd())) 
[18:04:28.229]             setwd(...future.workdir)
[18:04:28.229]         {
[18:04:28.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:28.229]                 ...future.oldOptions$nwarnings <- NULL
[18:04:28.229]             }
[18:04:28.229]             base::options(...future.oldOptions)
[18:04:28.229]             if (.Platform$OS.type == "windows") {
[18:04:28.229]                 old_names <- names(...future.oldEnvVars)
[18:04:28.229]                 envs <- base::Sys.getenv()
[18:04:28.229]                 names <- names(envs)
[18:04:28.229]                 common <- intersect(names, old_names)
[18:04:28.229]                 added <- setdiff(names, old_names)
[18:04:28.229]                 removed <- setdiff(old_names, names)
[18:04:28.229]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:28.229]                   envs[common]]
[18:04:28.229]                 NAMES <- toupper(changed)
[18:04:28.229]                 args <- list()
[18:04:28.229]                 for (kk in seq_along(NAMES)) {
[18:04:28.229]                   name <- changed[[kk]]
[18:04:28.229]                   NAME <- NAMES[[kk]]
[18:04:28.229]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:28.229]                     next
[18:04:28.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:28.229]                 }
[18:04:28.229]                 NAMES <- toupper(added)
[18:04:28.229]                 for (kk in seq_along(NAMES)) {
[18:04:28.229]                   name <- added[[kk]]
[18:04:28.229]                   NAME <- NAMES[[kk]]
[18:04:28.229]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:28.229]                     next
[18:04:28.229]                   args[[name]] <- ""
[18:04:28.229]                 }
[18:04:28.229]                 NAMES <- toupper(removed)
[18:04:28.229]                 for (kk in seq_along(NAMES)) {
[18:04:28.229]                   name <- removed[[kk]]
[18:04:28.229]                   NAME <- NAMES[[kk]]
[18:04:28.229]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:28.229]                     next
[18:04:28.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:28.229]                 }
[18:04:28.229]                 if (length(args) > 0) 
[18:04:28.229]                   base::do.call(base::Sys.setenv, args = args)
[18:04:28.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:28.229]             }
[18:04:28.229]             else {
[18:04:28.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:28.229]             }
[18:04:28.229]             {
[18:04:28.229]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:28.229]                   0L) {
[18:04:28.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:28.229]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:28.229]                   base::options(opts)
[18:04:28.229]                 }
[18:04:28.229]                 {
[18:04:28.229]                   {
[18:04:28.229]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:28.229]                     NULL
[18:04:28.229]                   }
[18:04:28.229]                   options(future.plan = NULL)
[18:04:28.229]                   if (is.na(NA_character_)) 
[18:04:28.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:28.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:28.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:28.229]                     .init = FALSE)
[18:04:28.229]                 }
[18:04:28.229]             }
[18:04:28.229]         }
[18:04:28.229]     })
[18:04:28.229]     if (TRUE) {
[18:04:28.229]         base::sink(type = "output", split = FALSE)
[18:04:28.229]         if (TRUE) {
[18:04:28.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:28.229]         }
[18:04:28.229]         else {
[18:04:28.229]             ...future.result["stdout"] <- base::list(NULL)
[18:04:28.229]         }
[18:04:28.229]         base::close(...future.stdout)
[18:04:28.229]         ...future.stdout <- NULL
[18:04:28.229]     }
[18:04:28.229]     ...future.result$conditions <- ...future.conditions
[18:04:28.229]     ...future.result$finished <- base::Sys.time()
[18:04:28.229]     ...future.result
[18:04:28.229] }
[18:04:28.234] assign_globals() ...
[18:04:28.234] List of 3
[18:04:28.234]  $ outer_function:function (x)  
[18:04:28.234]  $ map           :function (.x, .f, ...)  
[18:04:28.234]  $ inner_function:function (x)  
[18:04:28.234]  - attr(*, "where")=List of 3
[18:04:28.234]   ..$ outer_function:<environment: R_EmptyEnv> 
[18:04:28.234]   ..$ map           :<environment: R_EmptyEnv> 
[18:04:28.234]   ..$ inner_function:<environment: R_EmptyEnv> 
[18:04:28.234]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:28.234]  - attr(*, "resolved")= logi FALSE
[18:04:28.234]  - attr(*, "total_size")= num 7704
[18:04:28.234]  - attr(*, "already-done")= logi TRUE
[18:04:28.242] - reassign environment for ‘outer_function’
[18:04:28.243] - copied ‘outer_function’ to environment
[18:04:28.243] - reassign environment for ‘map’
[18:04:28.243] - copied ‘map’ to environment
[18:04:28.243] - reassign environment for ‘inner_function’
[18:04:28.244] - copied ‘inner_function’ to environment
[18:04:28.244] assign_globals() ... done
[18:04:28.244] requestCore(): workers = 2
[18:04:28.248] MulticoreFuture started
[18:04:28.249] - Launch lazy future ... done
[18:04:28.249] run() for ‘MulticoreFuture’ ... done
[18:04:28.250] result() for MulticoreFuture ...
[18:04:28.253] plan(): Setting new future strategy stack:
[18:04:28.253] List of future strategies:
[18:04:28.253] 1. sequential:
[18:04:28.253]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:28.253]    - tweaked: FALSE
[18:04:28.253]    - call: NULL
[18:04:28.256] plan(): nbrOfWorkers() = 1
[18:04:28.261] plan(): Setting new future strategy stack:
[18:04:28.261] List of future strategies:
[18:04:28.261] 1. multicore:
[18:04:28.261]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:28.261]    - tweaked: FALSE
[18:04:28.261]    - call: plan(strategy)
[18:04:28.271] plan(): nbrOfWorkers() = 2
[18:04:28.274] result() for MulticoreFuture ...
[18:04:28.274] result() for MulticoreFuture ... done
[18:04:28.276] result() for MulticoreFuture ... done
[18:04:28.276] result() for MulticoreFuture ...
[18:04:28.277] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[18:04:28.282] plan(): Setting new future strategy stack:
[18:04:28.282] List of future strategies:
[18:04:28.282] 1. multisession:
[18:04:28.282]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:28.282]    - tweaked: FALSE
[18:04:28.282]    - call: plan(strategy)
[18:04:28.283] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:04:28.284] multisession:
[18:04:28.284] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:28.284] - tweaked: FALSE
[18:04:28.284] - call: plan(strategy)
[18:04:28.296] getGlobalsAndPackages() ...
[18:04:28.296] Not searching for globals
[18:04:28.297] - globals: [0] <none>
[18:04:28.297] getGlobalsAndPackages() ... DONE
[18:04:28.298] [local output] makeClusterPSOCK() ...
[18:04:28.367] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:04:28.369] [local output] Base port: 11358
[18:04:28.370] [local output] Getting setup options for 2 cluster nodes ...
[18:04:28.370] [local output]  - Node 1 of 2 ...
[18:04:28.371] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:28.372] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpLRNsAG/worker.rank=1.parallelly.parent=323072.4ee003abc1a8.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpLRNsAG/worker.rank=1.parallelly.parent=323072.4ee003abc1a8.pid")'’
[18:04:28.634] - Possible to infer worker's PID: TRUE
[18:04:28.635] [local output] Rscript port: 11358

[18:04:28.635] [local output]  - Node 2 of 2 ...
[18:04:28.636] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:28.637] [local output] Rscript port: 11358

[18:04:28.638] [local output] Getting setup options for 2 cluster nodes ... done
[18:04:28.638] [local output]  - Parallel setup requested for some PSOCK nodes
[18:04:28.639] [local output] Setting up PSOCK nodes in parallel
[18:04:28.639] List of 36
[18:04:28.639]  $ worker          : chr "localhost"
[18:04:28.639]   ..- attr(*, "localhost")= logi TRUE
[18:04:28.639]  $ master          : chr "localhost"
[18:04:28.639]  $ port            : int 11358
[18:04:28.639]  $ connectTimeout  : num 120
[18:04:28.639]  $ timeout         : num 2592000
[18:04:28.639]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:04:28.639]  $ homogeneous     : logi TRUE
[18:04:28.639]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:04:28.639]  $ rscript_envs    : NULL
[18:04:28.639]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:28.639]  $ rscript_startup : NULL
[18:04:28.639]  $ rscript_sh      : chr "sh"
[18:04:28.639]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:28.639]  $ methods         : logi TRUE
[18:04:28.639]  $ socketOptions   : chr "no-delay"
[18:04:28.639]  $ useXDR          : logi FALSE
[18:04:28.639]  $ outfile         : chr "/dev/null"
[18:04:28.639]  $ renice          : int NA
[18:04:28.639]  $ rshcmd          : NULL
[18:04:28.639]  $ user            : chr(0) 
[18:04:28.639]  $ revtunnel       : logi FALSE
[18:04:28.639]  $ rshlogfile      : NULL
[18:04:28.639]  $ rshopts         : chr(0) 
[18:04:28.639]  $ rank            : int 1
[18:04:28.639]  $ manual          : logi FALSE
[18:04:28.639]  $ dryrun          : logi FALSE
[18:04:28.639]  $ quiet           : logi FALSE
[18:04:28.639]  $ setup_strategy  : chr "parallel"
[18:04:28.639]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:28.639]  $ pidfile         : chr "/tmp/RtmpLRNsAG/worker.rank=1.parallelly.parent=323072.4ee003abc1a8.pid"
[18:04:28.639]  $ rshcmd_label    : NULL
[18:04:28.639]  $ rsh_call        : NULL
[18:04:28.639]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:28.639]  $ localMachine    : logi TRUE
[18:04:28.639]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:04:28.639]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:04:28.639]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:04:28.639]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:04:28.639]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:04:28.639]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:04:28.639]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:04:28.639]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:04:28.639]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:04:28.639]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:04:28.639]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:04:28.639]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:04:28.639]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:04:28.639]  $ arguments       :List of 28
[18:04:28.639]   ..$ worker          : chr "localhost"
[18:04:28.639]   ..$ master          : NULL
[18:04:28.639]   ..$ port            : int 11358
[18:04:28.639]   ..$ connectTimeout  : num 120
[18:04:28.639]   ..$ timeout         : num 2592000
[18:04:28.639]   ..$ rscript         : NULL
[18:04:28.639]   ..$ homogeneous     : NULL
[18:04:28.639]   ..$ rscript_args    : NULL
[18:04:28.639]   ..$ rscript_envs    : NULL
[18:04:28.639]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:28.639]   ..$ rscript_startup : NULL
[18:04:28.639]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:04:28.639]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:28.639]   ..$ methods         : logi TRUE
[18:04:28.639]   ..$ socketOptions   : chr "no-delay"
[18:04:28.639]   ..$ useXDR          : logi FALSE
[18:04:28.639]   ..$ outfile         : chr "/dev/null"
[18:04:28.639]   ..$ renice          : int NA
[18:04:28.639]   ..$ rshcmd          : NULL
[18:04:28.639]   ..$ user            : NULL
[18:04:28.639]   ..$ revtunnel       : logi NA
[18:04:28.639]   ..$ rshlogfile      : NULL
[18:04:28.639]   ..$ rshopts         : NULL
[18:04:28.639]   ..$ rank            : int 1
[18:04:28.639]   ..$ manual          : logi FALSE
[18:04:28.639]   ..$ dryrun          : logi FALSE
[18:04:28.639]   ..$ quiet           : logi FALSE
[18:04:28.639]   ..$ setup_strategy  : chr "parallel"
[18:04:28.639]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:04:28.672] [local output] System call to launch all workers:
[18:04:28.673] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpLRNsAG/worker.rank=1.parallelly.parent=323072.4ee003abc1a8.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11358 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:04:28.673] [local output] Starting PSOCK main server
[18:04:28.683] [local output] Workers launched
[18:04:28.683] [local output] Waiting for workers to connect back
[18:04:28.683]  - [local output] 0 workers out of 2 ready
[18:04:29.039]  - [local output] 0 workers out of 2 ready
[18:04:29.041]  - [local output] 1 workers out of 2 ready
[18:04:29.041]  - [local output] 2 workers out of 2 ready
[18:04:29.041] [local output] Launching of workers completed
[18:04:29.041] [local output] Collecting session information from workers
[18:04:29.043] [local output]  - Worker #1 of 2
[18:04:29.044] [local output]  - Worker #2 of 2
[18:04:29.044] [local output] makeClusterPSOCK() ... done
[18:04:29.064] Packages needed by the future expression (n = 0): <none>
[18:04:29.064] Packages needed by future strategies (n = 0): <none>
[18:04:29.065] {
[18:04:29.065]     {
[18:04:29.065]         {
[18:04:29.065]             ...future.startTime <- base::Sys.time()
[18:04:29.065]             {
[18:04:29.065]                 {
[18:04:29.065]                   {
[18:04:29.065]                     {
[18:04:29.065]                       base::local({
[18:04:29.065]                         has_future <- base::requireNamespace("future", 
[18:04:29.065]                           quietly = TRUE)
[18:04:29.065]                         if (has_future) {
[18:04:29.065]                           ns <- base::getNamespace("future")
[18:04:29.065]                           version <- ns[[".package"]][["version"]]
[18:04:29.065]                           if (is.null(version)) 
[18:04:29.065]                             version <- utils::packageVersion("future")
[18:04:29.065]                         }
[18:04:29.065]                         else {
[18:04:29.065]                           version <- NULL
[18:04:29.065]                         }
[18:04:29.065]                         if (!has_future || version < "1.8.0") {
[18:04:29.065]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:29.065]                             "", base::R.version$version.string), 
[18:04:29.065]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:29.065]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:29.065]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:29.065]                               "release", "version")], collapse = " "), 
[18:04:29.065]                             hostname = base::Sys.info()[["nodename"]])
[18:04:29.065]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:29.065]                             info)
[18:04:29.065]                           info <- base::paste(info, collapse = "; ")
[18:04:29.065]                           if (!has_future) {
[18:04:29.065]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:29.065]                               info)
[18:04:29.065]                           }
[18:04:29.065]                           else {
[18:04:29.065]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:29.065]                               info, version)
[18:04:29.065]                           }
[18:04:29.065]                           base::stop(msg)
[18:04:29.065]                         }
[18:04:29.065]                       })
[18:04:29.065]                     }
[18:04:29.065]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:29.065]                     base::options(mc.cores = 1L)
[18:04:29.065]                   }
[18:04:29.065]                   ...future.strategy.old <- future::plan("list")
[18:04:29.065]                   options(future.plan = NULL)
[18:04:29.065]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.065]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:29.065]                 }
[18:04:29.065]                 ...future.workdir <- getwd()
[18:04:29.065]             }
[18:04:29.065]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:29.065]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:29.065]         }
[18:04:29.065]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:29.065]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:29.065]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:29.065]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:29.065]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:29.065]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:29.065]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:29.065]             base::names(...future.oldOptions))
[18:04:29.065]     }
[18:04:29.065]     if (FALSE) {
[18:04:29.065]     }
[18:04:29.065]     else {
[18:04:29.065]         if (TRUE) {
[18:04:29.065]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:29.065]                 open = "w")
[18:04:29.065]         }
[18:04:29.065]         else {
[18:04:29.065]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:29.065]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:29.065]         }
[18:04:29.065]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:29.065]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:29.065]             base::sink(type = "output", split = FALSE)
[18:04:29.065]             base::close(...future.stdout)
[18:04:29.065]         }, add = TRUE)
[18:04:29.065]     }
[18:04:29.065]     ...future.frame <- base::sys.nframe()
[18:04:29.065]     ...future.conditions <- base::list()
[18:04:29.065]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:29.065]     if (FALSE) {
[18:04:29.065]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:29.065]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:29.065]     }
[18:04:29.065]     ...future.result <- base::tryCatch({
[18:04:29.065]         base::withCallingHandlers({
[18:04:29.065]             ...future.value <- base::withVisible(base::local({
[18:04:29.065]                 ...future.makeSendCondition <- base::local({
[18:04:29.065]                   sendCondition <- NULL
[18:04:29.065]                   function(frame = 1L) {
[18:04:29.065]                     if (is.function(sendCondition)) 
[18:04:29.065]                       return(sendCondition)
[18:04:29.065]                     ns <- getNamespace("parallel")
[18:04:29.065]                     if (exists("sendData", mode = "function", 
[18:04:29.065]                       envir = ns)) {
[18:04:29.065]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:29.065]                         envir = ns)
[18:04:29.065]                       envir <- sys.frame(frame)
[18:04:29.065]                       master <- NULL
[18:04:29.065]                       while (!identical(envir, .GlobalEnv) && 
[18:04:29.065]                         !identical(envir, emptyenv())) {
[18:04:29.065]                         if (exists("master", mode = "list", envir = envir, 
[18:04:29.065]                           inherits = FALSE)) {
[18:04:29.065]                           master <- get("master", mode = "list", 
[18:04:29.065]                             envir = envir, inherits = FALSE)
[18:04:29.065]                           if (inherits(master, c("SOCKnode", 
[18:04:29.065]                             "SOCK0node"))) {
[18:04:29.065]                             sendCondition <<- function(cond) {
[18:04:29.065]                               data <- list(type = "VALUE", value = cond, 
[18:04:29.065]                                 success = TRUE)
[18:04:29.065]                               parallel_sendData(master, data)
[18:04:29.065]                             }
[18:04:29.065]                             return(sendCondition)
[18:04:29.065]                           }
[18:04:29.065]                         }
[18:04:29.065]                         frame <- frame + 1L
[18:04:29.065]                         envir <- sys.frame(frame)
[18:04:29.065]                       }
[18:04:29.065]                     }
[18:04:29.065]                     sendCondition <<- function(cond) NULL
[18:04:29.065]                   }
[18:04:29.065]                 })
[18:04:29.065]                 withCallingHandlers({
[18:04:29.065]                   NA
[18:04:29.065]                 }, immediateCondition = function(cond) {
[18:04:29.065]                   sendCondition <- ...future.makeSendCondition()
[18:04:29.065]                   sendCondition(cond)
[18:04:29.065]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.065]                   {
[18:04:29.065]                     inherits <- base::inherits
[18:04:29.065]                     invokeRestart <- base::invokeRestart
[18:04:29.065]                     is.null <- base::is.null
[18:04:29.065]                     muffled <- FALSE
[18:04:29.065]                     if (inherits(cond, "message")) {
[18:04:29.065]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:29.065]                       if (muffled) 
[18:04:29.065]                         invokeRestart("muffleMessage")
[18:04:29.065]                     }
[18:04:29.065]                     else if (inherits(cond, "warning")) {
[18:04:29.065]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:29.065]                       if (muffled) 
[18:04:29.065]                         invokeRestart("muffleWarning")
[18:04:29.065]                     }
[18:04:29.065]                     else if (inherits(cond, "condition")) {
[18:04:29.065]                       if (!is.null(pattern)) {
[18:04:29.065]                         computeRestarts <- base::computeRestarts
[18:04:29.065]                         grepl <- base::grepl
[18:04:29.065]                         restarts <- computeRestarts(cond)
[18:04:29.065]                         for (restart in restarts) {
[18:04:29.065]                           name <- restart$name
[18:04:29.065]                           if (is.null(name)) 
[18:04:29.065]                             next
[18:04:29.065]                           if (!grepl(pattern, name)) 
[18:04:29.065]                             next
[18:04:29.065]                           invokeRestart(restart)
[18:04:29.065]                           muffled <- TRUE
[18:04:29.065]                           break
[18:04:29.065]                         }
[18:04:29.065]                       }
[18:04:29.065]                     }
[18:04:29.065]                     invisible(muffled)
[18:04:29.065]                   }
[18:04:29.065]                   muffleCondition(cond)
[18:04:29.065]                 })
[18:04:29.065]             }))
[18:04:29.065]             future::FutureResult(value = ...future.value$value, 
[18:04:29.065]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.065]                   ...future.rng), globalenv = if (FALSE) 
[18:04:29.065]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:29.065]                     ...future.globalenv.names))
[18:04:29.065]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:29.065]         }, condition = base::local({
[18:04:29.065]             c <- base::c
[18:04:29.065]             inherits <- base::inherits
[18:04:29.065]             invokeRestart <- base::invokeRestart
[18:04:29.065]             length <- base::length
[18:04:29.065]             list <- base::list
[18:04:29.065]             seq.int <- base::seq.int
[18:04:29.065]             signalCondition <- base::signalCondition
[18:04:29.065]             sys.calls <- base::sys.calls
[18:04:29.065]             `[[` <- base::`[[`
[18:04:29.065]             `+` <- base::`+`
[18:04:29.065]             `<<-` <- base::`<<-`
[18:04:29.065]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:29.065]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:29.065]                   3L)]
[18:04:29.065]             }
[18:04:29.065]             function(cond) {
[18:04:29.065]                 is_error <- inherits(cond, "error")
[18:04:29.065]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:29.065]                   NULL)
[18:04:29.065]                 if (is_error) {
[18:04:29.065]                   sessionInformation <- function() {
[18:04:29.065]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:29.065]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:29.065]                       search = base::search(), system = base::Sys.info())
[18:04:29.065]                   }
[18:04:29.065]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.065]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:29.065]                     cond$call), session = sessionInformation(), 
[18:04:29.065]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:29.065]                   signalCondition(cond)
[18:04:29.065]                 }
[18:04:29.065]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:29.065]                 "immediateCondition"))) {
[18:04:29.065]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:29.065]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.065]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:29.065]                   if (TRUE && !signal) {
[18:04:29.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.065]                     {
[18:04:29.065]                       inherits <- base::inherits
[18:04:29.065]                       invokeRestart <- base::invokeRestart
[18:04:29.065]                       is.null <- base::is.null
[18:04:29.065]                       muffled <- FALSE
[18:04:29.065]                       if (inherits(cond, "message")) {
[18:04:29.065]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.065]                         if (muffled) 
[18:04:29.065]                           invokeRestart("muffleMessage")
[18:04:29.065]                       }
[18:04:29.065]                       else if (inherits(cond, "warning")) {
[18:04:29.065]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.065]                         if (muffled) 
[18:04:29.065]                           invokeRestart("muffleWarning")
[18:04:29.065]                       }
[18:04:29.065]                       else if (inherits(cond, "condition")) {
[18:04:29.065]                         if (!is.null(pattern)) {
[18:04:29.065]                           computeRestarts <- base::computeRestarts
[18:04:29.065]                           grepl <- base::grepl
[18:04:29.065]                           restarts <- computeRestarts(cond)
[18:04:29.065]                           for (restart in restarts) {
[18:04:29.065]                             name <- restart$name
[18:04:29.065]                             if (is.null(name)) 
[18:04:29.065]                               next
[18:04:29.065]                             if (!grepl(pattern, name)) 
[18:04:29.065]                               next
[18:04:29.065]                             invokeRestart(restart)
[18:04:29.065]                             muffled <- TRUE
[18:04:29.065]                             break
[18:04:29.065]                           }
[18:04:29.065]                         }
[18:04:29.065]                       }
[18:04:29.065]                       invisible(muffled)
[18:04:29.065]                     }
[18:04:29.065]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.065]                   }
[18:04:29.065]                 }
[18:04:29.065]                 else {
[18:04:29.065]                   if (TRUE) {
[18:04:29.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.065]                     {
[18:04:29.065]                       inherits <- base::inherits
[18:04:29.065]                       invokeRestart <- base::invokeRestart
[18:04:29.065]                       is.null <- base::is.null
[18:04:29.065]                       muffled <- FALSE
[18:04:29.065]                       if (inherits(cond, "message")) {
[18:04:29.065]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.065]                         if (muffled) 
[18:04:29.065]                           invokeRestart("muffleMessage")
[18:04:29.065]                       }
[18:04:29.065]                       else if (inherits(cond, "warning")) {
[18:04:29.065]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.065]                         if (muffled) 
[18:04:29.065]                           invokeRestart("muffleWarning")
[18:04:29.065]                       }
[18:04:29.065]                       else if (inherits(cond, "condition")) {
[18:04:29.065]                         if (!is.null(pattern)) {
[18:04:29.065]                           computeRestarts <- base::computeRestarts
[18:04:29.065]                           grepl <- base::grepl
[18:04:29.065]                           restarts <- computeRestarts(cond)
[18:04:29.065]                           for (restart in restarts) {
[18:04:29.065]                             name <- restart$name
[18:04:29.065]                             if (is.null(name)) 
[18:04:29.065]                               next
[18:04:29.065]                             if (!grepl(pattern, name)) 
[18:04:29.065]                               next
[18:04:29.065]                             invokeRestart(restart)
[18:04:29.065]                             muffled <- TRUE
[18:04:29.065]                             break
[18:04:29.065]                           }
[18:04:29.065]                         }
[18:04:29.065]                       }
[18:04:29.065]                       invisible(muffled)
[18:04:29.065]                     }
[18:04:29.065]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.065]                   }
[18:04:29.065]                 }
[18:04:29.065]             }
[18:04:29.065]         }))
[18:04:29.065]     }, error = function(ex) {
[18:04:29.065]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:29.065]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.065]                 ...future.rng), started = ...future.startTime, 
[18:04:29.065]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:29.065]             version = "1.8"), class = "FutureResult")
[18:04:29.065]     }, finally = {
[18:04:29.065]         if (!identical(...future.workdir, getwd())) 
[18:04:29.065]             setwd(...future.workdir)
[18:04:29.065]         {
[18:04:29.065]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:29.065]                 ...future.oldOptions$nwarnings <- NULL
[18:04:29.065]             }
[18:04:29.065]             base::options(...future.oldOptions)
[18:04:29.065]             if (.Platform$OS.type == "windows") {
[18:04:29.065]                 old_names <- names(...future.oldEnvVars)
[18:04:29.065]                 envs <- base::Sys.getenv()
[18:04:29.065]                 names <- names(envs)
[18:04:29.065]                 common <- intersect(names, old_names)
[18:04:29.065]                 added <- setdiff(names, old_names)
[18:04:29.065]                 removed <- setdiff(old_names, names)
[18:04:29.065]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:29.065]                   envs[common]]
[18:04:29.065]                 NAMES <- toupper(changed)
[18:04:29.065]                 args <- list()
[18:04:29.065]                 for (kk in seq_along(NAMES)) {
[18:04:29.065]                   name <- changed[[kk]]
[18:04:29.065]                   NAME <- NAMES[[kk]]
[18:04:29.065]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.065]                     next
[18:04:29.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.065]                 }
[18:04:29.065]                 NAMES <- toupper(added)
[18:04:29.065]                 for (kk in seq_along(NAMES)) {
[18:04:29.065]                   name <- added[[kk]]
[18:04:29.065]                   NAME <- NAMES[[kk]]
[18:04:29.065]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.065]                     next
[18:04:29.065]                   args[[name]] <- ""
[18:04:29.065]                 }
[18:04:29.065]                 NAMES <- toupper(removed)
[18:04:29.065]                 for (kk in seq_along(NAMES)) {
[18:04:29.065]                   name <- removed[[kk]]
[18:04:29.065]                   NAME <- NAMES[[kk]]
[18:04:29.065]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.065]                     next
[18:04:29.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.065]                 }
[18:04:29.065]                 if (length(args) > 0) 
[18:04:29.065]                   base::do.call(base::Sys.setenv, args = args)
[18:04:29.065]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:29.065]             }
[18:04:29.065]             else {
[18:04:29.065]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:29.065]             }
[18:04:29.065]             {
[18:04:29.065]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:29.065]                   0L) {
[18:04:29.065]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:29.065]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:29.065]                   base::options(opts)
[18:04:29.065]                 }
[18:04:29.065]                 {
[18:04:29.065]                   {
[18:04:29.065]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:29.065]                     NULL
[18:04:29.065]                   }
[18:04:29.065]                   options(future.plan = NULL)
[18:04:29.065]                   if (is.na(NA_character_)) 
[18:04:29.065]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.065]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:29.065]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:29.065]                     .init = FALSE)
[18:04:29.065]                 }
[18:04:29.065]             }
[18:04:29.065]         }
[18:04:29.065]     })
[18:04:29.065]     if (TRUE) {
[18:04:29.065]         base::sink(type = "output", split = FALSE)
[18:04:29.065]         if (TRUE) {
[18:04:29.065]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:29.065]         }
[18:04:29.065]         else {
[18:04:29.065]             ...future.result["stdout"] <- base::list(NULL)
[18:04:29.065]         }
[18:04:29.065]         base::close(...future.stdout)
[18:04:29.065]         ...future.stdout <- NULL
[18:04:29.065]     }
[18:04:29.065]     ...future.result$conditions <- ...future.conditions
[18:04:29.065]     ...future.result$finished <- base::Sys.time()
[18:04:29.065]     ...future.result
[18:04:29.065] }
[18:04:29.169] MultisessionFuture started
[18:04:29.172] result() for ClusterFuture ...
[18:04:29.173] receiveMessageFromWorker() for ClusterFuture ...
[18:04:29.173] - Validating connection of MultisessionFuture
[18:04:29.277] - received message: FutureResult
[18:04:29.278] - Received FutureResult
[18:04:29.278] - Erased future from FutureRegistry
[18:04:29.278] result() for ClusterFuture ...
[18:04:29.279] - result already collected: FutureResult
[18:04:29.281] result() for ClusterFuture ... done
[18:04:29.281] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:29.282] result() for ClusterFuture ... done
[18:04:29.282] result() for ClusterFuture ...
[18:04:29.282] - result already collected: FutureResult
[18:04:29.283] result() for ClusterFuture ... done
[18:04:29.283] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:04:29.292] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[18:04:29.292] getGlobalsAndPackages() ...
[18:04:29.293] Searching for globals...
[18:04:29.298] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:29.298] Searching for globals ... DONE
[18:04:29.298] Resolving globals: FALSE
[18:04:29.300] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:29.300] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:29.301] - globals: [2] ‘weight’, ‘group’
[18:04:29.301] - packages: [1] ‘stats’
[18:04:29.301] getGlobalsAndPackages() ... DONE
[18:04:29.302] run() for ‘Future’ ...
[18:04:29.302] - state: ‘created’
[18:04:29.302] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:29.329] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:29.329] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:29.330]   - Field: ‘node’
[18:04:29.330]   - Field: ‘label’
[18:04:29.330]   - Field: ‘local’
[18:04:29.330]   - Field: ‘owner’
[18:04:29.331]   - Field: ‘envir’
[18:04:29.331]   - Field: ‘workers’
[18:04:29.331]   - Field: ‘packages’
[18:04:29.331]   - Field: ‘gc’
[18:04:29.331]   - Field: ‘conditions’
[18:04:29.332]   - Field: ‘persistent’
[18:04:29.332]   - Field: ‘expr’
[18:04:29.332]   - Field: ‘uuid’
[18:04:29.332]   - Field: ‘seed’
[18:04:29.333]   - Field: ‘version’
[18:04:29.333]   - Field: ‘result’
[18:04:29.333]   - Field: ‘asynchronous’
[18:04:29.333]   - Field: ‘calls’
[18:04:29.334]   - Field: ‘globals’
[18:04:29.334]   - Field: ‘stdout’
[18:04:29.334]   - Field: ‘earlySignal’
[18:04:29.334]   - Field: ‘lazy’
[18:04:29.334]   - Field: ‘state’
[18:04:29.335] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:29.335] - Launch lazy future ...
[18:04:29.336] Packages needed by the future expression (n = 1): ‘stats’
[18:04:29.336] Packages needed by future strategies (n = 0): <none>
[18:04:29.337] {
[18:04:29.337]     {
[18:04:29.337]         {
[18:04:29.337]             ...future.startTime <- base::Sys.time()
[18:04:29.337]             {
[18:04:29.337]                 {
[18:04:29.337]                   {
[18:04:29.337]                     {
[18:04:29.337]                       {
[18:04:29.337]                         base::local({
[18:04:29.337]                           has_future <- base::requireNamespace("future", 
[18:04:29.337]                             quietly = TRUE)
[18:04:29.337]                           if (has_future) {
[18:04:29.337]                             ns <- base::getNamespace("future")
[18:04:29.337]                             version <- ns[[".package"]][["version"]]
[18:04:29.337]                             if (is.null(version)) 
[18:04:29.337]                               version <- utils::packageVersion("future")
[18:04:29.337]                           }
[18:04:29.337]                           else {
[18:04:29.337]                             version <- NULL
[18:04:29.337]                           }
[18:04:29.337]                           if (!has_future || version < "1.8.0") {
[18:04:29.337]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:29.337]                               "", base::R.version$version.string), 
[18:04:29.337]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:29.337]                                 base::R.version$platform, 8 * 
[18:04:29.337]                                   base::.Machine$sizeof.pointer), 
[18:04:29.337]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:29.337]                                 "release", "version")], collapse = " "), 
[18:04:29.337]                               hostname = base::Sys.info()[["nodename"]])
[18:04:29.337]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:29.337]                               info)
[18:04:29.337]                             info <- base::paste(info, collapse = "; ")
[18:04:29.337]                             if (!has_future) {
[18:04:29.337]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:29.337]                                 info)
[18:04:29.337]                             }
[18:04:29.337]                             else {
[18:04:29.337]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:29.337]                                 info, version)
[18:04:29.337]                             }
[18:04:29.337]                             base::stop(msg)
[18:04:29.337]                           }
[18:04:29.337]                         })
[18:04:29.337]                       }
[18:04:29.337]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:29.337]                       base::options(mc.cores = 1L)
[18:04:29.337]                     }
[18:04:29.337]                     base::local({
[18:04:29.337]                       for (pkg in "stats") {
[18:04:29.337]                         base::loadNamespace(pkg)
[18:04:29.337]                         base::library(pkg, character.only = TRUE)
[18:04:29.337]                       }
[18:04:29.337]                     })
[18:04:29.337]                   }
[18:04:29.337]                   ...future.strategy.old <- future::plan("list")
[18:04:29.337]                   options(future.plan = NULL)
[18:04:29.337]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.337]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:29.337]                 }
[18:04:29.337]                 ...future.workdir <- getwd()
[18:04:29.337]             }
[18:04:29.337]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:29.337]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:29.337]         }
[18:04:29.337]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:29.337]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:29.337]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:29.337]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:29.337]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:29.337]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:29.337]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:29.337]             base::names(...future.oldOptions))
[18:04:29.337]     }
[18:04:29.337]     if (FALSE) {
[18:04:29.337]     }
[18:04:29.337]     else {
[18:04:29.337]         if (TRUE) {
[18:04:29.337]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:29.337]                 open = "w")
[18:04:29.337]         }
[18:04:29.337]         else {
[18:04:29.337]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:29.337]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:29.337]         }
[18:04:29.337]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:29.337]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:29.337]             base::sink(type = "output", split = FALSE)
[18:04:29.337]             base::close(...future.stdout)
[18:04:29.337]         }, add = TRUE)
[18:04:29.337]     }
[18:04:29.337]     ...future.frame <- base::sys.nframe()
[18:04:29.337]     ...future.conditions <- base::list()
[18:04:29.337]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:29.337]     if (FALSE) {
[18:04:29.337]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:29.337]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:29.337]     }
[18:04:29.337]     ...future.result <- base::tryCatch({
[18:04:29.337]         base::withCallingHandlers({
[18:04:29.337]             ...future.value <- base::withVisible(base::local({
[18:04:29.337]                 ...future.makeSendCondition <- base::local({
[18:04:29.337]                   sendCondition <- NULL
[18:04:29.337]                   function(frame = 1L) {
[18:04:29.337]                     if (is.function(sendCondition)) 
[18:04:29.337]                       return(sendCondition)
[18:04:29.337]                     ns <- getNamespace("parallel")
[18:04:29.337]                     if (exists("sendData", mode = "function", 
[18:04:29.337]                       envir = ns)) {
[18:04:29.337]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:29.337]                         envir = ns)
[18:04:29.337]                       envir <- sys.frame(frame)
[18:04:29.337]                       master <- NULL
[18:04:29.337]                       while (!identical(envir, .GlobalEnv) && 
[18:04:29.337]                         !identical(envir, emptyenv())) {
[18:04:29.337]                         if (exists("master", mode = "list", envir = envir, 
[18:04:29.337]                           inherits = FALSE)) {
[18:04:29.337]                           master <- get("master", mode = "list", 
[18:04:29.337]                             envir = envir, inherits = FALSE)
[18:04:29.337]                           if (inherits(master, c("SOCKnode", 
[18:04:29.337]                             "SOCK0node"))) {
[18:04:29.337]                             sendCondition <<- function(cond) {
[18:04:29.337]                               data <- list(type = "VALUE", value = cond, 
[18:04:29.337]                                 success = TRUE)
[18:04:29.337]                               parallel_sendData(master, data)
[18:04:29.337]                             }
[18:04:29.337]                             return(sendCondition)
[18:04:29.337]                           }
[18:04:29.337]                         }
[18:04:29.337]                         frame <- frame + 1L
[18:04:29.337]                         envir <- sys.frame(frame)
[18:04:29.337]                       }
[18:04:29.337]                     }
[18:04:29.337]                     sendCondition <<- function(cond) NULL
[18:04:29.337]                   }
[18:04:29.337]                 })
[18:04:29.337]                 withCallingHandlers({
[18:04:29.337]                   {
[18:04:29.337]                     lm(weight ~ group - 1)
[18:04:29.337]                   }
[18:04:29.337]                 }, immediateCondition = function(cond) {
[18:04:29.337]                   sendCondition <- ...future.makeSendCondition()
[18:04:29.337]                   sendCondition(cond)
[18:04:29.337]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.337]                   {
[18:04:29.337]                     inherits <- base::inherits
[18:04:29.337]                     invokeRestart <- base::invokeRestart
[18:04:29.337]                     is.null <- base::is.null
[18:04:29.337]                     muffled <- FALSE
[18:04:29.337]                     if (inherits(cond, "message")) {
[18:04:29.337]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:29.337]                       if (muffled) 
[18:04:29.337]                         invokeRestart("muffleMessage")
[18:04:29.337]                     }
[18:04:29.337]                     else if (inherits(cond, "warning")) {
[18:04:29.337]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:29.337]                       if (muffled) 
[18:04:29.337]                         invokeRestart("muffleWarning")
[18:04:29.337]                     }
[18:04:29.337]                     else if (inherits(cond, "condition")) {
[18:04:29.337]                       if (!is.null(pattern)) {
[18:04:29.337]                         computeRestarts <- base::computeRestarts
[18:04:29.337]                         grepl <- base::grepl
[18:04:29.337]                         restarts <- computeRestarts(cond)
[18:04:29.337]                         for (restart in restarts) {
[18:04:29.337]                           name <- restart$name
[18:04:29.337]                           if (is.null(name)) 
[18:04:29.337]                             next
[18:04:29.337]                           if (!grepl(pattern, name)) 
[18:04:29.337]                             next
[18:04:29.337]                           invokeRestart(restart)
[18:04:29.337]                           muffled <- TRUE
[18:04:29.337]                           break
[18:04:29.337]                         }
[18:04:29.337]                       }
[18:04:29.337]                     }
[18:04:29.337]                     invisible(muffled)
[18:04:29.337]                   }
[18:04:29.337]                   muffleCondition(cond)
[18:04:29.337]                 })
[18:04:29.337]             }))
[18:04:29.337]             future::FutureResult(value = ...future.value$value, 
[18:04:29.337]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.337]                   ...future.rng), globalenv = if (FALSE) 
[18:04:29.337]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:29.337]                     ...future.globalenv.names))
[18:04:29.337]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:29.337]         }, condition = base::local({
[18:04:29.337]             c <- base::c
[18:04:29.337]             inherits <- base::inherits
[18:04:29.337]             invokeRestart <- base::invokeRestart
[18:04:29.337]             length <- base::length
[18:04:29.337]             list <- base::list
[18:04:29.337]             seq.int <- base::seq.int
[18:04:29.337]             signalCondition <- base::signalCondition
[18:04:29.337]             sys.calls <- base::sys.calls
[18:04:29.337]             `[[` <- base::`[[`
[18:04:29.337]             `+` <- base::`+`
[18:04:29.337]             `<<-` <- base::`<<-`
[18:04:29.337]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:29.337]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:29.337]                   3L)]
[18:04:29.337]             }
[18:04:29.337]             function(cond) {
[18:04:29.337]                 is_error <- inherits(cond, "error")
[18:04:29.337]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:29.337]                   NULL)
[18:04:29.337]                 if (is_error) {
[18:04:29.337]                   sessionInformation <- function() {
[18:04:29.337]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:29.337]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:29.337]                       search = base::search(), system = base::Sys.info())
[18:04:29.337]                   }
[18:04:29.337]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.337]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:29.337]                     cond$call), session = sessionInformation(), 
[18:04:29.337]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:29.337]                   signalCondition(cond)
[18:04:29.337]                 }
[18:04:29.337]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:29.337]                 "immediateCondition"))) {
[18:04:29.337]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:29.337]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.337]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:29.337]                   if (TRUE && !signal) {
[18:04:29.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.337]                     {
[18:04:29.337]                       inherits <- base::inherits
[18:04:29.337]                       invokeRestart <- base::invokeRestart
[18:04:29.337]                       is.null <- base::is.null
[18:04:29.337]                       muffled <- FALSE
[18:04:29.337]                       if (inherits(cond, "message")) {
[18:04:29.337]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.337]                         if (muffled) 
[18:04:29.337]                           invokeRestart("muffleMessage")
[18:04:29.337]                       }
[18:04:29.337]                       else if (inherits(cond, "warning")) {
[18:04:29.337]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.337]                         if (muffled) 
[18:04:29.337]                           invokeRestart("muffleWarning")
[18:04:29.337]                       }
[18:04:29.337]                       else if (inherits(cond, "condition")) {
[18:04:29.337]                         if (!is.null(pattern)) {
[18:04:29.337]                           computeRestarts <- base::computeRestarts
[18:04:29.337]                           grepl <- base::grepl
[18:04:29.337]                           restarts <- computeRestarts(cond)
[18:04:29.337]                           for (restart in restarts) {
[18:04:29.337]                             name <- restart$name
[18:04:29.337]                             if (is.null(name)) 
[18:04:29.337]                               next
[18:04:29.337]                             if (!grepl(pattern, name)) 
[18:04:29.337]                               next
[18:04:29.337]                             invokeRestart(restart)
[18:04:29.337]                             muffled <- TRUE
[18:04:29.337]                             break
[18:04:29.337]                           }
[18:04:29.337]                         }
[18:04:29.337]                       }
[18:04:29.337]                       invisible(muffled)
[18:04:29.337]                     }
[18:04:29.337]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.337]                   }
[18:04:29.337]                 }
[18:04:29.337]                 else {
[18:04:29.337]                   if (TRUE) {
[18:04:29.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.337]                     {
[18:04:29.337]                       inherits <- base::inherits
[18:04:29.337]                       invokeRestart <- base::invokeRestart
[18:04:29.337]                       is.null <- base::is.null
[18:04:29.337]                       muffled <- FALSE
[18:04:29.337]                       if (inherits(cond, "message")) {
[18:04:29.337]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.337]                         if (muffled) 
[18:04:29.337]                           invokeRestart("muffleMessage")
[18:04:29.337]                       }
[18:04:29.337]                       else if (inherits(cond, "warning")) {
[18:04:29.337]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.337]                         if (muffled) 
[18:04:29.337]                           invokeRestart("muffleWarning")
[18:04:29.337]                       }
[18:04:29.337]                       else if (inherits(cond, "condition")) {
[18:04:29.337]                         if (!is.null(pattern)) {
[18:04:29.337]                           computeRestarts <- base::computeRestarts
[18:04:29.337]                           grepl <- base::grepl
[18:04:29.337]                           restarts <- computeRestarts(cond)
[18:04:29.337]                           for (restart in restarts) {
[18:04:29.337]                             name <- restart$name
[18:04:29.337]                             if (is.null(name)) 
[18:04:29.337]                               next
[18:04:29.337]                             if (!grepl(pattern, name)) 
[18:04:29.337]                               next
[18:04:29.337]                             invokeRestart(restart)
[18:04:29.337]                             muffled <- TRUE
[18:04:29.337]                             break
[18:04:29.337]                           }
[18:04:29.337]                         }
[18:04:29.337]                       }
[18:04:29.337]                       invisible(muffled)
[18:04:29.337]                     }
[18:04:29.337]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.337]                   }
[18:04:29.337]                 }
[18:04:29.337]             }
[18:04:29.337]         }))
[18:04:29.337]     }, error = function(ex) {
[18:04:29.337]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:29.337]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.337]                 ...future.rng), started = ...future.startTime, 
[18:04:29.337]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:29.337]             version = "1.8"), class = "FutureResult")
[18:04:29.337]     }, finally = {
[18:04:29.337]         if (!identical(...future.workdir, getwd())) 
[18:04:29.337]             setwd(...future.workdir)
[18:04:29.337]         {
[18:04:29.337]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:29.337]                 ...future.oldOptions$nwarnings <- NULL
[18:04:29.337]             }
[18:04:29.337]             base::options(...future.oldOptions)
[18:04:29.337]             if (.Platform$OS.type == "windows") {
[18:04:29.337]                 old_names <- names(...future.oldEnvVars)
[18:04:29.337]                 envs <- base::Sys.getenv()
[18:04:29.337]                 names <- names(envs)
[18:04:29.337]                 common <- intersect(names, old_names)
[18:04:29.337]                 added <- setdiff(names, old_names)
[18:04:29.337]                 removed <- setdiff(old_names, names)
[18:04:29.337]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:29.337]                   envs[common]]
[18:04:29.337]                 NAMES <- toupper(changed)
[18:04:29.337]                 args <- list()
[18:04:29.337]                 for (kk in seq_along(NAMES)) {
[18:04:29.337]                   name <- changed[[kk]]
[18:04:29.337]                   NAME <- NAMES[[kk]]
[18:04:29.337]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.337]                     next
[18:04:29.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.337]                 }
[18:04:29.337]                 NAMES <- toupper(added)
[18:04:29.337]                 for (kk in seq_along(NAMES)) {
[18:04:29.337]                   name <- added[[kk]]
[18:04:29.337]                   NAME <- NAMES[[kk]]
[18:04:29.337]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.337]                     next
[18:04:29.337]                   args[[name]] <- ""
[18:04:29.337]                 }
[18:04:29.337]                 NAMES <- toupper(removed)
[18:04:29.337]                 for (kk in seq_along(NAMES)) {
[18:04:29.337]                   name <- removed[[kk]]
[18:04:29.337]                   NAME <- NAMES[[kk]]
[18:04:29.337]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.337]                     next
[18:04:29.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.337]                 }
[18:04:29.337]                 if (length(args) > 0) 
[18:04:29.337]                   base::do.call(base::Sys.setenv, args = args)
[18:04:29.337]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:29.337]             }
[18:04:29.337]             else {
[18:04:29.337]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:29.337]             }
[18:04:29.337]             {
[18:04:29.337]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:29.337]                   0L) {
[18:04:29.337]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:29.337]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:29.337]                   base::options(opts)
[18:04:29.337]                 }
[18:04:29.337]                 {
[18:04:29.337]                   {
[18:04:29.337]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:29.337]                     NULL
[18:04:29.337]                   }
[18:04:29.337]                   options(future.plan = NULL)
[18:04:29.337]                   if (is.na(NA_character_)) 
[18:04:29.337]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.337]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:29.337]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:29.337]                     .init = FALSE)
[18:04:29.337]                 }
[18:04:29.337]             }
[18:04:29.337]         }
[18:04:29.337]     })
[18:04:29.337]     if (TRUE) {
[18:04:29.337]         base::sink(type = "output", split = FALSE)
[18:04:29.337]         if (TRUE) {
[18:04:29.337]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:29.337]         }
[18:04:29.337]         else {
[18:04:29.337]             ...future.result["stdout"] <- base::list(NULL)
[18:04:29.337]         }
[18:04:29.337]         base::close(...future.stdout)
[18:04:29.337]         ...future.stdout <- NULL
[18:04:29.337]     }
[18:04:29.337]     ...future.result$conditions <- ...future.conditions
[18:04:29.337]     ...future.result$finished <- base::Sys.time()
[18:04:29.337]     ...future.result
[18:04:29.337] }
[18:04:29.343] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[18:04:29.343] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[18:04:29.344] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[18:04:29.345] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[18:04:29.346] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[18:04:29.346] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[18:04:29.347] MultisessionFuture started
[18:04:29.347] - Launch lazy future ... done
[18:04:29.348] run() for ‘MultisessionFuture’ ... done
[18:04:29.350] result() for ClusterFuture ...
[18:04:29.350] receiveMessageFromWorker() for ClusterFuture ...
[18:04:29.350] - Validating connection of MultisessionFuture
[18:04:29.414] - received message: FutureResult
[18:04:29.415] - Received FutureResult
[18:04:29.415] - Erased future from FutureRegistry
[18:04:29.415] result() for ClusterFuture ...
[18:04:29.415] - result already collected: FutureResult
[18:04:29.416] result() for ClusterFuture ... done
[18:04:29.416] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:29.416] result() for ClusterFuture ... done
[18:04:29.416] result() for ClusterFuture ...
[18:04:29.416] - result already collected: FutureResult
[18:04:29.417] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[18:04:29.421] getGlobalsAndPackages() ...
[18:04:29.421] Searching for globals...
[18:04:29.425] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:29.426] Searching for globals ... DONE
[18:04:29.426] Resolving globals: FALSE
[18:04:29.427] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:29.428] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:29.428] - globals: [2] ‘weight’, ‘group’
[18:04:29.429] - packages: [1] ‘stats’
[18:04:29.429] getGlobalsAndPackages() ... DONE
[18:04:29.429] run() for ‘Future’ ...
[18:04:29.430] - state: ‘created’
[18:04:29.430] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:29.455] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:29.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:29.455]   - Field: ‘node’
[18:04:29.456]   - Field: ‘label’
[18:04:29.456]   - Field: ‘local’
[18:04:29.456]   - Field: ‘owner’
[18:04:29.456]   - Field: ‘envir’
[18:04:29.456]   - Field: ‘workers’
[18:04:29.457]   - Field: ‘packages’
[18:04:29.457]   - Field: ‘gc’
[18:04:29.457]   - Field: ‘conditions’
[18:04:29.457]   - Field: ‘persistent’
[18:04:29.458]   - Field: ‘expr’
[18:04:29.458]   - Field: ‘uuid’
[18:04:29.458]   - Field: ‘seed’
[18:04:29.458]   - Field: ‘version’
[18:04:29.459]   - Field: ‘result’
[18:04:29.459]   - Field: ‘asynchronous’
[18:04:29.459]   - Field: ‘calls’
[18:04:29.459]   - Field: ‘globals’
[18:04:29.460]   - Field: ‘stdout’
[18:04:29.460]   - Field: ‘earlySignal’
[18:04:29.460]   - Field: ‘lazy’
[18:04:29.460]   - Field: ‘state’
[18:04:29.460] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:29.461] - Launch lazy future ...
[18:04:29.461] Packages needed by the future expression (n = 1): ‘stats’
[18:04:29.462] Packages needed by future strategies (n = 0): <none>
[18:04:29.463] {
[18:04:29.463]     {
[18:04:29.463]         {
[18:04:29.463]             ...future.startTime <- base::Sys.time()
[18:04:29.463]             {
[18:04:29.463]                 {
[18:04:29.463]                   {
[18:04:29.463]                     {
[18:04:29.463]                       {
[18:04:29.463]                         base::local({
[18:04:29.463]                           has_future <- base::requireNamespace("future", 
[18:04:29.463]                             quietly = TRUE)
[18:04:29.463]                           if (has_future) {
[18:04:29.463]                             ns <- base::getNamespace("future")
[18:04:29.463]                             version <- ns[[".package"]][["version"]]
[18:04:29.463]                             if (is.null(version)) 
[18:04:29.463]                               version <- utils::packageVersion("future")
[18:04:29.463]                           }
[18:04:29.463]                           else {
[18:04:29.463]                             version <- NULL
[18:04:29.463]                           }
[18:04:29.463]                           if (!has_future || version < "1.8.0") {
[18:04:29.463]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:29.463]                               "", base::R.version$version.string), 
[18:04:29.463]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:29.463]                                 base::R.version$platform, 8 * 
[18:04:29.463]                                   base::.Machine$sizeof.pointer), 
[18:04:29.463]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:29.463]                                 "release", "version")], collapse = " "), 
[18:04:29.463]                               hostname = base::Sys.info()[["nodename"]])
[18:04:29.463]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:29.463]                               info)
[18:04:29.463]                             info <- base::paste(info, collapse = "; ")
[18:04:29.463]                             if (!has_future) {
[18:04:29.463]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:29.463]                                 info)
[18:04:29.463]                             }
[18:04:29.463]                             else {
[18:04:29.463]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:29.463]                                 info, version)
[18:04:29.463]                             }
[18:04:29.463]                             base::stop(msg)
[18:04:29.463]                           }
[18:04:29.463]                         })
[18:04:29.463]                       }
[18:04:29.463]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:29.463]                       base::options(mc.cores = 1L)
[18:04:29.463]                     }
[18:04:29.463]                     base::local({
[18:04:29.463]                       for (pkg in "stats") {
[18:04:29.463]                         base::loadNamespace(pkg)
[18:04:29.463]                         base::library(pkg, character.only = TRUE)
[18:04:29.463]                       }
[18:04:29.463]                     })
[18:04:29.463]                   }
[18:04:29.463]                   ...future.strategy.old <- future::plan("list")
[18:04:29.463]                   options(future.plan = NULL)
[18:04:29.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:29.463]                 }
[18:04:29.463]                 ...future.workdir <- getwd()
[18:04:29.463]             }
[18:04:29.463]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:29.463]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:29.463]         }
[18:04:29.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:29.463]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:29.463]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:29.463]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:29.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:29.463]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:29.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:29.463]             base::names(...future.oldOptions))
[18:04:29.463]     }
[18:04:29.463]     if (FALSE) {
[18:04:29.463]     }
[18:04:29.463]     else {
[18:04:29.463]         if (TRUE) {
[18:04:29.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:29.463]                 open = "w")
[18:04:29.463]         }
[18:04:29.463]         else {
[18:04:29.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:29.463]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:29.463]         }
[18:04:29.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:29.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:29.463]             base::sink(type = "output", split = FALSE)
[18:04:29.463]             base::close(...future.stdout)
[18:04:29.463]         }, add = TRUE)
[18:04:29.463]     }
[18:04:29.463]     ...future.frame <- base::sys.nframe()
[18:04:29.463]     ...future.conditions <- base::list()
[18:04:29.463]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:29.463]     if (FALSE) {
[18:04:29.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:29.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:29.463]     }
[18:04:29.463]     ...future.result <- base::tryCatch({
[18:04:29.463]         base::withCallingHandlers({
[18:04:29.463]             ...future.value <- base::withVisible(base::local({
[18:04:29.463]                 ...future.makeSendCondition <- base::local({
[18:04:29.463]                   sendCondition <- NULL
[18:04:29.463]                   function(frame = 1L) {
[18:04:29.463]                     if (is.function(sendCondition)) 
[18:04:29.463]                       return(sendCondition)
[18:04:29.463]                     ns <- getNamespace("parallel")
[18:04:29.463]                     if (exists("sendData", mode = "function", 
[18:04:29.463]                       envir = ns)) {
[18:04:29.463]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:29.463]                         envir = ns)
[18:04:29.463]                       envir <- sys.frame(frame)
[18:04:29.463]                       master <- NULL
[18:04:29.463]                       while (!identical(envir, .GlobalEnv) && 
[18:04:29.463]                         !identical(envir, emptyenv())) {
[18:04:29.463]                         if (exists("master", mode = "list", envir = envir, 
[18:04:29.463]                           inherits = FALSE)) {
[18:04:29.463]                           master <- get("master", mode = "list", 
[18:04:29.463]                             envir = envir, inherits = FALSE)
[18:04:29.463]                           if (inherits(master, c("SOCKnode", 
[18:04:29.463]                             "SOCK0node"))) {
[18:04:29.463]                             sendCondition <<- function(cond) {
[18:04:29.463]                               data <- list(type = "VALUE", value = cond, 
[18:04:29.463]                                 success = TRUE)
[18:04:29.463]                               parallel_sendData(master, data)
[18:04:29.463]                             }
[18:04:29.463]                             return(sendCondition)
[18:04:29.463]                           }
[18:04:29.463]                         }
[18:04:29.463]                         frame <- frame + 1L
[18:04:29.463]                         envir <- sys.frame(frame)
[18:04:29.463]                       }
[18:04:29.463]                     }
[18:04:29.463]                     sendCondition <<- function(cond) NULL
[18:04:29.463]                   }
[18:04:29.463]                 })
[18:04:29.463]                 withCallingHandlers({
[18:04:29.463]                   {
[18:04:29.463]                     lm(weight ~ group - 1)
[18:04:29.463]                   }
[18:04:29.463]                 }, immediateCondition = function(cond) {
[18:04:29.463]                   sendCondition <- ...future.makeSendCondition()
[18:04:29.463]                   sendCondition(cond)
[18:04:29.463]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.463]                   {
[18:04:29.463]                     inherits <- base::inherits
[18:04:29.463]                     invokeRestart <- base::invokeRestart
[18:04:29.463]                     is.null <- base::is.null
[18:04:29.463]                     muffled <- FALSE
[18:04:29.463]                     if (inherits(cond, "message")) {
[18:04:29.463]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:29.463]                       if (muffled) 
[18:04:29.463]                         invokeRestart("muffleMessage")
[18:04:29.463]                     }
[18:04:29.463]                     else if (inherits(cond, "warning")) {
[18:04:29.463]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:29.463]                       if (muffled) 
[18:04:29.463]                         invokeRestart("muffleWarning")
[18:04:29.463]                     }
[18:04:29.463]                     else if (inherits(cond, "condition")) {
[18:04:29.463]                       if (!is.null(pattern)) {
[18:04:29.463]                         computeRestarts <- base::computeRestarts
[18:04:29.463]                         grepl <- base::grepl
[18:04:29.463]                         restarts <- computeRestarts(cond)
[18:04:29.463]                         for (restart in restarts) {
[18:04:29.463]                           name <- restart$name
[18:04:29.463]                           if (is.null(name)) 
[18:04:29.463]                             next
[18:04:29.463]                           if (!grepl(pattern, name)) 
[18:04:29.463]                             next
[18:04:29.463]                           invokeRestart(restart)
[18:04:29.463]                           muffled <- TRUE
[18:04:29.463]                           break
[18:04:29.463]                         }
[18:04:29.463]                       }
[18:04:29.463]                     }
[18:04:29.463]                     invisible(muffled)
[18:04:29.463]                   }
[18:04:29.463]                   muffleCondition(cond)
[18:04:29.463]                 })
[18:04:29.463]             }))
[18:04:29.463]             future::FutureResult(value = ...future.value$value, 
[18:04:29.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.463]                   ...future.rng), globalenv = if (FALSE) 
[18:04:29.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:29.463]                     ...future.globalenv.names))
[18:04:29.463]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:29.463]         }, condition = base::local({
[18:04:29.463]             c <- base::c
[18:04:29.463]             inherits <- base::inherits
[18:04:29.463]             invokeRestart <- base::invokeRestart
[18:04:29.463]             length <- base::length
[18:04:29.463]             list <- base::list
[18:04:29.463]             seq.int <- base::seq.int
[18:04:29.463]             signalCondition <- base::signalCondition
[18:04:29.463]             sys.calls <- base::sys.calls
[18:04:29.463]             `[[` <- base::`[[`
[18:04:29.463]             `+` <- base::`+`
[18:04:29.463]             `<<-` <- base::`<<-`
[18:04:29.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:29.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:29.463]                   3L)]
[18:04:29.463]             }
[18:04:29.463]             function(cond) {
[18:04:29.463]                 is_error <- inherits(cond, "error")
[18:04:29.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:29.463]                   NULL)
[18:04:29.463]                 if (is_error) {
[18:04:29.463]                   sessionInformation <- function() {
[18:04:29.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:29.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:29.463]                       search = base::search(), system = base::Sys.info())
[18:04:29.463]                   }
[18:04:29.463]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:29.463]                     cond$call), session = sessionInformation(), 
[18:04:29.463]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:29.463]                   signalCondition(cond)
[18:04:29.463]                 }
[18:04:29.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:29.463]                 "immediateCondition"))) {
[18:04:29.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:29.463]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:29.463]                   if (TRUE && !signal) {
[18:04:29.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.463]                     {
[18:04:29.463]                       inherits <- base::inherits
[18:04:29.463]                       invokeRestart <- base::invokeRestart
[18:04:29.463]                       is.null <- base::is.null
[18:04:29.463]                       muffled <- FALSE
[18:04:29.463]                       if (inherits(cond, "message")) {
[18:04:29.463]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.463]                         if (muffled) 
[18:04:29.463]                           invokeRestart("muffleMessage")
[18:04:29.463]                       }
[18:04:29.463]                       else if (inherits(cond, "warning")) {
[18:04:29.463]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.463]                         if (muffled) 
[18:04:29.463]                           invokeRestart("muffleWarning")
[18:04:29.463]                       }
[18:04:29.463]                       else if (inherits(cond, "condition")) {
[18:04:29.463]                         if (!is.null(pattern)) {
[18:04:29.463]                           computeRestarts <- base::computeRestarts
[18:04:29.463]                           grepl <- base::grepl
[18:04:29.463]                           restarts <- computeRestarts(cond)
[18:04:29.463]                           for (restart in restarts) {
[18:04:29.463]                             name <- restart$name
[18:04:29.463]                             if (is.null(name)) 
[18:04:29.463]                               next
[18:04:29.463]                             if (!grepl(pattern, name)) 
[18:04:29.463]                               next
[18:04:29.463]                             invokeRestart(restart)
[18:04:29.463]                             muffled <- TRUE
[18:04:29.463]                             break
[18:04:29.463]                           }
[18:04:29.463]                         }
[18:04:29.463]                       }
[18:04:29.463]                       invisible(muffled)
[18:04:29.463]                     }
[18:04:29.463]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.463]                   }
[18:04:29.463]                 }
[18:04:29.463]                 else {
[18:04:29.463]                   if (TRUE) {
[18:04:29.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.463]                     {
[18:04:29.463]                       inherits <- base::inherits
[18:04:29.463]                       invokeRestart <- base::invokeRestart
[18:04:29.463]                       is.null <- base::is.null
[18:04:29.463]                       muffled <- FALSE
[18:04:29.463]                       if (inherits(cond, "message")) {
[18:04:29.463]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.463]                         if (muffled) 
[18:04:29.463]                           invokeRestart("muffleMessage")
[18:04:29.463]                       }
[18:04:29.463]                       else if (inherits(cond, "warning")) {
[18:04:29.463]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.463]                         if (muffled) 
[18:04:29.463]                           invokeRestart("muffleWarning")
[18:04:29.463]                       }
[18:04:29.463]                       else if (inherits(cond, "condition")) {
[18:04:29.463]                         if (!is.null(pattern)) {
[18:04:29.463]                           computeRestarts <- base::computeRestarts
[18:04:29.463]                           grepl <- base::grepl
[18:04:29.463]                           restarts <- computeRestarts(cond)
[18:04:29.463]                           for (restart in restarts) {
[18:04:29.463]                             name <- restart$name
[18:04:29.463]                             if (is.null(name)) 
[18:04:29.463]                               next
[18:04:29.463]                             if (!grepl(pattern, name)) 
[18:04:29.463]                               next
[18:04:29.463]                             invokeRestart(restart)
[18:04:29.463]                             muffled <- TRUE
[18:04:29.463]                             break
[18:04:29.463]                           }
[18:04:29.463]                         }
[18:04:29.463]                       }
[18:04:29.463]                       invisible(muffled)
[18:04:29.463]                     }
[18:04:29.463]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.463]                   }
[18:04:29.463]                 }
[18:04:29.463]             }
[18:04:29.463]         }))
[18:04:29.463]     }, error = function(ex) {
[18:04:29.463]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:29.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.463]                 ...future.rng), started = ...future.startTime, 
[18:04:29.463]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:29.463]             version = "1.8"), class = "FutureResult")
[18:04:29.463]     }, finally = {
[18:04:29.463]         if (!identical(...future.workdir, getwd())) 
[18:04:29.463]             setwd(...future.workdir)
[18:04:29.463]         {
[18:04:29.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:29.463]                 ...future.oldOptions$nwarnings <- NULL
[18:04:29.463]             }
[18:04:29.463]             base::options(...future.oldOptions)
[18:04:29.463]             if (.Platform$OS.type == "windows") {
[18:04:29.463]                 old_names <- names(...future.oldEnvVars)
[18:04:29.463]                 envs <- base::Sys.getenv()
[18:04:29.463]                 names <- names(envs)
[18:04:29.463]                 common <- intersect(names, old_names)
[18:04:29.463]                 added <- setdiff(names, old_names)
[18:04:29.463]                 removed <- setdiff(old_names, names)
[18:04:29.463]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:29.463]                   envs[common]]
[18:04:29.463]                 NAMES <- toupper(changed)
[18:04:29.463]                 args <- list()
[18:04:29.463]                 for (kk in seq_along(NAMES)) {
[18:04:29.463]                   name <- changed[[kk]]
[18:04:29.463]                   NAME <- NAMES[[kk]]
[18:04:29.463]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.463]                     next
[18:04:29.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.463]                 }
[18:04:29.463]                 NAMES <- toupper(added)
[18:04:29.463]                 for (kk in seq_along(NAMES)) {
[18:04:29.463]                   name <- added[[kk]]
[18:04:29.463]                   NAME <- NAMES[[kk]]
[18:04:29.463]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.463]                     next
[18:04:29.463]                   args[[name]] <- ""
[18:04:29.463]                 }
[18:04:29.463]                 NAMES <- toupper(removed)
[18:04:29.463]                 for (kk in seq_along(NAMES)) {
[18:04:29.463]                   name <- removed[[kk]]
[18:04:29.463]                   NAME <- NAMES[[kk]]
[18:04:29.463]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.463]                     next
[18:04:29.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.463]                 }
[18:04:29.463]                 if (length(args) > 0) 
[18:04:29.463]                   base::do.call(base::Sys.setenv, args = args)
[18:04:29.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:29.463]             }
[18:04:29.463]             else {
[18:04:29.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:29.463]             }
[18:04:29.463]             {
[18:04:29.463]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:29.463]                   0L) {
[18:04:29.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:29.463]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:29.463]                   base::options(opts)
[18:04:29.463]                 }
[18:04:29.463]                 {
[18:04:29.463]                   {
[18:04:29.463]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:29.463]                     NULL
[18:04:29.463]                   }
[18:04:29.463]                   options(future.plan = NULL)
[18:04:29.463]                   if (is.na(NA_character_)) 
[18:04:29.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:29.463]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:29.463]                     .init = FALSE)
[18:04:29.463]                 }
[18:04:29.463]             }
[18:04:29.463]         }
[18:04:29.463]     })
[18:04:29.463]     if (TRUE) {
[18:04:29.463]         base::sink(type = "output", split = FALSE)
[18:04:29.463]         if (TRUE) {
[18:04:29.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:29.463]         }
[18:04:29.463]         else {
[18:04:29.463]             ...future.result["stdout"] <- base::list(NULL)
[18:04:29.463]         }
[18:04:29.463]         base::close(...future.stdout)
[18:04:29.463]         ...future.stdout <- NULL
[18:04:29.463]     }
[18:04:29.463]     ...future.result$conditions <- ...future.conditions
[18:04:29.463]     ...future.result$finished <- base::Sys.time()
[18:04:29.463]     ...future.result
[18:04:29.463] }
[18:04:29.469] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[18:04:29.469] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[18:04:29.470] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[18:04:29.471] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[18:04:29.472] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[18:04:29.472] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[18:04:29.474] MultisessionFuture started
[18:04:29.474] - Launch lazy future ... done
[18:04:29.474] run() for ‘MultisessionFuture’ ... done
[18:04:29.475] result() for ClusterFuture ...
[18:04:29.475] receiveMessageFromWorker() for ClusterFuture ...
[18:04:29.475] - Validating connection of MultisessionFuture
[18:04:29.518] - received message: FutureResult
[18:04:29.519] - Received FutureResult
[18:04:29.519] - Erased future from FutureRegistry
[18:04:29.519] result() for ClusterFuture ...
[18:04:29.520] - result already collected: FutureResult
[18:04:29.520] result() for ClusterFuture ... done
[18:04:29.520] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:29.520] result() for ClusterFuture ... done
[18:04:29.521] result() for ClusterFuture ...
[18:04:29.521] - result already collected: FutureResult
[18:04:29.521] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[18:04:29.526] getGlobalsAndPackages() ...
[18:04:29.526] Searching for globals...
[18:04:29.530] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:29.531] Searching for globals ... DONE
[18:04:29.531] Resolving globals: FALSE
[18:04:29.532] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:29.533] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:29.533] - globals: [2] ‘weight’, ‘group’
[18:04:29.534] - packages: [1] ‘stats’
[18:04:29.534] getGlobalsAndPackages() ... DONE
[18:04:29.535] run() for ‘Future’ ...
[18:04:29.535] - state: ‘created’
[18:04:29.535] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:29.560] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:29.561] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:29.561]   - Field: ‘node’
[18:04:29.561]   - Field: ‘label’
[18:04:29.561]   - Field: ‘local’
[18:04:29.562]   - Field: ‘owner’
[18:04:29.562]   - Field: ‘envir’
[18:04:29.562]   - Field: ‘workers’
[18:04:29.562]   - Field: ‘packages’
[18:04:29.562]   - Field: ‘gc’
[18:04:29.563]   - Field: ‘conditions’
[18:04:29.563]   - Field: ‘persistent’
[18:04:29.563]   - Field: ‘expr’
[18:04:29.563]   - Field: ‘uuid’
[18:04:29.564]   - Field: ‘seed’
[18:04:29.564]   - Field: ‘version’
[18:04:29.564]   - Field: ‘result’
[18:04:29.564]   - Field: ‘asynchronous’
[18:04:29.565]   - Field: ‘calls’
[18:04:29.565]   - Field: ‘globals’
[18:04:29.565]   - Field: ‘stdout’
[18:04:29.565]   - Field: ‘earlySignal’
[18:04:29.566]   - Field: ‘lazy’
[18:04:29.566]   - Field: ‘state’
[18:04:29.566] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:29.566] - Launch lazy future ...
[18:04:29.567] Packages needed by the future expression (n = 1): ‘stats’
[18:04:29.567] Packages needed by future strategies (n = 0): <none>
[18:04:29.568] {
[18:04:29.568]     {
[18:04:29.568]         {
[18:04:29.568]             ...future.startTime <- base::Sys.time()
[18:04:29.568]             {
[18:04:29.568]                 {
[18:04:29.568]                   {
[18:04:29.568]                     {
[18:04:29.568]                       {
[18:04:29.568]                         base::local({
[18:04:29.568]                           has_future <- base::requireNamespace("future", 
[18:04:29.568]                             quietly = TRUE)
[18:04:29.568]                           if (has_future) {
[18:04:29.568]                             ns <- base::getNamespace("future")
[18:04:29.568]                             version <- ns[[".package"]][["version"]]
[18:04:29.568]                             if (is.null(version)) 
[18:04:29.568]                               version <- utils::packageVersion("future")
[18:04:29.568]                           }
[18:04:29.568]                           else {
[18:04:29.568]                             version <- NULL
[18:04:29.568]                           }
[18:04:29.568]                           if (!has_future || version < "1.8.0") {
[18:04:29.568]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:29.568]                               "", base::R.version$version.string), 
[18:04:29.568]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:29.568]                                 base::R.version$platform, 8 * 
[18:04:29.568]                                   base::.Machine$sizeof.pointer), 
[18:04:29.568]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:29.568]                                 "release", "version")], collapse = " "), 
[18:04:29.568]                               hostname = base::Sys.info()[["nodename"]])
[18:04:29.568]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:29.568]                               info)
[18:04:29.568]                             info <- base::paste(info, collapse = "; ")
[18:04:29.568]                             if (!has_future) {
[18:04:29.568]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:29.568]                                 info)
[18:04:29.568]                             }
[18:04:29.568]                             else {
[18:04:29.568]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:29.568]                                 info, version)
[18:04:29.568]                             }
[18:04:29.568]                             base::stop(msg)
[18:04:29.568]                           }
[18:04:29.568]                         })
[18:04:29.568]                       }
[18:04:29.568]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:29.568]                       base::options(mc.cores = 1L)
[18:04:29.568]                     }
[18:04:29.568]                     base::local({
[18:04:29.568]                       for (pkg in "stats") {
[18:04:29.568]                         base::loadNamespace(pkg)
[18:04:29.568]                         base::library(pkg, character.only = TRUE)
[18:04:29.568]                       }
[18:04:29.568]                     })
[18:04:29.568]                   }
[18:04:29.568]                   ...future.strategy.old <- future::plan("list")
[18:04:29.568]                   options(future.plan = NULL)
[18:04:29.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:29.568]                 }
[18:04:29.568]                 ...future.workdir <- getwd()
[18:04:29.568]             }
[18:04:29.568]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:29.568]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:29.568]         }
[18:04:29.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:29.568]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:29.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:29.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:29.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:29.568]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:29.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:29.568]             base::names(...future.oldOptions))
[18:04:29.568]     }
[18:04:29.568]     if (FALSE) {
[18:04:29.568]     }
[18:04:29.568]     else {
[18:04:29.568]         if (TRUE) {
[18:04:29.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:29.568]                 open = "w")
[18:04:29.568]         }
[18:04:29.568]         else {
[18:04:29.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:29.568]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:29.568]         }
[18:04:29.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:29.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:29.568]             base::sink(type = "output", split = FALSE)
[18:04:29.568]             base::close(...future.stdout)
[18:04:29.568]         }, add = TRUE)
[18:04:29.568]     }
[18:04:29.568]     ...future.frame <- base::sys.nframe()
[18:04:29.568]     ...future.conditions <- base::list()
[18:04:29.568]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:29.568]     if (FALSE) {
[18:04:29.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:29.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:29.568]     }
[18:04:29.568]     ...future.result <- base::tryCatch({
[18:04:29.568]         base::withCallingHandlers({
[18:04:29.568]             ...future.value <- base::withVisible(base::local({
[18:04:29.568]                 ...future.makeSendCondition <- base::local({
[18:04:29.568]                   sendCondition <- NULL
[18:04:29.568]                   function(frame = 1L) {
[18:04:29.568]                     if (is.function(sendCondition)) 
[18:04:29.568]                       return(sendCondition)
[18:04:29.568]                     ns <- getNamespace("parallel")
[18:04:29.568]                     if (exists("sendData", mode = "function", 
[18:04:29.568]                       envir = ns)) {
[18:04:29.568]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:29.568]                         envir = ns)
[18:04:29.568]                       envir <- sys.frame(frame)
[18:04:29.568]                       master <- NULL
[18:04:29.568]                       while (!identical(envir, .GlobalEnv) && 
[18:04:29.568]                         !identical(envir, emptyenv())) {
[18:04:29.568]                         if (exists("master", mode = "list", envir = envir, 
[18:04:29.568]                           inherits = FALSE)) {
[18:04:29.568]                           master <- get("master", mode = "list", 
[18:04:29.568]                             envir = envir, inherits = FALSE)
[18:04:29.568]                           if (inherits(master, c("SOCKnode", 
[18:04:29.568]                             "SOCK0node"))) {
[18:04:29.568]                             sendCondition <<- function(cond) {
[18:04:29.568]                               data <- list(type = "VALUE", value = cond, 
[18:04:29.568]                                 success = TRUE)
[18:04:29.568]                               parallel_sendData(master, data)
[18:04:29.568]                             }
[18:04:29.568]                             return(sendCondition)
[18:04:29.568]                           }
[18:04:29.568]                         }
[18:04:29.568]                         frame <- frame + 1L
[18:04:29.568]                         envir <- sys.frame(frame)
[18:04:29.568]                       }
[18:04:29.568]                     }
[18:04:29.568]                     sendCondition <<- function(cond) NULL
[18:04:29.568]                   }
[18:04:29.568]                 })
[18:04:29.568]                 withCallingHandlers({
[18:04:29.568]                   {
[18:04:29.568]                     lm(weight ~ group - 1)
[18:04:29.568]                   }
[18:04:29.568]                 }, immediateCondition = function(cond) {
[18:04:29.568]                   sendCondition <- ...future.makeSendCondition()
[18:04:29.568]                   sendCondition(cond)
[18:04:29.568]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.568]                   {
[18:04:29.568]                     inherits <- base::inherits
[18:04:29.568]                     invokeRestart <- base::invokeRestart
[18:04:29.568]                     is.null <- base::is.null
[18:04:29.568]                     muffled <- FALSE
[18:04:29.568]                     if (inherits(cond, "message")) {
[18:04:29.568]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:29.568]                       if (muffled) 
[18:04:29.568]                         invokeRestart("muffleMessage")
[18:04:29.568]                     }
[18:04:29.568]                     else if (inherits(cond, "warning")) {
[18:04:29.568]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:29.568]                       if (muffled) 
[18:04:29.568]                         invokeRestart("muffleWarning")
[18:04:29.568]                     }
[18:04:29.568]                     else if (inherits(cond, "condition")) {
[18:04:29.568]                       if (!is.null(pattern)) {
[18:04:29.568]                         computeRestarts <- base::computeRestarts
[18:04:29.568]                         grepl <- base::grepl
[18:04:29.568]                         restarts <- computeRestarts(cond)
[18:04:29.568]                         for (restart in restarts) {
[18:04:29.568]                           name <- restart$name
[18:04:29.568]                           if (is.null(name)) 
[18:04:29.568]                             next
[18:04:29.568]                           if (!grepl(pattern, name)) 
[18:04:29.568]                             next
[18:04:29.568]                           invokeRestart(restart)
[18:04:29.568]                           muffled <- TRUE
[18:04:29.568]                           break
[18:04:29.568]                         }
[18:04:29.568]                       }
[18:04:29.568]                     }
[18:04:29.568]                     invisible(muffled)
[18:04:29.568]                   }
[18:04:29.568]                   muffleCondition(cond)
[18:04:29.568]                 })
[18:04:29.568]             }))
[18:04:29.568]             future::FutureResult(value = ...future.value$value, 
[18:04:29.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.568]                   ...future.rng), globalenv = if (FALSE) 
[18:04:29.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:29.568]                     ...future.globalenv.names))
[18:04:29.568]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:29.568]         }, condition = base::local({
[18:04:29.568]             c <- base::c
[18:04:29.568]             inherits <- base::inherits
[18:04:29.568]             invokeRestart <- base::invokeRestart
[18:04:29.568]             length <- base::length
[18:04:29.568]             list <- base::list
[18:04:29.568]             seq.int <- base::seq.int
[18:04:29.568]             signalCondition <- base::signalCondition
[18:04:29.568]             sys.calls <- base::sys.calls
[18:04:29.568]             `[[` <- base::`[[`
[18:04:29.568]             `+` <- base::`+`
[18:04:29.568]             `<<-` <- base::`<<-`
[18:04:29.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:29.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:29.568]                   3L)]
[18:04:29.568]             }
[18:04:29.568]             function(cond) {
[18:04:29.568]                 is_error <- inherits(cond, "error")
[18:04:29.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:29.568]                   NULL)
[18:04:29.568]                 if (is_error) {
[18:04:29.568]                   sessionInformation <- function() {
[18:04:29.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:29.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:29.568]                       search = base::search(), system = base::Sys.info())
[18:04:29.568]                   }
[18:04:29.568]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:29.568]                     cond$call), session = sessionInformation(), 
[18:04:29.568]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:29.568]                   signalCondition(cond)
[18:04:29.568]                 }
[18:04:29.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:29.568]                 "immediateCondition"))) {
[18:04:29.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:29.568]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:29.568]                   if (TRUE && !signal) {
[18:04:29.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.568]                     {
[18:04:29.568]                       inherits <- base::inherits
[18:04:29.568]                       invokeRestart <- base::invokeRestart
[18:04:29.568]                       is.null <- base::is.null
[18:04:29.568]                       muffled <- FALSE
[18:04:29.568]                       if (inherits(cond, "message")) {
[18:04:29.568]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.568]                         if (muffled) 
[18:04:29.568]                           invokeRestart("muffleMessage")
[18:04:29.568]                       }
[18:04:29.568]                       else if (inherits(cond, "warning")) {
[18:04:29.568]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.568]                         if (muffled) 
[18:04:29.568]                           invokeRestart("muffleWarning")
[18:04:29.568]                       }
[18:04:29.568]                       else if (inherits(cond, "condition")) {
[18:04:29.568]                         if (!is.null(pattern)) {
[18:04:29.568]                           computeRestarts <- base::computeRestarts
[18:04:29.568]                           grepl <- base::grepl
[18:04:29.568]                           restarts <- computeRestarts(cond)
[18:04:29.568]                           for (restart in restarts) {
[18:04:29.568]                             name <- restart$name
[18:04:29.568]                             if (is.null(name)) 
[18:04:29.568]                               next
[18:04:29.568]                             if (!grepl(pattern, name)) 
[18:04:29.568]                               next
[18:04:29.568]                             invokeRestart(restart)
[18:04:29.568]                             muffled <- TRUE
[18:04:29.568]                             break
[18:04:29.568]                           }
[18:04:29.568]                         }
[18:04:29.568]                       }
[18:04:29.568]                       invisible(muffled)
[18:04:29.568]                     }
[18:04:29.568]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.568]                   }
[18:04:29.568]                 }
[18:04:29.568]                 else {
[18:04:29.568]                   if (TRUE) {
[18:04:29.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.568]                     {
[18:04:29.568]                       inherits <- base::inherits
[18:04:29.568]                       invokeRestart <- base::invokeRestart
[18:04:29.568]                       is.null <- base::is.null
[18:04:29.568]                       muffled <- FALSE
[18:04:29.568]                       if (inherits(cond, "message")) {
[18:04:29.568]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.568]                         if (muffled) 
[18:04:29.568]                           invokeRestart("muffleMessage")
[18:04:29.568]                       }
[18:04:29.568]                       else if (inherits(cond, "warning")) {
[18:04:29.568]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.568]                         if (muffled) 
[18:04:29.568]                           invokeRestart("muffleWarning")
[18:04:29.568]                       }
[18:04:29.568]                       else if (inherits(cond, "condition")) {
[18:04:29.568]                         if (!is.null(pattern)) {
[18:04:29.568]                           computeRestarts <- base::computeRestarts
[18:04:29.568]                           grepl <- base::grepl
[18:04:29.568]                           restarts <- computeRestarts(cond)
[18:04:29.568]                           for (restart in restarts) {
[18:04:29.568]                             name <- restart$name
[18:04:29.568]                             if (is.null(name)) 
[18:04:29.568]                               next
[18:04:29.568]                             if (!grepl(pattern, name)) 
[18:04:29.568]                               next
[18:04:29.568]                             invokeRestart(restart)
[18:04:29.568]                             muffled <- TRUE
[18:04:29.568]                             break
[18:04:29.568]                           }
[18:04:29.568]                         }
[18:04:29.568]                       }
[18:04:29.568]                       invisible(muffled)
[18:04:29.568]                     }
[18:04:29.568]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.568]                   }
[18:04:29.568]                 }
[18:04:29.568]             }
[18:04:29.568]         }))
[18:04:29.568]     }, error = function(ex) {
[18:04:29.568]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:29.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.568]                 ...future.rng), started = ...future.startTime, 
[18:04:29.568]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:29.568]             version = "1.8"), class = "FutureResult")
[18:04:29.568]     }, finally = {
[18:04:29.568]         if (!identical(...future.workdir, getwd())) 
[18:04:29.568]             setwd(...future.workdir)
[18:04:29.568]         {
[18:04:29.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:29.568]                 ...future.oldOptions$nwarnings <- NULL
[18:04:29.568]             }
[18:04:29.568]             base::options(...future.oldOptions)
[18:04:29.568]             if (.Platform$OS.type == "windows") {
[18:04:29.568]                 old_names <- names(...future.oldEnvVars)
[18:04:29.568]                 envs <- base::Sys.getenv()
[18:04:29.568]                 names <- names(envs)
[18:04:29.568]                 common <- intersect(names, old_names)
[18:04:29.568]                 added <- setdiff(names, old_names)
[18:04:29.568]                 removed <- setdiff(old_names, names)
[18:04:29.568]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:29.568]                   envs[common]]
[18:04:29.568]                 NAMES <- toupper(changed)
[18:04:29.568]                 args <- list()
[18:04:29.568]                 for (kk in seq_along(NAMES)) {
[18:04:29.568]                   name <- changed[[kk]]
[18:04:29.568]                   NAME <- NAMES[[kk]]
[18:04:29.568]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.568]                     next
[18:04:29.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.568]                 }
[18:04:29.568]                 NAMES <- toupper(added)
[18:04:29.568]                 for (kk in seq_along(NAMES)) {
[18:04:29.568]                   name <- added[[kk]]
[18:04:29.568]                   NAME <- NAMES[[kk]]
[18:04:29.568]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.568]                     next
[18:04:29.568]                   args[[name]] <- ""
[18:04:29.568]                 }
[18:04:29.568]                 NAMES <- toupper(removed)
[18:04:29.568]                 for (kk in seq_along(NAMES)) {
[18:04:29.568]                   name <- removed[[kk]]
[18:04:29.568]                   NAME <- NAMES[[kk]]
[18:04:29.568]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.568]                     next
[18:04:29.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.568]                 }
[18:04:29.568]                 if (length(args) > 0) 
[18:04:29.568]                   base::do.call(base::Sys.setenv, args = args)
[18:04:29.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:29.568]             }
[18:04:29.568]             else {
[18:04:29.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:29.568]             }
[18:04:29.568]             {
[18:04:29.568]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:29.568]                   0L) {
[18:04:29.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:29.568]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:29.568]                   base::options(opts)
[18:04:29.568]                 }
[18:04:29.568]                 {
[18:04:29.568]                   {
[18:04:29.568]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:29.568]                     NULL
[18:04:29.568]                   }
[18:04:29.568]                   options(future.plan = NULL)
[18:04:29.568]                   if (is.na(NA_character_)) 
[18:04:29.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:29.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:29.568]                     .init = FALSE)
[18:04:29.568]                 }
[18:04:29.568]             }
[18:04:29.568]         }
[18:04:29.568]     })
[18:04:29.568]     if (TRUE) {
[18:04:29.568]         base::sink(type = "output", split = FALSE)
[18:04:29.568]         if (TRUE) {
[18:04:29.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:29.568]         }
[18:04:29.568]         else {
[18:04:29.568]             ...future.result["stdout"] <- base::list(NULL)
[18:04:29.568]         }
[18:04:29.568]         base::close(...future.stdout)
[18:04:29.568]         ...future.stdout <- NULL
[18:04:29.568]     }
[18:04:29.568]     ...future.result$conditions <- ...future.conditions
[18:04:29.568]     ...future.result$finished <- base::Sys.time()
[18:04:29.568]     ...future.result
[18:04:29.568] }
[18:04:29.574] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[18:04:29.574] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[18:04:29.575] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[18:04:29.576] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[18:04:29.577] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[18:04:29.577] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[18:04:29.578] MultisessionFuture started
[18:04:29.578] - Launch lazy future ... done
[18:04:29.578] run() for ‘MultisessionFuture’ ... done
[18:04:29.579] result() for ClusterFuture ...
[18:04:29.582] receiveMessageFromWorker() for ClusterFuture ...
[18:04:29.582] - Validating connection of MultisessionFuture
[18:04:29.625] - received message: FutureResult
[18:04:29.625] - Received FutureResult
[18:04:29.626] - Erased future from FutureRegistry
[18:04:29.626] result() for ClusterFuture ...
[18:04:29.626] - result already collected: FutureResult
[18:04:29.626] result() for ClusterFuture ... done
[18:04:29.627] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:29.627] result() for ClusterFuture ... done
[18:04:29.627] result() for ClusterFuture ...
[18:04:29.627] - result already collected: FutureResult
[18:04:29.627] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[18:04:29.631] getGlobalsAndPackages() ...
[18:04:29.631] Searching for globals...
[18:04:29.635] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:29.635] Searching for globals ... DONE
[18:04:29.635] Resolving globals: FALSE
[18:04:29.637] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:29.638] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:29.638] - globals: [2] ‘weight’, ‘group’
[18:04:29.638] - packages: [1] ‘stats’
[18:04:29.639] getGlobalsAndPackages() ... DONE
[18:04:29.639] run() for ‘Future’ ...
[18:04:29.640] - state: ‘created’
[18:04:29.640] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:29.663] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:29.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:29.664]   - Field: ‘node’
[18:04:29.664]   - Field: ‘label’
[18:04:29.664]   - Field: ‘local’
[18:04:29.665]   - Field: ‘owner’
[18:04:29.665]   - Field: ‘envir’
[18:04:29.665]   - Field: ‘workers’
[18:04:29.665]   - Field: ‘packages’
[18:04:29.666]   - Field: ‘gc’
[18:04:29.666]   - Field: ‘conditions’
[18:04:29.666]   - Field: ‘persistent’
[18:04:29.666]   - Field: ‘expr’
[18:04:29.666]   - Field: ‘uuid’
[18:04:29.666]   - Field: ‘seed’
[18:04:29.667]   - Field: ‘version’
[18:04:29.667]   - Field: ‘result’
[18:04:29.667]   - Field: ‘asynchronous’
[18:04:29.667]   - Field: ‘calls’
[18:04:29.667]   - Field: ‘globals’
[18:04:29.668]   - Field: ‘stdout’
[18:04:29.668]   - Field: ‘earlySignal’
[18:04:29.668]   - Field: ‘lazy’
[18:04:29.668]   - Field: ‘state’
[18:04:29.668] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:29.669] - Launch lazy future ...
[18:04:29.669] Packages needed by the future expression (n = 1): ‘stats’
[18:04:29.669] Packages needed by future strategies (n = 0): <none>
[18:04:29.670] {
[18:04:29.670]     {
[18:04:29.670]         {
[18:04:29.670]             ...future.startTime <- base::Sys.time()
[18:04:29.670]             {
[18:04:29.670]                 {
[18:04:29.670]                   {
[18:04:29.670]                     {
[18:04:29.670]                       {
[18:04:29.670]                         base::local({
[18:04:29.670]                           has_future <- base::requireNamespace("future", 
[18:04:29.670]                             quietly = TRUE)
[18:04:29.670]                           if (has_future) {
[18:04:29.670]                             ns <- base::getNamespace("future")
[18:04:29.670]                             version <- ns[[".package"]][["version"]]
[18:04:29.670]                             if (is.null(version)) 
[18:04:29.670]                               version <- utils::packageVersion("future")
[18:04:29.670]                           }
[18:04:29.670]                           else {
[18:04:29.670]                             version <- NULL
[18:04:29.670]                           }
[18:04:29.670]                           if (!has_future || version < "1.8.0") {
[18:04:29.670]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:29.670]                               "", base::R.version$version.string), 
[18:04:29.670]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:29.670]                                 base::R.version$platform, 8 * 
[18:04:29.670]                                   base::.Machine$sizeof.pointer), 
[18:04:29.670]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:29.670]                                 "release", "version")], collapse = " "), 
[18:04:29.670]                               hostname = base::Sys.info()[["nodename"]])
[18:04:29.670]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:29.670]                               info)
[18:04:29.670]                             info <- base::paste(info, collapse = "; ")
[18:04:29.670]                             if (!has_future) {
[18:04:29.670]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:29.670]                                 info)
[18:04:29.670]                             }
[18:04:29.670]                             else {
[18:04:29.670]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:29.670]                                 info, version)
[18:04:29.670]                             }
[18:04:29.670]                             base::stop(msg)
[18:04:29.670]                           }
[18:04:29.670]                         })
[18:04:29.670]                       }
[18:04:29.670]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:29.670]                       base::options(mc.cores = 1L)
[18:04:29.670]                     }
[18:04:29.670]                     base::local({
[18:04:29.670]                       for (pkg in "stats") {
[18:04:29.670]                         base::loadNamespace(pkg)
[18:04:29.670]                         base::library(pkg, character.only = TRUE)
[18:04:29.670]                       }
[18:04:29.670]                     })
[18:04:29.670]                   }
[18:04:29.670]                   ...future.strategy.old <- future::plan("list")
[18:04:29.670]                   options(future.plan = NULL)
[18:04:29.670]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.670]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:29.670]                 }
[18:04:29.670]                 ...future.workdir <- getwd()
[18:04:29.670]             }
[18:04:29.670]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:29.670]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:29.670]         }
[18:04:29.670]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:29.670]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:29.670]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:29.670]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:29.670]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:29.670]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:29.670]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:29.670]             base::names(...future.oldOptions))
[18:04:29.670]     }
[18:04:29.670]     if (FALSE) {
[18:04:29.670]     }
[18:04:29.670]     else {
[18:04:29.670]         if (TRUE) {
[18:04:29.670]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:29.670]                 open = "w")
[18:04:29.670]         }
[18:04:29.670]         else {
[18:04:29.670]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:29.670]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:29.670]         }
[18:04:29.670]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:29.670]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:29.670]             base::sink(type = "output", split = FALSE)
[18:04:29.670]             base::close(...future.stdout)
[18:04:29.670]         }, add = TRUE)
[18:04:29.670]     }
[18:04:29.670]     ...future.frame <- base::sys.nframe()
[18:04:29.670]     ...future.conditions <- base::list()
[18:04:29.670]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:29.670]     if (FALSE) {
[18:04:29.670]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:29.670]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:29.670]     }
[18:04:29.670]     ...future.result <- base::tryCatch({
[18:04:29.670]         base::withCallingHandlers({
[18:04:29.670]             ...future.value <- base::withVisible(base::local({
[18:04:29.670]                 ...future.makeSendCondition <- base::local({
[18:04:29.670]                   sendCondition <- NULL
[18:04:29.670]                   function(frame = 1L) {
[18:04:29.670]                     if (is.function(sendCondition)) 
[18:04:29.670]                       return(sendCondition)
[18:04:29.670]                     ns <- getNamespace("parallel")
[18:04:29.670]                     if (exists("sendData", mode = "function", 
[18:04:29.670]                       envir = ns)) {
[18:04:29.670]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:29.670]                         envir = ns)
[18:04:29.670]                       envir <- sys.frame(frame)
[18:04:29.670]                       master <- NULL
[18:04:29.670]                       while (!identical(envir, .GlobalEnv) && 
[18:04:29.670]                         !identical(envir, emptyenv())) {
[18:04:29.670]                         if (exists("master", mode = "list", envir = envir, 
[18:04:29.670]                           inherits = FALSE)) {
[18:04:29.670]                           master <- get("master", mode = "list", 
[18:04:29.670]                             envir = envir, inherits = FALSE)
[18:04:29.670]                           if (inherits(master, c("SOCKnode", 
[18:04:29.670]                             "SOCK0node"))) {
[18:04:29.670]                             sendCondition <<- function(cond) {
[18:04:29.670]                               data <- list(type = "VALUE", value = cond, 
[18:04:29.670]                                 success = TRUE)
[18:04:29.670]                               parallel_sendData(master, data)
[18:04:29.670]                             }
[18:04:29.670]                             return(sendCondition)
[18:04:29.670]                           }
[18:04:29.670]                         }
[18:04:29.670]                         frame <- frame + 1L
[18:04:29.670]                         envir <- sys.frame(frame)
[18:04:29.670]                       }
[18:04:29.670]                     }
[18:04:29.670]                     sendCondition <<- function(cond) NULL
[18:04:29.670]                   }
[18:04:29.670]                 })
[18:04:29.670]                 withCallingHandlers({
[18:04:29.670]                   {
[18:04:29.670]                     lm(weight ~ group - 1)
[18:04:29.670]                   }
[18:04:29.670]                 }, immediateCondition = function(cond) {
[18:04:29.670]                   sendCondition <- ...future.makeSendCondition()
[18:04:29.670]                   sendCondition(cond)
[18:04:29.670]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.670]                   {
[18:04:29.670]                     inherits <- base::inherits
[18:04:29.670]                     invokeRestart <- base::invokeRestart
[18:04:29.670]                     is.null <- base::is.null
[18:04:29.670]                     muffled <- FALSE
[18:04:29.670]                     if (inherits(cond, "message")) {
[18:04:29.670]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:29.670]                       if (muffled) 
[18:04:29.670]                         invokeRestart("muffleMessage")
[18:04:29.670]                     }
[18:04:29.670]                     else if (inherits(cond, "warning")) {
[18:04:29.670]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:29.670]                       if (muffled) 
[18:04:29.670]                         invokeRestart("muffleWarning")
[18:04:29.670]                     }
[18:04:29.670]                     else if (inherits(cond, "condition")) {
[18:04:29.670]                       if (!is.null(pattern)) {
[18:04:29.670]                         computeRestarts <- base::computeRestarts
[18:04:29.670]                         grepl <- base::grepl
[18:04:29.670]                         restarts <- computeRestarts(cond)
[18:04:29.670]                         for (restart in restarts) {
[18:04:29.670]                           name <- restart$name
[18:04:29.670]                           if (is.null(name)) 
[18:04:29.670]                             next
[18:04:29.670]                           if (!grepl(pattern, name)) 
[18:04:29.670]                             next
[18:04:29.670]                           invokeRestart(restart)
[18:04:29.670]                           muffled <- TRUE
[18:04:29.670]                           break
[18:04:29.670]                         }
[18:04:29.670]                       }
[18:04:29.670]                     }
[18:04:29.670]                     invisible(muffled)
[18:04:29.670]                   }
[18:04:29.670]                   muffleCondition(cond)
[18:04:29.670]                 })
[18:04:29.670]             }))
[18:04:29.670]             future::FutureResult(value = ...future.value$value, 
[18:04:29.670]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.670]                   ...future.rng), globalenv = if (FALSE) 
[18:04:29.670]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:29.670]                     ...future.globalenv.names))
[18:04:29.670]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:29.670]         }, condition = base::local({
[18:04:29.670]             c <- base::c
[18:04:29.670]             inherits <- base::inherits
[18:04:29.670]             invokeRestart <- base::invokeRestart
[18:04:29.670]             length <- base::length
[18:04:29.670]             list <- base::list
[18:04:29.670]             seq.int <- base::seq.int
[18:04:29.670]             signalCondition <- base::signalCondition
[18:04:29.670]             sys.calls <- base::sys.calls
[18:04:29.670]             `[[` <- base::`[[`
[18:04:29.670]             `+` <- base::`+`
[18:04:29.670]             `<<-` <- base::`<<-`
[18:04:29.670]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:29.670]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:29.670]                   3L)]
[18:04:29.670]             }
[18:04:29.670]             function(cond) {
[18:04:29.670]                 is_error <- inherits(cond, "error")
[18:04:29.670]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:29.670]                   NULL)
[18:04:29.670]                 if (is_error) {
[18:04:29.670]                   sessionInformation <- function() {
[18:04:29.670]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:29.670]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:29.670]                       search = base::search(), system = base::Sys.info())
[18:04:29.670]                   }
[18:04:29.670]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.670]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:29.670]                     cond$call), session = sessionInformation(), 
[18:04:29.670]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:29.670]                   signalCondition(cond)
[18:04:29.670]                 }
[18:04:29.670]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:29.670]                 "immediateCondition"))) {
[18:04:29.670]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:29.670]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.670]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:29.670]                   if (TRUE && !signal) {
[18:04:29.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.670]                     {
[18:04:29.670]                       inherits <- base::inherits
[18:04:29.670]                       invokeRestart <- base::invokeRestart
[18:04:29.670]                       is.null <- base::is.null
[18:04:29.670]                       muffled <- FALSE
[18:04:29.670]                       if (inherits(cond, "message")) {
[18:04:29.670]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.670]                         if (muffled) 
[18:04:29.670]                           invokeRestart("muffleMessage")
[18:04:29.670]                       }
[18:04:29.670]                       else if (inherits(cond, "warning")) {
[18:04:29.670]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.670]                         if (muffled) 
[18:04:29.670]                           invokeRestart("muffleWarning")
[18:04:29.670]                       }
[18:04:29.670]                       else if (inherits(cond, "condition")) {
[18:04:29.670]                         if (!is.null(pattern)) {
[18:04:29.670]                           computeRestarts <- base::computeRestarts
[18:04:29.670]                           grepl <- base::grepl
[18:04:29.670]                           restarts <- computeRestarts(cond)
[18:04:29.670]                           for (restart in restarts) {
[18:04:29.670]                             name <- restart$name
[18:04:29.670]                             if (is.null(name)) 
[18:04:29.670]                               next
[18:04:29.670]                             if (!grepl(pattern, name)) 
[18:04:29.670]                               next
[18:04:29.670]                             invokeRestart(restart)
[18:04:29.670]                             muffled <- TRUE
[18:04:29.670]                             break
[18:04:29.670]                           }
[18:04:29.670]                         }
[18:04:29.670]                       }
[18:04:29.670]                       invisible(muffled)
[18:04:29.670]                     }
[18:04:29.670]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.670]                   }
[18:04:29.670]                 }
[18:04:29.670]                 else {
[18:04:29.670]                   if (TRUE) {
[18:04:29.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.670]                     {
[18:04:29.670]                       inherits <- base::inherits
[18:04:29.670]                       invokeRestart <- base::invokeRestart
[18:04:29.670]                       is.null <- base::is.null
[18:04:29.670]                       muffled <- FALSE
[18:04:29.670]                       if (inherits(cond, "message")) {
[18:04:29.670]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.670]                         if (muffled) 
[18:04:29.670]                           invokeRestart("muffleMessage")
[18:04:29.670]                       }
[18:04:29.670]                       else if (inherits(cond, "warning")) {
[18:04:29.670]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.670]                         if (muffled) 
[18:04:29.670]                           invokeRestart("muffleWarning")
[18:04:29.670]                       }
[18:04:29.670]                       else if (inherits(cond, "condition")) {
[18:04:29.670]                         if (!is.null(pattern)) {
[18:04:29.670]                           computeRestarts <- base::computeRestarts
[18:04:29.670]                           grepl <- base::grepl
[18:04:29.670]                           restarts <- computeRestarts(cond)
[18:04:29.670]                           for (restart in restarts) {
[18:04:29.670]                             name <- restart$name
[18:04:29.670]                             if (is.null(name)) 
[18:04:29.670]                               next
[18:04:29.670]                             if (!grepl(pattern, name)) 
[18:04:29.670]                               next
[18:04:29.670]                             invokeRestart(restart)
[18:04:29.670]                             muffled <- TRUE
[18:04:29.670]                             break
[18:04:29.670]                           }
[18:04:29.670]                         }
[18:04:29.670]                       }
[18:04:29.670]                       invisible(muffled)
[18:04:29.670]                     }
[18:04:29.670]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.670]                   }
[18:04:29.670]                 }
[18:04:29.670]             }
[18:04:29.670]         }))
[18:04:29.670]     }, error = function(ex) {
[18:04:29.670]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:29.670]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.670]                 ...future.rng), started = ...future.startTime, 
[18:04:29.670]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:29.670]             version = "1.8"), class = "FutureResult")
[18:04:29.670]     }, finally = {
[18:04:29.670]         if (!identical(...future.workdir, getwd())) 
[18:04:29.670]             setwd(...future.workdir)
[18:04:29.670]         {
[18:04:29.670]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:29.670]                 ...future.oldOptions$nwarnings <- NULL
[18:04:29.670]             }
[18:04:29.670]             base::options(...future.oldOptions)
[18:04:29.670]             if (.Platform$OS.type == "windows") {
[18:04:29.670]                 old_names <- names(...future.oldEnvVars)
[18:04:29.670]                 envs <- base::Sys.getenv()
[18:04:29.670]                 names <- names(envs)
[18:04:29.670]                 common <- intersect(names, old_names)
[18:04:29.670]                 added <- setdiff(names, old_names)
[18:04:29.670]                 removed <- setdiff(old_names, names)
[18:04:29.670]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:29.670]                   envs[common]]
[18:04:29.670]                 NAMES <- toupper(changed)
[18:04:29.670]                 args <- list()
[18:04:29.670]                 for (kk in seq_along(NAMES)) {
[18:04:29.670]                   name <- changed[[kk]]
[18:04:29.670]                   NAME <- NAMES[[kk]]
[18:04:29.670]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.670]                     next
[18:04:29.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.670]                 }
[18:04:29.670]                 NAMES <- toupper(added)
[18:04:29.670]                 for (kk in seq_along(NAMES)) {
[18:04:29.670]                   name <- added[[kk]]
[18:04:29.670]                   NAME <- NAMES[[kk]]
[18:04:29.670]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.670]                     next
[18:04:29.670]                   args[[name]] <- ""
[18:04:29.670]                 }
[18:04:29.670]                 NAMES <- toupper(removed)
[18:04:29.670]                 for (kk in seq_along(NAMES)) {
[18:04:29.670]                   name <- removed[[kk]]
[18:04:29.670]                   NAME <- NAMES[[kk]]
[18:04:29.670]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.670]                     next
[18:04:29.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.670]                 }
[18:04:29.670]                 if (length(args) > 0) 
[18:04:29.670]                   base::do.call(base::Sys.setenv, args = args)
[18:04:29.670]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:29.670]             }
[18:04:29.670]             else {
[18:04:29.670]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:29.670]             }
[18:04:29.670]             {
[18:04:29.670]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:29.670]                   0L) {
[18:04:29.670]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:29.670]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:29.670]                   base::options(opts)
[18:04:29.670]                 }
[18:04:29.670]                 {
[18:04:29.670]                   {
[18:04:29.670]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:29.670]                     NULL
[18:04:29.670]                   }
[18:04:29.670]                   options(future.plan = NULL)
[18:04:29.670]                   if (is.na(NA_character_)) 
[18:04:29.670]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.670]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:29.670]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:29.670]                     .init = FALSE)
[18:04:29.670]                 }
[18:04:29.670]             }
[18:04:29.670]         }
[18:04:29.670]     })
[18:04:29.670]     if (TRUE) {
[18:04:29.670]         base::sink(type = "output", split = FALSE)
[18:04:29.670]         if (TRUE) {
[18:04:29.670]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:29.670]         }
[18:04:29.670]         else {
[18:04:29.670]             ...future.result["stdout"] <- base::list(NULL)
[18:04:29.670]         }
[18:04:29.670]         base::close(...future.stdout)
[18:04:29.670]         ...future.stdout <- NULL
[18:04:29.670]     }
[18:04:29.670]     ...future.result$conditions <- ...future.conditions
[18:04:29.670]     ...future.result$finished <- base::Sys.time()
[18:04:29.670]     ...future.result
[18:04:29.670] }
[18:04:29.676] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[18:04:29.676] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[18:04:29.677] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[18:04:29.677] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[18:04:29.678] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[18:04:29.678] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[18:04:29.679] MultisessionFuture started
[18:04:29.679] - Launch lazy future ... done
[18:04:29.679] run() for ‘MultisessionFuture’ ... done
[18:04:29.679] result() for ClusterFuture ...
[18:04:29.680] receiveMessageFromWorker() for ClusterFuture ...
[18:04:29.681] - Validating connection of MultisessionFuture
[18:04:29.724] - received message: FutureResult
[18:04:29.725] - Received FutureResult
[18:04:29.725] - Erased future from FutureRegistry
[18:04:29.725] result() for ClusterFuture ...
[18:04:29.726] - result already collected: FutureResult
[18:04:29.726] result() for ClusterFuture ... done
[18:04:29.726] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:29.726] result() for ClusterFuture ... done
[18:04:29.726] result() for ClusterFuture ...
[18:04:29.727] - result already collected: FutureResult
[18:04:29.727] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[18:04:29.731] getGlobalsAndPackages() ...
[18:04:29.731] Searching for globals...
[18:04:29.735] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[18:04:29.735] Searching for globals ... DONE
[18:04:29.735] Resolving globals: FALSE
[18:04:29.736] The total size of the 2 globals is 896 bytes (896 bytes)
[18:04:29.737] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[18:04:29.738] - globals: [2] ‘weight’, ‘group’
[18:04:29.738] - packages: [1] ‘stats’
[18:04:29.738] getGlobalsAndPackages() ... DONE
[18:04:29.739] run() for ‘Future’ ...
[18:04:29.739] - state: ‘created’
[18:04:29.740] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:29.764] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:29.765] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:29.765]   - Field: ‘node’
[18:04:29.765]   - Field: ‘label’
[18:04:29.765]   - Field: ‘local’
[18:04:29.766]   - Field: ‘owner’
[18:04:29.766]   - Field: ‘envir’
[18:04:29.766]   - Field: ‘workers’
[18:04:29.766]   - Field: ‘packages’
[18:04:29.766]   - Field: ‘gc’
[18:04:29.767]   - Field: ‘conditions’
[18:04:29.767]   - Field: ‘persistent’
[18:04:29.767]   - Field: ‘expr’
[18:04:29.767]   - Field: ‘uuid’
[18:04:29.767]   - Field: ‘seed’
[18:04:29.768]   - Field: ‘version’
[18:04:29.768]   - Field: ‘result’
[18:04:29.768]   - Field: ‘asynchronous’
[18:04:29.768]   - Field: ‘calls’
[18:04:29.768]   - Field: ‘globals’
[18:04:29.769]   - Field: ‘stdout’
[18:04:29.769]   - Field: ‘earlySignal’
[18:04:29.769]   - Field: ‘lazy’
[18:04:29.769]   - Field: ‘state’
[18:04:29.769] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:29.770] - Launch lazy future ...
[18:04:29.770] Packages needed by the future expression (n = 1): ‘stats’
[18:04:29.771] Packages needed by future strategies (n = 0): <none>
[18:04:29.772] {
[18:04:29.772]     {
[18:04:29.772]         {
[18:04:29.772]             ...future.startTime <- base::Sys.time()
[18:04:29.772]             {
[18:04:29.772]                 {
[18:04:29.772]                   {
[18:04:29.772]                     {
[18:04:29.772]                       {
[18:04:29.772]                         base::local({
[18:04:29.772]                           has_future <- base::requireNamespace("future", 
[18:04:29.772]                             quietly = TRUE)
[18:04:29.772]                           if (has_future) {
[18:04:29.772]                             ns <- base::getNamespace("future")
[18:04:29.772]                             version <- ns[[".package"]][["version"]]
[18:04:29.772]                             if (is.null(version)) 
[18:04:29.772]                               version <- utils::packageVersion("future")
[18:04:29.772]                           }
[18:04:29.772]                           else {
[18:04:29.772]                             version <- NULL
[18:04:29.772]                           }
[18:04:29.772]                           if (!has_future || version < "1.8.0") {
[18:04:29.772]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:29.772]                               "", base::R.version$version.string), 
[18:04:29.772]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:29.772]                                 base::R.version$platform, 8 * 
[18:04:29.772]                                   base::.Machine$sizeof.pointer), 
[18:04:29.772]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:29.772]                                 "release", "version")], collapse = " "), 
[18:04:29.772]                               hostname = base::Sys.info()[["nodename"]])
[18:04:29.772]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:29.772]                               info)
[18:04:29.772]                             info <- base::paste(info, collapse = "; ")
[18:04:29.772]                             if (!has_future) {
[18:04:29.772]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:29.772]                                 info)
[18:04:29.772]                             }
[18:04:29.772]                             else {
[18:04:29.772]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:29.772]                                 info, version)
[18:04:29.772]                             }
[18:04:29.772]                             base::stop(msg)
[18:04:29.772]                           }
[18:04:29.772]                         })
[18:04:29.772]                       }
[18:04:29.772]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:29.772]                       base::options(mc.cores = 1L)
[18:04:29.772]                     }
[18:04:29.772]                     base::local({
[18:04:29.772]                       for (pkg in "stats") {
[18:04:29.772]                         base::loadNamespace(pkg)
[18:04:29.772]                         base::library(pkg, character.only = TRUE)
[18:04:29.772]                       }
[18:04:29.772]                     })
[18:04:29.772]                   }
[18:04:29.772]                   ...future.strategy.old <- future::plan("list")
[18:04:29.772]                   options(future.plan = NULL)
[18:04:29.772]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.772]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:29.772]                 }
[18:04:29.772]                 ...future.workdir <- getwd()
[18:04:29.772]             }
[18:04:29.772]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:29.772]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:29.772]         }
[18:04:29.772]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:29.772]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:29.772]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:29.772]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:29.772]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:29.772]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:29.772]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:29.772]             base::names(...future.oldOptions))
[18:04:29.772]     }
[18:04:29.772]     if (FALSE) {
[18:04:29.772]     }
[18:04:29.772]     else {
[18:04:29.772]         if (TRUE) {
[18:04:29.772]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:29.772]                 open = "w")
[18:04:29.772]         }
[18:04:29.772]         else {
[18:04:29.772]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:29.772]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:29.772]         }
[18:04:29.772]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:29.772]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:29.772]             base::sink(type = "output", split = FALSE)
[18:04:29.772]             base::close(...future.stdout)
[18:04:29.772]         }, add = TRUE)
[18:04:29.772]     }
[18:04:29.772]     ...future.frame <- base::sys.nframe()
[18:04:29.772]     ...future.conditions <- base::list()
[18:04:29.772]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:29.772]     if (FALSE) {
[18:04:29.772]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:29.772]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:29.772]     }
[18:04:29.772]     ...future.result <- base::tryCatch({
[18:04:29.772]         base::withCallingHandlers({
[18:04:29.772]             ...future.value <- base::withVisible(base::local({
[18:04:29.772]                 ...future.makeSendCondition <- base::local({
[18:04:29.772]                   sendCondition <- NULL
[18:04:29.772]                   function(frame = 1L) {
[18:04:29.772]                     if (is.function(sendCondition)) 
[18:04:29.772]                       return(sendCondition)
[18:04:29.772]                     ns <- getNamespace("parallel")
[18:04:29.772]                     if (exists("sendData", mode = "function", 
[18:04:29.772]                       envir = ns)) {
[18:04:29.772]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:29.772]                         envir = ns)
[18:04:29.772]                       envir <- sys.frame(frame)
[18:04:29.772]                       master <- NULL
[18:04:29.772]                       while (!identical(envir, .GlobalEnv) && 
[18:04:29.772]                         !identical(envir, emptyenv())) {
[18:04:29.772]                         if (exists("master", mode = "list", envir = envir, 
[18:04:29.772]                           inherits = FALSE)) {
[18:04:29.772]                           master <- get("master", mode = "list", 
[18:04:29.772]                             envir = envir, inherits = FALSE)
[18:04:29.772]                           if (inherits(master, c("SOCKnode", 
[18:04:29.772]                             "SOCK0node"))) {
[18:04:29.772]                             sendCondition <<- function(cond) {
[18:04:29.772]                               data <- list(type = "VALUE", value = cond, 
[18:04:29.772]                                 success = TRUE)
[18:04:29.772]                               parallel_sendData(master, data)
[18:04:29.772]                             }
[18:04:29.772]                             return(sendCondition)
[18:04:29.772]                           }
[18:04:29.772]                         }
[18:04:29.772]                         frame <- frame + 1L
[18:04:29.772]                         envir <- sys.frame(frame)
[18:04:29.772]                       }
[18:04:29.772]                     }
[18:04:29.772]                     sendCondition <<- function(cond) NULL
[18:04:29.772]                   }
[18:04:29.772]                 })
[18:04:29.772]                 withCallingHandlers({
[18:04:29.772]                   {
[18:04:29.772]                     lm(weight ~ group - 1)
[18:04:29.772]                   }
[18:04:29.772]                 }, immediateCondition = function(cond) {
[18:04:29.772]                   sendCondition <- ...future.makeSendCondition()
[18:04:29.772]                   sendCondition(cond)
[18:04:29.772]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.772]                   {
[18:04:29.772]                     inherits <- base::inherits
[18:04:29.772]                     invokeRestart <- base::invokeRestart
[18:04:29.772]                     is.null <- base::is.null
[18:04:29.772]                     muffled <- FALSE
[18:04:29.772]                     if (inherits(cond, "message")) {
[18:04:29.772]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:29.772]                       if (muffled) 
[18:04:29.772]                         invokeRestart("muffleMessage")
[18:04:29.772]                     }
[18:04:29.772]                     else if (inherits(cond, "warning")) {
[18:04:29.772]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:29.772]                       if (muffled) 
[18:04:29.772]                         invokeRestart("muffleWarning")
[18:04:29.772]                     }
[18:04:29.772]                     else if (inherits(cond, "condition")) {
[18:04:29.772]                       if (!is.null(pattern)) {
[18:04:29.772]                         computeRestarts <- base::computeRestarts
[18:04:29.772]                         grepl <- base::grepl
[18:04:29.772]                         restarts <- computeRestarts(cond)
[18:04:29.772]                         for (restart in restarts) {
[18:04:29.772]                           name <- restart$name
[18:04:29.772]                           if (is.null(name)) 
[18:04:29.772]                             next
[18:04:29.772]                           if (!grepl(pattern, name)) 
[18:04:29.772]                             next
[18:04:29.772]                           invokeRestart(restart)
[18:04:29.772]                           muffled <- TRUE
[18:04:29.772]                           break
[18:04:29.772]                         }
[18:04:29.772]                       }
[18:04:29.772]                     }
[18:04:29.772]                     invisible(muffled)
[18:04:29.772]                   }
[18:04:29.772]                   muffleCondition(cond)
[18:04:29.772]                 })
[18:04:29.772]             }))
[18:04:29.772]             future::FutureResult(value = ...future.value$value, 
[18:04:29.772]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.772]                   ...future.rng), globalenv = if (FALSE) 
[18:04:29.772]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:29.772]                     ...future.globalenv.names))
[18:04:29.772]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:29.772]         }, condition = base::local({
[18:04:29.772]             c <- base::c
[18:04:29.772]             inherits <- base::inherits
[18:04:29.772]             invokeRestart <- base::invokeRestart
[18:04:29.772]             length <- base::length
[18:04:29.772]             list <- base::list
[18:04:29.772]             seq.int <- base::seq.int
[18:04:29.772]             signalCondition <- base::signalCondition
[18:04:29.772]             sys.calls <- base::sys.calls
[18:04:29.772]             `[[` <- base::`[[`
[18:04:29.772]             `+` <- base::`+`
[18:04:29.772]             `<<-` <- base::`<<-`
[18:04:29.772]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:29.772]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:29.772]                   3L)]
[18:04:29.772]             }
[18:04:29.772]             function(cond) {
[18:04:29.772]                 is_error <- inherits(cond, "error")
[18:04:29.772]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:29.772]                   NULL)
[18:04:29.772]                 if (is_error) {
[18:04:29.772]                   sessionInformation <- function() {
[18:04:29.772]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:29.772]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:29.772]                       search = base::search(), system = base::Sys.info())
[18:04:29.772]                   }
[18:04:29.772]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.772]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:29.772]                     cond$call), session = sessionInformation(), 
[18:04:29.772]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:29.772]                   signalCondition(cond)
[18:04:29.772]                 }
[18:04:29.772]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:29.772]                 "immediateCondition"))) {
[18:04:29.772]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:29.772]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.772]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:29.772]                   if (TRUE && !signal) {
[18:04:29.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.772]                     {
[18:04:29.772]                       inherits <- base::inherits
[18:04:29.772]                       invokeRestart <- base::invokeRestart
[18:04:29.772]                       is.null <- base::is.null
[18:04:29.772]                       muffled <- FALSE
[18:04:29.772]                       if (inherits(cond, "message")) {
[18:04:29.772]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.772]                         if (muffled) 
[18:04:29.772]                           invokeRestart("muffleMessage")
[18:04:29.772]                       }
[18:04:29.772]                       else if (inherits(cond, "warning")) {
[18:04:29.772]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.772]                         if (muffled) 
[18:04:29.772]                           invokeRestart("muffleWarning")
[18:04:29.772]                       }
[18:04:29.772]                       else if (inherits(cond, "condition")) {
[18:04:29.772]                         if (!is.null(pattern)) {
[18:04:29.772]                           computeRestarts <- base::computeRestarts
[18:04:29.772]                           grepl <- base::grepl
[18:04:29.772]                           restarts <- computeRestarts(cond)
[18:04:29.772]                           for (restart in restarts) {
[18:04:29.772]                             name <- restart$name
[18:04:29.772]                             if (is.null(name)) 
[18:04:29.772]                               next
[18:04:29.772]                             if (!grepl(pattern, name)) 
[18:04:29.772]                               next
[18:04:29.772]                             invokeRestart(restart)
[18:04:29.772]                             muffled <- TRUE
[18:04:29.772]                             break
[18:04:29.772]                           }
[18:04:29.772]                         }
[18:04:29.772]                       }
[18:04:29.772]                       invisible(muffled)
[18:04:29.772]                     }
[18:04:29.772]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.772]                   }
[18:04:29.772]                 }
[18:04:29.772]                 else {
[18:04:29.772]                   if (TRUE) {
[18:04:29.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.772]                     {
[18:04:29.772]                       inherits <- base::inherits
[18:04:29.772]                       invokeRestart <- base::invokeRestart
[18:04:29.772]                       is.null <- base::is.null
[18:04:29.772]                       muffled <- FALSE
[18:04:29.772]                       if (inherits(cond, "message")) {
[18:04:29.772]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.772]                         if (muffled) 
[18:04:29.772]                           invokeRestart("muffleMessage")
[18:04:29.772]                       }
[18:04:29.772]                       else if (inherits(cond, "warning")) {
[18:04:29.772]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.772]                         if (muffled) 
[18:04:29.772]                           invokeRestart("muffleWarning")
[18:04:29.772]                       }
[18:04:29.772]                       else if (inherits(cond, "condition")) {
[18:04:29.772]                         if (!is.null(pattern)) {
[18:04:29.772]                           computeRestarts <- base::computeRestarts
[18:04:29.772]                           grepl <- base::grepl
[18:04:29.772]                           restarts <- computeRestarts(cond)
[18:04:29.772]                           for (restart in restarts) {
[18:04:29.772]                             name <- restart$name
[18:04:29.772]                             if (is.null(name)) 
[18:04:29.772]                               next
[18:04:29.772]                             if (!grepl(pattern, name)) 
[18:04:29.772]                               next
[18:04:29.772]                             invokeRestart(restart)
[18:04:29.772]                             muffled <- TRUE
[18:04:29.772]                             break
[18:04:29.772]                           }
[18:04:29.772]                         }
[18:04:29.772]                       }
[18:04:29.772]                       invisible(muffled)
[18:04:29.772]                     }
[18:04:29.772]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.772]                   }
[18:04:29.772]                 }
[18:04:29.772]             }
[18:04:29.772]         }))
[18:04:29.772]     }, error = function(ex) {
[18:04:29.772]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:29.772]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.772]                 ...future.rng), started = ...future.startTime, 
[18:04:29.772]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:29.772]             version = "1.8"), class = "FutureResult")
[18:04:29.772]     }, finally = {
[18:04:29.772]         if (!identical(...future.workdir, getwd())) 
[18:04:29.772]             setwd(...future.workdir)
[18:04:29.772]         {
[18:04:29.772]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:29.772]                 ...future.oldOptions$nwarnings <- NULL
[18:04:29.772]             }
[18:04:29.772]             base::options(...future.oldOptions)
[18:04:29.772]             if (.Platform$OS.type == "windows") {
[18:04:29.772]                 old_names <- names(...future.oldEnvVars)
[18:04:29.772]                 envs <- base::Sys.getenv()
[18:04:29.772]                 names <- names(envs)
[18:04:29.772]                 common <- intersect(names, old_names)
[18:04:29.772]                 added <- setdiff(names, old_names)
[18:04:29.772]                 removed <- setdiff(old_names, names)
[18:04:29.772]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:29.772]                   envs[common]]
[18:04:29.772]                 NAMES <- toupper(changed)
[18:04:29.772]                 args <- list()
[18:04:29.772]                 for (kk in seq_along(NAMES)) {
[18:04:29.772]                   name <- changed[[kk]]
[18:04:29.772]                   NAME <- NAMES[[kk]]
[18:04:29.772]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.772]                     next
[18:04:29.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.772]                 }
[18:04:29.772]                 NAMES <- toupper(added)
[18:04:29.772]                 for (kk in seq_along(NAMES)) {
[18:04:29.772]                   name <- added[[kk]]
[18:04:29.772]                   NAME <- NAMES[[kk]]
[18:04:29.772]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.772]                     next
[18:04:29.772]                   args[[name]] <- ""
[18:04:29.772]                 }
[18:04:29.772]                 NAMES <- toupper(removed)
[18:04:29.772]                 for (kk in seq_along(NAMES)) {
[18:04:29.772]                   name <- removed[[kk]]
[18:04:29.772]                   NAME <- NAMES[[kk]]
[18:04:29.772]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.772]                     next
[18:04:29.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.772]                 }
[18:04:29.772]                 if (length(args) > 0) 
[18:04:29.772]                   base::do.call(base::Sys.setenv, args = args)
[18:04:29.772]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:29.772]             }
[18:04:29.772]             else {
[18:04:29.772]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:29.772]             }
[18:04:29.772]             {
[18:04:29.772]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:29.772]                   0L) {
[18:04:29.772]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:29.772]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:29.772]                   base::options(opts)
[18:04:29.772]                 }
[18:04:29.772]                 {
[18:04:29.772]                   {
[18:04:29.772]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:29.772]                     NULL
[18:04:29.772]                   }
[18:04:29.772]                   options(future.plan = NULL)
[18:04:29.772]                   if (is.na(NA_character_)) 
[18:04:29.772]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.772]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:29.772]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:29.772]                     .init = FALSE)
[18:04:29.772]                 }
[18:04:29.772]             }
[18:04:29.772]         }
[18:04:29.772]     })
[18:04:29.772]     if (TRUE) {
[18:04:29.772]         base::sink(type = "output", split = FALSE)
[18:04:29.772]         if (TRUE) {
[18:04:29.772]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:29.772]         }
[18:04:29.772]         else {
[18:04:29.772]             ...future.result["stdout"] <- base::list(NULL)
[18:04:29.772]         }
[18:04:29.772]         base::close(...future.stdout)
[18:04:29.772]         ...future.stdout <- NULL
[18:04:29.772]     }
[18:04:29.772]     ...future.result$conditions <- ...future.conditions
[18:04:29.772]     ...future.result$finished <- base::Sys.time()
[18:04:29.772]     ...future.result
[18:04:29.772] }
[18:04:29.777] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[18:04:29.777] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[18:04:29.778] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[18:04:29.779] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[18:04:29.780] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[18:04:29.780] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[18:04:29.782] MultisessionFuture started
[18:04:29.782] - Launch lazy future ... done
[18:04:29.782] run() for ‘MultisessionFuture’ ... done
[18:04:29.783] result() for ClusterFuture ...
[18:04:29.783] receiveMessageFromWorker() for ClusterFuture ...
[18:04:29.783] - Validating connection of MultisessionFuture
[18:04:29.829] - received message: FutureResult
[18:04:29.830] - Received FutureResult
[18:04:29.830] - Erased future from FutureRegistry
[18:04:29.830] result() for ClusterFuture ...
[18:04:29.830] - result already collected: FutureResult
[18:04:29.830] result() for ClusterFuture ... done
[18:04:29.831] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:29.831] result() for ClusterFuture ... done
[18:04:29.831] result() for ClusterFuture ...
[18:04:29.831] - result already collected: FutureResult
[18:04:29.831] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[18:04:29.835] getGlobalsAndPackages() ...
[18:04:29.835] Searching for globals...
[18:04:29.838] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[18:04:29.838] Searching for globals ... DONE
[18:04:29.838] Resolving globals: FALSE
[18:04:29.839] The total size of the 1 globals is 96 bytes (96 bytes)
[18:04:29.840] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[18:04:29.840] - globals: [1] ‘x’
[18:04:29.841] - packages: [1] ‘stats’
[18:04:29.841] getGlobalsAndPackages() ... DONE
[18:04:29.841] run() for ‘Future’ ...
[18:04:29.842] - state: ‘created’
[18:04:29.842] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:29.866] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:29.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:29.867]   - Field: ‘node’
[18:04:29.867]   - Field: ‘label’
[18:04:29.867]   - Field: ‘local’
[18:04:29.867]   - Field: ‘owner’
[18:04:29.867]   - Field: ‘envir’
[18:04:29.868]   - Field: ‘workers’
[18:04:29.868]   - Field: ‘packages’
[18:04:29.868]   - Field: ‘gc’
[18:04:29.868]   - Field: ‘conditions’
[18:04:29.868]   - Field: ‘persistent’
[18:04:29.869]   - Field: ‘expr’
[18:04:29.869]   - Field: ‘uuid’
[18:04:29.869]   - Field: ‘seed’
[18:04:29.869]   - Field: ‘version’
[18:04:29.869]   - Field: ‘result’
[18:04:29.870]   - Field: ‘asynchronous’
[18:04:29.870]   - Field: ‘calls’
[18:04:29.870]   - Field: ‘globals’
[18:04:29.870]   - Field: ‘stdout’
[18:04:29.870]   - Field: ‘earlySignal’
[18:04:29.871]   - Field: ‘lazy’
[18:04:29.871]   - Field: ‘state’
[18:04:29.871] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:29.871] - Launch lazy future ...
[18:04:29.872] Packages needed by the future expression (n = 1): ‘stats’
[18:04:29.872] Packages needed by future strategies (n = 0): <none>
[18:04:29.873] {
[18:04:29.873]     {
[18:04:29.873]         {
[18:04:29.873]             ...future.startTime <- base::Sys.time()
[18:04:29.873]             {
[18:04:29.873]                 {
[18:04:29.873]                   {
[18:04:29.873]                     {
[18:04:29.873]                       {
[18:04:29.873]                         base::local({
[18:04:29.873]                           has_future <- base::requireNamespace("future", 
[18:04:29.873]                             quietly = TRUE)
[18:04:29.873]                           if (has_future) {
[18:04:29.873]                             ns <- base::getNamespace("future")
[18:04:29.873]                             version <- ns[[".package"]][["version"]]
[18:04:29.873]                             if (is.null(version)) 
[18:04:29.873]                               version <- utils::packageVersion("future")
[18:04:29.873]                           }
[18:04:29.873]                           else {
[18:04:29.873]                             version <- NULL
[18:04:29.873]                           }
[18:04:29.873]                           if (!has_future || version < "1.8.0") {
[18:04:29.873]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:29.873]                               "", base::R.version$version.string), 
[18:04:29.873]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:29.873]                                 base::R.version$platform, 8 * 
[18:04:29.873]                                   base::.Machine$sizeof.pointer), 
[18:04:29.873]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:29.873]                                 "release", "version")], collapse = " "), 
[18:04:29.873]                               hostname = base::Sys.info()[["nodename"]])
[18:04:29.873]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:29.873]                               info)
[18:04:29.873]                             info <- base::paste(info, collapse = "; ")
[18:04:29.873]                             if (!has_future) {
[18:04:29.873]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:29.873]                                 info)
[18:04:29.873]                             }
[18:04:29.873]                             else {
[18:04:29.873]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:29.873]                                 info, version)
[18:04:29.873]                             }
[18:04:29.873]                             base::stop(msg)
[18:04:29.873]                           }
[18:04:29.873]                         })
[18:04:29.873]                       }
[18:04:29.873]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:29.873]                       base::options(mc.cores = 1L)
[18:04:29.873]                     }
[18:04:29.873]                     base::local({
[18:04:29.873]                       for (pkg in "stats") {
[18:04:29.873]                         base::loadNamespace(pkg)
[18:04:29.873]                         base::library(pkg, character.only = TRUE)
[18:04:29.873]                       }
[18:04:29.873]                     })
[18:04:29.873]                   }
[18:04:29.873]                   ...future.strategy.old <- future::plan("list")
[18:04:29.873]                   options(future.plan = NULL)
[18:04:29.873]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.873]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:29.873]                 }
[18:04:29.873]                 ...future.workdir <- getwd()
[18:04:29.873]             }
[18:04:29.873]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:29.873]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:29.873]         }
[18:04:29.873]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:29.873]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:29.873]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:29.873]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:29.873]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:29.873]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:29.873]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:29.873]             base::names(...future.oldOptions))
[18:04:29.873]     }
[18:04:29.873]     if (FALSE) {
[18:04:29.873]     }
[18:04:29.873]     else {
[18:04:29.873]         if (TRUE) {
[18:04:29.873]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:29.873]                 open = "w")
[18:04:29.873]         }
[18:04:29.873]         else {
[18:04:29.873]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:29.873]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:29.873]         }
[18:04:29.873]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:29.873]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:29.873]             base::sink(type = "output", split = FALSE)
[18:04:29.873]             base::close(...future.stdout)
[18:04:29.873]         }, add = TRUE)
[18:04:29.873]     }
[18:04:29.873]     ...future.frame <- base::sys.nframe()
[18:04:29.873]     ...future.conditions <- base::list()
[18:04:29.873]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:29.873]     if (FALSE) {
[18:04:29.873]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:29.873]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:29.873]     }
[18:04:29.873]     ...future.result <- base::tryCatch({
[18:04:29.873]         base::withCallingHandlers({
[18:04:29.873]             ...future.value <- base::withVisible(base::local({
[18:04:29.873]                 ...future.makeSendCondition <- base::local({
[18:04:29.873]                   sendCondition <- NULL
[18:04:29.873]                   function(frame = 1L) {
[18:04:29.873]                     if (is.function(sendCondition)) 
[18:04:29.873]                       return(sendCondition)
[18:04:29.873]                     ns <- getNamespace("parallel")
[18:04:29.873]                     if (exists("sendData", mode = "function", 
[18:04:29.873]                       envir = ns)) {
[18:04:29.873]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:29.873]                         envir = ns)
[18:04:29.873]                       envir <- sys.frame(frame)
[18:04:29.873]                       master <- NULL
[18:04:29.873]                       while (!identical(envir, .GlobalEnv) && 
[18:04:29.873]                         !identical(envir, emptyenv())) {
[18:04:29.873]                         if (exists("master", mode = "list", envir = envir, 
[18:04:29.873]                           inherits = FALSE)) {
[18:04:29.873]                           master <- get("master", mode = "list", 
[18:04:29.873]                             envir = envir, inherits = FALSE)
[18:04:29.873]                           if (inherits(master, c("SOCKnode", 
[18:04:29.873]                             "SOCK0node"))) {
[18:04:29.873]                             sendCondition <<- function(cond) {
[18:04:29.873]                               data <- list(type = "VALUE", value = cond, 
[18:04:29.873]                                 success = TRUE)
[18:04:29.873]                               parallel_sendData(master, data)
[18:04:29.873]                             }
[18:04:29.873]                             return(sendCondition)
[18:04:29.873]                           }
[18:04:29.873]                         }
[18:04:29.873]                         frame <- frame + 1L
[18:04:29.873]                         envir <- sys.frame(frame)
[18:04:29.873]                       }
[18:04:29.873]                     }
[18:04:29.873]                     sendCondition <<- function(cond) NULL
[18:04:29.873]                   }
[18:04:29.873]                 })
[18:04:29.873]                 withCallingHandlers({
[18:04:29.873]                   {
[18:04:29.873]                     xtabs(~x)
[18:04:29.873]                   }
[18:04:29.873]                 }, immediateCondition = function(cond) {
[18:04:29.873]                   sendCondition <- ...future.makeSendCondition()
[18:04:29.873]                   sendCondition(cond)
[18:04:29.873]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.873]                   {
[18:04:29.873]                     inherits <- base::inherits
[18:04:29.873]                     invokeRestart <- base::invokeRestart
[18:04:29.873]                     is.null <- base::is.null
[18:04:29.873]                     muffled <- FALSE
[18:04:29.873]                     if (inherits(cond, "message")) {
[18:04:29.873]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:29.873]                       if (muffled) 
[18:04:29.873]                         invokeRestart("muffleMessage")
[18:04:29.873]                     }
[18:04:29.873]                     else if (inherits(cond, "warning")) {
[18:04:29.873]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:29.873]                       if (muffled) 
[18:04:29.873]                         invokeRestart("muffleWarning")
[18:04:29.873]                     }
[18:04:29.873]                     else if (inherits(cond, "condition")) {
[18:04:29.873]                       if (!is.null(pattern)) {
[18:04:29.873]                         computeRestarts <- base::computeRestarts
[18:04:29.873]                         grepl <- base::grepl
[18:04:29.873]                         restarts <- computeRestarts(cond)
[18:04:29.873]                         for (restart in restarts) {
[18:04:29.873]                           name <- restart$name
[18:04:29.873]                           if (is.null(name)) 
[18:04:29.873]                             next
[18:04:29.873]                           if (!grepl(pattern, name)) 
[18:04:29.873]                             next
[18:04:29.873]                           invokeRestart(restart)
[18:04:29.873]                           muffled <- TRUE
[18:04:29.873]                           break
[18:04:29.873]                         }
[18:04:29.873]                       }
[18:04:29.873]                     }
[18:04:29.873]                     invisible(muffled)
[18:04:29.873]                   }
[18:04:29.873]                   muffleCondition(cond)
[18:04:29.873]                 })
[18:04:29.873]             }))
[18:04:29.873]             future::FutureResult(value = ...future.value$value, 
[18:04:29.873]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.873]                   ...future.rng), globalenv = if (FALSE) 
[18:04:29.873]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:29.873]                     ...future.globalenv.names))
[18:04:29.873]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:29.873]         }, condition = base::local({
[18:04:29.873]             c <- base::c
[18:04:29.873]             inherits <- base::inherits
[18:04:29.873]             invokeRestart <- base::invokeRestart
[18:04:29.873]             length <- base::length
[18:04:29.873]             list <- base::list
[18:04:29.873]             seq.int <- base::seq.int
[18:04:29.873]             signalCondition <- base::signalCondition
[18:04:29.873]             sys.calls <- base::sys.calls
[18:04:29.873]             `[[` <- base::`[[`
[18:04:29.873]             `+` <- base::`+`
[18:04:29.873]             `<<-` <- base::`<<-`
[18:04:29.873]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:29.873]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:29.873]                   3L)]
[18:04:29.873]             }
[18:04:29.873]             function(cond) {
[18:04:29.873]                 is_error <- inherits(cond, "error")
[18:04:29.873]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:29.873]                   NULL)
[18:04:29.873]                 if (is_error) {
[18:04:29.873]                   sessionInformation <- function() {
[18:04:29.873]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:29.873]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:29.873]                       search = base::search(), system = base::Sys.info())
[18:04:29.873]                   }
[18:04:29.873]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.873]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:29.873]                     cond$call), session = sessionInformation(), 
[18:04:29.873]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:29.873]                   signalCondition(cond)
[18:04:29.873]                 }
[18:04:29.873]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:29.873]                 "immediateCondition"))) {
[18:04:29.873]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:29.873]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.873]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:29.873]                   if (TRUE && !signal) {
[18:04:29.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.873]                     {
[18:04:29.873]                       inherits <- base::inherits
[18:04:29.873]                       invokeRestart <- base::invokeRestart
[18:04:29.873]                       is.null <- base::is.null
[18:04:29.873]                       muffled <- FALSE
[18:04:29.873]                       if (inherits(cond, "message")) {
[18:04:29.873]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.873]                         if (muffled) 
[18:04:29.873]                           invokeRestart("muffleMessage")
[18:04:29.873]                       }
[18:04:29.873]                       else if (inherits(cond, "warning")) {
[18:04:29.873]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.873]                         if (muffled) 
[18:04:29.873]                           invokeRestart("muffleWarning")
[18:04:29.873]                       }
[18:04:29.873]                       else if (inherits(cond, "condition")) {
[18:04:29.873]                         if (!is.null(pattern)) {
[18:04:29.873]                           computeRestarts <- base::computeRestarts
[18:04:29.873]                           grepl <- base::grepl
[18:04:29.873]                           restarts <- computeRestarts(cond)
[18:04:29.873]                           for (restart in restarts) {
[18:04:29.873]                             name <- restart$name
[18:04:29.873]                             if (is.null(name)) 
[18:04:29.873]                               next
[18:04:29.873]                             if (!grepl(pattern, name)) 
[18:04:29.873]                               next
[18:04:29.873]                             invokeRestart(restart)
[18:04:29.873]                             muffled <- TRUE
[18:04:29.873]                             break
[18:04:29.873]                           }
[18:04:29.873]                         }
[18:04:29.873]                       }
[18:04:29.873]                       invisible(muffled)
[18:04:29.873]                     }
[18:04:29.873]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.873]                   }
[18:04:29.873]                 }
[18:04:29.873]                 else {
[18:04:29.873]                   if (TRUE) {
[18:04:29.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.873]                     {
[18:04:29.873]                       inherits <- base::inherits
[18:04:29.873]                       invokeRestart <- base::invokeRestart
[18:04:29.873]                       is.null <- base::is.null
[18:04:29.873]                       muffled <- FALSE
[18:04:29.873]                       if (inherits(cond, "message")) {
[18:04:29.873]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.873]                         if (muffled) 
[18:04:29.873]                           invokeRestart("muffleMessage")
[18:04:29.873]                       }
[18:04:29.873]                       else if (inherits(cond, "warning")) {
[18:04:29.873]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.873]                         if (muffled) 
[18:04:29.873]                           invokeRestart("muffleWarning")
[18:04:29.873]                       }
[18:04:29.873]                       else if (inherits(cond, "condition")) {
[18:04:29.873]                         if (!is.null(pattern)) {
[18:04:29.873]                           computeRestarts <- base::computeRestarts
[18:04:29.873]                           grepl <- base::grepl
[18:04:29.873]                           restarts <- computeRestarts(cond)
[18:04:29.873]                           for (restart in restarts) {
[18:04:29.873]                             name <- restart$name
[18:04:29.873]                             if (is.null(name)) 
[18:04:29.873]                               next
[18:04:29.873]                             if (!grepl(pattern, name)) 
[18:04:29.873]                               next
[18:04:29.873]                             invokeRestart(restart)
[18:04:29.873]                             muffled <- TRUE
[18:04:29.873]                             break
[18:04:29.873]                           }
[18:04:29.873]                         }
[18:04:29.873]                       }
[18:04:29.873]                       invisible(muffled)
[18:04:29.873]                     }
[18:04:29.873]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.873]                   }
[18:04:29.873]                 }
[18:04:29.873]             }
[18:04:29.873]         }))
[18:04:29.873]     }, error = function(ex) {
[18:04:29.873]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:29.873]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.873]                 ...future.rng), started = ...future.startTime, 
[18:04:29.873]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:29.873]             version = "1.8"), class = "FutureResult")
[18:04:29.873]     }, finally = {
[18:04:29.873]         if (!identical(...future.workdir, getwd())) 
[18:04:29.873]             setwd(...future.workdir)
[18:04:29.873]         {
[18:04:29.873]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:29.873]                 ...future.oldOptions$nwarnings <- NULL
[18:04:29.873]             }
[18:04:29.873]             base::options(...future.oldOptions)
[18:04:29.873]             if (.Platform$OS.type == "windows") {
[18:04:29.873]                 old_names <- names(...future.oldEnvVars)
[18:04:29.873]                 envs <- base::Sys.getenv()
[18:04:29.873]                 names <- names(envs)
[18:04:29.873]                 common <- intersect(names, old_names)
[18:04:29.873]                 added <- setdiff(names, old_names)
[18:04:29.873]                 removed <- setdiff(old_names, names)
[18:04:29.873]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:29.873]                   envs[common]]
[18:04:29.873]                 NAMES <- toupper(changed)
[18:04:29.873]                 args <- list()
[18:04:29.873]                 for (kk in seq_along(NAMES)) {
[18:04:29.873]                   name <- changed[[kk]]
[18:04:29.873]                   NAME <- NAMES[[kk]]
[18:04:29.873]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.873]                     next
[18:04:29.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.873]                 }
[18:04:29.873]                 NAMES <- toupper(added)
[18:04:29.873]                 for (kk in seq_along(NAMES)) {
[18:04:29.873]                   name <- added[[kk]]
[18:04:29.873]                   NAME <- NAMES[[kk]]
[18:04:29.873]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.873]                     next
[18:04:29.873]                   args[[name]] <- ""
[18:04:29.873]                 }
[18:04:29.873]                 NAMES <- toupper(removed)
[18:04:29.873]                 for (kk in seq_along(NAMES)) {
[18:04:29.873]                   name <- removed[[kk]]
[18:04:29.873]                   NAME <- NAMES[[kk]]
[18:04:29.873]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.873]                     next
[18:04:29.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.873]                 }
[18:04:29.873]                 if (length(args) > 0) 
[18:04:29.873]                   base::do.call(base::Sys.setenv, args = args)
[18:04:29.873]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:29.873]             }
[18:04:29.873]             else {
[18:04:29.873]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:29.873]             }
[18:04:29.873]             {
[18:04:29.873]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:29.873]                   0L) {
[18:04:29.873]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:29.873]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:29.873]                   base::options(opts)
[18:04:29.873]                 }
[18:04:29.873]                 {
[18:04:29.873]                   {
[18:04:29.873]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:29.873]                     NULL
[18:04:29.873]                   }
[18:04:29.873]                   options(future.plan = NULL)
[18:04:29.873]                   if (is.na(NA_character_)) 
[18:04:29.873]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.873]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:29.873]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:29.873]                     .init = FALSE)
[18:04:29.873]                 }
[18:04:29.873]             }
[18:04:29.873]         }
[18:04:29.873]     })
[18:04:29.873]     if (TRUE) {
[18:04:29.873]         base::sink(type = "output", split = FALSE)
[18:04:29.873]         if (TRUE) {
[18:04:29.873]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:29.873]         }
[18:04:29.873]         else {
[18:04:29.873]             ...future.result["stdout"] <- base::list(NULL)
[18:04:29.873]         }
[18:04:29.873]         base::close(...future.stdout)
[18:04:29.873]         ...future.stdout <- NULL
[18:04:29.873]     }
[18:04:29.873]     ...future.result$conditions <- ...future.conditions
[18:04:29.873]     ...future.result$finished <- base::Sys.time()
[18:04:29.873]     ...future.result
[18:04:29.873] }
[18:04:29.878] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[18:04:29.878] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[18:04:29.879] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[18:04:29.880] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[18:04:29.881] MultisessionFuture started
[18:04:29.882] - Launch lazy future ... done
[18:04:29.882] run() for ‘MultisessionFuture’ ... done
[18:04:29.882] result() for ClusterFuture ...
[18:04:29.883] receiveMessageFromWorker() for ClusterFuture ...
[18:04:29.883] - Validating connection of MultisessionFuture
[18:04:29.925] - received message: FutureResult
[18:04:29.925] - Received FutureResult
[18:04:29.926] - Erased future from FutureRegistry
[18:04:29.926] result() for ClusterFuture ...
[18:04:29.926] - result already collected: FutureResult
[18:04:29.926] result() for ClusterFuture ... done
[18:04:29.927] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:29.927] result() for ClusterFuture ... done
[18:04:29.927] result() for ClusterFuture ...
[18:04:29.927] - result already collected: FutureResult
[18:04:29.927] result() for ClusterFuture ... done
x
1 2 
2 3 
[18:04:29.929] getGlobalsAndPackages() ...
[18:04:29.929] Searching for globals...
[18:04:29.931] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[18:04:29.932] Searching for globals ... DONE
[18:04:29.932] Resolving globals: FALSE
[18:04:29.933] The total size of the 1 globals is 96 bytes (96 bytes)
[18:04:29.934] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[18:04:29.934] - globals: [1] ‘x’
[18:04:29.934] - packages: [1] ‘stats’
[18:04:29.934] getGlobalsAndPackages() ... DONE
[18:04:29.935] run() for ‘Future’ ...
[18:04:29.935] - state: ‘created’
[18:04:29.935] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:29.959] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:29.959] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:29.960]   - Field: ‘node’
[18:04:29.960]   - Field: ‘label’
[18:04:29.960]   - Field: ‘local’
[18:04:29.960]   - Field: ‘owner’
[18:04:29.961]   - Field: ‘envir’
[18:04:29.961]   - Field: ‘workers’
[18:04:29.961]   - Field: ‘packages’
[18:04:29.961]   - Field: ‘gc’
[18:04:29.961]   - Field: ‘conditions’
[18:04:29.962]   - Field: ‘persistent’
[18:04:29.962]   - Field: ‘expr’
[18:04:29.962]   - Field: ‘uuid’
[18:04:29.962]   - Field: ‘seed’
[18:04:29.962]   - Field: ‘version’
[18:04:29.963]   - Field: ‘result’
[18:04:29.963]   - Field: ‘asynchronous’
[18:04:29.963]   - Field: ‘calls’
[18:04:29.963]   - Field: ‘globals’
[18:04:29.963]   - Field: ‘stdout’
[18:04:29.964]   - Field: ‘earlySignal’
[18:04:29.964]   - Field: ‘lazy’
[18:04:29.964]   - Field: ‘state’
[18:04:29.964] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:29.964] - Launch lazy future ...
[18:04:29.965] Packages needed by the future expression (n = 1): ‘stats’
[18:04:29.965] Packages needed by future strategies (n = 0): <none>
[18:04:29.966] {
[18:04:29.966]     {
[18:04:29.966]         {
[18:04:29.966]             ...future.startTime <- base::Sys.time()
[18:04:29.966]             {
[18:04:29.966]                 {
[18:04:29.966]                   {
[18:04:29.966]                     {
[18:04:29.966]                       {
[18:04:29.966]                         base::local({
[18:04:29.966]                           has_future <- base::requireNamespace("future", 
[18:04:29.966]                             quietly = TRUE)
[18:04:29.966]                           if (has_future) {
[18:04:29.966]                             ns <- base::getNamespace("future")
[18:04:29.966]                             version <- ns[[".package"]][["version"]]
[18:04:29.966]                             if (is.null(version)) 
[18:04:29.966]                               version <- utils::packageVersion("future")
[18:04:29.966]                           }
[18:04:29.966]                           else {
[18:04:29.966]                             version <- NULL
[18:04:29.966]                           }
[18:04:29.966]                           if (!has_future || version < "1.8.0") {
[18:04:29.966]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:29.966]                               "", base::R.version$version.string), 
[18:04:29.966]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:29.966]                                 base::R.version$platform, 8 * 
[18:04:29.966]                                   base::.Machine$sizeof.pointer), 
[18:04:29.966]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:29.966]                                 "release", "version")], collapse = " "), 
[18:04:29.966]                               hostname = base::Sys.info()[["nodename"]])
[18:04:29.966]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:29.966]                               info)
[18:04:29.966]                             info <- base::paste(info, collapse = "; ")
[18:04:29.966]                             if (!has_future) {
[18:04:29.966]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:29.966]                                 info)
[18:04:29.966]                             }
[18:04:29.966]                             else {
[18:04:29.966]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:29.966]                                 info, version)
[18:04:29.966]                             }
[18:04:29.966]                             base::stop(msg)
[18:04:29.966]                           }
[18:04:29.966]                         })
[18:04:29.966]                       }
[18:04:29.966]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:29.966]                       base::options(mc.cores = 1L)
[18:04:29.966]                     }
[18:04:29.966]                     base::local({
[18:04:29.966]                       for (pkg in "stats") {
[18:04:29.966]                         base::loadNamespace(pkg)
[18:04:29.966]                         base::library(pkg, character.only = TRUE)
[18:04:29.966]                       }
[18:04:29.966]                     })
[18:04:29.966]                   }
[18:04:29.966]                   ...future.strategy.old <- future::plan("list")
[18:04:29.966]                   options(future.plan = NULL)
[18:04:29.966]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.966]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:29.966]                 }
[18:04:29.966]                 ...future.workdir <- getwd()
[18:04:29.966]             }
[18:04:29.966]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:29.966]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:29.966]         }
[18:04:29.966]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:29.966]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:29.966]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:29.966]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:29.966]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:29.966]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:29.966]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:29.966]             base::names(...future.oldOptions))
[18:04:29.966]     }
[18:04:29.966]     if (FALSE) {
[18:04:29.966]     }
[18:04:29.966]     else {
[18:04:29.966]         if (TRUE) {
[18:04:29.966]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:29.966]                 open = "w")
[18:04:29.966]         }
[18:04:29.966]         else {
[18:04:29.966]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:29.966]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:29.966]         }
[18:04:29.966]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:29.966]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:29.966]             base::sink(type = "output", split = FALSE)
[18:04:29.966]             base::close(...future.stdout)
[18:04:29.966]         }, add = TRUE)
[18:04:29.966]     }
[18:04:29.966]     ...future.frame <- base::sys.nframe()
[18:04:29.966]     ...future.conditions <- base::list()
[18:04:29.966]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:29.966]     if (FALSE) {
[18:04:29.966]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:29.966]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:29.966]     }
[18:04:29.966]     ...future.result <- base::tryCatch({
[18:04:29.966]         base::withCallingHandlers({
[18:04:29.966]             ...future.value <- base::withVisible(base::local({
[18:04:29.966]                 ...future.makeSendCondition <- base::local({
[18:04:29.966]                   sendCondition <- NULL
[18:04:29.966]                   function(frame = 1L) {
[18:04:29.966]                     if (is.function(sendCondition)) 
[18:04:29.966]                       return(sendCondition)
[18:04:29.966]                     ns <- getNamespace("parallel")
[18:04:29.966]                     if (exists("sendData", mode = "function", 
[18:04:29.966]                       envir = ns)) {
[18:04:29.966]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:29.966]                         envir = ns)
[18:04:29.966]                       envir <- sys.frame(frame)
[18:04:29.966]                       master <- NULL
[18:04:29.966]                       while (!identical(envir, .GlobalEnv) && 
[18:04:29.966]                         !identical(envir, emptyenv())) {
[18:04:29.966]                         if (exists("master", mode = "list", envir = envir, 
[18:04:29.966]                           inherits = FALSE)) {
[18:04:29.966]                           master <- get("master", mode = "list", 
[18:04:29.966]                             envir = envir, inherits = FALSE)
[18:04:29.966]                           if (inherits(master, c("SOCKnode", 
[18:04:29.966]                             "SOCK0node"))) {
[18:04:29.966]                             sendCondition <<- function(cond) {
[18:04:29.966]                               data <- list(type = "VALUE", value = cond, 
[18:04:29.966]                                 success = TRUE)
[18:04:29.966]                               parallel_sendData(master, data)
[18:04:29.966]                             }
[18:04:29.966]                             return(sendCondition)
[18:04:29.966]                           }
[18:04:29.966]                         }
[18:04:29.966]                         frame <- frame + 1L
[18:04:29.966]                         envir <- sys.frame(frame)
[18:04:29.966]                       }
[18:04:29.966]                     }
[18:04:29.966]                     sendCondition <<- function(cond) NULL
[18:04:29.966]                   }
[18:04:29.966]                 })
[18:04:29.966]                 withCallingHandlers({
[18:04:29.966]                   {
[18:04:29.966]                     xtabs(~x)
[18:04:29.966]                   }
[18:04:29.966]                 }, immediateCondition = function(cond) {
[18:04:29.966]                   sendCondition <- ...future.makeSendCondition()
[18:04:29.966]                   sendCondition(cond)
[18:04:29.966]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.966]                   {
[18:04:29.966]                     inherits <- base::inherits
[18:04:29.966]                     invokeRestart <- base::invokeRestart
[18:04:29.966]                     is.null <- base::is.null
[18:04:29.966]                     muffled <- FALSE
[18:04:29.966]                     if (inherits(cond, "message")) {
[18:04:29.966]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:29.966]                       if (muffled) 
[18:04:29.966]                         invokeRestart("muffleMessage")
[18:04:29.966]                     }
[18:04:29.966]                     else if (inherits(cond, "warning")) {
[18:04:29.966]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:29.966]                       if (muffled) 
[18:04:29.966]                         invokeRestart("muffleWarning")
[18:04:29.966]                     }
[18:04:29.966]                     else if (inherits(cond, "condition")) {
[18:04:29.966]                       if (!is.null(pattern)) {
[18:04:29.966]                         computeRestarts <- base::computeRestarts
[18:04:29.966]                         grepl <- base::grepl
[18:04:29.966]                         restarts <- computeRestarts(cond)
[18:04:29.966]                         for (restart in restarts) {
[18:04:29.966]                           name <- restart$name
[18:04:29.966]                           if (is.null(name)) 
[18:04:29.966]                             next
[18:04:29.966]                           if (!grepl(pattern, name)) 
[18:04:29.966]                             next
[18:04:29.966]                           invokeRestart(restart)
[18:04:29.966]                           muffled <- TRUE
[18:04:29.966]                           break
[18:04:29.966]                         }
[18:04:29.966]                       }
[18:04:29.966]                     }
[18:04:29.966]                     invisible(muffled)
[18:04:29.966]                   }
[18:04:29.966]                   muffleCondition(cond)
[18:04:29.966]                 })
[18:04:29.966]             }))
[18:04:29.966]             future::FutureResult(value = ...future.value$value, 
[18:04:29.966]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.966]                   ...future.rng), globalenv = if (FALSE) 
[18:04:29.966]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:29.966]                     ...future.globalenv.names))
[18:04:29.966]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:29.966]         }, condition = base::local({
[18:04:29.966]             c <- base::c
[18:04:29.966]             inherits <- base::inherits
[18:04:29.966]             invokeRestart <- base::invokeRestart
[18:04:29.966]             length <- base::length
[18:04:29.966]             list <- base::list
[18:04:29.966]             seq.int <- base::seq.int
[18:04:29.966]             signalCondition <- base::signalCondition
[18:04:29.966]             sys.calls <- base::sys.calls
[18:04:29.966]             `[[` <- base::`[[`
[18:04:29.966]             `+` <- base::`+`
[18:04:29.966]             `<<-` <- base::`<<-`
[18:04:29.966]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:29.966]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:29.966]                   3L)]
[18:04:29.966]             }
[18:04:29.966]             function(cond) {
[18:04:29.966]                 is_error <- inherits(cond, "error")
[18:04:29.966]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:29.966]                   NULL)
[18:04:29.966]                 if (is_error) {
[18:04:29.966]                   sessionInformation <- function() {
[18:04:29.966]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:29.966]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:29.966]                       search = base::search(), system = base::Sys.info())
[18:04:29.966]                   }
[18:04:29.966]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.966]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:29.966]                     cond$call), session = sessionInformation(), 
[18:04:29.966]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:29.966]                   signalCondition(cond)
[18:04:29.966]                 }
[18:04:29.966]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:29.966]                 "immediateCondition"))) {
[18:04:29.966]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:29.966]                   ...future.conditions[[length(...future.conditions) + 
[18:04:29.966]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:29.966]                   if (TRUE && !signal) {
[18:04:29.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.966]                     {
[18:04:29.966]                       inherits <- base::inherits
[18:04:29.966]                       invokeRestart <- base::invokeRestart
[18:04:29.966]                       is.null <- base::is.null
[18:04:29.966]                       muffled <- FALSE
[18:04:29.966]                       if (inherits(cond, "message")) {
[18:04:29.966]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.966]                         if (muffled) 
[18:04:29.966]                           invokeRestart("muffleMessage")
[18:04:29.966]                       }
[18:04:29.966]                       else if (inherits(cond, "warning")) {
[18:04:29.966]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.966]                         if (muffled) 
[18:04:29.966]                           invokeRestart("muffleWarning")
[18:04:29.966]                       }
[18:04:29.966]                       else if (inherits(cond, "condition")) {
[18:04:29.966]                         if (!is.null(pattern)) {
[18:04:29.966]                           computeRestarts <- base::computeRestarts
[18:04:29.966]                           grepl <- base::grepl
[18:04:29.966]                           restarts <- computeRestarts(cond)
[18:04:29.966]                           for (restart in restarts) {
[18:04:29.966]                             name <- restart$name
[18:04:29.966]                             if (is.null(name)) 
[18:04:29.966]                               next
[18:04:29.966]                             if (!grepl(pattern, name)) 
[18:04:29.966]                               next
[18:04:29.966]                             invokeRestart(restart)
[18:04:29.966]                             muffled <- TRUE
[18:04:29.966]                             break
[18:04:29.966]                           }
[18:04:29.966]                         }
[18:04:29.966]                       }
[18:04:29.966]                       invisible(muffled)
[18:04:29.966]                     }
[18:04:29.966]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.966]                   }
[18:04:29.966]                 }
[18:04:29.966]                 else {
[18:04:29.966]                   if (TRUE) {
[18:04:29.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:29.966]                     {
[18:04:29.966]                       inherits <- base::inherits
[18:04:29.966]                       invokeRestart <- base::invokeRestart
[18:04:29.966]                       is.null <- base::is.null
[18:04:29.966]                       muffled <- FALSE
[18:04:29.966]                       if (inherits(cond, "message")) {
[18:04:29.966]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:29.966]                         if (muffled) 
[18:04:29.966]                           invokeRestart("muffleMessage")
[18:04:29.966]                       }
[18:04:29.966]                       else if (inherits(cond, "warning")) {
[18:04:29.966]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:29.966]                         if (muffled) 
[18:04:29.966]                           invokeRestart("muffleWarning")
[18:04:29.966]                       }
[18:04:29.966]                       else if (inherits(cond, "condition")) {
[18:04:29.966]                         if (!is.null(pattern)) {
[18:04:29.966]                           computeRestarts <- base::computeRestarts
[18:04:29.966]                           grepl <- base::grepl
[18:04:29.966]                           restarts <- computeRestarts(cond)
[18:04:29.966]                           for (restart in restarts) {
[18:04:29.966]                             name <- restart$name
[18:04:29.966]                             if (is.null(name)) 
[18:04:29.966]                               next
[18:04:29.966]                             if (!grepl(pattern, name)) 
[18:04:29.966]                               next
[18:04:29.966]                             invokeRestart(restart)
[18:04:29.966]                             muffled <- TRUE
[18:04:29.966]                             break
[18:04:29.966]                           }
[18:04:29.966]                         }
[18:04:29.966]                       }
[18:04:29.966]                       invisible(muffled)
[18:04:29.966]                     }
[18:04:29.966]                     muffleCondition(cond, pattern = "^muffle")
[18:04:29.966]                   }
[18:04:29.966]                 }
[18:04:29.966]             }
[18:04:29.966]         }))
[18:04:29.966]     }, error = function(ex) {
[18:04:29.966]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:29.966]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:29.966]                 ...future.rng), started = ...future.startTime, 
[18:04:29.966]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:29.966]             version = "1.8"), class = "FutureResult")
[18:04:29.966]     }, finally = {
[18:04:29.966]         if (!identical(...future.workdir, getwd())) 
[18:04:29.966]             setwd(...future.workdir)
[18:04:29.966]         {
[18:04:29.966]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:29.966]                 ...future.oldOptions$nwarnings <- NULL
[18:04:29.966]             }
[18:04:29.966]             base::options(...future.oldOptions)
[18:04:29.966]             if (.Platform$OS.type == "windows") {
[18:04:29.966]                 old_names <- names(...future.oldEnvVars)
[18:04:29.966]                 envs <- base::Sys.getenv()
[18:04:29.966]                 names <- names(envs)
[18:04:29.966]                 common <- intersect(names, old_names)
[18:04:29.966]                 added <- setdiff(names, old_names)
[18:04:29.966]                 removed <- setdiff(old_names, names)
[18:04:29.966]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:29.966]                   envs[common]]
[18:04:29.966]                 NAMES <- toupper(changed)
[18:04:29.966]                 args <- list()
[18:04:29.966]                 for (kk in seq_along(NAMES)) {
[18:04:29.966]                   name <- changed[[kk]]
[18:04:29.966]                   NAME <- NAMES[[kk]]
[18:04:29.966]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.966]                     next
[18:04:29.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.966]                 }
[18:04:29.966]                 NAMES <- toupper(added)
[18:04:29.966]                 for (kk in seq_along(NAMES)) {
[18:04:29.966]                   name <- added[[kk]]
[18:04:29.966]                   NAME <- NAMES[[kk]]
[18:04:29.966]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.966]                     next
[18:04:29.966]                   args[[name]] <- ""
[18:04:29.966]                 }
[18:04:29.966]                 NAMES <- toupper(removed)
[18:04:29.966]                 for (kk in seq_along(NAMES)) {
[18:04:29.966]                   name <- removed[[kk]]
[18:04:29.966]                   NAME <- NAMES[[kk]]
[18:04:29.966]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:29.966]                     next
[18:04:29.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:29.966]                 }
[18:04:29.966]                 if (length(args) > 0) 
[18:04:29.966]                   base::do.call(base::Sys.setenv, args = args)
[18:04:29.966]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:29.966]             }
[18:04:29.966]             else {
[18:04:29.966]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:29.966]             }
[18:04:29.966]             {
[18:04:29.966]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:29.966]                   0L) {
[18:04:29.966]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:29.966]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:29.966]                   base::options(opts)
[18:04:29.966]                 }
[18:04:29.966]                 {
[18:04:29.966]                   {
[18:04:29.966]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:29.966]                     NULL
[18:04:29.966]                   }
[18:04:29.966]                   options(future.plan = NULL)
[18:04:29.966]                   if (is.na(NA_character_)) 
[18:04:29.966]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:29.966]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:29.966]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:29.966]                     .init = FALSE)
[18:04:29.966]                 }
[18:04:29.966]             }
[18:04:29.966]         }
[18:04:29.966]     })
[18:04:29.966]     if (TRUE) {
[18:04:29.966]         base::sink(type = "output", split = FALSE)
[18:04:29.966]         if (TRUE) {
[18:04:29.966]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:29.966]         }
[18:04:29.966]         else {
[18:04:29.966]             ...future.result["stdout"] <- base::list(NULL)
[18:04:29.966]         }
[18:04:29.966]         base::close(...future.stdout)
[18:04:29.966]         ...future.stdout <- NULL
[18:04:29.966]     }
[18:04:29.966]     ...future.result$conditions <- ...future.conditions
[18:04:29.966]     ...future.result$finished <- base::Sys.time()
[18:04:29.966]     ...future.result
[18:04:29.966] }
[18:04:29.972] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[18:04:29.972] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[18:04:29.973] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[18:04:29.973] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[18:04:29.974] MultisessionFuture started
[18:04:29.974] - Launch lazy future ... done
[18:04:29.974] run() for ‘MultisessionFuture’ ... done
[18:04:29.975] result() for ClusterFuture ...
[18:04:29.975] receiveMessageFromWorker() for ClusterFuture ...
[18:04:29.975] - Validating connection of MultisessionFuture
[18:04:30.019] - received message: FutureResult
[18:04:30.020] - Received FutureResult
[18:04:30.020] - Erased future from FutureRegistry
[18:04:30.020] result() for ClusterFuture ...
[18:04:30.021] - result already collected: FutureResult
[18:04:30.021] result() for ClusterFuture ... done
[18:04:30.021] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:30.021] result() for ClusterFuture ... done
[18:04:30.021] result() for ClusterFuture ...
[18:04:30.022] - result already collected: FutureResult
[18:04:30.022] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[18:04:30.025] getGlobalsAndPackages() ...
[18:04:30.025] Searching for globals...
[18:04:30.028] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[18:04:30.029] Searching for globals ... DONE
[18:04:30.029] Resolving globals: FALSE
[18:04:30.030] 
[18:04:30.030] - packages: [2] ‘stats’, ‘datasets’
[18:04:30.030] getGlobalsAndPackages() ... DONE
[18:04:30.031] run() for ‘Future’ ...
[18:04:30.031] - state: ‘created’
[18:04:30.031] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:30.057] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:30.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:30.058]   - Field: ‘node’
[18:04:30.058]   - Field: ‘label’
[18:04:30.058]   - Field: ‘local’
[18:04:30.059]   - Field: ‘owner’
[18:04:30.059]   - Field: ‘envir’
[18:04:30.059]   - Field: ‘workers’
[18:04:30.059]   - Field: ‘packages’
[18:04:30.060]   - Field: ‘gc’
[18:04:30.060]   - Field: ‘conditions’
[18:04:30.060]   - Field: ‘persistent’
[18:04:30.060]   - Field: ‘expr’
[18:04:30.060]   - Field: ‘uuid’
[18:04:30.061]   - Field: ‘seed’
[18:04:30.061]   - Field: ‘version’
[18:04:30.061]   - Field: ‘result’
[18:04:30.061]   - Field: ‘asynchronous’
[18:04:30.061]   - Field: ‘calls’
[18:04:30.062]   - Field: ‘globals’
[18:04:30.062]   - Field: ‘stdout’
[18:04:30.062]   - Field: ‘earlySignal’
[18:04:30.062]   - Field: ‘lazy’
[18:04:30.063]   - Field: ‘state’
[18:04:30.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:30.063] - Launch lazy future ...
[18:04:30.064] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:30.064] Packages needed by future strategies (n = 0): <none>
[18:04:30.065] {
[18:04:30.065]     {
[18:04:30.065]         {
[18:04:30.065]             ...future.startTime <- base::Sys.time()
[18:04:30.065]             {
[18:04:30.065]                 {
[18:04:30.065]                   {
[18:04:30.065]                     {
[18:04:30.065]                       {
[18:04:30.065]                         base::local({
[18:04:30.065]                           has_future <- base::requireNamespace("future", 
[18:04:30.065]                             quietly = TRUE)
[18:04:30.065]                           if (has_future) {
[18:04:30.065]                             ns <- base::getNamespace("future")
[18:04:30.065]                             version <- ns[[".package"]][["version"]]
[18:04:30.065]                             if (is.null(version)) 
[18:04:30.065]                               version <- utils::packageVersion("future")
[18:04:30.065]                           }
[18:04:30.065]                           else {
[18:04:30.065]                             version <- NULL
[18:04:30.065]                           }
[18:04:30.065]                           if (!has_future || version < "1.8.0") {
[18:04:30.065]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:30.065]                               "", base::R.version$version.string), 
[18:04:30.065]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:30.065]                                 base::R.version$platform, 8 * 
[18:04:30.065]                                   base::.Machine$sizeof.pointer), 
[18:04:30.065]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:30.065]                                 "release", "version")], collapse = " "), 
[18:04:30.065]                               hostname = base::Sys.info()[["nodename"]])
[18:04:30.065]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:30.065]                               info)
[18:04:30.065]                             info <- base::paste(info, collapse = "; ")
[18:04:30.065]                             if (!has_future) {
[18:04:30.065]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:30.065]                                 info)
[18:04:30.065]                             }
[18:04:30.065]                             else {
[18:04:30.065]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:30.065]                                 info, version)
[18:04:30.065]                             }
[18:04:30.065]                             base::stop(msg)
[18:04:30.065]                           }
[18:04:30.065]                         })
[18:04:30.065]                       }
[18:04:30.065]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:30.065]                       base::options(mc.cores = 1L)
[18:04:30.065]                     }
[18:04:30.065]                     base::local({
[18:04:30.065]                       for (pkg in c("stats", "datasets")) {
[18:04:30.065]                         base::loadNamespace(pkg)
[18:04:30.065]                         base::library(pkg, character.only = TRUE)
[18:04:30.065]                       }
[18:04:30.065]                     })
[18:04:30.065]                   }
[18:04:30.065]                   ...future.strategy.old <- future::plan("list")
[18:04:30.065]                   options(future.plan = NULL)
[18:04:30.065]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:30.065]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:30.065]                 }
[18:04:30.065]                 ...future.workdir <- getwd()
[18:04:30.065]             }
[18:04:30.065]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:30.065]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:30.065]         }
[18:04:30.065]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:30.065]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:30.065]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:30.065]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:30.065]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:30.065]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:30.065]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:30.065]             base::names(...future.oldOptions))
[18:04:30.065]     }
[18:04:30.065]     if (FALSE) {
[18:04:30.065]     }
[18:04:30.065]     else {
[18:04:30.065]         if (TRUE) {
[18:04:30.065]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:30.065]                 open = "w")
[18:04:30.065]         }
[18:04:30.065]         else {
[18:04:30.065]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:30.065]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:30.065]         }
[18:04:30.065]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:30.065]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:30.065]             base::sink(type = "output", split = FALSE)
[18:04:30.065]             base::close(...future.stdout)
[18:04:30.065]         }, add = TRUE)
[18:04:30.065]     }
[18:04:30.065]     ...future.frame <- base::sys.nframe()
[18:04:30.065]     ...future.conditions <- base::list()
[18:04:30.065]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:30.065]     if (FALSE) {
[18:04:30.065]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:30.065]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:30.065]     }
[18:04:30.065]     ...future.result <- base::tryCatch({
[18:04:30.065]         base::withCallingHandlers({
[18:04:30.065]             ...future.value <- base::withVisible(base::local({
[18:04:30.065]                 ...future.makeSendCondition <- base::local({
[18:04:30.065]                   sendCondition <- NULL
[18:04:30.065]                   function(frame = 1L) {
[18:04:30.065]                     if (is.function(sendCondition)) 
[18:04:30.065]                       return(sendCondition)
[18:04:30.065]                     ns <- getNamespace("parallel")
[18:04:30.065]                     if (exists("sendData", mode = "function", 
[18:04:30.065]                       envir = ns)) {
[18:04:30.065]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:30.065]                         envir = ns)
[18:04:30.065]                       envir <- sys.frame(frame)
[18:04:30.065]                       master <- NULL
[18:04:30.065]                       while (!identical(envir, .GlobalEnv) && 
[18:04:30.065]                         !identical(envir, emptyenv())) {
[18:04:30.065]                         if (exists("master", mode = "list", envir = envir, 
[18:04:30.065]                           inherits = FALSE)) {
[18:04:30.065]                           master <- get("master", mode = "list", 
[18:04:30.065]                             envir = envir, inherits = FALSE)
[18:04:30.065]                           if (inherits(master, c("SOCKnode", 
[18:04:30.065]                             "SOCK0node"))) {
[18:04:30.065]                             sendCondition <<- function(cond) {
[18:04:30.065]                               data <- list(type = "VALUE", value = cond, 
[18:04:30.065]                                 success = TRUE)
[18:04:30.065]                               parallel_sendData(master, data)
[18:04:30.065]                             }
[18:04:30.065]                             return(sendCondition)
[18:04:30.065]                           }
[18:04:30.065]                         }
[18:04:30.065]                         frame <- frame + 1L
[18:04:30.065]                         envir <- sys.frame(frame)
[18:04:30.065]                       }
[18:04:30.065]                     }
[18:04:30.065]                     sendCondition <<- function(cond) NULL
[18:04:30.065]                   }
[18:04:30.065]                 })
[18:04:30.065]                 withCallingHandlers({
[18:04:30.065]                   {
[18:04:30.065]                     lm(dist ~ . - 1, data = cars)
[18:04:30.065]                   }
[18:04:30.065]                 }, immediateCondition = function(cond) {
[18:04:30.065]                   sendCondition <- ...future.makeSendCondition()
[18:04:30.065]                   sendCondition(cond)
[18:04:30.065]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.065]                   {
[18:04:30.065]                     inherits <- base::inherits
[18:04:30.065]                     invokeRestart <- base::invokeRestart
[18:04:30.065]                     is.null <- base::is.null
[18:04:30.065]                     muffled <- FALSE
[18:04:30.065]                     if (inherits(cond, "message")) {
[18:04:30.065]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:30.065]                       if (muffled) 
[18:04:30.065]                         invokeRestart("muffleMessage")
[18:04:30.065]                     }
[18:04:30.065]                     else if (inherits(cond, "warning")) {
[18:04:30.065]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:30.065]                       if (muffled) 
[18:04:30.065]                         invokeRestart("muffleWarning")
[18:04:30.065]                     }
[18:04:30.065]                     else if (inherits(cond, "condition")) {
[18:04:30.065]                       if (!is.null(pattern)) {
[18:04:30.065]                         computeRestarts <- base::computeRestarts
[18:04:30.065]                         grepl <- base::grepl
[18:04:30.065]                         restarts <- computeRestarts(cond)
[18:04:30.065]                         for (restart in restarts) {
[18:04:30.065]                           name <- restart$name
[18:04:30.065]                           if (is.null(name)) 
[18:04:30.065]                             next
[18:04:30.065]                           if (!grepl(pattern, name)) 
[18:04:30.065]                             next
[18:04:30.065]                           invokeRestart(restart)
[18:04:30.065]                           muffled <- TRUE
[18:04:30.065]                           break
[18:04:30.065]                         }
[18:04:30.065]                       }
[18:04:30.065]                     }
[18:04:30.065]                     invisible(muffled)
[18:04:30.065]                   }
[18:04:30.065]                   muffleCondition(cond)
[18:04:30.065]                 })
[18:04:30.065]             }))
[18:04:30.065]             future::FutureResult(value = ...future.value$value, 
[18:04:30.065]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:30.065]                   ...future.rng), globalenv = if (FALSE) 
[18:04:30.065]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:30.065]                     ...future.globalenv.names))
[18:04:30.065]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:30.065]         }, condition = base::local({
[18:04:30.065]             c <- base::c
[18:04:30.065]             inherits <- base::inherits
[18:04:30.065]             invokeRestart <- base::invokeRestart
[18:04:30.065]             length <- base::length
[18:04:30.065]             list <- base::list
[18:04:30.065]             seq.int <- base::seq.int
[18:04:30.065]             signalCondition <- base::signalCondition
[18:04:30.065]             sys.calls <- base::sys.calls
[18:04:30.065]             `[[` <- base::`[[`
[18:04:30.065]             `+` <- base::`+`
[18:04:30.065]             `<<-` <- base::`<<-`
[18:04:30.065]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:30.065]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:30.065]                   3L)]
[18:04:30.065]             }
[18:04:30.065]             function(cond) {
[18:04:30.065]                 is_error <- inherits(cond, "error")
[18:04:30.065]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:30.065]                   NULL)
[18:04:30.065]                 if (is_error) {
[18:04:30.065]                   sessionInformation <- function() {
[18:04:30.065]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:30.065]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:30.065]                       search = base::search(), system = base::Sys.info())
[18:04:30.065]                   }
[18:04:30.065]                   ...future.conditions[[length(...future.conditions) + 
[18:04:30.065]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:30.065]                     cond$call), session = sessionInformation(), 
[18:04:30.065]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:30.065]                   signalCondition(cond)
[18:04:30.065]                 }
[18:04:30.065]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:30.065]                 "immediateCondition"))) {
[18:04:30.065]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:30.065]                   ...future.conditions[[length(...future.conditions) + 
[18:04:30.065]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:30.065]                   if (TRUE && !signal) {
[18:04:30.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.065]                     {
[18:04:30.065]                       inherits <- base::inherits
[18:04:30.065]                       invokeRestart <- base::invokeRestart
[18:04:30.065]                       is.null <- base::is.null
[18:04:30.065]                       muffled <- FALSE
[18:04:30.065]                       if (inherits(cond, "message")) {
[18:04:30.065]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:30.065]                         if (muffled) 
[18:04:30.065]                           invokeRestart("muffleMessage")
[18:04:30.065]                       }
[18:04:30.065]                       else if (inherits(cond, "warning")) {
[18:04:30.065]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:30.065]                         if (muffled) 
[18:04:30.065]                           invokeRestart("muffleWarning")
[18:04:30.065]                       }
[18:04:30.065]                       else if (inherits(cond, "condition")) {
[18:04:30.065]                         if (!is.null(pattern)) {
[18:04:30.065]                           computeRestarts <- base::computeRestarts
[18:04:30.065]                           grepl <- base::grepl
[18:04:30.065]                           restarts <- computeRestarts(cond)
[18:04:30.065]                           for (restart in restarts) {
[18:04:30.065]                             name <- restart$name
[18:04:30.065]                             if (is.null(name)) 
[18:04:30.065]                               next
[18:04:30.065]                             if (!grepl(pattern, name)) 
[18:04:30.065]                               next
[18:04:30.065]                             invokeRestart(restart)
[18:04:30.065]                             muffled <- TRUE
[18:04:30.065]                             break
[18:04:30.065]                           }
[18:04:30.065]                         }
[18:04:30.065]                       }
[18:04:30.065]                       invisible(muffled)
[18:04:30.065]                     }
[18:04:30.065]                     muffleCondition(cond, pattern = "^muffle")
[18:04:30.065]                   }
[18:04:30.065]                 }
[18:04:30.065]                 else {
[18:04:30.065]                   if (TRUE) {
[18:04:30.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.065]                     {
[18:04:30.065]                       inherits <- base::inherits
[18:04:30.065]                       invokeRestart <- base::invokeRestart
[18:04:30.065]                       is.null <- base::is.null
[18:04:30.065]                       muffled <- FALSE
[18:04:30.065]                       if (inherits(cond, "message")) {
[18:04:30.065]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:30.065]                         if (muffled) 
[18:04:30.065]                           invokeRestart("muffleMessage")
[18:04:30.065]                       }
[18:04:30.065]                       else if (inherits(cond, "warning")) {
[18:04:30.065]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:30.065]                         if (muffled) 
[18:04:30.065]                           invokeRestart("muffleWarning")
[18:04:30.065]                       }
[18:04:30.065]                       else if (inherits(cond, "condition")) {
[18:04:30.065]                         if (!is.null(pattern)) {
[18:04:30.065]                           computeRestarts <- base::computeRestarts
[18:04:30.065]                           grepl <- base::grepl
[18:04:30.065]                           restarts <- computeRestarts(cond)
[18:04:30.065]                           for (restart in restarts) {
[18:04:30.065]                             name <- restart$name
[18:04:30.065]                             if (is.null(name)) 
[18:04:30.065]                               next
[18:04:30.065]                             if (!grepl(pattern, name)) 
[18:04:30.065]                               next
[18:04:30.065]                             invokeRestart(restart)
[18:04:30.065]                             muffled <- TRUE
[18:04:30.065]                             break
[18:04:30.065]                           }
[18:04:30.065]                         }
[18:04:30.065]                       }
[18:04:30.065]                       invisible(muffled)
[18:04:30.065]                     }
[18:04:30.065]                     muffleCondition(cond, pattern = "^muffle")
[18:04:30.065]                   }
[18:04:30.065]                 }
[18:04:30.065]             }
[18:04:30.065]         }))
[18:04:30.065]     }, error = function(ex) {
[18:04:30.065]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:30.065]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:30.065]                 ...future.rng), started = ...future.startTime, 
[18:04:30.065]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:30.065]             version = "1.8"), class = "FutureResult")
[18:04:30.065]     }, finally = {
[18:04:30.065]         if (!identical(...future.workdir, getwd())) 
[18:04:30.065]             setwd(...future.workdir)
[18:04:30.065]         {
[18:04:30.065]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:30.065]                 ...future.oldOptions$nwarnings <- NULL
[18:04:30.065]             }
[18:04:30.065]             base::options(...future.oldOptions)
[18:04:30.065]             if (.Platform$OS.type == "windows") {
[18:04:30.065]                 old_names <- names(...future.oldEnvVars)
[18:04:30.065]                 envs <- base::Sys.getenv()
[18:04:30.065]                 names <- names(envs)
[18:04:30.065]                 common <- intersect(names, old_names)
[18:04:30.065]                 added <- setdiff(names, old_names)
[18:04:30.065]                 removed <- setdiff(old_names, names)
[18:04:30.065]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:30.065]                   envs[common]]
[18:04:30.065]                 NAMES <- toupper(changed)
[18:04:30.065]                 args <- list()
[18:04:30.065]                 for (kk in seq_along(NAMES)) {
[18:04:30.065]                   name <- changed[[kk]]
[18:04:30.065]                   NAME <- NAMES[[kk]]
[18:04:30.065]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.065]                     next
[18:04:30.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:30.065]                 }
[18:04:30.065]                 NAMES <- toupper(added)
[18:04:30.065]                 for (kk in seq_along(NAMES)) {
[18:04:30.065]                   name <- added[[kk]]
[18:04:30.065]                   NAME <- NAMES[[kk]]
[18:04:30.065]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.065]                     next
[18:04:30.065]                   args[[name]] <- ""
[18:04:30.065]                 }
[18:04:30.065]                 NAMES <- toupper(removed)
[18:04:30.065]                 for (kk in seq_along(NAMES)) {
[18:04:30.065]                   name <- removed[[kk]]
[18:04:30.065]                   NAME <- NAMES[[kk]]
[18:04:30.065]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.065]                     next
[18:04:30.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:30.065]                 }
[18:04:30.065]                 if (length(args) > 0) 
[18:04:30.065]                   base::do.call(base::Sys.setenv, args = args)
[18:04:30.065]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:30.065]             }
[18:04:30.065]             else {
[18:04:30.065]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:30.065]             }
[18:04:30.065]             {
[18:04:30.065]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:30.065]                   0L) {
[18:04:30.065]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:30.065]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:30.065]                   base::options(opts)
[18:04:30.065]                 }
[18:04:30.065]                 {
[18:04:30.065]                   {
[18:04:30.065]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:30.065]                     NULL
[18:04:30.065]                   }
[18:04:30.065]                   options(future.plan = NULL)
[18:04:30.065]                   if (is.na(NA_character_)) 
[18:04:30.065]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:30.065]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:30.065]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:30.065]                     .init = FALSE)
[18:04:30.065]                 }
[18:04:30.065]             }
[18:04:30.065]         }
[18:04:30.065]     })
[18:04:30.065]     if (TRUE) {
[18:04:30.065]         base::sink(type = "output", split = FALSE)
[18:04:30.065]         if (TRUE) {
[18:04:30.065]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:30.065]         }
[18:04:30.065]         else {
[18:04:30.065]             ...future.result["stdout"] <- base::list(NULL)
[18:04:30.065]         }
[18:04:30.065]         base::close(...future.stdout)
[18:04:30.065]         ...future.stdout <- NULL
[18:04:30.065]     }
[18:04:30.065]     ...future.result$conditions <- ...future.conditions
[18:04:30.065]     ...future.result$finished <- base::Sys.time()
[18:04:30.065]     ...future.result
[18:04:30.065] }
[18:04:30.071] MultisessionFuture started
[18:04:30.072] - Launch lazy future ... done
[18:04:30.072] run() for ‘MultisessionFuture’ ... done
[18:04:30.072] result() for ClusterFuture ...
[18:04:30.072] receiveMessageFromWorker() for ClusterFuture ...
[18:04:30.073] - Validating connection of MultisessionFuture
[18:04:30.118] - received message: FutureResult
[18:04:30.119] - Received FutureResult
[18:04:30.119] - Erased future from FutureRegistry
[18:04:30.119] result() for ClusterFuture ...
[18:04:30.120] - result already collected: FutureResult
[18:04:30.120] result() for ClusterFuture ... done
[18:04:30.120] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:30.120] result() for ClusterFuture ... done
[18:04:30.120] result() for ClusterFuture ...
[18:04:30.121] - result already collected: FutureResult
[18:04:30.121] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[18:04:30.129] getGlobalsAndPackages() ...
[18:04:30.130] Searching for globals...
[18:04:30.133] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[18:04:30.133] Searching for globals ... DONE
[18:04:30.134] Resolving globals: FALSE
[18:04:30.135] 
[18:04:30.135] - packages: [2] ‘stats’, ‘datasets’
[18:04:30.135] getGlobalsAndPackages() ... DONE
[18:04:30.136] run() for ‘Future’ ...
[18:04:30.136] - state: ‘created’
[18:04:30.136] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:30.162] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:30.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:30.163]   - Field: ‘node’
[18:04:30.163]   - Field: ‘label’
[18:04:30.163]   - Field: ‘local’
[18:04:30.163]   - Field: ‘owner’
[18:04:30.164]   - Field: ‘envir’
[18:04:30.164]   - Field: ‘workers’
[18:04:30.164]   - Field: ‘packages’
[18:04:30.164]   - Field: ‘gc’
[18:04:30.165]   - Field: ‘conditions’
[18:04:30.165]   - Field: ‘persistent’
[18:04:30.165]   - Field: ‘expr’
[18:04:30.165]   - Field: ‘uuid’
[18:04:30.165]   - Field: ‘seed’
[18:04:30.166]   - Field: ‘version’
[18:04:30.166]   - Field: ‘result’
[18:04:30.166]   - Field: ‘asynchronous’
[18:04:30.166]   - Field: ‘calls’
[18:04:30.166]   - Field: ‘globals’
[18:04:30.167]   - Field: ‘stdout’
[18:04:30.167]   - Field: ‘earlySignal’
[18:04:30.167]   - Field: ‘lazy’
[18:04:30.167]   - Field: ‘state’
[18:04:30.167] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:30.168] - Launch lazy future ...
[18:04:30.168] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:30.169] Packages needed by future strategies (n = 0): <none>
[18:04:30.170] {
[18:04:30.170]     {
[18:04:30.170]         {
[18:04:30.170]             ...future.startTime <- base::Sys.time()
[18:04:30.170]             {
[18:04:30.170]                 {
[18:04:30.170]                   {
[18:04:30.170]                     {
[18:04:30.170]                       {
[18:04:30.170]                         base::local({
[18:04:30.170]                           has_future <- base::requireNamespace("future", 
[18:04:30.170]                             quietly = TRUE)
[18:04:30.170]                           if (has_future) {
[18:04:30.170]                             ns <- base::getNamespace("future")
[18:04:30.170]                             version <- ns[[".package"]][["version"]]
[18:04:30.170]                             if (is.null(version)) 
[18:04:30.170]                               version <- utils::packageVersion("future")
[18:04:30.170]                           }
[18:04:30.170]                           else {
[18:04:30.170]                             version <- NULL
[18:04:30.170]                           }
[18:04:30.170]                           if (!has_future || version < "1.8.0") {
[18:04:30.170]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:30.170]                               "", base::R.version$version.string), 
[18:04:30.170]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:30.170]                                 base::R.version$platform, 8 * 
[18:04:30.170]                                   base::.Machine$sizeof.pointer), 
[18:04:30.170]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:30.170]                                 "release", "version")], collapse = " "), 
[18:04:30.170]                               hostname = base::Sys.info()[["nodename"]])
[18:04:30.170]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:30.170]                               info)
[18:04:30.170]                             info <- base::paste(info, collapse = "; ")
[18:04:30.170]                             if (!has_future) {
[18:04:30.170]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:30.170]                                 info)
[18:04:30.170]                             }
[18:04:30.170]                             else {
[18:04:30.170]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:30.170]                                 info, version)
[18:04:30.170]                             }
[18:04:30.170]                             base::stop(msg)
[18:04:30.170]                           }
[18:04:30.170]                         })
[18:04:30.170]                       }
[18:04:30.170]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:30.170]                       base::options(mc.cores = 1L)
[18:04:30.170]                     }
[18:04:30.170]                     base::local({
[18:04:30.170]                       for (pkg in c("stats", "datasets")) {
[18:04:30.170]                         base::loadNamespace(pkg)
[18:04:30.170]                         base::library(pkg, character.only = TRUE)
[18:04:30.170]                       }
[18:04:30.170]                     })
[18:04:30.170]                   }
[18:04:30.170]                   ...future.strategy.old <- future::plan("list")
[18:04:30.170]                   options(future.plan = NULL)
[18:04:30.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:30.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:30.170]                 }
[18:04:30.170]                 ...future.workdir <- getwd()
[18:04:30.170]             }
[18:04:30.170]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:30.170]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:30.170]         }
[18:04:30.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:30.170]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:30.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:30.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:30.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:30.170]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:30.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:30.170]             base::names(...future.oldOptions))
[18:04:30.170]     }
[18:04:30.170]     if (FALSE) {
[18:04:30.170]     }
[18:04:30.170]     else {
[18:04:30.170]         if (TRUE) {
[18:04:30.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:30.170]                 open = "w")
[18:04:30.170]         }
[18:04:30.170]         else {
[18:04:30.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:30.170]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:30.170]         }
[18:04:30.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:30.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:30.170]             base::sink(type = "output", split = FALSE)
[18:04:30.170]             base::close(...future.stdout)
[18:04:30.170]         }, add = TRUE)
[18:04:30.170]     }
[18:04:30.170]     ...future.frame <- base::sys.nframe()
[18:04:30.170]     ...future.conditions <- base::list()
[18:04:30.170]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:30.170]     if (FALSE) {
[18:04:30.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:30.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:30.170]     }
[18:04:30.170]     ...future.result <- base::tryCatch({
[18:04:30.170]         base::withCallingHandlers({
[18:04:30.170]             ...future.value <- base::withVisible(base::local({
[18:04:30.170]                 ...future.makeSendCondition <- base::local({
[18:04:30.170]                   sendCondition <- NULL
[18:04:30.170]                   function(frame = 1L) {
[18:04:30.170]                     if (is.function(sendCondition)) 
[18:04:30.170]                       return(sendCondition)
[18:04:30.170]                     ns <- getNamespace("parallel")
[18:04:30.170]                     if (exists("sendData", mode = "function", 
[18:04:30.170]                       envir = ns)) {
[18:04:30.170]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:30.170]                         envir = ns)
[18:04:30.170]                       envir <- sys.frame(frame)
[18:04:30.170]                       master <- NULL
[18:04:30.170]                       while (!identical(envir, .GlobalEnv) && 
[18:04:30.170]                         !identical(envir, emptyenv())) {
[18:04:30.170]                         if (exists("master", mode = "list", envir = envir, 
[18:04:30.170]                           inherits = FALSE)) {
[18:04:30.170]                           master <- get("master", mode = "list", 
[18:04:30.170]                             envir = envir, inherits = FALSE)
[18:04:30.170]                           if (inherits(master, c("SOCKnode", 
[18:04:30.170]                             "SOCK0node"))) {
[18:04:30.170]                             sendCondition <<- function(cond) {
[18:04:30.170]                               data <- list(type = "VALUE", value = cond, 
[18:04:30.170]                                 success = TRUE)
[18:04:30.170]                               parallel_sendData(master, data)
[18:04:30.170]                             }
[18:04:30.170]                             return(sendCondition)
[18:04:30.170]                           }
[18:04:30.170]                         }
[18:04:30.170]                         frame <- frame + 1L
[18:04:30.170]                         envir <- sys.frame(frame)
[18:04:30.170]                       }
[18:04:30.170]                     }
[18:04:30.170]                     sendCondition <<- function(cond) NULL
[18:04:30.170]                   }
[18:04:30.170]                 })
[18:04:30.170]                 withCallingHandlers({
[18:04:30.170]                   {
[18:04:30.170]                     lm(dist ~ . + 0, data = cars)
[18:04:30.170]                   }
[18:04:30.170]                 }, immediateCondition = function(cond) {
[18:04:30.170]                   sendCondition <- ...future.makeSendCondition()
[18:04:30.170]                   sendCondition(cond)
[18:04:30.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.170]                   {
[18:04:30.170]                     inherits <- base::inherits
[18:04:30.170]                     invokeRestart <- base::invokeRestart
[18:04:30.170]                     is.null <- base::is.null
[18:04:30.170]                     muffled <- FALSE
[18:04:30.170]                     if (inherits(cond, "message")) {
[18:04:30.170]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:30.170]                       if (muffled) 
[18:04:30.170]                         invokeRestart("muffleMessage")
[18:04:30.170]                     }
[18:04:30.170]                     else if (inherits(cond, "warning")) {
[18:04:30.170]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:30.170]                       if (muffled) 
[18:04:30.170]                         invokeRestart("muffleWarning")
[18:04:30.170]                     }
[18:04:30.170]                     else if (inherits(cond, "condition")) {
[18:04:30.170]                       if (!is.null(pattern)) {
[18:04:30.170]                         computeRestarts <- base::computeRestarts
[18:04:30.170]                         grepl <- base::grepl
[18:04:30.170]                         restarts <- computeRestarts(cond)
[18:04:30.170]                         for (restart in restarts) {
[18:04:30.170]                           name <- restart$name
[18:04:30.170]                           if (is.null(name)) 
[18:04:30.170]                             next
[18:04:30.170]                           if (!grepl(pattern, name)) 
[18:04:30.170]                             next
[18:04:30.170]                           invokeRestart(restart)
[18:04:30.170]                           muffled <- TRUE
[18:04:30.170]                           break
[18:04:30.170]                         }
[18:04:30.170]                       }
[18:04:30.170]                     }
[18:04:30.170]                     invisible(muffled)
[18:04:30.170]                   }
[18:04:30.170]                   muffleCondition(cond)
[18:04:30.170]                 })
[18:04:30.170]             }))
[18:04:30.170]             future::FutureResult(value = ...future.value$value, 
[18:04:30.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:30.170]                   ...future.rng), globalenv = if (FALSE) 
[18:04:30.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:30.170]                     ...future.globalenv.names))
[18:04:30.170]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:30.170]         }, condition = base::local({
[18:04:30.170]             c <- base::c
[18:04:30.170]             inherits <- base::inherits
[18:04:30.170]             invokeRestart <- base::invokeRestart
[18:04:30.170]             length <- base::length
[18:04:30.170]             list <- base::list
[18:04:30.170]             seq.int <- base::seq.int
[18:04:30.170]             signalCondition <- base::signalCondition
[18:04:30.170]             sys.calls <- base::sys.calls
[18:04:30.170]             `[[` <- base::`[[`
[18:04:30.170]             `+` <- base::`+`
[18:04:30.170]             `<<-` <- base::`<<-`
[18:04:30.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:30.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:30.170]                   3L)]
[18:04:30.170]             }
[18:04:30.170]             function(cond) {
[18:04:30.170]                 is_error <- inherits(cond, "error")
[18:04:30.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:30.170]                   NULL)
[18:04:30.170]                 if (is_error) {
[18:04:30.170]                   sessionInformation <- function() {
[18:04:30.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:30.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:30.170]                       search = base::search(), system = base::Sys.info())
[18:04:30.170]                   }
[18:04:30.170]                   ...future.conditions[[length(...future.conditions) + 
[18:04:30.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:30.170]                     cond$call), session = sessionInformation(), 
[18:04:30.170]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:30.170]                   signalCondition(cond)
[18:04:30.170]                 }
[18:04:30.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:30.170]                 "immediateCondition"))) {
[18:04:30.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:30.170]                   ...future.conditions[[length(...future.conditions) + 
[18:04:30.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:30.170]                   if (TRUE && !signal) {
[18:04:30.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.170]                     {
[18:04:30.170]                       inherits <- base::inherits
[18:04:30.170]                       invokeRestart <- base::invokeRestart
[18:04:30.170]                       is.null <- base::is.null
[18:04:30.170]                       muffled <- FALSE
[18:04:30.170]                       if (inherits(cond, "message")) {
[18:04:30.170]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:30.170]                         if (muffled) 
[18:04:30.170]                           invokeRestart("muffleMessage")
[18:04:30.170]                       }
[18:04:30.170]                       else if (inherits(cond, "warning")) {
[18:04:30.170]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:30.170]                         if (muffled) 
[18:04:30.170]                           invokeRestart("muffleWarning")
[18:04:30.170]                       }
[18:04:30.170]                       else if (inherits(cond, "condition")) {
[18:04:30.170]                         if (!is.null(pattern)) {
[18:04:30.170]                           computeRestarts <- base::computeRestarts
[18:04:30.170]                           grepl <- base::grepl
[18:04:30.170]                           restarts <- computeRestarts(cond)
[18:04:30.170]                           for (restart in restarts) {
[18:04:30.170]                             name <- restart$name
[18:04:30.170]                             if (is.null(name)) 
[18:04:30.170]                               next
[18:04:30.170]                             if (!grepl(pattern, name)) 
[18:04:30.170]                               next
[18:04:30.170]                             invokeRestart(restart)
[18:04:30.170]                             muffled <- TRUE
[18:04:30.170]                             break
[18:04:30.170]                           }
[18:04:30.170]                         }
[18:04:30.170]                       }
[18:04:30.170]                       invisible(muffled)
[18:04:30.170]                     }
[18:04:30.170]                     muffleCondition(cond, pattern = "^muffle")
[18:04:30.170]                   }
[18:04:30.170]                 }
[18:04:30.170]                 else {
[18:04:30.170]                   if (TRUE) {
[18:04:30.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.170]                     {
[18:04:30.170]                       inherits <- base::inherits
[18:04:30.170]                       invokeRestart <- base::invokeRestart
[18:04:30.170]                       is.null <- base::is.null
[18:04:30.170]                       muffled <- FALSE
[18:04:30.170]                       if (inherits(cond, "message")) {
[18:04:30.170]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:30.170]                         if (muffled) 
[18:04:30.170]                           invokeRestart("muffleMessage")
[18:04:30.170]                       }
[18:04:30.170]                       else if (inherits(cond, "warning")) {
[18:04:30.170]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:30.170]                         if (muffled) 
[18:04:30.170]                           invokeRestart("muffleWarning")
[18:04:30.170]                       }
[18:04:30.170]                       else if (inherits(cond, "condition")) {
[18:04:30.170]                         if (!is.null(pattern)) {
[18:04:30.170]                           computeRestarts <- base::computeRestarts
[18:04:30.170]                           grepl <- base::grepl
[18:04:30.170]                           restarts <- computeRestarts(cond)
[18:04:30.170]                           for (restart in restarts) {
[18:04:30.170]                             name <- restart$name
[18:04:30.170]                             if (is.null(name)) 
[18:04:30.170]                               next
[18:04:30.170]                             if (!grepl(pattern, name)) 
[18:04:30.170]                               next
[18:04:30.170]                             invokeRestart(restart)
[18:04:30.170]                             muffled <- TRUE
[18:04:30.170]                             break
[18:04:30.170]                           }
[18:04:30.170]                         }
[18:04:30.170]                       }
[18:04:30.170]                       invisible(muffled)
[18:04:30.170]                     }
[18:04:30.170]                     muffleCondition(cond, pattern = "^muffle")
[18:04:30.170]                   }
[18:04:30.170]                 }
[18:04:30.170]             }
[18:04:30.170]         }))
[18:04:30.170]     }, error = function(ex) {
[18:04:30.170]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:30.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:30.170]                 ...future.rng), started = ...future.startTime, 
[18:04:30.170]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:30.170]             version = "1.8"), class = "FutureResult")
[18:04:30.170]     }, finally = {
[18:04:30.170]         if (!identical(...future.workdir, getwd())) 
[18:04:30.170]             setwd(...future.workdir)
[18:04:30.170]         {
[18:04:30.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:30.170]                 ...future.oldOptions$nwarnings <- NULL
[18:04:30.170]             }
[18:04:30.170]             base::options(...future.oldOptions)
[18:04:30.170]             if (.Platform$OS.type == "windows") {
[18:04:30.170]                 old_names <- names(...future.oldEnvVars)
[18:04:30.170]                 envs <- base::Sys.getenv()
[18:04:30.170]                 names <- names(envs)
[18:04:30.170]                 common <- intersect(names, old_names)
[18:04:30.170]                 added <- setdiff(names, old_names)
[18:04:30.170]                 removed <- setdiff(old_names, names)
[18:04:30.170]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:30.170]                   envs[common]]
[18:04:30.170]                 NAMES <- toupper(changed)
[18:04:30.170]                 args <- list()
[18:04:30.170]                 for (kk in seq_along(NAMES)) {
[18:04:30.170]                   name <- changed[[kk]]
[18:04:30.170]                   NAME <- NAMES[[kk]]
[18:04:30.170]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.170]                     next
[18:04:30.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:30.170]                 }
[18:04:30.170]                 NAMES <- toupper(added)
[18:04:30.170]                 for (kk in seq_along(NAMES)) {
[18:04:30.170]                   name <- added[[kk]]
[18:04:30.170]                   NAME <- NAMES[[kk]]
[18:04:30.170]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.170]                     next
[18:04:30.170]                   args[[name]] <- ""
[18:04:30.170]                 }
[18:04:30.170]                 NAMES <- toupper(removed)
[18:04:30.170]                 for (kk in seq_along(NAMES)) {
[18:04:30.170]                   name <- removed[[kk]]
[18:04:30.170]                   NAME <- NAMES[[kk]]
[18:04:30.170]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.170]                     next
[18:04:30.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:30.170]                 }
[18:04:30.170]                 if (length(args) > 0) 
[18:04:30.170]                   base::do.call(base::Sys.setenv, args = args)
[18:04:30.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:30.170]             }
[18:04:30.170]             else {
[18:04:30.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:30.170]             }
[18:04:30.170]             {
[18:04:30.170]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:30.170]                   0L) {
[18:04:30.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:30.170]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:30.170]                   base::options(opts)
[18:04:30.170]                 }
[18:04:30.170]                 {
[18:04:30.170]                   {
[18:04:30.170]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:30.170]                     NULL
[18:04:30.170]                   }
[18:04:30.170]                   options(future.plan = NULL)
[18:04:30.170]                   if (is.na(NA_character_)) 
[18:04:30.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:30.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:30.170]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:30.170]                     .init = FALSE)
[18:04:30.170]                 }
[18:04:30.170]             }
[18:04:30.170]         }
[18:04:30.170]     })
[18:04:30.170]     if (TRUE) {
[18:04:30.170]         base::sink(type = "output", split = FALSE)
[18:04:30.170]         if (TRUE) {
[18:04:30.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:30.170]         }
[18:04:30.170]         else {
[18:04:30.170]             ...future.result["stdout"] <- base::list(NULL)
[18:04:30.170]         }
[18:04:30.170]         base::close(...future.stdout)
[18:04:30.170]         ...future.stdout <- NULL
[18:04:30.170]     }
[18:04:30.170]     ...future.result$conditions <- ...future.conditions
[18:04:30.170]     ...future.result$finished <- base::Sys.time()
[18:04:30.170]     ...future.result
[18:04:30.170] }
[18:04:30.176] MultisessionFuture started
[18:04:30.176] - Launch lazy future ... done
[18:04:30.176] run() for ‘MultisessionFuture’ ... done
[18:04:30.177] result() for ClusterFuture ...
[18:04:30.178] receiveMessageFromWorker() for ClusterFuture ...
[18:04:30.178] - Validating connection of MultisessionFuture
[18:04:30.222] - received message: FutureResult
[18:04:30.222] - Received FutureResult
[18:04:30.223] - Erased future from FutureRegistry
[18:04:30.223] result() for ClusterFuture ...
[18:04:30.223] - result already collected: FutureResult
[18:04:30.223] result() for ClusterFuture ... done
[18:04:30.223] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:30.224] result() for ClusterFuture ... done
[18:04:30.224] result() for ClusterFuture ...
[18:04:30.224] - result already collected: FutureResult
[18:04:30.224] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[18:04:30.229] getGlobalsAndPackages() ...
[18:04:30.229] Searching for globals...
[18:04:30.233] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[18:04:30.234] Searching for globals ... DONE
[18:04:30.234] Resolving globals: FALSE
[18:04:30.235] 
[18:04:30.235] - packages: [2] ‘stats’, ‘datasets’
[18:04:30.235] getGlobalsAndPackages() ... DONE
[18:04:30.236] run() for ‘Future’ ...
[18:04:30.236] - state: ‘created’
[18:04:30.236] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:30.260] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:30.260] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:30.261]   - Field: ‘node’
[18:04:30.261]   - Field: ‘label’
[18:04:30.261]   - Field: ‘local’
[18:04:30.261]   - Field: ‘owner’
[18:04:30.262]   - Field: ‘envir’
[18:04:30.262]   - Field: ‘workers’
[18:04:30.262]   - Field: ‘packages’
[18:04:30.262]   - Field: ‘gc’
[18:04:30.262]   - Field: ‘conditions’
[18:04:30.263]   - Field: ‘persistent’
[18:04:30.263]   - Field: ‘expr’
[18:04:30.263]   - Field: ‘uuid’
[18:04:30.263]   - Field: ‘seed’
[18:04:30.263]   - Field: ‘version’
[18:04:30.264]   - Field: ‘result’
[18:04:30.264]   - Field: ‘asynchronous’
[18:04:30.264]   - Field: ‘calls’
[18:04:30.264]   - Field: ‘globals’
[18:04:30.264]   - Field: ‘stdout’
[18:04:30.265]   - Field: ‘earlySignal’
[18:04:30.265]   - Field: ‘lazy’
[18:04:30.265]   - Field: ‘state’
[18:04:30.265] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:30.265] - Launch lazy future ...
[18:04:30.266] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:30.266] Packages needed by future strategies (n = 0): <none>
[18:04:30.267] {
[18:04:30.267]     {
[18:04:30.267]         {
[18:04:30.267]             ...future.startTime <- base::Sys.time()
[18:04:30.267]             {
[18:04:30.267]                 {
[18:04:30.267]                   {
[18:04:30.267]                     {
[18:04:30.267]                       {
[18:04:30.267]                         base::local({
[18:04:30.267]                           has_future <- base::requireNamespace("future", 
[18:04:30.267]                             quietly = TRUE)
[18:04:30.267]                           if (has_future) {
[18:04:30.267]                             ns <- base::getNamespace("future")
[18:04:30.267]                             version <- ns[[".package"]][["version"]]
[18:04:30.267]                             if (is.null(version)) 
[18:04:30.267]                               version <- utils::packageVersion("future")
[18:04:30.267]                           }
[18:04:30.267]                           else {
[18:04:30.267]                             version <- NULL
[18:04:30.267]                           }
[18:04:30.267]                           if (!has_future || version < "1.8.0") {
[18:04:30.267]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:30.267]                               "", base::R.version$version.string), 
[18:04:30.267]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:30.267]                                 base::R.version$platform, 8 * 
[18:04:30.267]                                   base::.Machine$sizeof.pointer), 
[18:04:30.267]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:30.267]                                 "release", "version")], collapse = " "), 
[18:04:30.267]                               hostname = base::Sys.info()[["nodename"]])
[18:04:30.267]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:30.267]                               info)
[18:04:30.267]                             info <- base::paste(info, collapse = "; ")
[18:04:30.267]                             if (!has_future) {
[18:04:30.267]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:30.267]                                 info)
[18:04:30.267]                             }
[18:04:30.267]                             else {
[18:04:30.267]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:30.267]                                 info, version)
[18:04:30.267]                             }
[18:04:30.267]                             base::stop(msg)
[18:04:30.267]                           }
[18:04:30.267]                         })
[18:04:30.267]                       }
[18:04:30.267]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:30.267]                       base::options(mc.cores = 1L)
[18:04:30.267]                     }
[18:04:30.267]                     base::local({
[18:04:30.267]                       for (pkg in c("stats", "datasets")) {
[18:04:30.267]                         base::loadNamespace(pkg)
[18:04:30.267]                         base::library(pkg, character.only = TRUE)
[18:04:30.267]                       }
[18:04:30.267]                     })
[18:04:30.267]                   }
[18:04:30.267]                   ...future.strategy.old <- future::plan("list")
[18:04:30.267]                   options(future.plan = NULL)
[18:04:30.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:30.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:30.267]                 }
[18:04:30.267]                 ...future.workdir <- getwd()
[18:04:30.267]             }
[18:04:30.267]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:30.267]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:30.267]         }
[18:04:30.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:30.267]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:30.267]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:30.267]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:30.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:30.267]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:30.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:30.267]             base::names(...future.oldOptions))
[18:04:30.267]     }
[18:04:30.267]     if (FALSE) {
[18:04:30.267]     }
[18:04:30.267]     else {
[18:04:30.267]         if (TRUE) {
[18:04:30.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:30.267]                 open = "w")
[18:04:30.267]         }
[18:04:30.267]         else {
[18:04:30.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:30.267]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:30.267]         }
[18:04:30.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:30.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:30.267]             base::sink(type = "output", split = FALSE)
[18:04:30.267]             base::close(...future.stdout)
[18:04:30.267]         }, add = TRUE)
[18:04:30.267]     }
[18:04:30.267]     ...future.frame <- base::sys.nframe()
[18:04:30.267]     ...future.conditions <- base::list()
[18:04:30.267]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:30.267]     if (FALSE) {
[18:04:30.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:30.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:30.267]     }
[18:04:30.267]     ...future.result <- base::tryCatch({
[18:04:30.267]         base::withCallingHandlers({
[18:04:30.267]             ...future.value <- base::withVisible(base::local({
[18:04:30.267]                 ...future.makeSendCondition <- base::local({
[18:04:30.267]                   sendCondition <- NULL
[18:04:30.267]                   function(frame = 1L) {
[18:04:30.267]                     if (is.function(sendCondition)) 
[18:04:30.267]                       return(sendCondition)
[18:04:30.267]                     ns <- getNamespace("parallel")
[18:04:30.267]                     if (exists("sendData", mode = "function", 
[18:04:30.267]                       envir = ns)) {
[18:04:30.267]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:30.267]                         envir = ns)
[18:04:30.267]                       envir <- sys.frame(frame)
[18:04:30.267]                       master <- NULL
[18:04:30.267]                       while (!identical(envir, .GlobalEnv) && 
[18:04:30.267]                         !identical(envir, emptyenv())) {
[18:04:30.267]                         if (exists("master", mode = "list", envir = envir, 
[18:04:30.267]                           inherits = FALSE)) {
[18:04:30.267]                           master <- get("master", mode = "list", 
[18:04:30.267]                             envir = envir, inherits = FALSE)
[18:04:30.267]                           if (inherits(master, c("SOCKnode", 
[18:04:30.267]                             "SOCK0node"))) {
[18:04:30.267]                             sendCondition <<- function(cond) {
[18:04:30.267]                               data <- list(type = "VALUE", value = cond, 
[18:04:30.267]                                 success = TRUE)
[18:04:30.267]                               parallel_sendData(master, data)
[18:04:30.267]                             }
[18:04:30.267]                             return(sendCondition)
[18:04:30.267]                           }
[18:04:30.267]                         }
[18:04:30.267]                         frame <- frame + 1L
[18:04:30.267]                         envir <- sys.frame(frame)
[18:04:30.267]                       }
[18:04:30.267]                     }
[18:04:30.267]                     sendCondition <<- function(cond) NULL
[18:04:30.267]                   }
[18:04:30.267]                 })
[18:04:30.267]                 withCallingHandlers({
[18:04:30.267]                   {
[18:04:30.267]                     lm(dist ~ speed + speed^2, data = cars)
[18:04:30.267]                   }
[18:04:30.267]                 }, immediateCondition = function(cond) {
[18:04:30.267]                   sendCondition <- ...future.makeSendCondition()
[18:04:30.267]                   sendCondition(cond)
[18:04:30.267]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.267]                   {
[18:04:30.267]                     inherits <- base::inherits
[18:04:30.267]                     invokeRestart <- base::invokeRestart
[18:04:30.267]                     is.null <- base::is.null
[18:04:30.267]                     muffled <- FALSE
[18:04:30.267]                     if (inherits(cond, "message")) {
[18:04:30.267]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:30.267]                       if (muffled) 
[18:04:30.267]                         invokeRestart("muffleMessage")
[18:04:30.267]                     }
[18:04:30.267]                     else if (inherits(cond, "warning")) {
[18:04:30.267]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:30.267]                       if (muffled) 
[18:04:30.267]                         invokeRestart("muffleWarning")
[18:04:30.267]                     }
[18:04:30.267]                     else if (inherits(cond, "condition")) {
[18:04:30.267]                       if (!is.null(pattern)) {
[18:04:30.267]                         computeRestarts <- base::computeRestarts
[18:04:30.267]                         grepl <- base::grepl
[18:04:30.267]                         restarts <- computeRestarts(cond)
[18:04:30.267]                         for (restart in restarts) {
[18:04:30.267]                           name <- restart$name
[18:04:30.267]                           if (is.null(name)) 
[18:04:30.267]                             next
[18:04:30.267]                           if (!grepl(pattern, name)) 
[18:04:30.267]                             next
[18:04:30.267]                           invokeRestart(restart)
[18:04:30.267]                           muffled <- TRUE
[18:04:30.267]                           break
[18:04:30.267]                         }
[18:04:30.267]                       }
[18:04:30.267]                     }
[18:04:30.267]                     invisible(muffled)
[18:04:30.267]                   }
[18:04:30.267]                   muffleCondition(cond)
[18:04:30.267]                 })
[18:04:30.267]             }))
[18:04:30.267]             future::FutureResult(value = ...future.value$value, 
[18:04:30.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:30.267]                   ...future.rng), globalenv = if (FALSE) 
[18:04:30.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:30.267]                     ...future.globalenv.names))
[18:04:30.267]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:30.267]         }, condition = base::local({
[18:04:30.267]             c <- base::c
[18:04:30.267]             inherits <- base::inherits
[18:04:30.267]             invokeRestart <- base::invokeRestart
[18:04:30.267]             length <- base::length
[18:04:30.267]             list <- base::list
[18:04:30.267]             seq.int <- base::seq.int
[18:04:30.267]             signalCondition <- base::signalCondition
[18:04:30.267]             sys.calls <- base::sys.calls
[18:04:30.267]             `[[` <- base::`[[`
[18:04:30.267]             `+` <- base::`+`
[18:04:30.267]             `<<-` <- base::`<<-`
[18:04:30.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:30.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:30.267]                   3L)]
[18:04:30.267]             }
[18:04:30.267]             function(cond) {
[18:04:30.267]                 is_error <- inherits(cond, "error")
[18:04:30.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:30.267]                   NULL)
[18:04:30.267]                 if (is_error) {
[18:04:30.267]                   sessionInformation <- function() {
[18:04:30.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:30.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:30.267]                       search = base::search(), system = base::Sys.info())
[18:04:30.267]                   }
[18:04:30.267]                   ...future.conditions[[length(...future.conditions) + 
[18:04:30.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:30.267]                     cond$call), session = sessionInformation(), 
[18:04:30.267]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:30.267]                   signalCondition(cond)
[18:04:30.267]                 }
[18:04:30.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:30.267]                 "immediateCondition"))) {
[18:04:30.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:30.267]                   ...future.conditions[[length(...future.conditions) + 
[18:04:30.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:30.267]                   if (TRUE && !signal) {
[18:04:30.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.267]                     {
[18:04:30.267]                       inherits <- base::inherits
[18:04:30.267]                       invokeRestart <- base::invokeRestart
[18:04:30.267]                       is.null <- base::is.null
[18:04:30.267]                       muffled <- FALSE
[18:04:30.267]                       if (inherits(cond, "message")) {
[18:04:30.267]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:30.267]                         if (muffled) 
[18:04:30.267]                           invokeRestart("muffleMessage")
[18:04:30.267]                       }
[18:04:30.267]                       else if (inherits(cond, "warning")) {
[18:04:30.267]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:30.267]                         if (muffled) 
[18:04:30.267]                           invokeRestart("muffleWarning")
[18:04:30.267]                       }
[18:04:30.267]                       else if (inherits(cond, "condition")) {
[18:04:30.267]                         if (!is.null(pattern)) {
[18:04:30.267]                           computeRestarts <- base::computeRestarts
[18:04:30.267]                           grepl <- base::grepl
[18:04:30.267]                           restarts <- computeRestarts(cond)
[18:04:30.267]                           for (restart in restarts) {
[18:04:30.267]                             name <- restart$name
[18:04:30.267]                             if (is.null(name)) 
[18:04:30.267]                               next
[18:04:30.267]                             if (!grepl(pattern, name)) 
[18:04:30.267]                               next
[18:04:30.267]                             invokeRestart(restart)
[18:04:30.267]                             muffled <- TRUE
[18:04:30.267]                             break
[18:04:30.267]                           }
[18:04:30.267]                         }
[18:04:30.267]                       }
[18:04:30.267]                       invisible(muffled)
[18:04:30.267]                     }
[18:04:30.267]                     muffleCondition(cond, pattern = "^muffle")
[18:04:30.267]                   }
[18:04:30.267]                 }
[18:04:30.267]                 else {
[18:04:30.267]                   if (TRUE) {
[18:04:30.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.267]                     {
[18:04:30.267]                       inherits <- base::inherits
[18:04:30.267]                       invokeRestart <- base::invokeRestart
[18:04:30.267]                       is.null <- base::is.null
[18:04:30.267]                       muffled <- FALSE
[18:04:30.267]                       if (inherits(cond, "message")) {
[18:04:30.267]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:30.267]                         if (muffled) 
[18:04:30.267]                           invokeRestart("muffleMessage")
[18:04:30.267]                       }
[18:04:30.267]                       else if (inherits(cond, "warning")) {
[18:04:30.267]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:30.267]                         if (muffled) 
[18:04:30.267]                           invokeRestart("muffleWarning")
[18:04:30.267]                       }
[18:04:30.267]                       else if (inherits(cond, "condition")) {
[18:04:30.267]                         if (!is.null(pattern)) {
[18:04:30.267]                           computeRestarts <- base::computeRestarts
[18:04:30.267]                           grepl <- base::grepl
[18:04:30.267]                           restarts <- computeRestarts(cond)
[18:04:30.267]                           for (restart in restarts) {
[18:04:30.267]                             name <- restart$name
[18:04:30.267]                             if (is.null(name)) 
[18:04:30.267]                               next
[18:04:30.267]                             if (!grepl(pattern, name)) 
[18:04:30.267]                               next
[18:04:30.267]                             invokeRestart(restart)
[18:04:30.267]                             muffled <- TRUE
[18:04:30.267]                             break
[18:04:30.267]                           }
[18:04:30.267]                         }
[18:04:30.267]                       }
[18:04:30.267]                       invisible(muffled)
[18:04:30.267]                     }
[18:04:30.267]                     muffleCondition(cond, pattern = "^muffle")
[18:04:30.267]                   }
[18:04:30.267]                 }
[18:04:30.267]             }
[18:04:30.267]         }))
[18:04:30.267]     }, error = function(ex) {
[18:04:30.267]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:30.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:30.267]                 ...future.rng), started = ...future.startTime, 
[18:04:30.267]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:30.267]             version = "1.8"), class = "FutureResult")
[18:04:30.267]     }, finally = {
[18:04:30.267]         if (!identical(...future.workdir, getwd())) 
[18:04:30.267]             setwd(...future.workdir)
[18:04:30.267]         {
[18:04:30.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:30.267]                 ...future.oldOptions$nwarnings <- NULL
[18:04:30.267]             }
[18:04:30.267]             base::options(...future.oldOptions)
[18:04:30.267]             if (.Platform$OS.type == "windows") {
[18:04:30.267]                 old_names <- names(...future.oldEnvVars)
[18:04:30.267]                 envs <- base::Sys.getenv()
[18:04:30.267]                 names <- names(envs)
[18:04:30.267]                 common <- intersect(names, old_names)
[18:04:30.267]                 added <- setdiff(names, old_names)
[18:04:30.267]                 removed <- setdiff(old_names, names)
[18:04:30.267]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:30.267]                   envs[common]]
[18:04:30.267]                 NAMES <- toupper(changed)
[18:04:30.267]                 args <- list()
[18:04:30.267]                 for (kk in seq_along(NAMES)) {
[18:04:30.267]                   name <- changed[[kk]]
[18:04:30.267]                   NAME <- NAMES[[kk]]
[18:04:30.267]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.267]                     next
[18:04:30.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:30.267]                 }
[18:04:30.267]                 NAMES <- toupper(added)
[18:04:30.267]                 for (kk in seq_along(NAMES)) {
[18:04:30.267]                   name <- added[[kk]]
[18:04:30.267]                   NAME <- NAMES[[kk]]
[18:04:30.267]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.267]                     next
[18:04:30.267]                   args[[name]] <- ""
[18:04:30.267]                 }
[18:04:30.267]                 NAMES <- toupper(removed)
[18:04:30.267]                 for (kk in seq_along(NAMES)) {
[18:04:30.267]                   name <- removed[[kk]]
[18:04:30.267]                   NAME <- NAMES[[kk]]
[18:04:30.267]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.267]                     next
[18:04:30.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:30.267]                 }
[18:04:30.267]                 if (length(args) > 0) 
[18:04:30.267]                   base::do.call(base::Sys.setenv, args = args)
[18:04:30.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:30.267]             }
[18:04:30.267]             else {
[18:04:30.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:30.267]             }
[18:04:30.267]             {
[18:04:30.267]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:30.267]                   0L) {
[18:04:30.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:30.267]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:30.267]                   base::options(opts)
[18:04:30.267]                 }
[18:04:30.267]                 {
[18:04:30.267]                   {
[18:04:30.267]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:30.267]                     NULL
[18:04:30.267]                   }
[18:04:30.267]                   options(future.plan = NULL)
[18:04:30.267]                   if (is.na(NA_character_)) 
[18:04:30.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:30.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:30.267]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:30.267]                     .init = FALSE)
[18:04:30.267]                 }
[18:04:30.267]             }
[18:04:30.267]         }
[18:04:30.267]     })
[18:04:30.267]     if (TRUE) {
[18:04:30.267]         base::sink(type = "output", split = FALSE)
[18:04:30.267]         if (TRUE) {
[18:04:30.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:30.267]         }
[18:04:30.267]         else {
[18:04:30.267]             ...future.result["stdout"] <- base::list(NULL)
[18:04:30.267]         }
[18:04:30.267]         base::close(...future.stdout)
[18:04:30.267]         ...future.stdout <- NULL
[18:04:30.267]     }
[18:04:30.267]     ...future.result$conditions <- ...future.conditions
[18:04:30.267]     ...future.result$finished <- base::Sys.time()
[18:04:30.267]     ...future.result
[18:04:30.267] }
[18:04:30.273] MultisessionFuture started
[18:04:30.274] - Launch lazy future ... done
[18:04:30.274] run() for ‘MultisessionFuture’ ... done
[18:04:30.274] result() for ClusterFuture ...
[18:04:30.274] receiveMessageFromWorker() for ClusterFuture ...
[18:04:30.275] - Validating connection of MultisessionFuture
[18:04:30.320] - received message: FutureResult
[18:04:30.320] - Received FutureResult
[18:04:30.321] - Erased future from FutureRegistry
[18:04:30.321] result() for ClusterFuture ...
[18:04:30.321] - result already collected: FutureResult
[18:04:30.321] result() for ClusterFuture ... done
[18:04:30.321] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:30.322] result() for ClusterFuture ... done
[18:04:30.322] result() for ClusterFuture ...
[18:04:30.322] - result already collected: FutureResult
[18:04:30.322] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[18:04:30.328] getGlobalsAndPackages() ...
[18:04:30.328] Searching for globals...
[18:04:30.332] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[18:04:30.333] Searching for globals ... DONE
[18:04:30.333] Resolving globals: FALSE
[18:04:30.334] 
[18:04:30.334] - packages: [2] ‘stats’, ‘datasets’
[18:04:30.334] getGlobalsAndPackages() ... DONE
[18:04:30.335] run() for ‘Future’ ...
[18:04:30.335] - state: ‘created’
[18:04:30.335] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:30.362] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:30.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:30.363]   - Field: ‘node’
[18:04:30.363]   - Field: ‘label’
[18:04:30.363]   - Field: ‘local’
[18:04:30.363]   - Field: ‘owner’
[18:04:30.364]   - Field: ‘envir’
[18:04:30.364]   - Field: ‘workers’
[18:04:30.364]   - Field: ‘packages’
[18:04:30.364]   - Field: ‘gc’
[18:04:30.364]   - Field: ‘conditions’
[18:04:30.365]   - Field: ‘persistent’
[18:04:30.365]   - Field: ‘expr’
[18:04:30.365]   - Field: ‘uuid’
[18:04:30.365]   - Field: ‘seed’
[18:04:30.366]   - Field: ‘version’
[18:04:30.366]   - Field: ‘result’
[18:04:30.366]   - Field: ‘asynchronous’
[18:04:30.366]   - Field: ‘calls’
[18:04:30.366]   - Field: ‘globals’
[18:04:30.367]   - Field: ‘stdout’
[18:04:30.367]   - Field: ‘earlySignal’
[18:04:30.367]   - Field: ‘lazy’
[18:04:30.367]   - Field: ‘state’
[18:04:30.368] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:30.368] - Launch lazy future ...
[18:04:30.369] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:30.369] Packages needed by future strategies (n = 0): <none>
[18:04:30.370] {
[18:04:30.370]     {
[18:04:30.370]         {
[18:04:30.370]             ...future.startTime <- base::Sys.time()
[18:04:30.370]             {
[18:04:30.370]                 {
[18:04:30.370]                   {
[18:04:30.370]                     {
[18:04:30.370]                       {
[18:04:30.370]                         base::local({
[18:04:30.370]                           has_future <- base::requireNamespace("future", 
[18:04:30.370]                             quietly = TRUE)
[18:04:30.370]                           if (has_future) {
[18:04:30.370]                             ns <- base::getNamespace("future")
[18:04:30.370]                             version <- ns[[".package"]][["version"]]
[18:04:30.370]                             if (is.null(version)) 
[18:04:30.370]                               version <- utils::packageVersion("future")
[18:04:30.370]                           }
[18:04:30.370]                           else {
[18:04:30.370]                             version <- NULL
[18:04:30.370]                           }
[18:04:30.370]                           if (!has_future || version < "1.8.0") {
[18:04:30.370]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:30.370]                               "", base::R.version$version.string), 
[18:04:30.370]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:30.370]                                 base::R.version$platform, 8 * 
[18:04:30.370]                                   base::.Machine$sizeof.pointer), 
[18:04:30.370]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:30.370]                                 "release", "version")], collapse = " "), 
[18:04:30.370]                               hostname = base::Sys.info()[["nodename"]])
[18:04:30.370]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:30.370]                               info)
[18:04:30.370]                             info <- base::paste(info, collapse = "; ")
[18:04:30.370]                             if (!has_future) {
[18:04:30.370]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:30.370]                                 info)
[18:04:30.370]                             }
[18:04:30.370]                             else {
[18:04:30.370]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:30.370]                                 info, version)
[18:04:30.370]                             }
[18:04:30.370]                             base::stop(msg)
[18:04:30.370]                           }
[18:04:30.370]                         })
[18:04:30.370]                       }
[18:04:30.370]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:30.370]                       base::options(mc.cores = 1L)
[18:04:30.370]                     }
[18:04:30.370]                     base::local({
[18:04:30.370]                       for (pkg in c("stats", "datasets")) {
[18:04:30.370]                         base::loadNamespace(pkg)
[18:04:30.370]                         base::library(pkg, character.only = TRUE)
[18:04:30.370]                       }
[18:04:30.370]                     })
[18:04:30.370]                   }
[18:04:30.370]                   ...future.strategy.old <- future::plan("list")
[18:04:30.370]                   options(future.plan = NULL)
[18:04:30.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:30.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:30.370]                 }
[18:04:30.370]                 ...future.workdir <- getwd()
[18:04:30.370]             }
[18:04:30.370]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:30.370]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:30.370]         }
[18:04:30.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:30.370]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:30.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:30.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:30.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:30.370]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:30.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:30.370]             base::names(...future.oldOptions))
[18:04:30.370]     }
[18:04:30.370]     if (FALSE) {
[18:04:30.370]     }
[18:04:30.370]     else {
[18:04:30.370]         if (TRUE) {
[18:04:30.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:30.370]                 open = "w")
[18:04:30.370]         }
[18:04:30.370]         else {
[18:04:30.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:30.370]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:30.370]         }
[18:04:30.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:30.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:30.370]             base::sink(type = "output", split = FALSE)
[18:04:30.370]             base::close(...future.stdout)
[18:04:30.370]         }, add = TRUE)
[18:04:30.370]     }
[18:04:30.370]     ...future.frame <- base::sys.nframe()
[18:04:30.370]     ...future.conditions <- base::list()
[18:04:30.370]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:30.370]     if (FALSE) {
[18:04:30.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:30.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:30.370]     }
[18:04:30.370]     ...future.result <- base::tryCatch({
[18:04:30.370]         base::withCallingHandlers({
[18:04:30.370]             ...future.value <- base::withVisible(base::local({
[18:04:30.370]                 ...future.makeSendCondition <- base::local({
[18:04:30.370]                   sendCondition <- NULL
[18:04:30.370]                   function(frame = 1L) {
[18:04:30.370]                     if (is.function(sendCondition)) 
[18:04:30.370]                       return(sendCondition)
[18:04:30.370]                     ns <- getNamespace("parallel")
[18:04:30.370]                     if (exists("sendData", mode = "function", 
[18:04:30.370]                       envir = ns)) {
[18:04:30.370]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:30.370]                         envir = ns)
[18:04:30.370]                       envir <- sys.frame(frame)
[18:04:30.370]                       master <- NULL
[18:04:30.370]                       while (!identical(envir, .GlobalEnv) && 
[18:04:30.370]                         !identical(envir, emptyenv())) {
[18:04:30.370]                         if (exists("master", mode = "list", envir = envir, 
[18:04:30.370]                           inherits = FALSE)) {
[18:04:30.370]                           master <- get("master", mode = "list", 
[18:04:30.370]                             envir = envir, inherits = FALSE)
[18:04:30.370]                           if (inherits(master, c("SOCKnode", 
[18:04:30.370]                             "SOCK0node"))) {
[18:04:30.370]                             sendCondition <<- function(cond) {
[18:04:30.370]                               data <- list(type = "VALUE", value = cond, 
[18:04:30.370]                                 success = TRUE)
[18:04:30.370]                               parallel_sendData(master, data)
[18:04:30.370]                             }
[18:04:30.370]                             return(sendCondition)
[18:04:30.370]                           }
[18:04:30.370]                         }
[18:04:30.370]                         frame <- frame + 1L
[18:04:30.370]                         envir <- sys.frame(frame)
[18:04:30.370]                       }
[18:04:30.370]                     }
[18:04:30.370]                     sendCondition <<- function(cond) NULL
[18:04:30.370]                   }
[18:04:30.370]                 })
[18:04:30.370]                 withCallingHandlers({
[18:04:30.370]                   {
[18:04:30.370]                     lm(dist ~ speed + I(speed^2), data = cars)
[18:04:30.370]                   }
[18:04:30.370]                 }, immediateCondition = function(cond) {
[18:04:30.370]                   sendCondition <- ...future.makeSendCondition()
[18:04:30.370]                   sendCondition(cond)
[18:04:30.370]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.370]                   {
[18:04:30.370]                     inherits <- base::inherits
[18:04:30.370]                     invokeRestart <- base::invokeRestart
[18:04:30.370]                     is.null <- base::is.null
[18:04:30.370]                     muffled <- FALSE
[18:04:30.370]                     if (inherits(cond, "message")) {
[18:04:30.370]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:30.370]                       if (muffled) 
[18:04:30.370]                         invokeRestart("muffleMessage")
[18:04:30.370]                     }
[18:04:30.370]                     else if (inherits(cond, "warning")) {
[18:04:30.370]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:30.370]                       if (muffled) 
[18:04:30.370]                         invokeRestart("muffleWarning")
[18:04:30.370]                     }
[18:04:30.370]                     else if (inherits(cond, "condition")) {
[18:04:30.370]                       if (!is.null(pattern)) {
[18:04:30.370]                         computeRestarts <- base::computeRestarts
[18:04:30.370]                         grepl <- base::grepl
[18:04:30.370]                         restarts <- computeRestarts(cond)
[18:04:30.370]                         for (restart in restarts) {
[18:04:30.370]                           name <- restart$name
[18:04:30.370]                           if (is.null(name)) 
[18:04:30.370]                             next
[18:04:30.370]                           if (!grepl(pattern, name)) 
[18:04:30.370]                             next
[18:04:30.370]                           invokeRestart(restart)
[18:04:30.370]                           muffled <- TRUE
[18:04:30.370]                           break
[18:04:30.370]                         }
[18:04:30.370]                       }
[18:04:30.370]                     }
[18:04:30.370]                     invisible(muffled)
[18:04:30.370]                   }
[18:04:30.370]                   muffleCondition(cond)
[18:04:30.370]                 })
[18:04:30.370]             }))
[18:04:30.370]             future::FutureResult(value = ...future.value$value, 
[18:04:30.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:30.370]                   ...future.rng), globalenv = if (FALSE) 
[18:04:30.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:30.370]                     ...future.globalenv.names))
[18:04:30.370]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:30.370]         }, condition = base::local({
[18:04:30.370]             c <- base::c
[18:04:30.370]             inherits <- base::inherits
[18:04:30.370]             invokeRestart <- base::invokeRestart
[18:04:30.370]             length <- base::length
[18:04:30.370]             list <- base::list
[18:04:30.370]             seq.int <- base::seq.int
[18:04:30.370]             signalCondition <- base::signalCondition
[18:04:30.370]             sys.calls <- base::sys.calls
[18:04:30.370]             `[[` <- base::`[[`
[18:04:30.370]             `+` <- base::`+`
[18:04:30.370]             `<<-` <- base::`<<-`
[18:04:30.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:30.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:30.370]                   3L)]
[18:04:30.370]             }
[18:04:30.370]             function(cond) {
[18:04:30.370]                 is_error <- inherits(cond, "error")
[18:04:30.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:30.370]                   NULL)
[18:04:30.370]                 if (is_error) {
[18:04:30.370]                   sessionInformation <- function() {
[18:04:30.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:30.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:30.370]                       search = base::search(), system = base::Sys.info())
[18:04:30.370]                   }
[18:04:30.370]                   ...future.conditions[[length(...future.conditions) + 
[18:04:30.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:30.370]                     cond$call), session = sessionInformation(), 
[18:04:30.370]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:30.370]                   signalCondition(cond)
[18:04:30.370]                 }
[18:04:30.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:30.370]                 "immediateCondition"))) {
[18:04:30.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:30.370]                   ...future.conditions[[length(...future.conditions) + 
[18:04:30.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:30.370]                   if (TRUE && !signal) {
[18:04:30.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.370]                     {
[18:04:30.370]                       inherits <- base::inherits
[18:04:30.370]                       invokeRestart <- base::invokeRestart
[18:04:30.370]                       is.null <- base::is.null
[18:04:30.370]                       muffled <- FALSE
[18:04:30.370]                       if (inherits(cond, "message")) {
[18:04:30.370]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:30.370]                         if (muffled) 
[18:04:30.370]                           invokeRestart("muffleMessage")
[18:04:30.370]                       }
[18:04:30.370]                       else if (inherits(cond, "warning")) {
[18:04:30.370]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:30.370]                         if (muffled) 
[18:04:30.370]                           invokeRestart("muffleWarning")
[18:04:30.370]                       }
[18:04:30.370]                       else if (inherits(cond, "condition")) {
[18:04:30.370]                         if (!is.null(pattern)) {
[18:04:30.370]                           computeRestarts <- base::computeRestarts
[18:04:30.370]                           grepl <- base::grepl
[18:04:30.370]                           restarts <- computeRestarts(cond)
[18:04:30.370]                           for (restart in restarts) {
[18:04:30.370]                             name <- restart$name
[18:04:30.370]                             if (is.null(name)) 
[18:04:30.370]                               next
[18:04:30.370]                             if (!grepl(pattern, name)) 
[18:04:30.370]                               next
[18:04:30.370]                             invokeRestart(restart)
[18:04:30.370]                             muffled <- TRUE
[18:04:30.370]                             break
[18:04:30.370]                           }
[18:04:30.370]                         }
[18:04:30.370]                       }
[18:04:30.370]                       invisible(muffled)
[18:04:30.370]                     }
[18:04:30.370]                     muffleCondition(cond, pattern = "^muffle")
[18:04:30.370]                   }
[18:04:30.370]                 }
[18:04:30.370]                 else {
[18:04:30.370]                   if (TRUE) {
[18:04:30.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.370]                     {
[18:04:30.370]                       inherits <- base::inherits
[18:04:30.370]                       invokeRestart <- base::invokeRestart
[18:04:30.370]                       is.null <- base::is.null
[18:04:30.370]                       muffled <- FALSE
[18:04:30.370]                       if (inherits(cond, "message")) {
[18:04:30.370]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:30.370]                         if (muffled) 
[18:04:30.370]                           invokeRestart("muffleMessage")
[18:04:30.370]                       }
[18:04:30.370]                       else if (inherits(cond, "warning")) {
[18:04:30.370]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:30.370]                         if (muffled) 
[18:04:30.370]                           invokeRestart("muffleWarning")
[18:04:30.370]                       }
[18:04:30.370]                       else if (inherits(cond, "condition")) {
[18:04:30.370]                         if (!is.null(pattern)) {
[18:04:30.370]                           computeRestarts <- base::computeRestarts
[18:04:30.370]                           grepl <- base::grepl
[18:04:30.370]                           restarts <- computeRestarts(cond)
[18:04:30.370]                           for (restart in restarts) {
[18:04:30.370]                             name <- restart$name
[18:04:30.370]                             if (is.null(name)) 
[18:04:30.370]                               next
[18:04:30.370]                             if (!grepl(pattern, name)) 
[18:04:30.370]                               next
[18:04:30.370]                             invokeRestart(restart)
[18:04:30.370]                             muffled <- TRUE
[18:04:30.370]                             break
[18:04:30.370]                           }
[18:04:30.370]                         }
[18:04:30.370]                       }
[18:04:30.370]                       invisible(muffled)
[18:04:30.370]                     }
[18:04:30.370]                     muffleCondition(cond, pattern = "^muffle")
[18:04:30.370]                   }
[18:04:30.370]                 }
[18:04:30.370]             }
[18:04:30.370]         }))
[18:04:30.370]     }, error = function(ex) {
[18:04:30.370]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:30.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:30.370]                 ...future.rng), started = ...future.startTime, 
[18:04:30.370]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:30.370]             version = "1.8"), class = "FutureResult")
[18:04:30.370]     }, finally = {
[18:04:30.370]         if (!identical(...future.workdir, getwd())) 
[18:04:30.370]             setwd(...future.workdir)
[18:04:30.370]         {
[18:04:30.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:30.370]                 ...future.oldOptions$nwarnings <- NULL
[18:04:30.370]             }
[18:04:30.370]             base::options(...future.oldOptions)
[18:04:30.370]             if (.Platform$OS.type == "windows") {
[18:04:30.370]                 old_names <- names(...future.oldEnvVars)
[18:04:30.370]                 envs <- base::Sys.getenv()
[18:04:30.370]                 names <- names(envs)
[18:04:30.370]                 common <- intersect(names, old_names)
[18:04:30.370]                 added <- setdiff(names, old_names)
[18:04:30.370]                 removed <- setdiff(old_names, names)
[18:04:30.370]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:30.370]                   envs[common]]
[18:04:30.370]                 NAMES <- toupper(changed)
[18:04:30.370]                 args <- list()
[18:04:30.370]                 for (kk in seq_along(NAMES)) {
[18:04:30.370]                   name <- changed[[kk]]
[18:04:30.370]                   NAME <- NAMES[[kk]]
[18:04:30.370]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.370]                     next
[18:04:30.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:30.370]                 }
[18:04:30.370]                 NAMES <- toupper(added)
[18:04:30.370]                 for (kk in seq_along(NAMES)) {
[18:04:30.370]                   name <- added[[kk]]
[18:04:30.370]                   NAME <- NAMES[[kk]]
[18:04:30.370]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.370]                     next
[18:04:30.370]                   args[[name]] <- ""
[18:04:30.370]                 }
[18:04:30.370]                 NAMES <- toupper(removed)
[18:04:30.370]                 for (kk in seq_along(NAMES)) {
[18:04:30.370]                   name <- removed[[kk]]
[18:04:30.370]                   NAME <- NAMES[[kk]]
[18:04:30.370]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.370]                     next
[18:04:30.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:30.370]                 }
[18:04:30.370]                 if (length(args) > 0) 
[18:04:30.370]                   base::do.call(base::Sys.setenv, args = args)
[18:04:30.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:30.370]             }
[18:04:30.370]             else {
[18:04:30.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:30.370]             }
[18:04:30.370]             {
[18:04:30.370]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:30.370]                   0L) {
[18:04:30.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:30.370]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:30.370]                   base::options(opts)
[18:04:30.370]                 }
[18:04:30.370]                 {
[18:04:30.370]                   {
[18:04:30.370]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:30.370]                     NULL
[18:04:30.370]                   }
[18:04:30.370]                   options(future.plan = NULL)
[18:04:30.370]                   if (is.na(NA_character_)) 
[18:04:30.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:30.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:30.370]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:30.370]                     .init = FALSE)
[18:04:30.370]                 }
[18:04:30.370]             }
[18:04:30.370]         }
[18:04:30.370]     })
[18:04:30.370]     if (TRUE) {
[18:04:30.370]         base::sink(type = "output", split = FALSE)
[18:04:30.370]         if (TRUE) {
[18:04:30.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:30.370]         }
[18:04:30.370]         else {
[18:04:30.370]             ...future.result["stdout"] <- base::list(NULL)
[18:04:30.370]         }
[18:04:30.370]         base::close(...future.stdout)
[18:04:30.370]         ...future.stdout <- NULL
[18:04:30.370]     }
[18:04:30.370]     ...future.result$conditions <- ...future.conditions
[18:04:30.370]     ...future.result$finished <- base::Sys.time()
[18:04:30.370]     ...future.result
[18:04:30.370] }
[18:04:30.376] MultisessionFuture started
[18:04:30.376] - Launch lazy future ... done
[18:04:30.376] run() for ‘MultisessionFuture’ ... done
[18:04:30.377] result() for ClusterFuture ...
[18:04:30.377] receiveMessageFromWorker() for ClusterFuture ...
[18:04:30.377] - Validating connection of MultisessionFuture
[18:04:30.424] - received message: FutureResult
[18:04:30.424] - Received FutureResult
[18:04:30.424] - Erased future from FutureRegistry
[18:04:30.424] result() for ClusterFuture ...
[18:04:30.425] - result already collected: FutureResult
[18:04:30.425] result() for ClusterFuture ... done
[18:04:30.425] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:30.425] result() for ClusterFuture ... done
[18:04:30.425] result() for ClusterFuture ...
[18:04:30.426] - result already collected: FutureResult
[18:04:30.426] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[18:04:30.432] getGlobalsAndPackages() ...
[18:04:30.432] Searching for globals...
[18:04:30.435] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[18:04:30.436] Searching for globals ... DONE
[18:04:30.436] Resolving globals: FALSE
[18:04:30.437] 
[18:04:30.437] - packages: [2] ‘stats’, ‘datasets’
[18:04:30.437] getGlobalsAndPackages() ... DONE
[18:04:30.438] run() for ‘Future’ ...
[18:04:30.438] - state: ‘created’
[18:04:30.438] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:30.464] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:30.465] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:30.465]   - Field: ‘node’
[18:04:30.465]   - Field: ‘label’
[18:04:30.465]   - Field: ‘local’
[18:04:30.466]   - Field: ‘owner’
[18:04:30.466]   - Field: ‘envir’
[18:04:30.466]   - Field: ‘workers’
[18:04:30.466]   - Field: ‘packages’
[18:04:30.466]   - Field: ‘gc’
[18:04:30.467]   - Field: ‘conditions’
[18:04:30.467]   - Field: ‘persistent’
[18:04:30.467]   - Field: ‘expr’
[18:04:30.467]   - Field: ‘uuid’
[18:04:30.468]   - Field: ‘seed’
[18:04:30.468]   - Field: ‘version’
[18:04:30.468]   - Field: ‘result’
[18:04:30.468]   - Field: ‘asynchronous’
[18:04:30.468]   - Field: ‘calls’
[18:04:30.469]   - Field: ‘globals’
[18:04:30.469]   - Field: ‘stdout’
[18:04:30.469]   - Field: ‘earlySignal’
[18:04:30.469]   - Field: ‘lazy’
[18:04:30.469]   - Field: ‘state’
[18:04:30.470] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:30.470] - Launch lazy future ...
[18:04:30.470] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[18:04:30.471] Packages needed by future strategies (n = 0): <none>
[18:04:30.472] {
[18:04:30.472]     {
[18:04:30.472]         {
[18:04:30.472]             ...future.startTime <- base::Sys.time()
[18:04:30.472]             {
[18:04:30.472]                 {
[18:04:30.472]                   {
[18:04:30.472]                     {
[18:04:30.472]                       {
[18:04:30.472]                         base::local({
[18:04:30.472]                           has_future <- base::requireNamespace("future", 
[18:04:30.472]                             quietly = TRUE)
[18:04:30.472]                           if (has_future) {
[18:04:30.472]                             ns <- base::getNamespace("future")
[18:04:30.472]                             version <- ns[[".package"]][["version"]]
[18:04:30.472]                             if (is.null(version)) 
[18:04:30.472]                               version <- utils::packageVersion("future")
[18:04:30.472]                           }
[18:04:30.472]                           else {
[18:04:30.472]                             version <- NULL
[18:04:30.472]                           }
[18:04:30.472]                           if (!has_future || version < "1.8.0") {
[18:04:30.472]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:30.472]                               "", base::R.version$version.string), 
[18:04:30.472]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:30.472]                                 base::R.version$platform, 8 * 
[18:04:30.472]                                   base::.Machine$sizeof.pointer), 
[18:04:30.472]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:30.472]                                 "release", "version")], collapse = " "), 
[18:04:30.472]                               hostname = base::Sys.info()[["nodename"]])
[18:04:30.472]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:30.472]                               info)
[18:04:30.472]                             info <- base::paste(info, collapse = "; ")
[18:04:30.472]                             if (!has_future) {
[18:04:30.472]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:30.472]                                 info)
[18:04:30.472]                             }
[18:04:30.472]                             else {
[18:04:30.472]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:30.472]                                 info, version)
[18:04:30.472]                             }
[18:04:30.472]                             base::stop(msg)
[18:04:30.472]                           }
[18:04:30.472]                         })
[18:04:30.472]                       }
[18:04:30.472]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:30.472]                       base::options(mc.cores = 1L)
[18:04:30.472]                     }
[18:04:30.472]                     base::local({
[18:04:30.472]                       for (pkg in c("stats", "datasets")) {
[18:04:30.472]                         base::loadNamespace(pkg)
[18:04:30.472]                         base::library(pkg, character.only = TRUE)
[18:04:30.472]                       }
[18:04:30.472]                     })
[18:04:30.472]                   }
[18:04:30.472]                   ...future.strategy.old <- future::plan("list")
[18:04:30.472]                   options(future.plan = NULL)
[18:04:30.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:30.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:30.472]                 }
[18:04:30.472]                 ...future.workdir <- getwd()
[18:04:30.472]             }
[18:04:30.472]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:30.472]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:30.472]         }
[18:04:30.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:30.472]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:30.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:30.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:30.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:30.472]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:30.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:30.472]             base::names(...future.oldOptions))
[18:04:30.472]     }
[18:04:30.472]     if (FALSE) {
[18:04:30.472]     }
[18:04:30.472]     else {
[18:04:30.472]         if (TRUE) {
[18:04:30.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:30.472]                 open = "w")
[18:04:30.472]         }
[18:04:30.472]         else {
[18:04:30.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:30.472]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:30.472]         }
[18:04:30.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:30.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:30.472]             base::sink(type = "output", split = FALSE)
[18:04:30.472]             base::close(...future.stdout)
[18:04:30.472]         }, add = TRUE)
[18:04:30.472]     }
[18:04:30.472]     ...future.frame <- base::sys.nframe()
[18:04:30.472]     ...future.conditions <- base::list()
[18:04:30.472]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:30.472]     if (FALSE) {
[18:04:30.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:30.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:30.472]     }
[18:04:30.472]     ...future.result <- base::tryCatch({
[18:04:30.472]         base::withCallingHandlers({
[18:04:30.472]             ...future.value <- base::withVisible(base::local({
[18:04:30.472]                 ...future.makeSendCondition <- base::local({
[18:04:30.472]                   sendCondition <- NULL
[18:04:30.472]                   function(frame = 1L) {
[18:04:30.472]                     if (is.function(sendCondition)) 
[18:04:30.472]                       return(sendCondition)
[18:04:30.472]                     ns <- getNamespace("parallel")
[18:04:30.472]                     if (exists("sendData", mode = "function", 
[18:04:30.472]                       envir = ns)) {
[18:04:30.472]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:30.472]                         envir = ns)
[18:04:30.472]                       envir <- sys.frame(frame)
[18:04:30.472]                       master <- NULL
[18:04:30.472]                       while (!identical(envir, .GlobalEnv) && 
[18:04:30.472]                         !identical(envir, emptyenv())) {
[18:04:30.472]                         if (exists("master", mode = "list", envir = envir, 
[18:04:30.472]                           inherits = FALSE)) {
[18:04:30.472]                           master <- get("master", mode = "list", 
[18:04:30.472]                             envir = envir, inherits = FALSE)
[18:04:30.472]                           if (inherits(master, c("SOCKnode", 
[18:04:30.472]                             "SOCK0node"))) {
[18:04:30.472]                             sendCondition <<- function(cond) {
[18:04:30.472]                               data <- list(type = "VALUE", value = cond, 
[18:04:30.472]                                 success = TRUE)
[18:04:30.472]                               parallel_sendData(master, data)
[18:04:30.472]                             }
[18:04:30.472]                             return(sendCondition)
[18:04:30.472]                           }
[18:04:30.472]                         }
[18:04:30.472]                         frame <- frame + 1L
[18:04:30.472]                         envir <- sys.frame(frame)
[18:04:30.472]                       }
[18:04:30.472]                     }
[18:04:30.472]                     sendCondition <<- function(cond) NULL
[18:04:30.472]                   }
[18:04:30.472]                 })
[18:04:30.472]                 withCallingHandlers({
[18:04:30.472]                   {
[18:04:30.472]                     lm(dist ~ poly(speed, 2), data = cars)
[18:04:30.472]                   }
[18:04:30.472]                 }, immediateCondition = function(cond) {
[18:04:30.472]                   sendCondition <- ...future.makeSendCondition()
[18:04:30.472]                   sendCondition(cond)
[18:04:30.472]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.472]                   {
[18:04:30.472]                     inherits <- base::inherits
[18:04:30.472]                     invokeRestart <- base::invokeRestart
[18:04:30.472]                     is.null <- base::is.null
[18:04:30.472]                     muffled <- FALSE
[18:04:30.472]                     if (inherits(cond, "message")) {
[18:04:30.472]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:30.472]                       if (muffled) 
[18:04:30.472]                         invokeRestart("muffleMessage")
[18:04:30.472]                     }
[18:04:30.472]                     else if (inherits(cond, "warning")) {
[18:04:30.472]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:30.472]                       if (muffled) 
[18:04:30.472]                         invokeRestart("muffleWarning")
[18:04:30.472]                     }
[18:04:30.472]                     else if (inherits(cond, "condition")) {
[18:04:30.472]                       if (!is.null(pattern)) {
[18:04:30.472]                         computeRestarts <- base::computeRestarts
[18:04:30.472]                         grepl <- base::grepl
[18:04:30.472]                         restarts <- computeRestarts(cond)
[18:04:30.472]                         for (restart in restarts) {
[18:04:30.472]                           name <- restart$name
[18:04:30.472]                           if (is.null(name)) 
[18:04:30.472]                             next
[18:04:30.472]                           if (!grepl(pattern, name)) 
[18:04:30.472]                             next
[18:04:30.472]                           invokeRestart(restart)
[18:04:30.472]                           muffled <- TRUE
[18:04:30.472]                           break
[18:04:30.472]                         }
[18:04:30.472]                       }
[18:04:30.472]                     }
[18:04:30.472]                     invisible(muffled)
[18:04:30.472]                   }
[18:04:30.472]                   muffleCondition(cond)
[18:04:30.472]                 })
[18:04:30.472]             }))
[18:04:30.472]             future::FutureResult(value = ...future.value$value, 
[18:04:30.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:30.472]                   ...future.rng), globalenv = if (FALSE) 
[18:04:30.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:30.472]                     ...future.globalenv.names))
[18:04:30.472]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:30.472]         }, condition = base::local({
[18:04:30.472]             c <- base::c
[18:04:30.472]             inherits <- base::inherits
[18:04:30.472]             invokeRestart <- base::invokeRestart
[18:04:30.472]             length <- base::length
[18:04:30.472]             list <- base::list
[18:04:30.472]             seq.int <- base::seq.int
[18:04:30.472]             signalCondition <- base::signalCondition
[18:04:30.472]             sys.calls <- base::sys.calls
[18:04:30.472]             `[[` <- base::`[[`
[18:04:30.472]             `+` <- base::`+`
[18:04:30.472]             `<<-` <- base::`<<-`
[18:04:30.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:30.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:30.472]                   3L)]
[18:04:30.472]             }
[18:04:30.472]             function(cond) {
[18:04:30.472]                 is_error <- inherits(cond, "error")
[18:04:30.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:30.472]                   NULL)
[18:04:30.472]                 if (is_error) {
[18:04:30.472]                   sessionInformation <- function() {
[18:04:30.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:30.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:30.472]                       search = base::search(), system = base::Sys.info())
[18:04:30.472]                   }
[18:04:30.472]                   ...future.conditions[[length(...future.conditions) + 
[18:04:30.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:30.472]                     cond$call), session = sessionInformation(), 
[18:04:30.472]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:30.472]                   signalCondition(cond)
[18:04:30.472]                 }
[18:04:30.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:30.472]                 "immediateCondition"))) {
[18:04:30.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:30.472]                   ...future.conditions[[length(...future.conditions) + 
[18:04:30.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:30.472]                   if (TRUE && !signal) {
[18:04:30.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.472]                     {
[18:04:30.472]                       inherits <- base::inherits
[18:04:30.472]                       invokeRestart <- base::invokeRestart
[18:04:30.472]                       is.null <- base::is.null
[18:04:30.472]                       muffled <- FALSE
[18:04:30.472]                       if (inherits(cond, "message")) {
[18:04:30.472]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:30.472]                         if (muffled) 
[18:04:30.472]                           invokeRestart("muffleMessage")
[18:04:30.472]                       }
[18:04:30.472]                       else if (inherits(cond, "warning")) {
[18:04:30.472]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:30.472]                         if (muffled) 
[18:04:30.472]                           invokeRestart("muffleWarning")
[18:04:30.472]                       }
[18:04:30.472]                       else if (inherits(cond, "condition")) {
[18:04:30.472]                         if (!is.null(pattern)) {
[18:04:30.472]                           computeRestarts <- base::computeRestarts
[18:04:30.472]                           grepl <- base::grepl
[18:04:30.472]                           restarts <- computeRestarts(cond)
[18:04:30.472]                           for (restart in restarts) {
[18:04:30.472]                             name <- restart$name
[18:04:30.472]                             if (is.null(name)) 
[18:04:30.472]                               next
[18:04:30.472]                             if (!grepl(pattern, name)) 
[18:04:30.472]                               next
[18:04:30.472]                             invokeRestart(restart)
[18:04:30.472]                             muffled <- TRUE
[18:04:30.472]                             break
[18:04:30.472]                           }
[18:04:30.472]                         }
[18:04:30.472]                       }
[18:04:30.472]                       invisible(muffled)
[18:04:30.472]                     }
[18:04:30.472]                     muffleCondition(cond, pattern = "^muffle")
[18:04:30.472]                   }
[18:04:30.472]                 }
[18:04:30.472]                 else {
[18:04:30.472]                   if (TRUE) {
[18:04:30.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.472]                     {
[18:04:30.472]                       inherits <- base::inherits
[18:04:30.472]                       invokeRestart <- base::invokeRestart
[18:04:30.472]                       is.null <- base::is.null
[18:04:30.472]                       muffled <- FALSE
[18:04:30.472]                       if (inherits(cond, "message")) {
[18:04:30.472]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:30.472]                         if (muffled) 
[18:04:30.472]                           invokeRestart("muffleMessage")
[18:04:30.472]                       }
[18:04:30.472]                       else if (inherits(cond, "warning")) {
[18:04:30.472]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:30.472]                         if (muffled) 
[18:04:30.472]                           invokeRestart("muffleWarning")
[18:04:30.472]                       }
[18:04:30.472]                       else if (inherits(cond, "condition")) {
[18:04:30.472]                         if (!is.null(pattern)) {
[18:04:30.472]                           computeRestarts <- base::computeRestarts
[18:04:30.472]                           grepl <- base::grepl
[18:04:30.472]                           restarts <- computeRestarts(cond)
[18:04:30.472]                           for (restart in restarts) {
[18:04:30.472]                             name <- restart$name
[18:04:30.472]                             if (is.null(name)) 
[18:04:30.472]                               next
[18:04:30.472]                             if (!grepl(pattern, name)) 
[18:04:30.472]                               next
[18:04:30.472]                             invokeRestart(restart)
[18:04:30.472]                             muffled <- TRUE
[18:04:30.472]                             break
[18:04:30.472]                           }
[18:04:30.472]                         }
[18:04:30.472]                       }
[18:04:30.472]                       invisible(muffled)
[18:04:30.472]                     }
[18:04:30.472]                     muffleCondition(cond, pattern = "^muffle")
[18:04:30.472]                   }
[18:04:30.472]                 }
[18:04:30.472]             }
[18:04:30.472]         }))
[18:04:30.472]     }, error = function(ex) {
[18:04:30.472]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:30.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:30.472]                 ...future.rng), started = ...future.startTime, 
[18:04:30.472]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:30.472]             version = "1.8"), class = "FutureResult")
[18:04:30.472]     }, finally = {
[18:04:30.472]         if (!identical(...future.workdir, getwd())) 
[18:04:30.472]             setwd(...future.workdir)
[18:04:30.472]         {
[18:04:30.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:30.472]                 ...future.oldOptions$nwarnings <- NULL
[18:04:30.472]             }
[18:04:30.472]             base::options(...future.oldOptions)
[18:04:30.472]             if (.Platform$OS.type == "windows") {
[18:04:30.472]                 old_names <- names(...future.oldEnvVars)
[18:04:30.472]                 envs <- base::Sys.getenv()
[18:04:30.472]                 names <- names(envs)
[18:04:30.472]                 common <- intersect(names, old_names)
[18:04:30.472]                 added <- setdiff(names, old_names)
[18:04:30.472]                 removed <- setdiff(old_names, names)
[18:04:30.472]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:30.472]                   envs[common]]
[18:04:30.472]                 NAMES <- toupper(changed)
[18:04:30.472]                 args <- list()
[18:04:30.472]                 for (kk in seq_along(NAMES)) {
[18:04:30.472]                   name <- changed[[kk]]
[18:04:30.472]                   NAME <- NAMES[[kk]]
[18:04:30.472]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.472]                     next
[18:04:30.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:30.472]                 }
[18:04:30.472]                 NAMES <- toupper(added)
[18:04:30.472]                 for (kk in seq_along(NAMES)) {
[18:04:30.472]                   name <- added[[kk]]
[18:04:30.472]                   NAME <- NAMES[[kk]]
[18:04:30.472]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.472]                     next
[18:04:30.472]                   args[[name]] <- ""
[18:04:30.472]                 }
[18:04:30.472]                 NAMES <- toupper(removed)
[18:04:30.472]                 for (kk in seq_along(NAMES)) {
[18:04:30.472]                   name <- removed[[kk]]
[18:04:30.472]                   NAME <- NAMES[[kk]]
[18:04:30.472]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.472]                     next
[18:04:30.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:30.472]                 }
[18:04:30.472]                 if (length(args) > 0) 
[18:04:30.472]                   base::do.call(base::Sys.setenv, args = args)
[18:04:30.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:30.472]             }
[18:04:30.472]             else {
[18:04:30.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:30.472]             }
[18:04:30.472]             {
[18:04:30.472]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:30.472]                   0L) {
[18:04:30.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:30.472]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:30.472]                   base::options(opts)
[18:04:30.472]                 }
[18:04:30.472]                 {
[18:04:30.472]                   {
[18:04:30.472]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:30.472]                     NULL
[18:04:30.472]                   }
[18:04:30.472]                   options(future.plan = NULL)
[18:04:30.472]                   if (is.na(NA_character_)) 
[18:04:30.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:30.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:30.472]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:30.472]                     .init = FALSE)
[18:04:30.472]                 }
[18:04:30.472]             }
[18:04:30.472]         }
[18:04:30.472]     })
[18:04:30.472]     if (TRUE) {
[18:04:30.472]         base::sink(type = "output", split = FALSE)
[18:04:30.472]         if (TRUE) {
[18:04:30.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:30.472]         }
[18:04:30.472]         else {
[18:04:30.472]             ...future.result["stdout"] <- base::list(NULL)
[18:04:30.472]         }
[18:04:30.472]         base::close(...future.stdout)
[18:04:30.472]         ...future.stdout <- NULL
[18:04:30.472]     }
[18:04:30.472]     ...future.result$conditions <- ...future.conditions
[18:04:30.472]     ...future.result$finished <- base::Sys.time()
[18:04:30.472]     ...future.result
[18:04:30.472] }
[18:04:30.478] MultisessionFuture started
[18:04:30.479] - Launch lazy future ... done
[18:04:30.479] run() for ‘MultisessionFuture’ ... done
[18:04:30.479] result() for ClusterFuture ...
[18:04:30.479] receiveMessageFromWorker() for ClusterFuture ...
[18:04:30.480] - Validating connection of MultisessionFuture
[18:04:30.526] - received message: FutureResult
[18:04:30.526] - Received FutureResult
[18:04:30.526] - Erased future from FutureRegistry
[18:04:30.527] result() for ClusterFuture ...
[18:04:30.527] - result already collected: FutureResult
[18:04:30.527] result() for ClusterFuture ... done
[18:04:30.527] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:30.528] result() for ClusterFuture ... done
[18:04:30.528] result() for ClusterFuture ...
[18:04:30.528] - result already collected: FutureResult
[18:04:30.528] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[18:04:30.532] getGlobalsAndPackages() ...
[18:04:30.533] Searching for globals...
[18:04:30.542] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[18:04:30.542] Searching for globals ... DONE
[18:04:30.543] Resolving globals: FALSE
[18:04:30.544] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[18:04:30.545] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[18:04:30.545] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[18:04:30.546] 
[18:04:30.546] getGlobalsAndPackages() ... DONE
[18:04:30.546] run() for ‘Future’ ...
[18:04:30.547] - state: ‘created’
[18:04:30.547] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:30.572] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:30.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:30.572]   - Field: ‘node’
[18:04:30.572]   - Field: ‘label’
[18:04:30.573]   - Field: ‘local’
[18:04:30.573]   - Field: ‘owner’
[18:04:30.573]   - Field: ‘envir’
[18:04:30.573]   - Field: ‘workers’
[18:04:30.573]   - Field: ‘packages’
[18:04:30.574]   - Field: ‘gc’
[18:04:30.574]   - Field: ‘conditions’
[18:04:30.574]   - Field: ‘persistent’
[18:04:30.574]   - Field: ‘expr’
[18:04:30.574]   - Field: ‘uuid’
[18:04:30.575]   - Field: ‘seed’
[18:04:30.575]   - Field: ‘version’
[18:04:30.575]   - Field: ‘result’
[18:04:30.575]   - Field: ‘asynchronous’
[18:04:30.575]   - Field: ‘calls’
[18:04:30.576]   - Field: ‘globals’
[18:04:30.576]   - Field: ‘stdout’
[18:04:30.576]   - Field: ‘earlySignal’
[18:04:30.576]   - Field: ‘lazy’
[18:04:30.576]   - Field: ‘state’
[18:04:30.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:30.577] - Launch lazy future ...
[18:04:30.577] Packages needed by the future expression (n = 0): <none>
[18:04:30.578] Packages needed by future strategies (n = 0): <none>
[18:04:30.579] {
[18:04:30.579]     {
[18:04:30.579]         {
[18:04:30.579]             ...future.startTime <- base::Sys.time()
[18:04:30.579]             {
[18:04:30.579]                 {
[18:04:30.579]                   {
[18:04:30.579]                     {
[18:04:30.579]                       base::local({
[18:04:30.579]                         has_future <- base::requireNamespace("future", 
[18:04:30.579]                           quietly = TRUE)
[18:04:30.579]                         if (has_future) {
[18:04:30.579]                           ns <- base::getNamespace("future")
[18:04:30.579]                           version <- ns[[".package"]][["version"]]
[18:04:30.579]                           if (is.null(version)) 
[18:04:30.579]                             version <- utils::packageVersion("future")
[18:04:30.579]                         }
[18:04:30.579]                         else {
[18:04:30.579]                           version <- NULL
[18:04:30.579]                         }
[18:04:30.579]                         if (!has_future || version < "1.8.0") {
[18:04:30.579]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:30.579]                             "", base::R.version$version.string), 
[18:04:30.579]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:30.579]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:30.579]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:30.579]                               "release", "version")], collapse = " "), 
[18:04:30.579]                             hostname = base::Sys.info()[["nodename"]])
[18:04:30.579]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:30.579]                             info)
[18:04:30.579]                           info <- base::paste(info, collapse = "; ")
[18:04:30.579]                           if (!has_future) {
[18:04:30.579]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:30.579]                               info)
[18:04:30.579]                           }
[18:04:30.579]                           else {
[18:04:30.579]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:30.579]                               info, version)
[18:04:30.579]                           }
[18:04:30.579]                           base::stop(msg)
[18:04:30.579]                         }
[18:04:30.579]                       })
[18:04:30.579]                     }
[18:04:30.579]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:30.579]                     base::options(mc.cores = 1L)
[18:04:30.579]                   }
[18:04:30.579]                   ...future.strategy.old <- future::plan("list")
[18:04:30.579]                   options(future.plan = NULL)
[18:04:30.579]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:30.579]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:30.579]                 }
[18:04:30.579]                 ...future.workdir <- getwd()
[18:04:30.579]             }
[18:04:30.579]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:30.579]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:30.579]         }
[18:04:30.579]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:30.579]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:30.579]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:30.579]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:30.579]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:30.579]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:30.579]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:30.579]             base::names(...future.oldOptions))
[18:04:30.579]     }
[18:04:30.579]     if (FALSE) {
[18:04:30.579]     }
[18:04:30.579]     else {
[18:04:30.579]         if (TRUE) {
[18:04:30.579]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:30.579]                 open = "w")
[18:04:30.579]         }
[18:04:30.579]         else {
[18:04:30.579]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:30.579]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:30.579]         }
[18:04:30.579]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:30.579]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:30.579]             base::sink(type = "output", split = FALSE)
[18:04:30.579]             base::close(...future.stdout)
[18:04:30.579]         }, add = TRUE)
[18:04:30.579]     }
[18:04:30.579]     ...future.frame <- base::sys.nframe()
[18:04:30.579]     ...future.conditions <- base::list()
[18:04:30.579]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:30.579]     if (FALSE) {
[18:04:30.579]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:30.579]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:30.579]     }
[18:04:30.579]     ...future.result <- base::tryCatch({
[18:04:30.579]         base::withCallingHandlers({
[18:04:30.579]             ...future.value <- base::withVisible(base::local({
[18:04:30.579]                 ...future.makeSendCondition <- base::local({
[18:04:30.579]                   sendCondition <- NULL
[18:04:30.579]                   function(frame = 1L) {
[18:04:30.579]                     if (is.function(sendCondition)) 
[18:04:30.579]                       return(sendCondition)
[18:04:30.579]                     ns <- getNamespace("parallel")
[18:04:30.579]                     if (exists("sendData", mode = "function", 
[18:04:30.579]                       envir = ns)) {
[18:04:30.579]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:30.579]                         envir = ns)
[18:04:30.579]                       envir <- sys.frame(frame)
[18:04:30.579]                       master <- NULL
[18:04:30.579]                       while (!identical(envir, .GlobalEnv) && 
[18:04:30.579]                         !identical(envir, emptyenv())) {
[18:04:30.579]                         if (exists("master", mode = "list", envir = envir, 
[18:04:30.579]                           inherits = FALSE)) {
[18:04:30.579]                           master <- get("master", mode = "list", 
[18:04:30.579]                             envir = envir, inherits = FALSE)
[18:04:30.579]                           if (inherits(master, c("SOCKnode", 
[18:04:30.579]                             "SOCK0node"))) {
[18:04:30.579]                             sendCondition <<- function(cond) {
[18:04:30.579]                               data <- list(type = "VALUE", value = cond, 
[18:04:30.579]                                 success = TRUE)
[18:04:30.579]                               parallel_sendData(master, data)
[18:04:30.579]                             }
[18:04:30.579]                             return(sendCondition)
[18:04:30.579]                           }
[18:04:30.579]                         }
[18:04:30.579]                         frame <- frame + 1L
[18:04:30.579]                         envir <- sys.frame(frame)
[18:04:30.579]                       }
[18:04:30.579]                     }
[18:04:30.579]                     sendCondition <<- function(cond) NULL
[18:04:30.579]                   }
[18:04:30.579]                 })
[18:04:30.579]                 withCallingHandlers({
[18:04:30.579]                   {
[18:04:30.579]                     outer_function(1L)
[18:04:30.579]                   }
[18:04:30.579]                 }, immediateCondition = function(cond) {
[18:04:30.579]                   sendCondition <- ...future.makeSendCondition()
[18:04:30.579]                   sendCondition(cond)
[18:04:30.579]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.579]                   {
[18:04:30.579]                     inherits <- base::inherits
[18:04:30.579]                     invokeRestart <- base::invokeRestart
[18:04:30.579]                     is.null <- base::is.null
[18:04:30.579]                     muffled <- FALSE
[18:04:30.579]                     if (inherits(cond, "message")) {
[18:04:30.579]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:30.579]                       if (muffled) 
[18:04:30.579]                         invokeRestart("muffleMessage")
[18:04:30.579]                     }
[18:04:30.579]                     else if (inherits(cond, "warning")) {
[18:04:30.579]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:30.579]                       if (muffled) 
[18:04:30.579]                         invokeRestart("muffleWarning")
[18:04:30.579]                     }
[18:04:30.579]                     else if (inherits(cond, "condition")) {
[18:04:30.579]                       if (!is.null(pattern)) {
[18:04:30.579]                         computeRestarts <- base::computeRestarts
[18:04:30.579]                         grepl <- base::grepl
[18:04:30.579]                         restarts <- computeRestarts(cond)
[18:04:30.579]                         for (restart in restarts) {
[18:04:30.579]                           name <- restart$name
[18:04:30.579]                           if (is.null(name)) 
[18:04:30.579]                             next
[18:04:30.579]                           if (!grepl(pattern, name)) 
[18:04:30.579]                             next
[18:04:30.579]                           invokeRestart(restart)
[18:04:30.579]                           muffled <- TRUE
[18:04:30.579]                           break
[18:04:30.579]                         }
[18:04:30.579]                       }
[18:04:30.579]                     }
[18:04:30.579]                     invisible(muffled)
[18:04:30.579]                   }
[18:04:30.579]                   muffleCondition(cond)
[18:04:30.579]                 })
[18:04:30.579]             }))
[18:04:30.579]             future::FutureResult(value = ...future.value$value, 
[18:04:30.579]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:30.579]                   ...future.rng), globalenv = if (FALSE) 
[18:04:30.579]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:30.579]                     ...future.globalenv.names))
[18:04:30.579]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:30.579]         }, condition = base::local({
[18:04:30.579]             c <- base::c
[18:04:30.579]             inherits <- base::inherits
[18:04:30.579]             invokeRestart <- base::invokeRestart
[18:04:30.579]             length <- base::length
[18:04:30.579]             list <- base::list
[18:04:30.579]             seq.int <- base::seq.int
[18:04:30.579]             signalCondition <- base::signalCondition
[18:04:30.579]             sys.calls <- base::sys.calls
[18:04:30.579]             `[[` <- base::`[[`
[18:04:30.579]             `+` <- base::`+`
[18:04:30.579]             `<<-` <- base::`<<-`
[18:04:30.579]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:30.579]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:30.579]                   3L)]
[18:04:30.579]             }
[18:04:30.579]             function(cond) {
[18:04:30.579]                 is_error <- inherits(cond, "error")
[18:04:30.579]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:30.579]                   NULL)
[18:04:30.579]                 if (is_error) {
[18:04:30.579]                   sessionInformation <- function() {
[18:04:30.579]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:30.579]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:30.579]                       search = base::search(), system = base::Sys.info())
[18:04:30.579]                   }
[18:04:30.579]                   ...future.conditions[[length(...future.conditions) + 
[18:04:30.579]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:30.579]                     cond$call), session = sessionInformation(), 
[18:04:30.579]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:30.579]                   signalCondition(cond)
[18:04:30.579]                 }
[18:04:30.579]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:30.579]                 "immediateCondition"))) {
[18:04:30.579]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:30.579]                   ...future.conditions[[length(...future.conditions) + 
[18:04:30.579]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:30.579]                   if (TRUE && !signal) {
[18:04:30.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.579]                     {
[18:04:30.579]                       inherits <- base::inherits
[18:04:30.579]                       invokeRestart <- base::invokeRestart
[18:04:30.579]                       is.null <- base::is.null
[18:04:30.579]                       muffled <- FALSE
[18:04:30.579]                       if (inherits(cond, "message")) {
[18:04:30.579]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:30.579]                         if (muffled) 
[18:04:30.579]                           invokeRestart("muffleMessage")
[18:04:30.579]                       }
[18:04:30.579]                       else if (inherits(cond, "warning")) {
[18:04:30.579]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:30.579]                         if (muffled) 
[18:04:30.579]                           invokeRestart("muffleWarning")
[18:04:30.579]                       }
[18:04:30.579]                       else if (inherits(cond, "condition")) {
[18:04:30.579]                         if (!is.null(pattern)) {
[18:04:30.579]                           computeRestarts <- base::computeRestarts
[18:04:30.579]                           grepl <- base::grepl
[18:04:30.579]                           restarts <- computeRestarts(cond)
[18:04:30.579]                           for (restart in restarts) {
[18:04:30.579]                             name <- restart$name
[18:04:30.579]                             if (is.null(name)) 
[18:04:30.579]                               next
[18:04:30.579]                             if (!grepl(pattern, name)) 
[18:04:30.579]                               next
[18:04:30.579]                             invokeRestart(restart)
[18:04:30.579]                             muffled <- TRUE
[18:04:30.579]                             break
[18:04:30.579]                           }
[18:04:30.579]                         }
[18:04:30.579]                       }
[18:04:30.579]                       invisible(muffled)
[18:04:30.579]                     }
[18:04:30.579]                     muffleCondition(cond, pattern = "^muffle")
[18:04:30.579]                   }
[18:04:30.579]                 }
[18:04:30.579]                 else {
[18:04:30.579]                   if (TRUE) {
[18:04:30.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.579]                     {
[18:04:30.579]                       inherits <- base::inherits
[18:04:30.579]                       invokeRestart <- base::invokeRestart
[18:04:30.579]                       is.null <- base::is.null
[18:04:30.579]                       muffled <- FALSE
[18:04:30.579]                       if (inherits(cond, "message")) {
[18:04:30.579]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:30.579]                         if (muffled) 
[18:04:30.579]                           invokeRestart("muffleMessage")
[18:04:30.579]                       }
[18:04:30.579]                       else if (inherits(cond, "warning")) {
[18:04:30.579]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:30.579]                         if (muffled) 
[18:04:30.579]                           invokeRestart("muffleWarning")
[18:04:30.579]                       }
[18:04:30.579]                       else if (inherits(cond, "condition")) {
[18:04:30.579]                         if (!is.null(pattern)) {
[18:04:30.579]                           computeRestarts <- base::computeRestarts
[18:04:30.579]                           grepl <- base::grepl
[18:04:30.579]                           restarts <- computeRestarts(cond)
[18:04:30.579]                           for (restart in restarts) {
[18:04:30.579]                             name <- restart$name
[18:04:30.579]                             if (is.null(name)) 
[18:04:30.579]                               next
[18:04:30.579]                             if (!grepl(pattern, name)) 
[18:04:30.579]                               next
[18:04:30.579]                             invokeRestart(restart)
[18:04:30.579]                             muffled <- TRUE
[18:04:30.579]                             break
[18:04:30.579]                           }
[18:04:30.579]                         }
[18:04:30.579]                       }
[18:04:30.579]                       invisible(muffled)
[18:04:30.579]                     }
[18:04:30.579]                     muffleCondition(cond, pattern = "^muffle")
[18:04:30.579]                   }
[18:04:30.579]                 }
[18:04:30.579]             }
[18:04:30.579]         }))
[18:04:30.579]     }, error = function(ex) {
[18:04:30.579]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:30.579]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:30.579]                 ...future.rng), started = ...future.startTime, 
[18:04:30.579]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:30.579]             version = "1.8"), class = "FutureResult")
[18:04:30.579]     }, finally = {
[18:04:30.579]         if (!identical(...future.workdir, getwd())) 
[18:04:30.579]             setwd(...future.workdir)
[18:04:30.579]         {
[18:04:30.579]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:30.579]                 ...future.oldOptions$nwarnings <- NULL
[18:04:30.579]             }
[18:04:30.579]             base::options(...future.oldOptions)
[18:04:30.579]             if (.Platform$OS.type == "windows") {
[18:04:30.579]                 old_names <- names(...future.oldEnvVars)
[18:04:30.579]                 envs <- base::Sys.getenv()
[18:04:30.579]                 names <- names(envs)
[18:04:30.579]                 common <- intersect(names, old_names)
[18:04:30.579]                 added <- setdiff(names, old_names)
[18:04:30.579]                 removed <- setdiff(old_names, names)
[18:04:30.579]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:30.579]                   envs[common]]
[18:04:30.579]                 NAMES <- toupper(changed)
[18:04:30.579]                 args <- list()
[18:04:30.579]                 for (kk in seq_along(NAMES)) {
[18:04:30.579]                   name <- changed[[kk]]
[18:04:30.579]                   NAME <- NAMES[[kk]]
[18:04:30.579]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.579]                     next
[18:04:30.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:30.579]                 }
[18:04:30.579]                 NAMES <- toupper(added)
[18:04:30.579]                 for (kk in seq_along(NAMES)) {
[18:04:30.579]                   name <- added[[kk]]
[18:04:30.579]                   NAME <- NAMES[[kk]]
[18:04:30.579]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.579]                     next
[18:04:30.579]                   args[[name]] <- ""
[18:04:30.579]                 }
[18:04:30.579]                 NAMES <- toupper(removed)
[18:04:30.579]                 for (kk in seq_along(NAMES)) {
[18:04:30.579]                   name <- removed[[kk]]
[18:04:30.579]                   NAME <- NAMES[[kk]]
[18:04:30.579]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.579]                     next
[18:04:30.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:30.579]                 }
[18:04:30.579]                 if (length(args) > 0) 
[18:04:30.579]                   base::do.call(base::Sys.setenv, args = args)
[18:04:30.579]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:30.579]             }
[18:04:30.579]             else {
[18:04:30.579]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:30.579]             }
[18:04:30.579]             {
[18:04:30.579]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:30.579]                   0L) {
[18:04:30.579]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:30.579]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:30.579]                   base::options(opts)
[18:04:30.579]                 }
[18:04:30.579]                 {
[18:04:30.579]                   {
[18:04:30.579]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:30.579]                     NULL
[18:04:30.579]                   }
[18:04:30.579]                   options(future.plan = NULL)
[18:04:30.579]                   if (is.na(NA_character_)) 
[18:04:30.579]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:30.579]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:30.579]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:30.579]                     .init = FALSE)
[18:04:30.579]                 }
[18:04:30.579]             }
[18:04:30.579]         }
[18:04:30.579]     })
[18:04:30.579]     if (TRUE) {
[18:04:30.579]         base::sink(type = "output", split = FALSE)
[18:04:30.579]         if (TRUE) {
[18:04:30.579]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:30.579]         }
[18:04:30.579]         else {
[18:04:30.579]             ...future.result["stdout"] <- base::list(NULL)
[18:04:30.579]         }
[18:04:30.579]         base::close(...future.stdout)
[18:04:30.579]         ...future.stdout <- NULL
[18:04:30.579]     }
[18:04:30.579]     ...future.result$conditions <- ...future.conditions
[18:04:30.579]     ...future.result$finished <- base::Sys.time()
[18:04:30.579]     ...future.result
[18:04:30.579] }
[18:04:30.587] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[18:04:30.587] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[18:04:30.588] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[18:04:30.588] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[18:04:30.589] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[18:04:30.590] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[18:04:30.590] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[18:04:30.591] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[18:04:30.592] MultisessionFuture started
[18:04:30.592] - Launch lazy future ... done
[18:04:30.592] run() for ‘MultisessionFuture’ ... done
[18:04:30.592] result() for ClusterFuture ...
[18:04:30.593] receiveMessageFromWorker() for ClusterFuture ...
[18:04:30.593] - Validating connection of MultisessionFuture
[18:04:30.650] - received message: FutureResult
[18:04:30.650] - Received FutureResult
[18:04:30.650] - Erased future from FutureRegistry
[18:04:30.651] result() for ClusterFuture ...
[18:04:30.651] - result already collected: FutureResult
[18:04:30.651] result() for ClusterFuture ... done
[18:04:30.651] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:30.651] result() for ClusterFuture ... done
[18:04:30.652] result() for ClusterFuture ...
[18:04:30.652] - result already collected: FutureResult
[18:04:30.652] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[18:04:30.654] getGlobalsAndPackages() ...
[18:04:30.655] Searching for globals...
[18:04:30.663] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[18:04:30.664] Searching for globals ... DONE
[18:04:30.664] Resolving globals: FALSE
[18:04:30.665] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[18:04:30.666] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[18:04:30.667] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[18:04:30.667] 
[18:04:30.667] getGlobalsAndPackages() ... DONE
[18:04:30.668] run() for ‘Future’ ...
[18:04:30.668] - state: ‘created’
[18:04:30.668] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:30.693] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:30.693] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:30.694]   - Field: ‘node’
[18:04:30.694]   - Field: ‘label’
[18:04:30.694]   - Field: ‘local’
[18:04:30.694]   - Field: ‘owner’
[18:04:30.695]   - Field: ‘envir’
[18:04:30.695]   - Field: ‘workers’
[18:04:30.695]   - Field: ‘packages’
[18:04:30.695]   - Field: ‘gc’
[18:04:30.695]   - Field: ‘conditions’
[18:04:30.696]   - Field: ‘persistent’
[18:04:30.696]   - Field: ‘expr’
[18:04:30.696]   - Field: ‘uuid’
[18:04:30.696]   - Field: ‘seed’
[18:04:30.696]   - Field: ‘version’
[18:04:30.697]   - Field: ‘result’
[18:04:30.697]   - Field: ‘asynchronous’
[18:04:30.697]   - Field: ‘calls’
[18:04:30.697]   - Field: ‘globals’
[18:04:30.697]   - Field: ‘stdout’
[18:04:30.698]   - Field: ‘earlySignal’
[18:04:30.698]   - Field: ‘lazy’
[18:04:30.698]   - Field: ‘state’
[18:04:30.698] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:30.699] - Launch lazy future ...
[18:04:30.699] Packages needed by the future expression (n = 0): <none>
[18:04:30.699] Packages needed by future strategies (n = 0): <none>
[18:04:30.700] {
[18:04:30.700]     {
[18:04:30.700]         {
[18:04:30.700]             ...future.startTime <- base::Sys.time()
[18:04:30.700]             {
[18:04:30.700]                 {
[18:04:30.700]                   {
[18:04:30.700]                     {
[18:04:30.700]                       base::local({
[18:04:30.700]                         has_future <- base::requireNamespace("future", 
[18:04:30.700]                           quietly = TRUE)
[18:04:30.700]                         if (has_future) {
[18:04:30.700]                           ns <- base::getNamespace("future")
[18:04:30.700]                           version <- ns[[".package"]][["version"]]
[18:04:30.700]                           if (is.null(version)) 
[18:04:30.700]                             version <- utils::packageVersion("future")
[18:04:30.700]                         }
[18:04:30.700]                         else {
[18:04:30.700]                           version <- NULL
[18:04:30.700]                         }
[18:04:30.700]                         if (!has_future || version < "1.8.0") {
[18:04:30.700]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:30.700]                             "", base::R.version$version.string), 
[18:04:30.700]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:30.700]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:30.700]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:30.700]                               "release", "version")], collapse = " "), 
[18:04:30.700]                             hostname = base::Sys.info()[["nodename"]])
[18:04:30.700]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:30.700]                             info)
[18:04:30.700]                           info <- base::paste(info, collapse = "; ")
[18:04:30.700]                           if (!has_future) {
[18:04:30.700]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:30.700]                               info)
[18:04:30.700]                           }
[18:04:30.700]                           else {
[18:04:30.700]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:30.700]                               info, version)
[18:04:30.700]                           }
[18:04:30.700]                           base::stop(msg)
[18:04:30.700]                         }
[18:04:30.700]                       })
[18:04:30.700]                     }
[18:04:30.700]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:30.700]                     base::options(mc.cores = 1L)
[18:04:30.700]                   }
[18:04:30.700]                   ...future.strategy.old <- future::plan("list")
[18:04:30.700]                   options(future.plan = NULL)
[18:04:30.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:30.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:30.700]                 }
[18:04:30.700]                 ...future.workdir <- getwd()
[18:04:30.700]             }
[18:04:30.700]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:30.700]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:30.700]         }
[18:04:30.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:30.700]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:30.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:30.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:30.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:30.700]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:30.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:30.700]             base::names(...future.oldOptions))
[18:04:30.700]     }
[18:04:30.700]     if (FALSE) {
[18:04:30.700]     }
[18:04:30.700]     else {
[18:04:30.700]         if (TRUE) {
[18:04:30.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:30.700]                 open = "w")
[18:04:30.700]         }
[18:04:30.700]         else {
[18:04:30.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:30.700]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:30.700]         }
[18:04:30.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:30.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:30.700]             base::sink(type = "output", split = FALSE)
[18:04:30.700]             base::close(...future.stdout)
[18:04:30.700]         }, add = TRUE)
[18:04:30.700]     }
[18:04:30.700]     ...future.frame <- base::sys.nframe()
[18:04:30.700]     ...future.conditions <- base::list()
[18:04:30.700]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:30.700]     if (FALSE) {
[18:04:30.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:30.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:30.700]     }
[18:04:30.700]     ...future.result <- base::tryCatch({
[18:04:30.700]         base::withCallingHandlers({
[18:04:30.700]             ...future.value <- base::withVisible(base::local({
[18:04:30.700]                 ...future.makeSendCondition <- base::local({
[18:04:30.700]                   sendCondition <- NULL
[18:04:30.700]                   function(frame = 1L) {
[18:04:30.700]                     if (is.function(sendCondition)) 
[18:04:30.700]                       return(sendCondition)
[18:04:30.700]                     ns <- getNamespace("parallel")
[18:04:30.700]                     if (exists("sendData", mode = "function", 
[18:04:30.700]                       envir = ns)) {
[18:04:30.700]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:30.700]                         envir = ns)
[18:04:30.700]                       envir <- sys.frame(frame)
[18:04:30.700]                       master <- NULL
[18:04:30.700]                       while (!identical(envir, .GlobalEnv) && 
[18:04:30.700]                         !identical(envir, emptyenv())) {
[18:04:30.700]                         if (exists("master", mode = "list", envir = envir, 
[18:04:30.700]                           inherits = FALSE)) {
[18:04:30.700]                           master <- get("master", mode = "list", 
[18:04:30.700]                             envir = envir, inherits = FALSE)
[18:04:30.700]                           if (inherits(master, c("SOCKnode", 
[18:04:30.700]                             "SOCK0node"))) {
[18:04:30.700]                             sendCondition <<- function(cond) {
[18:04:30.700]                               data <- list(type = "VALUE", value = cond, 
[18:04:30.700]                                 success = TRUE)
[18:04:30.700]                               parallel_sendData(master, data)
[18:04:30.700]                             }
[18:04:30.700]                             return(sendCondition)
[18:04:30.700]                           }
[18:04:30.700]                         }
[18:04:30.700]                         frame <- frame + 1L
[18:04:30.700]                         envir <- sys.frame(frame)
[18:04:30.700]                       }
[18:04:30.700]                     }
[18:04:30.700]                     sendCondition <<- function(cond) NULL
[18:04:30.700]                   }
[18:04:30.700]                 })
[18:04:30.700]                 withCallingHandlers({
[18:04:30.700]                   {
[18:04:30.700]                     outer_function(1L)
[18:04:30.700]                   }
[18:04:30.700]                 }, immediateCondition = function(cond) {
[18:04:30.700]                   sendCondition <- ...future.makeSendCondition()
[18:04:30.700]                   sendCondition(cond)
[18:04:30.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.700]                   {
[18:04:30.700]                     inherits <- base::inherits
[18:04:30.700]                     invokeRestart <- base::invokeRestart
[18:04:30.700]                     is.null <- base::is.null
[18:04:30.700]                     muffled <- FALSE
[18:04:30.700]                     if (inherits(cond, "message")) {
[18:04:30.700]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:30.700]                       if (muffled) 
[18:04:30.700]                         invokeRestart("muffleMessage")
[18:04:30.700]                     }
[18:04:30.700]                     else if (inherits(cond, "warning")) {
[18:04:30.700]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:30.700]                       if (muffled) 
[18:04:30.700]                         invokeRestart("muffleWarning")
[18:04:30.700]                     }
[18:04:30.700]                     else if (inherits(cond, "condition")) {
[18:04:30.700]                       if (!is.null(pattern)) {
[18:04:30.700]                         computeRestarts <- base::computeRestarts
[18:04:30.700]                         grepl <- base::grepl
[18:04:30.700]                         restarts <- computeRestarts(cond)
[18:04:30.700]                         for (restart in restarts) {
[18:04:30.700]                           name <- restart$name
[18:04:30.700]                           if (is.null(name)) 
[18:04:30.700]                             next
[18:04:30.700]                           if (!grepl(pattern, name)) 
[18:04:30.700]                             next
[18:04:30.700]                           invokeRestart(restart)
[18:04:30.700]                           muffled <- TRUE
[18:04:30.700]                           break
[18:04:30.700]                         }
[18:04:30.700]                       }
[18:04:30.700]                     }
[18:04:30.700]                     invisible(muffled)
[18:04:30.700]                   }
[18:04:30.700]                   muffleCondition(cond)
[18:04:30.700]                 })
[18:04:30.700]             }))
[18:04:30.700]             future::FutureResult(value = ...future.value$value, 
[18:04:30.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:30.700]                   ...future.rng), globalenv = if (FALSE) 
[18:04:30.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:30.700]                     ...future.globalenv.names))
[18:04:30.700]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:30.700]         }, condition = base::local({
[18:04:30.700]             c <- base::c
[18:04:30.700]             inherits <- base::inherits
[18:04:30.700]             invokeRestart <- base::invokeRestart
[18:04:30.700]             length <- base::length
[18:04:30.700]             list <- base::list
[18:04:30.700]             seq.int <- base::seq.int
[18:04:30.700]             signalCondition <- base::signalCondition
[18:04:30.700]             sys.calls <- base::sys.calls
[18:04:30.700]             `[[` <- base::`[[`
[18:04:30.700]             `+` <- base::`+`
[18:04:30.700]             `<<-` <- base::`<<-`
[18:04:30.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:30.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:30.700]                   3L)]
[18:04:30.700]             }
[18:04:30.700]             function(cond) {
[18:04:30.700]                 is_error <- inherits(cond, "error")
[18:04:30.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:30.700]                   NULL)
[18:04:30.700]                 if (is_error) {
[18:04:30.700]                   sessionInformation <- function() {
[18:04:30.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:30.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:30.700]                       search = base::search(), system = base::Sys.info())
[18:04:30.700]                   }
[18:04:30.700]                   ...future.conditions[[length(...future.conditions) + 
[18:04:30.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:30.700]                     cond$call), session = sessionInformation(), 
[18:04:30.700]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:30.700]                   signalCondition(cond)
[18:04:30.700]                 }
[18:04:30.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:30.700]                 "immediateCondition"))) {
[18:04:30.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:30.700]                   ...future.conditions[[length(...future.conditions) + 
[18:04:30.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:30.700]                   if (TRUE && !signal) {
[18:04:30.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.700]                     {
[18:04:30.700]                       inherits <- base::inherits
[18:04:30.700]                       invokeRestart <- base::invokeRestart
[18:04:30.700]                       is.null <- base::is.null
[18:04:30.700]                       muffled <- FALSE
[18:04:30.700]                       if (inherits(cond, "message")) {
[18:04:30.700]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:30.700]                         if (muffled) 
[18:04:30.700]                           invokeRestart("muffleMessage")
[18:04:30.700]                       }
[18:04:30.700]                       else if (inherits(cond, "warning")) {
[18:04:30.700]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:30.700]                         if (muffled) 
[18:04:30.700]                           invokeRestart("muffleWarning")
[18:04:30.700]                       }
[18:04:30.700]                       else if (inherits(cond, "condition")) {
[18:04:30.700]                         if (!is.null(pattern)) {
[18:04:30.700]                           computeRestarts <- base::computeRestarts
[18:04:30.700]                           grepl <- base::grepl
[18:04:30.700]                           restarts <- computeRestarts(cond)
[18:04:30.700]                           for (restart in restarts) {
[18:04:30.700]                             name <- restart$name
[18:04:30.700]                             if (is.null(name)) 
[18:04:30.700]                               next
[18:04:30.700]                             if (!grepl(pattern, name)) 
[18:04:30.700]                               next
[18:04:30.700]                             invokeRestart(restart)
[18:04:30.700]                             muffled <- TRUE
[18:04:30.700]                             break
[18:04:30.700]                           }
[18:04:30.700]                         }
[18:04:30.700]                       }
[18:04:30.700]                       invisible(muffled)
[18:04:30.700]                     }
[18:04:30.700]                     muffleCondition(cond, pattern = "^muffle")
[18:04:30.700]                   }
[18:04:30.700]                 }
[18:04:30.700]                 else {
[18:04:30.700]                   if (TRUE) {
[18:04:30.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:30.700]                     {
[18:04:30.700]                       inherits <- base::inherits
[18:04:30.700]                       invokeRestart <- base::invokeRestart
[18:04:30.700]                       is.null <- base::is.null
[18:04:30.700]                       muffled <- FALSE
[18:04:30.700]                       if (inherits(cond, "message")) {
[18:04:30.700]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:30.700]                         if (muffled) 
[18:04:30.700]                           invokeRestart("muffleMessage")
[18:04:30.700]                       }
[18:04:30.700]                       else if (inherits(cond, "warning")) {
[18:04:30.700]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:30.700]                         if (muffled) 
[18:04:30.700]                           invokeRestart("muffleWarning")
[18:04:30.700]                       }
[18:04:30.700]                       else if (inherits(cond, "condition")) {
[18:04:30.700]                         if (!is.null(pattern)) {
[18:04:30.700]                           computeRestarts <- base::computeRestarts
[18:04:30.700]                           grepl <- base::grepl
[18:04:30.700]                           restarts <- computeRestarts(cond)
[18:04:30.700]                           for (restart in restarts) {
[18:04:30.700]                             name <- restart$name
[18:04:30.700]                             if (is.null(name)) 
[18:04:30.700]                               next
[18:04:30.700]                             if (!grepl(pattern, name)) 
[18:04:30.700]                               next
[18:04:30.700]                             invokeRestart(restart)
[18:04:30.700]                             muffled <- TRUE
[18:04:30.700]                             break
[18:04:30.700]                           }
[18:04:30.700]                         }
[18:04:30.700]                       }
[18:04:30.700]                       invisible(muffled)
[18:04:30.700]                     }
[18:04:30.700]                     muffleCondition(cond, pattern = "^muffle")
[18:04:30.700]                   }
[18:04:30.700]                 }
[18:04:30.700]             }
[18:04:30.700]         }))
[18:04:30.700]     }, error = function(ex) {
[18:04:30.700]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:30.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:30.700]                 ...future.rng), started = ...future.startTime, 
[18:04:30.700]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:30.700]             version = "1.8"), class = "FutureResult")
[18:04:30.700]     }, finally = {
[18:04:30.700]         if (!identical(...future.workdir, getwd())) 
[18:04:30.700]             setwd(...future.workdir)
[18:04:30.700]         {
[18:04:30.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:30.700]                 ...future.oldOptions$nwarnings <- NULL
[18:04:30.700]             }
[18:04:30.700]             base::options(...future.oldOptions)
[18:04:30.700]             if (.Platform$OS.type == "windows") {
[18:04:30.700]                 old_names <- names(...future.oldEnvVars)
[18:04:30.700]                 envs <- base::Sys.getenv()
[18:04:30.700]                 names <- names(envs)
[18:04:30.700]                 common <- intersect(names, old_names)
[18:04:30.700]                 added <- setdiff(names, old_names)
[18:04:30.700]                 removed <- setdiff(old_names, names)
[18:04:30.700]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:30.700]                   envs[common]]
[18:04:30.700]                 NAMES <- toupper(changed)
[18:04:30.700]                 args <- list()
[18:04:30.700]                 for (kk in seq_along(NAMES)) {
[18:04:30.700]                   name <- changed[[kk]]
[18:04:30.700]                   NAME <- NAMES[[kk]]
[18:04:30.700]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.700]                     next
[18:04:30.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:30.700]                 }
[18:04:30.700]                 NAMES <- toupper(added)
[18:04:30.700]                 for (kk in seq_along(NAMES)) {
[18:04:30.700]                   name <- added[[kk]]
[18:04:30.700]                   NAME <- NAMES[[kk]]
[18:04:30.700]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.700]                     next
[18:04:30.700]                   args[[name]] <- ""
[18:04:30.700]                 }
[18:04:30.700]                 NAMES <- toupper(removed)
[18:04:30.700]                 for (kk in seq_along(NAMES)) {
[18:04:30.700]                   name <- removed[[kk]]
[18:04:30.700]                   NAME <- NAMES[[kk]]
[18:04:30.700]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:30.700]                     next
[18:04:30.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:30.700]                 }
[18:04:30.700]                 if (length(args) > 0) 
[18:04:30.700]                   base::do.call(base::Sys.setenv, args = args)
[18:04:30.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:30.700]             }
[18:04:30.700]             else {
[18:04:30.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:30.700]             }
[18:04:30.700]             {
[18:04:30.700]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:30.700]                   0L) {
[18:04:30.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:30.700]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:30.700]                   base::options(opts)
[18:04:30.700]                 }
[18:04:30.700]                 {
[18:04:30.700]                   {
[18:04:30.700]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:30.700]                     NULL
[18:04:30.700]                   }
[18:04:30.700]                   options(future.plan = NULL)
[18:04:30.700]                   if (is.na(NA_character_)) 
[18:04:30.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:30.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:30.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:30.700]                     .init = FALSE)
[18:04:30.700]                 }
[18:04:30.700]             }
[18:04:30.700]         }
[18:04:30.700]     })
[18:04:30.700]     if (TRUE) {
[18:04:30.700]         base::sink(type = "output", split = FALSE)
[18:04:30.700]         if (TRUE) {
[18:04:30.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:30.700]         }
[18:04:30.700]         else {
[18:04:30.700]             ...future.result["stdout"] <- base::list(NULL)
[18:04:30.700]         }
[18:04:30.700]         base::close(...future.stdout)
[18:04:30.700]         ...future.stdout <- NULL
[18:04:30.700]     }
[18:04:30.700]     ...future.result$conditions <- ...future.conditions
[18:04:30.700]     ...future.result$finished <- base::Sys.time()
[18:04:30.700]     ...future.result
[18:04:30.700] }
[18:04:30.705] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[18:04:30.706] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[18:04:30.707] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[18:04:30.707] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[18:04:30.708] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[18:04:30.709] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[18:04:30.709] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[18:04:30.710] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[18:04:30.711] MultisessionFuture started
[18:04:30.711] - Launch lazy future ... done
[18:04:30.711] run() for ‘MultisessionFuture’ ... done
[18:04:30.711] result() for ClusterFuture ...
[18:04:30.712] receiveMessageFromWorker() for ClusterFuture ...
[18:04:30.713] - Validating connection of MultisessionFuture
[18:04:30.755] - received message: FutureResult
[18:04:30.755] - Received FutureResult
[18:04:30.755] - Erased future from FutureRegistry
[18:04:30.756] result() for ClusterFuture ...
[18:04:30.756] - result already collected: FutureResult
[18:04:30.756] result() for ClusterFuture ... done
[18:04:30.756] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:30.756] result() for ClusterFuture ... done
[18:04:30.757] result() for ClusterFuture ...
[18:04:30.757] - result already collected: FutureResult
[18:04:30.757] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[18:04:30.761] plan(): Setting new future strategy stack:
[18:04:30.761] List of future strategies:
[18:04:30.761] 1. FutureStrategy:
[18:04:30.761]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:30.761]    - tweaked: FALSE
[18:04:30.761]    - call: future::plan(oplan)
[18:04:30.763] plan(): nbrOfWorkers() = 1
> 
