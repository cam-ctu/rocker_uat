
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:47:02.086] plan(): Setting new future strategy stack:
[17:47:02.087] List of future strategies:
[17:47:02.087] 1. sequential:
[17:47:02.087]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.087]    - tweaked: FALSE
[17:47:02.087]    - call: future::plan("sequential")
[17:47:02.098] plan(): nbrOfWorkers() = 1
> 
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Globals - subassignments ...")
*** Globals - subassignments ...
> 
> message("*** Globals - subassignments w/ x$a <- value ...")
*** Globals - subassignments w/ x$a <- value ...
> 
> ## Truth:
> x <- x0 <- list()
> y0 <- list(a = 1)
> str(list(x = x, y0 = y0))
List of 2
 $ x : list()
 $ y0:List of 1
  ..$ a: num 1
> 
> y <- local({
+   x$a <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x[["a"]] <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x["a"] <- list(1)
+   x
+ })
> stopifnot(identical(y, y0))
> 
> stopifnot(identical(x, list()))
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Same with forced lazy evaluation
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     } %lazy% TRUE
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## 'x' is _not_ a global variable here
+     x <- list()
+     y %<-% {
+       x <- list(b = 2)
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, list(b = 2, a = 1)))
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x[["a"]] <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+     
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x["a"] <- list(1)
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     name <- "a"
+     y %<-% {
+       x[name] <- list(1)
+       x
+     }
+     rm(list = c("x", "name"))
+     print(y)
+     stopifnot(identical(y, y0))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[17:47:02.166] plan(): Setting new future strategy stack:
[17:47:02.166] List of future strategies:
[17:47:02.166] 1. sequential:
[17:47:02.166]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.166]    - tweaked: FALSE
[17:47:02.166]    - call: plan(strategy)
[17:47:02.179] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.180] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.180] Searching for globals...
[17:47:02.187] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.187] Searching for globals ... DONE
[17:47:02.187] Resolving globals: TRUE
[17:47:02.187] Resolving any globals that are futures ...
[17:47:02.188] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.188] Resolving any globals that are futures ... DONE
[17:47:02.188] Resolving futures part of globals (recursively) ...
[17:47:02.189] resolve() on list ...
[17:47:02.189]  recursive: 99
[17:47:02.189]  length: 1
[17:47:02.189]  elements: ‘x’
[17:47:02.190]  length: 0 (resolved future 1)
[17:47:02.190] resolve() on list ... DONE
[17:47:02.190] - globals: [1] ‘x’
[17:47:02.190] Resolving futures part of globals (recursively) ... DONE
[17:47:02.190] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.191] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.191] - globals: [1] ‘x’
[17:47:02.191] 
[17:47:02.191] getGlobalsAndPackages() ... DONE
[17:47:02.192] run() for ‘Future’ ...
[17:47:02.192] - state: ‘created’
[17:47:02.192] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:02.192] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:02.192] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:02.193]   - Field: ‘label’
[17:47:02.193]   - Field: ‘local’
[17:47:02.193]   - Field: ‘owner’
[17:47:02.193]   - Field: ‘envir’
[17:47:02.193]   - Field: ‘packages’
[17:47:02.193]   - Field: ‘gc’
[17:47:02.193]   - Field: ‘conditions’
[17:47:02.193]   - Field: ‘expr’
[17:47:02.193]   - Field: ‘uuid’
[17:47:02.193]   - Field: ‘seed’
[17:47:02.193]   - Field: ‘version’
[17:47:02.194]   - Field: ‘result’
[17:47:02.194]   - Field: ‘asynchronous’
[17:47:02.194]   - Field: ‘calls’
[17:47:02.194]   - Field: ‘globals’
[17:47:02.194]   - Field: ‘stdout’
[17:47:02.194]   - Field: ‘earlySignal’
[17:47:02.194]   - Field: ‘lazy’
[17:47:02.194]   - Field: ‘state’
[17:47:02.194] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:02.194] - Launch lazy future ...
[17:47:02.195] Packages needed by the future expression (n = 0): <none>
[17:47:02.195] Packages needed by future strategies (n = 0): <none>
[17:47:02.196] {
[17:47:02.196]     {
[17:47:02.196]         {
[17:47:02.196]             ...future.startTime <- base::Sys.time()
[17:47:02.196]             {
[17:47:02.196]                 {
[17:47:02.196]                   {
[17:47:02.196]                     base::local({
[17:47:02.196]                       has_future <- base::requireNamespace("future", 
[17:47:02.196]                         quietly = TRUE)
[17:47:02.196]                       if (has_future) {
[17:47:02.196]                         ns <- base::getNamespace("future")
[17:47:02.196]                         version <- ns[[".package"]][["version"]]
[17:47:02.196]                         if (is.null(version)) 
[17:47:02.196]                           version <- utils::packageVersion("future")
[17:47:02.196]                       }
[17:47:02.196]                       else {
[17:47:02.196]                         version <- NULL
[17:47:02.196]                       }
[17:47:02.196]                       if (!has_future || version < "1.8.0") {
[17:47:02.196]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.196]                           "", base::R.version$version.string), 
[17:47:02.196]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:02.196]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.196]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.196]                             "release", "version")], collapse = " "), 
[17:47:02.196]                           hostname = base::Sys.info()[["nodename"]])
[17:47:02.196]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.196]                           info)
[17:47:02.196]                         info <- base::paste(info, collapse = "; ")
[17:47:02.196]                         if (!has_future) {
[17:47:02.196]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.196]                             info)
[17:47:02.196]                         }
[17:47:02.196]                         else {
[17:47:02.196]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.196]                             info, version)
[17:47:02.196]                         }
[17:47:02.196]                         base::stop(msg)
[17:47:02.196]                       }
[17:47:02.196]                     })
[17:47:02.196]                   }
[17:47:02.196]                   ...future.strategy.old <- future::plan("list")
[17:47:02.196]                   options(future.plan = NULL)
[17:47:02.196]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.196]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.196]                 }
[17:47:02.196]                 ...future.workdir <- getwd()
[17:47:02.196]             }
[17:47:02.196]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.196]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.196]         }
[17:47:02.196]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.196]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.196]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.196]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.196]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.196]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.196]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.196]             base::names(...future.oldOptions))
[17:47:02.196]     }
[17:47:02.196]     if (FALSE) {
[17:47:02.196]     }
[17:47:02.196]     else {
[17:47:02.196]         if (TRUE) {
[17:47:02.196]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.196]                 open = "w")
[17:47:02.196]         }
[17:47:02.196]         else {
[17:47:02.196]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.196]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.196]         }
[17:47:02.196]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.196]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.196]             base::sink(type = "output", split = FALSE)
[17:47:02.196]             base::close(...future.stdout)
[17:47:02.196]         }, add = TRUE)
[17:47:02.196]     }
[17:47:02.196]     ...future.frame <- base::sys.nframe()
[17:47:02.196]     ...future.conditions <- base::list()
[17:47:02.196]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.196]     if (FALSE) {
[17:47:02.196]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.196]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.196]     }
[17:47:02.196]     ...future.result <- base::tryCatch({
[17:47:02.196]         base::withCallingHandlers({
[17:47:02.196]             ...future.value <- base::withVisible(base::local({
[17:47:02.196]                 x$a <- 1
[17:47:02.196]                 x
[17:47:02.196]             }))
[17:47:02.196]             future::FutureResult(value = ...future.value$value, 
[17:47:02.196]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.196]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.196]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.196]                     ...future.globalenv.names))
[17:47:02.196]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.196]         }, condition = base::local({
[17:47:02.196]             c <- base::c
[17:47:02.196]             inherits <- base::inherits
[17:47:02.196]             invokeRestart <- base::invokeRestart
[17:47:02.196]             length <- base::length
[17:47:02.196]             list <- base::list
[17:47:02.196]             seq.int <- base::seq.int
[17:47:02.196]             signalCondition <- base::signalCondition
[17:47:02.196]             sys.calls <- base::sys.calls
[17:47:02.196]             `[[` <- base::`[[`
[17:47:02.196]             `+` <- base::`+`
[17:47:02.196]             `<<-` <- base::`<<-`
[17:47:02.196]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.196]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.196]                   3L)]
[17:47:02.196]             }
[17:47:02.196]             function(cond) {
[17:47:02.196]                 is_error <- inherits(cond, "error")
[17:47:02.196]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.196]                   NULL)
[17:47:02.196]                 if (is_error) {
[17:47:02.196]                   sessionInformation <- function() {
[17:47:02.196]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.196]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.196]                       search = base::search(), system = base::Sys.info())
[17:47:02.196]                   }
[17:47:02.196]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.196]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.196]                     cond$call), session = sessionInformation(), 
[17:47:02.196]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.196]                   signalCondition(cond)
[17:47:02.196]                 }
[17:47:02.196]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.196]                 "immediateCondition"))) {
[17:47:02.196]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.196]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.196]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.196]                   if (TRUE && !signal) {
[17:47:02.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.196]                     {
[17:47:02.196]                       inherits <- base::inherits
[17:47:02.196]                       invokeRestart <- base::invokeRestart
[17:47:02.196]                       is.null <- base::is.null
[17:47:02.196]                       muffled <- FALSE
[17:47:02.196]                       if (inherits(cond, "message")) {
[17:47:02.196]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.196]                         if (muffled) 
[17:47:02.196]                           invokeRestart("muffleMessage")
[17:47:02.196]                       }
[17:47:02.196]                       else if (inherits(cond, "warning")) {
[17:47:02.196]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.196]                         if (muffled) 
[17:47:02.196]                           invokeRestart("muffleWarning")
[17:47:02.196]                       }
[17:47:02.196]                       else if (inherits(cond, "condition")) {
[17:47:02.196]                         if (!is.null(pattern)) {
[17:47:02.196]                           computeRestarts <- base::computeRestarts
[17:47:02.196]                           grepl <- base::grepl
[17:47:02.196]                           restarts <- computeRestarts(cond)
[17:47:02.196]                           for (restart in restarts) {
[17:47:02.196]                             name <- restart$name
[17:47:02.196]                             if (is.null(name)) 
[17:47:02.196]                               next
[17:47:02.196]                             if (!grepl(pattern, name)) 
[17:47:02.196]                               next
[17:47:02.196]                             invokeRestart(restart)
[17:47:02.196]                             muffled <- TRUE
[17:47:02.196]                             break
[17:47:02.196]                           }
[17:47:02.196]                         }
[17:47:02.196]                       }
[17:47:02.196]                       invisible(muffled)
[17:47:02.196]                     }
[17:47:02.196]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.196]                   }
[17:47:02.196]                 }
[17:47:02.196]                 else {
[17:47:02.196]                   if (TRUE) {
[17:47:02.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.196]                     {
[17:47:02.196]                       inherits <- base::inherits
[17:47:02.196]                       invokeRestart <- base::invokeRestart
[17:47:02.196]                       is.null <- base::is.null
[17:47:02.196]                       muffled <- FALSE
[17:47:02.196]                       if (inherits(cond, "message")) {
[17:47:02.196]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.196]                         if (muffled) 
[17:47:02.196]                           invokeRestart("muffleMessage")
[17:47:02.196]                       }
[17:47:02.196]                       else if (inherits(cond, "warning")) {
[17:47:02.196]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.196]                         if (muffled) 
[17:47:02.196]                           invokeRestart("muffleWarning")
[17:47:02.196]                       }
[17:47:02.196]                       else if (inherits(cond, "condition")) {
[17:47:02.196]                         if (!is.null(pattern)) {
[17:47:02.196]                           computeRestarts <- base::computeRestarts
[17:47:02.196]                           grepl <- base::grepl
[17:47:02.196]                           restarts <- computeRestarts(cond)
[17:47:02.196]                           for (restart in restarts) {
[17:47:02.196]                             name <- restart$name
[17:47:02.196]                             if (is.null(name)) 
[17:47:02.196]                               next
[17:47:02.196]                             if (!grepl(pattern, name)) 
[17:47:02.196]                               next
[17:47:02.196]                             invokeRestart(restart)
[17:47:02.196]                             muffled <- TRUE
[17:47:02.196]                             break
[17:47:02.196]                           }
[17:47:02.196]                         }
[17:47:02.196]                       }
[17:47:02.196]                       invisible(muffled)
[17:47:02.196]                     }
[17:47:02.196]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.196]                   }
[17:47:02.196]                 }
[17:47:02.196]             }
[17:47:02.196]         }))
[17:47:02.196]     }, error = function(ex) {
[17:47:02.196]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.196]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.196]                 ...future.rng), started = ...future.startTime, 
[17:47:02.196]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.196]             version = "1.8"), class = "FutureResult")
[17:47:02.196]     }, finally = {
[17:47:02.196]         if (!identical(...future.workdir, getwd())) 
[17:47:02.196]             setwd(...future.workdir)
[17:47:02.196]         {
[17:47:02.196]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.196]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.196]             }
[17:47:02.196]             base::options(...future.oldOptions)
[17:47:02.196]             if (.Platform$OS.type == "windows") {
[17:47:02.196]                 old_names <- names(...future.oldEnvVars)
[17:47:02.196]                 envs <- base::Sys.getenv()
[17:47:02.196]                 names <- names(envs)
[17:47:02.196]                 common <- intersect(names, old_names)
[17:47:02.196]                 added <- setdiff(names, old_names)
[17:47:02.196]                 removed <- setdiff(old_names, names)
[17:47:02.196]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.196]                   envs[common]]
[17:47:02.196]                 NAMES <- toupper(changed)
[17:47:02.196]                 args <- list()
[17:47:02.196]                 for (kk in seq_along(NAMES)) {
[17:47:02.196]                   name <- changed[[kk]]
[17:47:02.196]                   NAME <- NAMES[[kk]]
[17:47:02.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.196]                     next
[17:47:02.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.196]                 }
[17:47:02.196]                 NAMES <- toupper(added)
[17:47:02.196]                 for (kk in seq_along(NAMES)) {
[17:47:02.196]                   name <- added[[kk]]
[17:47:02.196]                   NAME <- NAMES[[kk]]
[17:47:02.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.196]                     next
[17:47:02.196]                   args[[name]] <- ""
[17:47:02.196]                 }
[17:47:02.196]                 NAMES <- toupper(removed)
[17:47:02.196]                 for (kk in seq_along(NAMES)) {
[17:47:02.196]                   name <- removed[[kk]]
[17:47:02.196]                   NAME <- NAMES[[kk]]
[17:47:02.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.196]                     next
[17:47:02.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.196]                 }
[17:47:02.196]                 if (length(args) > 0) 
[17:47:02.196]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.196]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.196]             }
[17:47:02.196]             else {
[17:47:02.196]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.196]             }
[17:47:02.196]             {
[17:47:02.196]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.196]                   0L) {
[17:47:02.196]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.196]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.196]                   base::options(opts)
[17:47:02.196]                 }
[17:47:02.196]                 {
[17:47:02.196]                   {
[17:47:02.196]                     NULL
[17:47:02.196]                     RNGkind("Mersenne-Twister")
[17:47:02.196]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:02.196]                       inherits = FALSE)
[17:47:02.196]                   }
[17:47:02.196]                   options(future.plan = NULL)
[17:47:02.196]                   if (is.na(NA_character_)) 
[17:47:02.196]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.196]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.196]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.196]                     .init = FALSE)
[17:47:02.196]                 }
[17:47:02.196]             }
[17:47:02.196]         }
[17:47:02.196]     })
[17:47:02.196]     if (TRUE) {
[17:47:02.196]         base::sink(type = "output", split = FALSE)
[17:47:02.196]         if (TRUE) {
[17:47:02.196]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.196]         }
[17:47:02.196]         else {
[17:47:02.196]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.196]         }
[17:47:02.196]         base::close(...future.stdout)
[17:47:02.196]         ...future.stdout <- NULL
[17:47:02.196]     }
[17:47:02.196]     ...future.result$conditions <- ...future.conditions
[17:47:02.196]     ...future.result$finished <- base::Sys.time()
[17:47:02.196]     ...future.result
[17:47:02.196] }
[17:47:02.198] assign_globals() ...
[17:47:02.198] List of 1
[17:47:02.198]  $ x: list()
[17:47:02.198]  - attr(*, "where")=List of 1
[17:47:02.198]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.198]  - attr(*, "resolved")= logi TRUE
[17:47:02.198]  - attr(*, "total_size")= num 0
[17:47:02.198]  - attr(*, "already-done")= logi TRUE
[17:47:02.200] - copied ‘x’ to environment
[17:47:02.200] assign_globals() ... done
[17:47:02.201] plan(): Setting new future strategy stack:
[17:47:02.201] List of future strategies:
[17:47:02.201] 1. sequential:
[17:47:02.201]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.201]    - tweaked: FALSE
[17:47:02.201]    - call: NULL
[17:47:02.201] plan(): nbrOfWorkers() = 1
[17:47:02.202] plan(): Setting new future strategy stack:
[17:47:02.202] List of future strategies:
[17:47:02.202] 1. sequential:
[17:47:02.202]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.202]    - tweaked: FALSE
[17:47:02.202]    - call: plan(strategy)
[17:47:02.205] plan(): nbrOfWorkers() = 1
[17:47:02.205] SequentialFuture started (and completed)
[17:47:02.206] - Launch lazy future ... done
[17:47:02.206] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.207] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.207] Searching for globals...
[17:47:02.209] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.209] Searching for globals ... DONE
[17:47:02.209] Resolving globals: TRUE
[17:47:02.209] Resolving any globals that are futures ...
[17:47:02.209] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.209] Resolving any globals that are futures ... DONE
[17:47:02.209] Resolving futures part of globals (recursively) ...
[17:47:02.210] resolve() on list ...
[17:47:02.210]  recursive: 99
[17:47:02.210]  length: 1
[17:47:02.210]  elements: ‘x’
[17:47:02.210]  length: 0 (resolved future 1)
[17:47:02.210] resolve() on list ... DONE
[17:47:02.210] - globals: [1] ‘x’
[17:47:02.210] Resolving futures part of globals (recursively) ... DONE
[17:47:02.210] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.211] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.211] - globals: [1] ‘x’
[17:47:02.211] 
[17:47:02.211] getGlobalsAndPackages() ... DONE
[17:47:02.211] run() for ‘Future’ ...
[17:47:02.211] - state: ‘created’
[17:47:02.212] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:02.212] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:02.212] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:02.212]   - Field: ‘label’
[17:47:02.212]   - Field: ‘local’
[17:47:02.212]   - Field: ‘owner’
[17:47:02.212]   - Field: ‘envir’
[17:47:02.212]   - Field: ‘packages’
[17:47:02.212]   - Field: ‘gc’
[17:47:02.213]   - Field: ‘conditions’
[17:47:02.213]   - Field: ‘expr’
[17:47:02.213]   - Field: ‘uuid’
[17:47:02.213]   - Field: ‘seed’
[17:47:02.213]   - Field: ‘version’
[17:47:02.213]   - Field: ‘result’
[17:47:02.213]   - Field: ‘asynchronous’
[17:47:02.213]   - Field: ‘calls’
[17:47:02.213]   - Field: ‘globals’
[17:47:02.213]   - Field: ‘stdout’
[17:47:02.213]   - Field: ‘earlySignal’
[17:47:02.214]   - Field: ‘lazy’
[17:47:02.214]   - Field: ‘state’
[17:47:02.214] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:02.214] - Launch lazy future ...
[17:47:02.214] Packages needed by the future expression (n = 0): <none>
[17:47:02.214] Packages needed by future strategies (n = 0): <none>
[17:47:02.214] {
[17:47:02.214]     {
[17:47:02.214]         {
[17:47:02.214]             ...future.startTime <- base::Sys.time()
[17:47:02.214]             {
[17:47:02.214]                 {
[17:47:02.214]                   {
[17:47:02.214]                     base::local({
[17:47:02.214]                       has_future <- base::requireNamespace("future", 
[17:47:02.214]                         quietly = TRUE)
[17:47:02.214]                       if (has_future) {
[17:47:02.214]                         ns <- base::getNamespace("future")
[17:47:02.214]                         version <- ns[[".package"]][["version"]]
[17:47:02.214]                         if (is.null(version)) 
[17:47:02.214]                           version <- utils::packageVersion("future")
[17:47:02.214]                       }
[17:47:02.214]                       else {
[17:47:02.214]                         version <- NULL
[17:47:02.214]                       }
[17:47:02.214]                       if (!has_future || version < "1.8.0") {
[17:47:02.214]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.214]                           "", base::R.version$version.string), 
[17:47:02.214]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:02.214]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.214]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.214]                             "release", "version")], collapse = " "), 
[17:47:02.214]                           hostname = base::Sys.info()[["nodename"]])
[17:47:02.214]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.214]                           info)
[17:47:02.214]                         info <- base::paste(info, collapse = "; ")
[17:47:02.214]                         if (!has_future) {
[17:47:02.214]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.214]                             info)
[17:47:02.214]                         }
[17:47:02.214]                         else {
[17:47:02.214]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.214]                             info, version)
[17:47:02.214]                         }
[17:47:02.214]                         base::stop(msg)
[17:47:02.214]                       }
[17:47:02.214]                     })
[17:47:02.214]                   }
[17:47:02.214]                   ...future.strategy.old <- future::plan("list")
[17:47:02.214]                   options(future.plan = NULL)
[17:47:02.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.214]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.214]                 }
[17:47:02.214]                 ...future.workdir <- getwd()
[17:47:02.214]             }
[17:47:02.214]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.214]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.214]         }
[17:47:02.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.214]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.214]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.214]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.214]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.214]             base::names(...future.oldOptions))
[17:47:02.214]     }
[17:47:02.214]     if (FALSE) {
[17:47:02.214]     }
[17:47:02.214]     else {
[17:47:02.214]         if (TRUE) {
[17:47:02.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.214]                 open = "w")
[17:47:02.214]         }
[17:47:02.214]         else {
[17:47:02.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.214]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.214]         }
[17:47:02.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.214]             base::sink(type = "output", split = FALSE)
[17:47:02.214]             base::close(...future.stdout)
[17:47:02.214]         }, add = TRUE)
[17:47:02.214]     }
[17:47:02.214]     ...future.frame <- base::sys.nframe()
[17:47:02.214]     ...future.conditions <- base::list()
[17:47:02.214]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.214]     if (FALSE) {
[17:47:02.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.214]     }
[17:47:02.214]     ...future.result <- base::tryCatch({
[17:47:02.214]         base::withCallingHandlers({
[17:47:02.214]             ...future.value <- base::withVisible(base::local({
[17:47:02.214]                 x$a <- 1
[17:47:02.214]                 x
[17:47:02.214]             }))
[17:47:02.214]             future::FutureResult(value = ...future.value$value, 
[17:47:02.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.214]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.214]                     ...future.globalenv.names))
[17:47:02.214]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.214]         }, condition = base::local({
[17:47:02.214]             c <- base::c
[17:47:02.214]             inherits <- base::inherits
[17:47:02.214]             invokeRestart <- base::invokeRestart
[17:47:02.214]             length <- base::length
[17:47:02.214]             list <- base::list
[17:47:02.214]             seq.int <- base::seq.int
[17:47:02.214]             signalCondition <- base::signalCondition
[17:47:02.214]             sys.calls <- base::sys.calls
[17:47:02.214]             `[[` <- base::`[[`
[17:47:02.214]             `+` <- base::`+`
[17:47:02.214]             `<<-` <- base::`<<-`
[17:47:02.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.214]                   3L)]
[17:47:02.214]             }
[17:47:02.214]             function(cond) {
[17:47:02.214]                 is_error <- inherits(cond, "error")
[17:47:02.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.214]                   NULL)
[17:47:02.214]                 if (is_error) {
[17:47:02.214]                   sessionInformation <- function() {
[17:47:02.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.214]                       search = base::search(), system = base::Sys.info())
[17:47:02.214]                   }
[17:47:02.214]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.214]                     cond$call), session = sessionInformation(), 
[17:47:02.214]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.214]                   signalCondition(cond)
[17:47:02.214]                 }
[17:47:02.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.214]                 "immediateCondition"))) {
[17:47:02.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.214]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.214]                   if (TRUE && !signal) {
[17:47:02.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.214]                     {
[17:47:02.214]                       inherits <- base::inherits
[17:47:02.214]                       invokeRestart <- base::invokeRestart
[17:47:02.214]                       is.null <- base::is.null
[17:47:02.214]                       muffled <- FALSE
[17:47:02.214]                       if (inherits(cond, "message")) {
[17:47:02.214]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.214]                         if (muffled) 
[17:47:02.214]                           invokeRestart("muffleMessage")
[17:47:02.214]                       }
[17:47:02.214]                       else if (inherits(cond, "warning")) {
[17:47:02.214]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.214]                         if (muffled) 
[17:47:02.214]                           invokeRestart("muffleWarning")
[17:47:02.214]                       }
[17:47:02.214]                       else if (inherits(cond, "condition")) {
[17:47:02.214]                         if (!is.null(pattern)) {
[17:47:02.214]                           computeRestarts <- base::computeRestarts
[17:47:02.214]                           grepl <- base::grepl
[17:47:02.214]                           restarts <- computeRestarts(cond)
[17:47:02.214]                           for (restart in restarts) {
[17:47:02.214]                             name <- restart$name
[17:47:02.214]                             if (is.null(name)) 
[17:47:02.214]                               next
[17:47:02.214]                             if (!grepl(pattern, name)) 
[17:47:02.214]                               next
[17:47:02.214]                             invokeRestart(restart)
[17:47:02.214]                             muffled <- TRUE
[17:47:02.214]                             break
[17:47:02.214]                           }
[17:47:02.214]                         }
[17:47:02.214]                       }
[17:47:02.214]                       invisible(muffled)
[17:47:02.214]                     }
[17:47:02.214]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.214]                   }
[17:47:02.214]                 }
[17:47:02.214]                 else {
[17:47:02.214]                   if (TRUE) {
[17:47:02.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.214]                     {
[17:47:02.214]                       inherits <- base::inherits
[17:47:02.214]                       invokeRestart <- base::invokeRestart
[17:47:02.214]                       is.null <- base::is.null
[17:47:02.214]                       muffled <- FALSE
[17:47:02.214]                       if (inherits(cond, "message")) {
[17:47:02.214]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.214]                         if (muffled) 
[17:47:02.214]                           invokeRestart("muffleMessage")
[17:47:02.214]                       }
[17:47:02.214]                       else if (inherits(cond, "warning")) {
[17:47:02.214]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.214]                         if (muffled) 
[17:47:02.214]                           invokeRestart("muffleWarning")
[17:47:02.214]                       }
[17:47:02.214]                       else if (inherits(cond, "condition")) {
[17:47:02.214]                         if (!is.null(pattern)) {
[17:47:02.214]                           computeRestarts <- base::computeRestarts
[17:47:02.214]                           grepl <- base::grepl
[17:47:02.214]                           restarts <- computeRestarts(cond)
[17:47:02.214]                           for (restart in restarts) {
[17:47:02.214]                             name <- restart$name
[17:47:02.214]                             if (is.null(name)) 
[17:47:02.214]                               next
[17:47:02.214]                             if (!grepl(pattern, name)) 
[17:47:02.214]                               next
[17:47:02.214]                             invokeRestart(restart)
[17:47:02.214]                             muffled <- TRUE
[17:47:02.214]                             break
[17:47:02.214]                           }
[17:47:02.214]                         }
[17:47:02.214]                       }
[17:47:02.214]                       invisible(muffled)
[17:47:02.214]                     }
[17:47:02.214]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.214]                   }
[17:47:02.214]                 }
[17:47:02.214]             }
[17:47:02.214]         }))
[17:47:02.214]     }, error = function(ex) {
[17:47:02.214]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.214]                 ...future.rng), started = ...future.startTime, 
[17:47:02.214]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.214]             version = "1.8"), class = "FutureResult")
[17:47:02.214]     }, finally = {
[17:47:02.214]         if (!identical(...future.workdir, getwd())) 
[17:47:02.214]             setwd(...future.workdir)
[17:47:02.214]         {
[17:47:02.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.214]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.214]             }
[17:47:02.214]             base::options(...future.oldOptions)
[17:47:02.214]             if (.Platform$OS.type == "windows") {
[17:47:02.214]                 old_names <- names(...future.oldEnvVars)
[17:47:02.214]                 envs <- base::Sys.getenv()
[17:47:02.214]                 names <- names(envs)
[17:47:02.214]                 common <- intersect(names, old_names)
[17:47:02.214]                 added <- setdiff(names, old_names)
[17:47:02.214]                 removed <- setdiff(old_names, names)
[17:47:02.214]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.214]                   envs[common]]
[17:47:02.214]                 NAMES <- toupper(changed)
[17:47:02.214]                 args <- list()
[17:47:02.214]                 for (kk in seq_along(NAMES)) {
[17:47:02.214]                   name <- changed[[kk]]
[17:47:02.214]                   NAME <- NAMES[[kk]]
[17:47:02.214]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.214]                     next
[17:47:02.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.214]                 }
[17:47:02.214]                 NAMES <- toupper(added)
[17:47:02.214]                 for (kk in seq_along(NAMES)) {
[17:47:02.214]                   name <- added[[kk]]
[17:47:02.214]                   NAME <- NAMES[[kk]]
[17:47:02.214]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.214]                     next
[17:47:02.214]                   args[[name]] <- ""
[17:47:02.214]                 }
[17:47:02.214]                 NAMES <- toupper(removed)
[17:47:02.214]                 for (kk in seq_along(NAMES)) {
[17:47:02.214]                   name <- removed[[kk]]
[17:47:02.214]                   NAME <- NAMES[[kk]]
[17:47:02.214]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.214]                     next
[17:47:02.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.214]                 }
[17:47:02.214]                 if (length(args) > 0) 
[17:47:02.214]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.214]             }
[17:47:02.214]             else {
[17:47:02.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.214]             }
[17:47:02.214]             {
[17:47:02.214]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.214]                   0L) {
[17:47:02.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.214]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.214]                   base::options(opts)
[17:47:02.214]                 }
[17:47:02.214]                 {
[17:47:02.214]                   {
[17:47:02.214]                     NULL
[17:47:02.214]                     RNGkind("Mersenne-Twister")
[17:47:02.214]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:02.214]                       inherits = FALSE)
[17:47:02.214]                   }
[17:47:02.214]                   options(future.plan = NULL)
[17:47:02.214]                   if (is.na(NA_character_)) 
[17:47:02.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.214]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.214]                     .init = FALSE)
[17:47:02.214]                 }
[17:47:02.214]             }
[17:47:02.214]         }
[17:47:02.214]     })
[17:47:02.214]     if (TRUE) {
[17:47:02.214]         base::sink(type = "output", split = FALSE)
[17:47:02.214]         if (TRUE) {
[17:47:02.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.214]         }
[17:47:02.214]         else {
[17:47:02.214]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.214]         }
[17:47:02.214]         base::close(...future.stdout)
[17:47:02.214]         ...future.stdout <- NULL
[17:47:02.214]     }
[17:47:02.214]     ...future.result$conditions <- ...future.conditions
[17:47:02.214]     ...future.result$finished <- base::Sys.time()
[17:47:02.214]     ...future.result
[17:47:02.214] }
[17:47:02.216] assign_globals() ...
[17:47:02.216] List of 1
[17:47:02.216]  $ x: list()
[17:47:02.216]  - attr(*, "where")=List of 1
[17:47:02.216]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.216]  - attr(*, "resolved")= logi TRUE
[17:47:02.216]  - attr(*, "total_size")= num 0
[17:47:02.216]  - attr(*, "already-done")= logi TRUE
[17:47:02.218] - copied ‘x’ to environment
[17:47:02.219] assign_globals() ... done
[17:47:02.219] plan(): Setting new future strategy stack:
[17:47:02.219] List of future strategies:
[17:47:02.219] 1. sequential:
[17:47:02.219]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.219]    - tweaked: FALSE
[17:47:02.219]    - call: NULL
[17:47:02.219] plan(): nbrOfWorkers() = 1
[17:47:02.220] plan(): Setting new future strategy stack:
[17:47:02.220] List of future strategies:
[17:47:02.220] 1. sequential:
[17:47:02.220]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.220]    - tweaked: FALSE
[17:47:02.220]    - call: plan(strategy)
[17:47:02.221] plan(): nbrOfWorkers() = 1
[17:47:02.221] SequentialFuture started (and completed)
[17:47:02.221] - Launch lazy future ... done
[17:47:02.221] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.222] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.222] Searching for globals...
[17:47:02.224] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.224] Searching for globals ... DONE
[17:47:02.224] Resolving globals: TRUE
[17:47:02.224] Resolving any globals that are futures ...
[17:47:02.224] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.224] Resolving any globals that are futures ... DONE
[17:47:02.225] Resolving futures part of globals (recursively) ...
[17:47:02.225] resolve() on list ...
[17:47:02.225]  recursive: 99
[17:47:02.225]  length: 1
[17:47:02.225]  elements: ‘x’
[17:47:02.225]  length: 0 (resolved future 1)
[17:47:02.226] resolve() on list ... DONE
[17:47:02.226] - globals: [1] ‘x’
[17:47:02.226] Resolving futures part of globals (recursively) ... DONE
[17:47:02.226] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.226] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.226] - globals: [1] ‘x’
[17:47:02.226] 
[17:47:02.226] getGlobalsAndPackages() ... DONE
[17:47:02.227] run() for ‘Future’ ...
[17:47:02.227] - state: ‘created’
[17:47:02.227] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:02.227] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:02.227] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:02.227]   - Field: ‘label’
[17:47:02.227]   - Field: ‘local’
[17:47:02.228]   - Field: ‘owner’
[17:47:02.228]   - Field: ‘envir’
[17:47:02.228]   - Field: ‘packages’
[17:47:02.228]   - Field: ‘gc’
[17:47:02.228]   - Field: ‘conditions’
[17:47:02.228]   - Field: ‘expr’
[17:47:02.228]   - Field: ‘uuid’
[17:47:02.228]   - Field: ‘seed’
[17:47:02.228]   - Field: ‘version’
[17:47:02.228]   - Field: ‘result’
[17:47:02.229]   - Field: ‘asynchronous’
[17:47:02.229]   - Field: ‘calls’
[17:47:02.229]   - Field: ‘globals’
[17:47:02.229]   - Field: ‘stdout’
[17:47:02.229]   - Field: ‘earlySignal’
[17:47:02.229]   - Field: ‘lazy’
[17:47:02.229]   - Field: ‘state’
[17:47:02.229] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:02.229] - Launch lazy future ...
[17:47:02.230] Packages needed by the future expression (n = 0): <none>
[17:47:02.230] Packages needed by future strategies (n = 0): <none>
[17:47:02.230] {
[17:47:02.230]     {
[17:47:02.230]         {
[17:47:02.230]             ...future.startTime <- base::Sys.time()
[17:47:02.230]             {
[17:47:02.230]                 {
[17:47:02.230]                   {
[17:47:02.230]                     base::local({
[17:47:02.230]                       has_future <- base::requireNamespace("future", 
[17:47:02.230]                         quietly = TRUE)
[17:47:02.230]                       if (has_future) {
[17:47:02.230]                         ns <- base::getNamespace("future")
[17:47:02.230]                         version <- ns[[".package"]][["version"]]
[17:47:02.230]                         if (is.null(version)) 
[17:47:02.230]                           version <- utils::packageVersion("future")
[17:47:02.230]                       }
[17:47:02.230]                       else {
[17:47:02.230]                         version <- NULL
[17:47:02.230]                       }
[17:47:02.230]                       if (!has_future || version < "1.8.0") {
[17:47:02.230]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.230]                           "", base::R.version$version.string), 
[17:47:02.230]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:02.230]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.230]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.230]                             "release", "version")], collapse = " "), 
[17:47:02.230]                           hostname = base::Sys.info()[["nodename"]])
[17:47:02.230]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.230]                           info)
[17:47:02.230]                         info <- base::paste(info, collapse = "; ")
[17:47:02.230]                         if (!has_future) {
[17:47:02.230]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.230]                             info)
[17:47:02.230]                         }
[17:47:02.230]                         else {
[17:47:02.230]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.230]                             info, version)
[17:47:02.230]                         }
[17:47:02.230]                         base::stop(msg)
[17:47:02.230]                       }
[17:47:02.230]                     })
[17:47:02.230]                   }
[17:47:02.230]                   ...future.strategy.old <- future::plan("list")
[17:47:02.230]                   options(future.plan = NULL)
[17:47:02.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.230]                 }
[17:47:02.230]                 ...future.workdir <- getwd()
[17:47:02.230]             }
[17:47:02.230]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.230]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.230]         }
[17:47:02.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.230]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.230]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.230]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.230]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.230]             base::names(...future.oldOptions))
[17:47:02.230]     }
[17:47:02.230]     if (FALSE) {
[17:47:02.230]     }
[17:47:02.230]     else {
[17:47:02.230]         if (TRUE) {
[17:47:02.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.230]                 open = "w")
[17:47:02.230]         }
[17:47:02.230]         else {
[17:47:02.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.230]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.230]         }
[17:47:02.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.230]             base::sink(type = "output", split = FALSE)
[17:47:02.230]             base::close(...future.stdout)
[17:47:02.230]         }, add = TRUE)
[17:47:02.230]     }
[17:47:02.230]     ...future.frame <- base::sys.nframe()
[17:47:02.230]     ...future.conditions <- base::list()
[17:47:02.230]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.230]     if (FALSE) {
[17:47:02.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.230]     }
[17:47:02.230]     ...future.result <- base::tryCatch({
[17:47:02.230]         base::withCallingHandlers({
[17:47:02.230]             ...future.value <- base::withVisible(base::local({
[17:47:02.230]                 x$a <- 1
[17:47:02.230]                 x
[17:47:02.230]             }))
[17:47:02.230]             future::FutureResult(value = ...future.value$value, 
[17:47:02.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.230]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.230]                     ...future.globalenv.names))
[17:47:02.230]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.230]         }, condition = base::local({
[17:47:02.230]             c <- base::c
[17:47:02.230]             inherits <- base::inherits
[17:47:02.230]             invokeRestart <- base::invokeRestart
[17:47:02.230]             length <- base::length
[17:47:02.230]             list <- base::list
[17:47:02.230]             seq.int <- base::seq.int
[17:47:02.230]             signalCondition <- base::signalCondition
[17:47:02.230]             sys.calls <- base::sys.calls
[17:47:02.230]             `[[` <- base::`[[`
[17:47:02.230]             `+` <- base::`+`
[17:47:02.230]             `<<-` <- base::`<<-`
[17:47:02.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.230]                   3L)]
[17:47:02.230]             }
[17:47:02.230]             function(cond) {
[17:47:02.230]                 is_error <- inherits(cond, "error")
[17:47:02.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.230]                   NULL)
[17:47:02.230]                 if (is_error) {
[17:47:02.230]                   sessionInformation <- function() {
[17:47:02.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.230]                       search = base::search(), system = base::Sys.info())
[17:47:02.230]                   }
[17:47:02.230]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.230]                     cond$call), session = sessionInformation(), 
[17:47:02.230]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.230]                   signalCondition(cond)
[17:47:02.230]                 }
[17:47:02.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.230]                 "immediateCondition"))) {
[17:47:02.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.230]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.230]                   if (TRUE && !signal) {
[17:47:02.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.230]                     {
[17:47:02.230]                       inherits <- base::inherits
[17:47:02.230]                       invokeRestart <- base::invokeRestart
[17:47:02.230]                       is.null <- base::is.null
[17:47:02.230]                       muffled <- FALSE
[17:47:02.230]                       if (inherits(cond, "message")) {
[17:47:02.230]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.230]                         if (muffled) 
[17:47:02.230]                           invokeRestart("muffleMessage")
[17:47:02.230]                       }
[17:47:02.230]                       else if (inherits(cond, "warning")) {
[17:47:02.230]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.230]                         if (muffled) 
[17:47:02.230]                           invokeRestart("muffleWarning")
[17:47:02.230]                       }
[17:47:02.230]                       else if (inherits(cond, "condition")) {
[17:47:02.230]                         if (!is.null(pattern)) {
[17:47:02.230]                           computeRestarts <- base::computeRestarts
[17:47:02.230]                           grepl <- base::grepl
[17:47:02.230]                           restarts <- computeRestarts(cond)
[17:47:02.230]                           for (restart in restarts) {
[17:47:02.230]                             name <- restart$name
[17:47:02.230]                             if (is.null(name)) 
[17:47:02.230]                               next
[17:47:02.230]                             if (!grepl(pattern, name)) 
[17:47:02.230]                               next
[17:47:02.230]                             invokeRestart(restart)
[17:47:02.230]                             muffled <- TRUE
[17:47:02.230]                             break
[17:47:02.230]                           }
[17:47:02.230]                         }
[17:47:02.230]                       }
[17:47:02.230]                       invisible(muffled)
[17:47:02.230]                     }
[17:47:02.230]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.230]                   }
[17:47:02.230]                 }
[17:47:02.230]                 else {
[17:47:02.230]                   if (TRUE) {
[17:47:02.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.230]                     {
[17:47:02.230]                       inherits <- base::inherits
[17:47:02.230]                       invokeRestart <- base::invokeRestart
[17:47:02.230]                       is.null <- base::is.null
[17:47:02.230]                       muffled <- FALSE
[17:47:02.230]                       if (inherits(cond, "message")) {
[17:47:02.230]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.230]                         if (muffled) 
[17:47:02.230]                           invokeRestart("muffleMessage")
[17:47:02.230]                       }
[17:47:02.230]                       else if (inherits(cond, "warning")) {
[17:47:02.230]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.230]                         if (muffled) 
[17:47:02.230]                           invokeRestart("muffleWarning")
[17:47:02.230]                       }
[17:47:02.230]                       else if (inherits(cond, "condition")) {
[17:47:02.230]                         if (!is.null(pattern)) {
[17:47:02.230]                           computeRestarts <- base::computeRestarts
[17:47:02.230]                           grepl <- base::grepl
[17:47:02.230]                           restarts <- computeRestarts(cond)
[17:47:02.230]                           for (restart in restarts) {
[17:47:02.230]                             name <- restart$name
[17:47:02.230]                             if (is.null(name)) 
[17:47:02.230]                               next
[17:47:02.230]                             if (!grepl(pattern, name)) 
[17:47:02.230]                               next
[17:47:02.230]                             invokeRestart(restart)
[17:47:02.230]                             muffled <- TRUE
[17:47:02.230]                             break
[17:47:02.230]                           }
[17:47:02.230]                         }
[17:47:02.230]                       }
[17:47:02.230]                       invisible(muffled)
[17:47:02.230]                     }
[17:47:02.230]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.230]                   }
[17:47:02.230]                 }
[17:47:02.230]             }
[17:47:02.230]         }))
[17:47:02.230]     }, error = function(ex) {
[17:47:02.230]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.230]                 ...future.rng), started = ...future.startTime, 
[17:47:02.230]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.230]             version = "1.8"), class = "FutureResult")
[17:47:02.230]     }, finally = {
[17:47:02.230]         if (!identical(...future.workdir, getwd())) 
[17:47:02.230]             setwd(...future.workdir)
[17:47:02.230]         {
[17:47:02.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.230]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.230]             }
[17:47:02.230]             base::options(...future.oldOptions)
[17:47:02.230]             if (.Platform$OS.type == "windows") {
[17:47:02.230]                 old_names <- names(...future.oldEnvVars)
[17:47:02.230]                 envs <- base::Sys.getenv()
[17:47:02.230]                 names <- names(envs)
[17:47:02.230]                 common <- intersect(names, old_names)
[17:47:02.230]                 added <- setdiff(names, old_names)
[17:47:02.230]                 removed <- setdiff(old_names, names)
[17:47:02.230]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.230]                   envs[common]]
[17:47:02.230]                 NAMES <- toupper(changed)
[17:47:02.230]                 args <- list()
[17:47:02.230]                 for (kk in seq_along(NAMES)) {
[17:47:02.230]                   name <- changed[[kk]]
[17:47:02.230]                   NAME <- NAMES[[kk]]
[17:47:02.230]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.230]                     next
[17:47:02.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.230]                 }
[17:47:02.230]                 NAMES <- toupper(added)
[17:47:02.230]                 for (kk in seq_along(NAMES)) {
[17:47:02.230]                   name <- added[[kk]]
[17:47:02.230]                   NAME <- NAMES[[kk]]
[17:47:02.230]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.230]                     next
[17:47:02.230]                   args[[name]] <- ""
[17:47:02.230]                 }
[17:47:02.230]                 NAMES <- toupper(removed)
[17:47:02.230]                 for (kk in seq_along(NAMES)) {
[17:47:02.230]                   name <- removed[[kk]]
[17:47:02.230]                   NAME <- NAMES[[kk]]
[17:47:02.230]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.230]                     next
[17:47:02.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.230]                 }
[17:47:02.230]                 if (length(args) > 0) 
[17:47:02.230]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.230]             }
[17:47:02.230]             else {
[17:47:02.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.230]             }
[17:47:02.230]             {
[17:47:02.230]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.230]                   0L) {
[17:47:02.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.230]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.230]                   base::options(opts)
[17:47:02.230]                 }
[17:47:02.230]                 {
[17:47:02.230]                   {
[17:47:02.230]                     NULL
[17:47:02.230]                     RNGkind("Mersenne-Twister")
[17:47:02.230]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:02.230]                       inherits = FALSE)
[17:47:02.230]                   }
[17:47:02.230]                   options(future.plan = NULL)
[17:47:02.230]                   if (is.na(NA_character_)) 
[17:47:02.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.230]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.230]                     .init = FALSE)
[17:47:02.230]                 }
[17:47:02.230]             }
[17:47:02.230]         }
[17:47:02.230]     })
[17:47:02.230]     if (TRUE) {
[17:47:02.230]         base::sink(type = "output", split = FALSE)
[17:47:02.230]         if (TRUE) {
[17:47:02.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.230]         }
[17:47:02.230]         else {
[17:47:02.230]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.230]         }
[17:47:02.230]         base::close(...future.stdout)
[17:47:02.230]         ...future.stdout <- NULL
[17:47:02.230]     }
[17:47:02.230]     ...future.result$conditions <- ...future.conditions
[17:47:02.230]     ...future.result$finished <- base::Sys.time()
[17:47:02.230]     ...future.result
[17:47:02.230] }
[17:47:02.232] assign_globals() ...
[17:47:02.232] List of 1
[17:47:02.232]  $ x: list()
[17:47:02.232]  - attr(*, "where")=List of 1
[17:47:02.232]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.232]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.232]  - attr(*, "resolved")= logi TRUE
[17:47:02.232]  - attr(*, "total_size")= num 0
[17:47:02.232]  - attr(*, "already-done")= logi TRUE
[17:47:02.235] - copied ‘x’ to environment
[17:47:02.235] assign_globals() ... done
[17:47:02.236] plan(): Setting new future strategy stack:
[17:47:02.236] List of future strategies:
[17:47:02.236] 1. sequential:
[17:47:02.236]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.236]    - tweaked: FALSE
[17:47:02.236]    - call: NULL
[17:47:02.236] plan(): nbrOfWorkers() = 1
[17:47:02.237] plan(): Setting new future strategy stack:
[17:47:02.237] List of future strategies:
[17:47:02.237] 1. sequential:
[17:47:02.237]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.237]    - tweaked: FALSE
[17:47:02.237]    - call: plan(strategy)
[17:47:02.237] plan(): nbrOfWorkers() = 1
[17:47:02.238] SequentialFuture started (and completed)
[17:47:02.238] - Launch lazy future ... done
[17:47:02.238] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.238] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.239] Searching for globals...
[17:47:02.240] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.240] Searching for globals ... DONE
[17:47:02.241] Resolving globals: TRUE
[17:47:02.241] Resolving any globals that are futures ...
[17:47:02.241] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.241] Resolving any globals that are futures ... DONE
[17:47:02.241] Resolving futures part of globals (recursively) ...
[17:47:02.241] resolve() on list ...
[17:47:02.241]  recursive: 99
[17:47:02.242]  length: 1
[17:47:02.242]  elements: ‘x’
[17:47:02.242]  length: 0 (resolved future 1)
[17:47:02.242] resolve() on list ... DONE
[17:47:02.242] - globals: [1] ‘x’
[17:47:02.242] Resolving futures part of globals (recursively) ... DONE
[17:47:02.242] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.242] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.243] - globals: [1] ‘x’
[17:47:02.243] 
[17:47:02.243] getGlobalsAndPackages() ... DONE
[17:47:02.243] run() for ‘Future’ ...
[17:47:02.243] - state: ‘created’
[17:47:02.243] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:02.243] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:02.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:02.244]   - Field: ‘label’
[17:47:02.244]   - Field: ‘local’
[17:47:02.244]   - Field: ‘owner’
[17:47:02.244]   - Field: ‘envir’
[17:47:02.244]   - Field: ‘packages’
[17:47:02.244]   - Field: ‘gc’
[17:47:02.244]   - Field: ‘conditions’
[17:47:02.244]   - Field: ‘expr’
[17:47:02.244]   - Field: ‘uuid’
[17:47:02.245]   - Field: ‘seed’
[17:47:02.245]   - Field: ‘version’
[17:47:02.245]   - Field: ‘result’
[17:47:02.245]   - Field: ‘asynchronous’
[17:47:02.245]   - Field: ‘calls’
[17:47:02.245]   - Field: ‘globals’
[17:47:02.245]   - Field: ‘stdout’
[17:47:02.245]   - Field: ‘earlySignal’
[17:47:02.245]   - Field: ‘lazy’
[17:47:02.245]   - Field: ‘state’
[17:47:02.245] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:02.246] - Launch lazy future ...
[17:47:02.246] Packages needed by the future expression (n = 0): <none>
[17:47:02.246] Packages needed by future strategies (n = 0): <none>
[17:47:02.246] {
[17:47:02.246]     {
[17:47:02.246]         {
[17:47:02.246]             ...future.startTime <- base::Sys.time()
[17:47:02.246]             {
[17:47:02.246]                 {
[17:47:02.246]                   {
[17:47:02.246]                     base::local({
[17:47:02.246]                       has_future <- base::requireNamespace("future", 
[17:47:02.246]                         quietly = TRUE)
[17:47:02.246]                       if (has_future) {
[17:47:02.246]                         ns <- base::getNamespace("future")
[17:47:02.246]                         version <- ns[[".package"]][["version"]]
[17:47:02.246]                         if (is.null(version)) 
[17:47:02.246]                           version <- utils::packageVersion("future")
[17:47:02.246]                       }
[17:47:02.246]                       else {
[17:47:02.246]                         version <- NULL
[17:47:02.246]                       }
[17:47:02.246]                       if (!has_future || version < "1.8.0") {
[17:47:02.246]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.246]                           "", base::R.version$version.string), 
[17:47:02.246]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:02.246]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.246]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.246]                             "release", "version")], collapse = " "), 
[17:47:02.246]                           hostname = base::Sys.info()[["nodename"]])
[17:47:02.246]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.246]                           info)
[17:47:02.246]                         info <- base::paste(info, collapse = "; ")
[17:47:02.246]                         if (!has_future) {
[17:47:02.246]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.246]                             info)
[17:47:02.246]                         }
[17:47:02.246]                         else {
[17:47:02.246]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.246]                             info, version)
[17:47:02.246]                         }
[17:47:02.246]                         base::stop(msg)
[17:47:02.246]                       }
[17:47:02.246]                     })
[17:47:02.246]                   }
[17:47:02.246]                   ...future.strategy.old <- future::plan("list")
[17:47:02.246]                   options(future.plan = NULL)
[17:47:02.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.246]                 }
[17:47:02.246]                 ...future.workdir <- getwd()
[17:47:02.246]             }
[17:47:02.246]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.246]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.246]         }
[17:47:02.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.246]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.246]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.246]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.246]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.246]             base::names(...future.oldOptions))
[17:47:02.246]     }
[17:47:02.246]     if (FALSE) {
[17:47:02.246]     }
[17:47:02.246]     else {
[17:47:02.246]         if (TRUE) {
[17:47:02.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.246]                 open = "w")
[17:47:02.246]         }
[17:47:02.246]         else {
[17:47:02.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.246]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.246]         }
[17:47:02.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.246]             base::sink(type = "output", split = FALSE)
[17:47:02.246]             base::close(...future.stdout)
[17:47:02.246]         }, add = TRUE)
[17:47:02.246]     }
[17:47:02.246]     ...future.frame <- base::sys.nframe()
[17:47:02.246]     ...future.conditions <- base::list()
[17:47:02.246]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.246]     if (FALSE) {
[17:47:02.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.246]     }
[17:47:02.246]     ...future.result <- base::tryCatch({
[17:47:02.246]         base::withCallingHandlers({
[17:47:02.246]             ...future.value <- base::withVisible(base::local({
[17:47:02.246]                 x$a <- 1
[17:47:02.246]                 x
[17:47:02.246]             }))
[17:47:02.246]             future::FutureResult(value = ...future.value$value, 
[17:47:02.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.246]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.246]                     ...future.globalenv.names))
[17:47:02.246]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.246]         }, condition = base::local({
[17:47:02.246]             c <- base::c
[17:47:02.246]             inherits <- base::inherits
[17:47:02.246]             invokeRestart <- base::invokeRestart
[17:47:02.246]             length <- base::length
[17:47:02.246]             list <- base::list
[17:47:02.246]             seq.int <- base::seq.int
[17:47:02.246]             signalCondition <- base::signalCondition
[17:47:02.246]             sys.calls <- base::sys.calls
[17:47:02.246]             `[[` <- base::`[[`
[17:47:02.246]             `+` <- base::`+`
[17:47:02.246]             `<<-` <- base::`<<-`
[17:47:02.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.246]                   3L)]
[17:47:02.246]             }
[17:47:02.246]             function(cond) {
[17:47:02.246]                 is_error <- inherits(cond, "error")
[17:47:02.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.246]                   NULL)
[17:47:02.246]                 if (is_error) {
[17:47:02.246]                   sessionInformation <- function() {
[17:47:02.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.246]                       search = base::search(), system = base::Sys.info())
[17:47:02.246]                   }
[17:47:02.246]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.246]                     cond$call), session = sessionInformation(), 
[17:47:02.246]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.246]                   signalCondition(cond)
[17:47:02.246]                 }
[17:47:02.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.246]                 "immediateCondition"))) {
[17:47:02.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.246]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.246]                   if (TRUE && !signal) {
[17:47:02.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.246]                     {
[17:47:02.246]                       inherits <- base::inherits
[17:47:02.246]                       invokeRestart <- base::invokeRestart
[17:47:02.246]                       is.null <- base::is.null
[17:47:02.246]                       muffled <- FALSE
[17:47:02.246]                       if (inherits(cond, "message")) {
[17:47:02.246]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.246]                         if (muffled) 
[17:47:02.246]                           invokeRestart("muffleMessage")
[17:47:02.246]                       }
[17:47:02.246]                       else if (inherits(cond, "warning")) {
[17:47:02.246]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.246]                         if (muffled) 
[17:47:02.246]                           invokeRestart("muffleWarning")
[17:47:02.246]                       }
[17:47:02.246]                       else if (inherits(cond, "condition")) {
[17:47:02.246]                         if (!is.null(pattern)) {
[17:47:02.246]                           computeRestarts <- base::computeRestarts
[17:47:02.246]                           grepl <- base::grepl
[17:47:02.246]                           restarts <- computeRestarts(cond)
[17:47:02.246]                           for (restart in restarts) {
[17:47:02.246]                             name <- restart$name
[17:47:02.246]                             if (is.null(name)) 
[17:47:02.246]                               next
[17:47:02.246]                             if (!grepl(pattern, name)) 
[17:47:02.246]                               next
[17:47:02.246]                             invokeRestart(restart)
[17:47:02.246]                             muffled <- TRUE
[17:47:02.246]                             break
[17:47:02.246]                           }
[17:47:02.246]                         }
[17:47:02.246]                       }
[17:47:02.246]                       invisible(muffled)
[17:47:02.246]                     }
[17:47:02.246]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.246]                   }
[17:47:02.246]                 }
[17:47:02.246]                 else {
[17:47:02.246]                   if (TRUE) {
[17:47:02.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.246]                     {
[17:47:02.246]                       inherits <- base::inherits
[17:47:02.246]                       invokeRestart <- base::invokeRestart
[17:47:02.246]                       is.null <- base::is.null
[17:47:02.246]                       muffled <- FALSE
[17:47:02.246]                       if (inherits(cond, "message")) {
[17:47:02.246]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.246]                         if (muffled) 
[17:47:02.246]                           invokeRestart("muffleMessage")
[17:47:02.246]                       }
[17:47:02.246]                       else if (inherits(cond, "warning")) {
[17:47:02.246]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.246]                         if (muffled) 
[17:47:02.246]                           invokeRestart("muffleWarning")
[17:47:02.246]                       }
[17:47:02.246]                       else if (inherits(cond, "condition")) {
[17:47:02.246]                         if (!is.null(pattern)) {
[17:47:02.246]                           computeRestarts <- base::computeRestarts
[17:47:02.246]                           grepl <- base::grepl
[17:47:02.246]                           restarts <- computeRestarts(cond)
[17:47:02.246]                           for (restart in restarts) {
[17:47:02.246]                             name <- restart$name
[17:47:02.246]                             if (is.null(name)) 
[17:47:02.246]                               next
[17:47:02.246]                             if (!grepl(pattern, name)) 
[17:47:02.246]                               next
[17:47:02.246]                             invokeRestart(restart)
[17:47:02.246]                             muffled <- TRUE
[17:47:02.246]                             break
[17:47:02.246]                           }
[17:47:02.246]                         }
[17:47:02.246]                       }
[17:47:02.246]                       invisible(muffled)
[17:47:02.246]                     }
[17:47:02.246]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.246]                   }
[17:47:02.246]                 }
[17:47:02.246]             }
[17:47:02.246]         }))
[17:47:02.246]     }, error = function(ex) {
[17:47:02.246]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.246]                 ...future.rng), started = ...future.startTime, 
[17:47:02.246]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.246]             version = "1.8"), class = "FutureResult")
[17:47:02.246]     }, finally = {
[17:47:02.246]         if (!identical(...future.workdir, getwd())) 
[17:47:02.246]             setwd(...future.workdir)
[17:47:02.246]         {
[17:47:02.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.246]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.246]             }
[17:47:02.246]             base::options(...future.oldOptions)
[17:47:02.246]             if (.Platform$OS.type == "windows") {
[17:47:02.246]                 old_names <- names(...future.oldEnvVars)
[17:47:02.246]                 envs <- base::Sys.getenv()
[17:47:02.246]                 names <- names(envs)
[17:47:02.246]                 common <- intersect(names, old_names)
[17:47:02.246]                 added <- setdiff(names, old_names)
[17:47:02.246]                 removed <- setdiff(old_names, names)
[17:47:02.246]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.246]                   envs[common]]
[17:47:02.246]                 NAMES <- toupper(changed)
[17:47:02.246]                 args <- list()
[17:47:02.246]                 for (kk in seq_along(NAMES)) {
[17:47:02.246]                   name <- changed[[kk]]
[17:47:02.246]                   NAME <- NAMES[[kk]]
[17:47:02.246]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.246]                     next
[17:47:02.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.246]                 }
[17:47:02.246]                 NAMES <- toupper(added)
[17:47:02.246]                 for (kk in seq_along(NAMES)) {
[17:47:02.246]                   name <- added[[kk]]
[17:47:02.246]                   NAME <- NAMES[[kk]]
[17:47:02.246]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.246]                     next
[17:47:02.246]                   args[[name]] <- ""
[17:47:02.246]                 }
[17:47:02.246]                 NAMES <- toupper(removed)
[17:47:02.246]                 for (kk in seq_along(NAMES)) {
[17:47:02.246]                   name <- removed[[kk]]
[17:47:02.246]                   NAME <- NAMES[[kk]]
[17:47:02.246]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.246]                     next
[17:47:02.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.246]                 }
[17:47:02.246]                 if (length(args) > 0) 
[17:47:02.246]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.246]             }
[17:47:02.246]             else {
[17:47:02.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.246]             }
[17:47:02.246]             {
[17:47:02.246]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.246]                   0L) {
[17:47:02.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.246]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.246]                   base::options(opts)
[17:47:02.246]                 }
[17:47:02.246]                 {
[17:47:02.246]                   {
[17:47:02.246]                     NULL
[17:47:02.246]                     RNGkind("Mersenne-Twister")
[17:47:02.246]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:02.246]                       inherits = FALSE)
[17:47:02.246]                   }
[17:47:02.246]                   options(future.plan = NULL)
[17:47:02.246]                   if (is.na(NA_character_)) 
[17:47:02.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.246]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.246]                     .init = FALSE)
[17:47:02.246]                 }
[17:47:02.246]             }
[17:47:02.246]         }
[17:47:02.246]     })
[17:47:02.246]     if (TRUE) {
[17:47:02.246]         base::sink(type = "output", split = FALSE)
[17:47:02.246]         if (TRUE) {
[17:47:02.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.246]         }
[17:47:02.246]         else {
[17:47:02.246]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.246]         }
[17:47:02.246]         base::close(...future.stdout)
[17:47:02.246]         ...future.stdout <- NULL
[17:47:02.246]     }
[17:47:02.246]     ...future.result$conditions <- ...future.conditions
[17:47:02.246]     ...future.result$finished <- base::Sys.time()
[17:47:02.246]     ...future.result
[17:47:02.246] }
[17:47:02.248] assign_globals() ...
[17:47:02.248] List of 1
[17:47:02.248]  $ x: list()
[17:47:02.248]  - attr(*, "where")=List of 1
[17:47:02.248]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.248]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.248]  - attr(*, "resolved")= logi TRUE
[17:47:02.248]  - attr(*, "total_size")= num 0
[17:47:02.248]  - attr(*, "already-done")= logi TRUE
[17:47:02.250] - copied ‘x’ to environment
[17:47:02.250] assign_globals() ... done
[17:47:02.250] plan(): Setting new future strategy stack:
[17:47:02.250] List of future strategies:
[17:47:02.250] 1. sequential:
[17:47:02.250]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.250]    - tweaked: FALSE
[17:47:02.250]    - call: NULL
[17:47:02.251] plan(): nbrOfWorkers() = 1
[17:47:02.252] plan(): Setting new future strategy stack:
[17:47:02.252] List of future strategies:
[17:47:02.252] 1. sequential:
[17:47:02.252]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.252]    - tweaked: FALSE
[17:47:02.252]    - call: plan(strategy)
[17:47:02.252] plan(): nbrOfWorkers() = 1
[17:47:02.252] SequentialFuture started (and completed)
[17:47:02.252] - Launch lazy future ... done
[17:47:02.252] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.253] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.253] Searching for globals...
[17:47:02.255] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:47:02.255] Searching for globals ... DONE
[17:47:02.256] Resolving globals: TRUE
[17:47:02.256] Resolving any globals that are futures ...
[17:47:02.256] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:47:02.256] Resolving any globals that are futures ... DONE
[17:47:02.256] 
[17:47:02.256] 
[17:47:02.256] getGlobalsAndPackages() ... DONE
[17:47:02.257] run() for ‘Future’ ...
[17:47:02.257] - state: ‘created’
[17:47:02.257] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:02.257] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:02.257] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:02.257]   - Field: ‘label’
[17:47:02.257]   - Field: ‘local’
[17:47:02.257]   - Field: ‘owner’
[17:47:02.257]   - Field: ‘envir’
[17:47:02.258]   - Field: ‘packages’
[17:47:02.258]   - Field: ‘gc’
[17:47:02.258]   - Field: ‘conditions’
[17:47:02.258]   - Field: ‘expr’
[17:47:02.258]   - Field: ‘uuid’
[17:47:02.258]   - Field: ‘seed’
[17:47:02.258]   - Field: ‘version’
[17:47:02.258]   - Field: ‘result’
[17:47:02.258]   - Field: ‘asynchronous’
[17:47:02.258]   - Field: ‘calls’
[17:47:02.258]   - Field: ‘globals’
[17:47:02.259]   - Field: ‘stdout’
[17:47:02.259]   - Field: ‘earlySignal’
[17:47:02.259]   - Field: ‘lazy’
[17:47:02.259]   - Field: ‘state’
[17:47:02.259] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:02.259] - Launch lazy future ...
[17:47:02.259] Packages needed by the future expression (n = 0): <none>
[17:47:02.259] Packages needed by future strategies (n = 0): <none>
[17:47:02.260] {
[17:47:02.260]     {
[17:47:02.260]         {
[17:47:02.260]             ...future.startTime <- base::Sys.time()
[17:47:02.260]             {
[17:47:02.260]                 {
[17:47:02.260]                   {
[17:47:02.260]                     base::local({
[17:47:02.260]                       has_future <- base::requireNamespace("future", 
[17:47:02.260]                         quietly = TRUE)
[17:47:02.260]                       if (has_future) {
[17:47:02.260]                         ns <- base::getNamespace("future")
[17:47:02.260]                         version <- ns[[".package"]][["version"]]
[17:47:02.260]                         if (is.null(version)) 
[17:47:02.260]                           version <- utils::packageVersion("future")
[17:47:02.260]                       }
[17:47:02.260]                       else {
[17:47:02.260]                         version <- NULL
[17:47:02.260]                       }
[17:47:02.260]                       if (!has_future || version < "1.8.0") {
[17:47:02.260]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.260]                           "", base::R.version$version.string), 
[17:47:02.260]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:02.260]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.260]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.260]                             "release", "version")], collapse = " "), 
[17:47:02.260]                           hostname = base::Sys.info()[["nodename"]])
[17:47:02.260]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.260]                           info)
[17:47:02.260]                         info <- base::paste(info, collapse = "; ")
[17:47:02.260]                         if (!has_future) {
[17:47:02.260]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.260]                             info)
[17:47:02.260]                         }
[17:47:02.260]                         else {
[17:47:02.260]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.260]                             info, version)
[17:47:02.260]                         }
[17:47:02.260]                         base::stop(msg)
[17:47:02.260]                       }
[17:47:02.260]                     })
[17:47:02.260]                   }
[17:47:02.260]                   ...future.strategy.old <- future::plan("list")
[17:47:02.260]                   options(future.plan = NULL)
[17:47:02.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.260]                 }
[17:47:02.260]                 ...future.workdir <- getwd()
[17:47:02.260]             }
[17:47:02.260]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.260]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.260]         }
[17:47:02.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.260]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.260]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.260]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.260]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.260]             base::names(...future.oldOptions))
[17:47:02.260]     }
[17:47:02.260]     if (FALSE) {
[17:47:02.260]     }
[17:47:02.260]     else {
[17:47:02.260]         if (TRUE) {
[17:47:02.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.260]                 open = "w")
[17:47:02.260]         }
[17:47:02.260]         else {
[17:47:02.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.260]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.260]         }
[17:47:02.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.260]             base::sink(type = "output", split = FALSE)
[17:47:02.260]             base::close(...future.stdout)
[17:47:02.260]         }, add = TRUE)
[17:47:02.260]     }
[17:47:02.260]     ...future.frame <- base::sys.nframe()
[17:47:02.260]     ...future.conditions <- base::list()
[17:47:02.260]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.260]     if (FALSE) {
[17:47:02.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.260]     }
[17:47:02.260]     ...future.result <- base::tryCatch({
[17:47:02.260]         base::withCallingHandlers({
[17:47:02.260]             ...future.value <- base::withVisible(base::local({
[17:47:02.260]                 x <- list(b = 2)
[17:47:02.260]                 x$a <- 1
[17:47:02.260]                 x
[17:47:02.260]             }))
[17:47:02.260]             future::FutureResult(value = ...future.value$value, 
[17:47:02.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.260]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.260]                     ...future.globalenv.names))
[17:47:02.260]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.260]         }, condition = base::local({
[17:47:02.260]             c <- base::c
[17:47:02.260]             inherits <- base::inherits
[17:47:02.260]             invokeRestart <- base::invokeRestart
[17:47:02.260]             length <- base::length
[17:47:02.260]             list <- base::list
[17:47:02.260]             seq.int <- base::seq.int
[17:47:02.260]             signalCondition <- base::signalCondition
[17:47:02.260]             sys.calls <- base::sys.calls
[17:47:02.260]             `[[` <- base::`[[`
[17:47:02.260]             `+` <- base::`+`
[17:47:02.260]             `<<-` <- base::`<<-`
[17:47:02.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.260]                   3L)]
[17:47:02.260]             }
[17:47:02.260]             function(cond) {
[17:47:02.260]                 is_error <- inherits(cond, "error")
[17:47:02.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.260]                   NULL)
[17:47:02.260]                 if (is_error) {
[17:47:02.260]                   sessionInformation <- function() {
[17:47:02.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.260]                       search = base::search(), system = base::Sys.info())
[17:47:02.260]                   }
[17:47:02.260]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.260]                     cond$call), session = sessionInformation(), 
[17:47:02.260]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.260]                   signalCondition(cond)
[17:47:02.260]                 }
[17:47:02.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.260]                 "immediateCondition"))) {
[17:47:02.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.260]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.260]                   if (TRUE && !signal) {
[17:47:02.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.260]                     {
[17:47:02.260]                       inherits <- base::inherits
[17:47:02.260]                       invokeRestart <- base::invokeRestart
[17:47:02.260]                       is.null <- base::is.null
[17:47:02.260]                       muffled <- FALSE
[17:47:02.260]                       if (inherits(cond, "message")) {
[17:47:02.260]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.260]                         if (muffled) 
[17:47:02.260]                           invokeRestart("muffleMessage")
[17:47:02.260]                       }
[17:47:02.260]                       else if (inherits(cond, "warning")) {
[17:47:02.260]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.260]                         if (muffled) 
[17:47:02.260]                           invokeRestart("muffleWarning")
[17:47:02.260]                       }
[17:47:02.260]                       else if (inherits(cond, "condition")) {
[17:47:02.260]                         if (!is.null(pattern)) {
[17:47:02.260]                           computeRestarts <- base::computeRestarts
[17:47:02.260]                           grepl <- base::grepl
[17:47:02.260]                           restarts <- computeRestarts(cond)
[17:47:02.260]                           for (restart in restarts) {
[17:47:02.260]                             name <- restart$name
[17:47:02.260]                             if (is.null(name)) 
[17:47:02.260]                               next
[17:47:02.260]                             if (!grepl(pattern, name)) 
[17:47:02.260]                               next
[17:47:02.260]                             invokeRestart(restart)
[17:47:02.260]                             muffled <- TRUE
[17:47:02.260]                             break
[17:47:02.260]                           }
[17:47:02.260]                         }
[17:47:02.260]                       }
[17:47:02.260]                       invisible(muffled)
[17:47:02.260]                     }
[17:47:02.260]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.260]                   }
[17:47:02.260]                 }
[17:47:02.260]                 else {
[17:47:02.260]                   if (TRUE) {
[17:47:02.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.260]                     {
[17:47:02.260]                       inherits <- base::inherits
[17:47:02.260]                       invokeRestart <- base::invokeRestart
[17:47:02.260]                       is.null <- base::is.null
[17:47:02.260]                       muffled <- FALSE
[17:47:02.260]                       if (inherits(cond, "message")) {
[17:47:02.260]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.260]                         if (muffled) 
[17:47:02.260]                           invokeRestart("muffleMessage")
[17:47:02.260]                       }
[17:47:02.260]                       else if (inherits(cond, "warning")) {
[17:47:02.260]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.260]                         if (muffled) 
[17:47:02.260]                           invokeRestart("muffleWarning")
[17:47:02.260]                       }
[17:47:02.260]                       else if (inherits(cond, "condition")) {
[17:47:02.260]                         if (!is.null(pattern)) {
[17:47:02.260]                           computeRestarts <- base::computeRestarts
[17:47:02.260]                           grepl <- base::grepl
[17:47:02.260]                           restarts <- computeRestarts(cond)
[17:47:02.260]                           for (restart in restarts) {
[17:47:02.260]                             name <- restart$name
[17:47:02.260]                             if (is.null(name)) 
[17:47:02.260]                               next
[17:47:02.260]                             if (!grepl(pattern, name)) 
[17:47:02.260]                               next
[17:47:02.260]                             invokeRestart(restart)
[17:47:02.260]                             muffled <- TRUE
[17:47:02.260]                             break
[17:47:02.260]                           }
[17:47:02.260]                         }
[17:47:02.260]                       }
[17:47:02.260]                       invisible(muffled)
[17:47:02.260]                     }
[17:47:02.260]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.260]                   }
[17:47:02.260]                 }
[17:47:02.260]             }
[17:47:02.260]         }))
[17:47:02.260]     }, error = function(ex) {
[17:47:02.260]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.260]                 ...future.rng), started = ...future.startTime, 
[17:47:02.260]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.260]             version = "1.8"), class = "FutureResult")
[17:47:02.260]     }, finally = {
[17:47:02.260]         if (!identical(...future.workdir, getwd())) 
[17:47:02.260]             setwd(...future.workdir)
[17:47:02.260]         {
[17:47:02.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.260]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.260]             }
[17:47:02.260]             base::options(...future.oldOptions)
[17:47:02.260]             if (.Platform$OS.type == "windows") {
[17:47:02.260]                 old_names <- names(...future.oldEnvVars)
[17:47:02.260]                 envs <- base::Sys.getenv()
[17:47:02.260]                 names <- names(envs)
[17:47:02.260]                 common <- intersect(names, old_names)
[17:47:02.260]                 added <- setdiff(names, old_names)
[17:47:02.260]                 removed <- setdiff(old_names, names)
[17:47:02.260]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.260]                   envs[common]]
[17:47:02.260]                 NAMES <- toupper(changed)
[17:47:02.260]                 args <- list()
[17:47:02.260]                 for (kk in seq_along(NAMES)) {
[17:47:02.260]                   name <- changed[[kk]]
[17:47:02.260]                   NAME <- NAMES[[kk]]
[17:47:02.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.260]                     next
[17:47:02.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.260]                 }
[17:47:02.260]                 NAMES <- toupper(added)
[17:47:02.260]                 for (kk in seq_along(NAMES)) {
[17:47:02.260]                   name <- added[[kk]]
[17:47:02.260]                   NAME <- NAMES[[kk]]
[17:47:02.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.260]                     next
[17:47:02.260]                   args[[name]] <- ""
[17:47:02.260]                 }
[17:47:02.260]                 NAMES <- toupper(removed)
[17:47:02.260]                 for (kk in seq_along(NAMES)) {
[17:47:02.260]                   name <- removed[[kk]]
[17:47:02.260]                   NAME <- NAMES[[kk]]
[17:47:02.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.260]                     next
[17:47:02.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.260]                 }
[17:47:02.260]                 if (length(args) > 0) 
[17:47:02.260]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.260]             }
[17:47:02.260]             else {
[17:47:02.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.260]             }
[17:47:02.260]             {
[17:47:02.260]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.260]                   0L) {
[17:47:02.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.260]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.260]                   base::options(opts)
[17:47:02.260]                 }
[17:47:02.260]                 {
[17:47:02.260]                   {
[17:47:02.260]                     NULL
[17:47:02.260]                     RNGkind("Mersenne-Twister")
[17:47:02.260]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:02.260]                       inherits = FALSE)
[17:47:02.260]                   }
[17:47:02.260]                   options(future.plan = NULL)
[17:47:02.260]                   if (is.na(NA_character_)) 
[17:47:02.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.260]                     .init = FALSE)
[17:47:02.260]                 }
[17:47:02.260]             }
[17:47:02.260]         }
[17:47:02.260]     })
[17:47:02.260]     if (TRUE) {
[17:47:02.260]         base::sink(type = "output", split = FALSE)
[17:47:02.260]         if (TRUE) {
[17:47:02.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.260]         }
[17:47:02.260]         else {
[17:47:02.260]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.260]         }
[17:47:02.260]         base::close(...future.stdout)
[17:47:02.260]         ...future.stdout <- NULL
[17:47:02.260]     }
[17:47:02.260]     ...future.result$conditions <- ...future.conditions
[17:47:02.260]     ...future.result$finished <- base::Sys.time()
[17:47:02.260]     ...future.result
[17:47:02.260] }
[17:47:02.261] plan(): Setting new future strategy stack:
[17:47:02.261] List of future strategies:
[17:47:02.261] 1. sequential:
[17:47:02.261]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.261]    - tweaked: FALSE
[17:47:02.261]    - call: NULL
[17:47:02.263] plan(): nbrOfWorkers() = 1
[17:47:02.264] plan(): Setting new future strategy stack:
[17:47:02.264] List of future strategies:
[17:47:02.264] 1. sequential:
[17:47:02.264]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.264]    - tweaked: FALSE
[17:47:02.264]    - call: plan(strategy)
[17:47:02.264] plan(): nbrOfWorkers() = 1
[17:47:02.264] SequentialFuture started (and completed)
[17:47:02.265] - Launch lazy future ... done
[17:47:02.265] run() for ‘SequentialFuture’ ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.265] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.265] Searching for globals...
[17:47:02.267] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:02.267] Searching for globals ... DONE
[17:47:02.267] Resolving globals: TRUE
[17:47:02.267] Resolving any globals that are futures ...
[17:47:02.267] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:02.267] Resolving any globals that are futures ... DONE
[17:47:02.268] Resolving futures part of globals (recursively) ...
[17:47:02.268] resolve() on list ...
[17:47:02.268]  recursive: 99
[17:47:02.268]  length: 1
[17:47:02.268]  elements: ‘x’
[17:47:02.268]  length: 0 (resolved future 1)
[17:47:02.268] resolve() on list ... DONE
[17:47:02.269] - globals: [1] ‘x’
[17:47:02.269] Resolving futures part of globals (recursively) ... DONE
[17:47:02.269] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.269] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.269] - globals: [1] ‘x’
[17:47:02.269] 
[17:47:02.269] getGlobalsAndPackages() ... DONE
[17:47:02.270] run() for ‘Future’ ...
[17:47:02.270] - state: ‘created’
[17:47:02.270] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:02.270] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:02.270] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:02.270]   - Field: ‘label’
[17:47:02.270]   - Field: ‘local’
[17:47:02.270]   - Field: ‘owner’
[17:47:02.270]   - Field: ‘envir’
[17:47:02.271]   - Field: ‘packages’
[17:47:02.271]   - Field: ‘gc’
[17:47:02.271]   - Field: ‘conditions’
[17:47:02.271]   - Field: ‘expr’
[17:47:02.271]   - Field: ‘uuid’
[17:47:02.271]   - Field: ‘seed’
[17:47:02.271]   - Field: ‘version’
[17:47:02.271]   - Field: ‘result’
[17:47:02.271]   - Field: ‘asynchronous’
[17:47:02.271]   - Field: ‘calls’
[17:47:02.271]   - Field: ‘globals’
[17:47:02.272]   - Field: ‘stdout’
[17:47:02.272]   - Field: ‘earlySignal’
[17:47:02.272]   - Field: ‘lazy’
[17:47:02.272]   - Field: ‘state’
[17:47:02.272] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:02.272] - Launch lazy future ...
[17:47:02.272] Packages needed by the future expression (n = 0): <none>
[17:47:02.272] Packages needed by future strategies (n = 0): <none>
[17:47:02.273] {
[17:47:02.273]     {
[17:47:02.273]         {
[17:47:02.273]             ...future.startTime <- base::Sys.time()
[17:47:02.273]             {
[17:47:02.273]                 {
[17:47:02.273]                   {
[17:47:02.273]                     base::local({
[17:47:02.273]                       has_future <- base::requireNamespace("future", 
[17:47:02.273]                         quietly = TRUE)
[17:47:02.273]                       if (has_future) {
[17:47:02.273]                         ns <- base::getNamespace("future")
[17:47:02.273]                         version <- ns[[".package"]][["version"]]
[17:47:02.273]                         if (is.null(version)) 
[17:47:02.273]                           version <- utils::packageVersion("future")
[17:47:02.273]                       }
[17:47:02.273]                       else {
[17:47:02.273]                         version <- NULL
[17:47:02.273]                       }
[17:47:02.273]                       if (!has_future || version < "1.8.0") {
[17:47:02.273]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.273]                           "", base::R.version$version.string), 
[17:47:02.273]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:02.273]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.273]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.273]                             "release", "version")], collapse = " "), 
[17:47:02.273]                           hostname = base::Sys.info()[["nodename"]])
[17:47:02.273]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.273]                           info)
[17:47:02.273]                         info <- base::paste(info, collapse = "; ")
[17:47:02.273]                         if (!has_future) {
[17:47:02.273]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.273]                             info)
[17:47:02.273]                         }
[17:47:02.273]                         else {
[17:47:02.273]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.273]                             info, version)
[17:47:02.273]                         }
[17:47:02.273]                         base::stop(msg)
[17:47:02.273]                       }
[17:47:02.273]                     })
[17:47:02.273]                   }
[17:47:02.273]                   ...future.strategy.old <- future::plan("list")
[17:47:02.273]                   options(future.plan = NULL)
[17:47:02.273]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.273]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.273]                 }
[17:47:02.273]                 ...future.workdir <- getwd()
[17:47:02.273]             }
[17:47:02.273]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.273]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.273]         }
[17:47:02.273]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.273]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.273]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.273]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.273]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.273]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.273]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.273]             base::names(...future.oldOptions))
[17:47:02.273]     }
[17:47:02.273]     if (FALSE) {
[17:47:02.273]     }
[17:47:02.273]     else {
[17:47:02.273]         if (TRUE) {
[17:47:02.273]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.273]                 open = "w")
[17:47:02.273]         }
[17:47:02.273]         else {
[17:47:02.273]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.273]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.273]         }
[17:47:02.273]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.273]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.273]             base::sink(type = "output", split = FALSE)
[17:47:02.273]             base::close(...future.stdout)
[17:47:02.273]         }, add = TRUE)
[17:47:02.273]     }
[17:47:02.273]     ...future.frame <- base::sys.nframe()
[17:47:02.273]     ...future.conditions <- base::list()
[17:47:02.273]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.273]     if (FALSE) {
[17:47:02.273]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.273]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.273]     }
[17:47:02.273]     ...future.result <- base::tryCatch({
[17:47:02.273]         base::withCallingHandlers({
[17:47:02.273]             ...future.value <- base::withVisible(base::local({
[17:47:02.273]                 x[["a"]] <- 1
[17:47:02.273]                 x
[17:47:02.273]             }))
[17:47:02.273]             future::FutureResult(value = ...future.value$value, 
[17:47:02.273]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.273]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.273]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.273]                     ...future.globalenv.names))
[17:47:02.273]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.273]         }, condition = base::local({
[17:47:02.273]             c <- base::c
[17:47:02.273]             inherits <- base::inherits
[17:47:02.273]             invokeRestart <- base::invokeRestart
[17:47:02.273]             length <- base::length
[17:47:02.273]             list <- base::list
[17:47:02.273]             seq.int <- base::seq.int
[17:47:02.273]             signalCondition <- base::signalCondition
[17:47:02.273]             sys.calls <- base::sys.calls
[17:47:02.273]             `[[` <- base::`[[`
[17:47:02.273]             `+` <- base::`+`
[17:47:02.273]             `<<-` <- base::`<<-`
[17:47:02.273]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.273]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.273]                   3L)]
[17:47:02.273]             }
[17:47:02.273]             function(cond) {
[17:47:02.273]                 is_error <- inherits(cond, "error")
[17:47:02.273]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.273]                   NULL)
[17:47:02.273]                 if (is_error) {
[17:47:02.273]                   sessionInformation <- function() {
[17:47:02.273]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.273]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.273]                       search = base::search(), system = base::Sys.info())
[17:47:02.273]                   }
[17:47:02.273]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.273]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.273]                     cond$call), session = sessionInformation(), 
[17:47:02.273]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.273]                   signalCondition(cond)
[17:47:02.273]                 }
[17:47:02.273]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.273]                 "immediateCondition"))) {
[17:47:02.273]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.273]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.273]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.273]                   if (TRUE && !signal) {
[17:47:02.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.273]                     {
[17:47:02.273]                       inherits <- base::inherits
[17:47:02.273]                       invokeRestart <- base::invokeRestart
[17:47:02.273]                       is.null <- base::is.null
[17:47:02.273]                       muffled <- FALSE
[17:47:02.273]                       if (inherits(cond, "message")) {
[17:47:02.273]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.273]                         if (muffled) 
[17:47:02.273]                           invokeRestart("muffleMessage")
[17:47:02.273]                       }
[17:47:02.273]                       else if (inherits(cond, "warning")) {
[17:47:02.273]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.273]                         if (muffled) 
[17:47:02.273]                           invokeRestart("muffleWarning")
[17:47:02.273]                       }
[17:47:02.273]                       else if (inherits(cond, "condition")) {
[17:47:02.273]                         if (!is.null(pattern)) {
[17:47:02.273]                           computeRestarts <- base::computeRestarts
[17:47:02.273]                           grepl <- base::grepl
[17:47:02.273]                           restarts <- computeRestarts(cond)
[17:47:02.273]                           for (restart in restarts) {
[17:47:02.273]                             name <- restart$name
[17:47:02.273]                             if (is.null(name)) 
[17:47:02.273]                               next
[17:47:02.273]                             if (!grepl(pattern, name)) 
[17:47:02.273]                               next
[17:47:02.273]                             invokeRestart(restart)
[17:47:02.273]                             muffled <- TRUE
[17:47:02.273]                             break
[17:47:02.273]                           }
[17:47:02.273]                         }
[17:47:02.273]                       }
[17:47:02.273]                       invisible(muffled)
[17:47:02.273]                     }
[17:47:02.273]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.273]                   }
[17:47:02.273]                 }
[17:47:02.273]                 else {
[17:47:02.273]                   if (TRUE) {
[17:47:02.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.273]                     {
[17:47:02.273]                       inherits <- base::inherits
[17:47:02.273]                       invokeRestart <- base::invokeRestart
[17:47:02.273]                       is.null <- base::is.null
[17:47:02.273]                       muffled <- FALSE
[17:47:02.273]                       if (inherits(cond, "message")) {
[17:47:02.273]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.273]                         if (muffled) 
[17:47:02.273]                           invokeRestart("muffleMessage")
[17:47:02.273]                       }
[17:47:02.273]                       else if (inherits(cond, "warning")) {
[17:47:02.273]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.273]                         if (muffled) 
[17:47:02.273]                           invokeRestart("muffleWarning")
[17:47:02.273]                       }
[17:47:02.273]                       else if (inherits(cond, "condition")) {
[17:47:02.273]                         if (!is.null(pattern)) {
[17:47:02.273]                           computeRestarts <- base::computeRestarts
[17:47:02.273]                           grepl <- base::grepl
[17:47:02.273]                           restarts <- computeRestarts(cond)
[17:47:02.273]                           for (restart in restarts) {
[17:47:02.273]                             name <- restart$name
[17:47:02.273]                             if (is.null(name)) 
[17:47:02.273]                               next
[17:47:02.273]                             if (!grepl(pattern, name)) 
[17:47:02.273]                               next
[17:47:02.273]                             invokeRestart(restart)
[17:47:02.273]                             muffled <- TRUE
[17:47:02.273]                             break
[17:47:02.273]                           }
[17:47:02.273]                         }
[17:47:02.273]                       }
[17:47:02.273]                       invisible(muffled)
[17:47:02.273]                     }
[17:47:02.273]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.273]                   }
[17:47:02.273]                 }
[17:47:02.273]             }
[17:47:02.273]         }))
[17:47:02.273]     }, error = function(ex) {
[17:47:02.273]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.273]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.273]                 ...future.rng), started = ...future.startTime, 
[17:47:02.273]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.273]             version = "1.8"), class = "FutureResult")
[17:47:02.273]     }, finally = {
[17:47:02.273]         if (!identical(...future.workdir, getwd())) 
[17:47:02.273]             setwd(...future.workdir)
[17:47:02.273]         {
[17:47:02.273]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.273]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.273]             }
[17:47:02.273]             base::options(...future.oldOptions)
[17:47:02.273]             if (.Platform$OS.type == "windows") {
[17:47:02.273]                 old_names <- names(...future.oldEnvVars)
[17:47:02.273]                 envs <- base::Sys.getenv()
[17:47:02.273]                 names <- names(envs)
[17:47:02.273]                 common <- intersect(names, old_names)
[17:47:02.273]                 added <- setdiff(names, old_names)
[17:47:02.273]                 removed <- setdiff(old_names, names)
[17:47:02.273]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.273]                   envs[common]]
[17:47:02.273]                 NAMES <- toupper(changed)
[17:47:02.273]                 args <- list()
[17:47:02.273]                 for (kk in seq_along(NAMES)) {
[17:47:02.273]                   name <- changed[[kk]]
[17:47:02.273]                   NAME <- NAMES[[kk]]
[17:47:02.273]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.273]                     next
[17:47:02.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.273]                 }
[17:47:02.273]                 NAMES <- toupper(added)
[17:47:02.273]                 for (kk in seq_along(NAMES)) {
[17:47:02.273]                   name <- added[[kk]]
[17:47:02.273]                   NAME <- NAMES[[kk]]
[17:47:02.273]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.273]                     next
[17:47:02.273]                   args[[name]] <- ""
[17:47:02.273]                 }
[17:47:02.273]                 NAMES <- toupper(removed)
[17:47:02.273]                 for (kk in seq_along(NAMES)) {
[17:47:02.273]                   name <- removed[[kk]]
[17:47:02.273]                   NAME <- NAMES[[kk]]
[17:47:02.273]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.273]                     next
[17:47:02.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.273]                 }
[17:47:02.273]                 if (length(args) > 0) 
[17:47:02.273]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.273]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.273]             }
[17:47:02.273]             else {
[17:47:02.273]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.273]             }
[17:47:02.273]             {
[17:47:02.273]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.273]                   0L) {
[17:47:02.273]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.273]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.273]                   base::options(opts)
[17:47:02.273]                 }
[17:47:02.273]                 {
[17:47:02.273]                   {
[17:47:02.273]                     NULL
[17:47:02.273]                     RNGkind("Mersenne-Twister")
[17:47:02.273]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:02.273]                       inherits = FALSE)
[17:47:02.273]                   }
[17:47:02.273]                   options(future.plan = NULL)
[17:47:02.273]                   if (is.na(NA_character_)) 
[17:47:02.273]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.273]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.273]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.273]                     .init = FALSE)
[17:47:02.273]                 }
[17:47:02.273]             }
[17:47:02.273]         }
[17:47:02.273]     })
[17:47:02.273]     if (TRUE) {
[17:47:02.273]         base::sink(type = "output", split = FALSE)
[17:47:02.273]         if (TRUE) {
[17:47:02.273]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.273]         }
[17:47:02.273]         else {
[17:47:02.273]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.273]         }
[17:47:02.273]         base::close(...future.stdout)
[17:47:02.273]         ...future.stdout <- NULL
[17:47:02.273]     }
[17:47:02.273]     ...future.result$conditions <- ...future.conditions
[17:47:02.273]     ...future.result$finished <- base::Sys.time()
[17:47:02.273]     ...future.result
[17:47:02.273] }
[17:47:02.274] assign_globals() ...
[17:47:02.274] List of 1
[17:47:02.274]  $ x: list()
[17:47:02.274]  - attr(*, "where")=List of 1
[17:47:02.274]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.274]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.274]  - attr(*, "resolved")= logi TRUE
[17:47:02.274]  - attr(*, "total_size")= num 0
[17:47:02.274]  - attr(*, "already-done")= logi TRUE
[17:47:02.276] - copied ‘x’ to environment
[17:47:02.277] assign_globals() ... done
[17:47:02.277] plan(): Setting new future strategy stack:
[17:47:02.277] List of future strategies:
[17:47:02.277] 1. sequential:
[17:47:02.277]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.277]    - tweaked: FALSE
[17:47:02.277]    - call: NULL
[17:47:02.277] plan(): nbrOfWorkers() = 1
[17:47:02.278] plan(): Setting new future strategy stack:
[17:47:02.278] List of future strategies:
[17:47:02.278] 1. sequential:
[17:47:02.278]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.278]    - tweaked: FALSE
[17:47:02.278]    - call: plan(strategy)
[17:47:02.278] plan(): nbrOfWorkers() = 1
[17:47:02.279] SequentialFuture started (and completed)
[17:47:02.279] - Launch lazy future ... done
[17:47:02.279] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.279] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.279] Searching for globals...
[17:47:02.281] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:02.281] Searching for globals ... DONE
[17:47:02.281] Resolving globals: TRUE
[17:47:02.281] Resolving any globals that are futures ...
[17:47:02.281] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:02.282] Resolving any globals that are futures ... DONE
[17:47:02.282] Resolving futures part of globals (recursively) ...
[17:47:02.282] resolve() on list ...
[17:47:02.282]  recursive: 99
[17:47:02.282]  length: 1
[17:47:02.282]  elements: ‘x’
[17:47:02.282]  length: 0 (resolved future 1)
[17:47:02.283] resolve() on list ... DONE
[17:47:02.283] - globals: [1] ‘x’
[17:47:02.283] Resolving futures part of globals (recursively) ... DONE
[17:47:02.283] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.283] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.283] - globals: [1] ‘x’
[17:47:02.283] 
[17:47:02.283] getGlobalsAndPackages() ... DONE
[17:47:02.284] run() for ‘Future’ ...
[17:47:02.284] - state: ‘created’
[17:47:02.284] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:02.284] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:02.284] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:02.284]   - Field: ‘label’
[17:47:02.284]   - Field: ‘local’
[17:47:02.285]   - Field: ‘owner’
[17:47:02.285]   - Field: ‘envir’
[17:47:02.285]   - Field: ‘packages’
[17:47:02.285]   - Field: ‘gc’
[17:47:02.285]   - Field: ‘conditions’
[17:47:02.285]   - Field: ‘expr’
[17:47:02.285]   - Field: ‘uuid’
[17:47:02.285]   - Field: ‘seed’
[17:47:02.285]   - Field: ‘version’
[17:47:02.285]   - Field: ‘result’
[17:47:02.285]   - Field: ‘asynchronous’
[17:47:02.285]   - Field: ‘calls’
[17:47:02.286]   - Field: ‘globals’
[17:47:02.286]   - Field: ‘stdout’
[17:47:02.286]   - Field: ‘earlySignal’
[17:47:02.286]   - Field: ‘lazy’
[17:47:02.286]   - Field: ‘state’
[17:47:02.286] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:02.286] - Launch lazy future ...
[17:47:02.286] Packages needed by the future expression (n = 0): <none>
[17:47:02.286] Packages needed by future strategies (n = 0): <none>
[17:47:02.287] {
[17:47:02.287]     {
[17:47:02.287]         {
[17:47:02.287]             ...future.startTime <- base::Sys.time()
[17:47:02.287]             {
[17:47:02.287]                 {
[17:47:02.287]                   {
[17:47:02.287]                     base::local({
[17:47:02.287]                       has_future <- base::requireNamespace("future", 
[17:47:02.287]                         quietly = TRUE)
[17:47:02.287]                       if (has_future) {
[17:47:02.287]                         ns <- base::getNamespace("future")
[17:47:02.287]                         version <- ns[[".package"]][["version"]]
[17:47:02.287]                         if (is.null(version)) 
[17:47:02.287]                           version <- utils::packageVersion("future")
[17:47:02.287]                       }
[17:47:02.287]                       else {
[17:47:02.287]                         version <- NULL
[17:47:02.287]                       }
[17:47:02.287]                       if (!has_future || version < "1.8.0") {
[17:47:02.287]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.287]                           "", base::R.version$version.string), 
[17:47:02.287]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:02.287]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.287]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.287]                             "release", "version")], collapse = " "), 
[17:47:02.287]                           hostname = base::Sys.info()[["nodename"]])
[17:47:02.287]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.287]                           info)
[17:47:02.287]                         info <- base::paste(info, collapse = "; ")
[17:47:02.287]                         if (!has_future) {
[17:47:02.287]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.287]                             info)
[17:47:02.287]                         }
[17:47:02.287]                         else {
[17:47:02.287]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.287]                             info, version)
[17:47:02.287]                         }
[17:47:02.287]                         base::stop(msg)
[17:47:02.287]                       }
[17:47:02.287]                     })
[17:47:02.287]                   }
[17:47:02.287]                   ...future.strategy.old <- future::plan("list")
[17:47:02.287]                   options(future.plan = NULL)
[17:47:02.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.287]                 }
[17:47:02.287]                 ...future.workdir <- getwd()
[17:47:02.287]             }
[17:47:02.287]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.287]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.287]         }
[17:47:02.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.287]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.287]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.287]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.287]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.287]             base::names(...future.oldOptions))
[17:47:02.287]     }
[17:47:02.287]     if (FALSE) {
[17:47:02.287]     }
[17:47:02.287]     else {
[17:47:02.287]         if (TRUE) {
[17:47:02.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.287]                 open = "w")
[17:47:02.287]         }
[17:47:02.287]         else {
[17:47:02.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.287]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.287]         }
[17:47:02.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.287]             base::sink(type = "output", split = FALSE)
[17:47:02.287]             base::close(...future.stdout)
[17:47:02.287]         }, add = TRUE)
[17:47:02.287]     }
[17:47:02.287]     ...future.frame <- base::sys.nframe()
[17:47:02.287]     ...future.conditions <- base::list()
[17:47:02.287]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.287]     if (FALSE) {
[17:47:02.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.287]     }
[17:47:02.287]     ...future.result <- base::tryCatch({
[17:47:02.287]         base::withCallingHandlers({
[17:47:02.287]             ...future.value <- base::withVisible(base::local({
[17:47:02.287]                 x[["a"]] <- 1
[17:47:02.287]                 x
[17:47:02.287]             }))
[17:47:02.287]             future::FutureResult(value = ...future.value$value, 
[17:47:02.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.287]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.287]                     ...future.globalenv.names))
[17:47:02.287]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.287]         }, condition = base::local({
[17:47:02.287]             c <- base::c
[17:47:02.287]             inherits <- base::inherits
[17:47:02.287]             invokeRestart <- base::invokeRestart
[17:47:02.287]             length <- base::length
[17:47:02.287]             list <- base::list
[17:47:02.287]             seq.int <- base::seq.int
[17:47:02.287]             signalCondition <- base::signalCondition
[17:47:02.287]             sys.calls <- base::sys.calls
[17:47:02.287]             `[[` <- base::`[[`
[17:47:02.287]             `+` <- base::`+`
[17:47:02.287]             `<<-` <- base::`<<-`
[17:47:02.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.287]                   3L)]
[17:47:02.287]             }
[17:47:02.287]             function(cond) {
[17:47:02.287]                 is_error <- inherits(cond, "error")
[17:47:02.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.287]                   NULL)
[17:47:02.287]                 if (is_error) {
[17:47:02.287]                   sessionInformation <- function() {
[17:47:02.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.287]                       search = base::search(), system = base::Sys.info())
[17:47:02.287]                   }
[17:47:02.287]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.287]                     cond$call), session = sessionInformation(), 
[17:47:02.287]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.287]                   signalCondition(cond)
[17:47:02.287]                 }
[17:47:02.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.287]                 "immediateCondition"))) {
[17:47:02.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.287]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.287]                   if (TRUE && !signal) {
[17:47:02.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.287]                     {
[17:47:02.287]                       inherits <- base::inherits
[17:47:02.287]                       invokeRestart <- base::invokeRestart
[17:47:02.287]                       is.null <- base::is.null
[17:47:02.287]                       muffled <- FALSE
[17:47:02.287]                       if (inherits(cond, "message")) {
[17:47:02.287]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.287]                         if (muffled) 
[17:47:02.287]                           invokeRestart("muffleMessage")
[17:47:02.287]                       }
[17:47:02.287]                       else if (inherits(cond, "warning")) {
[17:47:02.287]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.287]                         if (muffled) 
[17:47:02.287]                           invokeRestart("muffleWarning")
[17:47:02.287]                       }
[17:47:02.287]                       else if (inherits(cond, "condition")) {
[17:47:02.287]                         if (!is.null(pattern)) {
[17:47:02.287]                           computeRestarts <- base::computeRestarts
[17:47:02.287]                           grepl <- base::grepl
[17:47:02.287]                           restarts <- computeRestarts(cond)
[17:47:02.287]                           for (restart in restarts) {
[17:47:02.287]                             name <- restart$name
[17:47:02.287]                             if (is.null(name)) 
[17:47:02.287]                               next
[17:47:02.287]                             if (!grepl(pattern, name)) 
[17:47:02.287]                               next
[17:47:02.287]                             invokeRestart(restart)
[17:47:02.287]                             muffled <- TRUE
[17:47:02.287]                             break
[17:47:02.287]                           }
[17:47:02.287]                         }
[17:47:02.287]                       }
[17:47:02.287]                       invisible(muffled)
[17:47:02.287]                     }
[17:47:02.287]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.287]                   }
[17:47:02.287]                 }
[17:47:02.287]                 else {
[17:47:02.287]                   if (TRUE) {
[17:47:02.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.287]                     {
[17:47:02.287]                       inherits <- base::inherits
[17:47:02.287]                       invokeRestart <- base::invokeRestart
[17:47:02.287]                       is.null <- base::is.null
[17:47:02.287]                       muffled <- FALSE
[17:47:02.287]                       if (inherits(cond, "message")) {
[17:47:02.287]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.287]                         if (muffled) 
[17:47:02.287]                           invokeRestart("muffleMessage")
[17:47:02.287]                       }
[17:47:02.287]                       else if (inherits(cond, "warning")) {
[17:47:02.287]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.287]                         if (muffled) 
[17:47:02.287]                           invokeRestart("muffleWarning")
[17:47:02.287]                       }
[17:47:02.287]                       else if (inherits(cond, "condition")) {
[17:47:02.287]                         if (!is.null(pattern)) {
[17:47:02.287]                           computeRestarts <- base::computeRestarts
[17:47:02.287]                           grepl <- base::grepl
[17:47:02.287]                           restarts <- computeRestarts(cond)
[17:47:02.287]                           for (restart in restarts) {
[17:47:02.287]                             name <- restart$name
[17:47:02.287]                             if (is.null(name)) 
[17:47:02.287]                               next
[17:47:02.287]                             if (!grepl(pattern, name)) 
[17:47:02.287]                               next
[17:47:02.287]                             invokeRestart(restart)
[17:47:02.287]                             muffled <- TRUE
[17:47:02.287]                             break
[17:47:02.287]                           }
[17:47:02.287]                         }
[17:47:02.287]                       }
[17:47:02.287]                       invisible(muffled)
[17:47:02.287]                     }
[17:47:02.287]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.287]                   }
[17:47:02.287]                 }
[17:47:02.287]             }
[17:47:02.287]         }))
[17:47:02.287]     }, error = function(ex) {
[17:47:02.287]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.287]                 ...future.rng), started = ...future.startTime, 
[17:47:02.287]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.287]             version = "1.8"), class = "FutureResult")
[17:47:02.287]     }, finally = {
[17:47:02.287]         if (!identical(...future.workdir, getwd())) 
[17:47:02.287]             setwd(...future.workdir)
[17:47:02.287]         {
[17:47:02.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.287]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.287]             }
[17:47:02.287]             base::options(...future.oldOptions)
[17:47:02.287]             if (.Platform$OS.type == "windows") {
[17:47:02.287]                 old_names <- names(...future.oldEnvVars)
[17:47:02.287]                 envs <- base::Sys.getenv()
[17:47:02.287]                 names <- names(envs)
[17:47:02.287]                 common <- intersect(names, old_names)
[17:47:02.287]                 added <- setdiff(names, old_names)
[17:47:02.287]                 removed <- setdiff(old_names, names)
[17:47:02.287]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.287]                   envs[common]]
[17:47:02.287]                 NAMES <- toupper(changed)
[17:47:02.287]                 args <- list()
[17:47:02.287]                 for (kk in seq_along(NAMES)) {
[17:47:02.287]                   name <- changed[[kk]]
[17:47:02.287]                   NAME <- NAMES[[kk]]
[17:47:02.287]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.287]                     next
[17:47:02.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.287]                 }
[17:47:02.287]                 NAMES <- toupper(added)
[17:47:02.287]                 for (kk in seq_along(NAMES)) {
[17:47:02.287]                   name <- added[[kk]]
[17:47:02.287]                   NAME <- NAMES[[kk]]
[17:47:02.287]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.287]                     next
[17:47:02.287]                   args[[name]] <- ""
[17:47:02.287]                 }
[17:47:02.287]                 NAMES <- toupper(removed)
[17:47:02.287]                 for (kk in seq_along(NAMES)) {
[17:47:02.287]                   name <- removed[[kk]]
[17:47:02.287]                   NAME <- NAMES[[kk]]
[17:47:02.287]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.287]                     next
[17:47:02.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.287]                 }
[17:47:02.287]                 if (length(args) > 0) 
[17:47:02.287]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.287]             }
[17:47:02.287]             else {
[17:47:02.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.287]             }
[17:47:02.287]             {
[17:47:02.287]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.287]                   0L) {
[17:47:02.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.287]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.287]                   base::options(opts)
[17:47:02.287]                 }
[17:47:02.287]                 {
[17:47:02.287]                   {
[17:47:02.287]                     NULL
[17:47:02.287]                     RNGkind("Mersenne-Twister")
[17:47:02.287]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:02.287]                       inherits = FALSE)
[17:47:02.287]                   }
[17:47:02.287]                   options(future.plan = NULL)
[17:47:02.287]                   if (is.na(NA_character_)) 
[17:47:02.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.287]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.287]                     .init = FALSE)
[17:47:02.287]                 }
[17:47:02.287]             }
[17:47:02.287]         }
[17:47:02.287]     })
[17:47:02.287]     if (TRUE) {
[17:47:02.287]         base::sink(type = "output", split = FALSE)
[17:47:02.287]         if (TRUE) {
[17:47:02.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.287]         }
[17:47:02.287]         else {
[17:47:02.287]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.287]         }
[17:47:02.287]         base::close(...future.stdout)
[17:47:02.287]         ...future.stdout <- NULL
[17:47:02.287]     }
[17:47:02.287]     ...future.result$conditions <- ...future.conditions
[17:47:02.287]     ...future.result$finished <- base::Sys.time()
[17:47:02.287]     ...future.result
[17:47:02.287] }
[17:47:02.288] assign_globals() ...
[17:47:02.288] List of 1
[17:47:02.288]  $ x: list()
[17:47:02.288]  - attr(*, "where")=List of 1
[17:47:02.288]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.288]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.288]  - attr(*, "resolved")= logi TRUE
[17:47:02.288]  - attr(*, "total_size")= num 0
[17:47:02.288]  - attr(*, "already-done")= logi TRUE
[17:47:02.292] - copied ‘x’ to environment
[17:47:02.292] assign_globals() ... done
[17:47:02.292] plan(): Setting new future strategy stack:
[17:47:02.292] List of future strategies:
[17:47:02.292] 1. sequential:
[17:47:02.292]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.292]    - tweaked: FALSE
[17:47:02.292]    - call: NULL
[17:47:02.293] plan(): nbrOfWorkers() = 1
[17:47:02.293] plan(): Setting new future strategy stack:
[17:47:02.293] List of future strategies:
[17:47:02.293] 1. sequential:
[17:47:02.293]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.293]    - tweaked: FALSE
[17:47:02.293]    - call: plan(strategy)
[17:47:02.294] plan(): nbrOfWorkers() = 1
[17:47:02.294] SequentialFuture started (and completed)
[17:47:02.294] - Launch lazy future ... done
[17:47:02.294] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.295] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.295] Searching for globals...
[17:47:02.297] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:02.297] Searching for globals ... DONE
[17:47:02.297] Resolving globals: TRUE
[17:47:02.297] Resolving any globals that are futures ...
[17:47:02.297] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:02.297] Resolving any globals that are futures ... DONE
[17:47:02.297] Resolving futures part of globals (recursively) ...
[17:47:02.298] resolve() on list ...
[17:47:02.298]  recursive: 99
[17:47:02.298]  length: 1
[17:47:02.298]  elements: ‘x’
[17:47:02.298]  length: 0 (resolved future 1)
[17:47:02.298] resolve() on list ... DONE
[17:47:02.298] - globals: [1] ‘x’
[17:47:02.298] Resolving futures part of globals (recursively) ... DONE
[17:47:02.298] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.299] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.299] - globals: [1] ‘x’
[17:47:02.299] 
[17:47:02.299] getGlobalsAndPackages() ... DONE
[17:47:02.299] run() for ‘Future’ ...
[17:47:02.299] - state: ‘created’
[17:47:02.300] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:02.300] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:02.300] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:02.300]   - Field: ‘label’
[17:47:02.300]   - Field: ‘local’
[17:47:02.300]   - Field: ‘owner’
[17:47:02.300]   - Field: ‘envir’
[17:47:02.300]   - Field: ‘packages’
[17:47:02.300]   - Field: ‘gc’
[17:47:02.301]   - Field: ‘conditions’
[17:47:02.301]   - Field: ‘expr’
[17:47:02.301]   - Field: ‘uuid’
[17:47:02.301]   - Field: ‘seed’
[17:47:02.301]   - Field: ‘version’
[17:47:02.301]   - Field: ‘result’
[17:47:02.301]   - Field: ‘asynchronous’
[17:47:02.301]   - Field: ‘calls’
[17:47:02.301]   - Field: ‘globals’
[17:47:02.301]   - Field: ‘stdout’
[17:47:02.301]   - Field: ‘earlySignal’
[17:47:02.301]   - Field: ‘lazy’
[17:47:02.302]   - Field: ‘state’
[17:47:02.302] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:02.302] - Launch lazy future ...
[17:47:02.302] Packages needed by the future expression (n = 0): <none>
[17:47:02.302] Packages needed by future strategies (n = 0): <none>
[17:47:02.302] {
[17:47:02.302]     {
[17:47:02.302]         {
[17:47:02.302]             ...future.startTime <- base::Sys.time()
[17:47:02.302]             {
[17:47:02.302]                 {
[17:47:02.302]                   {
[17:47:02.302]                     base::local({
[17:47:02.302]                       has_future <- base::requireNamespace("future", 
[17:47:02.302]                         quietly = TRUE)
[17:47:02.302]                       if (has_future) {
[17:47:02.302]                         ns <- base::getNamespace("future")
[17:47:02.302]                         version <- ns[[".package"]][["version"]]
[17:47:02.302]                         if (is.null(version)) 
[17:47:02.302]                           version <- utils::packageVersion("future")
[17:47:02.302]                       }
[17:47:02.302]                       else {
[17:47:02.302]                         version <- NULL
[17:47:02.302]                       }
[17:47:02.302]                       if (!has_future || version < "1.8.0") {
[17:47:02.302]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.302]                           "", base::R.version$version.string), 
[17:47:02.302]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:02.302]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.302]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.302]                             "release", "version")], collapse = " "), 
[17:47:02.302]                           hostname = base::Sys.info()[["nodename"]])
[17:47:02.302]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.302]                           info)
[17:47:02.302]                         info <- base::paste(info, collapse = "; ")
[17:47:02.302]                         if (!has_future) {
[17:47:02.302]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.302]                             info)
[17:47:02.302]                         }
[17:47:02.302]                         else {
[17:47:02.302]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.302]                             info, version)
[17:47:02.302]                         }
[17:47:02.302]                         base::stop(msg)
[17:47:02.302]                       }
[17:47:02.302]                     })
[17:47:02.302]                   }
[17:47:02.302]                   ...future.strategy.old <- future::plan("list")
[17:47:02.302]                   options(future.plan = NULL)
[17:47:02.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.302]                 }
[17:47:02.302]                 ...future.workdir <- getwd()
[17:47:02.302]             }
[17:47:02.302]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.302]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.302]         }
[17:47:02.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.302]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.302]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.302]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.302]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.302]             base::names(...future.oldOptions))
[17:47:02.302]     }
[17:47:02.302]     if (FALSE) {
[17:47:02.302]     }
[17:47:02.302]     else {
[17:47:02.302]         if (TRUE) {
[17:47:02.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.302]                 open = "w")
[17:47:02.302]         }
[17:47:02.302]         else {
[17:47:02.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.302]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.302]         }
[17:47:02.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.302]             base::sink(type = "output", split = FALSE)
[17:47:02.302]             base::close(...future.stdout)
[17:47:02.302]         }, add = TRUE)
[17:47:02.302]     }
[17:47:02.302]     ...future.frame <- base::sys.nframe()
[17:47:02.302]     ...future.conditions <- base::list()
[17:47:02.302]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.302]     if (FALSE) {
[17:47:02.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.302]     }
[17:47:02.302]     ...future.result <- base::tryCatch({
[17:47:02.302]         base::withCallingHandlers({
[17:47:02.302]             ...future.value <- base::withVisible(base::local({
[17:47:02.302]                 x[["a"]] <- 1
[17:47:02.302]                 x
[17:47:02.302]             }))
[17:47:02.302]             future::FutureResult(value = ...future.value$value, 
[17:47:02.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.302]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.302]                     ...future.globalenv.names))
[17:47:02.302]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.302]         }, condition = base::local({
[17:47:02.302]             c <- base::c
[17:47:02.302]             inherits <- base::inherits
[17:47:02.302]             invokeRestart <- base::invokeRestart
[17:47:02.302]             length <- base::length
[17:47:02.302]             list <- base::list
[17:47:02.302]             seq.int <- base::seq.int
[17:47:02.302]             signalCondition <- base::signalCondition
[17:47:02.302]             sys.calls <- base::sys.calls
[17:47:02.302]             `[[` <- base::`[[`
[17:47:02.302]             `+` <- base::`+`
[17:47:02.302]             `<<-` <- base::`<<-`
[17:47:02.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.302]                   3L)]
[17:47:02.302]             }
[17:47:02.302]             function(cond) {
[17:47:02.302]                 is_error <- inherits(cond, "error")
[17:47:02.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.302]                   NULL)
[17:47:02.302]                 if (is_error) {
[17:47:02.302]                   sessionInformation <- function() {
[17:47:02.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.302]                       search = base::search(), system = base::Sys.info())
[17:47:02.302]                   }
[17:47:02.302]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.302]                     cond$call), session = sessionInformation(), 
[17:47:02.302]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.302]                   signalCondition(cond)
[17:47:02.302]                 }
[17:47:02.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.302]                 "immediateCondition"))) {
[17:47:02.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.302]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.302]                   if (TRUE && !signal) {
[17:47:02.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.302]                     {
[17:47:02.302]                       inherits <- base::inherits
[17:47:02.302]                       invokeRestart <- base::invokeRestart
[17:47:02.302]                       is.null <- base::is.null
[17:47:02.302]                       muffled <- FALSE
[17:47:02.302]                       if (inherits(cond, "message")) {
[17:47:02.302]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.302]                         if (muffled) 
[17:47:02.302]                           invokeRestart("muffleMessage")
[17:47:02.302]                       }
[17:47:02.302]                       else if (inherits(cond, "warning")) {
[17:47:02.302]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.302]                         if (muffled) 
[17:47:02.302]                           invokeRestart("muffleWarning")
[17:47:02.302]                       }
[17:47:02.302]                       else if (inherits(cond, "condition")) {
[17:47:02.302]                         if (!is.null(pattern)) {
[17:47:02.302]                           computeRestarts <- base::computeRestarts
[17:47:02.302]                           grepl <- base::grepl
[17:47:02.302]                           restarts <- computeRestarts(cond)
[17:47:02.302]                           for (restart in restarts) {
[17:47:02.302]                             name <- restart$name
[17:47:02.302]                             if (is.null(name)) 
[17:47:02.302]                               next
[17:47:02.302]                             if (!grepl(pattern, name)) 
[17:47:02.302]                               next
[17:47:02.302]                             invokeRestart(restart)
[17:47:02.302]                             muffled <- TRUE
[17:47:02.302]                             break
[17:47:02.302]                           }
[17:47:02.302]                         }
[17:47:02.302]                       }
[17:47:02.302]                       invisible(muffled)
[17:47:02.302]                     }
[17:47:02.302]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.302]                   }
[17:47:02.302]                 }
[17:47:02.302]                 else {
[17:47:02.302]                   if (TRUE) {
[17:47:02.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.302]                     {
[17:47:02.302]                       inherits <- base::inherits
[17:47:02.302]                       invokeRestart <- base::invokeRestart
[17:47:02.302]                       is.null <- base::is.null
[17:47:02.302]                       muffled <- FALSE
[17:47:02.302]                       if (inherits(cond, "message")) {
[17:47:02.302]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.302]                         if (muffled) 
[17:47:02.302]                           invokeRestart("muffleMessage")
[17:47:02.302]                       }
[17:47:02.302]                       else if (inherits(cond, "warning")) {
[17:47:02.302]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.302]                         if (muffled) 
[17:47:02.302]                           invokeRestart("muffleWarning")
[17:47:02.302]                       }
[17:47:02.302]                       else if (inherits(cond, "condition")) {
[17:47:02.302]                         if (!is.null(pattern)) {
[17:47:02.302]                           computeRestarts <- base::computeRestarts
[17:47:02.302]                           grepl <- base::grepl
[17:47:02.302]                           restarts <- computeRestarts(cond)
[17:47:02.302]                           for (restart in restarts) {
[17:47:02.302]                             name <- restart$name
[17:47:02.302]                             if (is.null(name)) 
[17:47:02.302]                               next
[17:47:02.302]                             if (!grepl(pattern, name)) 
[17:47:02.302]                               next
[17:47:02.302]                             invokeRestart(restart)
[17:47:02.302]                             muffled <- TRUE
[17:47:02.302]                             break
[17:47:02.302]                           }
[17:47:02.302]                         }
[17:47:02.302]                       }
[17:47:02.302]                       invisible(muffled)
[17:47:02.302]                     }
[17:47:02.302]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.302]                   }
[17:47:02.302]                 }
[17:47:02.302]             }
[17:47:02.302]         }))
[17:47:02.302]     }, error = function(ex) {
[17:47:02.302]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.302]                 ...future.rng), started = ...future.startTime, 
[17:47:02.302]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.302]             version = "1.8"), class = "FutureResult")
[17:47:02.302]     }, finally = {
[17:47:02.302]         if (!identical(...future.workdir, getwd())) 
[17:47:02.302]             setwd(...future.workdir)
[17:47:02.302]         {
[17:47:02.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.302]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.302]             }
[17:47:02.302]             base::options(...future.oldOptions)
[17:47:02.302]             if (.Platform$OS.type == "windows") {
[17:47:02.302]                 old_names <- names(...future.oldEnvVars)
[17:47:02.302]                 envs <- base::Sys.getenv()
[17:47:02.302]                 names <- names(envs)
[17:47:02.302]                 common <- intersect(names, old_names)
[17:47:02.302]                 added <- setdiff(names, old_names)
[17:47:02.302]                 removed <- setdiff(old_names, names)
[17:47:02.302]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.302]                   envs[common]]
[17:47:02.302]                 NAMES <- toupper(changed)
[17:47:02.302]                 args <- list()
[17:47:02.302]                 for (kk in seq_along(NAMES)) {
[17:47:02.302]                   name <- changed[[kk]]
[17:47:02.302]                   NAME <- NAMES[[kk]]
[17:47:02.302]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.302]                     next
[17:47:02.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.302]                 }
[17:47:02.302]                 NAMES <- toupper(added)
[17:47:02.302]                 for (kk in seq_along(NAMES)) {
[17:47:02.302]                   name <- added[[kk]]
[17:47:02.302]                   NAME <- NAMES[[kk]]
[17:47:02.302]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.302]                     next
[17:47:02.302]                   args[[name]] <- ""
[17:47:02.302]                 }
[17:47:02.302]                 NAMES <- toupper(removed)
[17:47:02.302]                 for (kk in seq_along(NAMES)) {
[17:47:02.302]                   name <- removed[[kk]]
[17:47:02.302]                   NAME <- NAMES[[kk]]
[17:47:02.302]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.302]                     next
[17:47:02.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.302]                 }
[17:47:02.302]                 if (length(args) > 0) 
[17:47:02.302]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.302]             }
[17:47:02.302]             else {
[17:47:02.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.302]             }
[17:47:02.302]             {
[17:47:02.302]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.302]                   0L) {
[17:47:02.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.302]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.302]                   base::options(opts)
[17:47:02.302]                 }
[17:47:02.302]                 {
[17:47:02.302]                   {
[17:47:02.302]                     NULL
[17:47:02.302]                     RNGkind("Mersenne-Twister")
[17:47:02.302]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:02.302]                       inherits = FALSE)
[17:47:02.302]                   }
[17:47:02.302]                   options(future.plan = NULL)
[17:47:02.302]                   if (is.na(NA_character_)) 
[17:47:02.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.302]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.302]                     .init = FALSE)
[17:47:02.302]                 }
[17:47:02.302]             }
[17:47:02.302]         }
[17:47:02.302]     })
[17:47:02.302]     if (TRUE) {
[17:47:02.302]         base::sink(type = "output", split = FALSE)
[17:47:02.302]         if (TRUE) {
[17:47:02.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.302]         }
[17:47:02.302]         else {
[17:47:02.302]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.302]         }
[17:47:02.302]         base::close(...future.stdout)
[17:47:02.302]         ...future.stdout <- NULL
[17:47:02.302]     }
[17:47:02.302]     ...future.result$conditions <- ...future.conditions
[17:47:02.302]     ...future.result$finished <- base::Sys.time()
[17:47:02.302]     ...future.result
[17:47:02.302] }
[17:47:02.304] assign_globals() ...
[17:47:02.304] List of 1
[17:47:02.304]  $ x: list()
[17:47:02.304]  - attr(*, "where")=List of 1
[17:47:02.304]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.304]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.304]  - attr(*, "resolved")= logi TRUE
[17:47:02.304]  - attr(*, "total_size")= num 0
[17:47:02.304]  - attr(*, "already-done")= logi TRUE
[17:47:02.306] - copied ‘x’ to environment
[17:47:02.306] assign_globals() ... done
[17:47:02.307] plan(): Setting new future strategy stack:
[17:47:02.307] List of future strategies:
[17:47:02.307] 1. sequential:
[17:47:02.307]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.307]    - tweaked: FALSE
[17:47:02.307]    - call: NULL
[17:47:02.307] plan(): nbrOfWorkers() = 1
[17:47:02.308] plan(): Setting new future strategy stack:
[17:47:02.308] List of future strategies:
[17:47:02.308] 1. sequential:
[17:47:02.308]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.308]    - tweaked: FALSE
[17:47:02.308]    - call: plan(strategy)
[17:47:02.308] plan(): nbrOfWorkers() = 1
[17:47:02.308] SequentialFuture started (and completed)
[17:47:02.309] - Launch lazy future ... done
[17:47:02.309] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.309] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.309] Searching for globals...
[17:47:02.311] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:02.311] Searching for globals ... DONE
[17:47:02.311] Resolving globals: TRUE
[17:47:02.311] Resolving any globals that are futures ...
[17:47:02.311] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:02.312] Resolving any globals that are futures ... DONE
[17:47:02.312] Resolving futures part of globals (recursively) ...
[17:47:02.312] resolve() on list ...
[17:47:02.312]  recursive: 99
[17:47:02.312]  length: 1
[17:47:02.312]  elements: ‘x’
[17:47:02.312]  length: 0 (resolved future 1)
[17:47:02.313] resolve() on list ... DONE
[17:47:02.313] - globals: [1] ‘x’
[17:47:02.313] Resolving futures part of globals (recursively) ... DONE
[17:47:02.313] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.313] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.313] - globals: [1] ‘x’
[17:47:02.313] 
[17:47:02.313] getGlobalsAndPackages() ... DONE
[17:47:02.314] run() for ‘Future’ ...
[17:47:02.314] - state: ‘created’
[17:47:02.314] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:02.314] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:02.314] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:02.314]   - Field: ‘label’
[17:47:02.314]   - Field: ‘local’
[17:47:02.314]   - Field: ‘owner’
[17:47:02.315]   - Field: ‘envir’
[17:47:02.315]   - Field: ‘packages’
[17:47:02.315]   - Field: ‘gc’
[17:47:02.315]   - Field: ‘conditions’
[17:47:02.315]   - Field: ‘expr’
[17:47:02.315]   - Field: ‘uuid’
[17:47:02.316]   - Field: ‘seed’
[17:47:02.316]   - Field: ‘version’
[17:47:02.317]   - Field: ‘result’
[17:47:02.317]   - Field: ‘asynchronous’
[17:47:02.317]   - Field: ‘calls’
[17:47:02.317]   - Field: ‘globals’
[17:47:02.317]   - Field: ‘stdout’
[17:47:02.317]   - Field: ‘earlySignal’
[17:47:02.317]   - Field: ‘lazy’
[17:47:02.317]   - Field: ‘state’
[17:47:02.317] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:02.317] - Launch lazy future ...
[17:47:02.318] Packages needed by the future expression (n = 0): <none>
[17:47:02.318] Packages needed by future strategies (n = 0): <none>
[17:47:02.318] {
[17:47:02.318]     {
[17:47:02.318]         {
[17:47:02.318]             ...future.startTime <- base::Sys.time()
[17:47:02.318]             {
[17:47:02.318]                 {
[17:47:02.318]                   {
[17:47:02.318]                     base::local({
[17:47:02.318]                       has_future <- base::requireNamespace("future", 
[17:47:02.318]                         quietly = TRUE)
[17:47:02.318]                       if (has_future) {
[17:47:02.318]                         ns <- base::getNamespace("future")
[17:47:02.318]                         version <- ns[[".package"]][["version"]]
[17:47:02.318]                         if (is.null(version)) 
[17:47:02.318]                           version <- utils::packageVersion("future")
[17:47:02.318]                       }
[17:47:02.318]                       else {
[17:47:02.318]                         version <- NULL
[17:47:02.318]                       }
[17:47:02.318]                       if (!has_future || version < "1.8.0") {
[17:47:02.318]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.318]                           "", base::R.version$version.string), 
[17:47:02.318]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:02.318]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.318]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.318]                             "release", "version")], collapse = " "), 
[17:47:02.318]                           hostname = base::Sys.info()[["nodename"]])
[17:47:02.318]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.318]                           info)
[17:47:02.318]                         info <- base::paste(info, collapse = "; ")
[17:47:02.318]                         if (!has_future) {
[17:47:02.318]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.318]                             info)
[17:47:02.318]                         }
[17:47:02.318]                         else {
[17:47:02.318]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.318]                             info, version)
[17:47:02.318]                         }
[17:47:02.318]                         base::stop(msg)
[17:47:02.318]                       }
[17:47:02.318]                     })
[17:47:02.318]                   }
[17:47:02.318]                   ...future.strategy.old <- future::plan("list")
[17:47:02.318]                   options(future.plan = NULL)
[17:47:02.318]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.318]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.318]                 }
[17:47:02.318]                 ...future.workdir <- getwd()
[17:47:02.318]             }
[17:47:02.318]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.318]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.318]         }
[17:47:02.318]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.318]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.318]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.318]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.318]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.318]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.318]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.318]             base::names(...future.oldOptions))
[17:47:02.318]     }
[17:47:02.318]     if (FALSE) {
[17:47:02.318]     }
[17:47:02.318]     else {
[17:47:02.318]         if (TRUE) {
[17:47:02.318]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.318]                 open = "w")
[17:47:02.318]         }
[17:47:02.318]         else {
[17:47:02.318]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.318]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.318]         }
[17:47:02.318]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.318]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.318]             base::sink(type = "output", split = FALSE)
[17:47:02.318]             base::close(...future.stdout)
[17:47:02.318]         }, add = TRUE)
[17:47:02.318]     }
[17:47:02.318]     ...future.frame <- base::sys.nframe()
[17:47:02.318]     ...future.conditions <- base::list()
[17:47:02.318]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.318]     if (FALSE) {
[17:47:02.318]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.318]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.318]     }
[17:47:02.318]     ...future.result <- base::tryCatch({
[17:47:02.318]         base::withCallingHandlers({
[17:47:02.318]             ...future.value <- base::withVisible(base::local({
[17:47:02.318]                 x["a"] <- list(1)
[17:47:02.318]                 x
[17:47:02.318]             }))
[17:47:02.318]             future::FutureResult(value = ...future.value$value, 
[17:47:02.318]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.318]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.318]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.318]                     ...future.globalenv.names))
[17:47:02.318]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.318]         }, condition = base::local({
[17:47:02.318]             c <- base::c
[17:47:02.318]             inherits <- base::inherits
[17:47:02.318]             invokeRestart <- base::invokeRestart
[17:47:02.318]             length <- base::length
[17:47:02.318]             list <- base::list
[17:47:02.318]             seq.int <- base::seq.int
[17:47:02.318]             signalCondition <- base::signalCondition
[17:47:02.318]             sys.calls <- base::sys.calls
[17:47:02.318]             `[[` <- base::`[[`
[17:47:02.318]             `+` <- base::`+`
[17:47:02.318]             `<<-` <- base::`<<-`
[17:47:02.318]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.318]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.318]                   3L)]
[17:47:02.318]             }
[17:47:02.318]             function(cond) {
[17:47:02.318]                 is_error <- inherits(cond, "error")
[17:47:02.318]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.318]                   NULL)
[17:47:02.318]                 if (is_error) {
[17:47:02.318]                   sessionInformation <- function() {
[17:47:02.318]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.318]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.318]                       search = base::search(), system = base::Sys.info())
[17:47:02.318]                   }
[17:47:02.318]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.318]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.318]                     cond$call), session = sessionInformation(), 
[17:47:02.318]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.318]                   signalCondition(cond)
[17:47:02.318]                 }
[17:47:02.318]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.318]                 "immediateCondition"))) {
[17:47:02.318]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.318]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.318]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.318]                   if (TRUE && !signal) {
[17:47:02.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.318]                     {
[17:47:02.318]                       inherits <- base::inherits
[17:47:02.318]                       invokeRestart <- base::invokeRestart
[17:47:02.318]                       is.null <- base::is.null
[17:47:02.318]                       muffled <- FALSE
[17:47:02.318]                       if (inherits(cond, "message")) {
[17:47:02.318]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.318]                         if (muffled) 
[17:47:02.318]                           invokeRestart("muffleMessage")
[17:47:02.318]                       }
[17:47:02.318]                       else if (inherits(cond, "warning")) {
[17:47:02.318]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.318]                         if (muffled) 
[17:47:02.318]                           invokeRestart("muffleWarning")
[17:47:02.318]                       }
[17:47:02.318]                       else if (inherits(cond, "condition")) {
[17:47:02.318]                         if (!is.null(pattern)) {
[17:47:02.318]                           computeRestarts <- base::computeRestarts
[17:47:02.318]                           grepl <- base::grepl
[17:47:02.318]                           restarts <- computeRestarts(cond)
[17:47:02.318]                           for (restart in restarts) {
[17:47:02.318]                             name <- restart$name
[17:47:02.318]                             if (is.null(name)) 
[17:47:02.318]                               next
[17:47:02.318]                             if (!grepl(pattern, name)) 
[17:47:02.318]                               next
[17:47:02.318]                             invokeRestart(restart)
[17:47:02.318]                             muffled <- TRUE
[17:47:02.318]                             break
[17:47:02.318]                           }
[17:47:02.318]                         }
[17:47:02.318]                       }
[17:47:02.318]                       invisible(muffled)
[17:47:02.318]                     }
[17:47:02.318]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.318]                   }
[17:47:02.318]                 }
[17:47:02.318]                 else {
[17:47:02.318]                   if (TRUE) {
[17:47:02.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.318]                     {
[17:47:02.318]                       inherits <- base::inherits
[17:47:02.318]                       invokeRestart <- base::invokeRestart
[17:47:02.318]                       is.null <- base::is.null
[17:47:02.318]                       muffled <- FALSE
[17:47:02.318]                       if (inherits(cond, "message")) {
[17:47:02.318]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.318]                         if (muffled) 
[17:47:02.318]                           invokeRestart("muffleMessage")
[17:47:02.318]                       }
[17:47:02.318]                       else if (inherits(cond, "warning")) {
[17:47:02.318]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.318]                         if (muffled) 
[17:47:02.318]                           invokeRestart("muffleWarning")
[17:47:02.318]                       }
[17:47:02.318]                       else if (inherits(cond, "condition")) {
[17:47:02.318]                         if (!is.null(pattern)) {
[17:47:02.318]                           computeRestarts <- base::computeRestarts
[17:47:02.318]                           grepl <- base::grepl
[17:47:02.318]                           restarts <- computeRestarts(cond)
[17:47:02.318]                           for (restart in restarts) {
[17:47:02.318]                             name <- restart$name
[17:47:02.318]                             if (is.null(name)) 
[17:47:02.318]                               next
[17:47:02.318]                             if (!grepl(pattern, name)) 
[17:47:02.318]                               next
[17:47:02.318]                             invokeRestart(restart)
[17:47:02.318]                             muffled <- TRUE
[17:47:02.318]                             break
[17:47:02.318]                           }
[17:47:02.318]                         }
[17:47:02.318]                       }
[17:47:02.318]                       invisible(muffled)
[17:47:02.318]                     }
[17:47:02.318]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.318]                   }
[17:47:02.318]                 }
[17:47:02.318]             }
[17:47:02.318]         }))
[17:47:02.318]     }, error = function(ex) {
[17:47:02.318]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.318]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.318]                 ...future.rng), started = ...future.startTime, 
[17:47:02.318]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.318]             version = "1.8"), class = "FutureResult")
[17:47:02.318]     }, finally = {
[17:47:02.318]         if (!identical(...future.workdir, getwd())) 
[17:47:02.318]             setwd(...future.workdir)
[17:47:02.318]         {
[17:47:02.318]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.318]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.318]             }
[17:47:02.318]             base::options(...future.oldOptions)
[17:47:02.318]             if (.Platform$OS.type == "windows") {
[17:47:02.318]                 old_names <- names(...future.oldEnvVars)
[17:47:02.318]                 envs <- base::Sys.getenv()
[17:47:02.318]                 names <- names(envs)
[17:47:02.318]                 common <- intersect(names, old_names)
[17:47:02.318]                 added <- setdiff(names, old_names)
[17:47:02.318]                 removed <- setdiff(old_names, names)
[17:47:02.318]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.318]                   envs[common]]
[17:47:02.318]                 NAMES <- toupper(changed)
[17:47:02.318]                 args <- list()
[17:47:02.318]                 for (kk in seq_along(NAMES)) {
[17:47:02.318]                   name <- changed[[kk]]
[17:47:02.318]                   NAME <- NAMES[[kk]]
[17:47:02.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.318]                     next
[17:47:02.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.318]                 }
[17:47:02.318]                 NAMES <- toupper(added)
[17:47:02.318]                 for (kk in seq_along(NAMES)) {
[17:47:02.318]                   name <- added[[kk]]
[17:47:02.318]                   NAME <- NAMES[[kk]]
[17:47:02.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.318]                     next
[17:47:02.318]                   args[[name]] <- ""
[17:47:02.318]                 }
[17:47:02.318]                 NAMES <- toupper(removed)
[17:47:02.318]                 for (kk in seq_along(NAMES)) {
[17:47:02.318]                   name <- removed[[kk]]
[17:47:02.318]                   NAME <- NAMES[[kk]]
[17:47:02.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.318]                     next
[17:47:02.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.318]                 }
[17:47:02.318]                 if (length(args) > 0) 
[17:47:02.318]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.318]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.318]             }
[17:47:02.318]             else {
[17:47:02.318]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.318]             }
[17:47:02.318]             {
[17:47:02.318]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.318]                   0L) {
[17:47:02.318]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.318]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.318]                   base::options(opts)
[17:47:02.318]                 }
[17:47:02.318]                 {
[17:47:02.318]                   {
[17:47:02.318]                     NULL
[17:47:02.318]                     RNGkind("Mersenne-Twister")
[17:47:02.318]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:02.318]                       inherits = FALSE)
[17:47:02.318]                   }
[17:47:02.318]                   options(future.plan = NULL)
[17:47:02.318]                   if (is.na(NA_character_)) 
[17:47:02.318]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.318]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.318]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.318]                     .init = FALSE)
[17:47:02.318]                 }
[17:47:02.318]             }
[17:47:02.318]         }
[17:47:02.318]     })
[17:47:02.318]     if (TRUE) {
[17:47:02.318]         base::sink(type = "output", split = FALSE)
[17:47:02.318]         if (TRUE) {
[17:47:02.318]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.318]         }
[17:47:02.318]         else {
[17:47:02.318]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.318]         }
[17:47:02.318]         base::close(...future.stdout)
[17:47:02.318]         ...future.stdout <- NULL
[17:47:02.318]     }
[17:47:02.318]     ...future.result$conditions <- ...future.conditions
[17:47:02.318]     ...future.result$finished <- base::Sys.time()
[17:47:02.318]     ...future.result
[17:47:02.318] }
[17:47:02.320] assign_globals() ...
[17:47:02.320] List of 1
[17:47:02.320]  $ x: list()
[17:47:02.320]  - attr(*, "where")=List of 1
[17:47:02.320]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.320]  - attr(*, "resolved")= logi TRUE
[17:47:02.320]  - attr(*, "total_size")= num 0
[17:47:02.320]  - attr(*, "already-done")= logi TRUE
[17:47:02.322] - copied ‘x’ to environment
[17:47:02.322] assign_globals() ... done
[17:47:02.322] plan(): Setting new future strategy stack:
[17:47:02.322] List of future strategies:
[17:47:02.322] 1. sequential:
[17:47:02.322]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.322]    - tweaked: FALSE
[17:47:02.322]    - call: NULL
[17:47:02.323] plan(): nbrOfWorkers() = 1
[17:47:02.323] plan(): Setting new future strategy stack:
[17:47:02.323] List of future strategies:
[17:47:02.323] 1. sequential:
[17:47:02.323]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.323]    - tweaked: FALSE
[17:47:02.323]    - call: plan(strategy)
[17:47:02.324] plan(): nbrOfWorkers() = 1
[17:47:02.324] SequentialFuture started (and completed)
[17:47:02.324] - Launch lazy future ... done
[17:47:02.324] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.325] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.325] Searching for globals...
[17:47:02.327] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:02.327] Searching for globals ... DONE
[17:47:02.327] Resolving globals: TRUE
[17:47:02.327] Resolving any globals that are futures ...
[17:47:02.327] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:02.327] Resolving any globals that are futures ... DONE
[17:47:02.327] Resolving futures part of globals (recursively) ...
[17:47:02.328] resolve() on list ...
[17:47:02.328]  recursive: 99
[17:47:02.328]  length: 1
[17:47:02.328]  elements: ‘x’
[17:47:02.328]  length: 0 (resolved future 1)
[17:47:02.328] resolve() on list ... DONE
[17:47:02.328] - globals: [1] ‘x’
[17:47:02.328] Resolving futures part of globals (recursively) ... DONE
[17:47:02.328] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.329] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.329] - globals: [1] ‘x’
[17:47:02.329] 
[17:47:02.329] getGlobalsAndPackages() ... DONE
[17:47:02.329] run() for ‘Future’ ...
[17:47:02.329] - state: ‘created’
[17:47:02.329] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:02.330] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:02.330] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:02.330]   - Field: ‘label’
[17:47:02.330]   - Field: ‘local’
[17:47:02.330]   - Field: ‘owner’
[17:47:02.330]   - Field: ‘envir’
[17:47:02.330]   - Field: ‘packages’
[17:47:02.330]   - Field: ‘gc’
[17:47:02.330]   - Field: ‘conditions’
[17:47:02.330]   - Field: ‘expr’
[17:47:02.331]   - Field: ‘uuid’
[17:47:02.331]   - Field: ‘seed’
[17:47:02.331]   - Field: ‘version’
[17:47:02.331]   - Field: ‘result’
[17:47:02.331]   - Field: ‘asynchronous’
[17:47:02.331]   - Field: ‘calls’
[17:47:02.331]   - Field: ‘globals’
[17:47:02.331]   - Field: ‘stdout’
[17:47:02.331]   - Field: ‘earlySignal’
[17:47:02.331]   - Field: ‘lazy’
[17:47:02.331]   - Field: ‘state’
[17:47:02.332] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:02.332] - Launch lazy future ...
[17:47:02.332] Packages needed by the future expression (n = 0): <none>
[17:47:02.332] Packages needed by future strategies (n = 0): <none>
[17:47:02.332] {
[17:47:02.332]     {
[17:47:02.332]         {
[17:47:02.332]             ...future.startTime <- base::Sys.time()
[17:47:02.332]             {
[17:47:02.332]                 {
[17:47:02.332]                   {
[17:47:02.332]                     base::local({
[17:47:02.332]                       has_future <- base::requireNamespace("future", 
[17:47:02.332]                         quietly = TRUE)
[17:47:02.332]                       if (has_future) {
[17:47:02.332]                         ns <- base::getNamespace("future")
[17:47:02.332]                         version <- ns[[".package"]][["version"]]
[17:47:02.332]                         if (is.null(version)) 
[17:47:02.332]                           version <- utils::packageVersion("future")
[17:47:02.332]                       }
[17:47:02.332]                       else {
[17:47:02.332]                         version <- NULL
[17:47:02.332]                       }
[17:47:02.332]                       if (!has_future || version < "1.8.0") {
[17:47:02.332]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.332]                           "", base::R.version$version.string), 
[17:47:02.332]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:02.332]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.332]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.332]                             "release", "version")], collapse = " "), 
[17:47:02.332]                           hostname = base::Sys.info()[["nodename"]])
[17:47:02.332]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.332]                           info)
[17:47:02.332]                         info <- base::paste(info, collapse = "; ")
[17:47:02.332]                         if (!has_future) {
[17:47:02.332]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.332]                             info)
[17:47:02.332]                         }
[17:47:02.332]                         else {
[17:47:02.332]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.332]                             info, version)
[17:47:02.332]                         }
[17:47:02.332]                         base::stop(msg)
[17:47:02.332]                       }
[17:47:02.332]                     })
[17:47:02.332]                   }
[17:47:02.332]                   ...future.strategy.old <- future::plan("list")
[17:47:02.332]                   options(future.plan = NULL)
[17:47:02.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.332]                 }
[17:47:02.332]                 ...future.workdir <- getwd()
[17:47:02.332]             }
[17:47:02.332]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.332]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.332]         }
[17:47:02.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.332]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.332]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.332]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.332]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.332]             base::names(...future.oldOptions))
[17:47:02.332]     }
[17:47:02.332]     if (FALSE) {
[17:47:02.332]     }
[17:47:02.332]     else {
[17:47:02.332]         if (TRUE) {
[17:47:02.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.332]                 open = "w")
[17:47:02.332]         }
[17:47:02.332]         else {
[17:47:02.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.332]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.332]         }
[17:47:02.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.332]             base::sink(type = "output", split = FALSE)
[17:47:02.332]             base::close(...future.stdout)
[17:47:02.332]         }, add = TRUE)
[17:47:02.332]     }
[17:47:02.332]     ...future.frame <- base::sys.nframe()
[17:47:02.332]     ...future.conditions <- base::list()
[17:47:02.332]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.332]     if (FALSE) {
[17:47:02.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.332]     }
[17:47:02.332]     ...future.result <- base::tryCatch({
[17:47:02.332]         base::withCallingHandlers({
[17:47:02.332]             ...future.value <- base::withVisible(base::local({
[17:47:02.332]                 x["a"] <- list(1)
[17:47:02.332]                 x
[17:47:02.332]             }))
[17:47:02.332]             future::FutureResult(value = ...future.value$value, 
[17:47:02.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.332]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.332]                     ...future.globalenv.names))
[17:47:02.332]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.332]         }, condition = base::local({
[17:47:02.332]             c <- base::c
[17:47:02.332]             inherits <- base::inherits
[17:47:02.332]             invokeRestart <- base::invokeRestart
[17:47:02.332]             length <- base::length
[17:47:02.332]             list <- base::list
[17:47:02.332]             seq.int <- base::seq.int
[17:47:02.332]             signalCondition <- base::signalCondition
[17:47:02.332]             sys.calls <- base::sys.calls
[17:47:02.332]             `[[` <- base::`[[`
[17:47:02.332]             `+` <- base::`+`
[17:47:02.332]             `<<-` <- base::`<<-`
[17:47:02.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.332]                   3L)]
[17:47:02.332]             }
[17:47:02.332]             function(cond) {
[17:47:02.332]                 is_error <- inherits(cond, "error")
[17:47:02.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.332]                   NULL)
[17:47:02.332]                 if (is_error) {
[17:47:02.332]                   sessionInformation <- function() {
[17:47:02.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.332]                       search = base::search(), system = base::Sys.info())
[17:47:02.332]                   }
[17:47:02.332]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.332]                     cond$call), session = sessionInformation(), 
[17:47:02.332]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.332]                   signalCondition(cond)
[17:47:02.332]                 }
[17:47:02.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.332]                 "immediateCondition"))) {
[17:47:02.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.332]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.332]                   if (TRUE && !signal) {
[17:47:02.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.332]                     {
[17:47:02.332]                       inherits <- base::inherits
[17:47:02.332]                       invokeRestart <- base::invokeRestart
[17:47:02.332]                       is.null <- base::is.null
[17:47:02.332]                       muffled <- FALSE
[17:47:02.332]                       if (inherits(cond, "message")) {
[17:47:02.332]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.332]                         if (muffled) 
[17:47:02.332]                           invokeRestart("muffleMessage")
[17:47:02.332]                       }
[17:47:02.332]                       else if (inherits(cond, "warning")) {
[17:47:02.332]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.332]                         if (muffled) 
[17:47:02.332]                           invokeRestart("muffleWarning")
[17:47:02.332]                       }
[17:47:02.332]                       else if (inherits(cond, "condition")) {
[17:47:02.332]                         if (!is.null(pattern)) {
[17:47:02.332]                           computeRestarts <- base::computeRestarts
[17:47:02.332]                           grepl <- base::grepl
[17:47:02.332]                           restarts <- computeRestarts(cond)
[17:47:02.332]                           for (restart in restarts) {
[17:47:02.332]                             name <- restart$name
[17:47:02.332]                             if (is.null(name)) 
[17:47:02.332]                               next
[17:47:02.332]                             if (!grepl(pattern, name)) 
[17:47:02.332]                               next
[17:47:02.332]                             invokeRestart(restart)
[17:47:02.332]                             muffled <- TRUE
[17:47:02.332]                             break
[17:47:02.332]                           }
[17:47:02.332]                         }
[17:47:02.332]                       }
[17:47:02.332]                       invisible(muffled)
[17:47:02.332]                     }
[17:47:02.332]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.332]                   }
[17:47:02.332]                 }
[17:47:02.332]                 else {
[17:47:02.332]                   if (TRUE) {
[17:47:02.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.332]                     {
[17:47:02.332]                       inherits <- base::inherits
[17:47:02.332]                       invokeRestart <- base::invokeRestart
[17:47:02.332]                       is.null <- base::is.null
[17:47:02.332]                       muffled <- FALSE
[17:47:02.332]                       if (inherits(cond, "message")) {
[17:47:02.332]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.332]                         if (muffled) 
[17:47:02.332]                           invokeRestart("muffleMessage")
[17:47:02.332]                       }
[17:47:02.332]                       else if (inherits(cond, "warning")) {
[17:47:02.332]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.332]                         if (muffled) 
[17:47:02.332]                           invokeRestart("muffleWarning")
[17:47:02.332]                       }
[17:47:02.332]                       else if (inherits(cond, "condition")) {
[17:47:02.332]                         if (!is.null(pattern)) {
[17:47:02.332]                           computeRestarts <- base::computeRestarts
[17:47:02.332]                           grepl <- base::grepl
[17:47:02.332]                           restarts <- computeRestarts(cond)
[17:47:02.332]                           for (restart in restarts) {
[17:47:02.332]                             name <- restart$name
[17:47:02.332]                             if (is.null(name)) 
[17:47:02.332]                               next
[17:47:02.332]                             if (!grepl(pattern, name)) 
[17:47:02.332]                               next
[17:47:02.332]                             invokeRestart(restart)
[17:47:02.332]                             muffled <- TRUE
[17:47:02.332]                             break
[17:47:02.332]                           }
[17:47:02.332]                         }
[17:47:02.332]                       }
[17:47:02.332]                       invisible(muffled)
[17:47:02.332]                     }
[17:47:02.332]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.332]                   }
[17:47:02.332]                 }
[17:47:02.332]             }
[17:47:02.332]         }))
[17:47:02.332]     }, error = function(ex) {
[17:47:02.332]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.332]                 ...future.rng), started = ...future.startTime, 
[17:47:02.332]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.332]             version = "1.8"), class = "FutureResult")
[17:47:02.332]     }, finally = {
[17:47:02.332]         if (!identical(...future.workdir, getwd())) 
[17:47:02.332]             setwd(...future.workdir)
[17:47:02.332]         {
[17:47:02.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.332]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.332]             }
[17:47:02.332]             base::options(...future.oldOptions)
[17:47:02.332]             if (.Platform$OS.type == "windows") {
[17:47:02.332]                 old_names <- names(...future.oldEnvVars)
[17:47:02.332]                 envs <- base::Sys.getenv()
[17:47:02.332]                 names <- names(envs)
[17:47:02.332]                 common <- intersect(names, old_names)
[17:47:02.332]                 added <- setdiff(names, old_names)
[17:47:02.332]                 removed <- setdiff(old_names, names)
[17:47:02.332]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.332]                   envs[common]]
[17:47:02.332]                 NAMES <- toupper(changed)
[17:47:02.332]                 args <- list()
[17:47:02.332]                 for (kk in seq_along(NAMES)) {
[17:47:02.332]                   name <- changed[[kk]]
[17:47:02.332]                   NAME <- NAMES[[kk]]
[17:47:02.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.332]                     next
[17:47:02.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.332]                 }
[17:47:02.332]                 NAMES <- toupper(added)
[17:47:02.332]                 for (kk in seq_along(NAMES)) {
[17:47:02.332]                   name <- added[[kk]]
[17:47:02.332]                   NAME <- NAMES[[kk]]
[17:47:02.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.332]                     next
[17:47:02.332]                   args[[name]] <- ""
[17:47:02.332]                 }
[17:47:02.332]                 NAMES <- toupper(removed)
[17:47:02.332]                 for (kk in seq_along(NAMES)) {
[17:47:02.332]                   name <- removed[[kk]]
[17:47:02.332]                   NAME <- NAMES[[kk]]
[17:47:02.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.332]                     next
[17:47:02.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.332]                 }
[17:47:02.332]                 if (length(args) > 0) 
[17:47:02.332]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.332]             }
[17:47:02.332]             else {
[17:47:02.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.332]             }
[17:47:02.332]             {
[17:47:02.332]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.332]                   0L) {
[17:47:02.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.332]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.332]                   base::options(opts)
[17:47:02.332]                 }
[17:47:02.332]                 {
[17:47:02.332]                   {
[17:47:02.332]                     NULL
[17:47:02.332]                     RNGkind("Mersenne-Twister")
[17:47:02.332]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:02.332]                       inherits = FALSE)
[17:47:02.332]                   }
[17:47:02.332]                   options(future.plan = NULL)
[17:47:02.332]                   if (is.na(NA_character_)) 
[17:47:02.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.332]                     .init = FALSE)
[17:47:02.332]                 }
[17:47:02.332]             }
[17:47:02.332]         }
[17:47:02.332]     })
[17:47:02.332]     if (TRUE) {
[17:47:02.332]         base::sink(type = "output", split = FALSE)
[17:47:02.332]         if (TRUE) {
[17:47:02.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.332]         }
[17:47:02.332]         else {
[17:47:02.332]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.332]         }
[17:47:02.332]         base::close(...future.stdout)
[17:47:02.332]         ...future.stdout <- NULL
[17:47:02.332]     }
[17:47:02.332]     ...future.result$conditions <- ...future.conditions
[17:47:02.332]     ...future.result$finished <- base::Sys.time()
[17:47:02.332]     ...future.result
[17:47:02.332] }
[17:47:02.334] assign_globals() ...
[17:47:02.334] List of 1
[17:47:02.334]  $ x: list()
[17:47:02.334]  - attr(*, "where")=List of 1
[17:47:02.334]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.334]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.334]  - attr(*, "resolved")= logi TRUE
[17:47:02.334]  - attr(*, "total_size")= num 0
[17:47:02.334]  - attr(*, "already-done")= logi TRUE
[17:47:02.336] - copied ‘x’ to environment
[17:47:02.336] assign_globals() ... done
[17:47:02.336] plan(): Setting new future strategy stack:
[17:47:02.336] List of future strategies:
[17:47:02.336] 1. sequential:
[17:47:02.336]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.336]    - tweaked: FALSE
[17:47:02.336]    - call: NULL
[17:47:02.337] plan(): nbrOfWorkers() = 1
[17:47:02.338] plan(): Setting new future strategy stack:
[17:47:02.338] List of future strategies:
[17:47:02.338] 1. sequential:
[17:47:02.338]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.338]    - tweaked: FALSE
[17:47:02.338]    - call: plan(strategy)
[17:47:02.338] plan(): nbrOfWorkers() = 1
[17:47:02.338] SequentialFuture started (and completed)
[17:47:02.338] - Launch lazy future ... done
[17:47:02.338] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.339] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.339] Searching for globals...
[17:47:02.341] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:02.341] Searching for globals ... DONE
[17:47:02.341] Resolving globals: TRUE
[17:47:02.341] Resolving any globals that are futures ...
[17:47:02.341] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:02.341] Resolving any globals that are futures ... DONE
[17:47:02.342] Resolving futures part of globals (recursively) ...
[17:47:02.343] resolve() on list ...
[17:47:02.343]  recursive: 99
[17:47:02.344]  length: 1
[17:47:02.344]  elements: ‘x’
[17:47:02.344]  length: 0 (resolved future 1)
[17:47:02.344] resolve() on list ... DONE
[17:47:02.344] - globals: [1] ‘x’
[17:47:02.344] Resolving futures part of globals (recursively) ... DONE
[17:47:02.344] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.344] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.345] - globals: [1] ‘x’
[17:47:02.345] 
[17:47:02.345] getGlobalsAndPackages() ... DONE
[17:47:02.345] run() for ‘Future’ ...
[17:47:02.345] - state: ‘created’
[17:47:02.345] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:02.345] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:02.346] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:02.346]   - Field: ‘label’
[17:47:02.346]   - Field: ‘local’
[17:47:02.346]   - Field: ‘owner’
[17:47:02.346]   - Field: ‘envir’
[17:47:02.346]   - Field: ‘packages’
[17:47:02.346]   - Field: ‘gc’
[17:47:02.346]   - Field: ‘conditions’
[17:47:02.346]   - Field: ‘expr’
[17:47:02.346]   - Field: ‘uuid’
[17:47:02.346]   - Field: ‘seed’
[17:47:02.347]   - Field: ‘version’
[17:47:02.347]   - Field: ‘result’
[17:47:02.347]   - Field: ‘asynchronous’
[17:47:02.347]   - Field: ‘calls’
[17:47:02.347]   - Field: ‘globals’
[17:47:02.347]   - Field: ‘stdout’
[17:47:02.347]   - Field: ‘earlySignal’
[17:47:02.347]   - Field: ‘lazy’
[17:47:02.347]   - Field: ‘state’
[17:47:02.347] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:02.347] - Launch lazy future ...
[17:47:02.348] Packages needed by the future expression (n = 0): <none>
[17:47:02.348] Packages needed by future strategies (n = 0): <none>
[17:47:02.348] {
[17:47:02.348]     {
[17:47:02.348]         {
[17:47:02.348]             ...future.startTime <- base::Sys.time()
[17:47:02.348]             {
[17:47:02.348]                 {
[17:47:02.348]                   {
[17:47:02.348]                     base::local({
[17:47:02.348]                       has_future <- base::requireNamespace("future", 
[17:47:02.348]                         quietly = TRUE)
[17:47:02.348]                       if (has_future) {
[17:47:02.348]                         ns <- base::getNamespace("future")
[17:47:02.348]                         version <- ns[[".package"]][["version"]]
[17:47:02.348]                         if (is.null(version)) 
[17:47:02.348]                           version <- utils::packageVersion("future")
[17:47:02.348]                       }
[17:47:02.348]                       else {
[17:47:02.348]                         version <- NULL
[17:47:02.348]                       }
[17:47:02.348]                       if (!has_future || version < "1.8.0") {
[17:47:02.348]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.348]                           "", base::R.version$version.string), 
[17:47:02.348]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:02.348]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.348]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.348]                             "release", "version")], collapse = " "), 
[17:47:02.348]                           hostname = base::Sys.info()[["nodename"]])
[17:47:02.348]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.348]                           info)
[17:47:02.348]                         info <- base::paste(info, collapse = "; ")
[17:47:02.348]                         if (!has_future) {
[17:47:02.348]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.348]                             info)
[17:47:02.348]                         }
[17:47:02.348]                         else {
[17:47:02.348]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.348]                             info, version)
[17:47:02.348]                         }
[17:47:02.348]                         base::stop(msg)
[17:47:02.348]                       }
[17:47:02.348]                     })
[17:47:02.348]                   }
[17:47:02.348]                   ...future.strategy.old <- future::plan("list")
[17:47:02.348]                   options(future.plan = NULL)
[17:47:02.348]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.348]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.348]                 }
[17:47:02.348]                 ...future.workdir <- getwd()
[17:47:02.348]             }
[17:47:02.348]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.348]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.348]         }
[17:47:02.348]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.348]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.348]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.348]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.348]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.348]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.348]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.348]             base::names(...future.oldOptions))
[17:47:02.348]     }
[17:47:02.348]     if (FALSE) {
[17:47:02.348]     }
[17:47:02.348]     else {
[17:47:02.348]         if (TRUE) {
[17:47:02.348]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.348]                 open = "w")
[17:47:02.348]         }
[17:47:02.348]         else {
[17:47:02.348]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.348]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.348]         }
[17:47:02.348]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.348]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.348]             base::sink(type = "output", split = FALSE)
[17:47:02.348]             base::close(...future.stdout)
[17:47:02.348]         }, add = TRUE)
[17:47:02.348]     }
[17:47:02.348]     ...future.frame <- base::sys.nframe()
[17:47:02.348]     ...future.conditions <- base::list()
[17:47:02.348]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.348]     if (FALSE) {
[17:47:02.348]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.348]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.348]     }
[17:47:02.348]     ...future.result <- base::tryCatch({
[17:47:02.348]         base::withCallingHandlers({
[17:47:02.348]             ...future.value <- base::withVisible(base::local({
[17:47:02.348]                 x["a"] <- list(1)
[17:47:02.348]                 x
[17:47:02.348]             }))
[17:47:02.348]             future::FutureResult(value = ...future.value$value, 
[17:47:02.348]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.348]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.348]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.348]                     ...future.globalenv.names))
[17:47:02.348]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.348]         }, condition = base::local({
[17:47:02.348]             c <- base::c
[17:47:02.348]             inherits <- base::inherits
[17:47:02.348]             invokeRestart <- base::invokeRestart
[17:47:02.348]             length <- base::length
[17:47:02.348]             list <- base::list
[17:47:02.348]             seq.int <- base::seq.int
[17:47:02.348]             signalCondition <- base::signalCondition
[17:47:02.348]             sys.calls <- base::sys.calls
[17:47:02.348]             `[[` <- base::`[[`
[17:47:02.348]             `+` <- base::`+`
[17:47:02.348]             `<<-` <- base::`<<-`
[17:47:02.348]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.348]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.348]                   3L)]
[17:47:02.348]             }
[17:47:02.348]             function(cond) {
[17:47:02.348]                 is_error <- inherits(cond, "error")
[17:47:02.348]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.348]                   NULL)
[17:47:02.348]                 if (is_error) {
[17:47:02.348]                   sessionInformation <- function() {
[17:47:02.348]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.348]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.348]                       search = base::search(), system = base::Sys.info())
[17:47:02.348]                   }
[17:47:02.348]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.348]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.348]                     cond$call), session = sessionInformation(), 
[17:47:02.348]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.348]                   signalCondition(cond)
[17:47:02.348]                 }
[17:47:02.348]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.348]                 "immediateCondition"))) {
[17:47:02.348]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.348]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.348]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.348]                   if (TRUE && !signal) {
[17:47:02.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.348]                     {
[17:47:02.348]                       inherits <- base::inherits
[17:47:02.348]                       invokeRestart <- base::invokeRestart
[17:47:02.348]                       is.null <- base::is.null
[17:47:02.348]                       muffled <- FALSE
[17:47:02.348]                       if (inherits(cond, "message")) {
[17:47:02.348]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.348]                         if (muffled) 
[17:47:02.348]                           invokeRestart("muffleMessage")
[17:47:02.348]                       }
[17:47:02.348]                       else if (inherits(cond, "warning")) {
[17:47:02.348]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.348]                         if (muffled) 
[17:47:02.348]                           invokeRestart("muffleWarning")
[17:47:02.348]                       }
[17:47:02.348]                       else if (inherits(cond, "condition")) {
[17:47:02.348]                         if (!is.null(pattern)) {
[17:47:02.348]                           computeRestarts <- base::computeRestarts
[17:47:02.348]                           grepl <- base::grepl
[17:47:02.348]                           restarts <- computeRestarts(cond)
[17:47:02.348]                           for (restart in restarts) {
[17:47:02.348]                             name <- restart$name
[17:47:02.348]                             if (is.null(name)) 
[17:47:02.348]                               next
[17:47:02.348]                             if (!grepl(pattern, name)) 
[17:47:02.348]                               next
[17:47:02.348]                             invokeRestart(restart)
[17:47:02.348]                             muffled <- TRUE
[17:47:02.348]                             break
[17:47:02.348]                           }
[17:47:02.348]                         }
[17:47:02.348]                       }
[17:47:02.348]                       invisible(muffled)
[17:47:02.348]                     }
[17:47:02.348]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.348]                   }
[17:47:02.348]                 }
[17:47:02.348]                 else {
[17:47:02.348]                   if (TRUE) {
[17:47:02.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.348]                     {
[17:47:02.348]                       inherits <- base::inherits
[17:47:02.348]                       invokeRestart <- base::invokeRestart
[17:47:02.348]                       is.null <- base::is.null
[17:47:02.348]                       muffled <- FALSE
[17:47:02.348]                       if (inherits(cond, "message")) {
[17:47:02.348]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.348]                         if (muffled) 
[17:47:02.348]                           invokeRestart("muffleMessage")
[17:47:02.348]                       }
[17:47:02.348]                       else if (inherits(cond, "warning")) {
[17:47:02.348]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.348]                         if (muffled) 
[17:47:02.348]                           invokeRestart("muffleWarning")
[17:47:02.348]                       }
[17:47:02.348]                       else if (inherits(cond, "condition")) {
[17:47:02.348]                         if (!is.null(pattern)) {
[17:47:02.348]                           computeRestarts <- base::computeRestarts
[17:47:02.348]                           grepl <- base::grepl
[17:47:02.348]                           restarts <- computeRestarts(cond)
[17:47:02.348]                           for (restart in restarts) {
[17:47:02.348]                             name <- restart$name
[17:47:02.348]                             if (is.null(name)) 
[17:47:02.348]                               next
[17:47:02.348]                             if (!grepl(pattern, name)) 
[17:47:02.348]                               next
[17:47:02.348]                             invokeRestart(restart)
[17:47:02.348]                             muffled <- TRUE
[17:47:02.348]                             break
[17:47:02.348]                           }
[17:47:02.348]                         }
[17:47:02.348]                       }
[17:47:02.348]                       invisible(muffled)
[17:47:02.348]                     }
[17:47:02.348]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.348]                   }
[17:47:02.348]                 }
[17:47:02.348]             }
[17:47:02.348]         }))
[17:47:02.348]     }, error = function(ex) {
[17:47:02.348]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.348]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.348]                 ...future.rng), started = ...future.startTime, 
[17:47:02.348]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.348]             version = "1.8"), class = "FutureResult")
[17:47:02.348]     }, finally = {
[17:47:02.348]         if (!identical(...future.workdir, getwd())) 
[17:47:02.348]             setwd(...future.workdir)
[17:47:02.348]         {
[17:47:02.348]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.348]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.348]             }
[17:47:02.348]             base::options(...future.oldOptions)
[17:47:02.348]             if (.Platform$OS.type == "windows") {
[17:47:02.348]                 old_names <- names(...future.oldEnvVars)
[17:47:02.348]                 envs <- base::Sys.getenv()
[17:47:02.348]                 names <- names(envs)
[17:47:02.348]                 common <- intersect(names, old_names)
[17:47:02.348]                 added <- setdiff(names, old_names)
[17:47:02.348]                 removed <- setdiff(old_names, names)
[17:47:02.348]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.348]                   envs[common]]
[17:47:02.348]                 NAMES <- toupper(changed)
[17:47:02.348]                 args <- list()
[17:47:02.348]                 for (kk in seq_along(NAMES)) {
[17:47:02.348]                   name <- changed[[kk]]
[17:47:02.348]                   NAME <- NAMES[[kk]]
[17:47:02.348]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.348]                     next
[17:47:02.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.348]                 }
[17:47:02.348]                 NAMES <- toupper(added)
[17:47:02.348]                 for (kk in seq_along(NAMES)) {
[17:47:02.348]                   name <- added[[kk]]
[17:47:02.348]                   NAME <- NAMES[[kk]]
[17:47:02.348]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.348]                     next
[17:47:02.348]                   args[[name]] <- ""
[17:47:02.348]                 }
[17:47:02.348]                 NAMES <- toupper(removed)
[17:47:02.348]                 for (kk in seq_along(NAMES)) {
[17:47:02.348]                   name <- removed[[kk]]
[17:47:02.348]                   NAME <- NAMES[[kk]]
[17:47:02.348]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.348]                     next
[17:47:02.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.348]                 }
[17:47:02.348]                 if (length(args) > 0) 
[17:47:02.348]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.348]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.348]             }
[17:47:02.348]             else {
[17:47:02.348]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.348]             }
[17:47:02.348]             {
[17:47:02.348]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.348]                   0L) {
[17:47:02.348]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.348]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.348]                   base::options(opts)
[17:47:02.348]                 }
[17:47:02.348]                 {
[17:47:02.348]                   {
[17:47:02.348]                     NULL
[17:47:02.348]                     RNGkind("Mersenne-Twister")
[17:47:02.348]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:02.348]                       inherits = FALSE)
[17:47:02.348]                   }
[17:47:02.348]                   options(future.plan = NULL)
[17:47:02.348]                   if (is.na(NA_character_)) 
[17:47:02.348]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.348]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.348]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.348]                     .init = FALSE)
[17:47:02.348]                 }
[17:47:02.348]             }
[17:47:02.348]         }
[17:47:02.348]     })
[17:47:02.348]     if (TRUE) {
[17:47:02.348]         base::sink(type = "output", split = FALSE)
[17:47:02.348]         if (TRUE) {
[17:47:02.348]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.348]         }
[17:47:02.348]         else {
[17:47:02.348]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.348]         }
[17:47:02.348]         base::close(...future.stdout)
[17:47:02.348]         ...future.stdout <- NULL
[17:47:02.348]     }
[17:47:02.348]     ...future.result$conditions <- ...future.conditions
[17:47:02.348]     ...future.result$finished <- base::Sys.time()
[17:47:02.348]     ...future.result
[17:47:02.348] }
[17:47:02.350] assign_globals() ...
[17:47:02.350] List of 1
[17:47:02.350]  $ x: list()
[17:47:02.350]  - attr(*, "where")=List of 1
[17:47:02.350]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.350]  - attr(*, "resolved")= logi TRUE
[17:47:02.350]  - attr(*, "total_size")= num 0
[17:47:02.350]  - attr(*, "already-done")= logi TRUE
[17:47:02.352] - copied ‘x’ to environment
[17:47:02.352] assign_globals() ... done
[17:47:02.352] plan(): Setting new future strategy stack:
[17:47:02.352] List of future strategies:
[17:47:02.352] 1. sequential:
[17:47:02.352]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.352]    - tweaked: FALSE
[17:47:02.352]    - call: NULL
[17:47:02.353] plan(): nbrOfWorkers() = 1
[17:47:02.353] plan(): Setting new future strategy stack:
[17:47:02.353] List of future strategies:
[17:47:02.353] 1. sequential:
[17:47:02.353]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.353]    - tweaked: FALSE
[17:47:02.353]    - call: plan(strategy)
[17:47:02.354] plan(): nbrOfWorkers() = 1
[17:47:02.354] SequentialFuture started (and completed)
[17:47:02.354] - Launch lazy future ... done
[17:47:02.354] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.355] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.355] Searching for globals...
[17:47:02.357] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:47:02.357] Searching for globals ... DONE
[17:47:02.357] Resolving globals: TRUE
[17:47:02.357] Resolving any globals that are futures ...
[17:47:02.357] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:47:02.357] Resolving any globals that are futures ... DONE
[17:47:02.358] Resolving futures part of globals (recursively) ...
[17:47:02.358] resolve() on list ...
[17:47:02.358]  recursive: 99
[17:47:02.358]  length: 2
[17:47:02.358]  elements: ‘x’, ‘name’
[17:47:02.358]  length: 1 (resolved future 1)
[17:47:02.358]  length: 0 (resolved future 2)
[17:47:02.359] resolve() on list ... DONE
[17:47:02.359] - globals: [2] ‘x’, ‘name’
[17:47:02.359] Resolving futures part of globals (recursively) ... DONE
[17:47:02.359] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:02.359] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[17:47:02.359] - globals: [2] ‘x’, ‘name’
[17:47:02.360] 
[17:47:02.360] getGlobalsAndPackages() ... DONE
[17:47:02.360] run() for ‘Future’ ...
[17:47:02.360] - state: ‘created’
[17:47:02.360] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:02.360] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:02.360] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:02.360]   - Field: ‘label’
[17:47:02.361]   - Field: ‘local’
[17:47:02.361]   - Field: ‘owner’
[17:47:02.361]   - Field: ‘envir’
[17:47:02.361]   - Field: ‘packages’
[17:47:02.361]   - Field: ‘gc’
[17:47:02.361]   - Field: ‘conditions’
[17:47:02.361]   - Field: ‘expr’
[17:47:02.361]   - Field: ‘uuid’
[17:47:02.361]   - Field: ‘seed’
[17:47:02.361]   - Field: ‘version’
[17:47:02.361]   - Field: ‘result’
[17:47:02.362]   - Field: ‘asynchronous’
[17:47:02.362]   - Field: ‘calls’
[17:47:02.362]   - Field: ‘globals’
[17:47:02.362]   - Field: ‘stdout’
[17:47:02.362]   - Field: ‘earlySignal’
[17:47:02.362]   - Field: ‘lazy’
[17:47:02.362]   - Field: ‘state’
[17:47:02.362] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:02.362] - Launch lazy future ...
[17:47:02.362] Packages needed by the future expression (n = 0): <none>
[17:47:02.363] Packages needed by future strategies (n = 0): <none>
[17:47:02.363] {
[17:47:02.363]     {
[17:47:02.363]         {
[17:47:02.363]             ...future.startTime <- base::Sys.time()
[17:47:02.363]             {
[17:47:02.363]                 {
[17:47:02.363]                   {
[17:47:02.363]                     base::local({
[17:47:02.363]                       has_future <- base::requireNamespace("future", 
[17:47:02.363]                         quietly = TRUE)
[17:47:02.363]                       if (has_future) {
[17:47:02.363]                         ns <- base::getNamespace("future")
[17:47:02.363]                         version <- ns[[".package"]][["version"]]
[17:47:02.363]                         if (is.null(version)) 
[17:47:02.363]                           version <- utils::packageVersion("future")
[17:47:02.363]                       }
[17:47:02.363]                       else {
[17:47:02.363]                         version <- NULL
[17:47:02.363]                       }
[17:47:02.363]                       if (!has_future || version < "1.8.0") {
[17:47:02.363]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.363]                           "", base::R.version$version.string), 
[17:47:02.363]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:02.363]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.363]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.363]                             "release", "version")], collapse = " "), 
[17:47:02.363]                           hostname = base::Sys.info()[["nodename"]])
[17:47:02.363]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.363]                           info)
[17:47:02.363]                         info <- base::paste(info, collapse = "; ")
[17:47:02.363]                         if (!has_future) {
[17:47:02.363]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.363]                             info)
[17:47:02.363]                         }
[17:47:02.363]                         else {
[17:47:02.363]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.363]                             info, version)
[17:47:02.363]                         }
[17:47:02.363]                         base::stop(msg)
[17:47:02.363]                       }
[17:47:02.363]                     })
[17:47:02.363]                   }
[17:47:02.363]                   ...future.strategy.old <- future::plan("list")
[17:47:02.363]                   options(future.plan = NULL)
[17:47:02.363]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.363]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.363]                 }
[17:47:02.363]                 ...future.workdir <- getwd()
[17:47:02.363]             }
[17:47:02.363]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.363]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.363]         }
[17:47:02.363]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.363]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.363]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.363]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.363]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.363]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.363]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.363]             base::names(...future.oldOptions))
[17:47:02.363]     }
[17:47:02.363]     if (FALSE) {
[17:47:02.363]     }
[17:47:02.363]     else {
[17:47:02.363]         if (TRUE) {
[17:47:02.363]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.363]                 open = "w")
[17:47:02.363]         }
[17:47:02.363]         else {
[17:47:02.363]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.363]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.363]         }
[17:47:02.363]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.363]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.363]             base::sink(type = "output", split = FALSE)
[17:47:02.363]             base::close(...future.stdout)
[17:47:02.363]         }, add = TRUE)
[17:47:02.363]     }
[17:47:02.363]     ...future.frame <- base::sys.nframe()
[17:47:02.363]     ...future.conditions <- base::list()
[17:47:02.363]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.363]     if (FALSE) {
[17:47:02.363]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.363]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.363]     }
[17:47:02.363]     ...future.result <- base::tryCatch({
[17:47:02.363]         base::withCallingHandlers({
[17:47:02.363]             ...future.value <- base::withVisible(base::local({
[17:47:02.363]                 x[name] <- list(1)
[17:47:02.363]                 x
[17:47:02.363]             }))
[17:47:02.363]             future::FutureResult(value = ...future.value$value, 
[17:47:02.363]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.363]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.363]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.363]                     ...future.globalenv.names))
[17:47:02.363]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.363]         }, condition = base::local({
[17:47:02.363]             c <- base::c
[17:47:02.363]             inherits <- base::inherits
[17:47:02.363]             invokeRestart <- base::invokeRestart
[17:47:02.363]             length <- base::length
[17:47:02.363]             list <- base::list
[17:47:02.363]             seq.int <- base::seq.int
[17:47:02.363]             signalCondition <- base::signalCondition
[17:47:02.363]             sys.calls <- base::sys.calls
[17:47:02.363]             `[[` <- base::`[[`
[17:47:02.363]             `+` <- base::`+`
[17:47:02.363]             `<<-` <- base::`<<-`
[17:47:02.363]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.363]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.363]                   3L)]
[17:47:02.363]             }
[17:47:02.363]             function(cond) {
[17:47:02.363]                 is_error <- inherits(cond, "error")
[17:47:02.363]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.363]                   NULL)
[17:47:02.363]                 if (is_error) {
[17:47:02.363]                   sessionInformation <- function() {
[17:47:02.363]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.363]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.363]                       search = base::search(), system = base::Sys.info())
[17:47:02.363]                   }
[17:47:02.363]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.363]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.363]                     cond$call), session = sessionInformation(), 
[17:47:02.363]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.363]                   signalCondition(cond)
[17:47:02.363]                 }
[17:47:02.363]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.363]                 "immediateCondition"))) {
[17:47:02.363]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.363]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.363]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.363]                   if (TRUE && !signal) {
[17:47:02.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.363]                     {
[17:47:02.363]                       inherits <- base::inherits
[17:47:02.363]                       invokeRestart <- base::invokeRestart
[17:47:02.363]                       is.null <- base::is.null
[17:47:02.363]                       muffled <- FALSE
[17:47:02.363]                       if (inherits(cond, "message")) {
[17:47:02.363]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.363]                         if (muffled) 
[17:47:02.363]                           invokeRestart("muffleMessage")
[17:47:02.363]                       }
[17:47:02.363]                       else if (inherits(cond, "warning")) {
[17:47:02.363]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.363]                         if (muffled) 
[17:47:02.363]                           invokeRestart("muffleWarning")
[17:47:02.363]                       }
[17:47:02.363]                       else if (inherits(cond, "condition")) {
[17:47:02.363]                         if (!is.null(pattern)) {
[17:47:02.363]                           computeRestarts <- base::computeRestarts
[17:47:02.363]                           grepl <- base::grepl
[17:47:02.363]                           restarts <- computeRestarts(cond)
[17:47:02.363]                           for (restart in restarts) {
[17:47:02.363]                             name <- restart$name
[17:47:02.363]                             if (is.null(name)) 
[17:47:02.363]                               next
[17:47:02.363]                             if (!grepl(pattern, name)) 
[17:47:02.363]                               next
[17:47:02.363]                             invokeRestart(restart)
[17:47:02.363]                             muffled <- TRUE
[17:47:02.363]                             break
[17:47:02.363]                           }
[17:47:02.363]                         }
[17:47:02.363]                       }
[17:47:02.363]                       invisible(muffled)
[17:47:02.363]                     }
[17:47:02.363]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.363]                   }
[17:47:02.363]                 }
[17:47:02.363]                 else {
[17:47:02.363]                   if (TRUE) {
[17:47:02.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.363]                     {
[17:47:02.363]                       inherits <- base::inherits
[17:47:02.363]                       invokeRestart <- base::invokeRestart
[17:47:02.363]                       is.null <- base::is.null
[17:47:02.363]                       muffled <- FALSE
[17:47:02.363]                       if (inherits(cond, "message")) {
[17:47:02.363]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.363]                         if (muffled) 
[17:47:02.363]                           invokeRestart("muffleMessage")
[17:47:02.363]                       }
[17:47:02.363]                       else if (inherits(cond, "warning")) {
[17:47:02.363]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.363]                         if (muffled) 
[17:47:02.363]                           invokeRestart("muffleWarning")
[17:47:02.363]                       }
[17:47:02.363]                       else if (inherits(cond, "condition")) {
[17:47:02.363]                         if (!is.null(pattern)) {
[17:47:02.363]                           computeRestarts <- base::computeRestarts
[17:47:02.363]                           grepl <- base::grepl
[17:47:02.363]                           restarts <- computeRestarts(cond)
[17:47:02.363]                           for (restart in restarts) {
[17:47:02.363]                             name <- restart$name
[17:47:02.363]                             if (is.null(name)) 
[17:47:02.363]                               next
[17:47:02.363]                             if (!grepl(pattern, name)) 
[17:47:02.363]                               next
[17:47:02.363]                             invokeRestart(restart)
[17:47:02.363]                             muffled <- TRUE
[17:47:02.363]                             break
[17:47:02.363]                           }
[17:47:02.363]                         }
[17:47:02.363]                       }
[17:47:02.363]                       invisible(muffled)
[17:47:02.363]                     }
[17:47:02.363]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.363]                   }
[17:47:02.363]                 }
[17:47:02.363]             }
[17:47:02.363]         }))
[17:47:02.363]     }, error = function(ex) {
[17:47:02.363]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.363]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.363]                 ...future.rng), started = ...future.startTime, 
[17:47:02.363]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.363]             version = "1.8"), class = "FutureResult")
[17:47:02.363]     }, finally = {
[17:47:02.363]         if (!identical(...future.workdir, getwd())) 
[17:47:02.363]             setwd(...future.workdir)
[17:47:02.363]         {
[17:47:02.363]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.363]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.363]             }
[17:47:02.363]             base::options(...future.oldOptions)
[17:47:02.363]             if (.Platform$OS.type == "windows") {
[17:47:02.363]                 old_names <- names(...future.oldEnvVars)
[17:47:02.363]                 envs <- base::Sys.getenv()
[17:47:02.363]                 names <- names(envs)
[17:47:02.363]                 common <- intersect(names, old_names)
[17:47:02.363]                 added <- setdiff(names, old_names)
[17:47:02.363]                 removed <- setdiff(old_names, names)
[17:47:02.363]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.363]                   envs[common]]
[17:47:02.363]                 NAMES <- toupper(changed)
[17:47:02.363]                 args <- list()
[17:47:02.363]                 for (kk in seq_along(NAMES)) {
[17:47:02.363]                   name <- changed[[kk]]
[17:47:02.363]                   NAME <- NAMES[[kk]]
[17:47:02.363]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.363]                     next
[17:47:02.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.363]                 }
[17:47:02.363]                 NAMES <- toupper(added)
[17:47:02.363]                 for (kk in seq_along(NAMES)) {
[17:47:02.363]                   name <- added[[kk]]
[17:47:02.363]                   NAME <- NAMES[[kk]]
[17:47:02.363]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.363]                     next
[17:47:02.363]                   args[[name]] <- ""
[17:47:02.363]                 }
[17:47:02.363]                 NAMES <- toupper(removed)
[17:47:02.363]                 for (kk in seq_along(NAMES)) {
[17:47:02.363]                   name <- removed[[kk]]
[17:47:02.363]                   NAME <- NAMES[[kk]]
[17:47:02.363]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.363]                     next
[17:47:02.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.363]                 }
[17:47:02.363]                 if (length(args) > 0) 
[17:47:02.363]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.363]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.363]             }
[17:47:02.363]             else {
[17:47:02.363]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.363]             }
[17:47:02.363]             {
[17:47:02.363]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.363]                   0L) {
[17:47:02.363]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.363]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.363]                   base::options(opts)
[17:47:02.363]                 }
[17:47:02.363]                 {
[17:47:02.363]                   {
[17:47:02.363]                     NULL
[17:47:02.363]                     RNGkind("Mersenne-Twister")
[17:47:02.363]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:02.363]                       inherits = FALSE)
[17:47:02.363]                   }
[17:47:02.363]                   options(future.plan = NULL)
[17:47:02.363]                   if (is.na(NA_character_)) 
[17:47:02.363]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.363]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.363]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.363]                     .init = FALSE)
[17:47:02.363]                 }
[17:47:02.363]             }
[17:47:02.363]         }
[17:47:02.363]     })
[17:47:02.363]     if (TRUE) {
[17:47:02.363]         base::sink(type = "output", split = FALSE)
[17:47:02.363]         if (TRUE) {
[17:47:02.363]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.363]         }
[17:47:02.363]         else {
[17:47:02.363]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.363]         }
[17:47:02.363]         base::close(...future.stdout)
[17:47:02.363]         ...future.stdout <- NULL
[17:47:02.363]     }
[17:47:02.363]     ...future.result$conditions <- ...future.conditions
[17:47:02.363]     ...future.result$finished <- base::Sys.time()
[17:47:02.363]     ...future.result
[17:47:02.363] }
[17:47:02.364] assign_globals() ...
[17:47:02.365] List of 2
[17:47:02.365]  $ x   : list()
[17:47:02.365]  $ name: chr "a"
[17:47:02.365]  - attr(*, "where")=List of 2
[17:47:02.365]   ..$ x   :<environment: R_EmptyEnv> 
[17:47:02.365]   ..$ name:<environment: R_EmptyEnv> 
[17:47:02.365]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.365]  - attr(*, "resolved")= logi TRUE
[17:47:02.365]  - attr(*, "total_size")= num 112
[17:47:02.365]  - attr(*, "already-done")= logi TRUE
[17:47:02.367] - copied ‘x’ to environment
[17:47:02.367] - copied ‘name’ to environment
[17:47:02.367] assign_globals() ... done
[17:47:02.368] plan(): Setting new future strategy stack:
[17:47:02.368] List of future strategies:
[17:47:02.368] 1. sequential:
[17:47:02.368]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.368]    - tweaked: FALSE
[17:47:02.368]    - call: NULL
[17:47:02.368] plan(): nbrOfWorkers() = 1
[17:47:02.369] plan(): Setting new future strategy stack:
[17:47:02.369] List of future strategies:
[17:47:02.369] 1. sequential:
[17:47:02.369]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.369]    - tweaked: FALSE
[17:47:02.369]    - call: plan(strategy)
[17:47:02.371] plan(): nbrOfWorkers() = 1
[17:47:02.371] SequentialFuture started (and completed)
[17:47:02.371] - Launch lazy future ... done
[17:47:02.371] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[17:47:02.379] plan(): Setting new future strategy stack:
[17:47:02.379] List of future strategies:
[17:47:02.379] 1. multicore:
[17:47:02.379]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:02.379]    - tweaked: FALSE
[17:47:02.379]    - call: plan(strategy)
[17:47:02.383] plan(): nbrOfWorkers() = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.383] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.383] Searching for globals...
[17:47:02.385] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.385] Searching for globals ... DONE
[17:47:02.385] Resolving globals: TRUE
[17:47:02.386] Resolving any globals that are futures ...
[17:47:02.386] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.386] Resolving any globals that are futures ... DONE
[17:47:02.386] Resolving futures part of globals (recursively) ...
[17:47:02.386] resolve() on list ...
[17:47:02.386]  recursive: 99
[17:47:02.386]  length: 1
[17:47:02.387]  elements: ‘x’
[17:47:02.387]  length: 0 (resolved future 1)
[17:47:02.387] resolve() on list ... DONE
[17:47:02.387] - globals: [1] ‘x’
[17:47:02.387] Resolving futures part of globals (recursively) ... DONE
[17:47:02.387] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.387] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.388] - globals: [1] ‘x’
[17:47:02.388] 
[17:47:02.388] getGlobalsAndPackages() ... DONE
[17:47:02.388] run() for ‘Future’ ...
[17:47:02.388] - state: ‘created’
[17:47:02.388] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:02.392] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:02.392] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:02.392]   - Field: ‘label’
[17:47:02.392]   - Field: ‘local’
[17:47:02.392]   - Field: ‘owner’
[17:47:02.392]   - Field: ‘envir’
[17:47:02.392]   - Field: ‘workers’
[17:47:02.392]   - Field: ‘packages’
[17:47:02.392]   - Field: ‘gc’
[17:47:02.392]   - Field: ‘job’
[17:47:02.393]   - Field: ‘conditions’
[17:47:02.393]   - Field: ‘expr’
[17:47:02.393]   - Field: ‘uuid’
[17:47:02.393]   - Field: ‘seed’
[17:47:02.393]   - Field: ‘version’
[17:47:02.393]   - Field: ‘result’
[17:47:02.393]   - Field: ‘asynchronous’
[17:47:02.393]   - Field: ‘calls’
[17:47:02.393]   - Field: ‘globals’
[17:47:02.393]   - Field: ‘stdout’
[17:47:02.393]   - Field: ‘earlySignal’
[17:47:02.394]   - Field: ‘lazy’
[17:47:02.394]   - Field: ‘state’
[17:47:02.394] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:02.394] - Launch lazy future ...
[17:47:02.395] Packages needed by the future expression (n = 0): <none>
[17:47:02.395] Packages needed by future strategies (n = 0): <none>
[17:47:02.395] {
[17:47:02.395]     {
[17:47:02.395]         {
[17:47:02.395]             ...future.startTime <- base::Sys.time()
[17:47:02.395]             {
[17:47:02.395]                 {
[17:47:02.395]                   {
[17:47:02.395]                     {
[17:47:02.395]                       base::local({
[17:47:02.395]                         has_future <- base::requireNamespace("future", 
[17:47:02.395]                           quietly = TRUE)
[17:47:02.395]                         if (has_future) {
[17:47:02.395]                           ns <- base::getNamespace("future")
[17:47:02.395]                           version <- ns[[".package"]][["version"]]
[17:47:02.395]                           if (is.null(version)) 
[17:47:02.395]                             version <- utils::packageVersion("future")
[17:47:02.395]                         }
[17:47:02.395]                         else {
[17:47:02.395]                           version <- NULL
[17:47:02.395]                         }
[17:47:02.395]                         if (!has_future || version < "1.8.0") {
[17:47:02.395]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.395]                             "", base::R.version$version.string), 
[17:47:02.395]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:02.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.395]                               "release", "version")], collapse = " "), 
[17:47:02.395]                             hostname = base::Sys.info()[["nodename"]])
[17:47:02.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.395]                             info)
[17:47:02.395]                           info <- base::paste(info, collapse = "; ")
[17:47:02.395]                           if (!has_future) {
[17:47:02.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.395]                               info)
[17:47:02.395]                           }
[17:47:02.395]                           else {
[17:47:02.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.395]                               info, version)
[17:47:02.395]                           }
[17:47:02.395]                           base::stop(msg)
[17:47:02.395]                         }
[17:47:02.395]                       })
[17:47:02.395]                     }
[17:47:02.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:02.395]                     base::options(mc.cores = 1L)
[17:47:02.395]                   }
[17:47:02.395]                   ...future.strategy.old <- future::plan("list")
[17:47:02.395]                   options(future.plan = NULL)
[17:47:02.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.395]                 }
[17:47:02.395]                 ...future.workdir <- getwd()
[17:47:02.395]             }
[17:47:02.395]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.395]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.395]         }
[17:47:02.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.395]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.395]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.395]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.395]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.395]             base::names(...future.oldOptions))
[17:47:02.395]     }
[17:47:02.395]     if (FALSE) {
[17:47:02.395]     }
[17:47:02.395]     else {
[17:47:02.395]         if (TRUE) {
[17:47:02.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.395]                 open = "w")
[17:47:02.395]         }
[17:47:02.395]         else {
[17:47:02.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.395]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.395]         }
[17:47:02.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.395]             base::sink(type = "output", split = FALSE)
[17:47:02.395]             base::close(...future.stdout)
[17:47:02.395]         }, add = TRUE)
[17:47:02.395]     }
[17:47:02.395]     ...future.frame <- base::sys.nframe()
[17:47:02.395]     ...future.conditions <- base::list()
[17:47:02.395]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.395]     if (FALSE) {
[17:47:02.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.395]     }
[17:47:02.395]     ...future.result <- base::tryCatch({
[17:47:02.395]         base::withCallingHandlers({
[17:47:02.395]             ...future.value <- base::withVisible(base::local({
[17:47:02.395]                 withCallingHandlers({
[17:47:02.395]                   {
[17:47:02.395]                     x$a <- 1
[17:47:02.395]                     x
[17:47:02.395]                   }
[17:47:02.395]                 }, immediateCondition = function(cond) {
[17:47:02.395]                   save_rds <- function (object, pathname, ...) 
[17:47:02.395]                   {
[17:47:02.395]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:02.395]                     if (file_test("-f", pathname_tmp)) {
[17:47:02.395]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.395]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:02.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.395]                         fi_tmp[["mtime"]])
[17:47:02.395]                     }
[17:47:02.395]                     tryCatch({
[17:47:02.395]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:02.395]                     }, error = function(ex) {
[17:47:02.395]                       msg <- conditionMessage(ex)
[17:47:02.395]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.395]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:02.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.395]                         fi_tmp[["mtime"]], msg)
[17:47:02.395]                       ex$message <- msg
[17:47:02.395]                       stop(ex)
[17:47:02.395]                     })
[17:47:02.395]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:02.395]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:02.395]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:02.395]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.395]                       fi <- file.info(pathname)
[17:47:02.395]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:02.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.395]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:02.395]                         fi[["size"]], fi[["mtime"]])
[17:47:02.395]                       stop(msg)
[17:47:02.395]                     }
[17:47:02.395]                     invisible(pathname)
[17:47:02.395]                   }
[17:47:02.395]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:02.395]                     rootPath = tempdir()) 
[17:47:02.395]                   {
[17:47:02.395]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:02.395]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:02.395]                       tmpdir = path, fileext = ".rds")
[17:47:02.395]                     save_rds(obj, file)
[17:47:02.395]                   }
[17:47:02.395]                   saveImmediateCondition(cond, path = "/tmp/RtmpR4Ygft/.future/immediateConditions")
[17:47:02.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.395]                   {
[17:47:02.395]                     inherits <- base::inherits
[17:47:02.395]                     invokeRestart <- base::invokeRestart
[17:47:02.395]                     is.null <- base::is.null
[17:47:02.395]                     muffled <- FALSE
[17:47:02.395]                     if (inherits(cond, "message")) {
[17:47:02.395]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:02.395]                       if (muffled) 
[17:47:02.395]                         invokeRestart("muffleMessage")
[17:47:02.395]                     }
[17:47:02.395]                     else if (inherits(cond, "warning")) {
[17:47:02.395]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:02.395]                       if (muffled) 
[17:47:02.395]                         invokeRestart("muffleWarning")
[17:47:02.395]                     }
[17:47:02.395]                     else if (inherits(cond, "condition")) {
[17:47:02.395]                       if (!is.null(pattern)) {
[17:47:02.395]                         computeRestarts <- base::computeRestarts
[17:47:02.395]                         grepl <- base::grepl
[17:47:02.395]                         restarts <- computeRestarts(cond)
[17:47:02.395]                         for (restart in restarts) {
[17:47:02.395]                           name <- restart$name
[17:47:02.395]                           if (is.null(name)) 
[17:47:02.395]                             next
[17:47:02.395]                           if (!grepl(pattern, name)) 
[17:47:02.395]                             next
[17:47:02.395]                           invokeRestart(restart)
[17:47:02.395]                           muffled <- TRUE
[17:47:02.395]                           break
[17:47:02.395]                         }
[17:47:02.395]                       }
[17:47:02.395]                     }
[17:47:02.395]                     invisible(muffled)
[17:47:02.395]                   }
[17:47:02.395]                   muffleCondition(cond)
[17:47:02.395]                 })
[17:47:02.395]             }))
[17:47:02.395]             future::FutureResult(value = ...future.value$value, 
[17:47:02.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.395]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.395]                     ...future.globalenv.names))
[17:47:02.395]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.395]         }, condition = base::local({
[17:47:02.395]             c <- base::c
[17:47:02.395]             inherits <- base::inherits
[17:47:02.395]             invokeRestart <- base::invokeRestart
[17:47:02.395]             length <- base::length
[17:47:02.395]             list <- base::list
[17:47:02.395]             seq.int <- base::seq.int
[17:47:02.395]             signalCondition <- base::signalCondition
[17:47:02.395]             sys.calls <- base::sys.calls
[17:47:02.395]             `[[` <- base::`[[`
[17:47:02.395]             `+` <- base::`+`
[17:47:02.395]             `<<-` <- base::`<<-`
[17:47:02.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.395]                   3L)]
[17:47:02.395]             }
[17:47:02.395]             function(cond) {
[17:47:02.395]                 is_error <- inherits(cond, "error")
[17:47:02.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.395]                   NULL)
[17:47:02.395]                 if (is_error) {
[17:47:02.395]                   sessionInformation <- function() {
[17:47:02.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.395]                       search = base::search(), system = base::Sys.info())
[17:47:02.395]                   }
[17:47:02.395]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.395]                     cond$call), session = sessionInformation(), 
[17:47:02.395]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.395]                   signalCondition(cond)
[17:47:02.395]                 }
[17:47:02.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.395]                 "immediateCondition"))) {
[17:47:02.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.395]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.395]                   if (TRUE && !signal) {
[17:47:02.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.395]                     {
[17:47:02.395]                       inherits <- base::inherits
[17:47:02.395]                       invokeRestart <- base::invokeRestart
[17:47:02.395]                       is.null <- base::is.null
[17:47:02.395]                       muffled <- FALSE
[17:47:02.395]                       if (inherits(cond, "message")) {
[17:47:02.395]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.395]                         if (muffled) 
[17:47:02.395]                           invokeRestart("muffleMessage")
[17:47:02.395]                       }
[17:47:02.395]                       else if (inherits(cond, "warning")) {
[17:47:02.395]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.395]                         if (muffled) 
[17:47:02.395]                           invokeRestart("muffleWarning")
[17:47:02.395]                       }
[17:47:02.395]                       else if (inherits(cond, "condition")) {
[17:47:02.395]                         if (!is.null(pattern)) {
[17:47:02.395]                           computeRestarts <- base::computeRestarts
[17:47:02.395]                           grepl <- base::grepl
[17:47:02.395]                           restarts <- computeRestarts(cond)
[17:47:02.395]                           for (restart in restarts) {
[17:47:02.395]                             name <- restart$name
[17:47:02.395]                             if (is.null(name)) 
[17:47:02.395]                               next
[17:47:02.395]                             if (!grepl(pattern, name)) 
[17:47:02.395]                               next
[17:47:02.395]                             invokeRestart(restart)
[17:47:02.395]                             muffled <- TRUE
[17:47:02.395]                             break
[17:47:02.395]                           }
[17:47:02.395]                         }
[17:47:02.395]                       }
[17:47:02.395]                       invisible(muffled)
[17:47:02.395]                     }
[17:47:02.395]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.395]                   }
[17:47:02.395]                 }
[17:47:02.395]                 else {
[17:47:02.395]                   if (TRUE) {
[17:47:02.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.395]                     {
[17:47:02.395]                       inherits <- base::inherits
[17:47:02.395]                       invokeRestart <- base::invokeRestart
[17:47:02.395]                       is.null <- base::is.null
[17:47:02.395]                       muffled <- FALSE
[17:47:02.395]                       if (inherits(cond, "message")) {
[17:47:02.395]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.395]                         if (muffled) 
[17:47:02.395]                           invokeRestart("muffleMessage")
[17:47:02.395]                       }
[17:47:02.395]                       else if (inherits(cond, "warning")) {
[17:47:02.395]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.395]                         if (muffled) 
[17:47:02.395]                           invokeRestart("muffleWarning")
[17:47:02.395]                       }
[17:47:02.395]                       else if (inherits(cond, "condition")) {
[17:47:02.395]                         if (!is.null(pattern)) {
[17:47:02.395]                           computeRestarts <- base::computeRestarts
[17:47:02.395]                           grepl <- base::grepl
[17:47:02.395]                           restarts <- computeRestarts(cond)
[17:47:02.395]                           for (restart in restarts) {
[17:47:02.395]                             name <- restart$name
[17:47:02.395]                             if (is.null(name)) 
[17:47:02.395]                               next
[17:47:02.395]                             if (!grepl(pattern, name)) 
[17:47:02.395]                               next
[17:47:02.395]                             invokeRestart(restart)
[17:47:02.395]                             muffled <- TRUE
[17:47:02.395]                             break
[17:47:02.395]                           }
[17:47:02.395]                         }
[17:47:02.395]                       }
[17:47:02.395]                       invisible(muffled)
[17:47:02.395]                     }
[17:47:02.395]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.395]                   }
[17:47:02.395]                 }
[17:47:02.395]             }
[17:47:02.395]         }))
[17:47:02.395]     }, error = function(ex) {
[17:47:02.395]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.395]                 ...future.rng), started = ...future.startTime, 
[17:47:02.395]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.395]             version = "1.8"), class = "FutureResult")
[17:47:02.395]     }, finally = {
[17:47:02.395]         if (!identical(...future.workdir, getwd())) 
[17:47:02.395]             setwd(...future.workdir)
[17:47:02.395]         {
[17:47:02.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.395]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.395]             }
[17:47:02.395]             base::options(...future.oldOptions)
[17:47:02.395]             if (.Platform$OS.type == "windows") {
[17:47:02.395]                 old_names <- names(...future.oldEnvVars)
[17:47:02.395]                 envs <- base::Sys.getenv()
[17:47:02.395]                 names <- names(envs)
[17:47:02.395]                 common <- intersect(names, old_names)
[17:47:02.395]                 added <- setdiff(names, old_names)
[17:47:02.395]                 removed <- setdiff(old_names, names)
[17:47:02.395]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.395]                   envs[common]]
[17:47:02.395]                 NAMES <- toupper(changed)
[17:47:02.395]                 args <- list()
[17:47:02.395]                 for (kk in seq_along(NAMES)) {
[17:47:02.395]                   name <- changed[[kk]]
[17:47:02.395]                   NAME <- NAMES[[kk]]
[17:47:02.395]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.395]                     next
[17:47:02.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.395]                 }
[17:47:02.395]                 NAMES <- toupper(added)
[17:47:02.395]                 for (kk in seq_along(NAMES)) {
[17:47:02.395]                   name <- added[[kk]]
[17:47:02.395]                   NAME <- NAMES[[kk]]
[17:47:02.395]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.395]                     next
[17:47:02.395]                   args[[name]] <- ""
[17:47:02.395]                 }
[17:47:02.395]                 NAMES <- toupper(removed)
[17:47:02.395]                 for (kk in seq_along(NAMES)) {
[17:47:02.395]                   name <- removed[[kk]]
[17:47:02.395]                   NAME <- NAMES[[kk]]
[17:47:02.395]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.395]                     next
[17:47:02.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.395]                 }
[17:47:02.395]                 if (length(args) > 0) 
[17:47:02.395]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.395]             }
[17:47:02.395]             else {
[17:47:02.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.395]             }
[17:47:02.395]             {
[17:47:02.395]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.395]                   0L) {
[17:47:02.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.395]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.395]                   base::options(opts)
[17:47:02.395]                 }
[17:47:02.395]                 {
[17:47:02.395]                   {
[17:47:02.395]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:02.395]                     NULL
[17:47:02.395]                   }
[17:47:02.395]                   options(future.plan = NULL)
[17:47:02.395]                   if (is.na(NA_character_)) 
[17:47:02.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.395]                     .init = FALSE)
[17:47:02.395]                 }
[17:47:02.395]             }
[17:47:02.395]         }
[17:47:02.395]     })
[17:47:02.395]     if (TRUE) {
[17:47:02.395]         base::sink(type = "output", split = FALSE)
[17:47:02.395]         if (TRUE) {
[17:47:02.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.395]         }
[17:47:02.395]         else {
[17:47:02.395]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.395]         }
[17:47:02.395]         base::close(...future.stdout)
[17:47:02.395]         ...future.stdout <- NULL
[17:47:02.395]     }
[17:47:02.395]     ...future.result$conditions <- ...future.conditions
[17:47:02.395]     ...future.result$finished <- base::Sys.time()
[17:47:02.395]     ...future.result
[17:47:02.395] }
[17:47:02.397] assign_globals() ...
[17:47:02.398] List of 1
[17:47:02.398]  $ x: list()
[17:47:02.398]  - attr(*, "where")=List of 1
[17:47:02.398]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.398]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.398]  - attr(*, "resolved")= logi TRUE
[17:47:02.398]  - attr(*, "total_size")= num 0
[17:47:02.398]  - attr(*, "already-done")= logi TRUE
[17:47:02.400] - copied ‘x’ to environment
[17:47:02.400] assign_globals() ... done
[17:47:02.400] requestCore(): workers = 2
[17:47:02.403] MulticoreFuture started
[17:47:02.403] - Launch lazy future ... done
[17:47:02.404] plan(): Setting new future strategy stack:
[17:47:02.404] run() for ‘MulticoreFuture’ ... done
[17:47:02.404] List of future strategies:
[17:47:02.404] 1. sequential:
[17:47:02.404]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.404]    - tweaked: FALSE
[17:47:02.404]    - call: NULL
[17:47:02.405] result() for MulticoreFuture ...
[17:47:02.405] plan(): nbrOfWorkers() = 1
[17:47:02.407] plan(): Setting new future strategy stack:
[17:47:02.407] List of future strategies:
[17:47:02.407] 1. multicore:
[17:47:02.407]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:02.407]    - tweaked: FALSE
[17:47:02.407]    - call: plan(strategy)
[17:47:02.416] plan(): nbrOfWorkers() = 2
[17:47:02.423] result() for MulticoreFuture ...
[17:47:02.423] result() for MulticoreFuture ... done
[17:47:02.423] result() for MulticoreFuture ... done
[17:47:02.423] result() for MulticoreFuture ...
[17:47:02.423] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.424] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.424] Searching for globals...
[17:47:02.427] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.427] Searching for globals ... DONE
[17:47:02.427] Resolving globals: TRUE
[17:47:02.427] Resolving any globals that are futures ...
[17:47:02.427] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.427] Resolving any globals that are futures ... DONE
[17:47:02.428] Resolving futures part of globals (recursively) ...
[17:47:02.428] resolve() on list ...
[17:47:02.428]  recursive: 99
[17:47:02.428]  length: 1
[17:47:02.428]  elements: ‘x’
[17:47:02.429]  length: 0 (resolved future 1)
[17:47:02.429] resolve() on list ... DONE
[17:47:02.429] - globals: [1] ‘x’
[17:47:02.429] Resolving futures part of globals (recursively) ... DONE
[17:47:02.429] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.430] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.430] - globals: [1] ‘x’
[17:47:02.430] 
[17:47:02.430] getGlobalsAndPackages() ... DONE
[17:47:02.430] run() for ‘Future’ ...
[17:47:02.430] - state: ‘created’
[17:47:02.431] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:02.434] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:02.435] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:02.435]   - Field: ‘label’
[17:47:02.435]   - Field: ‘local’
[17:47:02.435]   - Field: ‘owner’
[17:47:02.435]   - Field: ‘envir’
[17:47:02.435]   - Field: ‘workers’
[17:47:02.435]   - Field: ‘packages’
[17:47:02.435]   - Field: ‘gc’
[17:47:02.436]   - Field: ‘job’
[17:47:02.436]   - Field: ‘conditions’
[17:47:02.436]   - Field: ‘expr’
[17:47:02.436]   - Field: ‘uuid’
[17:47:02.436]   - Field: ‘seed’
[17:47:02.436]   - Field: ‘version’
[17:47:02.436]   - Field: ‘result’
[17:47:02.436]   - Field: ‘asynchronous’
[17:47:02.436]   - Field: ‘calls’
[17:47:02.437]   - Field: ‘globals’
[17:47:02.437]   - Field: ‘stdout’
[17:47:02.437]   - Field: ‘earlySignal’
[17:47:02.437]   - Field: ‘lazy’
[17:47:02.437]   - Field: ‘state’
[17:47:02.437] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:02.437] - Launch lazy future ...
[17:47:02.437] Packages needed by the future expression (n = 0): <none>
[17:47:02.438] Packages needed by future strategies (n = 0): <none>
[17:47:02.438] {
[17:47:02.438]     {
[17:47:02.438]         {
[17:47:02.438]             ...future.startTime <- base::Sys.time()
[17:47:02.438]             {
[17:47:02.438]                 {
[17:47:02.438]                   {
[17:47:02.438]                     {
[17:47:02.438]                       base::local({
[17:47:02.438]                         has_future <- base::requireNamespace("future", 
[17:47:02.438]                           quietly = TRUE)
[17:47:02.438]                         if (has_future) {
[17:47:02.438]                           ns <- base::getNamespace("future")
[17:47:02.438]                           version <- ns[[".package"]][["version"]]
[17:47:02.438]                           if (is.null(version)) 
[17:47:02.438]                             version <- utils::packageVersion("future")
[17:47:02.438]                         }
[17:47:02.438]                         else {
[17:47:02.438]                           version <- NULL
[17:47:02.438]                         }
[17:47:02.438]                         if (!has_future || version < "1.8.0") {
[17:47:02.438]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.438]                             "", base::R.version$version.string), 
[17:47:02.438]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:02.438]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.438]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.438]                               "release", "version")], collapse = " "), 
[17:47:02.438]                             hostname = base::Sys.info()[["nodename"]])
[17:47:02.438]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.438]                             info)
[17:47:02.438]                           info <- base::paste(info, collapse = "; ")
[17:47:02.438]                           if (!has_future) {
[17:47:02.438]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.438]                               info)
[17:47:02.438]                           }
[17:47:02.438]                           else {
[17:47:02.438]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.438]                               info, version)
[17:47:02.438]                           }
[17:47:02.438]                           base::stop(msg)
[17:47:02.438]                         }
[17:47:02.438]                       })
[17:47:02.438]                     }
[17:47:02.438]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:02.438]                     base::options(mc.cores = 1L)
[17:47:02.438]                   }
[17:47:02.438]                   ...future.strategy.old <- future::plan("list")
[17:47:02.438]                   options(future.plan = NULL)
[17:47:02.438]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.438]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.438]                 }
[17:47:02.438]                 ...future.workdir <- getwd()
[17:47:02.438]             }
[17:47:02.438]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.438]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.438]         }
[17:47:02.438]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.438]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.438]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.438]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.438]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.438]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.438]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.438]             base::names(...future.oldOptions))
[17:47:02.438]     }
[17:47:02.438]     if (FALSE) {
[17:47:02.438]     }
[17:47:02.438]     else {
[17:47:02.438]         if (TRUE) {
[17:47:02.438]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.438]                 open = "w")
[17:47:02.438]         }
[17:47:02.438]         else {
[17:47:02.438]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.438]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.438]         }
[17:47:02.438]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.438]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.438]             base::sink(type = "output", split = FALSE)
[17:47:02.438]             base::close(...future.stdout)
[17:47:02.438]         }, add = TRUE)
[17:47:02.438]     }
[17:47:02.438]     ...future.frame <- base::sys.nframe()
[17:47:02.438]     ...future.conditions <- base::list()
[17:47:02.438]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.438]     if (FALSE) {
[17:47:02.438]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.438]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.438]     }
[17:47:02.438]     ...future.result <- base::tryCatch({
[17:47:02.438]         base::withCallingHandlers({
[17:47:02.438]             ...future.value <- base::withVisible(base::local({
[17:47:02.438]                 withCallingHandlers({
[17:47:02.438]                   {
[17:47:02.438]                     x$a <- 1
[17:47:02.438]                     x
[17:47:02.438]                   }
[17:47:02.438]                 }, immediateCondition = function(cond) {
[17:47:02.438]                   save_rds <- function (object, pathname, ...) 
[17:47:02.438]                   {
[17:47:02.438]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:02.438]                     if (file_test("-f", pathname_tmp)) {
[17:47:02.438]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.438]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:02.438]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.438]                         fi_tmp[["mtime"]])
[17:47:02.438]                     }
[17:47:02.438]                     tryCatch({
[17:47:02.438]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:02.438]                     }, error = function(ex) {
[17:47:02.438]                       msg <- conditionMessage(ex)
[17:47:02.438]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.438]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:02.438]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.438]                         fi_tmp[["mtime"]], msg)
[17:47:02.438]                       ex$message <- msg
[17:47:02.438]                       stop(ex)
[17:47:02.438]                     })
[17:47:02.438]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:02.438]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:02.438]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:02.438]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.438]                       fi <- file.info(pathname)
[17:47:02.438]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:02.438]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.438]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:02.438]                         fi[["size"]], fi[["mtime"]])
[17:47:02.438]                       stop(msg)
[17:47:02.438]                     }
[17:47:02.438]                     invisible(pathname)
[17:47:02.438]                   }
[17:47:02.438]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:02.438]                     rootPath = tempdir()) 
[17:47:02.438]                   {
[17:47:02.438]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:02.438]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:02.438]                       tmpdir = path, fileext = ".rds")
[17:47:02.438]                     save_rds(obj, file)
[17:47:02.438]                   }
[17:47:02.438]                   saveImmediateCondition(cond, path = "/tmp/RtmpR4Ygft/.future/immediateConditions")
[17:47:02.438]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.438]                   {
[17:47:02.438]                     inherits <- base::inherits
[17:47:02.438]                     invokeRestart <- base::invokeRestart
[17:47:02.438]                     is.null <- base::is.null
[17:47:02.438]                     muffled <- FALSE
[17:47:02.438]                     if (inherits(cond, "message")) {
[17:47:02.438]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:02.438]                       if (muffled) 
[17:47:02.438]                         invokeRestart("muffleMessage")
[17:47:02.438]                     }
[17:47:02.438]                     else if (inherits(cond, "warning")) {
[17:47:02.438]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:02.438]                       if (muffled) 
[17:47:02.438]                         invokeRestart("muffleWarning")
[17:47:02.438]                     }
[17:47:02.438]                     else if (inherits(cond, "condition")) {
[17:47:02.438]                       if (!is.null(pattern)) {
[17:47:02.438]                         computeRestarts <- base::computeRestarts
[17:47:02.438]                         grepl <- base::grepl
[17:47:02.438]                         restarts <- computeRestarts(cond)
[17:47:02.438]                         for (restart in restarts) {
[17:47:02.438]                           name <- restart$name
[17:47:02.438]                           if (is.null(name)) 
[17:47:02.438]                             next
[17:47:02.438]                           if (!grepl(pattern, name)) 
[17:47:02.438]                             next
[17:47:02.438]                           invokeRestart(restart)
[17:47:02.438]                           muffled <- TRUE
[17:47:02.438]                           break
[17:47:02.438]                         }
[17:47:02.438]                       }
[17:47:02.438]                     }
[17:47:02.438]                     invisible(muffled)
[17:47:02.438]                   }
[17:47:02.438]                   muffleCondition(cond)
[17:47:02.438]                 })
[17:47:02.438]             }))
[17:47:02.438]             future::FutureResult(value = ...future.value$value, 
[17:47:02.438]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.438]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.438]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.438]                     ...future.globalenv.names))
[17:47:02.438]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.438]         }, condition = base::local({
[17:47:02.438]             c <- base::c
[17:47:02.438]             inherits <- base::inherits
[17:47:02.438]             invokeRestart <- base::invokeRestart
[17:47:02.438]             length <- base::length
[17:47:02.438]             list <- base::list
[17:47:02.438]             seq.int <- base::seq.int
[17:47:02.438]             signalCondition <- base::signalCondition
[17:47:02.438]             sys.calls <- base::sys.calls
[17:47:02.438]             `[[` <- base::`[[`
[17:47:02.438]             `+` <- base::`+`
[17:47:02.438]             `<<-` <- base::`<<-`
[17:47:02.438]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.438]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.438]                   3L)]
[17:47:02.438]             }
[17:47:02.438]             function(cond) {
[17:47:02.438]                 is_error <- inherits(cond, "error")
[17:47:02.438]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.438]                   NULL)
[17:47:02.438]                 if (is_error) {
[17:47:02.438]                   sessionInformation <- function() {
[17:47:02.438]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.438]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.438]                       search = base::search(), system = base::Sys.info())
[17:47:02.438]                   }
[17:47:02.438]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.438]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.438]                     cond$call), session = sessionInformation(), 
[17:47:02.438]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.438]                   signalCondition(cond)
[17:47:02.438]                 }
[17:47:02.438]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.438]                 "immediateCondition"))) {
[17:47:02.438]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.438]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.438]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.438]                   if (TRUE && !signal) {
[17:47:02.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.438]                     {
[17:47:02.438]                       inherits <- base::inherits
[17:47:02.438]                       invokeRestart <- base::invokeRestart
[17:47:02.438]                       is.null <- base::is.null
[17:47:02.438]                       muffled <- FALSE
[17:47:02.438]                       if (inherits(cond, "message")) {
[17:47:02.438]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.438]                         if (muffled) 
[17:47:02.438]                           invokeRestart("muffleMessage")
[17:47:02.438]                       }
[17:47:02.438]                       else if (inherits(cond, "warning")) {
[17:47:02.438]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.438]                         if (muffled) 
[17:47:02.438]                           invokeRestart("muffleWarning")
[17:47:02.438]                       }
[17:47:02.438]                       else if (inherits(cond, "condition")) {
[17:47:02.438]                         if (!is.null(pattern)) {
[17:47:02.438]                           computeRestarts <- base::computeRestarts
[17:47:02.438]                           grepl <- base::grepl
[17:47:02.438]                           restarts <- computeRestarts(cond)
[17:47:02.438]                           for (restart in restarts) {
[17:47:02.438]                             name <- restart$name
[17:47:02.438]                             if (is.null(name)) 
[17:47:02.438]                               next
[17:47:02.438]                             if (!grepl(pattern, name)) 
[17:47:02.438]                               next
[17:47:02.438]                             invokeRestart(restart)
[17:47:02.438]                             muffled <- TRUE
[17:47:02.438]                             break
[17:47:02.438]                           }
[17:47:02.438]                         }
[17:47:02.438]                       }
[17:47:02.438]                       invisible(muffled)
[17:47:02.438]                     }
[17:47:02.438]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.438]                   }
[17:47:02.438]                 }
[17:47:02.438]                 else {
[17:47:02.438]                   if (TRUE) {
[17:47:02.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.438]                     {
[17:47:02.438]                       inherits <- base::inherits
[17:47:02.438]                       invokeRestart <- base::invokeRestart
[17:47:02.438]                       is.null <- base::is.null
[17:47:02.438]                       muffled <- FALSE
[17:47:02.438]                       if (inherits(cond, "message")) {
[17:47:02.438]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.438]                         if (muffled) 
[17:47:02.438]                           invokeRestart("muffleMessage")
[17:47:02.438]                       }
[17:47:02.438]                       else if (inherits(cond, "warning")) {
[17:47:02.438]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.438]                         if (muffled) 
[17:47:02.438]                           invokeRestart("muffleWarning")
[17:47:02.438]                       }
[17:47:02.438]                       else if (inherits(cond, "condition")) {
[17:47:02.438]                         if (!is.null(pattern)) {
[17:47:02.438]                           computeRestarts <- base::computeRestarts
[17:47:02.438]                           grepl <- base::grepl
[17:47:02.438]                           restarts <- computeRestarts(cond)
[17:47:02.438]                           for (restart in restarts) {
[17:47:02.438]                             name <- restart$name
[17:47:02.438]                             if (is.null(name)) 
[17:47:02.438]                               next
[17:47:02.438]                             if (!grepl(pattern, name)) 
[17:47:02.438]                               next
[17:47:02.438]                             invokeRestart(restart)
[17:47:02.438]                             muffled <- TRUE
[17:47:02.438]                             break
[17:47:02.438]                           }
[17:47:02.438]                         }
[17:47:02.438]                       }
[17:47:02.438]                       invisible(muffled)
[17:47:02.438]                     }
[17:47:02.438]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.438]                   }
[17:47:02.438]                 }
[17:47:02.438]             }
[17:47:02.438]         }))
[17:47:02.438]     }, error = function(ex) {
[17:47:02.438]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.438]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.438]                 ...future.rng), started = ...future.startTime, 
[17:47:02.438]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.438]             version = "1.8"), class = "FutureResult")
[17:47:02.438]     }, finally = {
[17:47:02.438]         if (!identical(...future.workdir, getwd())) 
[17:47:02.438]             setwd(...future.workdir)
[17:47:02.438]         {
[17:47:02.438]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.438]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.438]             }
[17:47:02.438]             base::options(...future.oldOptions)
[17:47:02.438]             if (.Platform$OS.type == "windows") {
[17:47:02.438]                 old_names <- names(...future.oldEnvVars)
[17:47:02.438]                 envs <- base::Sys.getenv()
[17:47:02.438]                 names <- names(envs)
[17:47:02.438]                 common <- intersect(names, old_names)
[17:47:02.438]                 added <- setdiff(names, old_names)
[17:47:02.438]                 removed <- setdiff(old_names, names)
[17:47:02.438]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.438]                   envs[common]]
[17:47:02.438]                 NAMES <- toupper(changed)
[17:47:02.438]                 args <- list()
[17:47:02.438]                 for (kk in seq_along(NAMES)) {
[17:47:02.438]                   name <- changed[[kk]]
[17:47:02.438]                   NAME <- NAMES[[kk]]
[17:47:02.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.438]                     next
[17:47:02.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.438]                 }
[17:47:02.438]                 NAMES <- toupper(added)
[17:47:02.438]                 for (kk in seq_along(NAMES)) {
[17:47:02.438]                   name <- added[[kk]]
[17:47:02.438]                   NAME <- NAMES[[kk]]
[17:47:02.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.438]                     next
[17:47:02.438]                   args[[name]] <- ""
[17:47:02.438]                 }
[17:47:02.438]                 NAMES <- toupper(removed)
[17:47:02.438]                 for (kk in seq_along(NAMES)) {
[17:47:02.438]                   name <- removed[[kk]]
[17:47:02.438]                   NAME <- NAMES[[kk]]
[17:47:02.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.438]                     next
[17:47:02.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.438]                 }
[17:47:02.438]                 if (length(args) > 0) 
[17:47:02.438]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.438]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.438]             }
[17:47:02.438]             else {
[17:47:02.438]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.438]             }
[17:47:02.438]             {
[17:47:02.438]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.438]                   0L) {
[17:47:02.438]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.438]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.438]                   base::options(opts)
[17:47:02.438]                 }
[17:47:02.438]                 {
[17:47:02.438]                   {
[17:47:02.438]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:02.438]                     NULL
[17:47:02.438]                   }
[17:47:02.438]                   options(future.plan = NULL)
[17:47:02.438]                   if (is.na(NA_character_)) 
[17:47:02.438]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.438]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.438]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.438]                     .init = FALSE)
[17:47:02.438]                 }
[17:47:02.438]             }
[17:47:02.438]         }
[17:47:02.438]     })
[17:47:02.438]     if (TRUE) {
[17:47:02.438]         base::sink(type = "output", split = FALSE)
[17:47:02.438]         if (TRUE) {
[17:47:02.438]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.438]         }
[17:47:02.438]         else {
[17:47:02.438]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.438]         }
[17:47:02.438]         base::close(...future.stdout)
[17:47:02.438]         ...future.stdout <- NULL
[17:47:02.438]     }
[17:47:02.438]     ...future.result$conditions <- ...future.conditions
[17:47:02.438]     ...future.result$finished <- base::Sys.time()
[17:47:02.438]     ...future.result
[17:47:02.438] }
[17:47:02.440] assign_globals() ...
[17:47:02.440] List of 1
[17:47:02.440]  $ x: list()
[17:47:02.440]  - attr(*, "where")=List of 1
[17:47:02.440]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.440]  - attr(*, "resolved")= logi TRUE
[17:47:02.440]  - attr(*, "total_size")= num 0
[17:47:02.440]  - attr(*, "already-done")= logi TRUE
[17:47:02.443] - copied ‘x’ to environment
[17:47:02.443] assign_globals() ... done
[17:47:02.443] requestCore(): workers = 2
[17:47:02.445] MulticoreFuture started
[17:47:02.446] - Launch lazy future ... done
[17:47:02.446] run() for ‘MulticoreFuture’ ... done
[17:47:02.446] result() for MulticoreFuture ...
[17:47:02.446] plan(): Setting new future strategy stack:
[17:47:02.446] List of future strategies:
[17:47:02.446] 1. sequential:
[17:47:02.446]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.446]    - tweaked: FALSE
[17:47:02.446]    - call: NULL
[17:47:02.447] plan(): nbrOfWorkers() = 1
[17:47:02.449] plan(): Setting new future strategy stack:
[17:47:02.449] List of future strategies:
[17:47:02.449] 1. multicore:
[17:47:02.449]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:02.449]    - tweaked: FALSE
[17:47:02.449]    - call: plan(strategy)
[17:47:02.454] plan(): nbrOfWorkers() = 2
[17:47:02.455] result() for MulticoreFuture ...
[17:47:02.456] result() for MulticoreFuture ... done
[17:47:02.456] result() for MulticoreFuture ... done
[17:47:02.456] result() for MulticoreFuture ...
[17:47:02.456] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.457] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.457] Searching for globals...
[17:47:02.460] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.460] Searching for globals ... DONE
[17:47:02.460] Resolving globals: TRUE
[17:47:02.460] Resolving any globals that are futures ...
[17:47:02.460] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.460] Resolving any globals that are futures ... DONE
[17:47:02.461] Resolving futures part of globals (recursively) ...
[17:47:02.461] resolve() on list ...
[17:47:02.461]  recursive: 99
[17:47:02.461]  length: 1
[17:47:02.461]  elements: ‘x’
[17:47:02.462]  length: 0 (resolved future 1)
[17:47:02.462] resolve() on list ... DONE
[17:47:02.462] - globals: [1] ‘x’
[17:47:02.462] Resolving futures part of globals (recursively) ... DONE
[17:47:02.462] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.462] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.463] - globals: [1] ‘x’
[17:47:02.463] 
[17:47:02.463] getGlobalsAndPackages() ... DONE
[17:47:02.463] run() for ‘Future’ ...
[17:47:02.463] - state: ‘created’
[17:47:02.464] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:02.470] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:02.470] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:02.470]   - Field: ‘label’
[17:47:02.470]   - Field: ‘local’
[17:47:02.470]   - Field: ‘owner’
[17:47:02.470]   - Field: ‘envir’
[17:47:02.470]   - Field: ‘workers’
[17:47:02.471]   - Field: ‘packages’
[17:47:02.471]   - Field: ‘gc’
[17:47:02.471]   - Field: ‘job’
[17:47:02.471]   - Field: ‘conditions’
[17:47:02.471]   - Field: ‘expr’
[17:47:02.471]   - Field: ‘uuid’
[17:47:02.471]   - Field: ‘seed’
[17:47:02.472]   - Field: ‘version’
[17:47:02.472]   - Field: ‘result’
[17:47:02.472]   - Field: ‘asynchronous’
[17:47:02.472]   - Field: ‘calls’
[17:47:02.472]   - Field: ‘globals’
[17:47:02.472]   - Field: ‘stdout’
[17:47:02.472]   - Field: ‘earlySignal’
[17:47:02.472]   - Field: ‘lazy’
[17:47:02.472]   - Field: ‘state’
[17:47:02.473] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:02.473] - Launch lazy future ...
[17:47:02.473] Packages needed by the future expression (n = 0): <none>
[17:47:02.473] Packages needed by future strategies (n = 0): <none>
[17:47:02.474] {
[17:47:02.474]     {
[17:47:02.474]         {
[17:47:02.474]             ...future.startTime <- base::Sys.time()
[17:47:02.474]             {
[17:47:02.474]                 {
[17:47:02.474]                   {
[17:47:02.474]                     {
[17:47:02.474]                       base::local({
[17:47:02.474]                         has_future <- base::requireNamespace("future", 
[17:47:02.474]                           quietly = TRUE)
[17:47:02.474]                         if (has_future) {
[17:47:02.474]                           ns <- base::getNamespace("future")
[17:47:02.474]                           version <- ns[[".package"]][["version"]]
[17:47:02.474]                           if (is.null(version)) 
[17:47:02.474]                             version <- utils::packageVersion("future")
[17:47:02.474]                         }
[17:47:02.474]                         else {
[17:47:02.474]                           version <- NULL
[17:47:02.474]                         }
[17:47:02.474]                         if (!has_future || version < "1.8.0") {
[17:47:02.474]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.474]                             "", base::R.version$version.string), 
[17:47:02.474]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:02.474]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.474]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.474]                               "release", "version")], collapse = " "), 
[17:47:02.474]                             hostname = base::Sys.info()[["nodename"]])
[17:47:02.474]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.474]                             info)
[17:47:02.474]                           info <- base::paste(info, collapse = "; ")
[17:47:02.474]                           if (!has_future) {
[17:47:02.474]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.474]                               info)
[17:47:02.474]                           }
[17:47:02.474]                           else {
[17:47:02.474]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.474]                               info, version)
[17:47:02.474]                           }
[17:47:02.474]                           base::stop(msg)
[17:47:02.474]                         }
[17:47:02.474]                       })
[17:47:02.474]                     }
[17:47:02.474]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:02.474]                     base::options(mc.cores = 1L)
[17:47:02.474]                   }
[17:47:02.474]                   ...future.strategy.old <- future::plan("list")
[17:47:02.474]                   options(future.plan = NULL)
[17:47:02.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.474]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.474]                 }
[17:47:02.474]                 ...future.workdir <- getwd()
[17:47:02.474]             }
[17:47:02.474]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.474]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.474]         }
[17:47:02.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.474]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.474]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.474]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.474]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.474]             base::names(...future.oldOptions))
[17:47:02.474]     }
[17:47:02.474]     if (FALSE) {
[17:47:02.474]     }
[17:47:02.474]     else {
[17:47:02.474]         if (TRUE) {
[17:47:02.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.474]                 open = "w")
[17:47:02.474]         }
[17:47:02.474]         else {
[17:47:02.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.474]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.474]         }
[17:47:02.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.474]             base::sink(type = "output", split = FALSE)
[17:47:02.474]             base::close(...future.stdout)
[17:47:02.474]         }, add = TRUE)
[17:47:02.474]     }
[17:47:02.474]     ...future.frame <- base::sys.nframe()
[17:47:02.474]     ...future.conditions <- base::list()
[17:47:02.474]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.474]     if (FALSE) {
[17:47:02.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.474]     }
[17:47:02.474]     ...future.result <- base::tryCatch({
[17:47:02.474]         base::withCallingHandlers({
[17:47:02.474]             ...future.value <- base::withVisible(base::local({
[17:47:02.474]                 withCallingHandlers({
[17:47:02.474]                   {
[17:47:02.474]                     x$a <- 1
[17:47:02.474]                     x
[17:47:02.474]                   }
[17:47:02.474]                 }, immediateCondition = function(cond) {
[17:47:02.474]                   save_rds <- function (object, pathname, ...) 
[17:47:02.474]                   {
[17:47:02.474]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:02.474]                     if (file_test("-f", pathname_tmp)) {
[17:47:02.474]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.474]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:02.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.474]                         fi_tmp[["mtime"]])
[17:47:02.474]                     }
[17:47:02.474]                     tryCatch({
[17:47:02.474]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:02.474]                     }, error = function(ex) {
[17:47:02.474]                       msg <- conditionMessage(ex)
[17:47:02.474]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.474]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:02.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.474]                         fi_tmp[["mtime"]], msg)
[17:47:02.474]                       ex$message <- msg
[17:47:02.474]                       stop(ex)
[17:47:02.474]                     })
[17:47:02.474]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:02.474]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:02.474]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:02.474]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.474]                       fi <- file.info(pathname)
[17:47:02.474]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:02.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.474]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:02.474]                         fi[["size"]], fi[["mtime"]])
[17:47:02.474]                       stop(msg)
[17:47:02.474]                     }
[17:47:02.474]                     invisible(pathname)
[17:47:02.474]                   }
[17:47:02.474]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:02.474]                     rootPath = tempdir()) 
[17:47:02.474]                   {
[17:47:02.474]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:02.474]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:02.474]                       tmpdir = path, fileext = ".rds")
[17:47:02.474]                     save_rds(obj, file)
[17:47:02.474]                   }
[17:47:02.474]                   saveImmediateCondition(cond, path = "/tmp/RtmpR4Ygft/.future/immediateConditions")
[17:47:02.474]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.474]                   {
[17:47:02.474]                     inherits <- base::inherits
[17:47:02.474]                     invokeRestart <- base::invokeRestart
[17:47:02.474]                     is.null <- base::is.null
[17:47:02.474]                     muffled <- FALSE
[17:47:02.474]                     if (inherits(cond, "message")) {
[17:47:02.474]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:02.474]                       if (muffled) 
[17:47:02.474]                         invokeRestart("muffleMessage")
[17:47:02.474]                     }
[17:47:02.474]                     else if (inherits(cond, "warning")) {
[17:47:02.474]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:02.474]                       if (muffled) 
[17:47:02.474]                         invokeRestart("muffleWarning")
[17:47:02.474]                     }
[17:47:02.474]                     else if (inherits(cond, "condition")) {
[17:47:02.474]                       if (!is.null(pattern)) {
[17:47:02.474]                         computeRestarts <- base::computeRestarts
[17:47:02.474]                         grepl <- base::grepl
[17:47:02.474]                         restarts <- computeRestarts(cond)
[17:47:02.474]                         for (restart in restarts) {
[17:47:02.474]                           name <- restart$name
[17:47:02.474]                           if (is.null(name)) 
[17:47:02.474]                             next
[17:47:02.474]                           if (!grepl(pattern, name)) 
[17:47:02.474]                             next
[17:47:02.474]                           invokeRestart(restart)
[17:47:02.474]                           muffled <- TRUE
[17:47:02.474]                           break
[17:47:02.474]                         }
[17:47:02.474]                       }
[17:47:02.474]                     }
[17:47:02.474]                     invisible(muffled)
[17:47:02.474]                   }
[17:47:02.474]                   muffleCondition(cond)
[17:47:02.474]                 })
[17:47:02.474]             }))
[17:47:02.474]             future::FutureResult(value = ...future.value$value, 
[17:47:02.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.474]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.474]                     ...future.globalenv.names))
[17:47:02.474]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.474]         }, condition = base::local({
[17:47:02.474]             c <- base::c
[17:47:02.474]             inherits <- base::inherits
[17:47:02.474]             invokeRestart <- base::invokeRestart
[17:47:02.474]             length <- base::length
[17:47:02.474]             list <- base::list
[17:47:02.474]             seq.int <- base::seq.int
[17:47:02.474]             signalCondition <- base::signalCondition
[17:47:02.474]             sys.calls <- base::sys.calls
[17:47:02.474]             `[[` <- base::`[[`
[17:47:02.474]             `+` <- base::`+`
[17:47:02.474]             `<<-` <- base::`<<-`
[17:47:02.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.474]                   3L)]
[17:47:02.474]             }
[17:47:02.474]             function(cond) {
[17:47:02.474]                 is_error <- inherits(cond, "error")
[17:47:02.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.474]                   NULL)
[17:47:02.474]                 if (is_error) {
[17:47:02.474]                   sessionInformation <- function() {
[17:47:02.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.474]                       search = base::search(), system = base::Sys.info())
[17:47:02.474]                   }
[17:47:02.474]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.474]                     cond$call), session = sessionInformation(), 
[17:47:02.474]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.474]                   signalCondition(cond)
[17:47:02.474]                 }
[17:47:02.474]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.474]                 "immediateCondition"))) {
[17:47:02.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.474]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.474]                   if (TRUE && !signal) {
[17:47:02.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.474]                     {
[17:47:02.474]                       inherits <- base::inherits
[17:47:02.474]                       invokeRestart <- base::invokeRestart
[17:47:02.474]                       is.null <- base::is.null
[17:47:02.474]                       muffled <- FALSE
[17:47:02.474]                       if (inherits(cond, "message")) {
[17:47:02.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.474]                         if (muffled) 
[17:47:02.474]                           invokeRestart("muffleMessage")
[17:47:02.474]                       }
[17:47:02.474]                       else if (inherits(cond, "warning")) {
[17:47:02.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.474]                         if (muffled) 
[17:47:02.474]                           invokeRestart("muffleWarning")
[17:47:02.474]                       }
[17:47:02.474]                       else if (inherits(cond, "condition")) {
[17:47:02.474]                         if (!is.null(pattern)) {
[17:47:02.474]                           computeRestarts <- base::computeRestarts
[17:47:02.474]                           grepl <- base::grepl
[17:47:02.474]                           restarts <- computeRestarts(cond)
[17:47:02.474]                           for (restart in restarts) {
[17:47:02.474]                             name <- restart$name
[17:47:02.474]                             if (is.null(name)) 
[17:47:02.474]                               next
[17:47:02.474]                             if (!grepl(pattern, name)) 
[17:47:02.474]                               next
[17:47:02.474]                             invokeRestart(restart)
[17:47:02.474]                             muffled <- TRUE
[17:47:02.474]                             break
[17:47:02.474]                           }
[17:47:02.474]                         }
[17:47:02.474]                       }
[17:47:02.474]                       invisible(muffled)
[17:47:02.474]                     }
[17:47:02.474]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.474]                   }
[17:47:02.474]                 }
[17:47:02.474]                 else {
[17:47:02.474]                   if (TRUE) {
[17:47:02.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.474]                     {
[17:47:02.474]                       inherits <- base::inherits
[17:47:02.474]                       invokeRestart <- base::invokeRestart
[17:47:02.474]                       is.null <- base::is.null
[17:47:02.474]                       muffled <- FALSE
[17:47:02.474]                       if (inherits(cond, "message")) {
[17:47:02.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.474]                         if (muffled) 
[17:47:02.474]                           invokeRestart("muffleMessage")
[17:47:02.474]                       }
[17:47:02.474]                       else if (inherits(cond, "warning")) {
[17:47:02.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.474]                         if (muffled) 
[17:47:02.474]                           invokeRestart("muffleWarning")
[17:47:02.474]                       }
[17:47:02.474]                       else if (inherits(cond, "condition")) {
[17:47:02.474]                         if (!is.null(pattern)) {
[17:47:02.474]                           computeRestarts <- base::computeRestarts
[17:47:02.474]                           grepl <- base::grepl
[17:47:02.474]                           restarts <- computeRestarts(cond)
[17:47:02.474]                           for (restart in restarts) {
[17:47:02.474]                             name <- restart$name
[17:47:02.474]                             if (is.null(name)) 
[17:47:02.474]                               next
[17:47:02.474]                             if (!grepl(pattern, name)) 
[17:47:02.474]                               next
[17:47:02.474]                             invokeRestart(restart)
[17:47:02.474]                             muffled <- TRUE
[17:47:02.474]                             break
[17:47:02.474]                           }
[17:47:02.474]                         }
[17:47:02.474]                       }
[17:47:02.474]                       invisible(muffled)
[17:47:02.474]                     }
[17:47:02.474]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.474]                   }
[17:47:02.474]                 }
[17:47:02.474]             }
[17:47:02.474]         }))
[17:47:02.474]     }, error = function(ex) {
[17:47:02.474]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.474]                 ...future.rng), started = ...future.startTime, 
[17:47:02.474]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.474]             version = "1.8"), class = "FutureResult")
[17:47:02.474]     }, finally = {
[17:47:02.474]         if (!identical(...future.workdir, getwd())) 
[17:47:02.474]             setwd(...future.workdir)
[17:47:02.474]         {
[17:47:02.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.474]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.474]             }
[17:47:02.474]             base::options(...future.oldOptions)
[17:47:02.474]             if (.Platform$OS.type == "windows") {
[17:47:02.474]                 old_names <- names(...future.oldEnvVars)
[17:47:02.474]                 envs <- base::Sys.getenv()
[17:47:02.474]                 names <- names(envs)
[17:47:02.474]                 common <- intersect(names, old_names)
[17:47:02.474]                 added <- setdiff(names, old_names)
[17:47:02.474]                 removed <- setdiff(old_names, names)
[17:47:02.474]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.474]                   envs[common]]
[17:47:02.474]                 NAMES <- toupper(changed)
[17:47:02.474]                 args <- list()
[17:47:02.474]                 for (kk in seq_along(NAMES)) {
[17:47:02.474]                   name <- changed[[kk]]
[17:47:02.474]                   NAME <- NAMES[[kk]]
[17:47:02.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.474]                     next
[17:47:02.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.474]                 }
[17:47:02.474]                 NAMES <- toupper(added)
[17:47:02.474]                 for (kk in seq_along(NAMES)) {
[17:47:02.474]                   name <- added[[kk]]
[17:47:02.474]                   NAME <- NAMES[[kk]]
[17:47:02.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.474]                     next
[17:47:02.474]                   args[[name]] <- ""
[17:47:02.474]                 }
[17:47:02.474]                 NAMES <- toupper(removed)
[17:47:02.474]                 for (kk in seq_along(NAMES)) {
[17:47:02.474]                   name <- removed[[kk]]
[17:47:02.474]                   NAME <- NAMES[[kk]]
[17:47:02.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.474]                     next
[17:47:02.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.474]                 }
[17:47:02.474]                 if (length(args) > 0) 
[17:47:02.474]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.474]             }
[17:47:02.474]             else {
[17:47:02.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.474]             }
[17:47:02.474]             {
[17:47:02.474]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.474]                   0L) {
[17:47:02.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.474]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.474]                   base::options(opts)
[17:47:02.474]                 }
[17:47:02.474]                 {
[17:47:02.474]                   {
[17:47:02.474]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:02.474]                     NULL
[17:47:02.474]                   }
[17:47:02.474]                   options(future.plan = NULL)
[17:47:02.474]                   if (is.na(NA_character_)) 
[17:47:02.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.474]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.474]                     .init = FALSE)
[17:47:02.474]                 }
[17:47:02.474]             }
[17:47:02.474]         }
[17:47:02.474]     })
[17:47:02.474]     if (TRUE) {
[17:47:02.474]         base::sink(type = "output", split = FALSE)
[17:47:02.474]         if (TRUE) {
[17:47:02.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.474]         }
[17:47:02.474]         else {
[17:47:02.474]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.474]         }
[17:47:02.474]         base::close(...future.stdout)
[17:47:02.474]         ...future.stdout <- NULL
[17:47:02.474]     }
[17:47:02.474]     ...future.result$conditions <- ...future.conditions
[17:47:02.474]     ...future.result$finished <- base::Sys.time()
[17:47:02.474]     ...future.result
[17:47:02.474] }
[17:47:02.476] assign_globals() ...
[17:47:02.476] List of 1
[17:47:02.476]  $ x: list()
[17:47:02.476]  - attr(*, "where")=List of 1
[17:47:02.476]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.476]  - attr(*, "resolved")= logi TRUE
[17:47:02.476]  - attr(*, "total_size")= num 0
[17:47:02.476]  - attr(*, "already-done")= logi TRUE
[17:47:02.479] - copied ‘x’ to environment
[17:47:02.479] assign_globals() ... done
[17:47:02.479] requestCore(): workers = 2
[17:47:02.481] MulticoreFuture started
[17:47:02.481] - Launch lazy future ... done
[17:47:02.481] run() for ‘MulticoreFuture’ ... done
[17:47:02.482] result() for MulticoreFuture ...
[17:47:02.482] plan(): Setting new future strategy stack:
[17:47:02.482] List of future strategies:
[17:47:02.482] 1. sequential:
[17:47:02.482]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.482]    - tweaked: FALSE
[17:47:02.482]    - call: NULL
[17:47:02.483] plan(): nbrOfWorkers() = 1
[17:47:02.485] plan(): Setting new future strategy stack:
[17:47:02.485] List of future strategies:
[17:47:02.485] 1. multicore:
[17:47:02.485]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:02.485]    - tweaked: FALSE
[17:47:02.485]    - call: plan(strategy)
[17:47:02.490] plan(): nbrOfWorkers() = 2
[17:47:02.491] result() for MulticoreFuture ...
[17:47:02.491] result() for MulticoreFuture ... done
[17:47:02.491] result() for MulticoreFuture ... done
[17:47:02.492] result() for MulticoreFuture ...
[17:47:02.492] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.493] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.493] Searching for globals...
[17:47:02.496] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.496] Searching for globals ... DONE
[17:47:02.496] Resolving globals: TRUE
[17:47:02.496] Resolving any globals that are futures ...
[17:47:02.496] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:02.496] Resolving any globals that are futures ... DONE
[17:47:02.497] Resolving futures part of globals (recursively) ...
[17:47:02.497] resolve() on list ...
[17:47:02.497]  recursive: 99
[17:47:02.498]  length: 1
[17:47:02.498]  elements: ‘x’
[17:47:02.498]  length: 0 (resolved future 1)
[17:47:02.498] resolve() on list ... DONE
[17:47:02.498] - globals: [1] ‘x’
[17:47:02.498] Resolving futures part of globals (recursively) ... DONE
[17:47:02.498] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.499] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.499] - globals: [1] ‘x’
[17:47:02.499] 
[17:47:02.499] getGlobalsAndPackages() ... DONE
[17:47:02.499] run() for ‘Future’ ...
[17:47:02.500] - state: ‘created’
[17:47:02.500] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:02.504] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:02.504] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:02.504]   - Field: ‘label’
[17:47:02.504]   - Field: ‘local’
[17:47:02.504]   - Field: ‘owner’
[17:47:02.504]   - Field: ‘envir’
[17:47:02.504]   - Field: ‘workers’
[17:47:02.505]   - Field: ‘packages’
[17:47:02.505]   - Field: ‘gc’
[17:47:02.505]   - Field: ‘job’
[17:47:02.505]   - Field: ‘conditions’
[17:47:02.505]   - Field: ‘expr’
[17:47:02.505]   - Field: ‘uuid’
[17:47:02.505]   - Field: ‘seed’
[17:47:02.505]   - Field: ‘version’
[17:47:02.505]   - Field: ‘result’
[17:47:02.506]   - Field: ‘asynchronous’
[17:47:02.506]   - Field: ‘calls’
[17:47:02.506]   - Field: ‘globals’
[17:47:02.506]   - Field: ‘stdout’
[17:47:02.506]   - Field: ‘earlySignal’
[17:47:02.506]   - Field: ‘lazy’
[17:47:02.506]   - Field: ‘state’
[17:47:02.506] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:02.506] - Launch lazy future ...
[17:47:02.507] Packages needed by the future expression (n = 0): <none>
[17:47:02.507] Packages needed by future strategies (n = 0): <none>
[17:47:02.507] {
[17:47:02.507]     {
[17:47:02.507]         {
[17:47:02.507]             ...future.startTime <- base::Sys.time()
[17:47:02.507]             {
[17:47:02.507]                 {
[17:47:02.507]                   {
[17:47:02.507]                     {
[17:47:02.507]                       base::local({
[17:47:02.507]                         has_future <- base::requireNamespace("future", 
[17:47:02.507]                           quietly = TRUE)
[17:47:02.507]                         if (has_future) {
[17:47:02.507]                           ns <- base::getNamespace("future")
[17:47:02.507]                           version <- ns[[".package"]][["version"]]
[17:47:02.507]                           if (is.null(version)) 
[17:47:02.507]                             version <- utils::packageVersion("future")
[17:47:02.507]                         }
[17:47:02.507]                         else {
[17:47:02.507]                           version <- NULL
[17:47:02.507]                         }
[17:47:02.507]                         if (!has_future || version < "1.8.0") {
[17:47:02.507]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.507]                             "", base::R.version$version.string), 
[17:47:02.507]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:02.507]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.507]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.507]                               "release", "version")], collapse = " "), 
[17:47:02.507]                             hostname = base::Sys.info()[["nodename"]])
[17:47:02.507]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.507]                             info)
[17:47:02.507]                           info <- base::paste(info, collapse = "; ")
[17:47:02.507]                           if (!has_future) {
[17:47:02.507]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.507]                               info)
[17:47:02.507]                           }
[17:47:02.507]                           else {
[17:47:02.507]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.507]                               info, version)
[17:47:02.507]                           }
[17:47:02.507]                           base::stop(msg)
[17:47:02.507]                         }
[17:47:02.507]                       })
[17:47:02.507]                     }
[17:47:02.507]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:02.507]                     base::options(mc.cores = 1L)
[17:47:02.507]                   }
[17:47:02.507]                   ...future.strategy.old <- future::plan("list")
[17:47:02.507]                   options(future.plan = NULL)
[17:47:02.507]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.507]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.507]                 }
[17:47:02.507]                 ...future.workdir <- getwd()
[17:47:02.507]             }
[17:47:02.507]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.507]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.507]         }
[17:47:02.507]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.507]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.507]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.507]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.507]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.507]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.507]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.507]             base::names(...future.oldOptions))
[17:47:02.507]     }
[17:47:02.507]     if (FALSE) {
[17:47:02.507]     }
[17:47:02.507]     else {
[17:47:02.507]         if (TRUE) {
[17:47:02.507]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.507]                 open = "w")
[17:47:02.507]         }
[17:47:02.507]         else {
[17:47:02.507]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.507]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.507]         }
[17:47:02.507]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.507]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.507]             base::sink(type = "output", split = FALSE)
[17:47:02.507]             base::close(...future.stdout)
[17:47:02.507]         }, add = TRUE)
[17:47:02.507]     }
[17:47:02.507]     ...future.frame <- base::sys.nframe()
[17:47:02.507]     ...future.conditions <- base::list()
[17:47:02.507]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.507]     if (FALSE) {
[17:47:02.507]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.507]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.507]     }
[17:47:02.507]     ...future.result <- base::tryCatch({
[17:47:02.507]         base::withCallingHandlers({
[17:47:02.507]             ...future.value <- base::withVisible(base::local({
[17:47:02.507]                 withCallingHandlers({
[17:47:02.507]                   {
[17:47:02.507]                     x$a <- 1
[17:47:02.507]                     x
[17:47:02.507]                   }
[17:47:02.507]                 }, immediateCondition = function(cond) {
[17:47:02.507]                   save_rds <- function (object, pathname, ...) 
[17:47:02.507]                   {
[17:47:02.507]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:02.507]                     if (file_test("-f", pathname_tmp)) {
[17:47:02.507]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.507]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:02.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.507]                         fi_tmp[["mtime"]])
[17:47:02.507]                     }
[17:47:02.507]                     tryCatch({
[17:47:02.507]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:02.507]                     }, error = function(ex) {
[17:47:02.507]                       msg <- conditionMessage(ex)
[17:47:02.507]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.507]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:02.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.507]                         fi_tmp[["mtime"]], msg)
[17:47:02.507]                       ex$message <- msg
[17:47:02.507]                       stop(ex)
[17:47:02.507]                     })
[17:47:02.507]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:02.507]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:02.507]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:02.507]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.507]                       fi <- file.info(pathname)
[17:47:02.507]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:02.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.507]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:02.507]                         fi[["size"]], fi[["mtime"]])
[17:47:02.507]                       stop(msg)
[17:47:02.507]                     }
[17:47:02.507]                     invisible(pathname)
[17:47:02.507]                   }
[17:47:02.507]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:02.507]                     rootPath = tempdir()) 
[17:47:02.507]                   {
[17:47:02.507]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:02.507]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:02.507]                       tmpdir = path, fileext = ".rds")
[17:47:02.507]                     save_rds(obj, file)
[17:47:02.507]                   }
[17:47:02.507]                   saveImmediateCondition(cond, path = "/tmp/RtmpR4Ygft/.future/immediateConditions")
[17:47:02.507]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.507]                   {
[17:47:02.507]                     inherits <- base::inherits
[17:47:02.507]                     invokeRestart <- base::invokeRestart
[17:47:02.507]                     is.null <- base::is.null
[17:47:02.507]                     muffled <- FALSE
[17:47:02.507]                     if (inherits(cond, "message")) {
[17:47:02.507]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:02.507]                       if (muffled) 
[17:47:02.507]                         invokeRestart("muffleMessage")
[17:47:02.507]                     }
[17:47:02.507]                     else if (inherits(cond, "warning")) {
[17:47:02.507]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:02.507]                       if (muffled) 
[17:47:02.507]                         invokeRestart("muffleWarning")
[17:47:02.507]                     }
[17:47:02.507]                     else if (inherits(cond, "condition")) {
[17:47:02.507]                       if (!is.null(pattern)) {
[17:47:02.507]                         computeRestarts <- base::computeRestarts
[17:47:02.507]                         grepl <- base::grepl
[17:47:02.507]                         restarts <- computeRestarts(cond)
[17:47:02.507]                         for (restart in restarts) {
[17:47:02.507]                           name <- restart$name
[17:47:02.507]                           if (is.null(name)) 
[17:47:02.507]                             next
[17:47:02.507]                           if (!grepl(pattern, name)) 
[17:47:02.507]                             next
[17:47:02.507]                           invokeRestart(restart)
[17:47:02.507]                           muffled <- TRUE
[17:47:02.507]                           break
[17:47:02.507]                         }
[17:47:02.507]                       }
[17:47:02.507]                     }
[17:47:02.507]                     invisible(muffled)
[17:47:02.507]                   }
[17:47:02.507]                   muffleCondition(cond)
[17:47:02.507]                 })
[17:47:02.507]             }))
[17:47:02.507]             future::FutureResult(value = ...future.value$value, 
[17:47:02.507]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.507]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.507]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.507]                     ...future.globalenv.names))
[17:47:02.507]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.507]         }, condition = base::local({
[17:47:02.507]             c <- base::c
[17:47:02.507]             inherits <- base::inherits
[17:47:02.507]             invokeRestart <- base::invokeRestart
[17:47:02.507]             length <- base::length
[17:47:02.507]             list <- base::list
[17:47:02.507]             seq.int <- base::seq.int
[17:47:02.507]             signalCondition <- base::signalCondition
[17:47:02.507]             sys.calls <- base::sys.calls
[17:47:02.507]             `[[` <- base::`[[`
[17:47:02.507]             `+` <- base::`+`
[17:47:02.507]             `<<-` <- base::`<<-`
[17:47:02.507]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.507]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.507]                   3L)]
[17:47:02.507]             }
[17:47:02.507]             function(cond) {
[17:47:02.507]                 is_error <- inherits(cond, "error")
[17:47:02.507]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.507]                   NULL)
[17:47:02.507]                 if (is_error) {
[17:47:02.507]                   sessionInformation <- function() {
[17:47:02.507]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.507]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.507]                       search = base::search(), system = base::Sys.info())
[17:47:02.507]                   }
[17:47:02.507]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.507]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.507]                     cond$call), session = sessionInformation(), 
[17:47:02.507]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.507]                   signalCondition(cond)
[17:47:02.507]                 }
[17:47:02.507]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.507]                 "immediateCondition"))) {
[17:47:02.507]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.507]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.507]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.507]                   if (TRUE && !signal) {
[17:47:02.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.507]                     {
[17:47:02.507]                       inherits <- base::inherits
[17:47:02.507]                       invokeRestart <- base::invokeRestart
[17:47:02.507]                       is.null <- base::is.null
[17:47:02.507]                       muffled <- FALSE
[17:47:02.507]                       if (inherits(cond, "message")) {
[17:47:02.507]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.507]                         if (muffled) 
[17:47:02.507]                           invokeRestart("muffleMessage")
[17:47:02.507]                       }
[17:47:02.507]                       else if (inherits(cond, "warning")) {
[17:47:02.507]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.507]                         if (muffled) 
[17:47:02.507]                           invokeRestart("muffleWarning")
[17:47:02.507]                       }
[17:47:02.507]                       else if (inherits(cond, "condition")) {
[17:47:02.507]                         if (!is.null(pattern)) {
[17:47:02.507]                           computeRestarts <- base::computeRestarts
[17:47:02.507]                           grepl <- base::grepl
[17:47:02.507]                           restarts <- computeRestarts(cond)
[17:47:02.507]                           for (restart in restarts) {
[17:47:02.507]                             name <- restart$name
[17:47:02.507]                             if (is.null(name)) 
[17:47:02.507]                               next
[17:47:02.507]                             if (!grepl(pattern, name)) 
[17:47:02.507]                               next
[17:47:02.507]                             invokeRestart(restart)
[17:47:02.507]                             muffled <- TRUE
[17:47:02.507]                             break
[17:47:02.507]                           }
[17:47:02.507]                         }
[17:47:02.507]                       }
[17:47:02.507]                       invisible(muffled)
[17:47:02.507]                     }
[17:47:02.507]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.507]                   }
[17:47:02.507]                 }
[17:47:02.507]                 else {
[17:47:02.507]                   if (TRUE) {
[17:47:02.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.507]                     {
[17:47:02.507]                       inherits <- base::inherits
[17:47:02.507]                       invokeRestart <- base::invokeRestart
[17:47:02.507]                       is.null <- base::is.null
[17:47:02.507]                       muffled <- FALSE
[17:47:02.507]                       if (inherits(cond, "message")) {
[17:47:02.507]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.507]                         if (muffled) 
[17:47:02.507]                           invokeRestart("muffleMessage")
[17:47:02.507]                       }
[17:47:02.507]                       else if (inherits(cond, "warning")) {
[17:47:02.507]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.507]                         if (muffled) 
[17:47:02.507]                           invokeRestart("muffleWarning")
[17:47:02.507]                       }
[17:47:02.507]                       else if (inherits(cond, "condition")) {
[17:47:02.507]                         if (!is.null(pattern)) {
[17:47:02.507]                           computeRestarts <- base::computeRestarts
[17:47:02.507]                           grepl <- base::grepl
[17:47:02.507]                           restarts <- computeRestarts(cond)
[17:47:02.507]                           for (restart in restarts) {
[17:47:02.507]                             name <- restart$name
[17:47:02.507]                             if (is.null(name)) 
[17:47:02.507]                               next
[17:47:02.507]                             if (!grepl(pattern, name)) 
[17:47:02.507]                               next
[17:47:02.507]                             invokeRestart(restart)
[17:47:02.507]                             muffled <- TRUE
[17:47:02.507]                             break
[17:47:02.507]                           }
[17:47:02.507]                         }
[17:47:02.507]                       }
[17:47:02.507]                       invisible(muffled)
[17:47:02.507]                     }
[17:47:02.507]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.507]                   }
[17:47:02.507]                 }
[17:47:02.507]             }
[17:47:02.507]         }))
[17:47:02.507]     }, error = function(ex) {
[17:47:02.507]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.507]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.507]                 ...future.rng), started = ...future.startTime, 
[17:47:02.507]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.507]             version = "1.8"), class = "FutureResult")
[17:47:02.507]     }, finally = {
[17:47:02.507]         if (!identical(...future.workdir, getwd())) 
[17:47:02.507]             setwd(...future.workdir)
[17:47:02.507]         {
[17:47:02.507]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.507]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.507]             }
[17:47:02.507]             base::options(...future.oldOptions)
[17:47:02.507]             if (.Platform$OS.type == "windows") {
[17:47:02.507]                 old_names <- names(...future.oldEnvVars)
[17:47:02.507]                 envs <- base::Sys.getenv()
[17:47:02.507]                 names <- names(envs)
[17:47:02.507]                 common <- intersect(names, old_names)
[17:47:02.507]                 added <- setdiff(names, old_names)
[17:47:02.507]                 removed <- setdiff(old_names, names)
[17:47:02.507]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.507]                   envs[common]]
[17:47:02.507]                 NAMES <- toupper(changed)
[17:47:02.507]                 args <- list()
[17:47:02.507]                 for (kk in seq_along(NAMES)) {
[17:47:02.507]                   name <- changed[[kk]]
[17:47:02.507]                   NAME <- NAMES[[kk]]
[17:47:02.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.507]                     next
[17:47:02.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.507]                 }
[17:47:02.507]                 NAMES <- toupper(added)
[17:47:02.507]                 for (kk in seq_along(NAMES)) {
[17:47:02.507]                   name <- added[[kk]]
[17:47:02.507]                   NAME <- NAMES[[kk]]
[17:47:02.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.507]                     next
[17:47:02.507]                   args[[name]] <- ""
[17:47:02.507]                 }
[17:47:02.507]                 NAMES <- toupper(removed)
[17:47:02.507]                 for (kk in seq_along(NAMES)) {
[17:47:02.507]                   name <- removed[[kk]]
[17:47:02.507]                   NAME <- NAMES[[kk]]
[17:47:02.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.507]                     next
[17:47:02.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.507]                 }
[17:47:02.507]                 if (length(args) > 0) 
[17:47:02.507]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.507]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.507]             }
[17:47:02.507]             else {
[17:47:02.507]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.507]             }
[17:47:02.507]             {
[17:47:02.507]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.507]                   0L) {
[17:47:02.507]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.507]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.507]                   base::options(opts)
[17:47:02.507]                 }
[17:47:02.507]                 {
[17:47:02.507]                   {
[17:47:02.507]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:02.507]                     NULL
[17:47:02.507]                   }
[17:47:02.507]                   options(future.plan = NULL)
[17:47:02.507]                   if (is.na(NA_character_)) 
[17:47:02.507]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.507]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.507]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.507]                     .init = FALSE)
[17:47:02.507]                 }
[17:47:02.507]             }
[17:47:02.507]         }
[17:47:02.507]     })
[17:47:02.507]     if (TRUE) {
[17:47:02.507]         base::sink(type = "output", split = FALSE)
[17:47:02.507]         if (TRUE) {
[17:47:02.507]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.507]         }
[17:47:02.507]         else {
[17:47:02.507]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.507]         }
[17:47:02.507]         base::close(...future.stdout)
[17:47:02.507]         ...future.stdout <- NULL
[17:47:02.507]     }
[17:47:02.507]     ...future.result$conditions <- ...future.conditions
[17:47:02.507]     ...future.result$finished <- base::Sys.time()
[17:47:02.507]     ...future.result
[17:47:02.507] }
[17:47:02.510] assign_globals() ...
[17:47:02.510] List of 1
[17:47:02.510]  $ x: list()
[17:47:02.510]  - attr(*, "where")=List of 1
[17:47:02.510]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.510]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.510]  - attr(*, "resolved")= logi TRUE
[17:47:02.510]  - attr(*, "total_size")= num 0
[17:47:02.510]  - attr(*, "already-done")= logi TRUE
[17:47:02.513] - copied ‘x’ to environment
[17:47:02.513] assign_globals() ... done
[17:47:02.513] requestCore(): workers = 2
[17:47:02.515] MulticoreFuture started
[17:47:02.515] - Launch lazy future ... done
[17:47:02.516] run() for ‘MulticoreFuture’ ... done
[17:47:02.516] result() for MulticoreFuture ...
[17:47:02.516] plan(): Setting new future strategy stack:
[17:47:02.516] List of future strategies:
[17:47:02.516] 1. sequential:
[17:47:02.516]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.516]    - tweaked: FALSE
[17:47:02.516]    - call: NULL
[17:47:02.517] plan(): nbrOfWorkers() = 1
[17:47:02.519] plan(): Setting new future strategy stack:
[17:47:02.519] List of future strategies:
[17:47:02.519] 1. multicore:
[17:47:02.519]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:02.519]    - tweaked: FALSE
[17:47:02.519]    - call: plan(strategy)
[17:47:02.528] plan(): nbrOfWorkers() = 2
[17:47:02.529] result() for MulticoreFuture ...
[17:47:02.529] result() for MulticoreFuture ... done
[17:47:02.530] result() for MulticoreFuture ... done
[17:47:02.530] result() for MulticoreFuture ...
[17:47:02.530] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.531] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.531] Searching for globals...
[17:47:02.537] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:47:02.537] Searching for globals ... DONE
[17:47:02.538] Resolving globals: TRUE
[17:47:02.538] Resolving any globals that are futures ...
[17:47:02.538] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:47:02.538] Resolving any globals that are futures ... DONE
[17:47:02.538] 
[17:47:02.539] 
[17:47:02.539] getGlobalsAndPackages() ... DONE
[17:47:02.539] run() for ‘Future’ ...
[17:47:02.539] - state: ‘created’
[17:47:02.539] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:02.543] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:02.543] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:02.543]   - Field: ‘label’
[17:47:02.544]   - Field: ‘local’
[17:47:02.544]   - Field: ‘owner’
[17:47:02.544]   - Field: ‘envir’
[17:47:02.544]   - Field: ‘workers’
[17:47:02.544]   - Field: ‘packages’
[17:47:02.544]   - Field: ‘gc’
[17:47:02.544]   - Field: ‘job’
[17:47:02.544]   - Field: ‘conditions’
[17:47:02.545]   - Field: ‘expr’
[17:47:02.545]   - Field: ‘uuid’
[17:47:02.545]   - Field: ‘seed’
[17:47:02.545]   - Field: ‘version’
[17:47:02.545]   - Field: ‘result’
[17:47:02.545]   - Field: ‘asynchronous’
[17:47:02.545]   - Field: ‘calls’
[17:47:02.545]   - Field: ‘globals’
[17:47:02.545]   - Field: ‘stdout’
[17:47:02.546]   - Field: ‘earlySignal’
[17:47:02.546]   - Field: ‘lazy’
[17:47:02.546]   - Field: ‘state’
[17:47:02.546] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:02.546] - Launch lazy future ...
[17:47:02.546] Packages needed by the future expression (n = 0): <none>
[17:47:02.546] Packages needed by future strategies (n = 0): <none>
[17:47:02.547] {
[17:47:02.547]     {
[17:47:02.547]         {
[17:47:02.547]             ...future.startTime <- base::Sys.time()
[17:47:02.547]             {
[17:47:02.547]                 {
[17:47:02.547]                   {
[17:47:02.547]                     {
[17:47:02.547]                       base::local({
[17:47:02.547]                         has_future <- base::requireNamespace("future", 
[17:47:02.547]                           quietly = TRUE)
[17:47:02.547]                         if (has_future) {
[17:47:02.547]                           ns <- base::getNamespace("future")
[17:47:02.547]                           version <- ns[[".package"]][["version"]]
[17:47:02.547]                           if (is.null(version)) 
[17:47:02.547]                             version <- utils::packageVersion("future")
[17:47:02.547]                         }
[17:47:02.547]                         else {
[17:47:02.547]                           version <- NULL
[17:47:02.547]                         }
[17:47:02.547]                         if (!has_future || version < "1.8.0") {
[17:47:02.547]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.547]                             "", base::R.version$version.string), 
[17:47:02.547]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:02.547]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.547]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.547]                               "release", "version")], collapse = " "), 
[17:47:02.547]                             hostname = base::Sys.info()[["nodename"]])
[17:47:02.547]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.547]                             info)
[17:47:02.547]                           info <- base::paste(info, collapse = "; ")
[17:47:02.547]                           if (!has_future) {
[17:47:02.547]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.547]                               info)
[17:47:02.547]                           }
[17:47:02.547]                           else {
[17:47:02.547]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.547]                               info, version)
[17:47:02.547]                           }
[17:47:02.547]                           base::stop(msg)
[17:47:02.547]                         }
[17:47:02.547]                       })
[17:47:02.547]                     }
[17:47:02.547]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:02.547]                     base::options(mc.cores = 1L)
[17:47:02.547]                   }
[17:47:02.547]                   ...future.strategy.old <- future::plan("list")
[17:47:02.547]                   options(future.plan = NULL)
[17:47:02.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.547]                 }
[17:47:02.547]                 ...future.workdir <- getwd()
[17:47:02.547]             }
[17:47:02.547]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.547]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.547]         }
[17:47:02.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.547]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.547]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.547]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.547]             base::names(...future.oldOptions))
[17:47:02.547]     }
[17:47:02.547]     if (FALSE) {
[17:47:02.547]     }
[17:47:02.547]     else {
[17:47:02.547]         if (TRUE) {
[17:47:02.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.547]                 open = "w")
[17:47:02.547]         }
[17:47:02.547]         else {
[17:47:02.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.547]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.547]         }
[17:47:02.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.547]             base::sink(type = "output", split = FALSE)
[17:47:02.547]             base::close(...future.stdout)
[17:47:02.547]         }, add = TRUE)
[17:47:02.547]     }
[17:47:02.547]     ...future.frame <- base::sys.nframe()
[17:47:02.547]     ...future.conditions <- base::list()
[17:47:02.547]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.547]     if (FALSE) {
[17:47:02.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.547]     }
[17:47:02.547]     ...future.result <- base::tryCatch({
[17:47:02.547]         base::withCallingHandlers({
[17:47:02.547]             ...future.value <- base::withVisible(base::local({
[17:47:02.547]                 withCallingHandlers({
[17:47:02.547]                   {
[17:47:02.547]                     x <- list(b = 2)
[17:47:02.547]                     x$a <- 1
[17:47:02.547]                     x
[17:47:02.547]                   }
[17:47:02.547]                 }, immediateCondition = function(cond) {
[17:47:02.547]                   save_rds <- function (object, pathname, ...) 
[17:47:02.547]                   {
[17:47:02.547]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:02.547]                     if (file_test("-f", pathname_tmp)) {
[17:47:02.547]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.547]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:02.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.547]                         fi_tmp[["mtime"]])
[17:47:02.547]                     }
[17:47:02.547]                     tryCatch({
[17:47:02.547]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:02.547]                     }, error = function(ex) {
[17:47:02.547]                       msg <- conditionMessage(ex)
[17:47:02.547]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.547]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:02.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.547]                         fi_tmp[["mtime"]], msg)
[17:47:02.547]                       ex$message <- msg
[17:47:02.547]                       stop(ex)
[17:47:02.547]                     })
[17:47:02.547]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:02.547]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:02.547]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:02.547]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.547]                       fi <- file.info(pathname)
[17:47:02.547]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:02.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.547]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:02.547]                         fi[["size"]], fi[["mtime"]])
[17:47:02.547]                       stop(msg)
[17:47:02.547]                     }
[17:47:02.547]                     invisible(pathname)
[17:47:02.547]                   }
[17:47:02.547]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:02.547]                     rootPath = tempdir()) 
[17:47:02.547]                   {
[17:47:02.547]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:02.547]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:02.547]                       tmpdir = path, fileext = ".rds")
[17:47:02.547]                     save_rds(obj, file)
[17:47:02.547]                   }
[17:47:02.547]                   saveImmediateCondition(cond, path = "/tmp/RtmpR4Ygft/.future/immediateConditions")
[17:47:02.547]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.547]                   {
[17:47:02.547]                     inherits <- base::inherits
[17:47:02.547]                     invokeRestart <- base::invokeRestart
[17:47:02.547]                     is.null <- base::is.null
[17:47:02.547]                     muffled <- FALSE
[17:47:02.547]                     if (inherits(cond, "message")) {
[17:47:02.547]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:02.547]                       if (muffled) 
[17:47:02.547]                         invokeRestart("muffleMessage")
[17:47:02.547]                     }
[17:47:02.547]                     else if (inherits(cond, "warning")) {
[17:47:02.547]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:02.547]                       if (muffled) 
[17:47:02.547]                         invokeRestart("muffleWarning")
[17:47:02.547]                     }
[17:47:02.547]                     else if (inherits(cond, "condition")) {
[17:47:02.547]                       if (!is.null(pattern)) {
[17:47:02.547]                         computeRestarts <- base::computeRestarts
[17:47:02.547]                         grepl <- base::grepl
[17:47:02.547]                         restarts <- computeRestarts(cond)
[17:47:02.547]                         for (restart in restarts) {
[17:47:02.547]                           name <- restart$name
[17:47:02.547]                           if (is.null(name)) 
[17:47:02.547]                             next
[17:47:02.547]                           if (!grepl(pattern, name)) 
[17:47:02.547]                             next
[17:47:02.547]                           invokeRestart(restart)
[17:47:02.547]                           muffled <- TRUE
[17:47:02.547]                           break
[17:47:02.547]                         }
[17:47:02.547]                       }
[17:47:02.547]                     }
[17:47:02.547]                     invisible(muffled)
[17:47:02.547]                   }
[17:47:02.547]                   muffleCondition(cond)
[17:47:02.547]                 })
[17:47:02.547]             }))
[17:47:02.547]             future::FutureResult(value = ...future.value$value, 
[17:47:02.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.547]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.547]                     ...future.globalenv.names))
[17:47:02.547]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.547]         }, condition = base::local({
[17:47:02.547]             c <- base::c
[17:47:02.547]             inherits <- base::inherits
[17:47:02.547]             invokeRestart <- base::invokeRestart
[17:47:02.547]             length <- base::length
[17:47:02.547]             list <- base::list
[17:47:02.547]             seq.int <- base::seq.int
[17:47:02.547]             signalCondition <- base::signalCondition
[17:47:02.547]             sys.calls <- base::sys.calls
[17:47:02.547]             `[[` <- base::`[[`
[17:47:02.547]             `+` <- base::`+`
[17:47:02.547]             `<<-` <- base::`<<-`
[17:47:02.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.547]                   3L)]
[17:47:02.547]             }
[17:47:02.547]             function(cond) {
[17:47:02.547]                 is_error <- inherits(cond, "error")
[17:47:02.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.547]                   NULL)
[17:47:02.547]                 if (is_error) {
[17:47:02.547]                   sessionInformation <- function() {
[17:47:02.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.547]                       search = base::search(), system = base::Sys.info())
[17:47:02.547]                   }
[17:47:02.547]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.547]                     cond$call), session = sessionInformation(), 
[17:47:02.547]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.547]                   signalCondition(cond)
[17:47:02.547]                 }
[17:47:02.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.547]                 "immediateCondition"))) {
[17:47:02.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.547]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.547]                   if (TRUE && !signal) {
[17:47:02.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.547]                     {
[17:47:02.547]                       inherits <- base::inherits
[17:47:02.547]                       invokeRestart <- base::invokeRestart
[17:47:02.547]                       is.null <- base::is.null
[17:47:02.547]                       muffled <- FALSE
[17:47:02.547]                       if (inherits(cond, "message")) {
[17:47:02.547]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.547]                         if (muffled) 
[17:47:02.547]                           invokeRestart("muffleMessage")
[17:47:02.547]                       }
[17:47:02.547]                       else if (inherits(cond, "warning")) {
[17:47:02.547]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.547]                         if (muffled) 
[17:47:02.547]                           invokeRestart("muffleWarning")
[17:47:02.547]                       }
[17:47:02.547]                       else if (inherits(cond, "condition")) {
[17:47:02.547]                         if (!is.null(pattern)) {
[17:47:02.547]                           computeRestarts <- base::computeRestarts
[17:47:02.547]                           grepl <- base::grepl
[17:47:02.547]                           restarts <- computeRestarts(cond)
[17:47:02.547]                           for (restart in restarts) {
[17:47:02.547]                             name <- restart$name
[17:47:02.547]                             if (is.null(name)) 
[17:47:02.547]                               next
[17:47:02.547]                             if (!grepl(pattern, name)) 
[17:47:02.547]                               next
[17:47:02.547]                             invokeRestart(restart)
[17:47:02.547]                             muffled <- TRUE
[17:47:02.547]                             break
[17:47:02.547]                           }
[17:47:02.547]                         }
[17:47:02.547]                       }
[17:47:02.547]                       invisible(muffled)
[17:47:02.547]                     }
[17:47:02.547]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.547]                   }
[17:47:02.547]                 }
[17:47:02.547]                 else {
[17:47:02.547]                   if (TRUE) {
[17:47:02.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.547]                     {
[17:47:02.547]                       inherits <- base::inherits
[17:47:02.547]                       invokeRestart <- base::invokeRestart
[17:47:02.547]                       is.null <- base::is.null
[17:47:02.547]                       muffled <- FALSE
[17:47:02.547]                       if (inherits(cond, "message")) {
[17:47:02.547]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.547]                         if (muffled) 
[17:47:02.547]                           invokeRestart("muffleMessage")
[17:47:02.547]                       }
[17:47:02.547]                       else if (inherits(cond, "warning")) {
[17:47:02.547]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.547]                         if (muffled) 
[17:47:02.547]                           invokeRestart("muffleWarning")
[17:47:02.547]                       }
[17:47:02.547]                       else if (inherits(cond, "condition")) {
[17:47:02.547]                         if (!is.null(pattern)) {
[17:47:02.547]                           computeRestarts <- base::computeRestarts
[17:47:02.547]                           grepl <- base::grepl
[17:47:02.547]                           restarts <- computeRestarts(cond)
[17:47:02.547]                           for (restart in restarts) {
[17:47:02.547]                             name <- restart$name
[17:47:02.547]                             if (is.null(name)) 
[17:47:02.547]                               next
[17:47:02.547]                             if (!grepl(pattern, name)) 
[17:47:02.547]                               next
[17:47:02.547]                             invokeRestart(restart)
[17:47:02.547]                             muffled <- TRUE
[17:47:02.547]                             break
[17:47:02.547]                           }
[17:47:02.547]                         }
[17:47:02.547]                       }
[17:47:02.547]                       invisible(muffled)
[17:47:02.547]                     }
[17:47:02.547]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.547]                   }
[17:47:02.547]                 }
[17:47:02.547]             }
[17:47:02.547]         }))
[17:47:02.547]     }, error = function(ex) {
[17:47:02.547]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.547]                 ...future.rng), started = ...future.startTime, 
[17:47:02.547]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.547]             version = "1.8"), class = "FutureResult")
[17:47:02.547]     }, finally = {
[17:47:02.547]         if (!identical(...future.workdir, getwd())) 
[17:47:02.547]             setwd(...future.workdir)
[17:47:02.547]         {
[17:47:02.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.547]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.547]             }
[17:47:02.547]             base::options(...future.oldOptions)
[17:47:02.547]             if (.Platform$OS.type == "windows") {
[17:47:02.547]                 old_names <- names(...future.oldEnvVars)
[17:47:02.547]                 envs <- base::Sys.getenv()
[17:47:02.547]                 names <- names(envs)
[17:47:02.547]                 common <- intersect(names, old_names)
[17:47:02.547]                 added <- setdiff(names, old_names)
[17:47:02.547]                 removed <- setdiff(old_names, names)
[17:47:02.547]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.547]                   envs[common]]
[17:47:02.547]                 NAMES <- toupper(changed)
[17:47:02.547]                 args <- list()
[17:47:02.547]                 for (kk in seq_along(NAMES)) {
[17:47:02.547]                   name <- changed[[kk]]
[17:47:02.547]                   NAME <- NAMES[[kk]]
[17:47:02.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.547]                     next
[17:47:02.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.547]                 }
[17:47:02.547]                 NAMES <- toupper(added)
[17:47:02.547]                 for (kk in seq_along(NAMES)) {
[17:47:02.547]                   name <- added[[kk]]
[17:47:02.547]                   NAME <- NAMES[[kk]]
[17:47:02.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.547]                     next
[17:47:02.547]                   args[[name]] <- ""
[17:47:02.547]                 }
[17:47:02.547]                 NAMES <- toupper(removed)
[17:47:02.547]                 for (kk in seq_along(NAMES)) {
[17:47:02.547]                   name <- removed[[kk]]
[17:47:02.547]                   NAME <- NAMES[[kk]]
[17:47:02.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.547]                     next
[17:47:02.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.547]                 }
[17:47:02.547]                 if (length(args) > 0) 
[17:47:02.547]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.547]             }
[17:47:02.547]             else {
[17:47:02.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.547]             }
[17:47:02.547]             {
[17:47:02.547]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.547]                   0L) {
[17:47:02.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.547]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.547]                   base::options(opts)
[17:47:02.547]                 }
[17:47:02.547]                 {
[17:47:02.547]                   {
[17:47:02.547]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:02.547]                     NULL
[17:47:02.547]                   }
[17:47:02.547]                   options(future.plan = NULL)
[17:47:02.547]                   if (is.na(NA_character_)) 
[17:47:02.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.547]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.547]                     .init = FALSE)
[17:47:02.547]                 }
[17:47:02.547]             }
[17:47:02.547]         }
[17:47:02.547]     })
[17:47:02.547]     if (TRUE) {
[17:47:02.547]         base::sink(type = "output", split = FALSE)
[17:47:02.547]         if (TRUE) {
[17:47:02.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.547]         }
[17:47:02.547]         else {
[17:47:02.547]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.547]         }
[17:47:02.547]         base::close(...future.stdout)
[17:47:02.547]         ...future.stdout <- NULL
[17:47:02.547]     }
[17:47:02.547]     ...future.result$conditions <- ...future.conditions
[17:47:02.547]     ...future.result$finished <- base::Sys.time()
[17:47:02.547]     ...future.result
[17:47:02.547] }
[17:47:02.549] requestCore(): workers = 2
[17:47:02.551] MulticoreFuture started
[17:47:02.551] - Launch lazy future ... done
[17:47:02.552] run() for ‘MulticoreFuture’ ... done
[17:47:02.552] result() for MulticoreFuture ...
[17:47:02.552] plan(): Setting new future strategy stack:
[17:47:02.553] List of future strategies:
[17:47:02.553] 1. sequential:
[17:47:02.553]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.553]    - tweaked: FALSE
[17:47:02.553]    - call: NULL
[17:47:02.554] plan(): nbrOfWorkers() = 1
[17:47:02.556] plan(): Setting new future strategy stack:
[17:47:02.556] List of future strategies:
[17:47:02.556] 1. multicore:
[17:47:02.556]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:02.556]    - tweaked: FALSE
[17:47:02.556]    - call: plan(strategy)
[17:47:02.561] plan(): nbrOfWorkers() = 2
[17:47:02.562] result() for MulticoreFuture ...
[17:47:02.562] result() for MulticoreFuture ... done
[17:47:02.562] result() for MulticoreFuture ... done
[17:47:02.562] result() for MulticoreFuture ...
[17:47:02.562] result() for MulticoreFuture ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.563] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.563] Searching for globals...
[17:47:02.566] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:02.566] Searching for globals ... DONE
[17:47:02.566] Resolving globals: TRUE
[17:47:02.566] Resolving any globals that are futures ...
[17:47:02.566] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:02.566] Resolving any globals that are futures ... DONE
[17:47:02.567] Resolving futures part of globals (recursively) ...
[17:47:02.567] resolve() on list ...
[17:47:02.567]  recursive: 99
[17:47:02.567]  length: 1
[17:47:02.567]  elements: ‘x’
[17:47:02.568]  length: 0 (resolved future 1)
[17:47:02.568] resolve() on list ... DONE
[17:47:02.568] - globals: [1] ‘x’
[17:47:02.568] Resolving futures part of globals (recursively) ... DONE
[17:47:02.568] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.569] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.569] - globals: [1] ‘x’
[17:47:02.569] 
[17:47:02.569] getGlobalsAndPackages() ... DONE
[17:47:02.569] run() for ‘Future’ ...
[17:47:02.569] - state: ‘created’
[17:47:02.570] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:02.574] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:02.574] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:02.574]   - Field: ‘label’
[17:47:02.574]   - Field: ‘local’
[17:47:02.574]   - Field: ‘owner’
[17:47:02.574]   - Field: ‘envir’
[17:47:02.574]   - Field: ‘workers’
[17:47:02.574]   - Field: ‘packages’
[17:47:02.575]   - Field: ‘gc’
[17:47:02.575]   - Field: ‘job’
[17:47:02.575]   - Field: ‘conditions’
[17:47:02.575]   - Field: ‘expr’
[17:47:02.575]   - Field: ‘uuid’
[17:47:02.575]   - Field: ‘seed’
[17:47:02.575]   - Field: ‘version’
[17:47:02.575]   - Field: ‘result’
[17:47:02.576]   - Field: ‘asynchronous’
[17:47:02.576]   - Field: ‘calls’
[17:47:02.576]   - Field: ‘globals’
[17:47:02.576]   - Field: ‘stdout’
[17:47:02.576]   - Field: ‘earlySignal’
[17:47:02.576]   - Field: ‘lazy’
[17:47:02.576]   - Field: ‘state’
[17:47:02.576] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:02.576] - Launch lazy future ...
[17:47:02.577] Packages needed by the future expression (n = 0): <none>
[17:47:02.577] Packages needed by future strategies (n = 0): <none>
[17:47:02.577] {
[17:47:02.577]     {
[17:47:02.577]         {
[17:47:02.577]             ...future.startTime <- base::Sys.time()
[17:47:02.577]             {
[17:47:02.577]                 {
[17:47:02.577]                   {
[17:47:02.577]                     {
[17:47:02.577]                       base::local({
[17:47:02.577]                         has_future <- base::requireNamespace("future", 
[17:47:02.577]                           quietly = TRUE)
[17:47:02.577]                         if (has_future) {
[17:47:02.577]                           ns <- base::getNamespace("future")
[17:47:02.577]                           version <- ns[[".package"]][["version"]]
[17:47:02.577]                           if (is.null(version)) 
[17:47:02.577]                             version <- utils::packageVersion("future")
[17:47:02.577]                         }
[17:47:02.577]                         else {
[17:47:02.577]                           version <- NULL
[17:47:02.577]                         }
[17:47:02.577]                         if (!has_future || version < "1.8.0") {
[17:47:02.577]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.577]                             "", base::R.version$version.string), 
[17:47:02.577]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:02.577]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.577]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.577]                               "release", "version")], collapse = " "), 
[17:47:02.577]                             hostname = base::Sys.info()[["nodename"]])
[17:47:02.577]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.577]                             info)
[17:47:02.577]                           info <- base::paste(info, collapse = "; ")
[17:47:02.577]                           if (!has_future) {
[17:47:02.577]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.577]                               info)
[17:47:02.577]                           }
[17:47:02.577]                           else {
[17:47:02.577]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.577]                               info, version)
[17:47:02.577]                           }
[17:47:02.577]                           base::stop(msg)
[17:47:02.577]                         }
[17:47:02.577]                       })
[17:47:02.577]                     }
[17:47:02.577]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:02.577]                     base::options(mc.cores = 1L)
[17:47:02.577]                   }
[17:47:02.577]                   ...future.strategy.old <- future::plan("list")
[17:47:02.577]                   options(future.plan = NULL)
[17:47:02.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.577]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.577]                 }
[17:47:02.577]                 ...future.workdir <- getwd()
[17:47:02.577]             }
[17:47:02.577]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.577]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.577]         }
[17:47:02.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.577]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.577]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.577]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.577]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.577]             base::names(...future.oldOptions))
[17:47:02.577]     }
[17:47:02.577]     if (FALSE) {
[17:47:02.577]     }
[17:47:02.577]     else {
[17:47:02.577]         if (TRUE) {
[17:47:02.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.577]                 open = "w")
[17:47:02.577]         }
[17:47:02.577]         else {
[17:47:02.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.577]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.577]         }
[17:47:02.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.577]             base::sink(type = "output", split = FALSE)
[17:47:02.577]             base::close(...future.stdout)
[17:47:02.577]         }, add = TRUE)
[17:47:02.577]     }
[17:47:02.577]     ...future.frame <- base::sys.nframe()
[17:47:02.577]     ...future.conditions <- base::list()
[17:47:02.577]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.577]     if (FALSE) {
[17:47:02.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.577]     }
[17:47:02.577]     ...future.result <- base::tryCatch({
[17:47:02.577]         base::withCallingHandlers({
[17:47:02.577]             ...future.value <- base::withVisible(base::local({
[17:47:02.577]                 withCallingHandlers({
[17:47:02.577]                   {
[17:47:02.577]                     x[["a"]] <- 1
[17:47:02.577]                     x
[17:47:02.577]                   }
[17:47:02.577]                 }, immediateCondition = function(cond) {
[17:47:02.577]                   save_rds <- function (object, pathname, ...) 
[17:47:02.577]                   {
[17:47:02.577]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:02.577]                     if (file_test("-f", pathname_tmp)) {
[17:47:02.577]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.577]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:02.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.577]                         fi_tmp[["mtime"]])
[17:47:02.577]                     }
[17:47:02.577]                     tryCatch({
[17:47:02.577]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:02.577]                     }, error = function(ex) {
[17:47:02.577]                       msg <- conditionMessage(ex)
[17:47:02.577]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.577]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:02.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.577]                         fi_tmp[["mtime"]], msg)
[17:47:02.577]                       ex$message <- msg
[17:47:02.577]                       stop(ex)
[17:47:02.577]                     })
[17:47:02.577]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:02.577]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:02.577]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:02.577]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.577]                       fi <- file.info(pathname)
[17:47:02.577]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:02.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.577]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:02.577]                         fi[["size"]], fi[["mtime"]])
[17:47:02.577]                       stop(msg)
[17:47:02.577]                     }
[17:47:02.577]                     invisible(pathname)
[17:47:02.577]                   }
[17:47:02.577]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:02.577]                     rootPath = tempdir()) 
[17:47:02.577]                   {
[17:47:02.577]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:02.577]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:02.577]                       tmpdir = path, fileext = ".rds")
[17:47:02.577]                     save_rds(obj, file)
[17:47:02.577]                   }
[17:47:02.577]                   saveImmediateCondition(cond, path = "/tmp/RtmpR4Ygft/.future/immediateConditions")
[17:47:02.577]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.577]                   {
[17:47:02.577]                     inherits <- base::inherits
[17:47:02.577]                     invokeRestart <- base::invokeRestart
[17:47:02.577]                     is.null <- base::is.null
[17:47:02.577]                     muffled <- FALSE
[17:47:02.577]                     if (inherits(cond, "message")) {
[17:47:02.577]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:02.577]                       if (muffled) 
[17:47:02.577]                         invokeRestart("muffleMessage")
[17:47:02.577]                     }
[17:47:02.577]                     else if (inherits(cond, "warning")) {
[17:47:02.577]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:02.577]                       if (muffled) 
[17:47:02.577]                         invokeRestart("muffleWarning")
[17:47:02.577]                     }
[17:47:02.577]                     else if (inherits(cond, "condition")) {
[17:47:02.577]                       if (!is.null(pattern)) {
[17:47:02.577]                         computeRestarts <- base::computeRestarts
[17:47:02.577]                         grepl <- base::grepl
[17:47:02.577]                         restarts <- computeRestarts(cond)
[17:47:02.577]                         for (restart in restarts) {
[17:47:02.577]                           name <- restart$name
[17:47:02.577]                           if (is.null(name)) 
[17:47:02.577]                             next
[17:47:02.577]                           if (!grepl(pattern, name)) 
[17:47:02.577]                             next
[17:47:02.577]                           invokeRestart(restart)
[17:47:02.577]                           muffled <- TRUE
[17:47:02.577]                           break
[17:47:02.577]                         }
[17:47:02.577]                       }
[17:47:02.577]                     }
[17:47:02.577]                     invisible(muffled)
[17:47:02.577]                   }
[17:47:02.577]                   muffleCondition(cond)
[17:47:02.577]                 })
[17:47:02.577]             }))
[17:47:02.577]             future::FutureResult(value = ...future.value$value, 
[17:47:02.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.577]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.577]                     ...future.globalenv.names))
[17:47:02.577]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.577]         }, condition = base::local({
[17:47:02.577]             c <- base::c
[17:47:02.577]             inherits <- base::inherits
[17:47:02.577]             invokeRestart <- base::invokeRestart
[17:47:02.577]             length <- base::length
[17:47:02.577]             list <- base::list
[17:47:02.577]             seq.int <- base::seq.int
[17:47:02.577]             signalCondition <- base::signalCondition
[17:47:02.577]             sys.calls <- base::sys.calls
[17:47:02.577]             `[[` <- base::`[[`
[17:47:02.577]             `+` <- base::`+`
[17:47:02.577]             `<<-` <- base::`<<-`
[17:47:02.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.577]                   3L)]
[17:47:02.577]             }
[17:47:02.577]             function(cond) {
[17:47:02.577]                 is_error <- inherits(cond, "error")
[17:47:02.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.577]                   NULL)
[17:47:02.577]                 if (is_error) {
[17:47:02.577]                   sessionInformation <- function() {
[17:47:02.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.577]                       search = base::search(), system = base::Sys.info())
[17:47:02.577]                   }
[17:47:02.577]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.577]                     cond$call), session = sessionInformation(), 
[17:47:02.577]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.577]                   signalCondition(cond)
[17:47:02.577]                 }
[17:47:02.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.577]                 "immediateCondition"))) {
[17:47:02.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.577]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.577]                   if (TRUE && !signal) {
[17:47:02.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.577]                     {
[17:47:02.577]                       inherits <- base::inherits
[17:47:02.577]                       invokeRestart <- base::invokeRestart
[17:47:02.577]                       is.null <- base::is.null
[17:47:02.577]                       muffled <- FALSE
[17:47:02.577]                       if (inherits(cond, "message")) {
[17:47:02.577]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.577]                         if (muffled) 
[17:47:02.577]                           invokeRestart("muffleMessage")
[17:47:02.577]                       }
[17:47:02.577]                       else if (inherits(cond, "warning")) {
[17:47:02.577]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.577]                         if (muffled) 
[17:47:02.577]                           invokeRestart("muffleWarning")
[17:47:02.577]                       }
[17:47:02.577]                       else if (inherits(cond, "condition")) {
[17:47:02.577]                         if (!is.null(pattern)) {
[17:47:02.577]                           computeRestarts <- base::computeRestarts
[17:47:02.577]                           grepl <- base::grepl
[17:47:02.577]                           restarts <- computeRestarts(cond)
[17:47:02.577]                           for (restart in restarts) {
[17:47:02.577]                             name <- restart$name
[17:47:02.577]                             if (is.null(name)) 
[17:47:02.577]                               next
[17:47:02.577]                             if (!grepl(pattern, name)) 
[17:47:02.577]                               next
[17:47:02.577]                             invokeRestart(restart)
[17:47:02.577]                             muffled <- TRUE
[17:47:02.577]                             break
[17:47:02.577]                           }
[17:47:02.577]                         }
[17:47:02.577]                       }
[17:47:02.577]                       invisible(muffled)
[17:47:02.577]                     }
[17:47:02.577]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.577]                   }
[17:47:02.577]                 }
[17:47:02.577]                 else {
[17:47:02.577]                   if (TRUE) {
[17:47:02.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.577]                     {
[17:47:02.577]                       inherits <- base::inherits
[17:47:02.577]                       invokeRestart <- base::invokeRestart
[17:47:02.577]                       is.null <- base::is.null
[17:47:02.577]                       muffled <- FALSE
[17:47:02.577]                       if (inherits(cond, "message")) {
[17:47:02.577]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.577]                         if (muffled) 
[17:47:02.577]                           invokeRestart("muffleMessage")
[17:47:02.577]                       }
[17:47:02.577]                       else if (inherits(cond, "warning")) {
[17:47:02.577]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.577]                         if (muffled) 
[17:47:02.577]                           invokeRestart("muffleWarning")
[17:47:02.577]                       }
[17:47:02.577]                       else if (inherits(cond, "condition")) {
[17:47:02.577]                         if (!is.null(pattern)) {
[17:47:02.577]                           computeRestarts <- base::computeRestarts
[17:47:02.577]                           grepl <- base::grepl
[17:47:02.577]                           restarts <- computeRestarts(cond)
[17:47:02.577]                           for (restart in restarts) {
[17:47:02.577]                             name <- restart$name
[17:47:02.577]                             if (is.null(name)) 
[17:47:02.577]                               next
[17:47:02.577]                             if (!grepl(pattern, name)) 
[17:47:02.577]                               next
[17:47:02.577]                             invokeRestart(restart)
[17:47:02.577]                             muffled <- TRUE
[17:47:02.577]                             break
[17:47:02.577]                           }
[17:47:02.577]                         }
[17:47:02.577]                       }
[17:47:02.577]                       invisible(muffled)
[17:47:02.577]                     }
[17:47:02.577]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.577]                   }
[17:47:02.577]                 }
[17:47:02.577]             }
[17:47:02.577]         }))
[17:47:02.577]     }, error = function(ex) {
[17:47:02.577]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.577]                 ...future.rng), started = ...future.startTime, 
[17:47:02.577]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.577]             version = "1.8"), class = "FutureResult")
[17:47:02.577]     }, finally = {
[17:47:02.577]         if (!identical(...future.workdir, getwd())) 
[17:47:02.577]             setwd(...future.workdir)
[17:47:02.577]         {
[17:47:02.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.577]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.577]             }
[17:47:02.577]             base::options(...future.oldOptions)
[17:47:02.577]             if (.Platform$OS.type == "windows") {
[17:47:02.577]                 old_names <- names(...future.oldEnvVars)
[17:47:02.577]                 envs <- base::Sys.getenv()
[17:47:02.577]                 names <- names(envs)
[17:47:02.577]                 common <- intersect(names, old_names)
[17:47:02.577]                 added <- setdiff(names, old_names)
[17:47:02.577]                 removed <- setdiff(old_names, names)
[17:47:02.577]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.577]                   envs[common]]
[17:47:02.577]                 NAMES <- toupper(changed)
[17:47:02.577]                 args <- list()
[17:47:02.577]                 for (kk in seq_along(NAMES)) {
[17:47:02.577]                   name <- changed[[kk]]
[17:47:02.577]                   NAME <- NAMES[[kk]]
[17:47:02.577]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.577]                     next
[17:47:02.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.577]                 }
[17:47:02.577]                 NAMES <- toupper(added)
[17:47:02.577]                 for (kk in seq_along(NAMES)) {
[17:47:02.577]                   name <- added[[kk]]
[17:47:02.577]                   NAME <- NAMES[[kk]]
[17:47:02.577]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.577]                     next
[17:47:02.577]                   args[[name]] <- ""
[17:47:02.577]                 }
[17:47:02.577]                 NAMES <- toupper(removed)
[17:47:02.577]                 for (kk in seq_along(NAMES)) {
[17:47:02.577]                   name <- removed[[kk]]
[17:47:02.577]                   NAME <- NAMES[[kk]]
[17:47:02.577]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.577]                     next
[17:47:02.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.577]                 }
[17:47:02.577]                 if (length(args) > 0) 
[17:47:02.577]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.577]             }
[17:47:02.577]             else {
[17:47:02.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.577]             }
[17:47:02.577]             {
[17:47:02.577]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.577]                   0L) {
[17:47:02.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.577]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.577]                   base::options(opts)
[17:47:02.577]                 }
[17:47:02.577]                 {
[17:47:02.577]                   {
[17:47:02.577]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:02.577]                     NULL
[17:47:02.577]                   }
[17:47:02.577]                   options(future.plan = NULL)
[17:47:02.577]                   if (is.na(NA_character_)) 
[17:47:02.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.577]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.577]                     .init = FALSE)
[17:47:02.577]                 }
[17:47:02.577]             }
[17:47:02.577]         }
[17:47:02.577]     })
[17:47:02.577]     if (TRUE) {
[17:47:02.577]         base::sink(type = "output", split = FALSE)
[17:47:02.577]         if (TRUE) {
[17:47:02.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.577]         }
[17:47:02.577]         else {
[17:47:02.577]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.577]         }
[17:47:02.577]         base::close(...future.stdout)
[17:47:02.577]         ...future.stdout <- NULL
[17:47:02.577]     }
[17:47:02.577]     ...future.result$conditions <- ...future.conditions
[17:47:02.577]     ...future.result$finished <- base::Sys.time()
[17:47:02.577]     ...future.result
[17:47:02.577] }
[17:47:02.580] assign_globals() ...
[17:47:02.580] List of 1
[17:47:02.580]  $ x: list()
[17:47:02.580]  - attr(*, "where")=List of 1
[17:47:02.580]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.580]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.580]  - attr(*, "resolved")= logi TRUE
[17:47:02.580]  - attr(*, "total_size")= num 0
[17:47:02.580]  - attr(*, "already-done")= logi TRUE
[17:47:02.583] - copied ‘x’ to environment
[17:47:02.583] assign_globals() ... done
[17:47:02.583] requestCore(): workers = 2
[17:47:02.585] MulticoreFuture started
[17:47:02.585] - Launch lazy future ... done
[17:47:02.585] run() for ‘MulticoreFuture’ ... done
[17:47:02.586] plan(): Setting new future strategy stack:
[17:47:02.586] result() for MulticoreFuture ...
[17:47:02.586] List of future strategies:
[17:47:02.586] 1. sequential:
[17:47:02.586]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.586]    - tweaked: FALSE
[17:47:02.586]    - call: NULL
[17:47:02.591] plan(): nbrOfWorkers() = 1
[17:47:02.593] plan(): Setting new future strategy stack:
[17:47:02.593] List of future strategies:
[17:47:02.593] 1. multicore:
[17:47:02.593]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:02.593]    - tweaked: FALSE
[17:47:02.593]    - call: plan(strategy)
[17:47:02.598] plan(): nbrOfWorkers() = 2
[17:47:02.599] result() for MulticoreFuture ...
[17:47:02.599] result() for MulticoreFuture ... done
[17:47:02.599] result() for MulticoreFuture ... done
[17:47:02.599] result() for MulticoreFuture ...
[17:47:02.600] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.600] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.600] Searching for globals...
[17:47:02.603] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:02.603] Searching for globals ... DONE
[17:47:02.603] Resolving globals: TRUE
[17:47:02.604] Resolving any globals that are futures ...
[17:47:02.604] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:02.604] Resolving any globals that are futures ... DONE
[17:47:02.604] Resolving futures part of globals (recursively) ...
[17:47:02.605] resolve() on list ...
[17:47:02.605]  recursive: 99
[17:47:02.605]  length: 1
[17:47:02.605]  elements: ‘x’
[17:47:02.605]  length: 0 (resolved future 1)
[17:47:02.605] resolve() on list ... DONE
[17:47:02.605] - globals: [1] ‘x’
[17:47:02.606] Resolving futures part of globals (recursively) ... DONE
[17:47:02.606] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.606] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.606] - globals: [1] ‘x’
[17:47:02.606] 
[17:47:02.607] getGlobalsAndPackages() ... DONE
[17:47:02.607] run() for ‘Future’ ...
[17:47:02.607] - state: ‘created’
[17:47:02.607] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:02.611] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:02.611] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:02.611]   - Field: ‘label’
[17:47:02.611]   - Field: ‘local’
[17:47:02.612]   - Field: ‘owner’
[17:47:02.612]   - Field: ‘envir’
[17:47:02.612]   - Field: ‘workers’
[17:47:02.612]   - Field: ‘packages’
[17:47:02.612]   - Field: ‘gc’
[17:47:02.612]   - Field: ‘job’
[17:47:02.612]   - Field: ‘conditions’
[17:47:02.612]   - Field: ‘expr’
[17:47:02.613]   - Field: ‘uuid’
[17:47:02.613]   - Field: ‘seed’
[17:47:02.613]   - Field: ‘version’
[17:47:02.613]   - Field: ‘result’
[17:47:02.613]   - Field: ‘asynchronous’
[17:47:02.613]   - Field: ‘calls’
[17:47:02.613]   - Field: ‘globals’
[17:47:02.613]   - Field: ‘stdout’
[17:47:02.613]   - Field: ‘earlySignal’
[17:47:02.614]   - Field: ‘lazy’
[17:47:02.614]   - Field: ‘state’
[17:47:02.614] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:02.614] - Launch lazy future ...
[17:47:02.614] Packages needed by the future expression (n = 0): <none>
[17:47:02.614] Packages needed by future strategies (n = 0): <none>
[17:47:02.615] {
[17:47:02.615]     {
[17:47:02.615]         {
[17:47:02.615]             ...future.startTime <- base::Sys.time()
[17:47:02.615]             {
[17:47:02.615]                 {
[17:47:02.615]                   {
[17:47:02.615]                     {
[17:47:02.615]                       base::local({
[17:47:02.615]                         has_future <- base::requireNamespace("future", 
[17:47:02.615]                           quietly = TRUE)
[17:47:02.615]                         if (has_future) {
[17:47:02.615]                           ns <- base::getNamespace("future")
[17:47:02.615]                           version <- ns[[".package"]][["version"]]
[17:47:02.615]                           if (is.null(version)) 
[17:47:02.615]                             version <- utils::packageVersion("future")
[17:47:02.615]                         }
[17:47:02.615]                         else {
[17:47:02.615]                           version <- NULL
[17:47:02.615]                         }
[17:47:02.615]                         if (!has_future || version < "1.8.0") {
[17:47:02.615]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.615]                             "", base::R.version$version.string), 
[17:47:02.615]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:02.615]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.615]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.615]                               "release", "version")], collapse = " "), 
[17:47:02.615]                             hostname = base::Sys.info()[["nodename"]])
[17:47:02.615]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.615]                             info)
[17:47:02.615]                           info <- base::paste(info, collapse = "; ")
[17:47:02.615]                           if (!has_future) {
[17:47:02.615]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.615]                               info)
[17:47:02.615]                           }
[17:47:02.615]                           else {
[17:47:02.615]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.615]                               info, version)
[17:47:02.615]                           }
[17:47:02.615]                           base::stop(msg)
[17:47:02.615]                         }
[17:47:02.615]                       })
[17:47:02.615]                     }
[17:47:02.615]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:02.615]                     base::options(mc.cores = 1L)
[17:47:02.615]                   }
[17:47:02.615]                   ...future.strategy.old <- future::plan("list")
[17:47:02.615]                   options(future.plan = NULL)
[17:47:02.615]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.615]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.615]                 }
[17:47:02.615]                 ...future.workdir <- getwd()
[17:47:02.615]             }
[17:47:02.615]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.615]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.615]         }
[17:47:02.615]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.615]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.615]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.615]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.615]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.615]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.615]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.615]             base::names(...future.oldOptions))
[17:47:02.615]     }
[17:47:02.615]     if (FALSE) {
[17:47:02.615]     }
[17:47:02.615]     else {
[17:47:02.615]         if (TRUE) {
[17:47:02.615]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.615]                 open = "w")
[17:47:02.615]         }
[17:47:02.615]         else {
[17:47:02.615]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.615]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.615]         }
[17:47:02.615]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.615]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.615]             base::sink(type = "output", split = FALSE)
[17:47:02.615]             base::close(...future.stdout)
[17:47:02.615]         }, add = TRUE)
[17:47:02.615]     }
[17:47:02.615]     ...future.frame <- base::sys.nframe()
[17:47:02.615]     ...future.conditions <- base::list()
[17:47:02.615]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.615]     if (FALSE) {
[17:47:02.615]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.615]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.615]     }
[17:47:02.615]     ...future.result <- base::tryCatch({
[17:47:02.615]         base::withCallingHandlers({
[17:47:02.615]             ...future.value <- base::withVisible(base::local({
[17:47:02.615]                 withCallingHandlers({
[17:47:02.615]                   {
[17:47:02.615]                     x[["a"]] <- 1
[17:47:02.615]                     x
[17:47:02.615]                   }
[17:47:02.615]                 }, immediateCondition = function(cond) {
[17:47:02.615]                   save_rds <- function (object, pathname, ...) 
[17:47:02.615]                   {
[17:47:02.615]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:02.615]                     if (file_test("-f", pathname_tmp)) {
[17:47:02.615]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.615]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:02.615]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.615]                         fi_tmp[["mtime"]])
[17:47:02.615]                     }
[17:47:02.615]                     tryCatch({
[17:47:02.615]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:02.615]                     }, error = function(ex) {
[17:47:02.615]                       msg <- conditionMessage(ex)
[17:47:02.615]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.615]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:02.615]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.615]                         fi_tmp[["mtime"]], msg)
[17:47:02.615]                       ex$message <- msg
[17:47:02.615]                       stop(ex)
[17:47:02.615]                     })
[17:47:02.615]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:02.615]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:02.615]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:02.615]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.615]                       fi <- file.info(pathname)
[17:47:02.615]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:02.615]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.615]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:02.615]                         fi[["size"]], fi[["mtime"]])
[17:47:02.615]                       stop(msg)
[17:47:02.615]                     }
[17:47:02.615]                     invisible(pathname)
[17:47:02.615]                   }
[17:47:02.615]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:02.615]                     rootPath = tempdir()) 
[17:47:02.615]                   {
[17:47:02.615]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:02.615]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:02.615]                       tmpdir = path, fileext = ".rds")
[17:47:02.615]                     save_rds(obj, file)
[17:47:02.615]                   }
[17:47:02.615]                   saveImmediateCondition(cond, path = "/tmp/RtmpR4Ygft/.future/immediateConditions")
[17:47:02.615]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.615]                   {
[17:47:02.615]                     inherits <- base::inherits
[17:47:02.615]                     invokeRestart <- base::invokeRestart
[17:47:02.615]                     is.null <- base::is.null
[17:47:02.615]                     muffled <- FALSE
[17:47:02.615]                     if (inherits(cond, "message")) {
[17:47:02.615]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:02.615]                       if (muffled) 
[17:47:02.615]                         invokeRestart("muffleMessage")
[17:47:02.615]                     }
[17:47:02.615]                     else if (inherits(cond, "warning")) {
[17:47:02.615]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:02.615]                       if (muffled) 
[17:47:02.615]                         invokeRestart("muffleWarning")
[17:47:02.615]                     }
[17:47:02.615]                     else if (inherits(cond, "condition")) {
[17:47:02.615]                       if (!is.null(pattern)) {
[17:47:02.615]                         computeRestarts <- base::computeRestarts
[17:47:02.615]                         grepl <- base::grepl
[17:47:02.615]                         restarts <- computeRestarts(cond)
[17:47:02.615]                         for (restart in restarts) {
[17:47:02.615]                           name <- restart$name
[17:47:02.615]                           if (is.null(name)) 
[17:47:02.615]                             next
[17:47:02.615]                           if (!grepl(pattern, name)) 
[17:47:02.615]                             next
[17:47:02.615]                           invokeRestart(restart)
[17:47:02.615]                           muffled <- TRUE
[17:47:02.615]                           break
[17:47:02.615]                         }
[17:47:02.615]                       }
[17:47:02.615]                     }
[17:47:02.615]                     invisible(muffled)
[17:47:02.615]                   }
[17:47:02.615]                   muffleCondition(cond)
[17:47:02.615]                 })
[17:47:02.615]             }))
[17:47:02.615]             future::FutureResult(value = ...future.value$value, 
[17:47:02.615]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.615]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.615]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.615]                     ...future.globalenv.names))
[17:47:02.615]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.615]         }, condition = base::local({
[17:47:02.615]             c <- base::c
[17:47:02.615]             inherits <- base::inherits
[17:47:02.615]             invokeRestart <- base::invokeRestart
[17:47:02.615]             length <- base::length
[17:47:02.615]             list <- base::list
[17:47:02.615]             seq.int <- base::seq.int
[17:47:02.615]             signalCondition <- base::signalCondition
[17:47:02.615]             sys.calls <- base::sys.calls
[17:47:02.615]             `[[` <- base::`[[`
[17:47:02.615]             `+` <- base::`+`
[17:47:02.615]             `<<-` <- base::`<<-`
[17:47:02.615]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.615]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.615]                   3L)]
[17:47:02.615]             }
[17:47:02.615]             function(cond) {
[17:47:02.615]                 is_error <- inherits(cond, "error")
[17:47:02.615]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.615]                   NULL)
[17:47:02.615]                 if (is_error) {
[17:47:02.615]                   sessionInformation <- function() {
[17:47:02.615]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.615]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.615]                       search = base::search(), system = base::Sys.info())
[17:47:02.615]                   }
[17:47:02.615]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.615]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.615]                     cond$call), session = sessionInformation(), 
[17:47:02.615]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.615]                   signalCondition(cond)
[17:47:02.615]                 }
[17:47:02.615]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.615]                 "immediateCondition"))) {
[17:47:02.615]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.615]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.615]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.615]                   if (TRUE && !signal) {
[17:47:02.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.615]                     {
[17:47:02.615]                       inherits <- base::inherits
[17:47:02.615]                       invokeRestart <- base::invokeRestart
[17:47:02.615]                       is.null <- base::is.null
[17:47:02.615]                       muffled <- FALSE
[17:47:02.615]                       if (inherits(cond, "message")) {
[17:47:02.615]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.615]                         if (muffled) 
[17:47:02.615]                           invokeRestart("muffleMessage")
[17:47:02.615]                       }
[17:47:02.615]                       else if (inherits(cond, "warning")) {
[17:47:02.615]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.615]                         if (muffled) 
[17:47:02.615]                           invokeRestart("muffleWarning")
[17:47:02.615]                       }
[17:47:02.615]                       else if (inherits(cond, "condition")) {
[17:47:02.615]                         if (!is.null(pattern)) {
[17:47:02.615]                           computeRestarts <- base::computeRestarts
[17:47:02.615]                           grepl <- base::grepl
[17:47:02.615]                           restarts <- computeRestarts(cond)
[17:47:02.615]                           for (restart in restarts) {
[17:47:02.615]                             name <- restart$name
[17:47:02.615]                             if (is.null(name)) 
[17:47:02.615]                               next
[17:47:02.615]                             if (!grepl(pattern, name)) 
[17:47:02.615]                               next
[17:47:02.615]                             invokeRestart(restart)
[17:47:02.615]                             muffled <- TRUE
[17:47:02.615]                             break
[17:47:02.615]                           }
[17:47:02.615]                         }
[17:47:02.615]                       }
[17:47:02.615]                       invisible(muffled)
[17:47:02.615]                     }
[17:47:02.615]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.615]                   }
[17:47:02.615]                 }
[17:47:02.615]                 else {
[17:47:02.615]                   if (TRUE) {
[17:47:02.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.615]                     {
[17:47:02.615]                       inherits <- base::inherits
[17:47:02.615]                       invokeRestart <- base::invokeRestart
[17:47:02.615]                       is.null <- base::is.null
[17:47:02.615]                       muffled <- FALSE
[17:47:02.615]                       if (inherits(cond, "message")) {
[17:47:02.615]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.615]                         if (muffled) 
[17:47:02.615]                           invokeRestart("muffleMessage")
[17:47:02.615]                       }
[17:47:02.615]                       else if (inherits(cond, "warning")) {
[17:47:02.615]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.615]                         if (muffled) 
[17:47:02.615]                           invokeRestart("muffleWarning")
[17:47:02.615]                       }
[17:47:02.615]                       else if (inherits(cond, "condition")) {
[17:47:02.615]                         if (!is.null(pattern)) {
[17:47:02.615]                           computeRestarts <- base::computeRestarts
[17:47:02.615]                           grepl <- base::grepl
[17:47:02.615]                           restarts <- computeRestarts(cond)
[17:47:02.615]                           for (restart in restarts) {
[17:47:02.615]                             name <- restart$name
[17:47:02.615]                             if (is.null(name)) 
[17:47:02.615]                               next
[17:47:02.615]                             if (!grepl(pattern, name)) 
[17:47:02.615]                               next
[17:47:02.615]                             invokeRestart(restart)
[17:47:02.615]                             muffled <- TRUE
[17:47:02.615]                             break
[17:47:02.615]                           }
[17:47:02.615]                         }
[17:47:02.615]                       }
[17:47:02.615]                       invisible(muffled)
[17:47:02.615]                     }
[17:47:02.615]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.615]                   }
[17:47:02.615]                 }
[17:47:02.615]             }
[17:47:02.615]         }))
[17:47:02.615]     }, error = function(ex) {
[17:47:02.615]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.615]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.615]                 ...future.rng), started = ...future.startTime, 
[17:47:02.615]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.615]             version = "1.8"), class = "FutureResult")
[17:47:02.615]     }, finally = {
[17:47:02.615]         if (!identical(...future.workdir, getwd())) 
[17:47:02.615]             setwd(...future.workdir)
[17:47:02.615]         {
[17:47:02.615]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.615]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.615]             }
[17:47:02.615]             base::options(...future.oldOptions)
[17:47:02.615]             if (.Platform$OS.type == "windows") {
[17:47:02.615]                 old_names <- names(...future.oldEnvVars)
[17:47:02.615]                 envs <- base::Sys.getenv()
[17:47:02.615]                 names <- names(envs)
[17:47:02.615]                 common <- intersect(names, old_names)
[17:47:02.615]                 added <- setdiff(names, old_names)
[17:47:02.615]                 removed <- setdiff(old_names, names)
[17:47:02.615]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.615]                   envs[common]]
[17:47:02.615]                 NAMES <- toupper(changed)
[17:47:02.615]                 args <- list()
[17:47:02.615]                 for (kk in seq_along(NAMES)) {
[17:47:02.615]                   name <- changed[[kk]]
[17:47:02.615]                   NAME <- NAMES[[kk]]
[17:47:02.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.615]                     next
[17:47:02.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.615]                 }
[17:47:02.615]                 NAMES <- toupper(added)
[17:47:02.615]                 for (kk in seq_along(NAMES)) {
[17:47:02.615]                   name <- added[[kk]]
[17:47:02.615]                   NAME <- NAMES[[kk]]
[17:47:02.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.615]                     next
[17:47:02.615]                   args[[name]] <- ""
[17:47:02.615]                 }
[17:47:02.615]                 NAMES <- toupper(removed)
[17:47:02.615]                 for (kk in seq_along(NAMES)) {
[17:47:02.615]                   name <- removed[[kk]]
[17:47:02.615]                   NAME <- NAMES[[kk]]
[17:47:02.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.615]                     next
[17:47:02.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.615]                 }
[17:47:02.615]                 if (length(args) > 0) 
[17:47:02.615]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.615]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.615]             }
[17:47:02.615]             else {
[17:47:02.615]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.615]             }
[17:47:02.615]             {
[17:47:02.615]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.615]                   0L) {
[17:47:02.615]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.615]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.615]                   base::options(opts)
[17:47:02.615]                 }
[17:47:02.615]                 {
[17:47:02.615]                   {
[17:47:02.615]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:02.615]                     NULL
[17:47:02.615]                   }
[17:47:02.615]                   options(future.plan = NULL)
[17:47:02.615]                   if (is.na(NA_character_)) 
[17:47:02.615]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.615]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.615]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.615]                     .init = FALSE)
[17:47:02.615]                 }
[17:47:02.615]             }
[17:47:02.615]         }
[17:47:02.615]     })
[17:47:02.615]     if (TRUE) {
[17:47:02.615]         base::sink(type = "output", split = FALSE)
[17:47:02.615]         if (TRUE) {
[17:47:02.615]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.615]         }
[17:47:02.615]         else {
[17:47:02.615]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.615]         }
[17:47:02.615]         base::close(...future.stdout)
[17:47:02.615]         ...future.stdout <- NULL
[17:47:02.615]     }
[17:47:02.615]     ...future.result$conditions <- ...future.conditions
[17:47:02.615]     ...future.result$finished <- base::Sys.time()
[17:47:02.615]     ...future.result
[17:47:02.615] }
[17:47:02.617] assign_globals() ...
[17:47:02.617] List of 1
[17:47:02.617]  $ x: list()
[17:47:02.617]  - attr(*, "where")=List of 1
[17:47:02.617]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.617]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.617]  - attr(*, "resolved")= logi TRUE
[17:47:02.617]  - attr(*, "total_size")= num 0
[17:47:02.617]  - attr(*, "already-done")= logi TRUE
[17:47:02.620] - copied ‘x’ to environment
[17:47:02.620] assign_globals() ... done
[17:47:02.620] requestCore(): workers = 2
[17:47:02.622] MulticoreFuture started
[17:47:02.623] - Launch lazy future ... done
[17:47:02.623] run() for ‘MulticoreFuture’ ... done
[17:47:02.623] result() for MulticoreFuture ...
[17:47:02.623] plan(): Setting new future strategy stack:
[17:47:02.624] List of future strategies:
[17:47:02.624] 1. sequential:
[17:47:02.624]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.624]    - tweaked: FALSE
[17:47:02.624]    - call: NULL
[17:47:02.625] plan(): nbrOfWorkers() = 1
[17:47:02.627] plan(): Setting new future strategy stack:
[17:47:02.627] List of future strategies:
[17:47:02.627] 1. multicore:
[17:47:02.627]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:02.627]    - tweaked: FALSE
[17:47:02.627]    - call: plan(strategy)
[17:47:02.631] plan(): nbrOfWorkers() = 2
[17:47:02.632] result() for MulticoreFuture ...
[17:47:02.632] result() for MulticoreFuture ... done
[17:47:02.633] result() for MulticoreFuture ... done
[17:47:02.633] result() for MulticoreFuture ...
[17:47:02.633] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.634] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.634] Searching for globals...
[17:47:02.636] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:02.637] Searching for globals ... DONE
[17:47:02.637] Resolving globals: TRUE
[17:47:02.637] Resolving any globals that are futures ...
[17:47:02.637] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:02.637] Resolving any globals that are futures ... DONE
[17:47:02.638] Resolving futures part of globals (recursively) ...
[17:47:02.638] resolve() on list ...
[17:47:02.638]  recursive: 99
[17:47:02.638]  length: 1
[17:47:02.638]  elements: ‘x’
[17:47:02.638]  length: 0 (resolved future 1)
[17:47:02.638] resolve() on list ... DONE
[17:47:02.639] - globals: [1] ‘x’
[17:47:02.639] Resolving futures part of globals (recursively) ... DONE
[17:47:02.639] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.639] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.640] - globals: [1] ‘x’
[17:47:02.640] 
[17:47:02.640] getGlobalsAndPackages() ... DONE
[17:47:02.640] run() for ‘Future’ ...
[17:47:02.640] - state: ‘created’
[17:47:02.640] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:02.644] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:02.645] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:02.645]   - Field: ‘label’
[17:47:02.645]   - Field: ‘local’
[17:47:02.645]   - Field: ‘owner’
[17:47:02.645]   - Field: ‘envir’
[17:47:02.645]   - Field: ‘workers’
[17:47:02.645]   - Field: ‘packages’
[17:47:02.645]   - Field: ‘gc’
[17:47:02.646]   - Field: ‘job’
[17:47:02.646]   - Field: ‘conditions’
[17:47:02.646]   - Field: ‘expr’
[17:47:02.646]   - Field: ‘uuid’
[17:47:02.648]   - Field: ‘seed’
[17:47:02.648]   - Field: ‘version’
[17:47:02.649]   - Field: ‘result’
[17:47:02.649]   - Field: ‘asynchronous’
[17:47:02.649]   - Field: ‘calls’
[17:47:02.649]   - Field: ‘globals’
[17:47:02.649]   - Field: ‘stdout’
[17:47:02.649]   - Field: ‘earlySignal’
[17:47:02.649]   - Field: ‘lazy’
[17:47:02.649]   - Field: ‘state’
[17:47:02.650] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:02.650] - Launch lazy future ...
[17:47:02.650] Packages needed by the future expression (n = 0): <none>
[17:47:02.650] Packages needed by future strategies (n = 0): <none>
[17:47:02.651] {
[17:47:02.651]     {
[17:47:02.651]         {
[17:47:02.651]             ...future.startTime <- base::Sys.time()
[17:47:02.651]             {
[17:47:02.651]                 {
[17:47:02.651]                   {
[17:47:02.651]                     {
[17:47:02.651]                       base::local({
[17:47:02.651]                         has_future <- base::requireNamespace("future", 
[17:47:02.651]                           quietly = TRUE)
[17:47:02.651]                         if (has_future) {
[17:47:02.651]                           ns <- base::getNamespace("future")
[17:47:02.651]                           version <- ns[[".package"]][["version"]]
[17:47:02.651]                           if (is.null(version)) 
[17:47:02.651]                             version <- utils::packageVersion("future")
[17:47:02.651]                         }
[17:47:02.651]                         else {
[17:47:02.651]                           version <- NULL
[17:47:02.651]                         }
[17:47:02.651]                         if (!has_future || version < "1.8.0") {
[17:47:02.651]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.651]                             "", base::R.version$version.string), 
[17:47:02.651]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:02.651]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.651]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.651]                               "release", "version")], collapse = " "), 
[17:47:02.651]                             hostname = base::Sys.info()[["nodename"]])
[17:47:02.651]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.651]                             info)
[17:47:02.651]                           info <- base::paste(info, collapse = "; ")
[17:47:02.651]                           if (!has_future) {
[17:47:02.651]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.651]                               info)
[17:47:02.651]                           }
[17:47:02.651]                           else {
[17:47:02.651]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.651]                               info, version)
[17:47:02.651]                           }
[17:47:02.651]                           base::stop(msg)
[17:47:02.651]                         }
[17:47:02.651]                       })
[17:47:02.651]                     }
[17:47:02.651]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:02.651]                     base::options(mc.cores = 1L)
[17:47:02.651]                   }
[17:47:02.651]                   ...future.strategy.old <- future::plan("list")
[17:47:02.651]                   options(future.plan = NULL)
[17:47:02.651]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.651]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.651]                 }
[17:47:02.651]                 ...future.workdir <- getwd()
[17:47:02.651]             }
[17:47:02.651]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.651]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.651]         }
[17:47:02.651]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.651]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.651]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.651]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.651]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.651]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.651]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.651]             base::names(...future.oldOptions))
[17:47:02.651]     }
[17:47:02.651]     if (FALSE) {
[17:47:02.651]     }
[17:47:02.651]     else {
[17:47:02.651]         if (TRUE) {
[17:47:02.651]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.651]                 open = "w")
[17:47:02.651]         }
[17:47:02.651]         else {
[17:47:02.651]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.651]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.651]         }
[17:47:02.651]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.651]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.651]             base::sink(type = "output", split = FALSE)
[17:47:02.651]             base::close(...future.stdout)
[17:47:02.651]         }, add = TRUE)
[17:47:02.651]     }
[17:47:02.651]     ...future.frame <- base::sys.nframe()
[17:47:02.651]     ...future.conditions <- base::list()
[17:47:02.651]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.651]     if (FALSE) {
[17:47:02.651]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.651]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.651]     }
[17:47:02.651]     ...future.result <- base::tryCatch({
[17:47:02.651]         base::withCallingHandlers({
[17:47:02.651]             ...future.value <- base::withVisible(base::local({
[17:47:02.651]                 withCallingHandlers({
[17:47:02.651]                   {
[17:47:02.651]                     x[["a"]] <- 1
[17:47:02.651]                     x
[17:47:02.651]                   }
[17:47:02.651]                 }, immediateCondition = function(cond) {
[17:47:02.651]                   save_rds <- function (object, pathname, ...) 
[17:47:02.651]                   {
[17:47:02.651]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:02.651]                     if (file_test("-f", pathname_tmp)) {
[17:47:02.651]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.651]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:02.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.651]                         fi_tmp[["mtime"]])
[17:47:02.651]                     }
[17:47:02.651]                     tryCatch({
[17:47:02.651]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:02.651]                     }, error = function(ex) {
[17:47:02.651]                       msg <- conditionMessage(ex)
[17:47:02.651]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.651]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:02.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.651]                         fi_tmp[["mtime"]], msg)
[17:47:02.651]                       ex$message <- msg
[17:47:02.651]                       stop(ex)
[17:47:02.651]                     })
[17:47:02.651]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:02.651]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:02.651]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:02.651]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.651]                       fi <- file.info(pathname)
[17:47:02.651]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:02.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.651]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:02.651]                         fi[["size"]], fi[["mtime"]])
[17:47:02.651]                       stop(msg)
[17:47:02.651]                     }
[17:47:02.651]                     invisible(pathname)
[17:47:02.651]                   }
[17:47:02.651]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:02.651]                     rootPath = tempdir()) 
[17:47:02.651]                   {
[17:47:02.651]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:02.651]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:02.651]                       tmpdir = path, fileext = ".rds")
[17:47:02.651]                     save_rds(obj, file)
[17:47:02.651]                   }
[17:47:02.651]                   saveImmediateCondition(cond, path = "/tmp/RtmpR4Ygft/.future/immediateConditions")
[17:47:02.651]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.651]                   {
[17:47:02.651]                     inherits <- base::inherits
[17:47:02.651]                     invokeRestart <- base::invokeRestart
[17:47:02.651]                     is.null <- base::is.null
[17:47:02.651]                     muffled <- FALSE
[17:47:02.651]                     if (inherits(cond, "message")) {
[17:47:02.651]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:02.651]                       if (muffled) 
[17:47:02.651]                         invokeRestart("muffleMessage")
[17:47:02.651]                     }
[17:47:02.651]                     else if (inherits(cond, "warning")) {
[17:47:02.651]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:02.651]                       if (muffled) 
[17:47:02.651]                         invokeRestart("muffleWarning")
[17:47:02.651]                     }
[17:47:02.651]                     else if (inherits(cond, "condition")) {
[17:47:02.651]                       if (!is.null(pattern)) {
[17:47:02.651]                         computeRestarts <- base::computeRestarts
[17:47:02.651]                         grepl <- base::grepl
[17:47:02.651]                         restarts <- computeRestarts(cond)
[17:47:02.651]                         for (restart in restarts) {
[17:47:02.651]                           name <- restart$name
[17:47:02.651]                           if (is.null(name)) 
[17:47:02.651]                             next
[17:47:02.651]                           if (!grepl(pattern, name)) 
[17:47:02.651]                             next
[17:47:02.651]                           invokeRestart(restart)
[17:47:02.651]                           muffled <- TRUE
[17:47:02.651]                           break
[17:47:02.651]                         }
[17:47:02.651]                       }
[17:47:02.651]                     }
[17:47:02.651]                     invisible(muffled)
[17:47:02.651]                   }
[17:47:02.651]                   muffleCondition(cond)
[17:47:02.651]                 })
[17:47:02.651]             }))
[17:47:02.651]             future::FutureResult(value = ...future.value$value, 
[17:47:02.651]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.651]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.651]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.651]                     ...future.globalenv.names))
[17:47:02.651]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.651]         }, condition = base::local({
[17:47:02.651]             c <- base::c
[17:47:02.651]             inherits <- base::inherits
[17:47:02.651]             invokeRestart <- base::invokeRestart
[17:47:02.651]             length <- base::length
[17:47:02.651]             list <- base::list
[17:47:02.651]             seq.int <- base::seq.int
[17:47:02.651]             signalCondition <- base::signalCondition
[17:47:02.651]             sys.calls <- base::sys.calls
[17:47:02.651]             `[[` <- base::`[[`
[17:47:02.651]             `+` <- base::`+`
[17:47:02.651]             `<<-` <- base::`<<-`
[17:47:02.651]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.651]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.651]                   3L)]
[17:47:02.651]             }
[17:47:02.651]             function(cond) {
[17:47:02.651]                 is_error <- inherits(cond, "error")
[17:47:02.651]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.651]                   NULL)
[17:47:02.651]                 if (is_error) {
[17:47:02.651]                   sessionInformation <- function() {
[17:47:02.651]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.651]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.651]                       search = base::search(), system = base::Sys.info())
[17:47:02.651]                   }
[17:47:02.651]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.651]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.651]                     cond$call), session = sessionInformation(), 
[17:47:02.651]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.651]                   signalCondition(cond)
[17:47:02.651]                 }
[17:47:02.651]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.651]                 "immediateCondition"))) {
[17:47:02.651]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.651]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.651]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.651]                   if (TRUE && !signal) {
[17:47:02.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.651]                     {
[17:47:02.651]                       inherits <- base::inherits
[17:47:02.651]                       invokeRestart <- base::invokeRestart
[17:47:02.651]                       is.null <- base::is.null
[17:47:02.651]                       muffled <- FALSE
[17:47:02.651]                       if (inherits(cond, "message")) {
[17:47:02.651]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.651]                         if (muffled) 
[17:47:02.651]                           invokeRestart("muffleMessage")
[17:47:02.651]                       }
[17:47:02.651]                       else if (inherits(cond, "warning")) {
[17:47:02.651]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.651]                         if (muffled) 
[17:47:02.651]                           invokeRestart("muffleWarning")
[17:47:02.651]                       }
[17:47:02.651]                       else if (inherits(cond, "condition")) {
[17:47:02.651]                         if (!is.null(pattern)) {
[17:47:02.651]                           computeRestarts <- base::computeRestarts
[17:47:02.651]                           grepl <- base::grepl
[17:47:02.651]                           restarts <- computeRestarts(cond)
[17:47:02.651]                           for (restart in restarts) {
[17:47:02.651]                             name <- restart$name
[17:47:02.651]                             if (is.null(name)) 
[17:47:02.651]                               next
[17:47:02.651]                             if (!grepl(pattern, name)) 
[17:47:02.651]                               next
[17:47:02.651]                             invokeRestart(restart)
[17:47:02.651]                             muffled <- TRUE
[17:47:02.651]                             break
[17:47:02.651]                           }
[17:47:02.651]                         }
[17:47:02.651]                       }
[17:47:02.651]                       invisible(muffled)
[17:47:02.651]                     }
[17:47:02.651]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.651]                   }
[17:47:02.651]                 }
[17:47:02.651]                 else {
[17:47:02.651]                   if (TRUE) {
[17:47:02.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.651]                     {
[17:47:02.651]                       inherits <- base::inherits
[17:47:02.651]                       invokeRestart <- base::invokeRestart
[17:47:02.651]                       is.null <- base::is.null
[17:47:02.651]                       muffled <- FALSE
[17:47:02.651]                       if (inherits(cond, "message")) {
[17:47:02.651]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.651]                         if (muffled) 
[17:47:02.651]                           invokeRestart("muffleMessage")
[17:47:02.651]                       }
[17:47:02.651]                       else if (inherits(cond, "warning")) {
[17:47:02.651]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.651]                         if (muffled) 
[17:47:02.651]                           invokeRestart("muffleWarning")
[17:47:02.651]                       }
[17:47:02.651]                       else if (inherits(cond, "condition")) {
[17:47:02.651]                         if (!is.null(pattern)) {
[17:47:02.651]                           computeRestarts <- base::computeRestarts
[17:47:02.651]                           grepl <- base::grepl
[17:47:02.651]                           restarts <- computeRestarts(cond)
[17:47:02.651]                           for (restart in restarts) {
[17:47:02.651]                             name <- restart$name
[17:47:02.651]                             if (is.null(name)) 
[17:47:02.651]                               next
[17:47:02.651]                             if (!grepl(pattern, name)) 
[17:47:02.651]                               next
[17:47:02.651]                             invokeRestart(restart)
[17:47:02.651]                             muffled <- TRUE
[17:47:02.651]                             break
[17:47:02.651]                           }
[17:47:02.651]                         }
[17:47:02.651]                       }
[17:47:02.651]                       invisible(muffled)
[17:47:02.651]                     }
[17:47:02.651]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.651]                   }
[17:47:02.651]                 }
[17:47:02.651]             }
[17:47:02.651]         }))
[17:47:02.651]     }, error = function(ex) {
[17:47:02.651]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.651]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.651]                 ...future.rng), started = ...future.startTime, 
[17:47:02.651]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.651]             version = "1.8"), class = "FutureResult")
[17:47:02.651]     }, finally = {
[17:47:02.651]         if (!identical(...future.workdir, getwd())) 
[17:47:02.651]             setwd(...future.workdir)
[17:47:02.651]         {
[17:47:02.651]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.651]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.651]             }
[17:47:02.651]             base::options(...future.oldOptions)
[17:47:02.651]             if (.Platform$OS.type == "windows") {
[17:47:02.651]                 old_names <- names(...future.oldEnvVars)
[17:47:02.651]                 envs <- base::Sys.getenv()
[17:47:02.651]                 names <- names(envs)
[17:47:02.651]                 common <- intersect(names, old_names)
[17:47:02.651]                 added <- setdiff(names, old_names)
[17:47:02.651]                 removed <- setdiff(old_names, names)
[17:47:02.651]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.651]                   envs[common]]
[17:47:02.651]                 NAMES <- toupper(changed)
[17:47:02.651]                 args <- list()
[17:47:02.651]                 for (kk in seq_along(NAMES)) {
[17:47:02.651]                   name <- changed[[kk]]
[17:47:02.651]                   NAME <- NAMES[[kk]]
[17:47:02.651]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.651]                     next
[17:47:02.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.651]                 }
[17:47:02.651]                 NAMES <- toupper(added)
[17:47:02.651]                 for (kk in seq_along(NAMES)) {
[17:47:02.651]                   name <- added[[kk]]
[17:47:02.651]                   NAME <- NAMES[[kk]]
[17:47:02.651]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.651]                     next
[17:47:02.651]                   args[[name]] <- ""
[17:47:02.651]                 }
[17:47:02.651]                 NAMES <- toupper(removed)
[17:47:02.651]                 for (kk in seq_along(NAMES)) {
[17:47:02.651]                   name <- removed[[kk]]
[17:47:02.651]                   NAME <- NAMES[[kk]]
[17:47:02.651]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.651]                     next
[17:47:02.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.651]                 }
[17:47:02.651]                 if (length(args) > 0) 
[17:47:02.651]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.651]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.651]             }
[17:47:02.651]             else {
[17:47:02.651]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.651]             }
[17:47:02.651]             {
[17:47:02.651]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.651]                   0L) {
[17:47:02.651]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.651]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.651]                   base::options(opts)
[17:47:02.651]                 }
[17:47:02.651]                 {
[17:47:02.651]                   {
[17:47:02.651]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:02.651]                     NULL
[17:47:02.651]                   }
[17:47:02.651]                   options(future.plan = NULL)
[17:47:02.651]                   if (is.na(NA_character_)) 
[17:47:02.651]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.651]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.651]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.651]                     .init = FALSE)
[17:47:02.651]                 }
[17:47:02.651]             }
[17:47:02.651]         }
[17:47:02.651]     })
[17:47:02.651]     if (TRUE) {
[17:47:02.651]         base::sink(type = "output", split = FALSE)
[17:47:02.651]         if (TRUE) {
[17:47:02.651]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.651]         }
[17:47:02.651]         else {
[17:47:02.651]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.651]         }
[17:47:02.651]         base::close(...future.stdout)
[17:47:02.651]         ...future.stdout <- NULL
[17:47:02.651]     }
[17:47:02.651]     ...future.result$conditions <- ...future.conditions
[17:47:02.651]     ...future.result$finished <- base::Sys.time()
[17:47:02.651]     ...future.result
[17:47:02.651] }
[17:47:02.653] assign_globals() ...
[17:47:02.653] List of 1
[17:47:02.653]  $ x: list()
[17:47:02.653]  - attr(*, "where")=List of 1
[17:47:02.653]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.653]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.653]  - attr(*, "resolved")= logi TRUE
[17:47:02.653]  - attr(*, "total_size")= num 0
[17:47:02.653]  - attr(*, "already-done")= logi TRUE
[17:47:02.656] - copied ‘x’ to environment
[17:47:02.656] assign_globals() ... done
[17:47:02.656] requestCore(): workers = 2
[17:47:02.658] MulticoreFuture started
[17:47:02.659] - Launch lazy future ... done
[17:47:02.659] run() for ‘MulticoreFuture’ ... done
[17:47:02.659] plan(): Setting new future strategy stack:
[17:47:02.659] result() for MulticoreFuture ...
[17:47:02.660] List of future strategies:
[17:47:02.660] 1. sequential:
[17:47:02.660]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.660]    - tweaked: FALSE
[17:47:02.660]    - call: NULL
[17:47:02.661] plan(): nbrOfWorkers() = 1
[17:47:02.663] plan(): Setting new future strategy stack:
[17:47:02.663] List of future strategies:
[17:47:02.663] 1. multicore:
[17:47:02.663]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:02.663]    - tweaked: FALSE
[17:47:02.663]    - call: plan(strategy)
[17:47:02.668] plan(): nbrOfWorkers() = 2
[17:47:02.668] result() for MulticoreFuture ...
[17:47:02.669] result() for MulticoreFuture ... done
[17:47:02.669] result() for MulticoreFuture ... done
[17:47:02.669] result() for MulticoreFuture ...
[17:47:02.669] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.669] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.670] Searching for globals...
[17:47:02.673] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:02.673] Searching for globals ... DONE
[17:47:02.673] Resolving globals: TRUE
[17:47:02.673] Resolving any globals that are futures ...
[17:47:02.673] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:02.673] Resolving any globals that are futures ... DONE
[17:47:02.674] Resolving futures part of globals (recursively) ...
[17:47:02.674] resolve() on list ...
[17:47:02.674]  recursive: 99
[17:47:02.674]  length: 1
[17:47:02.674]  elements: ‘x’
[17:47:02.675]  length: 0 (resolved future 1)
[17:47:02.675] resolve() on list ... DONE
[17:47:02.675] - globals: [1] ‘x’
[17:47:02.675] Resolving futures part of globals (recursively) ... DONE
[17:47:02.675] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.676] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.676] - globals: [1] ‘x’
[17:47:02.676] 
[17:47:02.676] getGlobalsAndPackages() ... DONE
[17:47:02.676] run() for ‘Future’ ...
[17:47:02.677] - state: ‘created’
[17:47:02.677] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:02.681] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:02.681] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:02.681]   - Field: ‘label’
[17:47:02.681]   - Field: ‘local’
[17:47:02.681]   - Field: ‘owner’
[17:47:02.681]   - Field: ‘envir’
[17:47:02.681]   - Field: ‘workers’
[17:47:02.681]   - Field: ‘packages’
[17:47:02.682]   - Field: ‘gc’
[17:47:02.682]   - Field: ‘job’
[17:47:02.682]   - Field: ‘conditions’
[17:47:02.682]   - Field: ‘expr’
[17:47:02.682]   - Field: ‘uuid’
[17:47:02.682]   - Field: ‘seed’
[17:47:02.682]   - Field: ‘version’
[17:47:02.682]   - Field: ‘result’
[17:47:02.682]   - Field: ‘asynchronous’
[17:47:02.683]   - Field: ‘calls’
[17:47:02.683]   - Field: ‘globals’
[17:47:02.683]   - Field: ‘stdout’
[17:47:02.683]   - Field: ‘earlySignal’
[17:47:02.683]   - Field: ‘lazy’
[17:47:02.683]   - Field: ‘state’
[17:47:02.683] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:02.683] - Launch lazy future ...
[17:47:02.684] Packages needed by the future expression (n = 0): <none>
[17:47:02.684] Packages needed by future strategies (n = 0): <none>
[17:47:02.684] {
[17:47:02.684]     {
[17:47:02.684]         {
[17:47:02.684]             ...future.startTime <- base::Sys.time()
[17:47:02.684]             {
[17:47:02.684]                 {
[17:47:02.684]                   {
[17:47:02.684]                     {
[17:47:02.684]                       base::local({
[17:47:02.684]                         has_future <- base::requireNamespace("future", 
[17:47:02.684]                           quietly = TRUE)
[17:47:02.684]                         if (has_future) {
[17:47:02.684]                           ns <- base::getNamespace("future")
[17:47:02.684]                           version <- ns[[".package"]][["version"]]
[17:47:02.684]                           if (is.null(version)) 
[17:47:02.684]                             version <- utils::packageVersion("future")
[17:47:02.684]                         }
[17:47:02.684]                         else {
[17:47:02.684]                           version <- NULL
[17:47:02.684]                         }
[17:47:02.684]                         if (!has_future || version < "1.8.0") {
[17:47:02.684]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.684]                             "", base::R.version$version.string), 
[17:47:02.684]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:02.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.684]                               "release", "version")], collapse = " "), 
[17:47:02.684]                             hostname = base::Sys.info()[["nodename"]])
[17:47:02.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.684]                             info)
[17:47:02.684]                           info <- base::paste(info, collapse = "; ")
[17:47:02.684]                           if (!has_future) {
[17:47:02.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.684]                               info)
[17:47:02.684]                           }
[17:47:02.684]                           else {
[17:47:02.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.684]                               info, version)
[17:47:02.684]                           }
[17:47:02.684]                           base::stop(msg)
[17:47:02.684]                         }
[17:47:02.684]                       })
[17:47:02.684]                     }
[17:47:02.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:02.684]                     base::options(mc.cores = 1L)
[17:47:02.684]                   }
[17:47:02.684]                   ...future.strategy.old <- future::plan("list")
[17:47:02.684]                   options(future.plan = NULL)
[17:47:02.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.684]                 }
[17:47:02.684]                 ...future.workdir <- getwd()
[17:47:02.684]             }
[17:47:02.684]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.684]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.684]         }
[17:47:02.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.684]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.684]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.684]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.684]             base::names(...future.oldOptions))
[17:47:02.684]     }
[17:47:02.684]     if (FALSE) {
[17:47:02.684]     }
[17:47:02.684]     else {
[17:47:02.684]         if (TRUE) {
[17:47:02.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.684]                 open = "w")
[17:47:02.684]         }
[17:47:02.684]         else {
[17:47:02.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.684]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.684]         }
[17:47:02.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.684]             base::sink(type = "output", split = FALSE)
[17:47:02.684]             base::close(...future.stdout)
[17:47:02.684]         }, add = TRUE)
[17:47:02.684]     }
[17:47:02.684]     ...future.frame <- base::sys.nframe()
[17:47:02.684]     ...future.conditions <- base::list()
[17:47:02.684]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.684]     if (FALSE) {
[17:47:02.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.684]     }
[17:47:02.684]     ...future.result <- base::tryCatch({
[17:47:02.684]         base::withCallingHandlers({
[17:47:02.684]             ...future.value <- base::withVisible(base::local({
[17:47:02.684]                 withCallingHandlers({
[17:47:02.684]                   {
[17:47:02.684]                     x["a"] <- list(1)
[17:47:02.684]                     x
[17:47:02.684]                   }
[17:47:02.684]                 }, immediateCondition = function(cond) {
[17:47:02.684]                   save_rds <- function (object, pathname, ...) 
[17:47:02.684]                   {
[17:47:02.684]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:02.684]                     if (file_test("-f", pathname_tmp)) {
[17:47:02.684]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.684]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:02.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.684]                         fi_tmp[["mtime"]])
[17:47:02.684]                     }
[17:47:02.684]                     tryCatch({
[17:47:02.684]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:02.684]                     }, error = function(ex) {
[17:47:02.684]                       msg <- conditionMessage(ex)
[17:47:02.684]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.684]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:02.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.684]                         fi_tmp[["mtime"]], msg)
[17:47:02.684]                       ex$message <- msg
[17:47:02.684]                       stop(ex)
[17:47:02.684]                     })
[17:47:02.684]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:02.684]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:02.684]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:02.684]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.684]                       fi <- file.info(pathname)
[17:47:02.684]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:02.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.684]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:02.684]                         fi[["size"]], fi[["mtime"]])
[17:47:02.684]                       stop(msg)
[17:47:02.684]                     }
[17:47:02.684]                     invisible(pathname)
[17:47:02.684]                   }
[17:47:02.684]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:02.684]                     rootPath = tempdir()) 
[17:47:02.684]                   {
[17:47:02.684]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:02.684]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:02.684]                       tmpdir = path, fileext = ".rds")
[17:47:02.684]                     save_rds(obj, file)
[17:47:02.684]                   }
[17:47:02.684]                   saveImmediateCondition(cond, path = "/tmp/RtmpR4Ygft/.future/immediateConditions")
[17:47:02.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.684]                   {
[17:47:02.684]                     inherits <- base::inherits
[17:47:02.684]                     invokeRestart <- base::invokeRestart
[17:47:02.684]                     is.null <- base::is.null
[17:47:02.684]                     muffled <- FALSE
[17:47:02.684]                     if (inherits(cond, "message")) {
[17:47:02.684]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:02.684]                       if (muffled) 
[17:47:02.684]                         invokeRestart("muffleMessage")
[17:47:02.684]                     }
[17:47:02.684]                     else if (inherits(cond, "warning")) {
[17:47:02.684]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:02.684]                       if (muffled) 
[17:47:02.684]                         invokeRestart("muffleWarning")
[17:47:02.684]                     }
[17:47:02.684]                     else if (inherits(cond, "condition")) {
[17:47:02.684]                       if (!is.null(pattern)) {
[17:47:02.684]                         computeRestarts <- base::computeRestarts
[17:47:02.684]                         grepl <- base::grepl
[17:47:02.684]                         restarts <- computeRestarts(cond)
[17:47:02.684]                         for (restart in restarts) {
[17:47:02.684]                           name <- restart$name
[17:47:02.684]                           if (is.null(name)) 
[17:47:02.684]                             next
[17:47:02.684]                           if (!grepl(pattern, name)) 
[17:47:02.684]                             next
[17:47:02.684]                           invokeRestart(restart)
[17:47:02.684]                           muffled <- TRUE
[17:47:02.684]                           break
[17:47:02.684]                         }
[17:47:02.684]                       }
[17:47:02.684]                     }
[17:47:02.684]                     invisible(muffled)
[17:47:02.684]                   }
[17:47:02.684]                   muffleCondition(cond)
[17:47:02.684]                 })
[17:47:02.684]             }))
[17:47:02.684]             future::FutureResult(value = ...future.value$value, 
[17:47:02.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.684]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.684]                     ...future.globalenv.names))
[17:47:02.684]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.684]         }, condition = base::local({
[17:47:02.684]             c <- base::c
[17:47:02.684]             inherits <- base::inherits
[17:47:02.684]             invokeRestart <- base::invokeRestart
[17:47:02.684]             length <- base::length
[17:47:02.684]             list <- base::list
[17:47:02.684]             seq.int <- base::seq.int
[17:47:02.684]             signalCondition <- base::signalCondition
[17:47:02.684]             sys.calls <- base::sys.calls
[17:47:02.684]             `[[` <- base::`[[`
[17:47:02.684]             `+` <- base::`+`
[17:47:02.684]             `<<-` <- base::`<<-`
[17:47:02.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.684]                   3L)]
[17:47:02.684]             }
[17:47:02.684]             function(cond) {
[17:47:02.684]                 is_error <- inherits(cond, "error")
[17:47:02.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.684]                   NULL)
[17:47:02.684]                 if (is_error) {
[17:47:02.684]                   sessionInformation <- function() {
[17:47:02.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.684]                       search = base::search(), system = base::Sys.info())
[17:47:02.684]                   }
[17:47:02.684]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.684]                     cond$call), session = sessionInformation(), 
[17:47:02.684]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.684]                   signalCondition(cond)
[17:47:02.684]                 }
[17:47:02.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.684]                 "immediateCondition"))) {
[17:47:02.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.684]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.684]                   if (TRUE && !signal) {
[17:47:02.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.684]                     {
[17:47:02.684]                       inherits <- base::inherits
[17:47:02.684]                       invokeRestart <- base::invokeRestart
[17:47:02.684]                       is.null <- base::is.null
[17:47:02.684]                       muffled <- FALSE
[17:47:02.684]                       if (inherits(cond, "message")) {
[17:47:02.684]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.684]                         if (muffled) 
[17:47:02.684]                           invokeRestart("muffleMessage")
[17:47:02.684]                       }
[17:47:02.684]                       else if (inherits(cond, "warning")) {
[17:47:02.684]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.684]                         if (muffled) 
[17:47:02.684]                           invokeRestart("muffleWarning")
[17:47:02.684]                       }
[17:47:02.684]                       else if (inherits(cond, "condition")) {
[17:47:02.684]                         if (!is.null(pattern)) {
[17:47:02.684]                           computeRestarts <- base::computeRestarts
[17:47:02.684]                           grepl <- base::grepl
[17:47:02.684]                           restarts <- computeRestarts(cond)
[17:47:02.684]                           for (restart in restarts) {
[17:47:02.684]                             name <- restart$name
[17:47:02.684]                             if (is.null(name)) 
[17:47:02.684]                               next
[17:47:02.684]                             if (!grepl(pattern, name)) 
[17:47:02.684]                               next
[17:47:02.684]                             invokeRestart(restart)
[17:47:02.684]                             muffled <- TRUE
[17:47:02.684]                             break
[17:47:02.684]                           }
[17:47:02.684]                         }
[17:47:02.684]                       }
[17:47:02.684]                       invisible(muffled)
[17:47:02.684]                     }
[17:47:02.684]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.684]                   }
[17:47:02.684]                 }
[17:47:02.684]                 else {
[17:47:02.684]                   if (TRUE) {
[17:47:02.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.684]                     {
[17:47:02.684]                       inherits <- base::inherits
[17:47:02.684]                       invokeRestart <- base::invokeRestart
[17:47:02.684]                       is.null <- base::is.null
[17:47:02.684]                       muffled <- FALSE
[17:47:02.684]                       if (inherits(cond, "message")) {
[17:47:02.684]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.684]                         if (muffled) 
[17:47:02.684]                           invokeRestart("muffleMessage")
[17:47:02.684]                       }
[17:47:02.684]                       else if (inherits(cond, "warning")) {
[17:47:02.684]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.684]                         if (muffled) 
[17:47:02.684]                           invokeRestart("muffleWarning")
[17:47:02.684]                       }
[17:47:02.684]                       else if (inherits(cond, "condition")) {
[17:47:02.684]                         if (!is.null(pattern)) {
[17:47:02.684]                           computeRestarts <- base::computeRestarts
[17:47:02.684]                           grepl <- base::grepl
[17:47:02.684]                           restarts <- computeRestarts(cond)
[17:47:02.684]                           for (restart in restarts) {
[17:47:02.684]                             name <- restart$name
[17:47:02.684]                             if (is.null(name)) 
[17:47:02.684]                               next
[17:47:02.684]                             if (!grepl(pattern, name)) 
[17:47:02.684]                               next
[17:47:02.684]                             invokeRestart(restart)
[17:47:02.684]                             muffled <- TRUE
[17:47:02.684]                             break
[17:47:02.684]                           }
[17:47:02.684]                         }
[17:47:02.684]                       }
[17:47:02.684]                       invisible(muffled)
[17:47:02.684]                     }
[17:47:02.684]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.684]                   }
[17:47:02.684]                 }
[17:47:02.684]             }
[17:47:02.684]         }))
[17:47:02.684]     }, error = function(ex) {
[17:47:02.684]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.684]                 ...future.rng), started = ...future.startTime, 
[17:47:02.684]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.684]             version = "1.8"), class = "FutureResult")
[17:47:02.684]     }, finally = {
[17:47:02.684]         if (!identical(...future.workdir, getwd())) 
[17:47:02.684]             setwd(...future.workdir)
[17:47:02.684]         {
[17:47:02.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.684]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.684]             }
[17:47:02.684]             base::options(...future.oldOptions)
[17:47:02.684]             if (.Platform$OS.type == "windows") {
[17:47:02.684]                 old_names <- names(...future.oldEnvVars)
[17:47:02.684]                 envs <- base::Sys.getenv()
[17:47:02.684]                 names <- names(envs)
[17:47:02.684]                 common <- intersect(names, old_names)
[17:47:02.684]                 added <- setdiff(names, old_names)
[17:47:02.684]                 removed <- setdiff(old_names, names)
[17:47:02.684]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.684]                   envs[common]]
[17:47:02.684]                 NAMES <- toupper(changed)
[17:47:02.684]                 args <- list()
[17:47:02.684]                 for (kk in seq_along(NAMES)) {
[17:47:02.684]                   name <- changed[[kk]]
[17:47:02.684]                   NAME <- NAMES[[kk]]
[17:47:02.684]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.684]                     next
[17:47:02.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.684]                 }
[17:47:02.684]                 NAMES <- toupper(added)
[17:47:02.684]                 for (kk in seq_along(NAMES)) {
[17:47:02.684]                   name <- added[[kk]]
[17:47:02.684]                   NAME <- NAMES[[kk]]
[17:47:02.684]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.684]                     next
[17:47:02.684]                   args[[name]] <- ""
[17:47:02.684]                 }
[17:47:02.684]                 NAMES <- toupper(removed)
[17:47:02.684]                 for (kk in seq_along(NAMES)) {
[17:47:02.684]                   name <- removed[[kk]]
[17:47:02.684]                   NAME <- NAMES[[kk]]
[17:47:02.684]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.684]                     next
[17:47:02.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.684]                 }
[17:47:02.684]                 if (length(args) > 0) 
[17:47:02.684]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.684]             }
[17:47:02.684]             else {
[17:47:02.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.684]             }
[17:47:02.684]             {
[17:47:02.684]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.684]                   0L) {
[17:47:02.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.684]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.684]                   base::options(opts)
[17:47:02.684]                 }
[17:47:02.684]                 {
[17:47:02.684]                   {
[17:47:02.684]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:02.684]                     NULL
[17:47:02.684]                   }
[17:47:02.684]                   options(future.plan = NULL)
[17:47:02.684]                   if (is.na(NA_character_)) 
[17:47:02.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.684]                     .init = FALSE)
[17:47:02.684]                 }
[17:47:02.684]             }
[17:47:02.684]         }
[17:47:02.684]     })
[17:47:02.684]     if (TRUE) {
[17:47:02.684]         base::sink(type = "output", split = FALSE)
[17:47:02.684]         if (TRUE) {
[17:47:02.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.684]         }
[17:47:02.684]         else {
[17:47:02.684]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.684]         }
[17:47:02.684]         base::close(...future.stdout)
[17:47:02.684]         ...future.stdout <- NULL
[17:47:02.684]     }
[17:47:02.684]     ...future.result$conditions <- ...future.conditions
[17:47:02.684]     ...future.result$finished <- base::Sys.time()
[17:47:02.684]     ...future.result
[17:47:02.684] }
[17:47:02.687] assign_globals() ...
[17:47:02.687] List of 1
[17:47:02.687]  $ x: list()
[17:47:02.687]  - attr(*, "where")=List of 1
[17:47:02.687]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.687]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.687]  - attr(*, "resolved")= logi TRUE
[17:47:02.687]  - attr(*, "total_size")= num 0
[17:47:02.687]  - attr(*, "already-done")= logi TRUE
[17:47:02.690] - copied ‘x’ to environment
[17:47:02.690] assign_globals() ... done
[17:47:02.690] requestCore(): workers = 2
[17:47:02.692] MulticoreFuture started
[17:47:02.692] - Launch lazy future ... done
[17:47:02.692] run() for ‘MulticoreFuture’ ... done
[17:47:02.693] result() for MulticoreFuture ...
[17:47:02.693] plan(): Setting new future strategy stack:
[17:47:02.693] List of future strategies:
[17:47:02.693] 1. sequential:
[17:47:02.693]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.693]    - tweaked: FALSE
[17:47:02.693]    - call: NULL
[17:47:02.694] plan(): nbrOfWorkers() = 1
[17:47:02.696] plan(): Setting new future strategy stack:
[17:47:02.696] List of future strategies:
[17:47:02.696] 1. multicore:
[17:47:02.696]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:02.696]    - tweaked: FALSE
[17:47:02.696]    - call: plan(strategy)
[17:47:02.701] plan(): nbrOfWorkers() = 2
[17:47:02.702] result() for MulticoreFuture ...
[17:47:02.702] result() for MulticoreFuture ... done
[17:47:02.702] result() for MulticoreFuture ... done
[17:47:02.702] result() for MulticoreFuture ...
[17:47:02.702] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.703] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.703] Searching for globals...
[17:47:02.709] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:02.709] Searching for globals ... DONE
[17:47:02.709] Resolving globals: TRUE
[17:47:02.709] Resolving any globals that are futures ...
[17:47:02.709] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:02.709] Resolving any globals that are futures ... DONE
[17:47:02.710] Resolving futures part of globals (recursively) ...
[17:47:02.710] resolve() on list ...
[17:47:02.710]  recursive: 99
[17:47:02.710]  length: 1
[17:47:02.711]  elements: ‘x’
[17:47:02.711]  length: 0 (resolved future 1)
[17:47:02.711] resolve() on list ... DONE
[17:47:02.711] - globals: [1] ‘x’
[17:47:02.711] Resolving futures part of globals (recursively) ... DONE
[17:47:02.711] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.712] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.712] - globals: [1] ‘x’
[17:47:02.712] 
[17:47:02.712] getGlobalsAndPackages() ... DONE
[17:47:02.713] run() for ‘Future’ ...
[17:47:02.713] - state: ‘created’
[17:47:02.713] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:02.717] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:02.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:02.717]   - Field: ‘label’
[17:47:02.717]   - Field: ‘local’
[17:47:02.717]   - Field: ‘owner’
[17:47:02.717]   - Field: ‘envir’
[17:47:02.718]   - Field: ‘workers’
[17:47:02.718]   - Field: ‘packages’
[17:47:02.718]   - Field: ‘gc’
[17:47:02.718]   - Field: ‘job’
[17:47:02.718]   - Field: ‘conditions’
[17:47:02.718]   - Field: ‘expr’
[17:47:02.718]   - Field: ‘uuid’
[17:47:02.718]   - Field: ‘seed’
[17:47:02.719]   - Field: ‘version’
[17:47:02.719]   - Field: ‘result’
[17:47:02.719]   - Field: ‘asynchronous’
[17:47:02.719]   - Field: ‘calls’
[17:47:02.719]   - Field: ‘globals’
[17:47:02.719]   - Field: ‘stdout’
[17:47:02.719]   - Field: ‘earlySignal’
[17:47:02.719]   - Field: ‘lazy’
[17:47:02.719]   - Field: ‘state’
[17:47:02.720] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:02.720] - Launch lazy future ...
[17:47:02.720] Packages needed by the future expression (n = 0): <none>
[17:47:02.720] Packages needed by future strategies (n = 0): <none>
[17:47:02.721] {
[17:47:02.721]     {
[17:47:02.721]         {
[17:47:02.721]             ...future.startTime <- base::Sys.time()
[17:47:02.721]             {
[17:47:02.721]                 {
[17:47:02.721]                   {
[17:47:02.721]                     {
[17:47:02.721]                       base::local({
[17:47:02.721]                         has_future <- base::requireNamespace("future", 
[17:47:02.721]                           quietly = TRUE)
[17:47:02.721]                         if (has_future) {
[17:47:02.721]                           ns <- base::getNamespace("future")
[17:47:02.721]                           version <- ns[[".package"]][["version"]]
[17:47:02.721]                           if (is.null(version)) 
[17:47:02.721]                             version <- utils::packageVersion("future")
[17:47:02.721]                         }
[17:47:02.721]                         else {
[17:47:02.721]                           version <- NULL
[17:47:02.721]                         }
[17:47:02.721]                         if (!has_future || version < "1.8.0") {
[17:47:02.721]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.721]                             "", base::R.version$version.string), 
[17:47:02.721]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:02.721]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.721]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.721]                               "release", "version")], collapse = " "), 
[17:47:02.721]                             hostname = base::Sys.info()[["nodename"]])
[17:47:02.721]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.721]                             info)
[17:47:02.721]                           info <- base::paste(info, collapse = "; ")
[17:47:02.721]                           if (!has_future) {
[17:47:02.721]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.721]                               info)
[17:47:02.721]                           }
[17:47:02.721]                           else {
[17:47:02.721]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.721]                               info, version)
[17:47:02.721]                           }
[17:47:02.721]                           base::stop(msg)
[17:47:02.721]                         }
[17:47:02.721]                       })
[17:47:02.721]                     }
[17:47:02.721]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:02.721]                     base::options(mc.cores = 1L)
[17:47:02.721]                   }
[17:47:02.721]                   ...future.strategy.old <- future::plan("list")
[17:47:02.721]                   options(future.plan = NULL)
[17:47:02.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.721]                 }
[17:47:02.721]                 ...future.workdir <- getwd()
[17:47:02.721]             }
[17:47:02.721]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.721]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.721]         }
[17:47:02.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.721]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.721]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.721]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.721]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.721]             base::names(...future.oldOptions))
[17:47:02.721]     }
[17:47:02.721]     if (FALSE) {
[17:47:02.721]     }
[17:47:02.721]     else {
[17:47:02.721]         if (TRUE) {
[17:47:02.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.721]                 open = "w")
[17:47:02.721]         }
[17:47:02.721]         else {
[17:47:02.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.721]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.721]         }
[17:47:02.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.721]             base::sink(type = "output", split = FALSE)
[17:47:02.721]             base::close(...future.stdout)
[17:47:02.721]         }, add = TRUE)
[17:47:02.721]     }
[17:47:02.721]     ...future.frame <- base::sys.nframe()
[17:47:02.721]     ...future.conditions <- base::list()
[17:47:02.721]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.721]     if (FALSE) {
[17:47:02.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.721]     }
[17:47:02.721]     ...future.result <- base::tryCatch({
[17:47:02.721]         base::withCallingHandlers({
[17:47:02.721]             ...future.value <- base::withVisible(base::local({
[17:47:02.721]                 withCallingHandlers({
[17:47:02.721]                   {
[17:47:02.721]                     x["a"] <- list(1)
[17:47:02.721]                     x
[17:47:02.721]                   }
[17:47:02.721]                 }, immediateCondition = function(cond) {
[17:47:02.721]                   save_rds <- function (object, pathname, ...) 
[17:47:02.721]                   {
[17:47:02.721]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:02.721]                     if (file_test("-f", pathname_tmp)) {
[17:47:02.721]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.721]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:02.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.721]                         fi_tmp[["mtime"]])
[17:47:02.721]                     }
[17:47:02.721]                     tryCatch({
[17:47:02.721]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:02.721]                     }, error = function(ex) {
[17:47:02.721]                       msg <- conditionMessage(ex)
[17:47:02.721]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.721]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:02.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.721]                         fi_tmp[["mtime"]], msg)
[17:47:02.721]                       ex$message <- msg
[17:47:02.721]                       stop(ex)
[17:47:02.721]                     })
[17:47:02.721]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:02.721]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:02.721]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:02.721]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.721]                       fi <- file.info(pathname)
[17:47:02.721]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:02.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.721]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:02.721]                         fi[["size"]], fi[["mtime"]])
[17:47:02.721]                       stop(msg)
[17:47:02.721]                     }
[17:47:02.721]                     invisible(pathname)
[17:47:02.721]                   }
[17:47:02.721]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:02.721]                     rootPath = tempdir()) 
[17:47:02.721]                   {
[17:47:02.721]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:02.721]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:02.721]                       tmpdir = path, fileext = ".rds")
[17:47:02.721]                     save_rds(obj, file)
[17:47:02.721]                   }
[17:47:02.721]                   saveImmediateCondition(cond, path = "/tmp/RtmpR4Ygft/.future/immediateConditions")
[17:47:02.721]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.721]                   {
[17:47:02.721]                     inherits <- base::inherits
[17:47:02.721]                     invokeRestart <- base::invokeRestart
[17:47:02.721]                     is.null <- base::is.null
[17:47:02.721]                     muffled <- FALSE
[17:47:02.721]                     if (inherits(cond, "message")) {
[17:47:02.721]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:02.721]                       if (muffled) 
[17:47:02.721]                         invokeRestart("muffleMessage")
[17:47:02.721]                     }
[17:47:02.721]                     else if (inherits(cond, "warning")) {
[17:47:02.721]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:02.721]                       if (muffled) 
[17:47:02.721]                         invokeRestart("muffleWarning")
[17:47:02.721]                     }
[17:47:02.721]                     else if (inherits(cond, "condition")) {
[17:47:02.721]                       if (!is.null(pattern)) {
[17:47:02.721]                         computeRestarts <- base::computeRestarts
[17:47:02.721]                         grepl <- base::grepl
[17:47:02.721]                         restarts <- computeRestarts(cond)
[17:47:02.721]                         for (restart in restarts) {
[17:47:02.721]                           name <- restart$name
[17:47:02.721]                           if (is.null(name)) 
[17:47:02.721]                             next
[17:47:02.721]                           if (!grepl(pattern, name)) 
[17:47:02.721]                             next
[17:47:02.721]                           invokeRestart(restart)
[17:47:02.721]                           muffled <- TRUE
[17:47:02.721]                           break
[17:47:02.721]                         }
[17:47:02.721]                       }
[17:47:02.721]                     }
[17:47:02.721]                     invisible(muffled)
[17:47:02.721]                   }
[17:47:02.721]                   muffleCondition(cond)
[17:47:02.721]                 })
[17:47:02.721]             }))
[17:47:02.721]             future::FutureResult(value = ...future.value$value, 
[17:47:02.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.721]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.721]                     ...future.globalenv.names))
[17:47:02.721]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.721]         }, condition = base::local({
[17:47:02.721]             c <- base::c
[17:47:02.721]             inherits <- base::inherits
[17:47:02.721]             invokeRestart <- base::invokeRestart
[17:47:02.721]             length <- base::length
[17:47:02.721]             list <- base::list
[17:47:02.721]             seq.int <- base::seq.int
[17:47:02.721]             signalCondition <- base::signalCondition
[17:47:02.721]             sys.calls <- base::sys.calls
[17:47:02.721]             `[[` <- base::`[[`
[17:47:02.721]             `+` <- base::`+`
[17:47:02.721]             `<<-` <- base::`<<-`
[17:47:02.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.721]                   3L)]
[17:47:02.721]             }
[17:47:02.721]             function(cond) {
[17:47:02.721]                 is_error <- inherits(cond, "error")
[17:47:02.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.721]                   NULL)
[17:47:02.721]                 if (is_error) {
[17:47:02.721]                   sessionInformation <- function() {
[17:47:02.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.721]                       search = base::search(), system = base::Sys.info())
[17:47:02.721]                   }
[17:47:02.721]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.721]                     cond$call), session = sessionInformation(), 
[17:47:02.721]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.721]                   signalCondition(cond)
[17:47:02.721]                 }
[17:47:02.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.721]                 "immediateCondition"))) {
[17:47:02.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.721]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.721]                   if (TRUE && !signal) {
[17:47:02.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.721]                     {
[17:47:02.721]                       inherits <- base::inherits
[17:47:02.721]                       invokeRestart <- base::invokeRestart
[17:47:02.721]                       is.null <- base::is.null
[17:47:02.721]                       muffled <- FALSE
[17:47:02.721]                       if (inherits(cond, "message")) {
[17:47:02.721]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.721]                         if (muffled) 
[17:47:02.721]                           invokeRestart("muffleMessage")
[17:47:02.721]                       }
[17:47:02.721]                       else if (inherits(cond, "warning")) {
[17:47:02.721]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.721]                         if (muffled) 
[17:47:02.721]                           invokeRestart("muffleWarning")
[17:47:02.721]                       }
[17:47:02.721]                       else if (inherits(cond, "condition")) {
[17:47:02.721]                         if (!is.null(pattern)) {
[17:47:02.721]                           computeRestarts <- base::computeRestarts
[17:47:02.721]                           grepl <- base::grepl
[17:47:02.721]                           restarts <- computeRestarts(cond)
[17:47:02.721]                           for (restart in restarts) {
[17:47:02.721]                             name <- restart$name
[17:47:02.721]                             if (is.null(name)) 
[17:47:02.721]                               next
[17:47:02.721]                             if (!grepl(pattern, name)) 
[17:47:02.721]                               next
[17:47:02.721]                             invokeRestart(restart)
[17:47:02.721]                             muffled <- TRUE
[17:47:02.721]                             break
[17:47:02.721]                           }
[17:47:02.721]                         }
[17:47:02.721]                       }
[17:47:02.721]                       invisible(muffled)
[17:47:02.721]                     }
[17:47:02.721]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.721]                   }
[17:47:02.721]                 }
[17:47:02.721]                 else {
[17:47:02.721]                   if (TRUE) {
[17:47:02.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.721]                     {
[17:47:02.721]                       inherits <- base::inherits
[17:47:02.721]                       invokeRestart <- base::invokeRestart
[17:47:02.721]                       is.null <- base::is.null
[17:47:02.721]                       muffled <- FALSE
[17:47:02.721]                       if (inherits(cond, "message")) {
[17:47:02.721]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.721]                         if (muffled) 
[17:47:02.721]                           invokeRestart("muffleMessage")
[17:47:02.721]                       }
[17:47:02.721]                       else if (inherits(cond, "warning")) {
[17:47:02.721]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.721]                         if (muffled) 
[17:47:02.721]                           invokeRestart("muffleWarning")
[17:47:02.721]                       }
[17:47:02.721]                       else if (inherits(cond, "condition")) {
[17:47:02.721]                         if (!is.null(pattern)) {
[17:47:02.721]                           computeRestarts <- base::computeRestarts
[17:47:02.721]                           grepl <- base::grepl
[17:47:02.721]                           restarts <- computeRestarts(cond)
[17:47:02.721]                           for (restart in restarts) {
[17:47:02.721]                             name <- restart$name
[17:47:02.721]                             if (is.null(name)) 
[17:47:02.721]                               next
[17:47:02.721]                             if (!grepl(pattern, name)) 
[17:47:02.721]                               next
[17:47:02.721]                             invokeRestart(restart)
[17:47:02.721]                             muffled <- TRUE
[17:47:02.721]                             break
[17:47:02.721]                           }
[17:47:02.721]                         }
[17:47:02.721]                       }
[17:47:02.721]                       invisible(muffled)
[17:47:02.721]                     }
[17:47:02.721]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.721]                   }
[17:47:02.721]                 }
[17:47:02.721]             }
[17:47:02.721]         }))
[17:47:02.721]     }, error = function(ex) {
[17:47:02.721]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.721]                 ...future.rng), started = ...future.startTime, 
[17:47:02.721]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.721]             version = "1.8"), class = "FutureResult")
[17:47:02.721]     }, finally = {
[17:47:02.721]         if (!identical(...future.workdir, getwd())) 
[17:47:02.721]             setwd(...future.workdir)
[17:47:02.721]         {
[17:47:02.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.721]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.721]             }
[17:47:02.721]             base::options(...future.oldOptions)
[17:47:02.721]             if (.Platform$OS.type == "windows") {
[17:47:02.721]                 old_names <- names(...future.oldEnvVars)
[17:47:02.721]                 envs <- base::Sys.getenv()
[17:47:02.721]                 names <- names(envs)
[17:47:02.721]                 common <- intersect(names, old_names)
[17:47:02.721]                 added <- setdiff(names, old_names)
[17:47:02.721]                 removed <- setdiff(old_names, names)
[17:47:02.721]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.721]                   envs[common]]
[17:47:02.721]                 NAMES <- toupper(changed)
[17:47:02.721]                 args <- list()
[17:47:02.721]                 for (kk in seq_along(NAMES)) {
[17:47:02.721]                   name <- changed[[kk]]
[17:47:02.721]                   NAME <- NAMES[[kk]]
[17:47:02.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.721]                     next
[17:47:02.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.721]                 }
[17:47:02.721]                 NAMES <- toupper(added)
[17:47:02.721]                 for (kk in seq_along(NAMES)) {
[17:47:02.721]                   name <- added[[kk]]
[17:47:02.721]                   NAME <- NAMES[[kk]]
[17:47:02.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.721]                     next
[17:47:02.721]                   args[[name]] <- ""
[17:47:02.721]                 }
[17:47:02.721]                 NAMES <- toupper(removed)
[17:47:02.721]                 for (kk in seq_along(NAMES)) {
[17:47:02.721]                   name <- removed[[kk]]
[17:47:02.721]                   NAME <- NAMES[[kk]]
[17:47:02.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.721]                     next
[17:47:02.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.721]                 }
[17:47:02.721]                 if (length(args) > 0) 
[17:47:02.721]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.721]             }
[17:47:02.721]             else {
[17:47:02.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.721]             }
[17:47:02.721]             {
[17:47:02.721]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.721]                   0L) {
[17:47:02.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.721]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.721]                   base::options(opts)
[17:47:02.721]                 }
[17:47:02.721]                 {
[17:47:02.721]                   {
[17:47:02.721]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:02.721]                     NULL
[17:47:02.721]                   }
[17:47:02.721]                   options(future.plan = NULL)
[17:47:02.721]                   if (is.na(NA_character_)) 
[17:47:02.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.721]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.721]                     .init = FALSE)
[17:47:02.721]                 }
[17:47:02.721]             }
[17:47:02.721]         }
[17:47:02.721]     })
[17:47:02.721]     if (TRUE) {
[17:47:02.721]         base::sink(type = "output", split = FALSE)
[17:47:02.721]         if (TRUE) {
[17:47:02.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.721]         }
[17:47:02.721]         else {
[17:47:02.721]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.721]         }
[17:47:02.721]         base::close(...future.stdout)
[17:47:02.721]         ...future.stdout <- NULL
[17:47:02.721]     }
[17:47:02.721]     ...future.result$conditions <- ...future.conditions
[17:47:02.721]     ...future.result$finished <- base::Sys.time()
[17:47:02.721]     ...future.result
[17:47:02.721] }
[17:47:02.723] assign_globals() ...
[17:47:02.723] List of 1
[17:47:02.723]  $ x: list()
[17:47:02.723]  - attr(*, "where")=List of 1
[17:47:02.723]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.723]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.723]  - attr(*, "resolved")= logi TRUE
[17:47:02.723]  - attr(*, "total_size")= num 0
[17:47:02.723]  - attr(*, "already-done")= logi TRUE
[17:47:02.726] - copied ‘x’ to environment
[17:47:02.726] assign_globals() ... done
[17:47:02.726] requestCore(): workers = 2
[17:47:02.728] MulticoreFuture started
[17:47:02.728] - Launch lazy future ... done
[17:47:02.729] run() for ‘MulticoreFuture’ ... done
[17:47:02.729] result() for MulticoreFuture ...
[17:47:02.729] plan(): Setting new future strategy stack:
[17:47:02.729] List of future strategies:
[17:47:02.729] 1. sequential:
[17:47:02.729]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.729]    - tweaked: FALSE
[17:47:02.729]    - call: NULL
[17:47:02.730] plan(): nbrOfWorkers() = 1
[17:47:02.732] plan(): Setting new future strategy stack:
[17:47:02.732] List of future strategies:
[17:47:02.732] 1. multicore:
[17:47:02.732]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:02.732]    - tweaked: FALSE
[17:47:02.732]    - call: plan(strategy)
[17:47:02.738] plan(): nbrOfWorkers() = 2
[17:47:02.738] result() for MulticoreFuture ...
[17:47:02.739] result() for MulticoreFuture ... done
[17:47:02.739] result() for MulticoreFuture ... done
[17:47:02.739] result() for MulticoreFuture ...
[17:47:02.739] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.740] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.740] Searching for globals...
[17:47:02.743] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:02.743] Searching for globals ... DONE
[17:47:02.743] Resolving globals: TRUE
[17:47:02.743] Resolving any globals that are futures ...
[17:47:02.743] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:02.744] Resolving any globals that are futures ... DONE
[17:47:02.744] Resolving futures part of globals (recursively) ...
[17:47:02.744] resolve() on list ...
[17:47:02.745]  recursive: 99
[17:47:02.745]  length: 1
[17:47:02.745]  elements: ‘x’
[17:47:02.745]  length: 0 (resolved future 1)
[17:47:02.745] resolve() on list ... DONE
[17:47:02.745] - globals: [1] ‘x’
[17:47:02.745] Resolving futures part of globals (recursively) ... DONE
[17:47:02.745] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:02.746] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:02.746] - globals: [1] ‘x’
[17:47:02.746] 
[17:47:02.746] getGlobalsAndPackages() ... DONE
[17:47:02.747] run() for ‘Future’ ...
[17:47:02.747] - state: ‘created’
[17:47:02.747] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:02.751] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:02.751] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:02.751]   - Field: ‘label’
[17:47:02.751]   - Field: ‘local’
[17:47:02.751]   - Field: ‘owner’
[17:47:02.751]   - Field: ‘envir’
[17:47:02.752]   - Field: ‘workers’
[17:47:02.752]   - Field: ‘packages’
[17:47:02.752]   - Field: ‘gc’
[17:47:02.752]   - Field: ‘job’
[17:47:02.752]   - Field: ‘conditions’
[17:47:02.752]   - Field: ‘expr’
[17:47:02.752]   - Field: ‘uuid’
[17:47:02.752]   - Field: ‘seed’
[17:47:02.753]   - Field: ‘version’
[17:47:02.753]   - Field: ‘result’
[17:47:02.753]   - Field: ‘asynchronous’
[17:47:02.753]   - Field: ‘calls’
[17:47:02.753]   - Field: ‘globals’
[17:47:02.753]   - Field: ‘stdout’
[17:47:02.753]   - Field: ‘earlySignal’
[17:47:02.753]   - Field: ‘lazy’
[17:47:02.753]   - Field: ‘state’
[17:47:02.753] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:02.754] - Launch lazy future ...
[17:47:02.754] Packages needed by the future expression (n = 0): <none>
[17:47:02.754] Packages needed by future strategies (n = 0): <none>
[17:47:02.755] {
[17:47:02.755]     {
[17:47:02.755]         {
[17:47:02.755]             ...future.startTime <- base::Sys.time()
[17:47:02.755]             {
[17:47:02.755]                 {
[17:47:02.755]                   {
[17:47:02.755]                     {
[17:47:02.755]                       base::local({
[17:47:02.755]                         has_future <- base::requireNamespace("future", 
[17:47:02.755]                           quietly = TRUE)
[17:47:02.755]                         if (has_future) {
[17:47:02.755]                           ns <- base::getNamespace("future")
[17:47:02.755]                           version <- ns[[".package"]][["version"]]
[17:47:02.755]                           if (is.null(version)) 
[17:47:02.755]                             version <- utils::packageVersion("future")
[17:47:02.755]                         }
[17:47:02.755]                         else {
[17:47:02.755]                           version <- NULL
[17:47:02.755]                         }
[17:47:02.755]                         if (!has_future || version < "1.8.0") {
[17:47:02.755]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.755]                             "", base::R.version$version.string), 
[17:47:02.755]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:02.755]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.755]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.755]                               "release", "version")], collapse = " "), 
[17:47:02.755]                             hostname = base::Sys.info()[["nodename"]])
[17:47:02.755]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.755]                             info)
[17:47:02.755]                           info <- base::paste(info, collapse = "; ")
[17:47:02.755]                           if (!has_future) {
[17:47:02.755]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.755]                               info)
[17:47:02.755]                           }
[17:47:02.755]                           else {
[17:47:02.755]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.755]                               info, version)
[17:47:02.755]                           }
[17:47:02.755]                           base::stop(msg)
[17:47:02.755]                         }
[17:47:02.755]                       })
[17:47:02.755]                     }
[17:47:02.755]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:02.755]                     base::options(mc.cores = 1L)
[17:47:02.755]                   }
[17:47:02.755]                   ...future.strategy.old <- future::plan("list")
[17:47:02.755]                   options(future.plan = NULL)
[17:47:02.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.755]                 }
[17:47:02.755]                 ...future.workdir <- getwd()
[17:47:02.755]             }
[17:47:02.755]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.755]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.755]         }
[17:47:02.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.755]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.755]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.755]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.755]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.755]             base::names(...future.oldOptions))
[17:47:02.755]     }
[17:47:02.755]     if (FALSE) {
[17:47:02.755]     }
[17:47:02.755]     else {
[17:47:02.755]         if (TRUE) {
[17:47:02.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.755]                 open = "w")
[17:47:02.755]         }
[17:47:02.755]         else {
[17:47:02.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.755]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.755]         }
[17:47:02.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.755]             base::sink(type = "output", split = FALSE)
[17:47:02.755]             base::close(...future.stdout)
[17:47:02.755]         }, add = TRUE)
[17:47:02.755]     }
[17:47:02.755]     ...future.frame <- base::sys.nframe()
[17:47:02.755]     ...future.conditions <- base::list()
[17:47:02.755]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.755]     if (FALSE) {
[17:47:02.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.755]     }
[17:47:02.755]     ...future.result <- base::tryCatch({
[17:47:02.755]         base::withCallingHandlers({
[17:47:02.755]             ...future.value <- base::withVisible(base::local({
[17:47:02.755]                 withCallingHandlers({
[17:47:02.755]                   {
[17:47:02.755]                     x["a"] <- list(1)
[17:47:02.755]                     x
[17:47:02.755]                   }
[17:47:02.755]                 }, immediateCondition = function(cond) {
[17:47:02.755]                   save_rds <- function (object, pathname, ...) 
[17:47:02.755]                   {
[17:47:02.755]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:02.755]                     if (file_test("-f", pathname_tmp)) {
[17:47:02.755]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.755]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:02.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.755]                         fi_tmp[["mtime"]])
[17:47:02.755]                     }
[17:47:02.755]                     tryCatch({
[17:47:02.755]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:02.755]                     }, error = function(ex) {
[17:47:02.755]                       msg <- conditionMessage(ex)
[17:47:02.755]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.755]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:02.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.755]                         fi_tmp[["mtime"]], msg)
[17:47:02.755]                       ex$message <- msg
[17:47:02.755]                       stop(ex)
[17:47:02.755]                     })
[17:47:02.755]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:02.755]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:02.755]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:02.755]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.755]                       fi <- file.info(pathname)
[17:47:02.755]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:02.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.755]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:02.755]                         fi[["size"]], fi[["mtime"]])
[17:47:02.755]                       stop(msg)
[17:47:02.755]                     }
[17:47:02.755]                     invisible(pathname)
[17:47:02.755]                   }
[17:47:02.755]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:02.755]                     rootPath = tempdir()) 
[17:47:02.755]                   {
[17:47:02.755]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:02.755]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:02.755]                       tmpdir = path, fileext = ".rds")
[17:47:02.755]                     save_rds(obj, file)
[17:47:02.755]                   }
[17:47:02.755]                   saveImmediateCondition(cond, path = "/tmp/RtmpR4Ygft/.future/immediateConditions")
[17:47:02.755]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.755]                   {
[17:47:02.755]                     inherits <- base::inherits
[17:47:02.755]                     invokeRestart <- base::invokeRestart
[17:47:02.755]                     is.null <- base::is.null
[17:47:02.755]                     muffled <- FALSE
[17:47:02.755]                     if (inherits(cond, "message")) {
[17:47:02.755]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:02.755]                       if (muffled) 
[17:47:02.755]                         invokeRestart("muffleMessage")
[17:47:02.755]                     }
[17:47:02.755]                     else if (inherits(cond, "warning")) {
[17:47:02.755]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:02.755]                       if (muffled) 
[17:47:02.755]                         invokeRestart("muffleWarning")
[17:47:02.755]                     }
[17:47:02.755]                     else if (inherits(cond, "condition")) {
[17:47:02.755]                       if (!is.null(pattern)) {
[17:47:02.755]                         computeRestarts <- base::computeRestarts
[17:47:02.755]                         grepl <- base::grepl
[17:47:02.755]                         restarts <- computeRestarts(cond)
[17:47:02.755]                         for (restart in restarts) {
[17:47:02.755]                           name <- restart$name
[17:47:02.755]                           if (is.null(name)) 
[17:47:02.755]                             next
[17:47:02.755]                           if (!grepl(pattern, name)) 
[17:47:02.755]                             next
[17:47:02.755]                           invokeRestart(restart)
[17:47:02.755]                           muffled <- TRUE
[17:47:02.755]                           break
[17:47:02.755]                         }
[17:47:02.755]                       }
[17:47:02.755]                     }
[17:47:02.755]                     invisible(muffled)
[17:47:02.755]                   }
[17:47:02.755]                   muffleCondition(cond)
[17:47:02.755]                 })
[17:47:02.755]             }))
[17:47:02.755]             future::FutureResult(value = ...future.value$value, 
[17:47:02.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.755]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.755]                     ...future.globalenv.names))
[17:47:02.755]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.755]         }, condition = base::local({
[17:47:02.755]             c <- base::c
[17:47:02.755]             inherits <- base::inherits
[17:47:02.755]             invokeRestart <- base::invokeRestart
[17:47:02.755]             length <- base::length
[17:47:02.755]             list <- base::list
[17:47:02.755]             seq.int <- base::seq.int
[17:47:02.755]             signalCondition <- base::signalCondition
[17:47:02.755]             sys.calls <- base::sys.calls
[17:47:02.755]             `[[` <- base::`[[`
[17:47:02.755]             `+` <- base::`+`
[17:47:02.755]             `<<-` <- base::`<<-`
[17:47:02.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.755]                   3L)]
[17:47:02.755]             }
[17:47:02.755]             function(cond) {
[17:47:02.755]                 is_error <- inherits(cond, "error")
[17:47:02.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.755]                   NULL)
[17:47:02.755]                 if (is_error) {
[17:47:02.755]                   sessionInformation <- function() {
[17:47:02.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.755]                       search = base::search(), system = base::Sys.info())
[17:47:02.755]                   }
[17:47:02.755]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.755]                     cond$call), session = sessionInformation(), 
[17:47:02.755]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.755]                   signalCondition(cond)
[17:47:02.755]                 }
[17:47:02.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.755]                 "immediateCondition"))) {
[17:47:02.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.755]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.755]                   if (TRUE && !signal) {
[17:47:02.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.755]                     {
[17:47:02.755]                       inherits <- base::inherits
[17:47:02.755]                       invokeRestart <- base::invokeRestart
[17:47:02.755]                       is.null <- base::is.null
[17:47:02.755]                       muffled <- FALSE
[17:47:02.755]                       if (inherits(cond, "message")) {
[17:47:02.755]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.755]                         if (muffled) 
[17:47:02.755]                           invokeRestart("muffleMessage")
[17:47:02.755]                       }
[17:47:02.755]                       else if (inherits(cond, "warning")) {
[17:47:02.755]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.755]                         if (muffled) 
[17:47:02.755]                           invokeRestart("muffleWarning")
[17:47:02.755]                       }
[17:47:02.755]                       else if (inherits(cond, "condition")) {
[17:47:02.755]                         if (!is.null(pattern)) {
[17:47:02.755]                           computeRestarts <- base::computeRestarts
[17:47:02.755]                           grepl <- base::grepl
[17:47:02.755]                           restarts <- computeRestarts(cond)
[17:47:02.755]                           for (restart in restarts) {
[17:47:02.755]                             name <- restart$name
[17:47:02.755]                             if (is.null(name)) 
[17:47:02.755]                               next
[17:47:02.755]                             if (!grepl(pattern, name)) 
[17:47:02.755]                               next
[17:47:02.755]                             invokeRestart(restart)
[17:47:02.755]                             muffled <- TRUE
[17:47:02.755]                             break
[17:47:02.755]                           }
[17:47:02.755]                         }
[17:47:02.755]                       }
[17:47:02.755]                       invisible(muffled)
[17:47:02.755]                     }
[17:47:02.755]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.755]                   }
[17:47:02.755]                 }
[17:47:02.755]                 else {
[17:47:02.755]                   if (TRUE) {
[17:47:02.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.755]                     {
[17:47:02.755]                       inherits <- base::inherits
[17:47:02.755]                       invokeRestart <- base::invokeRestart
[17:47:02.755]                       is.null <- base::is.null
[17:47:02.755]                       muffled <- FALSE
[17:47:02.755]                       if (inherits(cond, "message")) {
[17:47:02.755]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.755]                         if (muffled) 
[17:47:02.755]                           invokeRestart("muffleMessage")
[17:47:02.755]                       }
[17:47:02.755]                       else if (inherits(cond, "warning")) {
[17:47:02.755]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.755]                         if (muffled) 
[17:47:02.755]                           invokeRestart("muffleWarning")
[17:47:02.755]                       }
[17:47:02.755]                       else if (inherits(cond, "condition")) {
[17:47:02.755]                         if (!is.null(pattern)) {
[17:47:02.755]                           computeRestarts <- base::computeRestarts
[17:47:02.755]                           grepl <- base::grepl
[17:47:02.755]                           restarts <- computeRestarts(cond)
[17:47:02.755]                           for (restart in restarts) {
[17:47:02.755]                             name <- restart$name
[17:47:02.755]                             if (is.null(name)) 
[17:47:02.755]                               next
[17:47:02.755]                             if (!grepl(pattern, name)) 
[17:47:02.755]                               next
[17:47:02.755]                             invokeRestart(restart)
[17:47:02.755]                             muffled <- TRUE
[17:47:02.755]                             break
[17:47:02.755]                           }
[17:47:02.755]                         }
[17:47:02.755]                       }
[17:47:02.755]                       invisible(muffled)
[17:47:02.755]                     }
[17:47:02.755]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.755]                   }
[17:47:02.755]                 }
[17:47:02.755]             }
[17:47:02.755]         }))
[17:47:02.755]     }, error = function(ex) {
[17:47:02.755]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.755]                 ...future.rng), started = ...future.startTime, 
[17:47:02.755]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.755]             version = "1.8"), class = "FutureResult")
[17:47:02.755]     }, finally = {
[17:47:02.755]         if (!identical(...future.workdir, getwd())) 
[17:47:02.755]             setwd(...future.workdir)
[17:47:02.755]         {
[17:47:02.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.755]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.755]             }
[17:47:02.755]             base::options(...future.oldOptions)
[17:47:02.755]             if (.Platform$OS.type == "windows") {
[17:47:02.755]                 old_names <- names(...future.oldEnvVars)
[17:47:02.755]                 envs <- base::Sys.getenv()
[17:47:02.755]                 names <- names(envs)
[17:47:02.755]                 common <- intersect(names, old_names)
[17:47:02.755]                 added <- setdiff(names, old_names)
[17:47:02.755]                 removed <- setdiff(old_names, names)
[17:47:02.755]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.755]                   envs[common]]
[17:47:02.755]                 NAMES <- toupper(changed)
[17:47:02.755]                 args <- list()
[17:47:02.755]                 for (kk in seq_along(NAMES)) {
[17:47:02.755]                   name <- changed[[kk]]
[17:47:02.755]                   NAME <- NAMES[[kk]]
[17:47:02.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.755]                     next
[17:47:02.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.755]                 }
[17:47:02.755]                 NAMES <- toupper(added)
[17:47:02.755]                 for (kk in seq_along(NAMES)) {
[17:47:02.755]                   name <- added[[kk]]
[17:47:02.755]                   NAME <- NAMES[[kk]]
[17:47:02.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.755]                     next
[17:47:02.755]                   args[[name]] <- ""
[17:47:02.755]                 }
[17:47:02.755]                 NAMES <- toupper(removed)
[17:47:02.755]                 for (kk in seq_along(NAMES)) {
[17:47:02.755]                   name <- removed[[kk]]
[17:47:02.755]                   NAME <- NAMES[[kk]]
[17:47:02.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.755]                     next
[17:47:02.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.755]                 }
[17:47:02.755]                 if (length(args) > 0) 
[17:47:02.755]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.755]             }
[17:47:02.755]             else {
[17:47:02.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.755]             }
[17:47:02.755]             {
[17:47:02.755]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.755]                   0L) {
[17:47:02.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.755]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.755]                   base::options(opts)
[17:47:02.755]                 }
[17:47:02.755]                 {
[17:47:02.755]                   {
[17:47:02.755]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:02.755]                     NULL
[17:47:02.755]                   }
[17:47:02.755]                   options(future.plan = NULL)
[17:47:02.755]                   if (is.na(NA_character_)) 
[17:47:02.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.755]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.755]                     .init = FALSE)
[17:47:02.755]                 }
[17:47:02.755]             }
[17:47:02.755]         }
[17:47:02.755]     })
[17:47:02.755]     if (TRUE) {
[17:47:02.755]         base::sink(type = "output", split = FALSE)
[17:47:02.755]         if (TRUE) {
[17:47:02.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.755]         }
[17:47:02.755]         else {
[17:47:02.755]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.755]         }
[17:47:02.755]         base::close(...future.stdout)
[17:47:02.755]         ...future.stdout <- NULL
[17:47:02.755]     }
[17:47:02.755]     ...future.result$conditions <- ...future.conditions
[17:47:02.755]     ...future.result$finished <- base::Sys.time()
[17:47:02.755]     ...future.result
[17:47:02.755] }
[17:47:02.757] assign_globals() ...
[17:47:02.757] List of 1
[17:47:02.757]  $ x: list()
[17:47:02.757]  - attr(*, "where")=List of 1
[17:47:02.757]   ..$ x:<environment: R_EmptyEnv> 
[17:47:02.757]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.757]  - attr(*, "resolved")= logi TRUE
[17:47:02.757]  - attr(*, "total_size")= num 0
[17:47:02.757]  - attr(*, "already-done")= logi TRUE
[17:47:02.763] - copied ‘x’ to environment
[17:47:02.763] assign_globals() ... done
[17:47:02.763] requestCore(): workers = 2
[17:47:02.765] MulticoreFuture started
[17:47:02.765] - Launch lazy future ... done
[17:47:02.765] run() for ‘MulticoreFuture’ ... done
[17:47:02.766] result() for MulticoreFuture ...
[17:47:02.766] plan(): Setting new future strategy stack:
[17:47:02.766] List of future strategies:
[17:47:02.766] 1. sequential:
[17:47:02.766]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.766]    - tweaked: FALSE
[17:47:02.766]    - call: NULL
[17:47:02.767] plan(): nbrOfWorkers() = 1
[17:47:02.769] plan(): Setting new future strategy stack:
[17:47:02.769] List of future strategies:
[17:47:02.769] 1. multicore:
[17:47:02.769]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:02.769]    - tweaked: FALSE
[17:47:02.769]    - call: plan(strategy)
[17:47:02.774] plan(): nbrOfWorkers() = 2
[17:47:02.775] result() for MulticoreFuture ...
[17:47:02.776] result() for MulticoreFuture ... done
[17:47:02.776] result() for MulticoreFuture ... done
[17:47:02.776] result() for MulticoreFuture ...
[17:47:02.776] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.777] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.777] Searching for globals...
[17:47:02.780] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:47:02.780] Searching for globals ... DONE
[17:47:02.780] Resolving globals: TRUE
[17:47:02.780] Resolving any globals that are futures ...
[17:47:02.781] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:47:02.781] Resolving any globals that are futures ... DONE
[17:47:02.781] Resolving futures part of globals (recursively) ...
[17:47:02.782] resolve() on list ...
[17:47:02.782]  recursive: 99
[17:47:02.782]  length: 2
[17:47:02.782]  elements: ‘x’, ‘name’
[17:47:02.782]  length: 1 (resolved future 1)
[17:47:02.782]  length: 0 (resolved future 2)
[17:47:02.782] resolve() on list ... DONE
[17:47:02.782] - globals: [2] ‘x’, ‘name’
[17:47:02.783] Resolving futures part of globals (recursively) ... DONE
[17:47:02.783] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:02.783] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[17:47:02.783] - globals: [2] ‘x’, ‘name’
[17:47:02.784] 
[17:47:02.784] getGlobalsAndPackages() ... DONE
[17:47:02.784] run() for ‘Future’ ...
[17:47:02.784] - state: ‘created’
[17:47:02.784] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:02.788] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:02.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:02.788]   - Field: ‘label’
[17:47:02.789]   - Field: ‘local’
[17:47:02.789]   - Field: ‘owner’
[17:47:02.789]   - Field: ‘envir’
[17:47:02.789]   - Field: ‘workers’
[17:47:02.789]   - Field: ‘packages’
[17:47:02.789]   - Field: ‘gc’
[17:47:02.789]   - Field: ‘job’
[17:47:02.789]   - Field: ‘conditions’
[17:47:02.789]   - Field: ‘expr’
[17:47:02.790]   - Field: ‘uuid’
[17:47:02.790]   - Field: ‘seed’
[17:47:02.790]   - Field: ‘version’
[17:47:02.790]   - Field: ‘result’
[17:47:02.790]   - Field: ‘asynchronous’
[17:47:02.790]   - Field: ‘calls’
[17:47:02.790]   - Field: ‘globals’
[17:47:02.790]   - Field: ‘stdout’
[17:47:02.790]   - Field: ‘earlySignal’
[17:47:02.791]   - Field: ‘lazy’
[17:47:02.791]   - Field: ‘state’
[17:47:02.791] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:02.791] - Launch lazy future ...
[17:47:02.791] Packages needed by the future expression (n = 0): <none>
[17:47:02.791] Packages needed by future strategies (n = 0): <none>
[17:47:02.792] {
[17:47:02.792]     {
[17:47:02.792]         {
[17:47:02.792]             ...future.startTime <- base::Sys.time()
[17:47:02.792]             {
[17:47:02.792]                 {
[17:47:02.792]                   {
[17:47:02.792]                     {
[17:47:02.792]                       base::local({
[17:47:02.792]                         has_future <- base::requireNamespace("future", 
[17:47:02.792]                           quietly = TRUE)
[17:47:02.792]                         if (has_future) {
[17:47:02.792]                           ns <- base::getNamespace("future")
[17:47:02.792]                           version <- ns[[".package"]][["version"]]
[17:47:02.792]                           if (is.null(version)) 
[17:47:02.792]                             version <- utils::packageVersion("future")
[17:47:02.792]                         }
[17:47:02.792]                         else {
[17:47:02.792]                           version <- NULL
[17:47:02.792]                         }
[17:47:02.792]                         if (!has_future || version < "1.8.0") {
[17:47:02.792]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:02.792]                             "", base::R.version$version.string), 
[17:47:02.792]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:02.792]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:02.792]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:02.792]                               "release", "version")], collapse = " "), 
[17:47:02.792]                             hostname = base::Sys.info()[["nodename"]])
[17:47:02.792]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:02.792]                             info)
[17:47:02.792]                           info <- base::paste(info, collapse = "; ")
[17:47:02.792]                           if (!has_future) {
[17:47:02.792]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:02.792]                               info)
[17:47:02.792]                           }
[17:47:02.792]                           else {
[17:47:02.792]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:02.792]                               info, version)
[17:47:02.792]                           }
[17:47:02.792]                           base::stop(msg)
[17:47:02.792]                         }
[17:47:02.792]                       })
[17:47:02.792]                     }
[17:47:02.792]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:02.792]                     base::options(mc.cores = 1L)
[17:47:02.792]                   }
[17:47:02.792]                   ...future.strategy.old <- future::plan("list")
[17:47:02.792]                   options(future.plan = NULL)
[17:47:02.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:02.792]                 }
[17:47:02.792]                 ...future.workdir <- getwd()
[17:47:02.792]             }
[17:47:02.792]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:02.792]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:02.792]         }
[17:47:02.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:02.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:02.792]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:02.792]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:02.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:02.792]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:02.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:02.792]             base::names(...future.oldOptions))
[17:47:02.792]     }
[17:47:02.792]     if (FALSE) {
[17:47:02.792]     }
[17:47:02.792]     else {
[17:47:02.792]         if (TRUE) {
[17:47:02.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:02.792]                 open = "w")
[17:47:02.792]         }
[17:47:02.792]         else {
[17:47:02.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:02.792]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:02.792]         }
[17:47:02.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:02.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:02.792]             base::sink(type = "output", split = FALSE)
[17:47:02.792]             base::close(...future.stdout)
[17:47:02.792]         }, add = TRUE)
[17:47:02.792]     }
[17:47:02.792]     ...future.frame <- base::sys.nframe()
[17:47:02.792]     ...future.conditions <- base::list()
[17:47:02.792]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:02.792]     if (FALSE) {
[17:47:02.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:02.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:02.792]     }
[17:47:02.792]     ...future.result <- base::tryCatch({
[17:47:02.792]         base::withCallingHandlers({
[17:47:02.792]             ...future.value <- base::withVisible(base::local({
[17:47:02.792]                 withCallingHandlers({
[17:47:02.792]                   {
[17:47:02.792]                     x[name] <- list(1)
[17:47:02.792]                     x
[17:47:02.792]                   }
[17:47:02.792]                 }, immediateCondition = function(cond) {
[17:47:02.792]                   save_rds <- function (object, pathname, ...) 
[17:47:02.792]                   {
[17:47:02.792]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:02.792]                     if (file_test("-f", pathname_tmp)) {
[17:47:02.792]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.792]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:02.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.792]                         fi_tmp[["mtime"]])
[17:47:02.792]                     }
[17:47:02.792]                     tryCatch({
[17:47:02.792]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:02.792]                     }, error = function(ex) {
[17:47:02.792]                       msg <- conditionMessage(ex)
[17:47:02.792]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.792]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:02.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.792]                         fi_tmp[["mtime"]], msg)
[17:47:02.792]                       ex$message <- msg
[17:47:02.792]                       stop(ex)
[17:47:02.792]                     })
[17:47:02.792]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:02.792]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:02.792]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:02.792]                       fi_tmp <- file.info(pathname_tmp)
[17:47:02.792]                       fi <- file.info(pathname)
[17:47:02.792]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:02.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:02.792]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:02.792]                         fi[["size"]], fi[["mtime"]])
[17:47:02.792]                       stop(msg)
[17:47:02.792]                     }
[17:47:02.792]                     invisible(pathname)
[17:47:02.792]                   }
[17:47:02.792]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:02.792]                     rootPath = tempdir()) 
[17:47:02.792]                   {
[17:47:02.792]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:02.792]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:02.792]                       tmpdir = path, fileext = ".rds")
[17:47:02.792]                     save_rds(obj, file)
[17:47:02.792]                   }
[17:47:02.792]                   saveImmediateCondition(cond, path = "/tmp/RtmpR4Ygft/.future/immediateConditions")
[17:47:02.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.792]                   {
[17:47:02.792]                     inherits <- base::inherits
[17:47:02.792]                     invokeRestart <- base::invokeRestart
[17:47:02.792]                     is.null <- base::is.null
[17:47:02.792]                     muffled <- FALSE
[17:47:02.792]                     if (inherits(cond, "message")) {
[17:47:02.792]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:02.792]                       if (muffled) 
[17:47:02.792]                         invokeRestart("muffleMessage")
[17:47:02.792]                     }
[17:47:02.792]                     else if (inherits(cond, "warning")) {
[17:47:02.792]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:02.792]                       if (muffled) 
[17:47:02.792]                         invokeRestart("muffleWarning")
[17:47:02.792]                     }
[17:47:02.792]                     else if (inherits(cond, "condition")) {
[17:47:02.792]                       if (!is.null(pattern)) {
[17:47:02.792]                         computeRestarts <- base::computeRestarts
[17:47:02.792]                         grepl <- base::grepl
[17:47:02.792]                         restarts <- computeRestarts(cond)
[17:47:02.792]                         for (restart in restarts) {
[17:47:02.792]                           name <- restart$name
[17:47:02.792]                           if (is.null(name)) 
[17:47:02.792]                             next
[17:47:02.792]                           if (!grepl(pattern, name)) 
[17:47:02.792]                             next
[17:47:02.792]                           invokeRestart(restart)
[17:47:02.792]                           muffled <- TRUE
[17:47:02.792]                           break
[17:47:02.792]                         }
[17:47:02.792]                       }
[17:47:02.792]                     }
[17:47:02.792]                     invisible(muffled)
[17:47:02.792]                   }
[17:47:02.792]                   muffleCondition(cond)
[17:47:02.792]                 })
[17:47:02.792]             }))
[17:47:02.792]             future::FutureResult(value = ...future.value$value, 
[17:47:02.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.792]                   ...future.rng), globalenv = if (FALSE) 
[17:47:02.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:02.792]                     ...future.globalenv.names))
[17:47:02.792]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:02.792]         }, condition = base::local({
[17:47:02.792]             c <- base::c
[17:47:02.792]             inherits <- base::inherits
[17:47:02.792]             invokeRestart <- base::invokeRestart
[17:47:02.792]             length <- base::length
[17:47:02.792]             list <- base::list
[17:47:02.792]             seq.int <- base::seq.int
[17:47:02.792]             signalCondition <- base::signalCondition
[17:47:02.792]             sys.calls <- base::sys.calls
[17:47:02.792]             `[[` <- base::`[[`
[17:47:02.792]             `+` <- base::`+`
[17:47:02.792]             `<<-` <- base::`<<-`
[17:47:02.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:02.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:02.792]                   3L)]
[17:47:02.792]             }
[17:47:02.792]             function(cond) {
[17:47:02.792]                 is_error <- inherits(cond, "error")
[17:47:02.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:02.792]                   NULL)
[17:47:02.792]                 if (is_error) {
[17:47:02.792]                   sessionInformation <- function() {
[17:47:02.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:02.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:02.792]                       search = base::search(), system = base::Sys.info())
[17:47:02.792]                   }
[17:47:02.792]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:02.792]                     cond$call), session = sessionInformation(), 
[17:47:02.792]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:02.792]                   signalCondition(cond)
[17:47:02.792]                 }
[17:47:02.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:02.792]                 "immediateCondition"))) {
[17:47:02.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:02.792]                   ...future.conditions[[length(...future.conditions) + 
[17:47:02.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:02.792]                   if (TRUE && !signal) {
[17:47:02.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.792]                     {
[17:47:02.792]                       inherits <- base::inherits
[17:47:02.792]                       invokeRestart <- base::invokeRestart
[17:47:02.792]                       is.null <- base::is.null
[17:47:02.792]                       muffled <- FALSE
[17:47:02.792]                       if (inherits(cond, "message")) {
[17:47:02.792]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.792]                         if (muffled) 
[17:47:02.792]                           invokeRestart("muffleMessage")
[17:47:02.792]                       }
[17:47:02.792]                       else if (inherits(cond, "warning")) {
[17:47:02.792]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.792]                         if (muffled) 
[17:47:02.792]                           invokeRestart("muffleWarning")
[17:47:02.792]                       }
[17:47:02.792]                       else if (inherits(cond, "condition")) {
[17:47:02.792]                         if (!is.null(pattern)) {
[17:47:02.792]                           computeRestarts <- base::computeRestarts
[17:47:02.792]                           grepl <- base::grepl
[17:47:02.792]                           restarts <- computeRestarts(cond)
[17:47:02.792]                           for (restart in restarts) {
[17:47:02.792]                             name <- restart$name
[17:47:02.792]                             if (is.null(name)) 
[17:47:02.792]                               next
[17:47:02.792]                             if (!grepl(pattern, name)) 
[17:47:02.792]                               next
[17:47:02.792]                             invokeRestart(restart)
[17:47:02.792]                             muffled <- TRUE
[17:47:02.792]                             break
[17:47:02.792]                           }
[17:47:02.792]                         }
[17:47:02.792]                       }
[17:47:02.792]                       invisible(muffled)
[17:47:02.792]                     }
[17:47:02.792]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.792]                   }
[17:47:02.792]                 }
[17:47:02.792]                 else {
[17:47:02.792]                   if (TRUE) {
[17:47:02.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:02.792]                     {
[17:47:02.792]                       inherits <- base::inherits
[17:47:02.792]                       invokeRestart <- base::invokeRestart
[17:47:02.792]                       is.null <- base::is.null
[17:47:02.792]                       muffled <- FALSE
[17:47:02.792]                       if (inherits(cond, "message")) {
[17:47:02.792]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:02.792]                         if (muffled) 
[17:47:02.792]                           invokeRestart("muffleMessage")
[17:47:02.792]                       }
[17:47:02.792]                       else if (inherits(cond, "warning")) {
[17:47:02.792]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:02.792]                         if (muffled) 
[17:47:02.792]                           invokeRestart("muffleWarning")
[17:47:02.792]                       }
[17:47:02.792]                       else if (inherits(cond, "condition")) {
[17:47:02.792]                         if (!is.null(pattern)) {
[17:47:02.792]                           computeRestarts <- base::computeRestarts
[17:47:02.792]                           grepl <- base::grepl
[17:47:02.792]                           restarts <- computeRestarts(cond)
[17:47:02.792]                           for (restart in restarts) {
[17:47:02.792]                             name <- restart$name
[17:47:02.792]                             if (is.null(name)) 
[17:47:02.792]                               next
[17:47:02.792]                             if (!grepl(pattern, name)) 
[17:47:02.792]                               next
[17:47:02.792]                             invokeRestart(restart)
[17:47:02.792]                             muffled <- TRUE
[17:47:02.792]                             break
[17:47:02.792]                           }
[17:47:02.792]                         }
[17:47:02.792]                       }
[17:47:02.792]                       invisible(muffled)
[17:47:02.792]                     }
[17:47:02.792]                     muffleCondition(cond, pattern = "^muffle")
[17:47:02.792]                   }
[17:47:02.792]                 }
[17:47:02.792]             }
[17:47:02.792]         }))
[17:47:02.792]     }, error = function(ex) {
[17:47:02.792]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:02.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:02.792]                 ...future.rng), started = ...future.startTime, 
[17:47:02.792]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:02.792]             version = "1.8"), class = "FutureResult")
[17:47:02.792]     }, finally = {
[17:47:02.792]         if (!identical(...future.workdir, getwd())) 
[17:47:02.792]             setwd(...future.workdir)
[17:47:02.792]         {
[17:47:02.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:02.792]                 ...future.oldOptions$nwarnings <- NULL
[17:47:02.792]             }
[17:47:02.792]             base::options(...future.oldOptions)
[17:47:02.792]             if (.Platform$OS.type == "windows") {
[17:47:02.792]                 old_names <- names(...future.oldEnvVars)
[17:47:02.792]                 envs <- base::Sys.getenv()
[17:47:02.792]                 names <- names(envs)
[17:47:02.792]                 common <- intersect(names, old_names)
[17:47:02.792]                 added <- setdiff(names, old_names)
[17:47:02.792]                 removed <- setdiff(old_names, names)
[17:47:02.792]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:02.792]                   envs[common]]
[17:47:02.792]                 NAMES <- toupper(changed)
[17:47:02.792]                 args <- list()
[17:47:02.792]                 for (kk in seq_along(NAMES)) {
[17:47:02.792]                   name <- changed[[kk]]
[17:47:02.792]                   NAME <- NAMES[[kk]]
[17:47:02.792]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.792]                     next
[17:47:02.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.792]                 }
[17:47:02.792]                 NAMES <- toupper(added)
[17:47:02.792]                 for (kk in seq_along(NAMES)) {
[17:47:02.792]                   name <- added[[kk]]
[17:47:02.792]                   NAME <- NAMES[[kk]]
[17:47:02.792]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.792]                     next
[17:47:02.792]                   args[[name]] <- ""
[17:47:02.792]                 }
[17:47:02.792]                 NAMES <- toupper(removed)
[17:47:02.792]                 for (kk in seq_along(NAMES)) {
[17:47:02.792]                   name <- removed[[kk]]
[17:47:02.792]                   NAME <- NAMES[[kk]]
[17:47:02.792]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:02.792]                     next
[17:47:02.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:02.792]                 }
[17:47:02.792]                 if (length(args) > 0) 
[17:47:02.792]                   base::do.call(base::Sys.setenv, args = args)
[17:47:02.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:02.792]             }
[17:47:02.792]             else {
[17:47:02.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:02.792]             }
[17:47:02.792]             {
[17:47:02.792]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:02.792]                   0L) {
[17:47:02.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:02.792]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:02.792]                   base::options(opts)
[17:47:02.792]                 }
[17:47:02.792]                 {
[17:47:02.792]                   {
[17:47:02.792]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:02.792]                     NULL
[17:47:02.792]                   }
[17:47:02.792]                   options(future.plan = NULL)
[17:47:02.792]                   if (is.na(NA_character_)) 
[17:47:02.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:02.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:02.792]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:02.792]                     .init = FALSE)
[17:47:02.792]                 }
[17:47:02.792]             }
[17:47:02.792]         }
[17:47:02.792]     })
[17:47:02.792]     if (TRUE) {
[17:47:02.792]         base::sink(type = "output", split = FALSE)
[17:47:02.792]         if (TRUE) {
[17:47:02.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:02.792]         }
[17:47:02.792]         else {
[17:47:02.792]             ...future.result["stdout"] <- base::list(NULL)
[17:47:02.792]         }
[17:47:02.792]         base::close(...future.stdout)
[17:47:02.792]         ...future.stdout <- NULL
[17:47:02.792]     }
[17:47:02.792]     ...future.result$conditions <- ...future.conditions
[17:47:02.792]     ...future.result$finished <- base::Sys.time()
[17:47:02.792]     ...future.result
[17:47:02.792] }
[17:47:02.794] assign_globals() ...
[17:47:02.795] List of 2
[17:47:02.795]  $ x   : list()
[17:47:02.795]  $ name: chr "a"
[17:47:02.795]  - attr(*, "where")=List of 2
[17:47:02.795]   ..$ x   :<environment: R_EmptyEnv> 
[17:47:02.795]   ..$ name:<environment: R_EmptyEnv> 
[17:47:02.795]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:02.795]  - attr(*, "resolved")= logi TRUE
[17:47:02.795]  - attr(*, "total_size")= num 112
[17:47:02.795]  - attr(*, "already-done")= logi TRUE
[17:47:02.798] - copied ‘x’ to environment
[17:47:02.798] - copied ‘name’ to environment
[17:47:02.798] assign_globals() ... done
[17:47:02.798] requestCore(): workers = 2
[17:47:02.800] MulticoreFuture started
[17:47:02.801] - Launch lazy future ... done
[17:47:02.801] run() for ‘MulticoreFuture’ ... done
[17:47:02.801] result() for MulticoreFuture ...
[17:47:02.801] plan(): Setting new future strategy stack:
[17:47:02.801] List of future strategies:
[17:47:02.801] 1. sequential:
[17:47:02.801]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:02.801]    - tweaked: FALSE
[17:47:02.801]    - call: NULL
[17:47:02.802] plan(): nbrOfWorkers() = 1
[17:47:02.804] plan(): Setting new future strategy stack:
[17:47:02.805] List of future strategies:
[17:47:02.805] 1. multicore:
[17:47:02.805]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:02.805]    - tweaked: FALSE
[17:47:02.805]    - call: plan(strategy)
[17:47:02.809] plan(): nbrOfWorkers() = 2
[17:47:02.810] result() for MulticoreFuture ...
[17:47:02.810] result() for MulticoreFuture ... done
[17:47:02.810] result() for MulticoreFuture ... done
[17:47:02.811] result() for MulticoreFuture ...
[17:47:02.811] result() for MulticoreFuture ... done
$a
[1] 1

- plan('multisession') ...
[17:47:02.811] plan(): Setting new future strategy stack:
[17:47:02.812] List of future strategies:
[17:47:02.812] 1. multisession:
[17:47:02.812]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:02.812]    - tweaked: FALSE
[17:47:02.812]    - call: plan(strategy)
[17:47:02.812] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:47:02.812] multisession:
[17:47:02.812] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:02.812] - tweaked: FALSE
[17:47:02.812] - call: plan(strategy)
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:02.821] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:02.822] Not searching for globals
[17:47:02.822] - globals: [0] <none>
[17:47:02.822] getGlobalsAndPackages() ... DONE
[17:47:02.823] [local output] makeClusterPSOCK() ...
[17:47:02.867] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:47:02.868] [local output] Base port: 11643
[17:47:02.868] [local output] Getting setup options for 2 cluster nodes ...
[17:47:02.868] [local output]  - Node 1 of 2 ...
[17:47:02.869] [local output] localMachine=TRUE => revtunnel=FALSE

[17:47:02.869] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpR4Ygft/worker.rank=1.parallelly.parent=44174.ac8e29f7e634.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpR4Ygft/worker.rank=1.parallelly.parent=44174.ac8e29f7e634.pid")'’
[17:47:03.055] - Possible to infer worker's PID: TRUE
[17:47:03.055] [local output] Rscript port: 11643

[17:47:03.056] [local output]  - Node 2 of 2 ...
[17:47:03.056] [local output] localMachine=TRUE => revtunnel=FALSE

[17:47:03.057] [local output] Rscript port: 11643

[17:47:03.057] [local output] Getting setup options for 2 cluster nodes ... done
[17:47:03.057] [local output]  - Parallel setup requested for some PSOCK nodes
[17:47:03.058] [local output] Setting up PSOCK nodes in parallel
[17:47:03.058] List of 36
[17:47:03.058]  $ worker          : chr "localhost"
[17:47:03.058]   ..- attr(*, "localhost")= logi TRUE
[17:47:03.058]  $ master          : chr "localhost"
[17:47:03.058]  $ port            : int 11643
[17:47:03.058]  $ connectTimeout  : num 120
[17:47:03.058]  $ timeout         : num 2592000
[17:47:03.058]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:47:03.058]  $ homogeneous     : logi TRUE
[17:47:03.058]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:47:03.058]  $ rscript_envs    : NULL
[17:47:03.058]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:47:03.058]  $ rscript_startup : NULL
[17:47:03.058]  $ rscript_sh      : chr "sh"
[17:47:03.058]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:47:03.058]  $ methods         : logi TRUE
[17:47:03.058]  $ socketOptions   : chr "no-delay"
[17:47:03.058]  $ useXDR          : logi FALSE
[17:47:03.058]  $ outfile         : chr "/dev/null"
[17:47:03.058]  $ renice          : int NA
[17:47:03.058]  $ rshcmd          : NULL
[17:47:03.058]  $ user            : chr(0) 
[17:47:03.058]  $ revtunnel       : logi FALSE
[17:47:03.058]  $ rshlogfile      : NULL
[17:47:03.058]  $ rshopts         : chr(0) 
[17:47:03.058]  $ rank            : int 1
[17:47:03.058]  $ manual          : logi FALSE
[17:47:03.058]  $ dryrun          : logi FALSE
[17:47:03.058]  $ quiet           : logi FALSE
[17:47:03.058]  $ setup_strategy  : chr "parallel"
[17:47:03.058]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:47:03.058]  $ pidfile         : chr "/tmp/RtmpR4Ygft/worker.rank=1.parallelly.parent=44174.ac8e29f7e634.pid"
[17:47:03.058]  $ rshcmd_label    : NULL
[17:47:03.058]  $ rsh_call        : NULL
[17:47:03.058]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:47:03.058]  $ localMachine    : logi TRUE
[17:47:03.058]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:47:03.058]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:47:03.058]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:47:03.058]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:47:03.058]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:47:03.058]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:47:03.058]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:47:03.058]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:47:03.058]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:47:03.058]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:47:03.058]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:47:03.058]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:47:03.058]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:47:03.058]  $ arguments       :List of 28
[17:47:03.058]   ..$ worker          : chr "localhost"
[17:47:03.058]   ..$ master          : NULL
[17:47:03.058]   ..$ port            : int 11643
[17:47:03.058]   ..$ connectTimeout  : num 120
[17:47:03.058]   ..$ timeout         : num 2592000
[17:47:03.058]   ..$ rscript         : NULL
[17:47:03.058]   ..$ homogeneous     : NULL
[17:47:03.058]   ..$ rscript_args    : NULL
[17:47:03.058]   ..$ rscript_envs    : NULL
[17:47:03.058]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:47:03.058]   ..$ rscript_startup : NULL
[17:47:03.058]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:47:03.058]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:47:03.058]   ..$ methods         : logi TRUE
[17:47:03.058]   ..$ socketOptions   : chr "no-delay"
[17:47:03.058]   ..$ useXDR          : logi FALSE
[17:47:03.058]   ..$ outfile         : chr "/dev/null"
[17:47:03.058]   ..$ renice          : int NA
[17:47:03.058]   ..$ rshcmd          : NULL
[17:47:03.058]   ..$ user            : NULL
[17:47:03.058]   ..$ revtunnel       : logi NA
[17:47:03.058]   ..$ rshlogfile      : NULL
[17:47:03.058]   ..$ rshopts         : NULL
[17:47:03.058]   ..$ rank            : int 1
[17:47:03.058]   ..$ manual          : logi FALSE
[17:47:03.058]   ..$ dryrun          : logi FALSE
[17:47:03.058]   ..$ quiet           : logi FALSE
[17:47:03.058]   ..$ setup_strategy  : chr "parallel"
[17:47:03.058]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:47:03.074] [local output] System call to launch all workers:
[17:47:03.074] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpR4Ygft/worker.rank=1.parallelly.parent=44174.ac8e29f7e634.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11643 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:47:03.074] [local output] Starting PSOCK main server
[17:47:03.080] [local output] Workers launched
[17:47:03.080] [local output] Waiting for workers to connect back
[17:47:03.081]  - [local output] 0 workers out of 2 ready
[17:47:03.324]  - [local output] 0 workers out of 2 ready
[17:47:03.324]  - [local output] 1 workers out of 2 ready
[17:47:03.324]  - [local output] 2 workers out of 2 ready
[17:47:03.325] [local output] Launching of workers completed
[17:47:03.325] [local output] Collecting session information from workers
[17:47:03.325] [local output]  - Worker #1 of 2
[17:47:03.326] [local output]  - Worker #2 of 2
[17:47:03.326] [local output] makeClusterPSOCK() ... done
[17:47:03.339] Packages needed by the future expression (n = 0): <none>
[17:47:03.339] Packages needed by future strategies (n = 0): <none>
[17:47:03.339] {
[17:47:03.339]     {
[17:47:03.339]         {
[17:47:03.339]             ...future.startTime <- base::Sys.time()
[17:47:03.339]             {
[17:47:03.339]                 {
[17:47:03.339]                   {
[17:47:03.339]                     {
[17:47:03.339]                       base::local({
[17:47:03.339]                         has_future <- base::requireNamespace("future", 
[17:47:03.339]                           quietly = TRUE)
[17:47:03.339]                         if (has_future) {
[17:47:03.339]                           ns <- base::getNamespace("future")
[17:47:03.339]                           version <- ns[[".package"]][["version"]]
[17:47:03.339]                           if (is.null(version)) 
[17:47:03.339]                             version <- utils::packageVersion("future")
[17:47:03.339]                         }
[17:47:03.339]                         else {
[17:47:03.339]                           version <- NULL
[17:47:03.339]                         }
[17:47:03.339]                         if (!has_future || version < "1.8.0") {
[17:47:03.339]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:03.339]                             "", base::R.version$version.string), 
[17:47:03.339]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:03.339]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:03.339]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:03.339]                               "release", "version")], collapse = " "), 
[17:47:03.339]                             hostname = base::Sys.info()[["nodename"]])
[17:47:03.339]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:03.339]                             info)
[17:47:03.339]                           info <- base::paste(info, collapse = "; ")
[17:47:03.339]                           if (!has_future) {
[17:47:03.339]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:03.339]                               info)
[17:47:03.339]                           }
[17:47:03.339]                           else {
[17:47:03.339]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:03.339]                               info, version)
[17:47:03.339]                           }
[17:47:03.339]                           base::stop(msg)
[17:47:03.339]                         }
[17:47:03.339]                       })
[17:47:03.339]                     }
[17:47:03.339]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:03.339]                     base::options(mc.cores = 1L)
[17:47:03.339]                   }
[17:47:03.339]                   ...future.strategy.old <- future::plan("list")
[17:47:03.339]                   options(future.plan = NULL)
[17:47:03.339]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.339]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:03.339]                 }
[17:47:03.339]                 ...future.workdir <- getwd()
[17:47:03.339]             }
[17:47:03.339]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:03.339]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:03.339]         }
[17:47:03.339]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:03.339]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:03.339]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:03.339]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:03.339]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:03.339]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:03.339]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:03.339]             base::names(...future.oldOptions))
[17:47:03.339]     }
[17:47:03.339]     if (FALSE) {
[17:47:03.339]     }
[17:47:03.339]     else {
[17:47:03.339]         if (TRUE) {
[17:47:03.339]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:03.339]                 open = "w")
[17:47:03.339]         }
[17:47:03.339]         else {
[17:47:03.339]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:03.339]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:03.339]         }
[17:47:03.339]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:03.339]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:03.339]             base::sink(type = "output", split = FALSE)
[17:47:03.339]             base::close(...future.stdout)
[17:47:03.339]         }, add = TRUE)
[17:47:03.339]     }
[17:47:03.339]     ...future.frame <- base::sys.nframe()
[17:47:03.339]     ...future.conditions <- base::list()
[17:47:03.339]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:03.339]     if (FALSE) {
[17:47:03.339]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:03.339]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:03.339]     }
[17:47:03.339]     ...future.result <- base::tryCatch({
[17:47:03.339]         base::withCallingHandlers({
[17:47:03.339]             ...future.value <- base::withVisible(base::local({
[17:47:03.339]                 ...future.makeSendCondition <- base::local({
[17:47:03.339]                   sendCondition <- NULL
[17:47:03.339]                   function(frame = 1L) {
[17:47:03.339]                     if (is.function(sendCondition)) 
[17:47:03.339]                       return(sendCondition)
[17:47:03.339]                     ns <- getNamespace("parallel")
[17:47:03.339]                     if (exists("sendData", mode = "function", 
[17:47:03.339]                       envir = ns)) {
[17:47:03.339]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:03.339]                         envir = ns)
[17:47:03.339]                       envir <- sys.frame(frame)
[17:47:03.339]                       master <- NULL
[17:47:03.339]                       while (!identical(envir, .GlobalEnv) && 
[17:47:03.339]                         !identical(envir, emptyenv())) {
[17:47:03.339]                         if (exists("master", mode = "list", envir = envir, 
[17:47:03.339]                           inherits = FALSE)) {
[17:47:03.339]                           master <- get("master", mode = "list", 
[17:47:03.339]                             envir = envir, inherits = FALSE)
[17:47:03.339]                           if (inherits(master, c("SOCKnode", 
[17:47:03.339]                             "SOCK0node"))) {
[17:47:03.339]                             sendCondition <<- function(cond) {
[17:47:03.339]                               data <- list(type = "VALUE", value = cond, 
[17:47:03.339]                                 success = TRUE)
[17:47:03.339]                               parallel_sendData(master, data)
[17:47:03.339]                             }
[17:47:03.339]                             return(sendCondition)
[17:47:03.339]                           }
[17:47:03.339]                         }
[17:47:03.339]                         frame <- frame + 1L
[17:47:03.339]                         envir <- sys.frame(frame)
[17:47:03.339]                       }
[17:47:03.339]                     }
[17:47:03.339]                     sendCondition <<- function(cond) NULL
[17:47:03.339]                   }
[17:47:03.339]                 })
[17:47:03.339]                 withCallingHandlers({
[17:47:03.339]                   NA
[17:47:03.339]                 }, immediateCondition = function(cond) {
[17:47:03.339]                   sendCondition <- ...future.makeSendCondition()
[17:47:03.339]                   sendCondition(cond)
[17:47:03.339]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.339]                   {
[17:47:03.339]                     inherits <- base::inherits
[17:47:03.339]                     invokeRestart <- base::invokeRestart
[17:47:03.339]                     is.null <- base::is.null
[17:47:03.339]                     muffled <- FALSE
[17:47:03.339]                     if (inherits(cond, "message")) {
[17:47:03.339]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:03.339]                       if (muffled) 
[17:47:03.339]                         invokeRestart("muffleMessage")
[17:47:03.339]                     }
[17:47:03.339]                     else if (inherits(cond, "warning")) {
[17:47:03.339]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:03.339]                       if (muffled) 
[17:47:03.339]                         invokeRestart("muffleWarning")
[17:47:03.339]                     }
[17:47:03.339]                     else if (inherits(cond, "condition")) {
[17:47:03.339]                       if (!is.null(pattern)) {
[17:47:03.339]                         computeRestarts <- base::computeRestarts
[17:47:03.339]                         grepl <- base::grepl
[17:47:03.339]                         restarts <- computeRestarts(cond)
[17:47:03.339]                         for (restart in restarts) {
[17:47:03.339]                           name <- restart$name
[17:47:03.339]                           if (is.null(name)) 
[17:47:03.339]                             next
[17:47:03.339]                           if (!grepl(pattern, name)) 
[17:47:03.339]                             next
[17:47:03.339]                           invokeRestart(restart)
[17:47:03.339]                           muffled <- TRUE
[17:47:03.339]                           break
[17:47:03.339]                         }
[17:47:03.339]                       }
[17:47:03.339]                     }
[17:47:03.339]                     invisible(muffled)
[17:47:03.339]                   }
[17:47:03.339]                   muffleCondition(cond)
[17:47:03.339]                 })
[17:47:03.339]             }))
[17:47:03.339]             future::FutureResult(value = ...future.value$value, 
[17:47:03.339]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.339]                   ...future.rng), globalenv = if (FALSE) 
[17:47:03.339]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:03.339]                     ...future.globalenv.names))
[17:47:03.339]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:03.339]         }, condition = base::local({
[17:47:03.339]             c <- base::c
[17:47:03.339]             inherits <- base::inherits
[17:47:03.339]             invokeRestart <- base::invokeRestart
[17:47:03.339]             length <- base::length
[17:47:03.339]             list <- base::list
[17:47:03.339]             seq.int <- base::seq.int
[17:47:03.339]             signalCondition <- base::signalCondition
[17:47:03.339]             sys.calls <- base::sys.calls
[17:47:03.339]             `[[` <- base::`[[`
[17:47:03.339]             `+` <- base::`+`
[17:47:03.339]             `<<-` <- base::`<<-`
[17:47:03.339]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:03.339]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:03.339]                   3L)]
[17:47:03.339]             }
[17:47:03.339]             function(cond) {
[17:47:03.339]                 is_error <- inherits(cond, "error")
[17:47:03.339]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:03.339]                   NULL)
[17:47:03.339]                 if (is_error) {
[17:47:03.339]                   sessionInformation <- function() {
[17:47:03.339]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:03.339]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:03.339]                       search = base::search(), system = base::Sys.info())
[17:47:03.339]                   }
[17:47:03.339]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.339]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:03.339]                     cond$call), session = sessionInformation(), 
[17:47:03.339]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:03.339]                   signalCondition(cond)
[17:47:03.339]                 }
[17:47:03.339]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:03.339]                 "immediateCondition"))) {
[17:47:03.339]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:03.339]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.339]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:03.339]                   if (TRUE && !signal) {
[17:47:03.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.339]                     {
[17:47:03.339]                       inherits <- base::inherits
[17:47:03.339]                       invokeRestart <- base::invokeRestart
[17:47:03.339]                       is.null <- base::is.null
[17:47:03.339]                       muffled <- FALSE
[17:47:03.339]                       if (inherits(cond, "message")) {
[17:47:03.339]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.339]                         if (muffled) 
[17:47:03.339]                           invokeRestart("muffleMessage")
[17:47:03.339]                       }
[17:47:03.339]                       else if (inherits(cond, "warning")) {
[17:47:03.339]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.339]                         if (muffled) 
[17:47:03.339]                           invokeRestart("muffleWarning")
[17:47:03.339]                       }
[17:47:03.339]                       else if (inherits(cond, "condition")) {
[17:47:03.339]                         if (!is.null(pattern)) {
[17:47:03.339]                           computeRestarts <- base::computeRestarts
[17:47:03.339]                           grepl <- base::grepl
[17:47:03.339]                           restarts <- computeRestarts(cond)
[17:47:03.339]                           for (restart in restarts) {
[17:47:03.339]                             name <- restart$name
[17:47:03.339]                             if (is.null(name)) 
[17:47:03.339]                               next
[17:47:03.339]                             if (!grepl(pattern, name)) 
[17:47:03.339]                               next
[17:47:03.339]                             invokeRestart(restart)
[17:47:03.339]                             muffled <- TRUE
[17:47:03.339]                             break
[17:47:03.339]                           }
[17:47:03.339]                         }
[17:47:03.339]                       }
[17:47:03.339]                       invisible(muffled)
[17:47:03.339]                     }
[17:47:03.339]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.339]                   }
[17:47:03.339]                 }
[17:47:03.339]                 else {
[17:47:03.339]                   if (TRUE) {
[17:47:03.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.339]                     {
[17:47:03.339]                       inherits <- base::inherits
[17:47:03.339]                       invokeRestart <- base::invokeRestart
[17:47:03.339]                       is.null <- base::is.null
[17:47:03.339]                       muffled <- FALSE
[17:47:03.339]                       if (inherits(cond, "message")) {
[17:47:03.339]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.339]                         if (muffled) 
[17:47:03.339]                           invokeRestart("muffleMessage")
[17:47:03.339]                       }
[17:47:03.339]                       else if (inherits(cond, "warning")) {
[17:47:03.339]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.339]                         if (muffled) 
[17:47:03.339]                           invokeRestart("muffleWarning")
[17:47:03.339]                       }
[17:47:03.339]                       else if (inherits(cond, "condition")) {
[17:47:03.339]                         if (!is.null(pattern)) {
[17:47:03.339]                           computeRestarts <- base::computeRestarts
[17:47:03.339]                           grepl <- base::grepl
[17:47:03.339]                           restarts <- computeRestarts(cond)
[17:47:03.339]                           for (restart in restarts) {
[17:47:03.339]                             name <- restart$name
[17:47:03.339]                             if (is.null(name)) 
[17:47:03.339]                               next
[17:47:03.339]                             if (!grepl(pattern, name)) 
[17:47:03.339]                               next
[17:47:03.339]                             invokeRestart(restart)
[17:47:03.339]                             muffled <- TRUE
[17:47:03.339]                             break
[17:47:03.339]                           }
[17:47:03.339]                         }
[17:47:03.339]                       }
[17:47:03.339]                       invisible(muffled)
[17:47:03.339]                     }
[17:47:03.339]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.339]                   }
[17:47:03.339]                 }
[17:47:03.339]             }
[17:47:03.339]         }))
[17:47:03.339]     }, error = function(ex) {
[17:47:03.339]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:03.339]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.339]                 ...future.rng), started = ...future.startTime, 
[17:47:03.339]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:03.339]             version = "1.8"), class = "FutureResult")
[17:47:03.339]     }, finally = {
[17:47:03.339]         if (!identical(...future.workdir, getwd())) 
[17:47:03.339]             setwd(...future.workdir)
[17:47:03.339]         {
[17:47:03.339]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:03.339]                 ...future.oldOptions$nwarnings <- NULL
[17:47:03.339]             }
[17:47:03.339]             base::options(...future.oldOptions)
[17:47:03.339]             if (.Platform$OS.type == "windows") {
[17:47:03.339]                 old_names <- names(...future.oldEnvVars)
[17:47:03.339]                 envs <- base::Sys.getenv()
[17:47:03.339]                 names <- names(envs)
[17:47:03.339]                 common <- intersect(names, old_names)
[17:47:03.339]                 added <- setdiff(names, old_names)
[17:47:03.339]                 removed <- setdiff(old_names, names)
[17:47:03.339]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:03.339]                   envs[common]]
[17:47:03.339]                 NAMES <- toupper(changed)
[17:47:03.339]                 args <- list()
[17:47:03.339]                 for (kk in seq_along(NAMES)) {
[17:47:03.339]                   name <- changed[[kk]]
[17:47:03.339]                   NAME <- NAMES[[kk]]
[17:47:03.339]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.339]                     next
[17:47:03.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.339]                 }
[17:47:03.339]                 NAMES <- toupper(added)
[17:47:03.339]                 for (kk in seq_along(NAMES)) {
[17:47:03.339]                   name <- added[[kk]]
[17:47:03.339]                   NAME <- NAMES[[kk]]
[17:47:03.339]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.339]                     next
[17:47:03.339]                   args[[name]] <- ""
[17:47:03.339]                 }
[17:47:03.339]                 NAMES <- toupper(removed)
[17:47:03.339]                 for (kk in seq_along(NAMES)) {
[17:47:03.339]                   name <- removed[[kk]]
[17:47:03.339]                   NAME <- NAMES[[kk]]
[17:47:03.339]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.339]                     next
[17:47:03.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.339]                 }
[17:47:03.339]                 if (length(args) > 0) 
[17:47:03.339]                   base::do.call(base::Sys.setenv, args = args)
[17:47:03.339]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:03.339]             }
[17:47:03.339]             else {
[17:47:03.339]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:03.339]             }
[17:47:03.339]             {
[17:47:03.339]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:03.339]                   0L) {
[17:47:03.339]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:03.339]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:03.339]                   base::options(opts)
[17:47:03.339]                 }
[17:47:03.339]                 {
[17:47:03.339]                   {
[17:47:03.339]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:03.339]                     NULL
[17:47:03.339]                   }
[17:47:03.339]                   options(future.plan = NULL)
[17:47:03.339]                   if (is.na(NA_character_)) 
[17:47:03.339]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.339]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:03.339]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:03.339]                     .init = FALSE)
[17:47:03.339]                 }
[17:47:03.339]             }
[17:47:03.339]         }
[17:47:03.339]     })
[17:47:03.339]     if (TRUE) {
[17:47:03.339]         base::sink(type = "output", split = FALSE)
[17:47:03.339]         if (TRUE) {
[17:47:03.339]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:03.339]         }
[17:47:03.339]         else {
[17:47:03.339]             ...future.result["stdout"] <- base::list(NULL)
[17:47:03.339]         }
[17:47:03.339]         base::close(...future.stdout)
[17:47:03.339]         ...future.stdout <- NULL
[17:47:03.339]     }
[17:47:03.339]     ...future.result$conditions <- ...future.conditions
[17:47:03.339]     ...future.result$finished <- base::Sys.time()
[17:47:03.339]     ...future.result
[17:47:03.339] }
[17:47:03.392] MultisessionFuture started
[17:47:03.393] result() for ClusterFuture ...
[17:47:03.393] receiveMessageFromWorker() for ClusterFuture ...
[17:47:03.393] - Validating connection of MultisessionFuture
[17:47:03.425] - received message: FutureResult
[17:47:03.425] - Received FutureResult
[17:47:03.425] - Erased future from FutureRegistry
[17:47:03.426] result() for ClusterFuture ...
[17:47:03.426] - result already collected: FutureResult
[17:47:03.426] result() for ClusterFuture ... done
[17:47:03.426] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:03.426] result() for ClusterFuture ... done
[17:47:03.426] result() for ClusterFuture ...
[17:47:03.426] - result already collected: FutureResult
[17:47:03.426] result() for ClusterFuture ... done
[17:47:03.427] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:47:03.430] plan(): nbrOfWorkers() = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:03.431] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:03.431] Searching for globals...
[17:47:03.434] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:03.434] Searching for globals ... DONE
[17:47:03.434] Resolving globals: TRUE
[17:47:03.434] Resolving any globals that are futures ...
[17:47:03.434] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:03.434] Resolving any globals that are futures ... DONE
[17:47:03.435] Resolving futures part of globals (recursively) ...
[17:47:03.435] resolve() on list ...
[17:47:03.435]  recursive: 99
[17:47:03.435]  length: 1
[17:47:03.435]  elements: ‘x’
[17:47:03.435]  length: 0 (resolved future 1)
[17:47:03.436] resolve() on list ... DONE
[17:47:03.436] - globals: [1] ‘x’
[17:47:03.436] Resolving futures part of globals (recursively) ... DONE
[17:47:03.436] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:03.436] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:03.436] - globals: [1] ‘x’
[17:47:03.437] 
[17:47:03.437] getGlobalsAndPackages() ... DONE
[17:47:03.437] run() for ‘Future’ ...
[17:47:03.437] - state: ‘created’
[17:47:03.437] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:03.452] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:03.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:03.452]   - Field: ‘node’
[17:47:03.452]   - Field: ‘label’
[17:47:03.452]   - Field: ‘local’
[17:47:03.452]   - Field: ‘owner’
[17:47:03.452]   - Field: ‘envir’
[17:47:03.452]   - Field: ‘workers’
[17:47:03.452]   - Field: ‘packages’
[17:47:03.453]   - Field: ‘gc’
[17:47:03.453]   - Field: ‘conditions’
[17:47:03.453]   - Field: ‘persistent’
[17:47:03.453]   - Field: ‘expr’
[17:47:03.453]   - Field: ‘uuid’
[17:47:03.453]   - Field: ‘seed’
[17:47:03.453]   - Field: ‘version’
[17:47:03.453]   - Field: ‘result’
[17:47:03.453]   - Field: ‘asynchronous’
[17:47:03.454]   - Field: ‘calls’
[17:47:03.454]   - Field: ‘globals’
[17:47:03.454]   - Field: ‘stdout’
[17:47:03.454]   - Field: ‘earlySignal’
[17:47:03.454]   - Field: ‘lazy’
[17:47:03.454]   - Field: ‘state’
[17:47:03.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:03.454] - Launch lazy future ...
[17:47:03.455] Packages needed by the future expression (n = 0): <none>
[17:47:03.455] Packages needed by future strategies (n = 0): <none>
[17:47:03.455] {
[17:47:03.455]     {
[17:47:03.455]         {
[17:47:03.455]             ...future.startTime <- base::Sys.time()
[17:47:03.455]             {
[17:47:03.455]                 {
[17:47:03.455]                   {
[17:47:03.455]                     {
[17:47:03.455]                       base::local({
[17:47:03.455]                         has_future <- base::requireNamespace("future", 
[17:47:03.455]                           quietly = TRUE)
[17:47:03.455]                         if (has_future) {
[17:47:03.455]                           ns <- base::getNamespace("future")
[17:47:03.455]                           version <- ns[[".package"]][["version"]]
[17:47:03.455]                           if (is.null(version)) 
[17:47:03.455]                             version <- utils::packageVersion("future")
[17:47:03.455]                         }
[17:47:03.455]                         else {
[17:47:03.455]                           version <- NULL
[17:47:03.455]                         }
[17:47:03.455]                         if (!has_future || version < "1.8.0") {
[17:47:03.455]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:03.455]                             "", base::R.version$version.string), 
[17:47:03.455]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:03.455]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:03.455]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:03.455]                               "release", "version")], collapse = " "), 
[17:47:03.455]                             hostname = base::Sys.info()[["nodename"]])
[17:47:03.455]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:03.455]                             info)
[17:47:03.455]                           info <- base::paste(info, collapse = "; ")
[17:47:03.455]                           if (!has_future) {
[17:47:03.455]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:03.455]                               info)
[17:47:03.455]                           }
[17:47:03.455]                           else {
[17:47:03.455]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:03.455]                               info, version)
[17:47:03.455]                           }
[17:47:03.455]                           base::stop(msg)
[17:47:03.455]                         }
[17:47:03.455]                       })
[17:47:03.455]                     }
[17:47:03.455]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:03.455]                     base::options(mc.cores = 1L)
[17:47:03.455]                   }
[17:47:03.455]                   ...future.strategy.old <- future::plan("list")
[17:47:03.455]                   options(future.plan = NULL)
[17:47:03.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:03.455]                 }
[17:47:03.455]                 ...future.workdir <- getwd()
[17:47:03.455]             }
[17:47:03.455]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:03.455]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:03.455]         }
[17:47:03.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:03.455]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:03.455]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:03.455]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:03.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:03.455]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:03.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:03.455]             base::names(...future.oldOptions))
[17:47:03.455]     }
[17:47:03.455]     if (FALSE) {
[17:47:03.455]     }
[17:47:03.455]     else {
[17:47:03.455]         if (TRUE) {
[17:47:03.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:03.455]                 open = "w")
[17:47:03.455]         }
[17:47:03.455]         else {
[17:47:03.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:03.455]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:03.455]         }
[17:47:03.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:03.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:03.455]             base::sink(type = "output", split = FALSE)
[17:47:03.455]             base::close(...future.stdout)
[17:47:03.455]         }, add = TRUE)
[17:47:03.455]     }
[17:47:03.455]     ...future.frame <- base::sys.nframe()
[17:47:03.455]     ...future.conditions <- base::list()
[17:47:03.455]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:03.455]     if (FALSE) {
[17:47:03.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:03.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:03.455]     }
[17:47:03.455]     ...future.result <- base::tryCatch({
[17:47:03.455]         base::withCallingHandlers({
[17:47:03.455]             ...future.value <- base::withVisible(base::local({
[17:47:03.455]                 ...future.makeSendCondition <- base::local({
[17:47:03.455]                   sendCondition <- NULL
[17:47:03.455]                   function(frame = 1L) {
[17:47:03.455]                     if (is.function(sendCondition)) 
[17:47:03.455]                       return(sendCondition)
[17:47:03.455]                     ns <- getNamespace("parallel")
[17:47:03.455]                     if (exists("sendData", mode = "function", 
[17:47:03.455]                       envir = ns)) {
[17:47:03.455]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:03.455]                         envir = ns)
[17:47:03.455]                       envir <- sys.frame(frame)
[17:47:03.455]                       master <- NULL
[17:47:03.455]                       while (!identical(envir, .GlobalEnv) && 
[17:47:03.455]                         !identical(envir, emptyenv())) {
[17:47:03.455]                         if (exists("master", mode = "list", envir = envir, 
[17:47:03.455]                           inherits = FALSE)) {
[17:47:03.455]                           master <- get("master", mode = "list", 
[17:47:03.455]                             envir = envir, inherits = FALSE)
[17:47:03.455]                           if (inherits(master, c("SOCKnode", 
[17:47:03.455]                             "SOCK0node"))) {
[17:47:03.455]                             sendCondition <<- function(cond) {
[17:47:03.455]                               data <- list(type = "VALUE", value = cond, 
[17:47:03.455]                                 success = TRUE)
[17:47:03.455]                               parallel_sendData(master, data)
[17:47:03.455]                             }
[17:47:03.455]                             return(sendCondition)
[17:47:03.455]                           }
[17:47:03.455]                         }
[17:47:03.455]                         frame <- frame + 1L
[17:47:03.455]                         envir <- sys.frame(frame)
[17:47:03.455]                       }
[17:47:03.455]                     }
[17:47:03.455]                     sendCondition <<- function(cond) NULL
[17:47:03.455]                   }
[17:47:03.455]                 })
[17:47:03.455]                 withCallingHandlers({
[17:47:03.455]                   {
[17:47:03.455]                     x$a <- 1
[17:47:03.455]                     x
[17:47:03.455]                   }
[17:47:03.455]                 }, immediateCondition = function(cond) {
[17:47:03.455]                   sendCondition <- ...future.makeSendCondition()
[17:47:03.455]                   sendCondition(cond)
[17:47:03.455]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.455]                   {
[17:47:03.455]                     inherits <- base::inherits
[17:47:03.455]                     invokeRestart <- base::invokeRestart
[17:47:03.455]                     is.null <- base::is.null
[17:47:03.455]                     muffled <- FALSE
[17:47:03.455]                     if (inherits(cond, "message")) {
[17:47:03.455]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:03.455]                       if (muffled) 
[17:47:03.455]                         invokeRestart("muffleMessage")
[17:47:03.455]                     }
[17:47:03.455]                     else if (inherits(cond, "warning")) {
[17:47:03.455]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:03.455]                       if (muffled) 
[17:47:03.455]                         invokeRestart("muffleWarning")
[17:47:03.455]                     }
[17:47:03.455]                     else if (inherits(cond, "condition")) {
[17:47:03.455]                       if (!is.null(pattern)) {
[17:47:03.455]                         computeRestarts <- base::computeRestarts
[17:47:03.455]                         grepl <- base::grepl
[17:47:03.455]                         restarts <- computeRestarts(cond)
[17:47:03.455]                         for (restart in restarts) {
[17:47:03.455]                           name <- restart$name
[17:47:03.455]                           if (is.null(name)) 
[17:47:03.455]                             next
[17:47:03.455]                           if (!grepl(pattern, name)) 
[17:47:03.455]                             next
[17:47:03.455]                           invokeRestart(restart)
[17:47:03.455]                           muffled <- TRUE
[17:47:03.455]                           break
[17:47:03.455]                         }
[17:47:03.455]                       }
[17:47:03.455]                     }
[17:47:03.455]                     invisible(muffled)
[17:47:03.455]                   }
[17:47:03.455]                   muffleCondition(cond)
[17:47:03.455]                 })
[17:47:03.455]             }))
[17:47:03.455]             future::FutureResult(value = ...future.value$value, 
[17:47:03.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.455]                   ...future.rng), globalenv = if (FALSE) 
[17:47:03.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:03.455]                     ...future.globalenv.names))
[17:47:03.455]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:03.455]         }, condition = base::local({
[17:47:03.455]             c <- base::c
[17:47:03.455]             inherits <- base::inherits
[17:47:03.455]             invokeRestart <- base::invokeRestart
[17:47:03.455]             length <- base::length
[17:47:03.455]             list <- base::list
[17:47:03.455]             seq.int <- base::seq.int
[17:47:03.455]             signalCondition <- base::signalCondition
[17:47:03.455]             sys.calls <- base::sys.calls
[17:47:03.455]             `[[` <- base::`[[`
[17:47:03.455]             `+` <- base::`+`
[17:47:03.455]             `<<-` <- base::`<<-`
[17:47:03.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:03.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:03.455]                   3L)]
[17:47:03.455]             }
[17:47:03.455]             function(cond) {
[17:47:03.455]                 is_error <- inherits(cond, "error")
[17:47:03.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:03.455]                   NULL)
[17:47:03.455]                 if (is_error) {
[17:47:03.455]                   sessionInformation <- function() {
[17:47:03.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:03.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:03.455]                       search = base::search(), system = base::Sys.info())
[17:47:03.455]                   }
[17:47:03.455]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:03.455]                     cond$call), session = sessionInformation(), 
[17:47:03.455]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:03.455]                   signalCondition(cond)
[17:47:03.455]                 }
[17:47:03.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:03.455]                 "immediateCondition"))) {
[17:47:03.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:03.455]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:03.455]                   if (TRUE && !signal) {
[17:47:03.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.455]                     {
[17:47:03.455]                       inherits <- base::inherits
[17:47:03.455]                       invokeRestart <- base::invokeRestart
[17:47:03.455]                       is.null <- base::is.null
[17:47:03.455]                       muffled <- FALSE
[17:47:03.455]                       if (inherits(cond, "message")) {
[17:47:03.455]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.455]                         if (muffled) 
[17:47:03.455]                           invokeRestart("muffleMessage")
[17:47:03.455]                       }
[17:47:03.455]                       else if (inherits(cond, "warning")) {
[17:47:03.455]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.455]                         if (muffled) 
[17:47:03.455]                           invokeRestart("muffleWarning")
[17:47:03.455]                       }
[17:47:03.455]                       else if (inherits(cond, "condition")) {
[17:47:03.455]                         if (!is.null(pattern)) {
[17:47:03.455]                           computeRestarts <- base::computeRestarts
[17:47:03.455]                           grepl <- base::grepl
[17:47:03.455]                           restarts <- computeRestarts(cond)
[17:47:03.455]                           for (restart in restarts) {
[17:47:03.455]                             name <- restart$name
[17:47:03.455]                             if (is.null(name)) 
[17:47:03.455]                               next
[17:47:03.455]                             if (!grepl(pattern, name)) 
[17:47:03.455]                               next
[17:47:03.455]                             invokeRestart(restart)
[17:47:03.455]                             muffled <- TRUE
[17:47:03.455]                             break
[17:47:03.455]                           }
[17:47:03.455]                         }
[17:47:03.455]                       }
[17:47:03.455]                       invisible(muffled)
[17:47:03.455]                     }
[17:47:03.455]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.455]                   }
[17:47:03.455]                 }
[17:47:03.455]                 else {
[17:47:03.455]                   if (TRUE) {
[17:47:03.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.455]                     {
[17:47:03.455]                       inherits <- base::inherits
[17:47:03.455]                       invokeRestart <- base::invokeRestart
[17:47:03.455]                       is.null <- base::is.null
[17:47:03.455]                       muffled <- FALSE
[17:47:03.455]                       if (inherits(cond, "message")) {
[17:47:03.455]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.455]                         if (muffled) 
[17:47:03.455]                           invokeRestart("muffleMessage")
[17:47:03.455]                       }
[17:47:03.455]                       else if (inherits(cond, "warning")) {
[17:47:03.455]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.455]                         if (muffled) 
[17:47:03.455]                           invokeRestart("muffleWarning")
[17:47:03.455]                       }
[17:47:03.455]                       else if (inherits(cond, "condition")) {
[17:47:03.455]                         if (!is.null(pattern)) {
[17:47:03.455]                           computeRestarts <- base::computeRestarts
[17:47:03.455]                           grepl <- base::grepl
[17:47:03.455]                           restarts <- computeRestarts(cond)
[17:47:03.455]                           for (restart in restarts) {
[17:47:03.455]                             name <- restart$name
[17:47:03.455]                             if (is.null(name)) 
[17:47:03.455]                               next
[17:47:03.455]                             if (!grepl(pattern, name)) 
[17:47:03.455]                               next
[17:47:03.455]                             invokeRestart(restart)
[17:47:03.455]                             muffled <- TRUE
[17:47:03.455]                             break
[17:47:03.455]                           }
[17:47:03.455]                         }
[17:47:03.455]                       }
[17:47:03.455]                       invisible(muffled)
[17:47:03.455]                     }
[17:47:03.455]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.455]                   }
[17:47:03.455]                 }
[17:47:03.455]             }
[17:47:03.455]         }))
[17:47:03.455]     }, error = function(ex) {
[17:47:03.455]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:03.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.455]                 ...future.rng), started = ...future.startTime, 
[17:47:03.455]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:03.455]             version = "1.8"), class = "FutureResult")
[17:47:03.455]     }, finally = {
[17:47:03.455]         if (!identical(...future.workdir, getwd())) 
[17:47:03.455]             setwd(...future.workdir)
[17:47:03.455]         {
[17:47:03.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:03.455]                 ...future.oldOptions$nwarnings <- NULL
[17:47:03.455]             }
[17:47:03.455]             base::options(...future.oldOptions)
[17:47:03.455]             if (.Platform$OS.type == "windows") {
[17:47:03.455]                 old_names <- names(...future.oldEnvVars)
[17:47:03.455]                 envs <- base::Sys.getenv()
[17:47:03.455]                 names <- names(envs)
[17:47:03.455]                 common <- intersect(names, old_names)
[17:47:03.455]                 added <- setdiff(names, old_names)
[17:47:03.455]                 removed <- setdiff(old_names, names)
[17:47:03.455]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:03.455]                   envs[common]]
[17:47:03.455]                 NAMES <- toupper(changed)
[17:47:03.455]                 args <- list()
[17:47:03.455]                 for (kk in seq_along(NAMES)) {
[17:47:03.455]                   name <- changed[[kk]]
[17:47:03.455]                   NAME <- NAMES[[kk]]
[17:47:03.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.455]                     next
[17:47:03.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.455]                 }
[17:47:03.455]                 NAMES <- toupper(added)
[17:47:03.455]                 for (kk in seq_along(NAMES)) {
[17:47:03.455]                   name <- added[[kk]]
[17:47:03.455]                   NAME <- NAMES[[kk]]
[17:47:03.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.455]                     next
[17:47:03.455]                   args[[name]] <- ""
[17:47:03.455]                 }
[17:47:03.455]                 NAMES <- toupper(removed)
[17:47:03.455]                 for (kk in seq_along(NAMES)) {
[17:47:03.455]                   name <- removed[[kk]]
[17:47:03.455]                   NAME <- NAMES[[kk]]
[17:47:03.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.455]                     next
[17:47:03.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.455]                 }
[17:47:03.455]                 if (length(args) > 0) 
[17:47:03.455]                   base::do.call(base::Sys.setenv, args = args)
[17:47:03.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:03.455]             }
[17:47:03.455]             else {
[17:47:03.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:03.455]             }
[17:47:03.455]             {
[17:47:03.455]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:03.455]                   0L) {
[17:47:03.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:03.455]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:03.455]                   base::options(opts)
[17:47:03.455]                 }
[17:47:03.455]                 {
[17:47:03.455]                   {
[17:47:03.455]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:03.455]                     NULL
[17:47:03.455]                   }
[17:47:03.455]                   options(future.plan = NULL)
[17:47:03.455]                   if (is.na(NA_character_)) 
[17:47:03.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:03.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:03.455]                     .init = FALSE)
[17:47:03.455]                 }
[17:47:03.455]             }
[17:47:03.455]         }
[17:47:03.455]     })
[17:47:03.455]     if (TRUE) {
[17:47:03.455]         base::sink(type = "output", split = FALSE)
[17:47:03.455]         if (TRUE) {
[17:47:03.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:03.455]         }
[17:47:03.455]         else {
[17:47:03.455]             ...future.result["stdout"] <- base::list(NULL)
[17:47:03.455]         }
[17:47:03.455]         base::close(...future.stdout)
[17:47:03.455]         ...future.stdout <- NULL
[17:47:03.455]     }
[17:47:03.455]     ...future.result$conditions <- ...future.conditions
[17:47:03.455]     ...future.result$finished <- base::Sys.time()
[17:47:03.455]     ...future.result
[17:47:03.455] }
[17:47:03.458] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:47:03.458] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:47:03.459] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:47:03.459] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:47:03.460] MultisessionFuture started
[17:47:03.460] - Launch lazy future ... done
[17:47:03.460] run() for ‘MultisessionFuture’ ... done
[17:47:03.460] result() for ClusterFuture ...
[17:47:03.460] receiveMessageFromWorker() for ClusterFuture ...
[17:47:03.460] - Validating connection of MultisessionFuture
[17:47:03.461] - received message: FutureResult
[17:47:03.461] - Received FutureResult
[17:47:03.461] - Erased future from FutureRegistry
[17:47:03.462] result() for ClusterFuture ...
[17:47:03.462] - result already collected: FutureResult
[17:47:03.462] result() for ClusterFuture ... done
[17:47:03.462] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:03.462] result() for ClusterFuture ... done
[17:47:03.462] result() for ClusterFuture ...
[17:47:03.462] - result already collected: FutureResult
[17:47:03.462] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:03.463] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:03.463] Searching for globals...
[17:47:03.465] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:03.465] Searching for globals ... DONE
[17:47:03.466] Resolving globals: TRUE
[17:47:03.466] Resolving any globals that are futures ...
[17:47:03.466] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:03.466] Resolving any globals that are futures ... DONE
[17:47:03.466] Resolving futures part of globals (recursively) ...
[17:47:03.467] resolve() on list ...
[17:47:03.467]  recursive: 99
[17:47:03.467]  length: 1
[17:47:03.467]  elements: ‘x’
[17:47:03.467]  length: 0 (resolved future 1)
[17:47:03.467] resolve() on list ... DONE
[17:47:03.467] - globals: [1] ‘x’
[17:47:03.468] Resolving futures part of globals (recursively) ... DONE
[17:47:03.468] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:03.468] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:03.468] - globals: [1] ‘x’
[17:47:03.468] 
[17:47:03.468] getGlobalsAndPackages() ... DONE
[17:47:03.469] run() for ‘Future’ ...
[17:47:03.469] - state: ‘created’
[17:47:03.469] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:03.483] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:03.483] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:03.484]   - Field: ‘node’
[17:47:03.484]   - Field: ‘label’
[17:47:03.484]   - Field: ‘local’
[17:47:03.484]   - Field: ‘owner’
[17:47:03.484]   - Field: ‘envir’
[17:47:03.484]   - Field: ‘workers’
[17:47:03.484]   - Field: ‘packages’
[17:47:03.484]   - Field: ‘gc’
[17:47:03.484]   - Field: ‘conditions’
[17:47:03.484]   - Field: ‘persistent’
[17:47:03.485]   - Field: ‘expr’
[17:47:03.485]   - Field: ‘uuid’
[17:47:03.485]   - Field: ‘seed’
[17:47:03.485]   - Field: ‘version’
[17:47:03.485]   - Field: ‘result’
[17:47:03.485]   - Field: ‘asynchronous’
[17:47:03.485]   - Field: ‘calls’
[17:47:03.485]   - Field: ‘globals’
[17:47:03.486]   - Field: ‘stdout’
[17:47:03.486]   - Field: ‘earlySignal’
[17:47:03.486]   - Field: ‘lazy’
[17:47:03.486]   - Field: ‘state’
[17:47:03.486] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:03.486] - Launch lazy future ...
[17:47:03.486] Packages needed by the future expression (n = 0): <none>
[17:47:03.487] Packages needed by future strategies (n = 0): <none>
[17:47:03.487] {
[17:47:03.487]     {
[17:47:03.487]         {
[17:47:03.487]             ...future.startTime <- base::Sys.time()
[17:47:03.487]             {
[17:47:03.487]                 {
[17:47:03.487]                   {
[17:47:03.487]                     {
[17:47:03.487]                       base::local({
[17:47:03.487]                         has_future <- base::requireNamespace("future", 
[17:47:03.487]                           quietly = TRUE)
[17:47:03.487]                         if (has_future) {
[17:47:03.487]                           ns <- base::getNamespace("future")
[17:47:03.487]                           version <- ns[[".package"]][["version"]]
[17:47:03.487]                           if (is.null(version)) 
[17:47:03.487]                             version <- utils::packageVersion("future")
[17:47:03.487]                         }
[17:47:03.487]                         else {
[17:47:03.487]                           version <- NULL
[17:47:03.487]                         }
[17:47:03.487]                         if (!has_future || version < "1.8.0") {
[17:47:03.487]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:03.487]                             "", base::R.version$version.string), 
[17:47:03.487]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:03.487]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:03.487]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:03.487]                               "release", "version")], collapse = " "), 
[17:47:03.487]                             hostname = base::Sys.info()[["nodename"]])
[17:47:03.487]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:03.487]                             info)
[17:47:03.487]                           info <- base::paste(info, collapse = "; ")
[17:47:03.487]                           if (!has_future) {
[17:47:03.487]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:03.487]                               info)
[17:47:03.487]                           }
[17:47:03.487]                           else {
[17:47:03.487]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:03.487]                               info, version)
[17:47:03.487]                           }
[17:47:03.487]                           base::stop(msg)
[17:47:03.487]                         }
[17:47:03.487]                       })
[17:47:03.487]                     }
[17:47:03.487]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:03.487]                     base::options(mc.cores = 1L)
[17:47:03.487]                   }
[17:47:03.487]                   ...future.strategy.old <- future::plan("list")
[17:47:03.487]                   options(future.plan = NULL)
[17:47:03.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:03.487]                 }
[17:47:03.487]                 ...future.workdir <- getwd()
[17:47:03.487]             }
[17:47:03.487]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:03.487]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:03.487]         }
[17:47:03.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:03.487]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:03.487]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:03.487]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:03.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:03.487]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:03.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:03.487]             base::names(...future.oldOptions))
[17:47:03.487]     }
[17:47:03.487]     if (FALSE) {
[17:47:03.487]     }
[17:47:03.487]     else {
[17:47:03.487]         if (TRUE) {
[17:47:03.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:03.487]                 open = "w")
[17:47:03.487]         }
[17:47:03.487]         else {
[17:47:03.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:03.487]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:03.487]         }
[17:47:03.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:03.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:03.487]             base::sink(type = "output", split = FALSE)
[17:47:03.487]             base::close(...future.stdout)
[17:47:03.487]         }, add = TRUE)
[17:47:03.487]     }
[17:47:03.487]     ...future.frame <- base::sys.nframe()
[17:47:03.487]     ...future.conditions <- base::list()
[17:47:03.487]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:03.487]     if (FALSE) {
[17:47:03.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:03.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:03.487]     }
[17:47:03.487]     ...future.result <- base::tryCatch({
[17:47:03.487]         base::withCallingHandlers({
[17:47:03.487]             ...future.value <- base::withVisible(base::local({
[17:47:03.487]                 ...future.makeSendCondition <- base::local({
[17:47:03.487]                   sendCondition <- NULL
[17:47:03.487]                   function(frame = 1L) {
[17:47:03.487]                     if (is.function(sendCondition)) 
[17:47:03.487]                       return(sendCondition)
[17:47:03.487]                     ns <- getNamespace("parallel")
[17:47:03.487]                     if (exists("sendData", mode = "function", 
[17:47:03.487]                       envir = ns)) {
[17:47:03.487]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:03.487]                         envir = ns)
[17:47:03.487]                       envir <- sys.frame(frame)
[17:47:03.487]                       master <- NULL
[17:47:03.487]                       while (!identical(envir, .GlobalEnv) && 
[17:47:03.487]                         !identical(envir, emptyenv())) {
[17:47:03.487]                         if (exists("master", mode = "list", envir = envir, 
[17:47:03.487]                           inherits = FALSE)) {
[17:47:03.487]                           master <- get("master", mode = "list", 
[17:47:03.487]                             envir = envir, inherits = FALSE)
[17:47:03.487]                           if (inherits(master, c("SOCKnode", 
[17:47:03.487]                             "SOCK0node"))) {
[17:47:03.487]                             sendCondition <<- function(cond) {
[17:47:03.487]                               data <- list(type = "VALUE", value = cond, 
[17:47:03.487]                                 success = TRUE)
[17:47:03.487]                               parallel_sendData(master, data)
[17:47:03.487]                             }
[17:47:03.487]                             return(sendCondition)
[17:47:03.487]                           }
[17:47:03.487]                         }
[17:47:03.487]                         frame <- frame + 1L
[17:47:03.487]                         envir <- sys.frame(frame)
[17:47:03.487]                       }
[17:47:03.487]                     }
[17:47:03.487]                     sendCondition <<- function(cond) NULL
[17:47:03.487]                   }
[17:47:03.487]                 })
[17:47:03.487]                 withCallingHandlers({
[17:47:03.487]                   {
[17:47:03.487]                     x$a <- 1
[17:47:03.487]                     x
[17:47:03.487]                   }
[17:47:03.487]                 }, immediateCondition = function(cond) {
[17:47:03.487]                   sendCondition <- ...future.makeSendCondition()
[17:47:03.487]                   sendCondition(cond)
[17:47:03.487]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.487]                   {
[17:47:03.487]                     inherits <- base::inherits
[17:47:03.487]                     invokeRestart <- base::invokeRestart
[17:47:03.487]                     is.null <- base::is.null
[17:47:03.487]                     muffled <- FALSE
[17:47:03.487]                     if (inherits(cond, "message")) {
[17:47:03.487]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:03.487]                       if (muffled) 
[17:47:03.487]                         invokeRestart("muffleMessage")
[17:47:03.487]                     }
[17:47:03.487]                     else if (inherits(cond, "warning")) {
[17:47:03.487]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:03.487]                       if (muffled) 
[17:47:03.487]                         invokeRestart("muffleWarning")
[17:47:03.487]                     }
[17:47:03.487]                     else if (inherits(cond, "condition")) {
[17:47:03.487]                       if (!is.null(pattern)) {
[17:47:03.487]                         computeRestarts <- base::computeRestarts
[17:47:03.487]                         grepl <- base::grepl
[17:47:03.487]                         restarts <- computeRestarts(cond)
[17:47:03.487]                         for (restart in restarts) {
[17:47:03.487]                           name <- restart$name
[17:47:03.487]                           if (is.null(name)) 
[17:47:03.487]                             next
[17:47:03.487]                           if (!grepl(pattern, name)) 
[17:47:03.487]                             next
[17:47:03.487]                           invokeRestart(restart)
[17:47:03.487]                           muffled <- TRUE
[17:47:03.487]                           break
[17:47:03.487]                         }
[17:47:03.487]                       }
[17:47:03.487]                     }
[17:47:03.487]                     invisible(muffled)
[17:47:03.487]                   }
[17:47:03.487]                   muffleCondition(cond)
[17:47:03.487]                 })
[17:47:03.487]             }))
[17:47:03.487]             future::FutureResult(value = ...future.value$value, 
[17:47:03.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.487]                   ...future.rng), globalenv = if (FALSE) 
[17:47:03.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:03.487]                     ...future.globalenv.names))
[17:47:03.487]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:03.487]         }, condition = base::local({
[17:47:03.487]             c <- base::c
[17:47:03.487]             inherits <- base::inherits
[17:47:03.487]             invokeRestart <- base::invokeRestart
[17:47:03.487]             length <- base::length
[17:47:03.487]             list <- base::list
[17:47:03.487]             seq.int <- base::seq.int
[17:47:03.487]             signalCondition <- base::signalCondition
[17:47:03.487]             sys.calls <- base::sys.calls
[17:47:03.487]             `[[` <- base::`[[`
[17:47:03.487]             `+` <- base::`+`
[17:47:03.487]             `<<-` <- base::`<<-`
[17:47:03.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:03.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:03.487]                   3L)]
[17:47:03.487]             }
[17:47:03.487]             function(cond) {
[17:47:03.487]                 is_error <- inherits(cond, "error")
[17:47:03.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:03.487]                   NULL)
[17:47:03.487]                 if (is_error) {
[17:47:03.487]                   sessionInformation <- function() {
[17:47:03.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:03.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:03.487]                       search = base::search(), system = base::Sys.info())
[17:47:03.487]                   }
[17:47:03.487]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:03.487]                     cond$call), session = sessionInformation(), 
[17:47:03.487]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:03.487]                   signalCondition(cond)
[17:47:03.487]                 }
[17:47:03.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:03.487]                 "immediateCondition"))) {
[17:47:03.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:03.487]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:03.487]                   if (TRUE && !signal) {
[17:47:03.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.487]                     {
[17:47:03.487]                       inherits <- base::inherits
[17:47:03.487]                       invokeRestart <- base::invokeRestart
[17:47:03.487]                       is.null <- base::is.null
[17:47:03.487]                       muffled <- FALSE
[17:47:03.487]                       if (inherits(cond, "message")) {
[17:47:03.487]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.487]                         if (muffled) 
[17:47:03.487]                           invokeRestart("muffleMessage")
[17:47:03.487]                       }
[17:47:03.487]                       else if (inherits(cond, "warning")) {
[17:47:03.487]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.487]                         if (muffled) 
[17:47:03.487]                           invokeRestart("muffleWarning")
[17:47:03.487]                       }
[17:47:03.487]                       else if (inherits(cond, "condition")) {
[17:47:03.487]                         if (!is.null(pattern)) {
[17:47:03.487]                           computeRestarts <- base::computeRestarts
[17:47:03.487]                           grepl <- base::grepl
[17:47:03.487]                           restarts <- computeRestarts(cond)
[17:47:03.487]                           for (restart in restarts) {
[17:47:03.487]                             name <- restart$name
[17:47:03.487]                             if (is.null(name)) 
[17:47:03.487]                               next
[17:47:03.487]                             if (!grepl(pattern, name)) 
[17:47:03.487]                               next
[17:47:03.487]                             invokeRestart(restart)
[17:47:03.487]                             muffled <- TRUE
[17:47:03.487]                             break
[17:47:03.487]                           }
[17:47:03.487]                         }
[17:47:03.487]                       }
[17:47:03.487]                       invisible(muffled)
[17:47:03.487]                     }
[17:47:03.487]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.487]                   }
[17:47:03.487]                 }
[17:47:03.487]                 else {
[17:47:03.487]                   if (TRUE) {
[17:47:03.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.487]                     {
[17:47:03.487]                       inherits <- base::inherits
[17:47:03.487]                       invokeRestart <- base::invokeRestart
[17:47:03.487]                       is.null <- base::is.null
[17:47:03.487]                       muffled <- FALSE
[17:47:03.487]                       if (inherits(cond, "message")) {
[17:47:03.487]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.487]                         if (muffled) 
[17:47:03.487]                           invokeRestart("muffleMessage")
[17:47:03.487]                       }
[17:47:03.487]                       else if (inherits(cond, "warning")) {
[17:47:03.487]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.487]                         if (muffled) 
[17:47:03.487]                           invokeRestart("muffleWarning")
[17:47:03.487]                       }
[17:47:03.487]                       else if (inherits(cond, "condition")) {
[17:47:03.487]                         if (!is.null(pattern)) {
[17:47:03.487]                           computeRestarts <- base::computeRestarts
[17:47:03.487]                           grepl <- base::grepl
[17:47:03.487]                           restarts <- computeRestarts(cond)
[17:47:03.487]                           for (restart in restarts) {
[17:47:03.487]                             name <- restart$name
[17:47:03.487]                             if (is.null(name)) 
[17:47:03.487]                               next
[17:47:03.487]                             if (!grepl(pattern, name)) 
[17:47:03.487]                               next
[17:47:03.487]                             invokeRestart(restart)
[17:47:03.487]                             muffled <- TRUE
[17:47:03.487]                             break
[17:47:03.487]                           }
[17:47:03.487]                         }
[17:47:03.487]                       }
[17:47:03.487]                       invisible(muffled)
[17:47:03.487]                     }
[17:47:03.487]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.487]                   }
[17:47:03.487]                 }
[17:47:03.487]             }
[17:47:03.487]         }))
[17:47:03.487]     }, error = function(ex) {
[17:47:03.487]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:03.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.487]                 ...future.rng), started = ...future.startTime, 
[17:47:03.487]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:03.487]             version = "1.8"), class = "FutureResult")
[17:47:03.487]     }, finally = {
[17:47:03.487]         if (!identical(...future.workdir, getwd())) 
[17:47:03.487]             setwd(...future.workdir)
[17:47:03.487]         {
[17:47:03.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:03.487]                 ...future.oldOptions$nwarnings <- NULL
[17:47:03.487]             }
[17:47:03.487]             base::options(...future.oldOptions)
[17:47:03.487]             if (.Platform$OS.type == "windows") {
[17:47:03.487]                 old_names <- names(...future.oldEnvVars)
[17:47:03.487]                 envs <- base::Sys.getenv()
[17:47:03.487]                 names <- names(envs)
[17:47:03.487]                 common <- intersect(names, old_names)
[17:47:03.487]                 added <- setdiff(names, old_names)
[17:47:03.487]                 removed <- setdiff(old_names, names)
[17:47:03.487]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:03.487]                   envs[common]]
[17:47:03.487]                 NAMES <- toupper(changed)
[17:47:03.487]                 args <- list()
[17:47:03.487]                 for (kk in seq_along(NAMES)) {
[17:47:03.487]                   name <- changed[[kk]]
[17:47:03.487]                   NAME <- NAMES[[kk]]
[17:47:03.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.487]                     next
[17:47:03.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.487]                 }
[17:47:03.487]                 NAMES <- toupper(added)
[17:47:03.487]                 for (kk in seq_along(NAMES)) {
[17:47:03.487]                   name <- added[[kk]]
[17:47:03.487]                   NAME <- NAMES[[kk]]
[17:47:03.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.487]                     next
[17:47:03.487]                   args[[name]] <- ""
[17:47:03.487]                 }
[17:47:03.487]                 NAMES <- toupper(removed)
[17:47:03.487]                 for (kk in seq_along(NAMES)) {
[17:47:03.487]                   name <- removed[[kk]]
[17:47:03.487]                   NAME <- NAMES[[kk]]
[17:47:03.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.487]                     next
[17:47:03.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.487]                 }
[17:47:03.487]                 if (length(args) > 0) 
[17:47:03.487]                   base::do.call(base::Sys.setenv, args = args)
[17:47:03.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:03.487]             }
[17:47:03.487]             else {
[17:47:03.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:03.487]             }
[17:47:03.487]             {
[17:47:03.487]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:03.487]                   0L) {
[17:47:03.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:03.487]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:03.487]                   base::options(opts)
[17:47:03.487]                 }
[17:47:03.487]                 {
[17:47:03.487]                   {
[17:47:03.487]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:03.487]                     NULL
[17:47:03.487]                   }
[17:47:03.487]                   options(future.plan = NULL)
[17:47:03.487]                   if (is.na(NA_character_)) 
[17:47:03.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:03.487]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:03.487]                     .init = FALSE)
[17:47:03.487]                 }
[17:47:03.487]             }
[17:47:03.487]         }
[17:47:03.487]     })
[17:47:03.487]     if (TRUE) {
[17:47:03.487]         base::sink(type = "output", split = FALSE)
[17:47:03.487]         if (TRUE) {
[17:47:03.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:03.487]         }
[17:47:03.487]         else {
[17:47:03.487]             ...future.result["stdout"] <- base::list(NULL)
[17:47:03.487]         }
[17:47:03.487]         base::close(...future.stdout)
[17:47:03.487]         ...future.stdout <- NULL
[17:47:03.487]     }
[17:47:03.487]     ...future.result$conditions <- ...future.conditions
[17:47:03.487]     ...future.result$finished <- base::Sys.time()
[17:47:03.487]     ...future.result
[17:47:03.487] }
[17:47:03.490] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:47:03.490] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:47:03.490] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:47:03.491] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:47:03.491] MultisessionFuture started
[17:47:03.491] - Launch lazy future ... done
[17:47:03.492] run() for ‘MultisessionFuture’ ... done
[17:47:03.492] result() for ClusterFuture ...
[17:47:03.492] receiveMessageFromWorker() for ClusterFuture ...
[17:47:03.492] - Validating connection of MultisessionFuture
[17:47:03.497] - received message: FutureResult
[17:47:03.497] - Received FutureResult
[17:47:03.497] - Erased future from FutureRegistry
[17:47:03.497] result() for ClusterFuture ...
[17:47:03.497] - result already collected: FutureResult
[17:47:03.497] result() for ClusterFuture ... done
[17:47:03.497] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:03.498] result() for ClusterFuture ... done
[17:47:03.498] result() for ClusterFuture ...
[17:47:03.498] - result already collected: FutureResult
[17:47:03.498] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:03.498] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:03.499] Searching for globals...
[17:47:03.501] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:03.501] Searching for globals ... DONE
[17:47:03.501] Resolving globals: TRUE
[17:47:03.502] Resolving any globals that are futures ...
[17:47:03.502] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:03.502] Resolving any globals that are futures ... DONE
[17:47:03.502] Resolving futures part of globals (recursively) ...
[17:47:03.503] resolve() on list ...
[17:47:03.503]  recursive: 99
[17:47:03.503]  length: 1
[17:47:03.503]  elements: ‘x’
[17:47:03.503]  length: 0 (resolved future 1)
[17:47:03.503] resolve() on list ... DONE
[17:47:03.503] - globals: [1] ‘x’
[17:47:03.503] Resolving futures part of globals (recursively) ... DONE
[17:47:03.504] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:03.504] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:03.504] - globals: [1] ‘x’
[17:47:03.504] 
[17:47:03.504] getGlobalsAndPackages() ... DONE
[17:47:03.505] run() for ‘Future’ ...
[17:47:03.505] - state: ‘created’
[17:47:03.505] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:03.521] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:03.521] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:03.521]   - Field: ‘node’
[17:47:03.521]   - Field: ‘label’
[17:47:03.521]   - Field: ‘local’
[17:47:03.522]   - Field: ‘owner’
[17:47:03.522]   - Field: ‘envir’
[17:47:03.522]   - Field: ‘workers’
[17:47:03.522]   - Field: ‘packages’
[17:47:03.522]   - Field: ‘gc’
[17:47:03.522]   - Field: ‘conditions’
[17:47:03.522]   - Field: ‘persistent’
[17:47:03.522]   - Field: ‘expr’
[17:47:03.522]   - Field: ‘uuid’
[17:47:03.522]   - Field: ‘seed’
[17:47:03.522]   - Field: ‘version’
[17:47:03.523]   - Field: ‘result’
[17:47:03.523]   - Field: ‘asynchronous’
[17:47:03.523]   - Field: ‘calls’
[17:47:03.523]   - Field: ‘globals’
[17:47:03.523]   - Field: ‘stdout’
[17:47:03.523]   - Field: ‘earlySignal’
[17:47:03.523]   - Field: ‘lazy’
[17:47:03.523]   - Field: ‘state’
[17:47:03.523] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:03.523] - Launch lazy future ...
[17:47:03.524] Packages needed by the future expression (n = 0): <none>
[17:47:03.524] Packages needed by future strategies (n = 0): <none>
[17:47:03.524] {
[17:47:03.524]     {
[17:47:03.524]         {
[17:47:03.524]             ...future.startTime <- base::Sys.time()
[17:47:03.524]             {
[17:47:03.524]                 {
[17:47:03.524]                   {
[17:47:03.524]                     {
[17:47:03.524]                       base::local({
[17:47:03.524]                         has_future <- base::requireNamespace("future", 
[17:47:03.524]                           quietly = TRUE)
[17:47:03.524]                         if (has_future) {
[17:47:03.524]                           ns <- base::getNamespace("future")
[17:47:03.524]                           version <- ns[[".package"]][["version"]]
[17:47:03.524]                           if (is.null(version)) 
[17:47:03.524]                             version <- utils::packageVersion("future")
[17:47:03.524]                         }
[17:47:03.524]                         else {
[17:47:03.524]                           version <- NULL
[17:47:03.524]                         }
[17:47:03.524]                         if (!has_future || version < "1.8.0") {
[17:47:03.524]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:03.524]                             "", base::R.version$version.string), 
[17:47:03.524]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:03.524]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:03.524]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:03.524]                               "release", "version")], collapse = " "), 
[17:47:03.524]                             hostname = base::Sys.info()[["nodename"]])
[17:47:03.524]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:03.524]                             info)
[17:47:03.524]                           info <- base::paste(info, collapse = "; ")
[17:47:03.524]                           if (!has_future) {
[17:47:03.524]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:03.524]                               info)
[17:47:03.524]                           }
[17:47:03.524]                           else {
[17:47:03.524]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:03.524]                               info, version)
[17:47:03.524]                           }
[17:47:03.524]                           base::stop(msg)
[17:47:03.524]                         }
[17:47:03.524]                       })
[17:47:03.524]                     }
[17:47:03.524]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:03.524]                     base::options(mc.cores = 1L)
[17:47:03.524]                   }
[17:47:03.524]                   ...future.strategy.old <- future::plan("list")
[17:47:03.524]                   options(future.plan = NULL)
[17:47:03.524]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.524]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:03.524]                 }
[17:47:03.524]                 ...future.workdir <- getwd()
[17:47:03.524]             }
[17:47:03.524]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:03.524]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:03.524]         }
[17:47:03.524]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:03.524]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:03.524]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:03.524]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:03.524]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:03.524]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:03.524]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:03.524]             base::names(...future.oldOptions))
[17:47:03.524]     }
[17:47:03.524]     if (FALSE) {
[17:47:03.524]     }
[17:47:03.524]     else {
[17:47:03.524]         if (TRUE) {
[17:47:03.524]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:03.524]                 open = "w")
[17:47:03.524]         }
[17:47:03.524]         else {
[17:47:03.524]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:03.524]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:03.524]         }
[17:47:03.524]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:03.524]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:03.524]             base::sink(type = "output", split = FALSE)
[17:47:03.524]             base::close(...future.stdout)
[17:47:03.524]         }, add = TRUE)
[17:47:03.524]     }
[17:47:03.524]     ...future.frame <- base::sys.nframe()
[17:47:03.524]     ...future.conditions <- base::list()
[17:47:03.524]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:03.524]     if (FALSE) {
[17:47:03.524]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:03.524]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:03.524]     }
[17:47:03.524]     ...future.result <- base::tryCatch({
[17:47:03.524]         base::withCallingHandlers({
[17:47:03.524]             ...future.value <- base::withVisible(base::local({
[17:47:03.524]                 ...future.makeSendCondition <- base::local({
[17:47:03.524]                   sendCondition <- NULL
[17:47:03.524]                   function(frame = 1L) {
[17:47:03.524]                     if (is.function(sendCondition)) 
[17:47:03.524]                       return(sendCondition)
[17:47:03.524]                     ns <- getNamespace("parallel")
[17:47:03.524]                     if (exists("sendData", mode = "function", 
[17:47:03.524]                       envir = ns)) {
[17:47:03.524]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:03.524]                         envir = ns)
[17:47:03.524]                       envir <- sys.frame(frame)
[17:47:03.524]                       master <- NULL
[17:47:03.524]                       while (!identical(envir, .GlobalEnv) && 
[17:47:03.524]                         !identical(envir, emptyenv())) {
[17:47:03.524]                         if (exists("master", mode = "list", envir = envir, 
[17:47:03.524]                           inherits = FALSE)) {
[17:47:03.524]                           master <- get("master", mode = "list", 
[17:47:03.524]                             envir = envir, inherits = FALSE)
[17:47:03.524]                           if (inherits(master, c("SOCKnode", 
[17:47:03.524]                             "SOCK0node"))) {
[17:47:03.524]                             sendCondition <<- function(cond) {
[17:47:03.524]                               data <- list(type = "VALUE", value = cond, 
[17:47:03.524]                                 success = TRUE)
[17:47:03.524]                               parallel_sendData(master, data)
[17:47:03.524]                             }
[17:47:03.524]                             return(sendCondition)
[17:47:03.524]                           }
[17:47:03.524]                         }
[17:47:03.524]                         frame <- frame + 1L
[17:47:03.524]                         envir <- sys.frame(frame)
[17:47:03.524]                       }
[17:47:03.524]                     }
[17:47:03.524]                     sendCondition <<- function(cond) NULL
[17:47:03.524]                   }
[17:47:03.524]                 })
[17:47:03.524]                 withCallingHandlers({
[17:47:03.524]                   {
[17:47:03.524]                     x$a <- 1
[17:47:03.524]                     x
[17:47:03.524]                   }
[17:47:03.524]                 }, immediateCondition = function(cond) {
[17:47:03.524]                   sendCondition <- ...future.makeSendCondition()
[17:47:03.524]                   sendCondition(cond)
[17:47:03.524]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.524]                   {
[17:47:03.524]                     inherits <- base::inherits
[17:47:03.524]                     invokeRestart <- base::invokeRestart
[17:47:03.524]                     is.null <- base::is.null
[17:47:03.524]                     muffled <- FALSE
[17:47:03.524]                     if (inherits(cond, "message")) {
[17:47:03.524]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:03.524]                       if (muffled) 
[17:47:03.524]                         invokeRestart("muffleMessage")
[17:47:03.524]                     }
[17:47:03.524]                     else if (inherits(cond, "warning")) {
[17:47:03.524]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:03.524]                       if (muffled) 
[17:47:03.524]                         invokeRestart("muffleWarning")
[17:47:03.524]                     }
[17:47:03.524]                     else if (inherits(cond, "condition")) {
[17:47:03.524]                       if (!is.null(pattern)) {
[17:47:03.524]                         computeRestarts <- base::computeRestarts
[17:47:03.524]                         grepl <- base::grepl
[17:47:03.524]                         restarts <- computeRestarts(cond)
[17:47:03.524]                         for (restart in restarts) {
[17:47:03.524]                           name <- restart$name
[17:47:03.524]                           if (is.null(name)) 
[17:47:03.524]                             next
[17:47:03.524]                           if (!grepl(pattern, name)) 
[17:47:03.524]                             next
[17:47:03.524]                           invokeRestart(restart)
[17:47:03.524]                           muffled <- TRUE
[17:47:03.524]                           break
[17:47:03.524]                         }
[17:47:03.524]                       }
[17:47:03.524]                     }
[17:47:03.524]                     invisible(muffled)
[17:47:03.524]                   }
[17:47:03.524]                   muffleCondition(cond)
[17:47:03.524]                 })
[17:47:03.524]             }))
[17:47:03.524]             future::FutureResult(value = ...future.value$value, 
[17:47:03.524]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.524]                   ...future.rng), globalenv = if (FALSE) 
[17:47:03.524]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:03.524]                     ...future.globalenv.names))
[17:47:03.524]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:03.524]         }, condition = base::local({
[17:47:03.524]             c <- base::c
[17:47:03.524]             inherits <- base::inherits
[17:47:03.524]             invokeRestart <- base::invokeRestart
[17:47:03.524]             length <- base::length
[17:47:03.524]             list <- base::list
[17:47:03.524]             seq.int <- base::seq.int
[17:47:03.524]             signalCondition <- base::signalCondition
[17:47:03.524]             sys.calls <- base::sys.calls
[17:47:03.524]             `[[` <- base::`[[`
[17:47:03.524]             `+` <- base::`+`
[17:47:03.524]             `<<-` <- base::`<<-`
[17:47:03.524]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:03.524]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:03.524]                   3L)]
[17:47:03.524]             }
[17:47:03.524]             function(cond) {
[17:47:03.524]                 is_error <- inherits(cond, "error")
[17:47:03.524]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:03.524]                   NULL)
[17:47:03.524]                 if (is_error) {
[17:47:03.524]                   sessionInformation <- function() {
[17:47:03.524]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:03.524]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:03.524]                       search = base::search(), system = base::Sys.info())
[17:47:03.524]                   }
[17:47:03.524]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.524]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:03.524]                     cond$call), session = sessionInformation(), 
[17:47:03.524]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:03.524]                   signalCondition(cond)
[17:47:03.524]                 }
[17:47:03.524]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:03.524]                 "immediateCondition"))) {
[17:47:03.524]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:03.524]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.524]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:03.524]                   if (TRUE && !signal) {
[17:47:03.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.524]                     {
[17:47:03.524]                       inherits <- base::inherits
[17:47:03.524]                       invokeRestart <- base::invokeRestart
[17:47:03.524]                       is.null <- base::is.null
[17:47:03.524]                       muffled <- FALSE
[17:47:03.524]                       if (inherits(cond, "message")) {
[17:47:03.524]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.524]                         if (muffled) 
[17:47:03.524]                           invokeRestart("muffleMessage")
[17:47:03.524]                       }
[17:47:03.524]                       else if (inherits(cond, "warning")) {
[17:47:03.524]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.524]                         if (muffled) 
[17:47:03.524]                           invokeRestart("muffleWarning")
[17:47:03.524]                       }
[17:47:03.524]                       else if (inherits(cond, "condition")) {
[17:47:03.524]                         if (!is.null(pattern)) {
[17:47:03.524]                           computeRestarts <- base::computeRestarts
[17:47:03.524]                           grepl <- base::grepl
[17:47:03.524]                           restarts <- computeRestarts(cond)
[17:47:03.524]                           for (restart in restarts) {
[17:47:03.524]                             name <- restart$name
[17:47:03.524]                             if (is.null(name)) 
[17:47:03.524]                               next
[17:47:03.524]                             if (!grepl(pattern, name)) 
[17:47:03.524]                               next
[17:47:03.524]                             invokeRestart(restart)
[17:47:03.524]                             muffled <- TRUE
[17:47:03.524]                             break
[17:47:03.524]                           }
[17:47:03.524]                         }
[17:47:03.524]                       }
[17:47:03.524]                       invisible(muffled)
[17:47:03.524]                     }
[17:47:03.524]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.524]                   }
[17:47:03.524]                 }
[17:47:03.524]                 else {
[17:47:03.524]                   if (TRUE) {
[17:47:03.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.524]                     {
[17:47:03.524]                       inherits <- base::inherits
[17:47:03.524]                       invokeRestart <- base::invokeRestart
[17:47:03.524]                       is.null <- base::is.null
[17:47:03.524]                       muffled <- FALSE
[17:47:03.524]                       if (inherits(cond, "message")) {
[17:47:03.524]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.524]                         if (muffled) 
[17:47:03.524]                           invokeRestart("muffleMessage")
[17:47:03.524]                       }
[17:47:03.524]                       else if (inherits(cond, "warning")) {
[17:47:03.524]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.524]                         if (muffled) 
[17:47:03.524]                           invokeRestart("muffleWarning")
[17:47:03.524]                       }
[17:47:03.524]                       else if (inherits(cond, "condition")) {
[17:47:03.524]                         if (!is.null(pattern)) {
[17:47:03.524]                           computeRestarts <- base::computeRestarts
[17:47:03.524]                           grepl <- base::grepl
[17:47:03.524]                           restarts <- computeRestarts(cond)
[17:47:03.524]                           for (restart in restarts) {
[17:47:03.524]                             name <- restart$name
[17:47:03.524]                             if (is.null(name)) 
[17:47:03.524]                               next
[17:47:03.524]                             if (!grepl(pattern, name)) 
[17:47:03.524]                               next
[17:47:03.524]                             invokeRestart(restart)
[17:47:03.524]                             muffled <- TRUE
[17:47:03.524]                             break
[17:47:03.524]                           }
[17:47:03.524]                         }
[17:47:03.524]                       }
[17:47:03.524]                       invisible(muffled)
[17:47:03.524]                     }
[17:47:03.524]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.524]                   }
[17:47:03.524]                 }
[17:47:03.524]             }
[17:47:03.524]         }))
[17:47:03.524]     }, error = function(ex) {
[17:47:03.524]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:03.524]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.524]                 ...future.rng), started = ...future.startTime, 
[17:47:03.524]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:03.524]             version = "1.8"), class = "FutureResult")
[17:47:03.524]     }, finally = {
[17:47:03.524]         if (!identical(...future.workdir, getwd())) 
[17:47:03.524]             setwd(...future.workdir)
[17:47:03.524]         {
[17:47:03.524]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:03.524]                 ...future.oldOptions$nwarnings <- NULL
[17:47:03.524]             }
[17:47:03.524]             base::options(...future.oldOptions)
[17:47:03.524]             if (.Platform$OS.type == "windows") {
[17:47:03.524]                 old_names <- names(...future.oldEnvVars)
[17:47:03.524]                 envs <- base::Sys.getenv()
[17:47:03.524]                 names <- names(envs)
[17:47:03.524]                 common <- intersect(names, old_names)
[17:47:03.524]                 added <- setdiff(names, old_names)
[17:47:03.524]                 removed <- setdiff(old_names, names)
[17:47:03.524]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:03.524]                   envs[common]]
[17:47:03.524]                 NAMES <- toupper(changed)
[17:47:03.524]                 args <- list()
[17:47:03.524]                 for (kk in seq_along(NAMES)) {
[17:47:03.524]                   name <- changed[[kk]]
[17:47:03.524]                   NAME <- NAMES[[kk]]
[17:47:03.524]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.524]                     next
[17:47:03.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.524]                 }
[17:47:03.524]                 NAMES <- toupper(added)
[17:47:03.524]                 for (kk in seq_along(NAMES)) {
[17:47:03.524]                   name <- added[[kk]]
[17:47:03.524]                   NAME <- NAMES[[kk]]
[17:47:03.524]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.524]                     next
[17:47:03.524]                   args[[name]] <- ""
[17:47:03.524]                 }
[17:47:03.524]                 NAMES <- toupper(removed)
[17:47:03.524]                 for (kk in seq_along(NAMES)) {
[17:47:03.524]                   name <- removed[[kk]]
[17:47:03.524]                   NAME <- NAMES[[kk]]
[17:47:03.524]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.524]                     next
[17:47:03.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.524]                 }
[17:47:03.524]                 if (length(args) > 0) 
[17:47:03.524]                   base::do.call(base::Sys.setenv, args = args)
[17:47:03.524]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:03.524]             }
[17:47:03.524]             else {
[17:47:03.524]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:03.524]             }
[17:47:03.524]             {
[17:47:03.524]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:03.524]                   0L) {
[17:47:03.524]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:03.524]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:03.524]                   base::options(opts)
[17:47:03.524]                 }
[17:47:03.524]                 {
[17:47:03.524]                   {
[17:47:03.524]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:03.524]                     NULL
[17:47:03.524]                   }
[17:47:03.524]                   options(future.plan = NULL)
[17:47:03.524]                   if (is.na(NA_character_)) 
[17:47:03.524]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.524]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:03.524]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:03.524]                     .init = FALSE)
[17:47:03.524]                 }
[17:47:03.524]             }
[17:47:03.524]         }
[17:47:03.524]     })
[17:47:03.524]     if (TRUE) {
[17:47:03.524]         base::sink(type = "output", split = FALSE)
[17:47:03.524]         if (TRUE) {
[17:47:03.524]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:03.524]         }
[17:47:03.524]         else {
[17:47:03.524]             ...future.result["stdout"] <- base::list(NULL)
[17:47:03.524]         }
[17:47:03.524]         base::close(...future.stdout)
[17:47:03.524]         ...future.stdout <- NULL
[17:47:03.524]     }
[17:47:03.524]     ...future.result$conditions <- ...future.conditions
[17:47:03.524]     ...future.result$finished <- base::Sys.time()
[17:47:03.524]     ...future.result
[17:47:03.524] }
[17:47:03.527] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:47:03.527] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:47:03.527] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:47:03.527] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:47:03.528] MultisessionFuture started
[17:47:03.528] - Launch lazy future ... done
[17:47:03.528] run() for ‘MultisessionFuture’ ... done
[17:47:03.528] result() for ClusterFuture ...
[17:47:03.529] receiveMessageFromWorker() for ClusterFuture ...
[17:47:03.529] - Validating connection of MultisessionFuture
[17:47:03.530] - received message: FutureResult
[17:47:03.530] - Received FutureResult
[17:47:03.530] - Erased future from FutureRegistry
[17:47:03.530] result() for ClusterFuture ...
[17:47:03.530] - result already collected: FutureResult
[17:47:03.530] result() for ClusterFuture ... done
[17:47:03.530] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:03.530] result() for ClusterFuture ... done
[17:47:03.531] result() for ClusterFuture ...
[17:47:03.531] - result already collected: FutureResult
[17:47:03.531] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:03.531] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:03.531] Searching for globals...
[17:47:03.533] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:03.533] Searching for globals ... DONE
[17:47:03.533] Resolving globals: TRUE
[17:47:03.534] Resolving any globals that are futures ...
[17:47:03.534] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:47:03.534] Resolving any globals that are futures ... DONE
[17:47:03.534] Resolving futures part of globals (recursively) ...
[17:47:03.534] resolve() on list ...
[17:47:03.534]  recursive: 99
[17:47:03.534]  length: 1
[17:47:03.535]  elements: ‘x’
[17:47:03.535]  length: 0 (resolved future 1)
[17:47:03.535] resolve() on list ... DONE
[17:47:03.535] - globals: [1] ‘x’
[17:47:03.535] Resolving futures part of globals (recursively) ... DONE
[17:47:03.535] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:03.535] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:03.536] - globals: [1] ‘x’
[17:47:03.536] 
[17:47:03.536] getGlobalsAndPackages() ... DONE
[17:47:03.536] run() for ‘Future’ ...
[17:47:03.536] - state: ‘created’
[17:47:03.536] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:03.549] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:03.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:03.550]   - Field: ‘node’
[17:47:03.550]   - Field: ‘label’
[17:47:03.550]   - Field: ‘local’
[17:47:03.550]   - Field: ‘owner’
[17:47:03.550]   - Field: ‘envir’
[17:47:03.550]   - Field: ‘workers’
[17:47:03.550]   - Field: ‘packages’
[17:47:03.550]   - Field: ‘gc’
[17:47:03.550]   - Field: ‘conditions’
[17:47:03.550]   - Field: ‘persistent’
[17:47:03.551]   - Field: ‘expr’
[17:47:03.551]   - Field: ‘uuid’
[17:47:03.551]   - Field: ‘seed’
[17:47:03.551]   - Field: ‘version’
[17:47:03.551]   - Field: ‘result’
[17:47:03.551]   - Field: ‘asynchronous’
[17:47:03.551]   - Field: ‘calls’
[17:47:03.551]   - Field: ‘globals’
[17:47:03.551]   - Field: ‘stdout’
[17:47:03.551]   - Field: ‘earlySignal’
[17:47:03.551]   - Field: ‘lazy’
[17:47:03.552]   - Field: ‘state’
[17:47:03.552] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:03.552] - Launch lazy future ...
[17:47:03.552] Packages needed by the future expression (n = 0): <none>
[17:47:03.552] Packages needed by future strategies (n = 0): <none>
[17:47:03.553] {
[17:47:03.553]     {
[17:47:03.553]         {
[17:47:03.553]             ...future.startTime <- base::Sys.time()
[17:47:03.553]             {
[17:47:03.553]                 {
[17:47:03.553]                   {
[17:47:03.553]                     {
[17:47:03.553]                       base::local({
[17:47:03.553]                         has_future <- base::requireNamespace("future", 
[17:47:03.553]                           quietly = TRUE)
[17:47:03.553]                         if (has_future) {
[17:47:03.553]                           ns <- base::getNamespace("future")
[17:47:03.553]                           version <- ns[[".package"]][["version"]]
[17:47:03.553]                           if (is.null(version)) 
[17:47:03.553]                             version <- utils::packageVersion("future")
[17:47:03.553]                         }
[17:47:03.553]                         else {
[17:47:03.553]                           version <- NULL
[17:47:03.553]                         }
[17:47:03.553]                         if (!has_future || version < "1.8.0") {
[17:47:03.553]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:03.553]                             "", base::R.version$version.string), 
[17:47:03.553]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:03.553]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:03.553]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:03.553]                               "release", "version")], collapse = " "), 
[17:47:03.553]                             hostname = base::Sys.info()[["nodename"]])
[17:47:03.553]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:03.553]                             info)
[17:47:03.553]                           info <- base::paste(info, collapse = "; ")
[17:47:03.553]                           if (!has_future) {
[17:47:03.553]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:03.553]                               info)
[17:47:03.553]                           }
[17:47:03.553]                           else {
[17:47:03.553]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:03.553]                               info, version)
[17:47:03.553]                           }
[17:47:03.553]                           base::stop(msg)
[17:47:03.553]                         }
[17:47:03.553]                       })
[17:47:03.553]                     }
[17:47:03.553]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:03.553]                     base::options(mc.cores = 1L)
[17:47:03.553]                   }
[17:47:03.553]                   ...future.strategy.old <- future::plan("list")
[17:47:03.553]                   options(future.plan = NULL)
[17:47:03.553]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.553]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:03.553]                 }
[17:47:03.553]                 ...future.workdir <- getwd()
[17:47:03.553]             }
[17:47:03.553]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:03.553]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:03.553]         }
[17:47:03.553]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:03.553]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:03.553]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:03.553]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:03.553]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:03.553]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:03.553]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:03.553]             base::names(...future.oldOptions))
[17:47:03.553]     }
[17:47:03.553]     if (FALSE) {
[17:47:03.553]     }
[17:47:03.553]     else {
[17:47:03.553]         if (TRUE) {
[17:47:03.553]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:03.553]                 open = "w")
[17:47:03.553]         }
[17:47:03.553]         else {
[17:47:03.553]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:03.553]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:03.553]         }
[17:47:03.553]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:03.553]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:03.553]             base::sink(type = "output", split = FALSE)
[17:47:03.553]             base::close(...future.stdout)
[17:47:03.553]         }, add = TRUE)
[17:47:03.553]     }
[17:47:03.553]     ...future.frame <- base::sys.nframe()
[17:47:03.553]     ...future.conditions <- base::list()
[17:47:03.553]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:03.553]     if (FALSE) {
[17:47:03.553]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:03.553]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:03.553]     }
[17:47:03.553]     ...future.result <- base::tryCatch({
[17:47:03.553]         base::withCallingHandlers({
[17:47:03.553]             ...future.value <- base::withVisible(base::local({
[17:47:03.553]                 ...future.makeSendCondition <- base::local({
[17:47:03.553]                   sendCondition <- NULL
[17:47:03.553]                   function(frame = 1L) {
[17:47:03.553]                     if (is.function(sendCondition)) 
[17:47:03.553]                       return(sendCondition)
[17:47:03.553]                     ns <- getNamespace("parallel")
[17:47:03.553]                     if (exists("sendData", mode = "function", 
[17:47:03.553]                       envir = ns)) {
[17:47:03.553]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:03.553]                         envir = ns)
[17:47:03.553]                       envir <- sys.frame(frame)
[17:47:03.553]                       master <- NULL
[17:47:03.553]                       while (!identical(envir, .GlobalEnv) && 
[17:47:03.553]                         !identical(envir, emptyenv())) {
[17:47:03.553]                         if (exists("master", mode = "list", envir = envir, 
[17:47:03.553]                           inherits = FALSE)) {
[17:47:03.553]                           master <- get("master", mode = "list", 
[17:47:03.553]                             envir = envir, inherits = FALSE)
[17:47:03.553]                           if (inherits(master, c("SOCKnode", 
[17:47:03.553]                             "SOCK0node"))) {
[17:47:03.553]                             sendCondition <<- function(cond) {
[17:47:03.553]                               data <- list(type = "VALUE", value = cond, 
[17:47:03.553]                                 success = TRUE)
[17:47:03.553]                               parallel_sendData(master, data)
[17:47:03.553]                             }
[17:47:03.553]                             return(sendCondition)
[17:47:03.553]                           }
[17:47:03.553]                         }
[17:47:03.553]                         frame <- frame + 1L
[17:47:03.553]                         envir <- sys.frame(frame)
[17:47:03.553]                       }
[17:47:03.553]                     }
[17:47:03.553]                     sendCondition <<- function(cond) NULL
[17:47:03.553]                   }
[17:47:03.553]                 })
[17:47:03.553]                 withCallingHandlers({
[17:47:03.553]                   {
[17:47:03.553]                     x$a <- 1
[17:47:03.553]                     x
[17:47:03.553]                   }
[17:47:03.553]                 }, immediateCondition = function(cond) {
[17:47:03.553]                   sendCondition <- ...future.makeSendCondition()
[17:47:03.553]                   sendCondition(cond)
[17:47:03.553]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.553]                   {
[17:47:03.553]                     inherits <- base::inherits
[17:47:03.553]                     invokeRestart <- base::invokeRestart
[17:47:03.553]                     is.null <- base::is.null
[17:47:03.553]                     muffled <- FALSE
[17:47:03.553]                     if (inherits(cond, "message")) {
[17:47:03.553]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:03.553]                       if (muffled) 
[17:47:03.553]                         invokeRestart("muffleMessage")
[17:47:03.553]                     }
[17:47:03.553]                     else if (inherits(cond, "warning")) {
[17:47:03.553]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:03.553]                       if (muffled) 
[17:47:03.553]                         invokeRestart("muffleWarning")
[17:47:03.553]                     }
[17:47:03.553]                     else if (inherits(cond, "condition")) {
[17:47:03.553]                       if (!is.null(pattern)) {
[17:47:03.553]                         computeRestarts <- base::computeRestarts
[17:47:03.553]                         grepl <- base::grepl
[17:47:03.553]                         restarts <- computeRestarts(cond)
[17:47:03.553]                         for (restart in restarts) {
[17:47:03.553]                           name <- restart$name
[17:47:03.553]                           if (is.null(name)) 
[17:47:03.553]                             next
[17:47:03.553]                           if (!grepl(pattern, name)) 
[17:47:03.553]                             next
[17:47:03.553]                           invokeRestart(restart)
[17:47:03.553]                           muffled <- TRUE
[17:47:03.553]                           break
[17:47:03.553]                         }
[17:47:03.553]                       }
[17:47:03.553]                     }
[17:47:03.553]                     invisible(muffled)
[17:47:03.553]                   }
[17:47:03.553]                   muffleCondition(cond)
[17:47:03.553]                 })
[17:47:03.553]             }))
[17:47:03.553]             future::FutureResult(value = ...future.value$value, 
[17:47:03.553]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.553]                   ...future.rng), globalenv = if (FALSE) 
[17:47:03.553]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:03.553]                     ...future.globalenv.names))
[17:47:03.553]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:03.553]         }, condition = base::local({
[17:47:03.553]             c <- base::c
[17:47:03.553]             inherits <- base::inherits
[17:47:03.553]             invokeRestart <- base::invokeRestart
[17:47:03.553]             length <- base::length
[17:47:03.553]             list <- base::list
[17:47:03.553]             seq.int <- base::seq.int
[17:47:03.553]             signalCondition <- base::signalCondition
[17:47:03.553]             sys.calls <- base::sys.calls
[17:47:03.553]             `[[` <- base::`[[`
[17:47:03.553]             `+` <- base::`+`
[17:47:03.553]             `<<-` <- base::`<<-`
[17:47:03.553]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:03.553]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:03.553]                   3L)]
[17:47:03.553]             }
[17:47:03.553]             function(cond) {
[17:47:03.553]                 is_error <- inherits(cond, "error")
[17:47:03.553]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:03.553]                   NULL)
[17:47:03.553]                 if (is_error) {
[17:47:03.553]                   sessionInformation <- function() {
[17:47:03.553]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:03.553]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:03.553]                       search = base::search(), system = base::Sys.info())
[17:47:03.553]                   }
[17:47:03.553]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.553]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:03.553]                     cond$call), session = sessionInformation(), 
[17:47:03.553]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:03.553]                   signalCondition(cond)
[17:47:03.553]                 }
[17:47:03.553]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:03.553]                 "immediateCondition"))) {
[17:47:03.553]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:03.553]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.553]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:03.553]                   if (TRUE && !signal) {
[17:47:03.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.553]                     {
[17:47:03.553]                       inherits <- base::inherits
[17:47:03.553]                       invokeRestart <- base::invokeRestart
[17:47:03.553]                       is.null <- base::is.null
[17:47:03.553]                       muffled <- FALSE
[17:47:03.553]                       if (inherits(cond, "message")) {
[17:47:03.553]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.553]                         if (muffled) 
[17:47:03.553]                           invokeRestart("muffleMessage")
[17:47:03.553]                       }
[17:47:03.553]                       else if (inherits(cond, "warning")) {
[17:47:03.553]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.553]                         if (muffled) 
[17:47:03.553]                           invokeRestart("muffleWarning")
[17:47:03.553]                       }
[17:47:03.553]                       else if (inherits(cond, "condition")) {
[17:47:03.553]                         if (!is.null(pattern)) {
[17:47:03.553]                           computeRestarts <- base::computeRestarts
[17:47:03.553]                           grepl <- base::grepl
[17:47:03.553]                           restarts <- computeRestarts(cond)
[17:47:03.553]                           for (restart in restarts) {
[17:47:03.553]                             name <- restart$name
[17:47:03.553]                             if (is.null(name)) 
[17:47:03.553]                               next
[17:47:03.553]                             if (!grepl(pattern, name)) 
[17:47:03.553]                               next
[17:47:03.553]                             invokeRestart(restart)
[17:47:03.553]                             muffled <- TRUE
[17:47:03.553]                             break
[17:47:03.553]                           }
[17:47:03.553]                         }
[17:47:03.553]                       }
[17:47:03.553]                       invisible(muffled)
[17:47:03.553]                     }
[17:47:03.553]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.553]                   }
[17:47:03.553]                 }
[17:47:03.553]                 else {
[17:47:03.553]                   if (TRUE) {
[17:47:03.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.553]                     {
[17:47:03.553]                       inherits <- base::inherits
[17:47:03.553]                       invokeRestart <- base::invokeRestart
[17:47:03.553]                       is.null <- base::is.null
[17:47:03.553]                       muffled <- FALSE
[17:47:03.553]                       if (inherits(cond, "message")) {
[17:47:03.553]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.553]                         if (muffled) 
[17:47:03.553]                           invokeRestart("muffleMessage")
[17:47:03.553]                       }
[17:47:03.553]                       else if (inherits(cond, "warning")) {
[17:47:03.553]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.553]                         if (muffled) 
[17:47:03.553]                           invokeRestart("muffleWarning")
[17:47:03.553]                       }
[17:47:03.553]                       else if (inherits(cond, "condition")) {
[17:47:03.553]                         if (!is.null(pattern)) {
[17:47:03.553]                           computeRestarts <- base::computeRestarts
[17:47:03.553]                           grepl <- base::grepl
[17:47:03.553]                           restarts <- computeRestarts(cond)
[17:47:03.553]                           for (restart in restarts) {
[17:47:03.553]                             name <- restart$name
[17:47:03.553]                             if (is.null(name)) 
[17:47:03.553]                               next
[17:47:03.553]                             if (!grepl(pattern, name)) 
[17:47:03.553]                               next
[17:47:03.553]                             invokeRestart(restart)
[17:47:03.553]                             muffled <- TRUE
[17:47:03.553]                             break
[17:47:03.553]                           }
[17:47:03.553]                         }
[17:47:03.553]                       }
[17:47:03.553]                       invisible(muffled)
[17:47:03.553]                     }
[17:47:03.553]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.553]                   }
[17:47:03.553]                 }
[17:47:03.553]             }
[17:47:03.553]         }))
[17:47:03.553]     }, error = function(ex) {
[17:47:03.553]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:03.553]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.553]                 ...future.rng), started = ...future.startTime, 
[17:47:03.553]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:03.553]             version = "1.8"), class = "FutureResult")
[17:47:03.553]     }, finally = {
[17:47:03.553]         if (!identical(...future.workdir, getwd())) 
[17:47:03.553]             setwd(...future.workdir)
[17:47:03.553]         {
[17:47:03.553]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:03.553]                 ...future.oldOptions$nwarnings <- NULL
[17:47:03.553]             }
[17:47:03.553]             base::options(...future.oldOptions)
[17:47:03.553]             if (.Platform$OS.type == "windows") {
[17:47:03.553]                 old_names <- names(...future.oldEnvVars)
[17:47:03.553]                 envs <- base::Sys.getenv()
[17:47:03.553]                 names <- names(envs)
[17:47:03.553]                 common <- intersect(names, old_names)
[17:47:03.553]                 added <- setdiff(names, old_names)
[17:47:03.553]                 removed <- setdiff(old_names, names)
[17:47:03.553]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:03.553]                   envs[common]]
[17:47:03.553]                 NAMES <- toupper(changed)
[17:47:03.553]                 args <- list()
[17:47:03.553]                 for (kk in seq_along(NAMES)) {
[17:47:03.553]                   name <- changed[[kk]]
[17:47:03.553]                   NAME <- NAMES[[kk]]
[17:47:03.553]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.553]                     next
[17:47:03.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.553]                 }
[17:47:03.553]                 NAMES <- toupper(added)
[17:47:03.553]                 for (kk in seq_along(NAMES)) {
[17:47:03.553]                   name <- added[[kk]]
[17:47:03.553]                   NAME <- NAMES[[kk]]
[17:47:03.553]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.553]                     next
[17:47:03.553]                   args[[name]] <- ""
[17:47:03.553]                 }
[17:47:03.553]                 NAMES <- toupper(removed)
[17:47:03.553]                 for (kk in seq_along(NAMES)) {
[17:47:03.553]                   name <- removed[[kk]]
[17:47:03.553]                   NAME <- NAMES[[kk]]
[17:47:03.553]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.553]                     next
[17:47:03.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.553]                 }
[17:47:03.553]                 if (length(args) > 0) 
[17:47:03.553]                   base::do.call(base::Sys.setenv, args = args)
[17:47:03.553]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:03.553]             }
[17:47:03.553]             else {
[17:47:03.553]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:03.553]             }
[17:47:03.553]             {
[17:47:03.553]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:03.553]                   0L) {
[17:47:03.553]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:03.553]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:03.553]                   base::options(opts)
[17:47:03.553]                 }
[17:47:03.553]                 {
[17:47:03.553]                   {
[17:47:03.553]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:03.553]                     NULL
[17:47:03.553]                   }
[17:47:03.553]                   options(future.plan = NULL)
[17:47:03.553]                   if (is.na(NA_character_)) 
[17:47:03.553]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.553]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:03.553]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:03.553]                     .init = FALSE)
[17:47:03.553]                 }
[17:47:03.553]             }
[17:47:03.553]         }
[17:47:03.553]     })
[17:47:03.553]     if (TRUE) {
[17:47:03.553]         base::sink(type = "output", split = FALSE)
[17:47:03.553]         if (TRUE) {
[17:47:03.553]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:03.553]         }
[17:47:03.553]         else {
[17:47:03.553]             ...future.result["stdout"] <- base::list(NULL)
[17:47:03.553]         }
[17:47:03.553]         base::close(...future.stdout)
[17:47:03.553]         ...future.stdout <- NULL
[17:47:03.553]     }
[17:47:03.553]     ...future.result$conditions <- ...future.conditions
[17:47:03.553]     ...future.result$finished <- base::Sys.time()
[17:47:03.553]     ...future.result
[17:47:03.553] }
[17:47:03.555] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:47:03.555] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:47:03.556] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:47:03.556] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:47:03.557] MultisessionFuture started
[17:47:03.557] - Launch lazy future ... done
[17:47:03.557] run() for ‘MultisessionFuture’ ... done
[17:47:03.557] result() for ClusterFuture ...
[17:47:03.557] receiveMessageFromWorker() for ClusterFuture ...
[17:47:03.557] - Validating connection of MultisessionFuture
[17:47:03.558] - received message: FutureResult
[17:47:03.559] - Received FutureResult
[17:47:03.559] - Erased future from FutureRegistry
[17:47:03.559] result() for ClusterFuture ...
[17:47:03.559] - result already collected: FutureResult
[17:47:03.559] result() for ClusterFuture ... done
[17:47:03.559] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:03.559] result() for ClusterFuture ... done
[17:47:03.559] result() for ClusterFuture ...
[17:47:03.559] - result already collected: FutureResult
[17:47:03.560] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:03.560] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:03.560] Searching for globals...
[17:47:03.563] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:47:03.563] Searching for globals ... DONE
[17:47:03.563] Resolving globals: TRUE
[17:47:03.563] Resolving any globals that are futures ...
[17:47:03.563] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:47:03.563] Resolving any globals that are futures ... DONE
[17:47:03.563] 
[17:47:03.564] 
[17:47:03.564] getGlobalsAndPackages() ... DONE
[17:47:03.564] run() for ‘Future’ ...
[17:47:03.564] - state: ‘created’
[17:47:03.564] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:03.580] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:03.580] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:03.580]   - Field: ‘node’
[17:47:03.580]   - Field: ‘label’
[17:47:03.580]   - Field: ‘local’
[17:47:03.580]   - Field: ‘owner’
[17:47:03.580]   - Field: ‘envir’
[17:47:03.580]   - Field: ‘workers’
[17:47:03.581]   - Field: ‘packages’
[17:47:03.581]   - Field: ‘gc’
[17:47:03.581]   - Field: ‘conditions’
[17:47:03.581]   - Field: ‘persistent’
[17:47:03.581]   - Field: ‘expr’
[17:47:03.581]   - Field: ‘uuid’
[17:47:03.581]   - Field: ‘seed’
[17:47:03.581]   - Field: ‘version’
[17:47:03.581]   - Field: ‘result’
[17:47:03.581]   - Field: ‘asynchronous’
[17:47:03.581]   - Field: ‘calls’
[17:47:03.582]   - Field: ‘globals’
[17:47:03.582]   - Field: ‘stdout’
[17:47:03.582]   - Field: ‘earlySignal’
[17:47:03.582]   - Field: ‘lazy’
[17:47:03.582]   - Field: ‘state’
[17:47:03.582] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:03.582] - Launch lazy future ...
[17:47:03.582] Packages needed by the future expression (n = 0): <none>
[17:47:03.582] Packages needed by future strategies (n = 0): <none>
[17:47:03.583] {
[17:47:03.583]     {
[17:47:03.583]         {
[17:47:03.583]             ...future.startTime <- base::Sys.time()
[17:47:03.583]             {
[17:47:03.583]                 {
[17:47:03.583]                   {
[17:47:03.583]                     {
[17:47:03.583]                       base::local({
[17:47:03.583]                         has_future <- base::requireNamespace("future", 
[17:47:03.583]                           quietly = TRUE)
[17:47:03.583]                         if (has_future) {
[17:47:03.583]                           ns <- base::getNamespace("future")
[17:47:03.583]                           version <- ns[[".package"]][["version"]]
[17:47:03.583]                           if (is.null(version)) 
[17:47:03.583]                             version <- utils::packageVersion("future")
[17:47:03.583]                         }
[17:47:03.583]                         else {
[17:47:03.583]                           version <- NULL
[17:47:03.583]                         }
[17:47:03.583]                         if (!has_future || version < "1.8.0") {
[17:47:03.583]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:03.583]                             "", base::R.version$version.string), 
[17:47:03.583]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:03.583]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:03.583]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:03.583]                               "release", "version")], collapse = " "), 
[17:47:03.583]                             hostname = base::Sys.info()[["nodename"]])
[17:47:03.583]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:03.583]                             info)
[17:47:03.583]                           info <- base::paste(info, collapse = "; ")
[17:47:03.583]                           if (!has_future) {
[17:47:03.583]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:03.583]                               info)
[17:47:03.583]                           }
[17:47:03.583]                           else {
[17:47:03.583]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:03.583]                               info, version)
[17:47:03.583]                           }
[17:47:03.583]                           base::stop(msg)
[17:47:03.583]                         }
[17:47:03.583]                       })
[17:47:03.583]                     }
[17:47:03.583]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:03.583]                     base::options(mc.cores = 1L)
[17:47:03.583]                   }
[17:47:03.583]                   ...future.strategy.old <- future::plan("list")
[17:47:03.583]                   options(future.plan = NULL)
[17:47:03.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:03.583]                 }
[17:47:03.583]                 ...future.workdir <- getwd()
[17:47:03.583]             }
[17:47:03.583]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:03.583]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:03.583]         }
[17:47:03.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:03.583]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:03.583]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:03.583]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:03.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:03.583]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:03.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:03.583]             base::names(...future.oldOptions))
[17:47:03.583]     }
[17:47:03.583]     if (FALSE) {
[17:47:03.583]     }
[17:47:03.583]     else {
[17:47:03.583]         if (TRUE) {
[17:47:03.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:03.583]                 open = "w")
[17:47:03.583]         }
[17:47:03.583]         else {
[17:47:03.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:03.583]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:03.583]         }
[17:47:03.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:03.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:03.583]             base::sink(type = "output", split = FALSE)
[17:47:03.583]             base::close(...future.stdout)
[17:47:03.583]         }, add = TRUE)
[17:47:03.583]     }
[17:47:03.583]     ...future.frame <- base::sys.nframe()
[17:47:03.583]     ...future.conditions <- base::list()
[17:47:03.583]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:03.583]     if (FALSE) {
[17:47:03.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:03.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:03.583]     }
[17:47:03.583]     ...future.result <- base::tryCatch({
[17:47:03.583]         base::withCallingHandlers({
[17:47:03.583]             ...future.value <- base::withVisible(base::local({
[17:47:03.583]                 ...future.makeSendCondition <- base::local({
[17:47:03.583]                   sendCondition <- NULL
[17:47:03.583]                   function(frame = 1L) {
[17:47:03.583]                     if (is.function(sendCondition)) 
[17:47:03.583]                       return(sendCondition)
[17:47:03.583]                     ns <- getNamespace("parallel")
[17:47:03.583]                     if (exists("sendData", mode = "function", 
[17:47:03.583]                       envir = ns)) {
[17:47:03.583]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:03.583]                         envir = ns)
[17:47:03.583]                       envir <- sys.frame(frame)
[17:47:03.583]                       master <- NULL
[17:47:03.583]                       while (!identical(envir, .GlobalEnv) && 
[17:47:03.583]                         !identical(envir, emptyenv())) {
[17:47:03.583]                         if (exists("master", mode = "list", envir = envir, 
[17:47:03.583]                           inherits = FALSE)) {
[17:47:03.583]                           master <- get("master", mode = "list", 
[17:47:03.583]                             envir = envir, inherits = FALSE)
[17:47:03.583]                           if (inherits(master, c("SOCKnode", 
[17:47:03.583]                             "SOCK0node"))) {
[17:47:03.583]                             sendCondition <<- function(cond) {
[17:47:03.583]                               data <- list(type = "VALUE", value = cond, 
[17:47:03.583]                                 success = TRUE)
[17:47:03.583]                               parallel_sendData(master, data)
[17:47:03.583]                             }
[17:47:03.583]                             return(sendCondition)
[17:47:03.583]                           }
[17:47:03.583]                         }
[17:47:03.583]                         frame <- frame + 1L
[17:47:03.583]                         envir <- sys.frame(frame)
[17:47:03.583]                       }
[17:47:03.583]                     }
[17:47:03.583]                     sendCondition <<- function(cond) NULL
[17:47:03.583]                   }
[17:47:03.583]                 })
[17:47:03.583]                 withCallingHandlers({
[17:47:03.583]                   {
[17:47:03.583]                     x <- list(b = 2)
[17:47:03.583]                     x$a <- 1
[17:47:03.583]                     x
[17:47:03.583]                   }
[17:47:03.583]                 }, immediateCondition = function(cond) {
[17:47:03.583]                   sendCondition <- ...future.makeSendCondition()
[17:47:03.583]                   sendCondition(cond)
[17:47:03.583]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.583]                   {
[17:47:03.583]                     inherits <- base::inherits
[17:47:03.583]                     invokeRestart <- base::invokeRestart
[17:47:03.583]                     is.null <- base::is.null
[17:47:03.583]                     muffled <- FALSE
[17:47:03.583]                     if (inherits(cond, "message")) {
[17:47:03.583]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:03.583]                       if (muffled) 
[17:47:03.583]                         invokeRestart("muffleMessage")
[17:47:03.583]                     }
[17:47:03.583]                     else if (inherits(cond, "warning")) {
[17:47:03.583]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:03.583]                       if (muffled) 
[17:47:03.583]                         invokeRestart("muffleWarning")
[17:47:03.583]                     }
[17:47:03.583]                     else if (inherits(cond, "condition")) {
[17:47:03.583]                       if (!is.null(pattern)) {
[17:47:03.583]                         computeRestarts <- base::computeRestarts
[17:47:03.583]                         grepl <- base::grepl
[17:47:03.583]                         restarts <- computeRestarts(cond)
[17:47:03.583]                         for (restart in restarts) {
[17:47:03.583]                           name <- restart$name
[17:47:03.583]                           if (is.null(name)) 
[17:47:03.583]                             next
[17:47:03.583]                           if (!grepl(pattern, name)) 
[17:47:03.583]                             next
[17:47:03.583]                           invokeRestart(restart)
[17:47:03.583]                           muffled <- TRUE
[17:47:03.583]                           break
[17:47:03.583]                         }
[17:47:03.583]                       }
[17:47:03.583]                     }
[17:47:03.583]                     invisible(muffled)
[17:47:03.583]                   }
[17:47:03.583]                   muffleCondition(cond)
[17:47:03.583]                 })
[17:47:03.583]             }))
[17:47:03.583]             future::FutureResult(value = ...future.value$value, 
[17:47:03.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.583]                   ...future.rng), globalenv = if (FALSE) 
[17:47:03.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:03.583]                     ...future.globalenv.names))
[17:47:03.583]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:03.583]         }, condition = base::local({
[17:47:03.583]             c <- base::c
[17:47:03.583]             inherits <- base::inherits
[17:47:03.583]             invokeRestart <- base::invokeRestart
[17:47:03.583]             length <- base::length
[17:47:03.583]             list <- base::list
[17:47:03.583]             seq.int <- base::seq.int
[17:47:03.583]             signalCondition <- base::signalCondition
[17:47:03.583]             sys.calls <- base::sys.calls
[17:47:03.583]             `[[` <- base::`[[`
[17:47:03.583]             `+` <- base::`+`
[17:47:03.583]             `<<-` <- base::`<<-`
[17:47:03.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:03.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:03.583]                   3L)]
[17:47:03.583]             }
[17:47:03.583]             function(cond) {
[17:47:03.583]                 is_error <- inherits(cond, "error")
[17:47:03.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:03.583]                   NULL)
[17:47:03.583]                 if (is_error) {
[17:47:03.583]                   sessionInformation <- function() {
[17:47:03.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:03.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:03.583]                       search = base::search(), system = base::Sys.info())
[17:47:03.583]                   }
[17:47:03.583]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:03.583]                     cond$call), session = sessionInformation(), 
[17:47:03.583]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:03.583]                   signalCondition(cond)
[17:47:03.583]                 }
[17:47:03.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:03.583]                 "immediateCondition"))) {
[17:47:03.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:03.583]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:03.583]                   if (TRUE && !signal) {
[17:47:03.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.583]                     {
[17:47:03.583]                       inherits <- base::inherits
[17:47:03.583]                       invokeRestart <- base::invokeRestart
[17:47:03.583]                       is.null <- base::is.null
[17:47:03.583]                       muffled <- FALSE
[17:47:03.583]                       if (inherits(cond, "message")) {
[17:47:03.583]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.583]                         if (muffled) 
[17:47:03.583]                           invokeRestart("muffleMessage")
[17:47:03.583]                       }
[17:47:03.583]                       else if (inherits(cond, "warning")) {
[17:47:03.583]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.583]                         if (muffled) 
[17:47:03.583]                           invokeRestart("muffleWarning")
[17:47:03.583]                       }
[17:47:03.583]                       else if (inherits(cond, "condition")) {
[17:47:03.583]                         if (!is.null(pattern)) {
[17:47:03.583]                           computeRestarts <- base::computeRestarts
[17:47:03.583]                           grepl <- base::grepl
[17:47:03.583]                           restarts <- computeRestarts(cond)
[17:47:03.583]                           for (restart in restarts) {
[17:47:03.583]                             name <- restart$name
[17:47:03.583]                             if (is.null(name)) 
[17:47:03.583]                               next
[17:47:03.583]                             if (!grepl(pattern, name)) 
[17:47:03.583]                               next
[17:47:03.583]                             invokeRestart(restart)
[17:47:03.583]                             muffled <- TRUE
[17:47:03.583]                             break
[17:47:03.583]                           }
[17:47:03.583]                         }
[17:47:03.583]                       }
[17:47:03.583]                       invisible(muffled)
[17:47:03.583]                     }
[17:47:03.583]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.583]                   }
[17:47:03.583]                 }
[17:47:03.583]                 else {
[17:47:03.583]                   if (TRUE) {
[17:47:03.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.583]                     {
[17:47:03.583]                       inherits <- base::inherits
[17:47:03.583]                       invokeRestart <- base::invokeRestart
[17:47:03.583]                       is.null <- base::is.null
[17:47:03.583]                       muffled <- FALSE
[17:47:03.583]                       if (inherits(cond, "message")) {
[17:47:03.583]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.583]                         if (muffled) 
[17:47:03.583]                           invokeRestart("muffleMessage")
[17:47:03.583]                       }
[17:47:03.583]                       else if (inherits(cond, "warning")) {
[17:47:03.583]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.583]                         if (muffled) 
[17:47:03.583]                           invokeRestart("muffleWarning")
[17:47:03.583]                       }
[17:47:03.583]                       else if (inherits(cond, "condition")) {
[17:47:03.583]                         if (!is.null(pattern)) {
[17:47:03.583]                           computeRestarts <- base::computeRestarts
[17:47:03.583]                           grepl <- base::grepl
[17:47:03.583]                           restarts <- computeRestarts(cond)
[17:47:03.583]                           for (restart in restarts) {
[17:47:03.583]                             name <- restart$name
[17:47:03.583]                             if (is.null(name)) 
[17:47:03.583]                               next
[17:47:03.583]                             if (!grepl(pattern, name)) 
[17:47:03.583]                               next
[17:47:03.583]                             invokeRestart(restart)
[17:47:03.583]                             muffled <- TRUE
[17:47:03.583]                             break
[17:47:03.583]                           }
[17:47:03.583]                         }
[17:47:03.583]                       }
[17:47:03.583]                       invisible(muffled)
[17:47:03.583]                     }
[17:47:03.583]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.583]                   }
[17:47:03.583]                 }
[17:47:03.583]             }
[17:47:03.583]         }))
[17:47:03.583]     }, error = function(ex) {
[17:47:03.583]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:03.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.583]                 ...future.rng), started = ...future.startTime, 
[17:47:03.583]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:03.583]             version = "1.8"), class = "FutureResult")
[17:47:03.583]     }, finally = {
[17:47:03.583]         if (!identical(...future.workdir, getwd())) 
[17:47:03.583]             setwd(...future.workdir)
[17:47:03.583]         {
[17:47:03.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:03.583]                 ...future.oldOptions$nwarnings <- NULL
[17:47:03.583]             }
[17:47:03.583]             base::options(...future.oldOptions)
[17:47:03.583]             if (.Platform$OS.type == "windows") {
[17:47:03.583]                 old_names <- names(...future.oldEnvVars)
[17:47:03.583]                 envs <- base::Sys.getenv()
[17:47:03.583]                 names <- names(envs)
[17:47:03.583]                 common <- intersect(names, old_names)
[17:47:03.583]                 added <- setdiff(names, old_names)
[17:47:03.583]                 removed <- setdiff(old_names, names)
[17:47:03.583]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:03.583]                   envs[common]]
[17:47:03.583]                 NAMES <- toupper(changed)
[17:47:03.583]                 args <- list()
[17:47:03.583]                 for (kk in seq_along(NAMES)) {
[17:47:03.583]                   name <- changed[[kk]]
[17:47:03.583]                   NAME <- NAMES[[kk]]
[17:47:03.583]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.583]                     next
[17:47:03.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.583]                 }
[17:47:03.583]                 NAMES <- toupper(added)
[17:47:03.583]                 for (kk in seq_along(NAMES)) {
[17:47:03.583]                   name <- added[[kk]]
[17:47:03.583]                   NAME <- NAMES[[kk]]
[17:47:03.583]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.583]                     next
[17:47:03.583]                   args[[name]] <- ""
[17:47:03.583]                 }
[17:47:03.583]                 NAMES <- toupper(removed)
[17:47:03.583]                 for (kk in seq_along(NAMES)) {
[17:47:03.583]                   name <- removed[[kk]]
[17:47:03.583]                   NAME <- NAMES[[kk]]
[17:47:03.583]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.583]                     next
[17:47:03.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.583]                 }
[17:47:03.583]                 if (length(args) > 0) 
[17:47:03.583]                   base::do.call(base::Sys.setenv, args = args)
[17:47:03.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:03.583]             }
[17:47:03.583]             else {
[17:47:03.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:03.583]             }
[17:47:03.583]             {
[17:47:03.583]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:03.583]                   0L) {
[17:47:03.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:03.583]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:03.583]                   base::options(opts)
[17:47:03.583]                 }
[17:47:03.583]                 {
[17:47:03.583]                   {
[17:47:03.583]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:03.583]                     NULL
[17:47:03.583]                   }
[17:47:03.583]                   options(future.plan = NULL)
[17:47:03.583]                   if (is.na(NA_character_)) 
[17:47:03.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:03.583]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:03.583]                     .init = FALSE)
[17:47:03.583]                 }
[17:47:03.583]             }
[17:47:03.583]         }
[17:47:03.583]     })
[17:47:03.583]     if (TRUE) {
[17:47:03.583]         base::sink(type = "output", split = FALSE)
[17:47:03.583]         if (TRUE) {
[17:47:03.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:03.583]         }
[17:47:03.583]         else {
[17:47:03.583]             ...future.result["stdout"] <- base::list(NULL)
[17:47:03.583]         }
[17:47:03.583]         base::close(...future.stdout)
[17:47:03.583]         ...future.stdout <- NULL
[17:47:03.583]     }
[17:47:03.583]     ...future.result$conditions <- ...future.conditions
[17:47:03.583]     ...future.result$finished <- base::Sys.time()
[17:47:03.583]     ...future.result
[17:47:03.583] }
[17:47:03.586] MultisessionFuture started
[17:47:03.586] - Launch lazy future ... done
[17:47:03.586] run() for ‘MultisessionFuture’ ... done
[17:47:03.586] result() for ClusterFuture ...
[17:47:03.586] receiveMessageFromWorker() for ClusterFuture ...
[17:47:03.587] - Validating connection of MultisessionFuture
[17:47:03.588] - received message: FutureResult
[17:47:03.588] - Received FutureResult
[17:47:03.588] - Erased future from FutureRegistry
[17:47:03.588] result() for ClusterFuture ...
[17:47:03.588] - result already collected: FutureResult
[17:47:03.588] result() for ClusterFuture ... done
[17:47:03.588] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:03.588] result() for ClusterFuture ... done
[17:47:03.589] result() for ClusterFuture ...
[17:47:03.589] - result already collected: FutureResult
[17:47:03.589] result() for ClusterFuture ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:03.589] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:03.589] Searching for globals...
[17:47:03.591] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:03.591] Searching for globals ... DONE
[17:47:03.591] Resolving globals: TRUE
[17:47:03.591] Resolving any globals that are futures ...
[17:47:03.592] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:03.592] Resolving any globals that are futures ... DONE
[17:47:03.592] Resolving futures part of globals (recursively) ...
[17:47:03.592] resolve() on list ...
[17:47:03.592]  recursive: 99
[17:47:03.592]  length: 1
[17:47:03.592]  elements: ‘x’
[17:47:03.593]  length: 0 (resolved future 1)
[17:47:03.593] resolve() on list ... DONE
[17:47:03.593] - globals: [1] ‘x’
[17:47:03.593] Resolving futures part of globals (recursively) ... DONE
[17:47:03.593] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:03.593] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:03.593] - globals: [1] ‘x’
[17:47:03.594] 
[17:47:03.594] getGlobalsAndPackages() ... DONE
[17:47:03.594] run() for ‘Future’ ...
[17:47:03.594] - state: ‘created’
[17:47:03.594] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:03.607] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:03.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:03.608]   - Field: ‘node’
[17:47:03.608]   - Field: ‘label’
[17:47:03.608]   - Field: ‘local’
[17:47:03.608]   - Field: ‘owner’
[17:47:03.608]   - Field: ‘envir’
[17:47:03.608]   - Field: ‘workers’
[17:47:03.608]   - Field: ‘packages’
[17:47:03.608]   - Field: ‘gc’
[17:47:03.608]   - Field: ‘conditions’
[17:47:03.609]   - Field: ‘persistent’
[17:47:03.609]   - Field: ‘expr’
[17:47:03.609]   - Field: ‘uuid’
[17:47:03.609]   - Field: ‘seed’
[17:47:03.609]   - Field: ‘version’
[17:47:03.609]   - Field: ‘result’
[17:47:03.609]   - Field: ‘asynchronous’
[17:47:03.609]   - Field: ‘calls’
[17:47:03.609]   - Field: ‘globals’
[17:47:03.609]   - Field: ‘stdout’
[17:47:03.609]   - Field: ‘earlySignal’
[17:47:03.610]   - Field: ‘lazy’
[17:47:03.610]   - Field: ‘state’
[17:47:03.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:03.610] - Launch lazy future ...
[17:47:03.610] Packages needed by the future expression (n = 0): <none>
[17:47:03.610] Packages needed by future strategies (n = 0): <none>
[17:47:03.611] {
[17:47:03.611]     {
[17:47:03.611]         {
[17:47:03.611]             ...future.startTime <- base::Sys.time()
[17:47:03.611]             {
[17:47:03.611]                 {
[17:47:03.611]                   {
[17:47:03.611]                     {
[17:47:03.611]                       base::local({
[17:47:03.611]                         has_future <- base::requireNamespace("future", 
[17:47:03.611]                           quietly = TRUE)
[17:47:03.611]                         if (has_future) {
[17:47:03.611]                           ns <- base::getNamespace("future")
[17:47:03.611]                           version <- ns[[".package"]][["version"]]
[17:47:03.611]                           if (is.null(version)) 
[17:47:03.611]                             version <- utils::packageVersion("future")
[17:47:03.611]                         }
[17:47:03.611]                         else {
[17:47:03.611]                           version <- NULL
[17:47:03.611]                         }
[17:47:03.611]                         if (!has_future || version < "1.8.0") {
[17:47:03.611]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:03.611]                             "", base::R.version$version.string), 
[17:47:03.611]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:03.611]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:03.611]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:03.611]                               "release", "version")], collapse = " "), 
[17:47:03.611]                             hostname = base::Sys.info()[["nodename"]])
[17:47:03.611]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:03.611]                             info)
[17:47:03.611]                           info <- base::paste(info, collapse = "; ")
[17:47:03.611]                           if (!has_future) {
[17:47:03.611]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:03.611]                               info)
[17:47:03.611]                           }
[17:47:03.611]                           else {
[17:47:03.611]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:03.611]                               info, version)
[17:47:03.611]                           }
[17:47:03.611]                           base::stop(msg)
[17:47:03.611]                         }
[17:47:03.611]                       })
[17:47:03.611]                     }
[17:47:03.611]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:03.611]                     base::options(mc.cores = 1L)
[17:47:03.611]                   }
[17:47:03.611]                   ...future.strategy.old <- future::plan("list")
[17:47:03.611]                   options(future.plan = NULL)
[17:47:03.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:03.611]                 }
[17:47:03.611]                 ...future.workdir <- getwd()
[17:47:03.611]             }
[17:47:03.611]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:03.611]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:03.611]         }
[17:47:03.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:03.611]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:03.611]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:03.611]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:03.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:03.611]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:03.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:03.611]             base::names(...future.oldOptions))
[17:47:03.611]     }
[17:47:03.611]     if (FALSE) {
[17:47:03.611]     }
[17:47:03.611]     else {
[17:47:03.611]         if (TRUE) {
[17:47:03.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:03.611]                 open = "w")
[17:47:03.611]         }
[17:47:03.611]         else {
[17:47:03.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:03.611]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:03.611]         }
[17:47:03.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:03.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:03.611]             base::sink(type = "output", split = FALSE)
[17:47:03.611]             base::close(...future.stdout)
[17:47:03.611]         }, add = TRUE)
[17:47:03.611]     }
[17:47:03.611]     ...future.frame <- base::sys.nframe()
[17:47:03.611]     ...future.conditions <- base::list()
[17:47:03.611]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:03.611]     if (FALSE) {
[17:47:03.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:03.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:03.611]     }
[17:47:03.611]     ...future.result <- base::tryCatch({
[17:47:03.611]         base::withCallingHandlers({
[17:47:03.611]             ...future.value <- base::withVisible(base::local({
[17:47:03.611]                 ...future.makeSendCondition <- base::local({
[17:47:03.611]                   sendCondition <- NULL
[17:47:03.611]                   function(frame = 1L) {
[17:47:03.611]                     if (is.function(sendCondition)) 
[17:47:03.611]                       return(sendCondition)
[17:47:03.611]                     ns <- getNamespace("parallel")
[17:47:03.611]                     if (exists("sendData", mode = "function", 
[17:47:03.611]                       envir = ns)) {
[17:47:03.611]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:03.611]                         envir = ns)
[17:47:03.611]                       envir <- sys.frame(frame)
[17:47:03.611]                       master <- NULL
[17:47:03.611]                       while (!identical(envir, .GlobalEnv) && 
[17:47:03.611]                         !identical(envir, emptyenv())) {
[17:47:03.611]                         if (exists("master", mode = "list", envir = envir, 
[17:47:03.611]                           inherits = FALSE)) {
[17:47:03.611]                           master <- get("master", mode = "list", 
[17:47:03.611]                             envir = envir, inherits = FALSE)
[17:47:03.611]                           if (inherits(master, c("SOCKnode", 
[17:47:03.611]                             "SOCK0node"))) {
[17:47:03.611]                             sendCondition <<- function(cond) {
[17:47:03.611]                               data <- list(type = "VALUE", value = cond, 
[17:47:03.611]                                 success = TRUE)
[17:47:03.611]                               parallel_sendData(master, data)
[17:47:03.611]                             }
[17:47:03.611]                             return(sendCondition)
[17:47:03.611]                           }
[17:47:03.611]                         }
[17:47:03.611]                         frame <- frame + 1L
[17:47:03.611]                         envir <- sys.frame(frame)
[17:47:03.611]                       }
[17:47:03.611]                     }
[17:47:03.611]                     sendCondition <<- function(cond) NULL
[17:47:03.611]                   }
[17:47:03.611]                 })
[17:47:03.611]                 withCallingHandlers({
[17:47:03.611]                   {
[17:47:03.611]                     x[["a"]] <- 1
[17:47:03.611]                     x
[17:47:03.611]                   }
[17:47:03.611]                 }, immediateCondition = function(cond) {
[17:47:03.611]                   sendCondition <- ...future.makeSendCondition()
[17:47:03.611]                   sendCondition(cond)
[17:47:03.611]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.611]                   {
[17:47:03.611]                     inherits <- base::inherits
[17:47:03.611]                     invokeRestart <- base::invokeRestart
[17:47:03.611]                     is.null <- base::is.null
[17:47:03.611]                     muffled <- FALSE
[17:47:03.611]                     if (inherits(cond, "message")) {
[17:47:03.611]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:03.611]                       if (muffled) 
[17:47:03.611]                         invokeRestart("muffleMessage")
[17:47:03.611]                     }
[17:47:03.611]                     else if (inherits(cond, "warning")) {
[17:47:03.611]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:03.611]                       if (muffled) 
[17:47:03.611]                         invokeRestart("muffleWarning")
[17:47:03.611]                     }
[17:47:03.611]                     else if (inherits(cond, "condition")) {
[17:47:03.611]                       if (!is.null(pattern)) {
[17:47:03.611]                         computeRestarts <- base::computeRestarts
[17:47:03.611]                         grepl <- base::grepl
[17:47:03.611]                         restarts <- computeRestarts(cond)
[17:47:03.611]                         for (restart in restarts) {
[17:47:03.611]                           name <- restart$name
[17:47:03.611]                           if (is.null(name)) 
[17:47:03.611]                             next
[17:47:03.611]                           if (!grepl(pattern, name)) 
[17:47:03.611]                             next
[17:47:03.611]                           invokeRestart(restart)
[17:47:03.611]                           muffled <- TRUE
[17:47:03.611]                           break
[17:47:03.611]                         }
[17:47:03.611]                       }
[17:47:03.611]                     }
[17:47:03.611]                     invisible(muffled)
[17:47:03.611]                   }
[17:47:03.611]                   muffleCondition(cond)
[17:47:03.611]                 })
[17:47:03.611]             }))
[17:47:03.611]             future::FutureResult(value = ...future.value$value, 
[17:47:03.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.611]                   ...future.rng), globalenv = if (FALSE) 
[17:47:03.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:03.611]                     ...future.globalenv.names))
[17:47:03.611]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:03.611]         }, condition = base::local({
[17:47:03.611]             c <- base::c
[17:47:03.611]             inherits <- base::inherits
[17:47:03.611]             invokeRestart <- base::invokeRestart
[17:47:03.611]             length <- base::length
[17:47:03.611]             list <- base::list
[17:47:03.611]             seq.int <- base::seq.int
[17:47:03.611]             signalCondition <- base::signalCondition
[17:47:03.611]             sys.calls <- base::sys.calls
[17:47:03.611]             `[[` <- base::`[[`
[17:47:03.611]             `+` <- base::`+`
[17:47:03.611]             `<<-` <- base::`<<-`
[17:47:03.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:03.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:03.611]                   3L)]
[17:47:03.611]             }
[17:47:03.611]             function(cond) {
[17:47:03.611]                 is_error <- inherits(cond, "error")
[17:47:03.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:03.611]                   NULL)
[17:47:03.611]                 if (is_error) {
[17:47:03.611]                   sessionInformation <- function() {
[17:47:03.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:03.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:03.611]                       search = base::search(), system = base::Sys.info())
[17:47:03.611]                   }
[17:47:03.611]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:03.611]                     cond$call), session = sessionInformation(), 
[17:47:03.611]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:03.611]                   signalCondition(cond)
[17:47:03.611]                 }
[17:47:03.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:03.611]                 "immediateCondition"))) {
[17:47:03.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:03.611]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:03.611]                   if (TRUE && !signal) {
[17:47:03.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.611]                     {
[17:47:03.611]                       inherits <- base::inherits
[17:47:03.611]                       invokeRestart <- base::invokeRestart
[17:47:03.611]                       is.null <- base::is.null
[17:47:03.611]                       muffled <- FALSE
[17:47:03.611]                       if (inherits(cond, "message")) {
[17:47:03.611]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.611]                         if (muffled) 
[17:47:03.611]                           invokeRestart("muffleMessage")
[17:47:03.611]                       }
[17:47:03.611]                       else if (inherits(cond, "warning")) {
[17:47:03.611]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.611]                         if (muffled) 
[17:47:03.611]                           invokeRestart("muffleWarning")
[17:47:03.611]                       }
[17:47:03.611]                       else if (inherits(cond, "condition")) {
[17:47:03.611]                         if (!is.null(pattern)) {
[17:47:03.611]                           computeRestarts <- base::computeRestarts
[17:47:03.611]                           grepl <- base::grepl
[17:47:03.611]                           restarts <- computeRestarts(cond)
[17:47:03.611]                           for (restart in restarts) {
[17:47:03.611]                             name <- restart$name
[17:47:03.611]                             if (is.null(name)) 
[17:47:03.611]                               next
[17:47:03.611]                             if (!grepl(pattern, name)) 
[17:47:03.611]                               next
[17:47:03.611]                             invokeRestart(restart)
[17:47:03.611]                             muffled <- TRUE
[17:47:03.611]                             break
[17:47:03.611]                           }
[17:47:03.611]                         }
[17:47:03.611]                       }
[17:47:03.611]                       invisible(muffled)
[17:47:03.611]                     }
[17:47:03.611]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.611]                   }
[17:47:03.611]                 }
[17:47:03.611]                 else {
[17:47:03.611]                   if (TRUE) {
[17:47:03.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.611]                     {
[17:47:03.611]                       inherits <- base::inherits
[17:47:03.611]                       invokeRestart <- base::invokeRestart
[17:47:03.611]                       is.null <- base::is.null
[17:47:03.611]                       muffled <- FALSE
[17:47:03.611]                       if (inherits(cond, "message")) {
[17:47:03.611]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.611]                         if (muffled) 
[17:47:03.611]                           invokeRestart("muffleMessage")
[17:47:03.611]                       }
[17:47:03.611]                       else if (inherits(cond, "warning")) {
[17:47:03.611]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.611]                         if (muffled) 
[17:47:03.611]                           invokeRestart("muffleWarning")
[17:47:03.611]                       }
[17:47:03.611]                       else if (inherits(cond, "condition")) {
[17:47:03.611]                         if (!is.null(pattern)) {
[17:47:03.611]                           computeRestarts <- base::computeRestarts
[17:47:03.611]                           grepl <- base::grepl
[17:47:03.611]                           restarts <- computeRestarts(cond)
[17:47:03.611]                           for (restart in restarts) {
[17:47:03.611]                             name <- restart$name
[17:47:03.611]                             if (is.null(name)) 
[17:47:03.611]                               next
[17:47:03.611]                             if (!grepl(pattern, name)) 
[17:47:03.611]                               next
[17:47:03.611]                             invokeRestart(restart)
[17:47:03.611]                             muffled <- TRUE
[17:47:03.611]                             break
[17:47:03.611]                           }
[17:47:03.611]                         }
[17:47:03.611]                       }
[17:47:03.611]                       invisible(muffled)
[17:47:03.611]                     }
[17:47:03.611]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.611]                   }
[17:47:03.611]                 }
[17:47:03.611]             }
[17:47:03.611]         }))
[17:47:03.611]     }, error = function(ex) {
[17:47:03.611]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:03.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.611]                 ...future.rng), started = ...future.startTime, 
[17:47:03.611]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:03.611]             version = "1.8"), class = "FutureResult")
[17:47:03.611]     }, finally = {
[17:47:03.611]         if (!identical(...future.workdir, getwd())) 
[17:47:03.611]             setwd(...future.workdir)
[17:47:03.611]         {
[17:47:03.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:03.611]                 ...future.oldOptions$nwarnings <- NULL
[17:47:03.611]             }
[17:47:03.611]             base::options(...future.oldOptions)
[17:47:03.611]             if (.Platform$OS.type == "windows") {
[17:47:03.611]                 old_names <- names(...future.oldEnvVars)
[17:47:03.611]                 envs <- base::Sys.getenv()
[17:47:03.611]                 names <- names(envs)
[17:47:03.611]                 common <- intersect(names, old_names)
[17:47:03.611]                 added <- setdiff(names, old_names)
[17:47:03.611]                 removed <- setdiff(old_names, names)
[17:47:03.611]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:03.611]                   envs[common]]
[17:47:03.611]                 NAMES <- toupper(changed)
[17:47:03.611]                 args <- list()
[17:47:03.611]                 for (kk in seq_along(NAMES)) {
[17:47:03.611]                   name <- changed[[kk]]
[17:47:03.611]                   NAME <- NAMES[[kk]]
[17:47:03.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.611]                     next
[17:47:03.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.611]                 }
[17:47:03.611]                 NAMES <- toupper(added)
[17:47:03.611]                 for (kk in seq_along(NAMES)) {
[17:47:03.611]                   name <- added[[kk]]
[17:47:03.611]                   NAME <- NAMES[[kk]]
[17:47:03.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.611]                     next
[17:47:03.611]                   args[[name]] <- ""
[17:47:03.611]                 }
[17:47:03.611]                 NAMES <- toupper(removed)
[17:47:03.611]                 for (kk in seq_along(NAMES)) {
[17:47:03.611]                   name <- removed[[kk]]
[17:47:03.611]                   NAME <- NAMES[[kk]]
[17:47:03.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.611]                     next
[17:47:03.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.611]                 }
[17:47:03.611]                 if (length(args) > 0) 
[17:47:03.611]                   base::do.call(base::Sys.setenv, args = args)
[17:47:03.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:03.611]             }
[17:47:03.611]             else {
[17:47:03.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:03.611]             }
[17:47:03.611]             {
[17:47:03.611]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:03.611]                   0L) {
[17:47:03.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:03.611]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:03.611]                   base::options(opts)
[17:47:03.611]                 }
[17:47:03.611]                 {
[17:47:03.611]                   {
[17:47:03.611]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:03.611]                     NULL
[17:47:03.611]                   }
[17:47:03.611]                   options(future.plan = NULL)
[17:47:03.611]                   if (is.na(NA_character_)) 
[17:47:03.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:03.611]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:03.611]                     .init = FALSE)
[17:47:03.611]                 }
[17:47:03.611]             }
[17:47:03.611]         }
[17:47:03.611]     })
[17:47:03.611]     if (TRUE) {
[17:47:03.611]         base::sink(type = "output", split = FALSE)
[17:47:03.611]         if (TRUE) {
[17:47:03.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:03.611]         }
[17:47:03.611]         else {
[17:47:03.611]             ...future.result["stdout"] <- base::list(NULL)
[17:47:03.611]         }
[17:47:03.611]         base::close(...future.stdout)
[17:47:03.611]         ...future.stdout <- NULL
[17:47:03.611]     }
[17:47:03.611]     ...future.result$conditions <- ...future.conditions
[17:47:03.611]     ...future.result$finished <- base::Sys.time()
[17:47:03.611]     ...future.result
[17:47:03.611] }
[17:47:03.613] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:47:03.613] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:47:03.614] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:47:03.614] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:47:03.614] MultisessionFuture started
[17:47:03.614] - Launch lazy future ... done
[17:47:03.615] run() for ‘MultisessionFuture’ ... done
[17:47:03.615] result() for ClusterFuture ...
[17:47:03.615] receiveMessageFromWorker() for ClusterFuture ...
[17:47:03.615] - Validating connection of MultisessionFuture
[17:47:03.616] - received message: FutureResult
[17:47:03.616] - Received FutureResult
[17:47:03.616] - Erased future from FutureRegistry
[17:47:03.617] result() for ClusterFuture ...
[17:47:03.617] - result already collected: FutureResult
[17:47:03.617] result() for ClusterFuture ... done
[17:47:03.617] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:03.617] result() for ClusterFuture ... done
[17:47:03.617] result() for ClusterFuture ...
[17:47:03.617] - result already collected: FutureResult
[17:47:03.617] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:03.617] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:03.618] Searching for globals...
[17:47:03.619] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:03.620] Searching for globals ... DONE
[17:47:03.620] Resolving globals: TRUE
[17:47:03.620] Resolving any globals that are futures ...
[17:47:03.620] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:03.620] Resolving any globals that are futures ... DONE
[17:47:03.620] Resolving futures part of globals (recursively) ...
[17:47:03.621] resolve() on list ...
[17:47:03.621]  recursive: 99
[17:47:03.621]  length: 1
[17:47:03.621]  elements: ‘x’
[17:47:03.621]  length: 0 (resolved future 1)
[17:47:03.621] resolve() on list ... DONE
[17:47:03.621] - globals: [1] ‘x’
[17:47:03.621] Resolving futures part of globals (recursively) ... DONE
[17:47:03.621] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:03.622] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:03.622] - globals: [1] ‘x’
[17:47:03.622] 
[17:47:03.622] getGlobalsAndPackages() ... DONE
[17:47:03.622] run() for ‘Future’ ...
[17:47:03.622] - state: ‘created’
[17:47:03.622] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:03.636] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:03.636] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:03.636]   - Field: ‘node’
[17:47:03.636]   - Field: ‘label’
[17:47:03.636]   - Field: ‘local’
[17:47:03.636]   - Field: ‘owner’
[17:47:03.637]   - Field: ‘envir’
[17:47:03.637]   - Field: ‘workers’
[17:47:03.637]   - Field: ‘packages’
[17:47:03.637]   - Field: ‘gc’
[17:47:03.637]   - Field: ‘conditions’
[17:47:03.637]   - Field: ‘persistent’
[17:47:03.637]   - Field: ‘expr’
[17:47:03.637]   - Field: ‘uuid’
[17:47:03.637]   - Field: ‘seed’
[17:47:03.637]   - Field: ‘version’
[17:47:03.637]   - Field: ‘result’
[17:47:03.638]   - Field: ‘asynchronous’
[17:47:03.638]   - Field: ‘calls’
[17:47:03.638]   - Field: ‘globals’
[17:47:03.638]   - Field: ‘stdout’
[17:47:03.638]   - Field: ‘earlySignal’
[17:47:03.638]   - Field: ‘lazy’
[17:47:03.638]   - Field: ‘state’
[17:47:03.638] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:03.638] - Launch lazy future ...
[17:47:03.639] Packages needed by the future expression (n = 0): <none>
[17:47:03.639] Packages needed by future strategies (n = 0): <none>
[17:47:03.639] {
[17:47:03.639]     {
[17:47:03.639]         {
[17:47:03.639]             ...future.startTime <- base::Sys.time()
[17:47:03.639]             {
[17:47:03.639]                 {
[17:47:03.639]                   {
[17:47:03.639]                     {
[17:47:03.639]                       base::local({
[17:47:03.639]                         has_future <- base::requireNamespace("future", 
[17:47:03.639]                           quietly = TRUE)
[17:47:03.639]                         if (has_future) {
[17:47:03.639]                           ns <- base::getNamespace("future")
[17:47:03.639]                           version <- ns[[".package"]][["version"]]
[17:47:03.639]                           if (is.null(version)) 
[17:47:03.639]                             version <- utils::packageVersion("future")
[17:47:03.639]                         }
[17:47:03.639]                         else {
[17:47:03.639]                           version <- NULL
[17:47:03.639]                         }
[17:47:03.639]                         if (!has_future || version < "1.8.0") {
[17:47:03.639]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:03.639]                             "", base::R.version$version.string), 
[17:47:03.639]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:03.639]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:03.639]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:03.639]                               "release", "version")], collapse = " "), 
[17:47:03.639]                             hostname = base::Sys.info()[["nodename"]])
[17:47:03.639]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:03.639]                             info)
[17:47:03.639]                           info <- base::paste(info, collapse = "; ")
[17:47:03.639]                           if (!has_future) {
[17:47:03.639]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:03.639]                               info)
[17:47:03.639]                           }
[17:47:03.639]                           else {
[17:47:03.639]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:03.639]                               info, version)
[17:47:03.639]                           }
[17:47:03.639]                           base::stop(msg)
[17:47:03.639]                         }
[17:47:03.639]                       })
[17:47:03.639]                     }
[17:47:03.639]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:03.639]                     base::options(mc.cores = 1L)
[17:47:03.639]                   }
[17:47:03.639]                   ...future.strategy.old <- future::plan("list")
[17:47:03.639]                   options(future.plan = NULL)
[17:47:03.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.639]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:03.639]                 }
[17:47:03.639]                 ...future.workdir <- getwd()
[17:47:03.639]             }
[17:47:03.639]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:03.639]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:03.639]         }
[17:47:03.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:03.639]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:03.639]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:03.639]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:03.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:03.639]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:03.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:03.639]             base::names(...future.oldOptions))
[17:47:03.639]     }
[17:47:03.639]     if (FALSE) {
[17:47:03.639]     }
[17:47:03.639]     else {
[17:47:03.639]         if (TRUE) {
[17:47:03.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:03.639]                 open = "w")
[17:47:03.639]         }
[17:47:03.639]         else {
[17:47:03.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:03.639]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:03.639]         }
[17:47:03.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:03.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:03.639]             base::sink(type = "output", split = FALSE)
[17:47:03.639]             base::close(...future.stdout)
[17:47:03.639]         }, add = TRUE)
[17:47:03.639]     }
[17:47:03.639]     ...future.frame <- base::sys.nframe()
[17:47:03.639]     ...future.conditions <- base::list()
[17:47:03.639]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:03.639]     if (FALSE) {
[17:47:03.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:03.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:03.639]     }
[17:47:03.639]     ...future.result <- base::tryCatch({
[17:47:03.639]         base::withCallingHandlers({
[17:47:03.639]             ...future.value <- base::withVisible(base::local({
[17:47:03.639]                 ...future.makeSendCondition <- base::local({
[17:47:03.639]                   sendCondition <- NULL
[17:47:03.639]                   function(frame = 1L) {
[17:47:03.639]                     if (is.function(sendCondition)) 
[17:47:03.639]                       return(sendCondition)
[17:47:03.639]                     ns <- getNamespace("parallel")
[17:47:03.639]                     if (exists("sendData", mode = "function", 
[17:47:03.639]                       envir = ns)) {
[17:47:03.639]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:03.639]                         envir = ns)
[17:47:03.639]                       envir <- sys.frame(frame)
[17:47:03.639]                       master <- NULL
[17:47:03.639]                       while (!identical(envir, .GlobalEnv) && 
[17:47:03.639]                         !identical(envir, emptyenv())) {
[17:47:03.639]                         if (exists("master", mode = "list", envir = envir, 
[17:47:03.639]                           inherits = FALSE)) {
[17:47:03.639]                           master <- get("master", mode = "list", 
[17:47:03.639]                             envir = envir, inherits = FALSE)
[17:47:03.639]                           if (inherits(master, c("SOCKnode", 
[17:47:03.639]                             "SOCK0node"))) {
[17:47:03.639]                             sendCondition <<- function(cond) {
[17:47:03.639]                               data <- list(type = "VALUE", value = cond, 
[17:47:03.639]                                 success = TRUE)
[17:47:03.639]                               parallel_sendData(master, data)
[17:47:03.639]                             }
[17:47:03.639]                             return(sendCondition)
[17:47:03.639]                           }
[17:47:03.639]                         }
[17:47:03.639]                         frame <- frame + 1L
[17:47:03.639]                         envir <- sys.frame(frame)
[17:47:03.639]                       }
[17:47:03.639]                     }
[17:47:03.639]                     sendCondition <<- function(cond) NULL
[17:47:03.639]                   }
[17:47:03.639]                 })
[17:47:03.639]                 withCallingHandlers({
[17:47:03.639]                   {
[17:47:03.639]                     x[["a"]] <- 1
[17:47:03.639]                     x
[17:47:03.639]                   }
[17:47:03.639]                 }, immediateCondition = function(cond) {
[17:47:03.639]                   sendCondition <- ...future.makeSendCondition()
[17:47:03.639]                   sendCondition(cond)
[17:47:03.639]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.639]                   {
[17:47:03.639]                     inherits <- base::inherits
[17:47:03.639]                     invokeRestart <- base::invokeRestart
[17:47:03.639]                     is.null <- base::is.null
[17:47:03.639]                     muffled <- FALSE
[17:47:03.639]                     if (inherits(cond, "message")) {
[17:47:03.639]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:03.639]                       if (muffled) 
[17:47:03.639]                         invokeRestart("muffleMessage")
[17:47:03.639]                     }
[17:47:03.639]                     else if (inherits(cond, "warning")) {
[17:47:03.639]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:03.639]                       if (muffled) 
[17:47:03.639]                         invokeRestart("muffleWarning")
[17:47:03.639]                     }
[17:47:03.639]                     else if (inherits(cond, "condition")) {
[17:47:03.639]                       if (!is.null(pattern)) {
[17:47:03.639]                         computeRestarts <- base::computeRestarts
[17:47:03.639]                         grepl <- base::grepl
[17:47:03.639]                         restarts <- computeRestarts(cond)
[17:47:03.639]                         for (restart in restarts) {
[17:47:03.639]                           name <- restart$name
[17:47:03.639]                           if (is.null(name)) 
[17:47:03.639]                             next
[17:47:03.639]                           if (!grepl(pattern, name)) 
[17:47:03.639]                             next
[17:47:03.639]                           invokeRestart(restart)
[17:47:03.639]                           muffled <- TRUE
[17:47:03.639]                           break
[17:47:03.639]                         }
[17:47:03.639]                       }
[17:47:03.639]                     }
[17:47:03.639]                     invisible(muffled)
[17:47:03.639]                   }
[17:47:03.639]                   muffleCondition(cond)
[17:47:03.639]                 })
[17:47:03.639]             }))
[17:47:03.639]             future::FutureResult(value = ...future.value$value, 
[17:47:03.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.639]                   ...future.rng), globalenv = if (FALSE) 
[17:47:03.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:03.639]                     ...future.globalenv.names))
[17:47:03.639]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:03.639]         }, condition = base::local({
[17:47:03.639]             c <- base::c
[17:47:03.639]             inherits <- base::inherits
[17:47:03.639]             invokeRestart <- base::invokeRestart
[17:47:03.639]             length <- base::length
[17:47:03.639]             list <- base::list
[17:47:03.639]             seq.int <- base::seq.int
[17:47:03.639]             signalCondition <- base::signalCondition
[17:47:03.639]             sys.calls <- base::sys.calls
[17:47:03.639]             `[[` <- base::`[[`
[17:47:03.639]             `+` <- base::`+`
[17:47:03.639]             `<<-` <- base::`<<-`
[17:47:03.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:03.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:03.639]                   3L)]
[17:47:03.639]             }
[17:47:03.639]             function(cond) {
[17:47:03.639]                 is_error <- inherits(cond, "error")
[17:47:03.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:03.639]                   NULL)
[17:47:03.639]                 if (is_error) {
[17:47:03.639]                   sessionInformation <- function() {
[17:47:03.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:03.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:03.639]                       search = base::search(), system = base::Sys.info())
[17:47:03.639]                   }
[17:47:03.639]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:03.639]                     cond$call), session = sessionInformation(), 
[17:47:03.639]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:03.639]                   signalCondition(cond)
[17:47:03.639]                 }
[17:47:03.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:03.639]                 "immediateCondition"))) {
[17:47:03.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:03.639]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:03.639]                   if (TRUE && !signal) {
[17:47:03.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.639]                     {
[17:47:03.639]                       inherits <- base::inherits
[17:47:03.639]                       invokeRestart <- base::invokeRestart
[17:47:03.639]                       is.null <- base::is.null
[17:47:03.639]                       muffled <- FALSE
[17:47:03.639]                       if (inherits(cond, "message")) {
[17:47:03.639]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.639]                         if (muffled) 
[17:47:03.639]                           invokeRestart("muffleMessage")
[17:47:03.639]                       }
[17:47:03.639]                       else if (inherits(cond, "warning")) {
[17:47:03.639]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.639]                         if (muffled) 
[17:47:03.639]                           invokeRestart("muffleWarning")
[17:47:03.639]                       }
[17:47:03.639]                       else if (inherits(cond, "condition")) {
[17:47:03.639]                         if (!is.null(pattern)) {
[17:47:03.639]                           computeRestarts <- base::computeRestarts
[17:47:03.639]                           grepl <- base::grepl
[17:47:03.639]                           restarts <- computeRestarts(cond)
[17:47:03.639]                           for (restart in restarts) {
[17:47:03.639]                             name <- restart$name
[17:47:03.639]                             if (is.null(name)) 
[17:47:03.639]                               next
[17:47:03.639]                             if (!grepl(pattern, name)) 
[17:47:03.639]                               next
[17:47:03.639]                             invokeRestart(restart)
[17:47:03.639]                             muffled <- TRUE
[17:47:03.639]                             break
[17:47:03.639]                           }
[17:47:03.639]                         }
[17:47:03.639]                       }
[17:47:03.639]                       invisible(muffled)
[17:47:03.639]                     }
[17:47:03.639]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.639]                   }
[17:47:03.639]                 }
[17:47:03.639]                 else {
[17:47:03.639]                   if (TRUE) {
[17:47:03.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.639]                     {
[17:47:03.639]                       inherits <- base::inherits
[17:47:03.639]                       invokeRestart <- base::invokeRestart
[17:47:03.639]                       is.null <- base::is.null
[17:47:03.639]                       muffled <- FALSE
[17:47:03.639]                       if (inherits(cond, "message")) {
[17:47:03.639]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.639]                         if (muffled) 
[17:47:03.639]                           invokeRestart("muffleMessage")
[17:47:03.639]                       }
[17:47:03.639]                       else if (inherits(cond, "warning")) {
[17:47:03.639]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.639]                         if (muffled) 
[17:47:03.639]                           invokeRestart("muffleWarning")
[17:47:03.639]                       }
[17:47:03.639]                       else if (inherits(cond, "condition")) {
[17:47:03.639]                         if (!is.null(pattern)) {
[17:47:03.639]                           computeRestarts <- base::computeRestarts
[17:47:03.639]                           grepl <- base::grepl
[17:47:03.639]                           restarts <- computeRestarts(cond)
[17:47:03.639]                           for (restart in restarts) {
[17:47:03.639]                             name <- restart$name
[17:47:03.639]                             if (is.null(name)) 
[17:47:03.639]                               next
[17:47:03.639]                             if (!grepl(pattern, name)) 
[17:47:03.639]                               next
[17:47:03.639]                             invokeRestart(restart)
[17:47:03.639]                             muffled <- TRUE
[17:47:03.639]                             break
[17:47:03.639]                           }
[17:47:03.639]                         }
[17:47:03.639]                       }
[17:47:03.639]                       invisible(muffled)
[17:47:03.639]                     }
[17:47:03.639]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.639]                   }
[17:47:03.639]                 }
[17:47:03.639]             }
[17:47:03.639]         }))
[17:47:03.639]     }, error = function(ex) {
[17:47:03.639]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:03.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.639]                 ...future.rng), started = ...future.startTime, 
[17:47:03.639]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:03.639]             version = "1.8"), class = "FutureResult")
[17:47:03.639]     }, finally = {
[17:47:03.639]         if (!identical(...future.workdir, getwd())) 
[17:47:03.639]             setwd(...future.workdir)
[17:47:03.639]         {
[17:47:03.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:03.639]                 ...future.oldOptions$nwarnings <- NULL
[17:47:03.639]             }
[17:47:03.639]             base::options(...future.oldOptions)
[17:47:03.639]             if (.Platform$OS.type == "windows") {
[17:47:03.639]                 old_names <- names(...future.oldEnvVars)
[17:47:03.639]                 envs <- base::Sys.getenv()
[17:47:03.639]                 names <- names(envs)
[17:47:03.639]                 common <- intersect(names, old_names)
[17:47:03.639]                 added <- setdiff(names, old_names)
[17:47:03.639]                 removed <- setdiff(old_names, names)
[17:47:03.639]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:03.639]                   envs[common]]
[17:47:03.639]                 NAMES <- toupper(changed)
[17:47:03.639]                 args <- list()
[17:47:03.639]                 for (kk in seq_along(NAMES)) {
[17:47:03.639]                   name <- changed[[kk]]
[17:47:03.639]                   NAME <- NAMES[[kk]]
[17:47:03.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.639]                     next
[17:47:03.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.639]                 }
[17:47:03.639]                 NAMES <- toupper(added)
[17:47:03.639]                 for (kk in seq_along(NAMES)) {
[17:47:03.639]                   name <- added[[kk]]
[17:47:03.639]                   NAME <- NAMES[[kk]]
[17:47:03.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.639]                     next
[17:47:03.639]                   args[[name]] <- ""
[17:47:03.639]                 }
[17:47:03.639]                 NAMES <- toupper(removed)
[17:47:03.639]                 for (kk in seq_along(NAMES)) {
[17:47:03.639]                   name <- removed[[kk]]
[17:47:03.639]                   NAME <- NAMES[[kk]]
[17:47:03.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.639]                     next
[17:47:03.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.639]                 }
[17:47:03.639]                 if (length(args) > 0) 
[17:47:03.639]                   base::do.call(base::Sys.setenv, args = args)
[17:47:03.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:03.639]             }
[17:47:03.639]             else {
[17:47:03.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:03.639]             }
[17:47:03.639]             {
[17:47:03.639]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:03.639]                   0L) {
[17:47:03.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:03.639]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:03.639]                   base::options(opts)
[17:47:03.639]                 }
[17:47:03.639]                 {
[17:47:03.639]                   {
[17:47:03.639]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:03.639]                     NULL
[17:47:03.639]                   }
[17:47:03.639]                   options(future.plan = NULL)
[17:47:03.639]                   if (is.na(NA_character_)) 
[17:47:03.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:03.639]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:03.639]                     .init = FALSE)
[17:47:03.639]                 }
[17:47:03.639]             }
[17:47:03.639]         }
[17:47:03.639]     })
[17:47:03.639]     if (TRUE) {
[17:47:03.639]         base::sink(type = "output", split = FALSE)
[17:47:03.639]         if (TRUE) {
[17:47:03.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:03.639]         }
[17:47:03.639]         else {
[17:47:03.639]             ...future.result["stdout"] <- base::list(NULL)
[17:47:03.639]         }
[17:47:03.639]         base::close(...future.stdout)
[17:47:03.639]         ...future.stdout <- NULL
[17:47:03.639]     }
[17:47:03.639]     ...future.result$conditions <- ...future.conditions
[17:47:03.639]     ...future.result$finished <- base::Sys.time()
[17:47:03.639]     ...future.result
[17:47:03.639] }
[17:47:03.642] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:47:03.642] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:47:03.642] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:47:03.642] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:47:03.643] MultisessionFuture started
[17:47:03.643] - Launch lazy future ... done
[17:47:03.643] run() for ‘MultisessionFuture’ ... done
[17:47:03.643] result() for ClusterFuture ...
[17:47:03.643] receiveMessageFromWorker() for ClusterFuture ...
[17:47:03.644] - Validating connection of MultisessionFuture
[17:47:03.645] - received message: FutureResult
[17:47:03.645] - Received FutureResult
[17:47:03.645] - Erased future from FutureRegistry
[17:47:03.645] result() for ClusterFuture ...
[17:47:03.645] - result already collected: FutureResult
[17:47:03.645] result() for ClusterFuture ... done
[17:47:03.645] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:03.645] result() for ClusterFuture ... done
[17:47:03.646] result() for ClusterFuture ...
[17:47:03.646] - result already collected: FutureResult
[17:47:03.646] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:03.646] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:03.646] Searching for globals...
[17:47:03.648] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:03.648] Searching for globals ... DONE
[17:47:03.649] Resolving globals: TRUE
[17:47:03.649] Resolving any globals that are futures ...
[17:47:03.649] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:47:03.649] Resolving any globals that are futures ... DONE
[17:47:03.649] Resolving futures part of globals (recursively) ...
[17:47:03.649] resolve() on list ...
[17:47:03.650]  recursive: 99
[17:47:03.650]  length: 1
[17:47:03.650]  elements: ‘x’
[17:47:03.650]  length: 0 (resolved future 1)
[17:47:03.650] resolve() on list ... DONE
[17:47:03.650] - globals: [1] ‘x’
[17:47:03.650] Resolving futures part of globals (recursively) ... DONE
[17:47:03.650] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:03.651] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:03.651] - globals: [1] ‘x’
[17:47:03.651] 
[17:47:03.651] getGlobalsAndPackages() ... DONE
[17:47:03.651] run() for ‘Future’ ...
[17:47:03.651] - state: ‘created’
[17:47:03.651] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:03.670] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:03.670] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:03.670]   - Field: ‘node’
[17:47:03.670]   - Field: ‘label’
[17:47:03.670]   - Field: ‘local’
[17:47:03.670]   - Field: ‘owner’
[17:47:03.671]   - Field: ‘envir’
[17:47:03.671]   - Field: ‘workers’
[17:47:03.671]   - Field: ‘packages’
[17:47:03.671]   - Field: ‘gc’
[17:47:03.671]   - Field: ‘conditions’
[17:47:03.671]   - Field: ‘persistent’
[17:47:03.671]   - Field: ‘expr’
[17:47:03.671]   - Field: ‘uuid’
[17:47:03.671]   - Field: ‘seed’
[17:47:03.671]   - Field: ‘version’
[17:47:03.671]   - Field: ‘result’
[17:47:03.672]   - Field: ‘asynchronous’
[17:47:03.672]   - Field: ‘calls’
[17:47:03.672]   - Field: ‘globals’
[17:47:03.672]   - Field: ‘stdout’
[17:47:03.672]   - Field: ‘earlySignal’
[17:47:03.672]   - Field: ‘lazy’
[17:47:03.672]   - Field: ‘state’
[17:47:03.672] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:03.672] - Launch lazy future ...
[17:47:03.673] Packages needed by the future expression (n = 0): <none>
[17:47:03.673] Packages needed by future strategies (n = 0): <none>
[17:47:03.673] {
[17:47:03.673]     {
[17:47:03.673]         {
[17:47:03.673]             ...future.startTime <- base::Sys.time()
[17:47:03.673]             {
[17:47:03.673]                 {
[17:47:03.673]                   {
[17:47:03.673]                     {
[17:47:03.673]                       base::local({
[17:47:03.673]                         has_future <- base::requireNamespace("future", 
[17:47:03.673]                           quietly = TRUE)
[17:47:03.673]                         if (has_future) {
[17:47:03.673]                           ns <- base::getNamespace("future")
[17:47:03.673]                           version <- ns[[".package"]][["version"]]
[17:47:03.673]                           if (is.null(version)) 
[17:47:03.673]                             version <- utils::packageVersion("future")
[17:47:03.673]                         }
[17:47:03.673]                         else {
[17:47:03.673]                           version <- NULL
[17:47:03.673]                         }
[17:47:03.673]                         if (!has_future || version < "1.8.0") {
[17:47:03.673]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:03.673]                             "", base::R.version$version.string), 
[17:47:03.673]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:03.673]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:03.673]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:03.673]                               "release", "version")], collapse = " "), 
[17:47:03.673]                             hostname = base::Sys.info()[["nodename"]])
[17:47:03.673]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:03.673]                             info)
[17:47:03.673]                           info <- base::paste(info, collapse = "; ")
[17:47:03.673]                           if (!has_future) {
[17:47:03.673]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:03.673]                               info)
[17:47:03.673]                           }
[17:47:03.673]                           else {
[17:47:03.673]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:03.673]                               info, version)
[17:47:03.673]                           }
[17:47:03.673]                           base::stop(msg)
[17:47:03.673]                         }
[17:47:03.673]                       })
[17:47:03.673]                     }
[17:47:03.673]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:03.673]                     base::options(mc.cores = 1L)
[17:47:03.673]                   }
[17:47:03.673]                   ...future.strategy.old <- future::plan("list")
[17:47:03.673]                   options(future.plan = NULL)
[17:47:03.673]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.673]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:03.673]                 }
[17:47:03.673]                 ...future.workdir <- getwd()
[17:47:03.673]             }
[17:47:03.673]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:03.673]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:03.673]         }
[17:47:03.673]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:03.673]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:03.673]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:03.673]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:03.673]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:03.673]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:03.673]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:03.673]             base::names(...future.oldOptions))
[17:47:03.673]     }
[17:47:03.673]     if (FALSE) {
[17:47:03.673]     }
[17:47:03.673]     else {
[17:47:03.673]         if (TRUE) {
[17:47:03.673]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:03.673]                 open = "w")
[17:47:03.673]         }
[17:47:03.673]         else {
[17:47:03.673]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:03.673]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:03.673]         }
[17:47:03.673]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:03.673]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:03.673]             base::sink(type = "output", split = FALSE)
[17:47:03.673]             base::close(...future.stdout)
[17:47:03.673]         }, add = TRUE)
[17:47:03.673]     }
[17:47:03.673]     ...future.frame <- base::sys.nframe()
[17:47:03.673]     ...future.conditions <- base::list()
[17:47:03.673]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:03.673]     if (FALSE) {
[17:47:03.673]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:03.673]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:03.673]     }
[17:47:03.673]     ...future.result <- base::tryCatch({
[17:47:03.673]         base::withCallingHandlers({
[17:47:03.673]             ...future.value <- base::withVisible(base::local({
[17:47:03.673]                 ...future.makeSendCondition <- base::local({
[17:47:03.673]                   sendCondition <- NULL
[17:47:03.673]                   function(frame = 1L) {
[17:47:03.673]                     if (is.function(sendCondition)) 
[17:47:03.673]                       return(sendCondition)
[17:47:03.673]                     ns <- getNamespace("parallel")
[17:47:03.673]                     if (exists("sendData", mode = "function", 
[17:47:03.673]                       envir = ns)) {
[17:47:03.673]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:03.673]                         envir = ns)
[17:47:03.673]                       envir <- sys.frame(frame)
[17:47:03.673]                       master <- NULL
[17:47:03.673]                       while (!identical(envir, .GlobalEnv) && 
[17:47:03.673]                         !identical(envir, emptyenv())) {
[17:47:03.673]                         if (exists("master", mode = "list", envir = envir, 
[17:47:03.673]                           inherits = FALSE)) {
[17:47:03.673]                           master <- get("master", mode = "list", 
[17:47:03.673]                             envir = envir, inherits = FALSE)
[17:47:03.673]                           if (inherits(master, c("SOCKnode", 
[17:47:03.673]                             "SOCK0node"))) {
[17:47:03.673]                             sendCondition <<- function(cond) {
[17:47:03.673]                               data <- list(type = "VALUE", value = cond, 
[17:47:03.673]                                 success = TRUE)
[17:47:03.673]                               parallel_sendData(master, data)
[17:47:03.673]                             }
[17:47:03.673]                             return(sendCondition)
[17:47:03.673]                           }
[17:47:03.673]                         }
[17:47:03.673]                         frame <- frame + 1L
[17:47:03.673]                         envir <- sys.frame(frame)
[17:47:03.673]                       }
[17:47:03.673]                     }
[17:47:03.673]                     sendCondition <<- function(cond) NULL
[17:47:03.673]                   }
[17:47:03.673]                 })
[17:47:03.673]                 withCallingHandlers({
[17:47:03.673]                   {
[17:47:03.673]                     x[["a"]] <- 1
[17:47:03.673]                     x
[17:47:03.673]                   }
[17:47:03.673]                 }, immediateCondition = function(cond) {
[17:47:03.673]                   sendCondition <- ...future.makeSendCondition()
[17:47:03.673]                   sendCondition(cond)
[17:47:03.673]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.673]                   {
[17:47:03.673]                     inherits <- base::inherits
[17:47:03.673]                     invokeRestart <- base::invokeRestart
[17:47:03.673]                     is.null <- base::is.null
[17:47:03.673]                     muffled <- FALSE
[17:47:03.673]                     if (inherits(cond, "message")) {
[17:47:03.673]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:03.673]                       if (muffled) 
[17:47:03.673]                         invokeRestart("muffleMessage")
[17:47:03.673]                     }
[17:47:03.673]                     else if (inherits(cond, "warning")) {
[17:47:03.673]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:03.673]                       if (muffled) 
[17:47:03.673]                         invokeRestart("muffleWarning")
[17:47:03.673]                     }
[17:47:03.673]                     else if (inherits(cond, "condition")) {
[17:47:03.673]                       if (!is.null(pattern)) {
[17:47:03.673]                         computeRestarts <- base::computeRestarts
[17:47:03.673]                         grepl <- base::grepl
[17:47:03.673]                         restarts <- computeRestarts(cond)
[17:47:03.673]                         for (restart in restarts) {
[17:47:03.673]                           name <- restart$name
[17:47:03.673]                           if (is.null(name)) 
[17:47:03.673]                             next
[17:47:03.673]                           if (!grepl(pattern, name)) 
[17:47:03.673]                             next
[17:47:03.673]                           invokeRestart(restart)
[17:47:03.673]                           muffled <- TRUE
[17:47:03.673]                           break
[17:47:03.673]                         }
[17:47:03.673]                       }
[17:47:03.673]                     }
[17:47:03.673]                     invisible(muffled)
[17:47:03.673]                   }
[17:47:03.673]                   muffleCondition(cond)
[17:47:03.673]                 })
[17:47:03.673]             }))
[17:47:03.673]             future::FutureResult(value = ...future.value$value, 
[17:47:03.673]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.673]                   ...future.rng), globalenv = if (FALSE) 
[17:47:03.673]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:03.673]                     ...future.globalenv.names))
[17:47:03.673]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:03.673]         }, condition = base::local({
[17:47:03.673]             c <- base::c
[17:47:03.673]             inherits <- base::inherits
[17:47:03.673]             invokeRestart <- base::invokeRestart
[17:47:03.673]             length <- base::length
[17:47:03.673]             list <- base::list
[17:47:03.673]             seq.int <- base::seq.int
[17:47:03.673]             signalCondition <- base::signalCondition
[17:47:03.673]             sys.calls <- base::sys.calls
[17:47:03.673]             `[[` <- base::`[[`
[17:47:03.673]             `+` <- base::`+`
[17:47:03.673]             `<<-` <- base::`<<-`
[17:47:03.673]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:03.673]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:03.673]                   3L)]
[17:47:03.673]             }
[17:47:03.673]             function(cond) {
[17:47:03.673]                 is_error <- inherits(cond, "error")
[17:47:03.673]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:03.673]                   NULL)
[17:47:03.673]                 if (is_error) {
[17:47:03.673]                   sessionInformation <- function() {
[17:47:03.673]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:03.673]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:03.673]                       search = base::search(), system = base::Sys.info())
[17:47:03.673]                   }
[17:47:03.673]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.673]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:03.673]                     cond$call), session = sessionInformation(), 
[17:47:03.673]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:03.673]                   signalCondition(cond)
[17:47:03.673]                 }
[17:47:03.673]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:03.673]                 "immediateCondition"))) {
[17:47:03.673]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:03.673]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.673]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:03.673]                   if (TRUE && !signal) {
[17:47:03.673]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.673]                     {
[17:47:03.673]                       inherits <- base::inherits
[17:47:03.673]                       invokeRestart <- base::invokeRestart
[17:47:03.673]                       is.null <- base::is.null
[17:47:03.673]                       muffled <- FALSE
[17:47:03.673]                       if (inherits(cond, "message")) {
[17:47:03.673]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.673]                         if (muffled) 
[17:47:03.673]                           invokeRestart("muffleMessage")
[17:47:03.673]                       }
[17:47:03.673]                       else if (inherits(cond, "warning")) {
[17:47:03.673]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.673]                         if (muffled) 
[17:47:03.673]                           invokeRestart("muffleWarning")
[17:47:03.673]                       }
[17:47:03.673]                       else if (inherits(cond, "condition")) {
[17:47:03.673]                         if (!is.null(pattern)) {
[17:47:03.673]                           computeRestarts <- base::computeRestarts
[17:47:03.673]                           grepl <- base::grepl
[17:47:03.673]                           restarts <- computeRestarts(cond)
[17:47:03.673]                           for (restart in restarts) {
[17:47:03.673]                             name <- restart$name
[17:47:03.673]                             if (is.null(name)) 
[17:47:03.673]                               next
[17:47:03.673]                             if (!grepl(pattern, name)) 
[17:47:03.673]                               next
[17:47:03.673]                             invokeRestart(restart)
[17:47:03.673]                             muffled <- TRUE
[17:47:03.673]                             break
[17:47:03.673]                           }
[17:47:03.673]                         }
[17:47:03.673]                       }
[17:47:03.673]                       invisible(muffled)
[17:47:03.673]                     }
[17:47:03.673]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.673]                   }
[17:47:03.673]                 }
[17:47:03.673]                 else {
[17:47:03.673]                   if (TRUE) {
[17:47:03.673]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.673]                     {
[17:47:03.673]                       inherits <- base::inherits
[17:47:03.673]                       invokeRestart <- base::invokeRestart
[17:47:03.673]                       is.null <- base::is.null
[17:47:03.673]                       muffled <- FALSE
[17:47:03.673]                       if (inherits(cond, "message")) {
[17:47:03.673]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.673]                         if (muffled) 
[17:47:03.673]                           invokeRestart("muffleMessage")
[17:47:03.673]                       }
[17:47:03.673]                       else if (inherits(cond, "warning")) {
[17:47:03.673]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.673]                         if (muffled) 
[17:47:03.673]                           invokeRestart("muffleWarning")
[17:47:03.673]                       }
[17:47:03.673]                       else if (inherits(cond, "condition")) {
[17:47:03.673]                         if (!is.null(pattern)) {
[17:47:03.673]                           computeRestarts <- base::computeRestarts
[17:47:03.673]                           grepl <- base::grepl
[17:47:03.673]                           restarts <- computeRestarts(cond)
[17:47:03.673]                           for (restart in restarts) {
[17:47:03.673]                             name <- restart$name
[17:47:03.673]                             if (is.null(name)) 
[17:47:03.673]                               next
[17:47:03.673]                             if (!grepl(pattern, name)) 
[17:47:03.673]                               next
[17:47:03.673]                             invokeRestart(restart)
[17:47:03.673]                             muffled <- TRUE
[17:47:03.673]                             break
[17:47:03.673]                           }
[17:47:03.673]                         }
[17:47:03.673]                       }
[17:47:03.673]                       invisible(muffled)
[17:47:03.673]                     }
[17:47:03.673]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.673]                   }
[17:47:03.673]                 }
[17:47:03.673]             }
[17:47:03.673]         }))
[17:47:03.673]     }, error = function(ex) {
[17:47:03.673]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:03.673]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.673]                 ...future.rng), started = ...future.startTime, 
[17:47:03.673]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:03.673]             version = "1.8"), class = "FutureResult")
[17:47:03.673]     }, finally = {
[17:47:03.673]         if (!identical(...future.workdir, getwd())) 
[17:47:03.673]             setwd(...future.workdir)
[17:47:03.673]         {
[17:47:03.673]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:03.673]                 ...future.oldOptions$nwarnings <- NULL
[17:47:03.673]             }
[17:47:03.673]             base::options(...future.oldOptions)
[17:47:03.673]             if (.Platform$OS.type == "windows") {
[17:47:03.673]                 old_names <- names(...future.oldEnvVars)
[17:47:03.673]                 envs <- base::Sys.getenv()
[17:47:03.673]                 names <- names(envs)
[17:47:03.673]                 common <- intersect(names, old_names)
[17:47:03.673]                 added <- setdiff(names, old_names)
[17:47:03.673]                 removed <- setdiff(old_names, names)
[17:47:03.673]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:03.673]                   envs[common]]
[17:47:03.673]                 NAMES <- toupper(changed)
[17:47:03.673]                 args <- list()
[17:47:03.673]                 for (kk in seq_along(NAMES)) {
[17:47:03.673]                   name <- changed[[kk]]
[17:47:03.673]                   NAME <- NAMES[[kk]]
[17:47:03.673]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.673]                     next
[17:47:03.673]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.673]                 }
[17:47:03.673]                 NAMES <- toupper(added)
[17:47:03.673]                 for (kk in seq_along(NAMES)) {
[17:47:03.673]                   name <- added[[kk]]
[17:47:03.673]                   NAME <- NAMES[[kk]]
[17:47:03.673]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.673]                     next
[17:47:03.673]                   args[[name]] <- ""
[17:47:03.673]                 }
[17:47:03.673]                 NAMES <- toupper(removed)
[17:47:03.673]                 for (kk in seq_along(NAMES)) {
[17:47:03.673]                   name <- removed[[kk]]
[17:47:03.673]                   NAME <- NAMES[[kk]]
[17:47:03.673]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.673]                     next
[17:47:03.673]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.673]                 }
[17:47:03.673]                 if (length(args) > 0) 
[17:47:03.673]                   base::do.call(base::Sys.setenv, args = args)
[17:47:03.673]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:03.673]             }
[17:47:03.673]             else {
[17:47:03.673]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:03.673]             }
[17:47:03.673]             {
[17:47:03.673]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:03.673]                   0L) {
[17:47:03.673]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:03.673]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:03.673]                   base::options(opts)
[17:47:03.673]                 }
[17:47:03.673]                 {
[17:47:03.673]                   {
[17:47:03.673]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:03.673]                     NULL
[17:47:03.673]                   }
[17:47:03.673]                   options(future.plan = NULL)
[17:47:03.673]                   if (is.na(NA_character_)) 
[17:47:03.673]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.673]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:03.673]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:03.673]                     .init = FALSE)
[17:47:03.673]                 }
[17:47:03.673]             }
[17:47:03.673]         }
[17:47:03.673]     })
[17:47:03.673]     if (TRUE) {
[17:47:03.673]         base::sink(type = "output", split = FALSE)
[17:47:03.673]         if (TRUE) {
[17:47:03.673]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:03.673]         }
[17:47:03.673]         else {
[17:47:03.673]             ...future.result["stdout"] <- base::list(NULL)
[17:47:03.673]         }
[17:47:03.673]         base::close(...future.stdout)
[17:47:03.673]         ...future.stdout <- NULL
[17:47:03.673]     }
[17:47:03.673]     ...future.result$conditions <- ...future.conditions
[17:47:03.673]     ...future.result$finished <- base::Sys.time()
[17:47:03.673]     ...future.result
[17:47:03.673] }
[17:47:03.676] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:47:03.676] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:47:03.676] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:47:03.676] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:47:03.677] MultisessionFuture started
[17:47:03.677] - Launch lazy future ... done
[17:47:03.677] run() for ‘MultisessionFuture’ ... done
[17:47:03.677] result() for ClusterFuture ...
[17:47:03.677] receiveMessageFromWorker() for ClusterFuture ...
[17:47:03.678] - Validating connection of MultisessionFuture
[17:47:03.679] - received message: FutureResult
[17:47:03.679] - Received FutureResult
[17:47:03.679] - Erased future from FutureRegistry
[17:47:03.679] result() for ClusterFuture ...
[17:47:03.679] - result already collected: FutureResult
[17:47:03.679] result() for ClusterFuture ... done
[17:47:03.679] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:03.679] result() for ClusterFuture ... done
[17:47:03.680] result() for ClusterFuture ...
[17:47:03.680] - result already collected: FutureResult
[17:47:03.680] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:03.680] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:03.680] Searching for globals...
[17:47:03.682] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:03.682] Searching for globals ... DONE
[17:47:03.682] Resolving globals: TRUE
[17:47:03.683] Resolving any globals that are futures ...
[17:47:03.683] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:03.683] Resolving any globals that are futures ... DONE
[17:47:03.683] Resolving futures part of globals (recursively) ...
[17:47:03.683] resolve() on list ...
[17:47:03.683]  recursive: 99
[17:47:03.684]  length: 1
[17:47:03.684]  elements: ‘x’
[17:47:03.684]  length: 0 (resolved future 1)
[17:47:03.684] resolve() on list ... DONE
[17:47:03.684] - globals: [1] ‘x’
[17:47:03.684] Resolving futures part of globals (recursively) ... DONE
[17:47:03.684] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:03.684] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:03.685] - globals: [1] ‘x’
[17:47:03.685] 
[17:47:03.685] getGlobalsAndPackages() ... DONE
[17:47:03.685] run() for ‘Future’ ...
[17:47:03.685] - state: ‘created’
[17:47:03.685] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:03.699] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:03.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:03.699]   - Field: ‘node’
[17:47:03.699]   - Field: ‘label’
[17:47:03.699]   - Field: ‘local’
[17:47:03.699]   - Field: ‘owner’
[17:47:03.699]   - Field: ‘envir’
[17:47:03.700]   - Field: ‘workers’
[17:47:03.700]   - Field: ‘packages’
[17:47:03.700]   - Field: ‘gc’
[17:47:03.700]   - Field: ‘conditions’
[17:47:03.700]   - Field: ‘persistent’
[17:47:03.700]   - Field: ‘expr’
[17:47:03.700]   - Field: ‘uuid’
[17:47:03.700]   - Field: ‘seed’
[17:47:03.700]   - Field: ‘version’
[17:47:03.700]   - Field: ‘result’
[17:47:03.700]   - Field: ‘asynchronous’
[17:47:03.701]   - Field: ‘calls’
[17:47:03.701]   - Field: ‘globals’
[17:47:03.701]   - Field: ‘stdout’
[17:47:03.701]   - Field: ‘earlySignal’
[17:47:03.701]   - Field: ‘lazy’
[17:47:03.701]   - Field: ‘state’
[17:47:03.701] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:03.701] - Launch lazy future ...
[17:47:03.701] Packages needed by the future expression (n = 0): <none>
[17:47:03.702] Packages needed by future strategies (n = 0): <none>
[17:47:03.702] {
[17:47:03.702]     {
[17:47:03.702]         {
[17:47:03.702]             ...future.startTime <- base::Sys.time()
[17:47:03.702]             {
[17:47:03.702]                 {
[17:47:03.702]                   {
[17:47:03.702]                     {
[17:47:03.702]                       base::local({
[17:47:03.702]                         has_future <- base::requireNamespace("future", 
[17:47:03.702]                           quietly = TRUE)
[17:47:03.702]                         if (has_future) {
[17:47:03.702]                           ns <- base::getNamespace("future")
[17:47:03.702]                           version <- ns[[".package"]][["version"]]
[17:47:03.702]                           if (is.null(version)) 
[17:47:03.702]                             version <- utils::packageVersion("future")
[17:47:03.702]                         }
[17:47:03.702]                         else {
[17:47:03.702]                           version <- NULL
[17:47:03.702]                         }
[17:47:03.702]                         if (!has_future || version < "1.8.0") {
[17:47:03.702]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:03.702]                             "", base::R.version$version.string), 
[17:47:03.702]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:03.702]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:03.702]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:03.702]                               "release", "version")], collapse = " "), 
[17:47:03.702]                             hostname = base::Sys.info()[["nodename"]])
[17:47:03.702]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:03.702]                             info)
[17:47:03.702]                           info <- base::paste(info, collapse = "; ")
[17:47:03.702]                           if (!has_future) {
[17:47:03.702]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:03.702]                               info)
[17:47:03.702]                           }
[17:47:03.702]                           else {
[17:47:03.702]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:03.702]                               info, version)
[17:47:03.702]                           }
[17:47:03.702]                           base::stop(msg)
[17:47:03.702]                         }
[17:47:03.702]                       })
[17:47:03.702]                     }
[17:47:03.702]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:03.702]                     base::options(mc.cores = 1L)
[17:47:03.702]                   }
[17:47:03.702]                   ...future.strategy.old <- future::plan("list")
[17:47:03.702]                   options(future.plan = NULL)
[17:47:03.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:03.702]                 }
[17:47:03.702]                 ...future.workdir <- getwd()
[17:47:03.702]             }
[17:47:03.702]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:03.702]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:03.702]         }
[17:47:03.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:03.702]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:03.702]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:03.702]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:03.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:03.702]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:03.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:03.702]             base::names(...future.oldOptions))
[17:47:03.702]     }
[17:47:03.702]     if (FALSE) {
[17:47:03.702]     }
[17:47:03.702]     else {
[17:47:03.702]         if (TRUE) {
[17:47:03.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:03.702]                 open = "w")
[17:47:03.702]         }
[17:47:03.702]         else {
[17:47:03.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:03.702]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:03.702]         }
[17:47:03.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:03.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:03.702]             base::sink(type = "output", split = FALSE)
[17:47:03.702]             base::close(...future.stdout)
[17:47:03.702]         }, add = TRUE)
[17:47:03.702]     }
[17:47:03.702]     ...future.frame <- base::sys.nframe()
[17:47:03.702]     ...future.conditions <- base::list()
[17:47:03.702]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:03.702]     if (FALSE) {
[17:47:03.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:03.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:03.702]     }
[17:47:03.702]     ...future.result <- base::tryCatch({
[17:47:03.702]         base::withCallingHandlers({
[17:47:03.702]             ...future.value <- base::withVisible(base::local({
[17:47:03.702]                 ...future.makeSendCondition <- base::local({
[17:47:03.702]                   sendCondition <- NULL
[17:47:03.702]                   function(frame = 1L) {
[17:47:03.702]                     if (is.function(sendCondition)) 
[17:47:03.702]                       return(sendCondition)
[17:47:03.702]                     ns <- getNamespace("parallel")
[17:47:03.702]                     if (exists("sendData", mode = "function", 
[17:47:03.702]                       envir = ns)) {
[17:47:03.702]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:03.702]                         envir = ns)
[17:47:03.702]                       envir <- sys.frame(frame)
[17:47:03.702]                       master <- NULL
[17:47:03.702]                       while (!identical(envir, .GlobalEnv) && 
[17:47:03.702]                         !identical(envir, emptyenv())) {
[17:47:03.702]                         if (exists("master", mode = "list", envir = envir, 
[17:47:03.702]                           inherits = FALSE)) {
[17:47:03.702]                           master <- get("master", mode = "list", 
[17:47:03.702]                             envir = envir, inherits = FALSE)
[17:47:03.702]                           if (inherits(master, c("SOCKnode", 
[17:47:03.702]                             "SOCK0node"))) {
[17:47:03.702]                             sendCondition <<- function(cond) {
[17:47:03.702]                               data <- list(type = "VALUE", value = cond, 
[17:47:03.702]                                 success = TRUE)
[17:47:03.702]                               parallel_sendData(master, data)
[17:47:03.702]                             }
[17:47:03.702]                             return(sendCondition)
[17:47:03.702]                           }
[17:47:03.702]                         }
[17:47:03.702]                         frame <- frame + 1L
[17:47:03.702]                         envir <- sys.frame(frame)
[17:47:03.702]                       }
[17:47:03.702]                     }
[17:47:03.702]                     sendCondition <<- function(cond) NULL
[17:47:03.702]                   }
[17:47:03.702]                 })
[17:47:03.702]                 withCallingHandlers({
[17:47:03.702]                   {
[17:47:03.702]                     x["a"] <- list(1)
[17:47:03.702]                     x
[17:47:03.702]                   }
[17:47:03.702]                 }, immediateCondition = function(cond) {
[17:47:03.702]                   sendCondition <- ...future.makeSendCondition()
[17:47:03.702]                   sendCondition(cond)
[17:47:03.702]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.702]                   {
[17:47:03.702]                     inherits <- base::inherits
[17:47:03.702]                     invokeRestart <- base::invokeRestart
[17:47:03.702]                     is.null <- base::is.null
[17:47:03.702]                     muffled <- FALSE
[17:47:03.702]                     if (inherits(cond, "message")) {
[17:47:03.702]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:03.702]                       if (muffled) 
[17:47:03.702]                         invokeRestart("muffleMessage")
[17:47:03.702]                     }
[17:47:03.702]                     else if (inherits(cond, "warning")) {
[17:47:03.702]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:03.702]                       if (muffled) 
[17:47:03.702]                         invokeRestart("muffleWarning")
[17:47:03.702]                     }
[17:47:03.702]                     else if (inherits(cond, "condition")) {
[17:47:03.702]                       if (!is.null(pattern)) {
[17:47:03.702]                         computeRestarts <- base::computeRestarts
[17:47:03.702]                         grepl <- base::grepl
[17:47:03.702]                         restarts <- computeRestarts(cond)
[17:47:03.702]                         for (restart in restarts) {
[17:47:03.702]                           name <- restart$name
[17:47:03.702]                           if (is.null(name)) 
[17:47:03.702]                             next
[17:47:03.702]                           if (!grepl(pattern, name)) 
[17:47:03.702]                             next
[17:47:03.702]                           invokeRestart(restart)
[17:47:03.702]                           muffled <- TRUE
[17:47:03.702]                           break
[17:47:03.702]                         }
[17:47:03.702]                       }
[17:47:03.702]                     }
[17:47:03.702]                     invisible(muffled)
[17:47:03.702]                   }
[17:47:03.702]                   muffleCondition(cond)
[17:47:03.702]                 })
[17:47:03.702]             }))
[17:47:03.702]             future::FutureResult(value = ...future.value$value, 
[17:47:03.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.702]                   ...future.rng), globalenv = if (FALSE) 
[17:47:03.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:03.702]                     ...future.globalenv.names))
[17:47:03.702]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:03.702]         }, condition = base::local({
[17:47:03.702]             c <- base::c
[17:47:03.702]             inherits <- base::inherits
[17:47:03.702]             invokeRestart <- base::invokeRestart
[17:47:03.702]             length <- base::length
[17:47:03.702]             list <- base::list
[17:47:03.702]             seq.int <- base::seq.int
[17:47:03.702]             signalCondition <- base::signalCondition
[17:47:03.702]             sys.calls <- base::sys.calls
[17:47:03.702]             `[[` <- base::`[[`
[17:47:03.702]             `+` <- base::`+`
[17:47:03.702]             `<<-` <- base::`<<-`
[17:47:03.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:03.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:03.702]                   3L)]
[17:47:03.702]             }
[17:47:03.702]             function(cond) {
[17:47:03.702]                 is_error <- inherits(cond, "error")
[17:47:03.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:03.702]                   NULL)
[17:47:03.702]                 if (is_error) {
[17:47:03.702]                   sessionInformation <- function() {
[17:47:03.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:03.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:03.702]                       search = base::search(), system = base::Sys.info())
[17:47:03.702]                   }
[17:47:03.702]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:03.702]                     cond$call), session = sessionInformation(), 
[17:47:03.702]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:03.702]                   signalCondition(cond)
[17:47:03.702]                 }
[17:47:03.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:03.702]                 "immediateCondition"))) {
[17:47:03.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:03.702]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:03.702]                   if (TRUE && !signal) {
[17:47:03.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.702]                     {
[17:47:03.702]                       inherits <- base::inherits
[17:47:03.702]                       invokeRestart <- base::invokeRestart
[17:47:03.702]                       is.null <- base::is.null
[17:47:03.702]                       muffled <- FALSE
[17:47:03.702]                       if (inherits(cond, "message")) {
[17:47:03.702]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.702]                         if (muffled) 
[17:47:03.702]                           invokeRestart("muffleMessage")
[17:47:03.702]                       }
[17:47:03.702]                       else if (inherits(cond, "warning")) {
[17:47:03.702]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.702]                         if (muffled) 
[17:47:03.702]                           invokeRestart("muffleWarning")
[17:47:03.702]                       }
[17:47:03.702]                       else if (inherits(cond, "condition")) {
[17:47:03.702]                         if (!is.null(pattern)) {
[17:47:03.702]                           computeRestarts <- base::computeRestarts
[17:47:03.702]                           grepl <- base::grepl
[17:47:03.702]                           restarts <- computeRestarts(cond)
[17:47:03.702]                           for (restart in restarts) {
[17:47:03.702]                             name <- restart$name
[17:47:03.702]                             if (is.null(name)) 
[17:47:03.702]                               next
[17:47:03.702]                             if (!grepl(pattern, name)) 
[17:47:03.702]                               next
[17:47:03.702]                             invokeRestart(restart)
[17:47:03.702]                             muffled <- TRUE
[17:47:03.702]                             break
[17:47:03.702]                           }
[17:47:03.702]                         }
[17:47:03.702]                       }
[17:47:03.702]                       invisible(muffled)
[17:47:03.702]                     }
[17:47:03.702]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.702]                   }
[17:47:03.702]                 }
[17:47:03.702]                 else {
[17:47:03.702]                   if (TRUE) {
[17:47:03.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.702]                     {
[17:47:03.702]                       inherits <- base::inherits
[17:47:03.702]                       invokeRestart <- base::invokeRestart
[17:47:03.702]                       is.null <- base::is.null
[17:47:03.702]                       muffled <- FALSE
[17:47:03.702]                       if (inherits(cond, "message")) {
[17:47:03.702]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.702]                         if (muffled) 
[17:47:03.702]                           invokeRestart("muffleMessage")
[17:47:03.702]                       }
[17:47:03.702]                       else if (inherits(cond, "warning")) {
[17:47:03.702]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.702]                         if (muffled) 
[17:47:03.702]                           invokeRestart("muffleWarning")
[17:47:03.702]                       }
[17:47:03.702]                       else if (inherits(cond, "condition")) {
[17:47:03.702]                         if (!is.null(pattern)) {
[17:47:03.702]                           computeRestarts <- base::computeRestarts
[17:47:03.702]                           grepl <- base::grepl
[17:47:03.702]                           restarts <- computeRestarts(cond)
[17:47:03.702]                           for (restart in restarts) {
[17:47:03.702]                             name <- restart$name
[17:47:03.702]                             if (is.null(name)) 
[17:47:03.702]                               next
[17:47:03.702]                             if (!grepl(pattern, name)) 
[17:47:03.702]                               next
[17:47:03.702]                             invokeRestart(restart)
[17:47:03.702]                             muffled <- TRUE
[17:47:03.702]                             break
[17:47:03.702]                           }
[17:47:03.702]                         }
[17:47:03.702]                       }
[17:47:03.702]                       invisible(muffled)
[17:47:03.702]                     }
[17:47:03.702]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.702]                   }
[17:47:03.702]                 }
[17:47:03.702]             }
[17:47:03.702]         }))
[17:47:03.702]     }, error = function(ex) {
[17:47:03.702]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:03.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.702]                 ...future.rng), started = ...future.startTime, 
[17:47:03.702]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:03.702]             version = "1.8"), class = "FutureResult")
[17:47:03.702]     }, finally = {
[17:47:03.702]         if (!identical(...future.workdir, getwd())) 
[17:47:03.702]             setwd(...future.workdir)
[17:47:03.702]         {
[17:47:03.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:03.702]                 ...future.oldOptions$nwarnings <- NULL
[17:47:03.702]             }
[17:47:03.702]             base::options(...future.oldOptions)
[17:47:03.702]             if (.Platform$OS.type == "windows") {
[17:47:03.702]                 old_names <- names(...future.oldEnvVars)
[17:47:03.702]                 envs <- base::Sys.getenv()
[17:47:03.702]                 names <- names(envs)
[17:47:03.702]                 common <- intersect(names, old_names)
[17:47:03.702]                 added <- setdiff(names, old_names)
[17:47:03.702]                 removed <- setdiff(old_names, names)
[17:47:03.702]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:03.702]                   envs[common]]
[17:47:03.702]                 NAMES <- toupper(changed)
[17:47:03.702]                 args <- list()
[17:47:03.702]                 for (kk in seq_along(NAMES)) {
[17:47:03.702]                   name <- changed[[kk]]
[17:47:03.702]                   NAME <- NAMES[[kk]]
[17:47:03.702]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.702]                     next
[17:47:03.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.702]                 }
[17:47:03.702]                 NAMES <- toupper(added)
[17:47:03.702]                 for (kk in seq_along(NAMES)) {
[17:47:03.702]                   name <- added[[kk]]
[17:47:03.702]                   NAME <- NAMES[[kk]]
[17:47:03.702]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.702]                     next
[17:47:03.702]                   args[[name]] <- ""
[17:47:03.702]                 }
[17:47:03.702]                 NAMES <- toupper(removed)
[17:47:03.702]                 for (kk in seq_along(NAMES)) {
[17:47:03.702]                   name <- removed[[kk]]
[17:47:03.702]                   NAME <- NAMES[[kk]]
[17:47:03.702]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.702]                     next
[17:47:03.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.702]                 }
[17:47:03.702]                 if (length(args) > 0) 
[17:47:03.702]                   base::do.call(base::Sys.setenv, args = args)
[17:47:03.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:03.702]             }
[17:47:03.702]             else {
[17:47:03.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:03.702]             }
[17:47:03.702]             {
[17:47:03.702]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:03.702]                   0L) {
[17:47:03.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:03.702]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:03.702]                   base::options(opts)
[17:47:03.702]                 }
[17:47:03.702]                 {
[17:47:03.702]                   {
[17:47:03.702]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:03.702]                     NULL
[17:47:03.702]                   }
[17:47:03.702]                   options(future.plan = NULL)
[17:47:03.702]                   if (is.na(NA_character_)) 
[17:47:03.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:03.702]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:03.702]                     .init = FALSE)
[17:47:03.702]                 }
[17:47:03.702]             }
[17:47:03.702]         }
[17:47:03.702]     })
[17:47:03.702]     if (TRUE) {
[17:47:03.702]         base::sink(type = "output", split = FALSE)
[17:47:03.702]         if (TRUE) {
[17:47:03.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:03.702]         }
[17:47:03.702]         else {
[17:47:03.702]             ...future.result["stdout"] <- base::list(NULL)
[17:47:03.702]         }
[17:47:03.702]         base::close(...future.stdout)
[17:47:03.702]         ...future.stdout <- NULL
[17:47:03.702]     }
[17:47:03.702]     ...future.result$conditions <- ...future.conditions
[17:47:03.702]     ...future.result$finished <- base::Sys.time()
[17:47:03.702]     ...future.result
[17:47:03.702] }
[17:47:03.704] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:47:03.705] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:47:03.705] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:47:03.705] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:47:03.706] MultisessionFuture started
[17:47:03.706] - Launch lazy future ... done
[17:47:03.706] run() for ‘MultisessionFuture’ ... done
[17:47:03.706] result() for ClusterFuture ...
[17:47:03.706] receiveMessageFromWorker() for ClusterFuture ...
[17:47:03.706] - Validating connection of MultisessionFuture
[17:47:03.707] - received message: FutureResult
[17:47:03.708] - Received FutureResult
[17:47:03.708] - Erased future from FutureRegistry
[17:47:03.708] result() for ClusterFuture ...
[17:47:03.708] - result already collected: FutureResult
[17:47:03.708] result() for ClusterFuture ... done
[17:47:03.708] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:03.708] result() for ClusterFuture ... done
[17:47:03.708] result() for ClusterFuture ...
[17:47:03.708] - result already collected: FutureResult
[17:47:03.708] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:03.709] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:03.709] Searching for globals...
[17:47:03.711] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:03.711] Searching for globals ... DONE
[17:47:03.711] Resolving globals: TRUE
[17:47:03.711] Resolving any globals that are futures ...
[17:47:03.711] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:03.712] Resolving any globals that are futures ... DONE
[17:47:03.712] Resolving futures part of globals (recursively) ...
[17:47:03.712] resolve() on list ...
[17:47:03.712]  recursive: 99
[17:47:03.712]  length: 1
[17:47:03.712]  elements: ‘x’
[17:47:03.713]  length: 0 (resolved future 1)
[17:47:03.713] resolve() on list ... DONE
[17:47:03.713] - globals: [1] ‘x’
[17:47:03.713] Resolving futures part of globals (recursively) ... DONE
[17:47:03.713] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:03.713] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:03.713] - globals: [1] ‘x’
[17:47:03.714] 
[17:47:03.714] getGlobalsAndPackages() ... DONE
[17:47:03.714] run() for ‘Future’ ...
[17:47:03.714] - state: ‘created’
[17:47:03.714] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:03.727] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:03.728] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:03.728]   - Field: ‘node’
[17:47:03.728]   - Field: ‘label’
[17:47:03.728]   - Field: ‘local’
[17:47:03.728]   - Field: ‘owner’
[17:47:03.728]   - Field: ‘envir’
[17:47:03.728]   - Field: ‘workers’
[17:47:03.728]   - Field: ‘packages’
[17:47:03.728]   - Field: ‘gc’
[17:47:03.729]   - Field: ‘conditions’
[17:47:03.729]   - Field: ‘persistent’
[17:47:03.729]   - Field: ‘expr’
[17:47:03.729]   - Field: ‘uuid’
[17:47:03.729]   - Field: ‘seed’
[17:47:03.729]   - Field: ‘version’
[17:47:03.729]   - Field: ‘result’
[17:47:03.729]   - Field: ‘asynchronous’
[17:47:03.729]   - Field: ‘calls’
[17:47:03.729]   - Field: ‘globals’
[17:47:03.729]   - Field: ‘stdout’
[17:47:03.730]   - Field: ‘earlySignal’
[17:47:03.730]   - Field: ‘lazy’
[17:47:03.730]   - Field: ‘state’
[17:47:03.730] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:03.730] - Launch lazy future ...
[17:47:03.730] Packages needed by the future expression (n = 0): <none>
[17:47:03.730] Packages needed by future strategies (n = 0): <none>
[17:47:03.731] {
[17:47:03.731]     {
[17:47:03.731]         {
[17:47:03.731]             ...future.startTime <- base::Sys.time()
[17:47:03.731]             {
[17:47:03.731]                 {
[17:47:03.731]                   {
[17:47:03.731]                     {
[17:47:03.731]                       base::local({
[17:47:03.731]                         has_future <- base::requireNamespace("future", 
[17:47:03.731]                           quietly = TRUE)
[17:47:03.731]                         if (has_future) {
[17:47:03.731]                           ns <- base::getNamespace("future")
[17:47:03.731]                           version <- ns[[".package"]][["version"]]
[17:47:03.731]                           if (is.null(version)) 
[17:47:03.731]                             version <- utils::packageVersion("future")
[17:47:03.731]                         }
[17:47:03.731]                         else {
[17:47:03.731]                           version <- NULL
[17:47:03.731]                         }
[17:47:03.731]                         if (!has_future || version < "1.8.0") {
[17:47:03.731]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:03.731]                             "", base::R.version$version.string), 
[17:47:03.731]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:03.731]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:03.731]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:03.731]                               "release", "version")], collapse = " "), 
[17:47:03.731]                             hostname = base::Sys.info()[["nodename"]])
[17:47:03.731]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:03.731]                             info)
[17:47:03.731]                           info <- base::paste(info, collapse = "; ")
[17:47:03.731]                           if (!has_future) {
[17:47:03.731]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:03.731]                               info)
[17:47:03.731]                           }
[17:47:03.731]                           else {
[17:47:03.731]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:03.731]                               info, version)
[17:47:03.731]                           }
[17:47:03.731]                           base::stop(msg)
[17:47:03.731]                         }
[17:47:03.731]                       })
[17:47:03.731]                     }
[17:47:03.731]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:03.731]                     base::options(mc.cores = 1L)
[17:47:03.731]                   }
[17:47:03.731]                   ...future.strategy.old <- future::plan("list")
[17:47:03.731]                   options(future.plan = NULL)
[17:47:03.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:03.731]                 }
[17:47:03.731]                 ...future.workdir <- getwd()
[17:47:03.731]             }
[17:47:03.731]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:03.731]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:03.731]         }
[17:47:03.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:03.731]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:03.731]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:03.731]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:03.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:03.731]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:03.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:03.731]             base::names(...future.oldOptions))
[17:47:03.731]     }
[17:47:03.731]     if (FALSE) {
[17:47:03.731]     }
[17:47:03.731]     else {
[17:47:03.731]         if (TRUE) {
[17:47:03.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:03.731]                 open = "w")
[17:47:03.731]         }
[17:47:03.731]         else {
[17:47:03.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:03.731]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:03.731]         }
[17:47:03.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:03.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:03.731]             base::sink(type = "output", split = FALSE)
[17:47:03.731]             base::close(...future.stdout)
[17:47:03.731]         }, add = TRUE)
[17:47:03.731]     }
[17:47:03.731]     ...future.frame <- base::sys.nframe()
[17:47:03.731]     ...future.conditions <- base::list()
[17:47:03.731]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:03.731]     if (FALSE) {
[17:47:03.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:03.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:03.731]     }
[17:47:03.731]     ...future.result <- base::tryCatch({
[17:47:03.731]         base::withCallingHandlers({
[17:47:03.731]             ...future.value <- base::withVisible(base::local({
[17:47:03.731]                 ...future.makeSendCondition <- base::local({
[17:47:03.731]                   sendCondition <- NULL
[17:47:03.731]                   function(frame = 1L) {
[17:47:03.731]                     if (is.function(sendCondition)) 
[17:47:03.731]                       return(sendCondition)
[17:47:03.731]                     ns <- getNamespace("parallel")
[17:47:03.731]                     if (exists("sendData", mode = "function", 
[17:47:03.731]                       envir = ns)) {
[17:47:03.731]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:03.731]                         envir = ns)
[17:47:03.731]                       envir <- sys.frame(frame)
[17:47:03.731]                       master <- NULL
[17:47:03.731]                       while (!identical(envir, .GlobalEnv) && 
[17:47:03.731]                         !identical(envir, emptyenv())) {
[17:47:03.731]                         if (exists("master", mode = "list", envir = envir, 
[17:47:03.731]                           inherits = FALSE)) {
[17:47:03.731]                           master <- get("master", mode = "list", 
[17:47:03.731]                             envir = envir, inherits = FALSE)
[17:47:03.731]                           if (inherits(master, c("SOCKnode", 
[17:47:03.731]                             "SOCK0node"))) {
[17:47:03.731]                             sendCondition <<- function(cond) {
[17:47:03.731]                               data <- list(type = "VALUE", value = cond, 
[17:47:03.731]                                 success = TRUE)
[17:47:03.731]                               parallel_sendData(master, data)
[17:47:03.731]                             }
[17:47:03.731]                             return(sendCondition)
[17:47:03.731]                           }
[17:47:03.731]                         }
[17:47:03.731]                         frame <- frame + 1L
[17:47:03.731]                         envir <- sys.frame(frame)
[17:47:03.731]                       }
[17:47:03.731]                     }
[17:47:03.731]                     sendCondition <<- function(cond) NULL
[17:47:03.731]                   }
[17:47:03.731]                 })
[17:47:03.731]                 withCallingHandlers({
[17:47:03.731]                   {
[17:47:03.731]                     x["a"] <- list(1)
[17:47:03.731]                     x
[17:47:03.731]                   }
[17:47:03.731]                 }, immediateCondition = function(cond) {
[17:47:03.731]                   sendCondition <- ...future.makeSendCondition()
[17:47:03.731]                   sendCondition(cond)
[17:47:03.731]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.731]                   {
[17:47:03.731]                     inherits <- base::inherits
[17:47:03.731]                     invokeRestart <- base::invokeRestart
[17:47:03.731]                     is.null <- base::is.null
[17:47:03.731]                     muffled <- FALSE
[17:47:03.731]                     if (inherits(cond, "message")) {
[17:47:03.731]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:03.731]                       if (muffled) 
[17:47:03.731]                         invokeRestart("muffleMessage")
[17:47:03.731]                     }
[17:47:03.731]                     else if (inherits(cond, "warning")) {
[17:47:03.731]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:03.731]                       if (muffled) 
[17:47:03.731]                         invokeRestart("muffleWarning")
[17:47:03.731]                     }
[17:47:03.731]                     else if (inherits(cond, "condition")) {
[17:47:03.731]                       if (!is.null(pattern)) {
[17:47:03.731]                         computeRestarts <- base::computeRestarts
[17:47:03.731]                         grepl <- base::grepl
[17:47:03.731]                         restarts <- computeRestarts(cond)
[17:47:03.731]                         for (restart in restarts) {
[17:47:03.731]                           name <- restart$name
[17:47:03.731]                           if (is.null(name)) 
[17:47:03.731]                             next
[17:47:03.731]                           if (!grepl(pattern, name)) 
[17:47:03.731]                             next
[17:47:03.731]                           invokeRestart(restart)
[17:47:03.731]                           muffled <- TRUE
[17:47:03.731]                           break
[17:47:03.731]                         }
[17:47:03.731]                       }
[17:47:03.731]                     }
[17:47:03.731]                     invisible(muffled)
[17:47:03.731]                   }
[17:47:03.731]                   muffleCondition(cond)
[17:47:03.731]                 })
[17:47:03.731]             }))
[17:47:03.731]             future::FutureResult(value = ...future.value$value, 
[17:47:03.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.731]                   ...future.rng), globalenv = if (FALSE) 
[17:47:03.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:03.731]                     ...future.globalenv.names))
[17:47:03.731]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:03.731]         }, condition = base::local({
[17:47:03.731]             c <- base::c
[17:47:03.731]             inherits <- base::inherits
[17:47:03.731]             invokeRestart <- base::invokeRestart
[17:47:03.731]             length <- base::length
[17:47:03.731]             list <- base::list
[17:47:03.731]             seq.int <- base::seq.int
[17:47:03.731]             signalCondition <- base::signalCondition
[17:47:03.731]             sys.calls <- base::sys.calls
[17:47:03.731]             `[[` <- base::`[[`
[17:47:03.731]             `+` <- base::`+`
[17:47:03.731]             `<<-` <- base::`<<-`
[17:47:03.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:03.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:03.731]                   3L)]
[17:47:03.731]             }
[17:47:03.731]             function(cond) {
[17:47:03.731]                 is_error <- inherits(cond, "error")
[17:47:03.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:03.731]                   NULL)
[17:47:03.731]                 if (is_error) {
[17:47:03.731]                   sessionInformation <- function() {
[17:47:03.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:03.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:03.731]                       search = base::search(), system = base::Sys.info())
[17:47:03.731]                   }
[17:47:03.731]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:03.731]                     cond$call), session = sessionInformation(), 
[17:47:03.731]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:03.731]                   signalCondition(cond)
[17:47:03.731]                 }
[17:47:03.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:03.731]                 "immediateCondition"))) {
[17:47:03.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:03.731]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:03.731]                   if (TRUE && !signal) {
[17:47:03.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.731]                     {
[17:47:03.731]                       inherits <- base::inherits
[17:47:03.731]                       invokeRestart <- base::invokeRestart
[17:47:03.731]                       is.null <- base::is.null
[17:47:03.731]                       muffled <- FALSE
[17:47:03.731]                       if (inherits(cond, "message")) {
[17:47:03.731]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.731]                         if (muffled) 
[17:47:03.731]                           invokeRestart("muffleMessage")
[17:47:03.731]                       }
[17:47:03.731]                       else if (inherits(cond, "warning")) {
[17:47:03.731]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.731]                         if (muffled) 
[17:47:03.731]                           invokeRestart("muffleWarning")
[17:47:03.731]                       }
[17:47:03.731]                       else if (inherits(cond, "condition")) {
[17:47:03.731]                         if (!is.null(pattern)) {
[17:47:03.731]                           computeRestarts <- base::computeRestarts
[17:47:03.731]                           grepl <- base::grepl
[17:47:03.731]                           restarts <- computeRestarts(cond)
[17:47:03.731]                           for (restart in restarts) {
[17:47:03.731]                             name <- restart$name
[17:47:03.731]                             if (is.null(name)) 
[17:47:03.731]                               next
[17:47:03.731]                             if (!grepl(pattern, name)) 
[17:47:03.731]                               next
[17:47:03.731]                             invokeRestart(restart)
[17:47:03.731]                             muffled <- TRUE
[17:47:03.731]                             break
[17:47:03.731]                           }
[17:47:03.731]                         }
[17:47:03.731]                       }
[17:47:03.731]                       invisible(muffled)
[17:47:03.731]                     }
[17:47:03.731]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.731]                   }
[17:47:03.731]                 }
[17:47:03.731]                 else {
[17:47:03.731]                   if (TRUE) {
[17:47:03.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.731]                     {
[17:47:03.731]                       inherits <- base::inherits
[17:47:03.731]                       invokeRestart <- base::invokeRestart
[17:47:03.731]                       is.null <- base::is.null
[17:47:03.731]                       muffled <- FALSE
[17:47:03.731]                       if (inherits(cond, "message")) {
[17:47:03.731]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.731]                         if (muffled) 
[17:47:03.731]                           invokeRestart("muffleMessage")
[17:47:03.731]                       }
[17:47:03.731]                       else if (inherits(cond, "warning")) {
[17:47:03.731]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.731]                         if (muffled) 
[17:47:03.731]                           invokeRestart("muffleWarning")
[17:47:03.731]                       }
[17:47:03.731]                       else if (inherits(cond, "condition")) {
[17:47:03.731]                         if (!is.null(pattern)) {
[17:47:03.731]                           computeRestarts <- base::computeRestarts
[17:47:03.731]                           grepl <- base::grepl
[17:47:03.731]                           restarts <- computeRestarts(cond)
[17:47:03.731]                           for (restart in restarts) {
[17:47:03.731]                             name <- restart$name
[17:47:03.731]                             if (is.null(name)) 
[17:47:03.731]                               next
[17:47:03.731]                             if (!grepl(pattern, name)) 
[17:47:03.731]                               next
[17:47:03.731]                             invokeRestart(restart)
[17:47:03.731]                             muffled <- TRUE
[17:47:03.731]                             break
[17:47:03.731]                           }
[17:47:03.731]                         }
[17:47:03.731]                       }
[17:47:03.731]                       invisible(muffled)
[17:47:03.731]                     }
[17:47:03.731]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.731]                   }
[17:47:03.731]                 }
[17:47:03.731]             }
[17:47:03.731]         }))
[17:47:03.731]     }, error = function(ex) {
[17:47:03.731]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:03.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.731]                 ...future.rng), started = ...future.startTime, 
[17:47:03.731]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:03.731]             version = "1.8"), class = "FutureResult")
[17:47:03.731]     }, finally = {
[17:47:03.731]         if (!identical(...future.workdir, getwd())) 
[17:47:03.731]             setwd(...future.workdir)
[17:47:03.731]         {
[17:47:03.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:03.731]                 ...future.oldOptions$nwarnings <- NULL
[17:47:03.731]             }
[17:47:03.731]             base::options(...future.oldOptions)
[17:47:03.731]             if (.Platform$OS.type == "windows") {
[17:47:03.731]                 old_names <- names(...future.oldEnvVars)
[17:47:03.731]                 envs <- base::Sys.getenv()
[17:47:03.731]                 names <- names(envs)
[17:47:03.731]                 common <- intersect(names, old_names)
[17:47:03.731]                 added <- setdiff(names, old_names)
[17:47:03.731]                 removed <- setdiff(old_names, names)
[17:47:03.731]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:03.731]                   envs[common]]
[17:47:03.731]                 NAMES <- toupper(changed)
[17:47:03.731]                 args <- list()
[17:47:03.731]                 for (kk in seq_along(NAMES)) {
[17:47:03.731]                   name <- changed[[kk]]
[17:47:03.731]                   NAME <- NAMES[[kk]]
[17:47:03.731]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.731]                     next
[17:47:03.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.731]                 }
[17:47:03.731]                 NAMES <- toupper(added)
[17:47:03.731]                 for (kk in seq_along(NAMES)) {
[17:47:03.731]                   name <- added[[kk]]
[17:47:03.731]                   NAME <- NAMES[[kk]]
[17:47:03.731]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.731]                     next
[17:47:03.731]                   args[[name]] <- ""
[17:47:03.731]                 }
[17:47:03.731]                 NAMES <- toupper(removed)
[17:47:03.731]                 for (kk in seq_along(NAMES)) {
[17:47:03.731]                   name <- removed[[kk]]
[17:47:03.731]                   NAME <- NAMES[[kk]]
[17:47:03.731]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.731]                     next
[17:47:03.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.731]                 }
[17:47:03.731]                 if (length(args) > 0) 
[17:47:03.731]                   base::do.call(base::Sys.setenv, args = args)
[17:47:03.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:03.731]             }
[17:47:03.731]             else {
[17:47:03.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:03.731]             }
[17:47:03.731]             {
[17:47:03.731]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:03.731]                   0L) {
[17:47:03.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:03.731]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:03.731]                   base::options(opts)
[17:47:03.731]                 }
[17:47:03.731]                 {
[17:47:03.731]                   {
[17:47:03.731]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:03.731]                     NULL
[17:47:03.731]                   }
[17:47:03.731]                   options(future.plan = NULL)
[17:47:03.731]                   if (is.na(NA_character_)) 
[17:47:03.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:03.731]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:03.731]                     .init = FALSE)
[17:47:03.731]                 }
[17:47:03.731]             }
[17:47:03.731]         }
[17:47:03.731]     })
[17:47:03.731]     if (TRUE) {
[17:47:03.731]         base::sink(type = "output", split = FALSE)
[17:47:03.731]         if (TRUE) {
[17:47:03.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:03.731]         }
[17:47:03.731]         else {
[17:47:03.731]             ...future.result["stdout"] <- base::list(NULL)
[17:47:03.731]         }
[17:47:03.731]         base::close(...future.stdout)
[17:47:03.731]         ...future.stdout <- NULL
[17:47:03.731]     }
[17:47:03.731]     ...future.result$conditions <- ...future.conditions
[17:47:03.731]     ...future.result$finished <- base::Sys.time()
[17:47:03.731]     ...future.result
[17:47:03.731] }
[17:47:03.733] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:47:03.733] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:47:03.734] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:47:03.734] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:47:03.734] MultisessionFuture started
[17:47:03.735] - Launch lazy future ... done
[17:47:03.735] run() for ‘MultisessionFuture’ ... done
[17:47:03.735] result() for ClusterFuture ...
[17:47:03.735] receiveMessageFromWorker() for ClusterFuture ...
[17:47:03.735] - Validating connection of MultisessionFuture
[17:47:03.736] - received message: FutureResult
[17:47:03.736] - Received FutureResult
[17:47:03.737] - Erased future from FutureRegistry
[17:47:03.737] result() for ClusterFuture ...
[17:47:03.737] - result already collected: FutureResult
[17:47:03.737] result() for ClusterFuture ... done
[17:47:03.737] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:03.737] result() for ClusterFuture ... done
[17:47:03.737] result() for ClusterFuture ...
[17:47:03.737] - result already collected: FutureResult
[17:47:03.737] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:03.738] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:03.738] Searching for globals...
[17:47:03.740] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:03.740] Searching for globals ... DONE
[17:47:03.740] Resolving globals: TRUE
[17:47:03.740] Resolving any globals that are futures ...
[17:47:03.740] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:47:03.741] Resolving any globals that are futures ... DONE
[17:47:03.741] Resolving futures part of globals (recursively) ...
[17:47:03.741] resolve() on list ...
[17:47:03.741]  recursive: 99
[17:47:03.741]  length: 1
[17:47:03.741]  elements: ‘x’
[17:47:03.742]  length: 0 (resolved future 1)
[17:47:03.742] resolve() on list ... DONE
[17:47:03.742] - globals: [1] ‘x’
[17:47:03.742] Resolving futures part of globals (recursively) ... DONE
[17:47:03.742] The total size of the 1 globals is 0 bytes (0 bytes)
[17:47:03.742] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:47:03.742] - globals: [1] ‘x’
[17:47:03.742] 
[17:47:03.743] getGlobalsAndPackages() ... DONE
[17:47:03.743] run() for ‘Future’ ...
[17:47:03.743] - state: ‘created’
[17:47:03.743] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:03.756] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:03.756] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:03.757]   - Field: ‘node’
[17:47:03.757]   - Field: ‘label’
[17:47:03.757]   - Field: ‘local’
[17:47:03.757]   - Field: ‘owner’
[17:47:03.757]   - Field: ‘envir’
[17:47:03.757]   - Field: ‘workers’
[17:47:03.757]   - Field: ‘packages’
[17:47:03.757]   - Field: ‘gc’
[17:47:03.757]   - Field: ‘conditions’
[17:47:03.757]   - Field: ‘persistent’
[17:47:03.757]   - Field: ‘expr’
[17:47:03.758]   - Field: ‘uuid’
[17:47:03.758]   - Field: ‘seed’
[17:47:03.758]   - Field: ‘version’
[17:47:03.758]   - Field: ‘result’
[17:47:03.758]   - Field: ‘asynchronous’
[17:47:03.758]   - Field: ‘calls’
[17:47:03.758]   - Field: ‘globals’
[17:47:03.758]   - Field: ‘stdout’
[17:47:03.758]   - Field: ‘earlySignal’
[17:47:03.758]   - Field: ‘lazy’
[17:47:03.758]   - Field: ‘state’
[17:47:03.759] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:03.759] - Launch lazy future ...
[17:47:03.759] Packages needed by the future expression (n = 0): <none>
[17:47:03.759] Packages needed by future strategies (n = 0): <none>
[17:47:03.759] {
[17:47:03.759]     {
[17:47:03.759]         {
[17:47:03.759]             ...future.startTime <- base::Sys.time()
[17:47:03.759]             {
[17:47:03.759]                 {
[17:47:03.759]                   {
[17:47:03.759]                     {
[17:47:03.759]                       base::local({
[17:47:03.759]                         has_future <- base::requireNamespace("future", 
[17:47:03.759]                           quietly = TRUE)
[17:47:03.759]                         if (has_future) {
[17:47:03.759]                           ns <- base::getNamespace("future")
[17:47:03.759]                           version <- ns[[".package"]][["version"]]
[17:47:03.759]                           if (is.null(version)) 
[17:47:03.759]                             version <- utils::packageVersion("future")
[17:47:03.759]                         }
[17:47:03.759]                         else {
[17:47:03.759]                           version <- NULL
[17:47:03.759]                         }
[17:47:03.759]                         if (!has_future || version < "1.8.0") {
[17:47:03.759]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:03.759]                             "", base::R.version$version.string), 
[17:47:03.759]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:03.759]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:03.759]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:03.759]                               "release", "version")], collapse = " "), 
[17:47:03.759]                             hostname = base::Sys.info()[["nodename"]])
[17:47:03.759]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:03.759]                             info)
[17:47:03.759]                           info <- base::paste(info, collapse = "; ")
[17:47:03.759]                           if (!has_future) {
[17:47:03.759]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:03.759]                               info)
[17:47:03.759]                           }
[17:47:03.759]                           else {
[17:47:03.759]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:03.759]                               info, version)
[17:47:03.759]                           }
[17:47:03.759]                           base::stop(msg)
[17:47:03.759]                         }
[17:47:03.759]                       })
[17:47:03.759]                     }
[17:47:03.759]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:03.759]                     base::options(mc.cores = 1L)
[17:47:03.759]                   }
[17:47:03.759]                   ...future.strategy.old <- future::plan("list")
[17:47:03.759]                   options(future.plan = NULL)
[17:47:03.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:03.759]                 }
[17:47:03.759]                 ...future.workdir <- getwd()
[17:47:03.759]             }
[17:47:03.759]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:03.759]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:03.759]         }
[17:47:03.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:03.759]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:03.759]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:03.759]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:03.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:03.759]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:03.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:03.759]             base::names(...future.oldOptions))
[17:47:03.759]     }
[17:47:03.759]     if (FALSE) {
[17:47:03.759]     }
[17:47:03.759]     else {
[17:47:03.759]         if (TRUE) {
[17:47:03.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:03.759]                 open = "w")
[17:47:03.759]         }
[17:47:03.759]         else {
[17:47:03.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:03.759]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:03.759]         }
[17:47:03.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:03.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:03.759]             base::sink(type = "output", split = FALSE)
[17:47:03.759]             base::close(...future.stdout)
[17:47:03.759]         }, add = TRUE)
[17:47:03.759]     }
[17:47:03.759]     ...future.frame <- base::sys.nframe()
[17:47:03.759]     ...future.conditions <- base::list()
[17:47:03.759]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:03.759]     if (FALSE) {
[17:47:03.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:03.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:03.759]     }
[17:47:03.759]     ...future.result <- base::tryCatch({
[17:47:03.759]         base::withCallingHandlers({
[17:47:03.759]             ...future.value <- base::withVisible(base::local({
[17:47:03.759]                 ...future.makeSendCondition <- base::local({
[17:47:03.759]                   sendCondition <- NULL
[17:47:03.759]                   function(frame = 1L) {
[17:47:03.759]                     if (is.function(sendCondition)) 
[17:47:03.759]                       return(sendCondition)
[17:47:03.759]                     ns <- getNamespace("parallel")
[17:47:03.759]                     if (exists("sendData", mode = "function", 
[17:47:03.759]                       envir = ns)) {
[17:47:03.759]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:03.759]                         envir = ns)
[17:47:03.759]                       envir <- sys.frame(frame)
[17:47:03.759]                       master <- NULL
[17:47:03.759]                       while (!identical(envir, .GlobalEnv) && 
[17:47:03.759]                         !identical(envir, emptyenv())) {
[17:47:03.759]                         if (exists("master", mode = "list", envir = envir, 
[17:47:03.759]                           inherits = FALSE)) {
[17:47:03.759]                           master <- get("master", mode = "list", 
[17:47:03.759]                             envir = envir, inherits = FALSE)
[17:47:03.759]                           if (inherits(master, c("SOCKnode", 
[17:47:03.759]                             "SOCK0node"))) {
[17:47:03.759]                             sendCondition <<- function(cond) {
[17:47:03.759]                               data <- list(type = "VALUE", value = cond, 
[17:47:03.759]                                 success = TRUE)
[17:47:03.759]                               parallel_sendData(master, data)
[17:47:03.759]                             }
[17:47:03.759]                             return(sendCondition)
[17:47:03.759]                           }
[17:47:03.759]                         }
[17:47:03.759]                         frame <- frame + 1L
[17:47:03.759]                         envir <- sys.frame(frame)
[17:47:03.759]                       }
[17:47:03.759]                     }
[17:47:03.759]                     sendCondition <<- function(cond) NULL
[17:47:03.759]                   }
[17:47:03.759]                 })
[17:47:03.759]                 withCallingHandlers({
[17:47:03.759]                   {
[17:47:03.759]                     x["a"] <- list(1)
[17:47:03.759]                     x
[17:47:03.759]                   }
[17:47:03.759]                 }, immediateCondition = function(cond) {
[17:47:03.759]                   sendCondition <- ...future.makeSendCondition()
[17:47:03.759]                   sendCondition(cond)
[17:47:03.759]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.759]                   {
[17:47:03.759]                     inherits <- base::inherits
[17:47:03.759]                     invokeRestart <- base::invokeRestart
[17:47:03.759]                     is.null <- base::is.null
[17:47:03.759]                     muffled <- FALSE
[17:47:03.759]                     if (inherits(cond, "message")) {
[17:47:03.759]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:03.759]                       if (muffled) 
[17:47:03.759]                         invokeRestart("muffleMessage")
[17:47:03.759]                     }
[17:47:03.759]                     else if (inherits(cond, "warning")) {
[17:47:03.759]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:03.759]                       if (muffled) 
[17:47:03.759]                         invokeRestart("muffleWarning")
[17:47:03.759]                     }
[17:47:03.759]                     else if (inherits(cond, "condition")) {
[17:47:03.759]                       if (!is.null(pattern)) {
[17:47:03.759]                         computeRestarts <- base::computeRestarts
[17:47:03.759]                         grepl <- base::grepl
[17:47:03.759]                         restarts <- computeRestarts(cond)
[17:47:03.759]                         for (restart in restarts) {
[17:47:03.759]                           name <- restart$name
[17:47:03.759]                           if (is.null(name)) 
[17:47:03.759]                             next
[17:47:03.759]                           if (!grepl(pattern, name)) 
[17:47:03.759]                             next
[17:47:03.759]                           invokeRestart(restart)
[17:47:03.759]                           muffled <- TRUE
[17:47:03.759]                           break
[17:47:03.759]                         }
[17:47:03.759]                       }
[17:47:03.759]                     }
[17:47:03.759]                     invisible(muffled)
[17:47:03.759]                   }
[17:47:03.759]                   muffleCondition(cond)
[17:47:03.759]                 })
[17:47:03.759]             }))
[17:47:03.759]             future::FutureResult(value = ...future.value$value, 
[17:47:03.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.759]                   ...future.rng), globalenv = if (FALSE) 
[17:47:03.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:03.759]                     ...future.globalenv.names))
[17:47:03.759]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:03.759]         }, condition = base::local({
[17:47:03.759]             c <- base::c
[17:47:03.759]             inherits <- base::inherits
[17:47:03.759]             invokeRestart <- base::invokeRestart
[17:47:03.759]             length <- base::length
[17:47:03.759]             list <- base::list
[17:47:03.759]             seq.int <- base::seq.int
[17:47:03.759]             signalCondition <- base::signalCondition
[17:47:03.759]             sys.calls <- base::sys.calls
[17:47:03.759]             `[[` <- base::`[[`
[17:47:03.759]             `+` <- base::`+`
[17:47:03.759]             `<<-` <- base::`<<-`
[17:47:03.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:03.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:03.759]                   3L)]
[17:47:03.759]             }
[17:47:03.759]             function(cond) {
[17:47:03.759]                 is_error <- inherits(cond, "error")
[17:47:03.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:03.759]                   NULL)
[17:47:03.759]                 if (is_error) {
[17:47:03.759]                   sessionInformation <- function() {
[17:47:03.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:03.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:03.759]                       search = base::search(), system = base::Sys.info())
[17:47:03.759]                   }
[17:47:03.759]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:03.759]                     cond$call), session = sessionInformation(), 
[17:47:03.759]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:03.759]                   signalCondition(cond)
[17:47:03.759]                 }
[17:47:03.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:03.759]                 "immediateCondition"))) {
[17:47:03.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:03.759]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:03.759]                   if (TRUE && !signal) {
[17:47:03.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.759]                     {
[17:47:03.759]                       inherits <- base::inherits
[17:47:03.759]                       invokeRestart <- base::invokeRestart
[17:47:03.759]                       is.null <- base::is.null
[17:47:03.759]                       muffled <- FALSE
[17:47:03.759]                       if (inherits(cond, "message")) {
[17:47:03.759]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.759]                         if (muffled) 
[17:47:03.759]                           invokeRestart("muffleMessage")
[17:47:03.759]                       }
[17:47:03.759]                       else if (inherits(cond, "warning")) {
[17:47:03.759]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.759]                         if (muffled) 
[17:47:03.759]                           invokeRestart("muffleWarning")
[17:47:03.759]                       }
[17:47:03.759]                       else if (inherits(cond, "condition")) {
[17:47:03.759]                         if (!is.null(pattern)) {
[17:47:03.759]                           computeRestarts <- base::computeRestarts
[17:47:03.759]                           grepl <- base::grepl
[17:47:03.759]                           restarts <- computeRestarts(cond)
[17:47:03.759]                           for (restart in restarts) {
[17:47:03.759]                             name <- restart$name
[17:47:03.759]                             if (is.null(name)) 
[17:47:03.759]                               next
[17:47:03.759]                             if (!grepl(pattern, name)) 
[17:47:03.759]                               next
[17:47:03.759]                             invokeRestart(restart)
[17:47:03.759]                             muffled <- TRUE
[17:47:03.759]                             break
[17:47:03.759]                           }
[17:47:03.759]                         }
[17:47:03.759]                       }
[17:47:03.759]                       invisible(muffled)
[17:47:03.759]                     }
[17:47:03.759]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.759]                   }
[17:47:03.759]                 }
[17:47:03.759]                 else {
[17:47:03.759]                   if (TRUE) {
[17:47:03.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.759]                     {
[17:47:03.759]                       inherits <- base::inherits
[17:47:03.759]                       invokeRestart <- base::invokeRestart
[17:47:03.759]                       is.null <- base::is.null
[17:47:03.759]                       muffled <- FALSE
[17:47:03.759]                       if (inherits(cond, "message")) {
[17:47:03.759]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.759]                         if (muffled) 
[17:47:03.759]                           invokeRestart("muffleMessage")
[17:47:03.759]                       }
[17:47:03.759]                       else if (inherits(cond, "warning")) {
[17:47:03.759]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.759]                         if (muffled) 
[17:47:03.759]                           invokeRestart("muffleWarning")
[17:47:03.759]                       }
[17:47:03.759]                       else if (inherits(cond, "condition")) {
[17:47:03.759]                         if (!is.null(pattern)) {
[17:47:03.759]                           computeRestarts <- base::computeRestarts
[17:47:03.759]                           grepl <- base::grepl
[17:47:03.759]                           restarts <- computeRestarts(cond)
[17:47:03.759]                           for (restart in restarts) {
[17:47:03.759]                             name <- restart$name
[17:47:03.759]                             if (is.null(name)) 
[17:47:03.759]                               next
[17:47:03.759]                             if (!grepl(pattern, name)) 
[17:47:03.759]                               next
[17:47:03.759]                             invokeRestart(restart)
[17:47:03.759]                             muffled <- TRUE
[17:47:03.759]                             break
[17:47:03.759]                           }
[17:47:03.759]                         }
[17:47:03.759]                       }
[17:47:03.759]                       invisible(muffled)
[17:47:03.759]                     }
[17:47:03.759]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.759]                   }
[17:47:03.759]                 }
[17:47:03.759]             }
[17:47:03.759]         }))
[17:47:03.759]     }, error = function(ex) {
[17:47:03.759]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:03.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.759]                 ...future.rng), started = ...future.startTime, 
[17:47:03.759]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:03.759]             version = "1.8"), class = "FutureResult")
[17:47:03.759]     }, finally = {
[17:47:03.759]         if (!identical(...future.workdir, getwd())) 
[17:47:03.759]             setwd(...future.workdir)
[17:47:03.759]         {
[17:47:03.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:03.759]                 ...future.oldOptions$nwarnings <- NULL
[17:47:03.759]             }
[17:47:03.759]             base::options(...future.oldOptions)
[17:47:03.759]             if (.Platform$OS.type == "windows") {
[17:47:03.759]                 old_names <- names(...future.oldEnvVars)
[17:47:03.759]                 envs <- base::Sys.getenv()
[17:47:03.759]                 names <- names(envs)
[17:47:03.759]                 common <- intersect(names, old_names)
[17:47:03.759]                 added <- setdiff(names, old_names)
[17:47:03.759]                 removed <- setdiff(old_names, names)
[17:47:03.759]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:03.759]                   envs[common]]
[17:47:03.759]                 NAMES <- toupper(changed)
[17:47:03.759]                 args <- list()
[17:47:03.759]                 for (kk in seq_along(NAMES)) {
[17:47:03.759]                   name <- changed[[kk]]
[17:47:03.759]                   NAME <- NAMES[[kk]]
[17:47:03.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.759]                     next
[17:47:03.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.759]                 }
[17:47:03.759]                 NAMES <- toupper(added)
[17:47:03.759]                 for (kk in seq_along(NAMES)) {
[17:47:03.759]                   name <- added[[kk]]
[17:47:03.759]                   NAME <- NAMES[[kk]]
[17:47:03.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.759]                     next
[17:47:03.759]                   args[[name]] <- ""
[17:47:03.759]                 }
[17:47:03.759]                 NAMES <- toupper(removed)
[17:47:03.759]                 for (kk in seq_along(NAMES)) {
[17:47:03.759]                   name <- removed[[kk]]
[17:47:03.759]                   NAME <- NAMES[[kk]]
[17:47:03.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.759]                     next
[17:47:03.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.759]                 }
[17:47:03.759]                 if (length(args) > 0) 
[17:47:03.759]                   base::do.call(base::Sys.setenv, args = args)
[17:47:03.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:03.759]             }
[17:47:03.759]             else {
[17:47:03.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:03.759]             }
[17:47:03.759]             {
[17:47:03.759]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:03.759]                   0L) {
[17:47:03.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:03.759]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:03.759]                   base::options(opts)
[17:47:03.759]                 }
[17:47:03.759]                 {
[17:47:03.759]                   {
[17:47:03.759]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:03.759]                     NULL
[17:47:03.759]                   }
[17:47:03.759]                   options(future.plan = NULL)
[17:47:03.759]                   if (is.na(NA_character_)) 
[17:47:03.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:03.759]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:03.759]                     .init = FALSE)
[17:47:03.759]                 }
[17:47:03.759]             }
[17:47:03.759]         }
[17:47:03.759]     })
[17:47:03.759]     if (TRUE) {
[17:47:03.759]         base::sink(type = "output", split = FALSE)
[17:47:03.759]         if (TRUE) {
[17:47:03.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:03.759]         }
[17:47:03.759]         else {
[17:47:03.759]             ...future.result["stdout"] <- base::list(NULL)
[17:47:03.759]         }
[17:47:03.759]         base::close(...future.stdout)
[17:47:03.759]         ...future.stdout <- NULL
[17:47:03.759]     }
[17:47:03.759]     ...future.result$conditions <- ...future.conditions
[17:47:03.759]     ...future.result$finished <- base::Sys.time()
[17:47:03.759]     ...future.result
[17:47:03.759] }
[17:47:03.762] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:47:03.762] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:47:03.762] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:47:03.763] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:47:03.763] MultisessionFuture started
[17:47:03.763] - Launch lazy future ... done
[17:47:03.763] run() for ‘MultisessionFuture’ ... done
[17:47:03.764] result() for ClusterFuture ...
[17:47:03.764] receiveMessageFromWorker() for ClusterFuture ...
[17:47:03.764] - Validating connection of MultisessionFuture
[17:47:03.765] - received message: FutureResult
[17:47:03.765] - Received FutureResult
[17:47:03.765] - Erased future from FutureRegistry
[17:47:03.765] result() for ClusterFuture ...
[17:47:03.765] - result already collected: FutureResult
[17:47:03.765] result() for ClusterFuture ... done
[17:47:03.766] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:03.766] result() for ClusterFuture ... done
[17:47:03.766] result() for ClusterFuture ...
[17:47:03.766] - result already collected: FutureResult
[17:47:03.766] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:03.766] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:03.767] Searching for globals...
[17:47:03.769] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:47:03.769] Searching for globals ... DONE
[17:47:03.769] Resolving globals: TRUE
[17:47:03.769] Resolving any globals that are futures ...
[17:47:03.769] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:47:03.769] Resolving any globals that are futures ... DONE
[17:47:03.770] Resolving futures part of globals (recursively) ...
[17:47:03.770] resolve() on list ...
[17:47:03.770]  recursive: 99
[17:47:03.770]  length: 2
[17:47:03.770]  elements: ‘x’, ‘name’
[17:47:03.770]  length: 1 (resolved future 1)
[17:47:03.770]  length: 0 (resolved future 2)
[17:47:03.770] resolve() on list ... DONE
[17:47:03.770] - globals: [2] ‘x’, ‘name’
[17:47:03.771] Resolving futures part of globals (recursively) ... DONE
[17:47:03.771] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:03.771] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[17:47:03.771] - globals: [2] ‘x’, ‘name’
[17:47:03.771] 
[17:47:03.772] getGlobalsAndPackages() ... DONE
[17:47:03.772] run() for ‘Future’ ...
[17:47:03.772] - state: ‘created’
[17:47:03.772] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:03.785] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:03.785] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:03.785]   - Field: ‘node’
[17:47:03.785]   - Field: ‘label’
[17:47:03.786]   - Field: ‘local’
[17:47:03.786]   - Field: ‘owner’
[17:47:03.786]   - Field: ‘envir’
[17:47:03.786]   - Field: ‘workers’
[17:47:03.786]   - Field: ‘packages’
[17:47:03.786]   - Field: ‘gc’
[17:47:03.786]   - Field: ‘conditions’
[17:47:03.786]   - Field: ‘persistent’
[17:47:03.786]   - Field: ‘expr’
[17:47:03.786]   - Field: ‘uuid’
[17:47:03.786]   - Field: ‘seed’
[17:47:03.787]   - Field: ‘version’
[17:47:03.787]   - Field: ‘result’
[17:47:03.787]   - Field: ‘asynchronous’
[17:47:03.787]   - Field: ‘calls’
[17:47:03.787]   - Field: ‘globals’
[17:47:03.787]   - Field: ‘stdout’
[17:47:03.787]   - Field: ‘earlySignal’
[17:47:03.787]   - Field: ‘lazy’
[17:47:03.787]   - Field: ‘state’
[17:47:03.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:03.788] - Launch lazy future ...
[17:47:03.788] Packages needed by the future expression (n = 0): <none>
[17:47:03.788] Packages needed by future strategies (n = 0): <none>
[17:47:03.788] {
[17:47:03.788]     {
[17:47:03.788]         {
[17:47:03.788]             ...future.startTime <- base::Sys.time()
[17:47:03.788]             {
[17:47:03.788]                 {
[17:47:03.788]                   {
[17:47:03.788]                     {
[17:47:03.788]                       base::local({
[17:47:03.788]                         has_future <- base::requireNamespace("future", 
[17:47:03.788]                           quietly = TRUE)
[17:47:03.788]                         if (has_future) {
[17:47:03.788]                           ns <- base::getNamespace("future")
[17:47:03.788]                           version <- ns[[".package"]][["version"]]
[17:47:03.788]                           if (is.null(version)) 
[17:47:03.788]                             version <- utils::packageVersion("future")
[17:47:03.788]                         }
[17:47:03.788]                         else {
[17:47:03.788]                           version <- NULL
[17:47:03.788]                         }
[17:47:03.788]                         if (!has_future || version < "1.8.0") {
[17:47:03.788]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:03.788]                             "", base::R.version$version.string), 
[17:47:03.788]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:03.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:03.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:03.788]                               "release", "version")], collapse = " "), 
[17:47:03.788]                             hostname = base::Sys.info()[["nodename"]])
[17:47:03.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:03.788]                             info)
[17:47:03.788]                           info <- base::paste(info, collapse = "; ")
[17:47:03.788]                           if (!has_future) {
[17:47:03.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:03.788]                               info)
[17:47:03.788]                           }
[17:47:03.788]                           else {
[17:47:03.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:03.788]                               info, version)
[17:47:03.788]                           }
[17:47:03.788]                           base::stop(msg)
[17:47:03.788]                         }
[17:47:03.788]                       })
[17:47:03.788]                     }
[17:47:03.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:03.788]                     base::options(mc.cores = 1L)
[17:47:03.788]                   }
[17:47:03.788]                   ...future.strategy.old <- future::plan("list")
[17:47:03.788]                   options(future.plan = NULL)
[17:47:03.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:03.788]                 }
[17:47:03.788]                 ...future.workdir <- getwd()
[17:47:03.788]             }
[17:47:03.788]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:03.788]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:03.788]         }
[17:47:03.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:03.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:03.788]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:03.788]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:03.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:03.788]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:03.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:03.788]             base::names(...future.oldOptions))
[17:47:03.788]     }
[17:47:03.788]     if (FALSE) {
[17:47:03.788]     }
[17:47:03.788]     else {
[17:47:03.788]         if (TRUE) {
[17:47:03.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:03.788]                 open = "w")
[17:47:03.788]         }
[17:47:03.788]         else {
[17:47:03.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:03.788]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:03.788]         }
[17:47:03.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:03.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:03.788]             base::sink(type = "output", split = FALSE)
[17:47:03.788]             base::close(...future.stdout)
[17:47:03.788]         }, add = TRUE)
[17:47:03.788]     }
[17:47:03.788]     ...future.frame <- base::sys.nframe()
[17:47:03.788]     ...future.conditions <- base::list()
[17:47:03.788]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:03.788]     if (FALSE) {
[17:47:03.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:03.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:03.788]     }
[17:47:03.788]     ...future.result <- base::tryCatch({
[17:47:03.788]         base::withCallingHandlers({
[17:47:03.788]             ...future.value <- base::withVisible(base::local({
[17:47:03.788]                 ...future.makeSendCondition <- base::local({
[17:47:03.788]                   sendCondition <- NULL
[17:47:03.788]                   function(frame = 1L) {
[17:47:03.788]                     if (is.function(sendCondition)) 
[17:47:03.788]                       return(sendCondition)
[17:47:03.788]                     ns <- getNamespace("parallel")
[17:47:03.788]                     if (exists("sendData", mode = "function", 
[17:47:03.788]                       envir = ns)) {
[17:47:03.788]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:03.788]                         envir = ns)
[17:47:03.788]                       envir <- sys.frame(frame)
[17:47:03.788]                       master <- NULL
[17:47:03.788]                       while (!identical(envir, .GlobalEnv) && 
[17:47:03.788]                         !identical(envir, emptyenv())) {
[17:47:03.788]                         if (exists("master", mode = "list", envir = envir, 
[17:47:03.788]                           inherits = FALSE)) {
[17:47:03.788]                           master <- get("master", mode = "list", 
[17:47:03.788]                             envir = envir, inherits = FALSE)
[17:47:03.788]                           if (inherits(master, c("SOCKnode", 
[17:47:03.788]                             "SOCK0node"))) {
[17:47:03.788]                             sendCondition <<- function(cond) {
[17:47:03.788]                               data <- list(type = "VALUE", value = cond, 
[17:47:03.788]                                 success = TRUE)
[17:47:03.788]                               parallel_sendData(master, data)
[17:47:03.788]                             }
[17:47:03.788]                             return(sendCondition)
[17:47:03.788]                           }
[17:47:03.788]                         }
[17:47:03.788]                         frame <- frame + 1L
[17:47:03.788]                         envir <- sys.frame(frame)
[17:47:03.788]                       }
[17:47:03.788]                     }
[17:47:03.788]                     sendCondition <<- function(cond) NULL
[17:47:03.788]                   }
[17:47:03.788]                 })
[17:47:03.788]                 withCallingHandlers({
[17:47:03.788]                   {
[17:47:03.788]                     x[name] <- list(1)
[17:47:03.788]                     x
[17:47:03.788]                   }
[17:47:03.788]                 }, immediateCondition = function(cond) {
[17:47:03.788]                   sendCondition <- ...future.makeSendCondition()
[17:47:03.788]                   sendCondition(cond)
[17:47:03.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.788]                   {
[17:47:03.788]                     inherits <- base::inherits
[17:47:03.788]                     invokeRestart <- base::invokeRestart
[17:47:03.788]                     is.null <- base::is.null
[17:47:03.788]                     muffled <- FALSE
[17:47:03.788]                     if (inherits(cond, "message")) {
[17:47:03.788]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:03.788]                       if (muffled) 
[17:47:03.788]                         invokeRestart("muffleMessage")
[17:47:03.788]                     }
[17:47:03.788]                     else if (inherits(cond, "warning")) {
[17:47:03.788]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:03.788]                       if (muffled) 
[17:47:03.788]                         invokeRestart("muffleWarning")
[17:47:03.788]                     }
[17:47:03.788]                     else if (inherits(cond, "condition")) {
[17:47:03.788]                       if (!is.null(pattern)) {
[17:47:03.788]                         computeRestarts <- base::computeRestarts
[17:47:03.788]                         grepl <- base::grepl
[17:47:03.788]                         restarts <- computeRestarts(cond)
[17:47:03.788]                         for (restart in restarts) {
[17:47:03.788]                           name <- restart$name
[17:47:03.788]                           if (is.null(name)) 
[17:47:03.788]                             next
[17:47:03.788]                           if (!grepl(pattern, name)) 
[17:47:03.788]                             next
[17:47:03.788]                           invokeRestart(restart)
[17:47:03.788]                           muffled <- TRUE
[17:47:03.788]                           break
[17:47:03.788]                         }
[17:47:03.788]                       }
[17:47:03.788]                     }
[17:47:03.788]                     invisible(muffled)
[17:47:03.788]                   }
[17:47:03.788]                   muffleCondition(cond)
[17:47:03.788]                 })
[17:47:03.788]             }))
[17:47:03.788]             future::FutureResult(value = ...future.value$value, 
[17:47:03.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.788]                   ...future.rng), globalenv = if (FALSE) 
[17:47:03.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:03.788]                     ...future.globalenv.names))
[17:47:03.788]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:03.788]         }, condition = base::local({
[17:47:03.788]             c <- base::c
[17:47:03.788]             inherits <- base::inherits
[17:47:03.788]             invokeRestart <- base::invokeRestart
[17:47:03.788]             length <- base::length
[17:47:03.788]             list <- base::list
[17:47:03.788]             seq.int <- base::seq.int
[17:47:03.788]             signalCondition <- base::signalCondition
[17:47:03.788]             sys.calls <- base::sys.calls
[17:47:03.788]             `[[` <- base::`[[`
[17:47:03.788]             `+` <- base::`+`
[17:47:03.788]             `<<-` <- base::`<<-`
[17:47:03.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:03.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:03.788]                   3L)]
[17:47:03.788]             }
[17:47:03.788]             function(cond) {
[17:47:03.788]                 is_error <- inherits(cond, "error")
[17:47:03.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:03.788]                   NULL)
[17:47:03.788]                 if (is_error) {
[17:47:03.788]                   sessionInformation <- function() {
[17:47:03.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:03.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:03.788]                       search = base::search(), system = base::Sys.info())
[17:47:03.788]                   }
[17:47:03.788]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:03.788]                     cond$call), session = sessionInformation(), 
[17:47:03.788]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:03.788]                   signalCondition(cond)
[17:47:03.788]                 }
[17:47:03.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:03.788]                 "immediateCondition"))) {
[17:47:03.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:03.788]                   ...future.conditions[[length(...future.conditions) + 
[17:47:03.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:03.788]                   if (TRUE && !signal) {
[17:47:03.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.788]                     {
[17:47:03.788]                       inherits <- base::inherits
[17:47:03.788]                       invokeRestart <- base::invokeRestart
[17:47:03.788]                       is.null <- base::is.null
[17:47:03.788]                       muffled <- FALSE
[17:47:03.788]                       if (inherits(cond, "message")) {
[17:47:03.788]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.788]                         if (muffled) 
[17:47:03.788]                           invokeRestart("muffleMessage")
[17:47:03.788]                       }
[17:47:03.788]                       else if (inherits(cond, "warning")) {
[17:47:03.788]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.788]                         if (muffled) 
[17:47:03.788]                           invokeRestart("muffleWarning")
[17:47:03.788]                       }
[17:47:03.788]                       else if (inherits(cond, "condition")) {
[17:47:03.788]                         if (!is.null(pattern)) {
[17:47:03.788]                           computeRestarts <- base::computeRestarts
[17:47:03.788]                           grepl <- base::grepl
[17:47:03.788]                           restarts <- computeRestarts(cond)
[17:47:03.788]                           for (restart in restarts) {
[17:47:03.788]                             name <- restart$name
[17:47:03.788]                             if (is.null(name)) 
[17:47:03.788]                               next
[17:47:03.788]                             if (!grepl(pattern, name)) 
[17:47:03.788]                               next
[17:47:03.788]                             invokeRestart(restart)
[17:47:03.788]                             muffled <- TRUE
[17:47:03.788]                             break
[17:47:03.788]                           }
[17:47:03.788]                         }
[17:47:03.788]                       }
[17:47:03.788]                       invisible(muffled)
[17:47:03.788]                     }
[17:47:03.788]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.788]                   }
[17:47:03.788]                 }
[17:47:03.788]                 else {
[17:47:03.788]                   if (TRUE) {
[17:47:03.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:03.788]                     {
[17:47:03.788]                       inherits <- base::inherits
[17:47:03.788]                       invokeRestart <- base::invokeRestart
[17:47:03.788]                       is.null <- base::is.null
[17:47:03.788]                       muffled <- FALSE
[17:47:03.788]                       if (inherits(cond, "message")) {
[17:47:03.788]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:03.788]                         if (muffled) 
[17:47:03.788]                           invokeRestart("muffleMessage")
[17:47:03.788]                       }
[17:47:03.788]                       else if (inherits(cond, "warning")) {
[17:47:03.788]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:03.788]                         if (muffled) 
[17:47:03.788]                           invokeRestart("muffleWarning")
[17:47:03.788]                       }
[17:47:03.788]                       else if (inherits(cond, "condition")) {
[17:47:03.788]                         if (!is.null(pattern)) {
[17:47:03.788]                           computeRestarts <- base::computeRestarts
[17:47:03.788]                           grepl <- base::grepl
[17:47:03.788]                           restarts <- computeRestarts(cond)
[17:47:03.788]                           for (restart in restarts) {
[17:47:03.788]                             name <- restart$name
[17:47:03.788]                             if (is.null(name)) 
[17:47:03.788]                               next
[17:47:03.788]                             if (!grepl(pattern, name)) 
[17:47:03.788]                               next
[17:47:03.788]                             invokeRestart(restart)
[17:47:03.788]                             muffled <- TRUE
[17:47:03.788]                             break
[17:47:03.788]                           }
[17:47:03.788]                         }
[17:47:03.788]                       }
[17:47:03.788]                       invisible(muffled)
[17:47:03.788]                     }
[17:47:03.788]                     muffleCondition(cond, pattern = "^muffle")
[17:47:03.788]                   }
[17:47:03.788]                 }
[17:47:03.788]             }
[17:47:03.788]         }))
[17:47:03.788]     }, error = function(ex) {
[17:47:03.788]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:03.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:03.788]                 ...future.rng), started = ...future.startTime, 
[17:47:03.788]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:03.788]             version = "1.8"), class = "FutureResult")
[17:47:03.788]     }, finally = {
[17:47:03.788]         if (!identical(...future.workdir, getwd())) 
[17:47:03.788]             setwd(...future.workdir)
[17:47:03.788]         {
[17:47:03.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:03.788]                 ...future.oldOptions$nwarnings <- NULL
[17:47:03.788]             }
[17:47:03.788]             base::options(...future.oldOptions)
[17:47:03.788]             if (.Platform$OS.type == "windows") {
[17:47:03.788]                 old_names <- names(...future.oldEnvVars)
[17:47:03.788]                 envs <- base::Sys.getenv()
[17:47:03.788]                 names <- names(envs)
[17:47:03.788]                 common <- intersect(names, old_names)
[17:47:03.788]                 added <- setdiff(names, old_names)
[17:47:03.788]                 removed <- setdiff(old_names, names)
[17:47:03.788]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:03.788]                   envs[common]]
[17:47:03.788]                 NAMES <- toupper(changed)
[17:47:03.788]                 args <- list()
[17:47:03.788]                 for (kk in seq_along(NAMES)) {
[17:47:03.788]                   name <- changed[[kk]]
[17:47:03.788]                   NAME <- NAMES[[kk]]
[17:47:03.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.788]                     next
[17:47:03.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.788]                 }
[17:47:03.788]                 NAMES <- toupper(added)
[17:47:03.788]                 for (kk in seq_along(NAMES)) {
[17:47:03.788]                   name <- added[[kk]]
[17:47:03.788]                   NAME <- NAMES[[kk]]
[17:47:03.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.788]                     next
[17:47:03.788]                   args[[name]] <- ""
[17:47:03.788]                 }
[17:47:03.788]                 NAMES <- toupper(removed)
[17:47:03.788]                 for (kk in seq_along(NAMES)) {
[17:47:03.788]                   name <- removed[[kk]]
[17:47:03.788]                   NAME <- NAMES[[kk]]
[17:47:03.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:03.788]                     next
[17:47:03.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:03.788]                 }
[17:47:03.788]                 if (length(args) > 0) 
[17:47:03.788]                   base::do.call(base::Sys.setenv, args = args)
[17:47:03.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:03.788]             }
[17:47:03.788]             else {
[17:47:03.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:03.788]             }
[17:47:03.788]             {
[17:47:03.788]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:03.788]                   0L) {
[17:47:03.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:03.788]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:03.788]                   base::options(opts)
[17:47:03.788]                 }
[17:47:03.788]                 {
[17:47:03.788]                   {
[17:47:03.788]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:03.788]                     NULL
[17:47:03.788]                   }
[17:47:03.788]                   options(future.plan = NULL)
[17:47:03.788]                   if (is.na(NA_character_)) 
[17:47:03.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:03.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:03.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:03.788]                     .init = FALSE)
[17:47:03.788]                 }
[17:47:03.788]             }
[17:47:03.788]         }
[17:47:03.788]     })
[17:47:03.788]     if (TRUE) {
[17:47:03.788]         base::sink(type = "output", split = FALSE)
[17:47:03.788]         if (TRUE) {
[17:47:03.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:03.788]         }
[17:47:03.788]         else {
[17:47:03.788]             ...future.result["stdout"] <- base::list(NULL)
[17:47:03.788]         }
[17:47:03.788]         base::close(...future.stdout)
[17:47:03.788]         ...future.stdout <- NULL
[17:47:03.788]     }
[17:47:03.788]     ...future.result$conditions <- ...future.conditions
[17:47:03.788]     ...future.result$finished <- base::Sys.time()
[17:47:03.788]     ...future.result
[17:47:03.788] }
[17:47:03.791] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:47:03.791] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:47:03.791] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:47:03.791] Exporting ‘name’ (112 bytes) to cluster node #1 ...
[17:47:03.792] Exporting ‘name’ (112 bytes) to cluster node #1 ... DONE
[17:47:03.792] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:47:03.792] MultisessionFuture started
[17:47:03.793] - Launch lazy future ... done
[17:47:03.793] run() for ‘MultisessionFuture’ ... done
[17:47:03.793] result() for ClusterFuture ...
[17:47:03.793] receiveMessageFromWorker() for ClusterFuture ...
[17:47:03.793] - Validating connection of MultisessionFuture
[17:47:03.794] - received message: FutureResult
[17:47:03.794] - Received FutureResult
[17:47:03.795] - Erased future from FutureRegistry
[17:47:03.795] result() for ClusterFuture ...
[17:47:03.795] - result already collected: FutureResult
[17:47:03.795] result() for ClusterFuture ... done
[17:47:03.795] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:03.795] result() for ClusterFuture ... done
[17:47:03.795] result() for ClusterFuture ...
[17:47:03.795] - result already collected: FutureResult
[17:47:03.795] result() for ClusterFuture ... done
$a
[1] 1

Testing with 2 cores ... DONE
> 
> message("*** Globals - subassignments w/ x$a <- value ... DONE")
*** Globals - subassignments w/ x$a <- value ... DONE
> 
> message("*** Globals - subassignments ... DONE")
*** Globals - subassignments ... DONE
> 
> source("incl/end.R")
[17:47:03.796] plan(): Setting new future strategy stack:
[17:47:03.796] List of future strategies:
[17:47:03.796] 1. FutureStrategy:
[17:47:03.796]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:03.796]    - tweaked: FALSE
[17:47:03.796]    - call: future::plan(oplan)
[17:47:03.799] plan(): nbrOfWorkers() = 1
> 
