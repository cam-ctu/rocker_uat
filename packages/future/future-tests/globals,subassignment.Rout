
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[18:04:46.813] plan(): Setting new future strategy stack:
[18:04:46.814] List of future strategies:
[18:04:46.814] 1. sequential:
[18:04:46.814]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:46.814]    - tweaked: FALSE
[18:04:46.814]    - call: future::plan("sequential")
[18:04:46.840] plan(): nbrOfWorkers() = 1
> 
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Globals - subassignments ...")
*** Globals - subassignments ...
> 
> message("*** Globals - subassignments w/ x$a <- value ...")
*** Globals - subassignments w/ x$a <- value ...
> 
> ## Truth:
> x <- x0 <- list()
> y0 <- list(a = 1)
> str(list(x = x, y0 = y0))
List of 2
 $ x : list()
 $ y0:List of 1
  ..$ a: num 1
> 
> y <- local({
+   x$a <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x[["a"]] <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x["a"] <- list(1)
+   x
+ })
> stopifnot(identical(y, y0))
> 
> stopifnot(identical(x, list()))
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Same with forced lazy evaluation
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     } %lazy% TRUE
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## 'x' is _not_ a global variable here
+     x <- list()
+     y %<-% {
+       x <- list(b = 2)
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, list(b = 2, a = 1)))
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x[["a"]] <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+     
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x["a"] <- list(1)
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     name <- "a"
+     y %<-% {
+       x[name] <- list(1)
+       x
+     }
+     rm(list = c("x", "name"))
+     print(y)
+     stopifnot(identical(y, y0))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[18:04:46.976] plan(): Setting new future strategy stack:
[18:04:46.976] List of future strategies:
[18:04:46.976] 1. sequential:
[18:04:46.976]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:46.976]    - tweaked: FALSE
[18:04:46.976]    - call: plan(strategy)
[18:04:47.001] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.003] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.004] Searching for globals...
[18:04:47.018] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.018] Searching for globals ... DONE
[18:04:47.018] Resolving globals: TRUE
[18:04:47.018] Resolving any globals that are futures ...
[18:04:47.019] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.019] Resolving any globals that are futures ... DONE
[18:04:47.020] Resolving futures part of globals (recursively) ...
[18:04:47.021] resolve() on list ...
[18:04:47.021]  recursive: 99
[18:04:47.022]  length: 1
[18:04:47.022]  elements: ‘x’
[18:04:47.022]  length: 0 (resolved future 1)
[18:04:47.023] resolve() on list ... DONE
[18:04:47.023] - globals: [1] ‘x’
[18:04:47.023] Resolving futures part of globals (recursively) ... DONE
[18:04:47.024] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.025] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.025] - globals: [1] ‘x’
[18:04:47.025] 
[18:04:47.025] getGlobalsAndPackages() ... DONE
[18:04:47.026] run() for ‘Future’ ...
[18:04:47.027] - state: ‘created’
[18:04:47.027] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:47.028] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:47.028] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:47.028]   - Field: ‘label’
[18:04:47.028]   - Field: ‘local’
[18:04:47.028]   - Field: ‘owner’
[18:04:47.029]   - Field: ‘envir’
[18:04:47.029]   - Field: ‘packages’
[18:04:47.029]   - Field: ‘gc’
[18:04:47.029]   - Field: ‘conditions’
[18:04:47.029]   - Field: ‘expr’
[18:04:47.030]   - Field: ‘uuid’
[18:04:47.030]   - Field: ‘seed’
[18:04:47.030]   - Field: ‘version’
[18:04:47.030]   - Field: ‘result’
[18:04:47.030]   - Field: ‘asynchronous’
[18:04:47.031]   - Field: ‘calls’
[18:04:47.031]   - Field: ‘globals’
[18:04:47.031]   - Field: ‘stdout’
[18:04:47.031]   - Field: ‘earlySignal’
[18:04:47.031]   - Field: ‘lazy’
[18:04:47.032]   - Field: ‘state’
[18:04:47.032] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:47.032] - Launch lazy future ...
[18:04:47.033] Packages needed by the future expression (n = 0): <none>
[18:04:47.033] Packages needed by future strategies (n = 0): <none>
[18:04:47.035] {
[18:04:47.035]     {
[18:04:47.035]         {
[18:04:47.035]             ...future.startTime <- base::Sys.time()
[18:04:47.035]             {
[18:04:47.035]                 {
[18:04:47.035]                   {
[18:04:47.035]                     base::local({
[18:04:47.035]                       has_future <- base::requireNamespace("future", 
[18:04:47.035]                         quietly = TRUE)
[18:04:47.035]                       if (has_future) {
[18:04:47.035]                         ns <- base::getNamespace("future")
[18:04:47.035]                         version <- ns[[".package"]][["version"]]
[18:04:47.035]                         if (is.null(version)) 
[18:04:47.035]                           version <- utils::packageVersion("future")
[18:04:47.035]                       }
[18:04:47.035]                       else {
[18:04:47.035]                         version <- NULL
[18:04:47.035]                       }
[18:04:47.035]                       if (!has_future || version < "1.8.0") {
[18:04:47.035]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.035]                           "", base::R.version$version.string), 
[18:04:47.035]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:47.035]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.035]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.035]                             "release", "version")], collapse = " "), 
[18:04:47.035]                           hostname = base::Sys.info()[["nodename"]])
[18:04:47.035]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.035]                           info)
[18:04:47.035]                         info <- base::paste(info, collapse = "; ")
[18:04:47.035]                         if (!has_future) {
[18:04:47.035]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.035]                             info)
[18:04:47.035]                         }
[18:04:47.035]                         else {
[18:04:47.035]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.035]                             info, version)
[18:04:47.035]                         }
[18:04:47.035]                         base::stop(msg)
[18:04:47.035]                       }
[18:04:47.035]                     })
[18:04:47.035]                   }
[18:04:47.035]                   ...future.strategy.old <- future::plan("list")
[18:04:47.035]                   options(future.plan = NULL)
[18:04:47.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.035]                 }
[18:04:47.035]                 ...future.workdir <- getwd()
[18:04:47.035]             }
[18:04:47.035]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.035]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.035]         }
[18:04:47.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.035]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.035]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.035]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.035]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.035]             base::names(...future.oldOptions))
[18:04:47.035]     }
[18:04:47.035]     if (FALSE) {
[18:04:47.035]     }
[18:04:47.035]     else {
[18:04:47.035]         if (TRUE) {
[18:04:47.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.035]                 open = "w")
[18:04:47.035]         }
[18:04:47.035]         else {
[18:04:47.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.035]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.035]         }
[18:04:47.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.035]             base::sink(type = "output", split = FALSE)
[18:04:47.035]             base::close(...future.stdout)
[18:04:47.035]         }, add = TRUE)
[18:04:47.035]     }
[18:04:47.035]     ...future.frame <- base::sys.nframe()
[18:04:47.035]     ...future.conditions <- base::list()
[18:04:47.035]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.035]     if (FALSE) {
[18:04:47.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.035]     }
[18:04:47.035]     ...future.result <- base::tryCatch({
[18:04:47.035]         base::withCallingHandlers({
[18:04:47.035]             ...future.value <- base::withVisible(base::local({
[18:04:47.035]                 x$a <- 1
[18:04:47.035]                 x
[18:04:47.035]             }))
[18:04:47.035]             future::FutureResult(value = ...future.value$value, 
[18:04:47.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.035]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.035]                     ...future.globalenv.names))
[18:04:47.035]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.035]         }, condition = base::local({
[18:04:47.035]             c <- base::c
[18:04:47.035]             inherits <- base::inherits
[18:04:47.035]             invokeRestart <- base::invokeRestart
[18:04:47.035]             length <- base::length
[18:04:47.035]             list <- base::list
[18:04:47.035]             seq.int <- base::seq.int
[18:04:47.035]             signalCondition <- base::signalCondition
[18:04:47.035]             sys.calls <- base::sys.calls
[18:04:47.035]             `[[` <- base::`[[`
[18:04:47.035]             `+` <- base::`+`
[18:04:47.035]             `<<-` <- base::`<<-`
[18:04:47.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.035]                   3L)]
[18:04:47.035]             }
[18:04:47.035]             function(cond) {
[18:04:47.035]                 is_error <- inherits(cond, "error")
[18:04:47.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.035]                   NULL)
[18:04:47.035]                 if (is_error) {
[18:04:47.035]                   sessionInformation <- function() {
[18:04:47.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.035]                       search = base::search(), system = base::Sys.info())
[18:04:47.035]                   }
[18:04:47.035]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.035]                     cond$call), session = sessionInformation(), 
[18:04:47.035]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.035]                   signalCondition(cond)
[18:04:47.035]                 }
[18:04:47.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.035]                 "immediateCondition"))) {
[18:04:47.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.035]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.035]                   if (TRUE && !signal) {
[18:04:47.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.035]                     {
[18:04:47.035]                       inherits <- base::inherits
[18:04:47.035]                       invokeRestart <- base::invokeRestart
[18:04:47.035]                       is.null <- base::is.null
[18:04:47.035]                       muffled <- FALSE
[18:04:47.035]                       if (inherits(cond, "message")) {
[18:04:47.035]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.035]                         if (muffled) 
[18:04:47.035]                           invokeRestart("muffleMessage")
[18:04:47.035]                       }
[18:04:47.035]                       else if (inherits(cond, "warning")) {
[18:04:47.035]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.035]                         if (muffled) 
[18:04:47.035]                           invokeRestart("muffleWarning")
[18:04:47.035]                       }
[18:04:47.035]                       else if (inherits(cond, "condition")) {
[18:04:47.035]                         if (!is.null(pattern)) {
[18:04:47.035]                           computeRestarts <- base::computeRestarts
[18:04:47.035]                           grepl <- base::grepl
[18:04:47.035]                           restarts <- computeRestarts(cond)
[18:04:47.035]                           for (restart in restarts) {
[18:04:47.035]                             name <- restart$name
[18:04:47.035]                             if (is.null(name)) 
[18:04:47.035]                               next
[18:04:47.035]                             if (!grepl(pattern, name)) 
[18:04:47.035]                               next
[18:04:47.035]                             invokeRestart(restart)
[18:04:47.035]                             muffled <- TRUE
[18:04:47.035]                             break
[18:04:47.035]                           }
[18:04:47.035]                         }
[18:04:47.035]                       }
[18:04:47.035]                       invisible(muffled)
[18:04:47.035]                     }
[18:04:47.035]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.035]                   }
[18:04:47.035]                 }
[18:04:47.035]                 else {
[18:04:47.035]                   if (TRUE) {
[18:04:47.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.035]                     {
[18:04:47.035]                       inherits <- base::inherits
[18:04:47.035]                       invokeRestart <- base::invokeRestart
[18:04:47.035]                       is.null <- base::is.null
[18:04:47.035]                       muffled <- FALSE
[18:04:47.035]                       if (inherits(cond, "message")) {
[18:04:47.035]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.035]                         if (muffled) 
[18:04:47.035]                           invokeRestart("muffleMessage")
[18:04:47.035]                       }
[18:04:47.035]                       else if (inherits(cond, "warning")) {
[18:04:47.035]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.035]                         if (muffled) 
[18:04:47.035]                           invokeRestart("muffleWarning")
[18:04:47.035]                       }
[18:04:47.035]                       else if (inherits(cond, "condition")) {
[18:04:47.035]                         if (!is.null(pattern)) {
[18:04:47.035]                           computeRestarts <- base::computeRestarts
[18:04:47.035]                           grepl <- base::grepl
[18:04:47.035]                           restarts <- computeRestarts(cond)
[18:04:47.035]                           for (restart in restarts) {
[18:04:47.035]                             name <- restart$name
[18:04:47.035]                             if (is.null(name)) 
[18:04:47.035]                               next
[18:04:47.035]                             if (!grepl(pattern, name)) 
[18:04:47.035]                               next
[18:04:47.035]                             invokeRestart(restart)
[18:04:47.035]                             muffled <- TRUE
[18:04:47.035]                             break
[18:04:47.035]                           }
[18:04:47.035]                         }
[18:04:47.035]                       }
[18:04:47.035]                       invisible(muffled)
[18:04:47.035]                     }
[18:04:47.035]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.035]                   }
[18:04:47.035]                 }
[18:04:47.035]             }
[18:04:47.035]         }))
[18:04:47.035]     }, error = function(ex) {
[18:04:47.035]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.035]                 ...future.rng), started = ...future.startTime, 
[18:04:47.035]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.035]             version = "1.8"), class = "FutureResult")
[18:04:47.035]     }, finally = {
[18:04:47.035]         if (!identical(...future.workdir, getwd())) 
[18:04:47.035]             setwd(...future.workdir)
[18:04:47.035]         {
[18:04:47.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.035]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.035]             }
[18:04:47.035]             base::options(...future.oldOptions)
[18:04:47.035]             if (.Platform$OS.type == "windows") {
[18:04:47.035]                 old_names <- names(...future.oldEnvVars)
[18:04:47.035]                 envs <- base::Sys.getenv()
[18:04:47.035]                 names <- names(envs)
[18:04:47.035]                 common <- intersect(names, old_names)
[18:04:47.035]                 added <- setdiff(names, old_names)
[18:04:47.035]                 removed <- setdiff(old_names, names)
[18:04:47.035]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.035]                   envs[common]]
[18:04:47.035]                 NAMES <- toupper(changed)
[18:04:47.035]                 args <- list()
[18:04:47.035]                 for (kk in seq_along(NAMES)) {
[18:04:47.035]                   name <- changed[[kk]]
[18:04:47.035]                   NAME <- NAMES[[kk]]
[18:04:47.035]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.035]                     next
[18:04:47.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.035]                 }
[18:04:47.035]                 NAMES <- toupper(added)
[18:04:47.035]                 for (kk in seq_along(NAMES)) {
[18:04:47.035]                   name <- added[[kk]]
[18:04:47.035]                   NAME <- NAMES[[kk]]
[18:04:47.035]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.035]                     next
[18:04:47.035]                   args[[name]] <- ""
[18:04:47.035]                 }
[18:04:47.035]                 NAMES <- toupper(removed)
[18:04:47.035]                 for (kk in seq_along(NAMES)) {
[18:04:47.035]                   name <- removed[[kk]]
[18:04:47.035]                   NAME <- NAMES[[kk]]
[18:04:47.035]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.035]                     next
[18:04:47.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.035]                 }
[18:04:47.035]                 if (length(args) > 0) 
[18:04:47.035]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.035]             }
[18:04:47.035]             else {
[18:04:47.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.035]             }
[18:04:47.035]             {
[18:04:47.035]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.035]                   0L) {
[18:04:47.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.035]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.035]                   base::options(opts)
[18:04:47.035]                 }
[18:04:47.035]                 {
[18:04:47.035]                   {
[18:04:47.035]                     NULL
[18:04:47.035]                     RNGkind("Mersenne-Twister")
[18:04:47.035]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:47.035]                       inherits = FALSE)
[18:04:47.035]                   }
[18:04:47.035]                   options(future.plan = NULL)
[18:04:47.035]                   if (is.na(NA_character_)) 
[18:04:47.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.035]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.035]                     .init = FALSE)
[18:04:47.035]                 }
[18:04:47.035]             }
[18:04:47.035]         }
[18:04:47.035]     })
[18:04:47.035]     if (TRUE) {
[18:04:47.035]         base::sink(type = "output", split = FALSE)
[18:04:47.035]         if (TRUE) {
[18:04:47.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.035]         }
[18:04:47.035]         else {
[18:04:47.035]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.035]         }
[18:04:47.035]         base::close(...future.stdout)
[18:04:47.035]         ...future.stdout <- NULL
[18:04:47.035]     }
[18:04:47.035]     ...future.result$conditions <- ...future.conditions
[18:04:47.035]     ...future.result$finished <- base::Sys.time()
[18:04:47.035]     ...future.result
[18:04:47.035] }
[18:04:47.038] assign_globals() ...
[18:04:47.038] List of 1
[18:04:47.038]  $ x: list()
[18:04:47.038]  - attr(*, "where")=List of 1
[18:04:47.038]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.038]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.038]  - attr(*, "resolved")= logi TRUE
[18:04:47.038]  - attr(*, "total_size")= num 0
[18:04:47.038]  - attr(*, "already-done")= logi TRUE
[18:04:47.043] - copied ‘x’ to environment
[18:04:47.043] assign_globals() ... done
[18:04:47.044] plan(): Setting new future strategy stack:
[18:04:47.044] List of future strategies:
[18:04:47.044] 1. sequential:
[18:04:47.044]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.044]    - tweaked: FALSE
[18:04:47.044]    - call: NULL
[18:04:47.045] plan(): nbrOfWorkers() = 1
[18:04:47.047] plan(): Setting new future strategy stack:
[18:04:47.047] List of future strategies:
[18:04:47.047] 1. sequential:
[18:04:47.047]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.047]    - tweaked: FALSE
[18:04:47.047]    - call: plan(strategy)
[18:04:47.052] plan(): nbrOfWorkers() = 1
[18:04:47.052] SequentialFuture started (and completed)
[18:04:47.053] - Launch lazy future ... done
[18:04:47.053] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.054] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.055] Searching for globals...
[18:04:47.059] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.060] Searching for globals ... DONE
[18:04:47.060] Resolving globals: TRUE
[18:04:47.060] Resolving any globals that are futures ...
[18:04:47.060] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.061] Resolving any globals that are futures ... DONE
[18:04:47.061] Resolving futures part of globals (recursively) ...
[18:04:47.062] resolve() on list ...
[18:04:47.062]  recursive: 99
[18:04:47.062]  length: 1
[18:04:47.063]  elements: ‘x’
[18:04:47.063]  length: 0 (resolved future 1)
[18:04:47.063] resolve() on list ... DONE
[18:04:47.063] - globals: [1] ‘x’
[18:04:47.063] Resolving futures part of globals (recursively) ... DONE
[18:04:47.064] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.064] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.065] - globals: [1] ‘x’
[18:04:47.065] 
[18:04:47.065] getGlobalsAndPackages() ... DONE
[18:04:47.066] run() for ‘Future’ ...
[18:04:47.066] - state: ‘created’
[18:04:47.066] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:47.067] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:47.067] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:47.067]   - Field: ‘label’
[18:04:47.068]   - Field: ‘local’
[18:04:47.068]   - Field: ‘owner’
[18:04:47.068]   - Field: ‘envir’
[18:04:47.068]   - Field: ‘packages’
[18:04:47.068]   - Field: ‘gc’
[18:04:47.069]   - Field: ‘conditions’
[18:04:47.069]   - Field: ‘expr’
[18:04:47.069]   - Field: ‘uuid’
[18:04:47.069]   - Field: ‘seed’
[18:04:47.069]   - Field: ‘version’
[18:04:47.070]   - Field: ‘result’
[18:04:47.070]   - Field: ‘asynchronous’
[18:04:47.070]   - Field: ‘calls’
[18:04:47.070]   - Field: ‘globals’
[18:04:47.070]   - Field: ‘stdout’
[18:04:47.070]   - Field: ‘earlySignal’
[18:04:47.071]   - Field: ‘lazy’
[18:04:47.071]   - Field: ‘state’
[18:04:47.071] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:47.071] - Launch lazy future ...
[18:04:47.072] Packages needed by the future expression (n = 0): <none>
[18:04:47.072] Packages needed by future strategies (n = 0): <none>
[18:04:47.073] {
[18:04:47.073]     {
[18:04:47.073]         {
[18:04:47.073]             ...future.startTime <- base::Sys.time()
[18:04:47.073]             {
[18:04:47.073]                 {
[18:04:47.073]                   {
[18:04:47.073]                     base::local({
[18:04:47.073]                       has_future <- base::requireNamespace("future", 
[18:04:47.073]                         quietly = TRUE)
[18:04:47.073]                       if (has_future) {
[18:04:47.073]                         ns <- base::getNamespace("future")
[18:04:47.073]                         version <- ns[[".package"]][["version"]]
[18:04:47.073]                         if (is.null(version)) 
[18:04:47.073]                           version <- utils::packageVersion("future")
[18:04:47.073]                       }
[18:04:47.073]                       else {
[18:04:47.073]                         version <- NULL
[18:04:47.073]                       }
[18:04:47.073]                       if (!has_future || version < "1.8.0") {
[18:04:47.073]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.073]                           "", base::R.version$version.string), 
[18:04:47.073]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:47.073]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.073]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.073]                             "release", "version")], collapse = " "), 
[18:04:47.073]                           hostname = base::Sys.info()[["nodename"]])
[18:04:47.073]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.073]                           info)
[18:04:47.073]                         info <- base::paste(info, collapse = "; ")
[18:04:47.073]                         if (!has_future) {
[18:04:47.073]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.073]                             info)
[18:04:47.073]                         }
[18:04:47.073]                         else {
[18:04:47.073]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.073]                             info, version)
[18:04:47.073]                         }
[18:04:47.073]                         base::stop(msg)
[18:04:47.073]                       }
[18:04:47.073]                     })
[18:04:47.073]                   }
[18:04:47.073]                   ...future.strategy.old <- future::plan("list")
[18:04:47.073]                   options(future.plan = NULL)
[18:04:47.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.073]                 }
[18:04:47.073]                 ...future.workdir <- getwd()
[18:04:47.073]             }
[18:04:47.073]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.073]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.073]         }
[18:04:47.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.073]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.073]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.073]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.073]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.073]             base::names(...future.oldOptions))
[18:04:47.073]     }
[18:04:47.073]     if (FALSE) {
[18:04:47.073]     }
[18:04:47.073]     else {
[18:04:47.073]         if (TRUE) {
[18:04:47.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.073]                 open = "w")
[18:04:47.073]         }
[18:04:47.073]         else {
[18:04:47.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.073]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.073]         }
[18:04:47.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.073]             base::sink(type = "output", split = FALSE)
[18:04:47.073]             base::close(...future.stdout)
[18:04:47.073]         }, add = TRUE)
[18:04:47.073]     }
[18:04:47.073]     ...future.frame <- base::sys.nframe()
[18:04:47.073]     ...future.conditions <- base::list()
[18:04:47.073]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.073]     if (FALSE) {
[18:04:47.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.073]     }
[18:04:47.073]     ...future.result <- base::tryCatch({
[18:04:47.073]         base::withCallingHandlers({
[18:04:47.073]             ...future.value <- base::withVisible(base::local({
[18:04:47.073]                 x$a <- 1
[18:04:47.073]                 x
[18:04:47.073]             }))
[18:04:47.073]             future::FutureResult(value = ...future.value$value, 
[18:04:47.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.073]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.073]                     ...future.globalenv.names))
[18:04:47.073]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.073]         }, condition = base::local({
[18:04:47.073]             c <- base::c
[18:04:47.073]             inherits <- base::inherits
[18:04:47.073]             invokeRestart <- base::invokeRestart
[18:04:47.073]             length <- base::length
[18:04:47.073]             list <- base::list
[18:04:47.073]             seq.int <- base::seq.int
[18:04:47.073]             signalCondition <- base::signalCondition
[18:04:47.073]             sys.calls <- base::sys.calls
[18:04:47.073]             `[[` <- base::`[[`
[18:04:47.073]             `+` <- base::`+`
[18:04:47.073]             `<<-` <- base::`<<-`
[18:04:47.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.073]                   3L)]
[18:04:47.073]             }
[18:04:47.073]             function(cond) {
[18:04:47.073]                 is_error <- inherits(cond, "error")
[18:04:47.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.073]                   NULL)
[18:04:47.073]                 if (is_error) {
[18:04:47.073]                   sessionInformation <- function() {
[18:04:47.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.073]                       search = base::search(), system = base::Sys.info())
[18:04:47.073]                   }
[18:04:47.073]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.073]                     cond$call), session = sessionInformation(), 
[18:04:47.073]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.073]                   signalCondition(cond)
[18:04:47.073]                 }
[18:04:47.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.073]                 "immediateCondition"))) {
[18:04:47.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.073]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.073]                   if (TRUE && !signal) {
[18:04:47.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.073]                     {
[18:04:47.073]                       inherits <- base::inherits
[18:04:47.073]                       invokeRestart <- base::invokeRestart
[18:04:47.073]                       is.null <- base::is.null
[18:04:47.073]                       muffled <- FALSE
[18:04:47.073]                       if (inherits(cond, "message")) {
[18:04:47.073]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.073]                         if (muffled) 
[18:04:47.073]                           invokeRestart("muffleMessage")
[18:04:47.073]                       }
[18:04:47.073]                       else if (inherits(cond, "warning")) {
[18:04:47.073]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.073]                         if (muffled) 
[18:04:47.073]                           invokeRestart("muffleWarning")
[18:04:47.073]                       }
[18:04:47.073]                       else if (inherits(cond, "condition")) {
[18:04:47.073]                         if (!is.null(pattern)) {
[18:04:47.073]                           computeRestarts <- base::computeRestarts
[18:04:47.073]                           grepl <- base::grepl
[18:04:47.073]                           restarts <- computeRestarts(cond)
[18:04:47.073]                           for (restart in restarts) {
[18:04:47.073]                             name <- restart$name
[18:04:47.073]                             if (is.null(name)) 
[18:04:47.073]                               next
[18:04:47.073]                             if (!grepl(pattern, name)) 
[18:04:47.073]                               next
[18:04:47.073]                             invokeRestart(restart)
[18:04:47.073]                             muffled <- TRUE
[18:04:47.073]                             break
[18:04:47.073]                           }
[18:04:47.073]                         }
[18:04:47.073]                       }
[18:04:47.073]                       invisible(muffled)
[18:04:47.073]                     }
[18:04:47.073]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.073]                   }
[18:04:47.073]                 }
[18:04:47.073]                 else {
[18:04:47.073]                   if (TRUE) {
[18:04:47.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.073]                     {
[18:04:47.073]                       inherits <- base::inherits
[18:04:47.073]                       invokeRestart <- base::invokeRestart
[18:04:47.073]                       is.null <- base::is.null
[18:04:47.073]                       muffled <- FALSE
[18:04:47.073]                       if (inherits(cond, "message")) {
[18:04:47.073]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.073]                         if (muffled) 
[18:04:47.073]                           invokeRestart("muffleMessage")
[18:04:47.073]                       }
[18:04:47.073]                       else if (inherits(cond, "warning")) {
[18:04:47.073]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.073]                         if (muffled) 
[18:04:47.073]                           invokeRestart("muffleWarning")
[18:04:47.073]                       }
[18:04:47.073]                       else if (inherits(cond, "condition")) {
[18:04:47.073]                         if (!is.null(pattern)) {
[18:04:47.073]                           computeRestarts <- base::computeRestarts
[18:04:47.073]                           grepl <- base::grepl
[18:04:47.073]                           restarts <- computeRestarts(cond)
[18:04:47.073]                           for (restart in restarts) {
[18:04:47.073]                             name <- restart$name
[18:04:47.073]                             if (is.null(name)) 
[18:04:47.073]                               next
[18:04:47.073]                             if (!grepl(pattern, name)) 
[18:04:47.073]                               next
[18:04:47.073]                             invokeRestart(restart)
[18:04:47.073]                             muffled <- TRUE
[18:04:47.073]                             break
[18:04:47.073]                           }
[18:04:47.073]                         }
[18:04:47.073]                       }
[18:04:47.073]                       invisible(muffled)
[18:04:47.073]                     }
[18:04:47.073]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.073]                   }
[18:04:47.073]                 }
[18:04:47.073]             }
[18:04:47.073]         }))
[18:04:47.073]     }, error = function(ex) {
[18:04:47.073]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.073]                 ...future.rng), started = ...future.startTime, 
[18:04:47.073]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.073]             version = "1.8"), class = "FutureResult")
[18:04:47.073]     }, finally = {
[18:04:47.073]         if (!identical(...future.workdir, getwd())) 
[18:04:47.073]             setwd(...future.workdir)
[18:04:47.073]         {
[18:04:47.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.073]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.073]             }
[18:04:47.073]             base::options(...future.oldOptions)
[18:04:47.073]             if (.Platform$OS.type == "windows") {
[18:04:47.073]                 old_names <- names(...future.oldEnvVars)
[18:04:47.073]                 envs <- base::Sys.getenv()
[18:04:47.073]                 names <- names(envs)
[18:04:47.073]                 common <- intersect(names, old_names)
[18:04:47.073]                 added <- setdiff(names, old_names)
[18:04:47.073]                 removed <- setdiff(old_names, names)
[18:04:47.073]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.073]                   envs[common]]
[18:04:47.073]                 NAMES <- toupper(changed)
[18:04:47.073]                 args <- list()
[18:04:47.073]                 for (kk in seq_along(NAMES)) {
[18:04:47.073]                   name <- changed[[kk]]
[18:04:47.073]                   NAME <- NAMES[[kk]]
[18:04:47.073]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.073]                     next
[18:04:47.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.073]                 }
[18:04:47.073]                 NAMES <- toupper(added)
[18:04:47.073]                 for (kk in seq_along(NAMES)) {
[18:04:47.073]                   name <- added[[kk]]
[18:04:47.073]                   NAME <- NAMES[[kk]]
[18:04:47.073]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.073]                     next
[18:04:47.073]                   args[[name]] <- ""
[18:04:47.073]                 }
[18:04:47.073]                 NAMES <- toupper(removed)
[18:04:47.073]                 for (kk in seq_along(NAMES)) {
[18:04:47.073]                   name <- removed[[kk]]
[18:04:47.073]                   NAME <- NAMES[[kk]]
[18:04:47.073]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.073]                     next
[18:04:47.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.073]                 }
[18:04:47.073]                 if (length(args) > 0) 
[18:04:47.073]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.073]             }
[18:04:47.073]             else {
[18:04:47.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.073]             }
[18:04:47.073]             {
[18:04:47.073]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.073]                   0L) {
[18:04:47.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.073]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.073]                   base::options(opts)
[18:04:47.073]                 }
[18:04:47.073]                 {
[18:04:47.073]                   {
[18:04:47.073]                     NULL
[18:04:47.073]                     RNGkind("Mersenne-Twister")
[18:04:47.073]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:47.073]                       inherits = FALSE)
[18:04:47.073]                   }
[18:04:47.073]                   options(future.plan = NULL)
[18:04:47.073]                   if (is.na(NA_character_)) 
[18:04:47.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.073]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.073]                     .init = FALSE)
[18:04:47.073]                 }
[18:04:47.073]             }
[18:04:47.073]         }
[18:04:47.073]     })
[18:04:47.073]     if (TRUE) {
[18:04:47.073]         base::sink(type = "output", split = FALSE)
[18:04:47.073]         if (TRUE) {
[18:04:47.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.073]         }
[18:04:47.073]         else {
[18:04:47.073]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.073]         }
[18:04:47.073]         base::close(...future.stdout)
[18:04:47.073]         ...future.stdout <- NULL
[18:04:47.073]     }
[18:04:47.073]     ...future.result$conditions <- ...future.conditions
[18:04:47.073]     ...future.result$finished <- base::Sys.time()
[18:04:47.073]     ...future.result
[18:04:47.073] }
[18:04:47.076] assign_globals() ...
[18:04:47.076] List of 1
[18:04:47.076]  $ x: list()
[18:04:47.076]  - attr(*, "where")=List of 1
[18:04:47.076]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.076]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.076]  - attr(*, "resolved")= logi TRUE
[18:04:47.076]  - attr(*, "total_size")= num 0
[18:04:47.076]  - attr(*, "already-done")= logi TRUE
[18:04:47.082] - copied ‘x’ to environment
[18:04:47.082] assign_globals() ... done
[18:04:47.082] plan(): Setting new future strategy stack:
[18:04:47.083] List of future strategies:
[18:04:47.083] 1. sequential:
[18:04:47.083]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.083]    - tweaked: FALSE
[18:04:47.083]    - call: NULL
[18:04:47.084] plan(): nbrOfWorkers() = 1
[18:04:47.085] plan(): Setting new future strategy stack:
[18:04:47.086] List of future strategies:
[18:04:47.086] 1. sequential:
[18:04:47.086]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.086]    - tweaked: FALSE
[18:04:47.086]    - call: plan(strategy)
[18:04:47.087] plan(): nbrOfWorkers() = 1
[18:04:47.087] SequentialFuture started (and completed)
[18:04:47.087] - Launch lazy future ... done
[18:04:47.087] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.090] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.090] Searching for globals...
[18:04:47.095] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.095] Searching for globals ... DONE
[18:04:47.095] Resolving globals: TRUE
[18:04:47.095] Resolving any globals that are futures ...
[18:04:47.096] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.096] Resolving any globals that are futures ... DONE
[18:04:47.097] Resolving futures part of globals (recursively) ...
[18:04:47.097] resolve() on list ...
[18:04:47.097]  recursive: 99
[18:04:47.097]  length: 1
[18:04:47.098]  elements: ‘x’
[18:04:47.098]  length: 0 (resolved future 1)
[18:04:47.098] resolve() on list ... DONE
[18:04:47.098] - globals: [1] ‘x’
[18:04:47.099] Resolving futures part of globals (recursively) ... DONE
[18:04:47.099] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.100] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.100] - globals: [1] ‘x’
[18:04:47.100] 
[18:04:47.100] getGlobalsAndPackages() ... DONE
[18:04:47.101] run() for ‘Future’ ...
[18:04:47.101] - state: ‘created’
[18:04:47.101] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:47.102] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:47.102] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:47.102]   - Field: ‘label’
[18:04:47.103]   - Field: ‘local’
[18:04:47.103]   - Field: ‘owner’
[18:04:47.103]   - Field: ‘envir’
[18:04:47.103]   - Field: ‘packages’
[18:04:47.103]   - Field: ‘gc’
[18:04:47.104]   - Field: ‘conditions’
[18:04:47.104]   - Field: ‘expr’
[18:04:47.104]   - Field: ‘uuid’
[18:04:47.104]   - Field: ‘seed’
[18:04:47.104]   - Field: ‘version’
[18:04:47.105]   - Field: ‘result’
[18:04:47.105]   - Field: ‘asynchronous’
[18:04:47.105]   - Field: ‘calls’
[18:04:47.105]   - Field: ‘globals’
[18:04:47.105]   - Field: ‘stdout’
[18:04:47.106]   - Field: ‘earlySignal’
[18:04:47.106]   - Field: ‘lazy’
[18:04:47.106]   - Field: ‘state’
[18:04:47.106] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:47.107] - Launch lazy future ...
[18:04:47.107] Packages needed by the future expression (n = 0): <none>
[18:04:47.107] Packages needed by future strategies (n = 0): <none>
[18:04:47.108] {
[18:04:47.108]     {
[18:04:47.108]         {
[18:04:47.108]             ...future.startTime <- base::Sys.time()
[18:04:47.108]             {
[18:04:47.108]                 {
[18:04:47.108]                   {
[18:04:47.108]                     base::local({
[18:04:47.108]                       has_future <- base::requireNamespace("future", 
[18:04:47.108]                         quietly = TRUE)
[18:04:47.108]                       if (has_future) {
[18:04:47.108]                         ns <- base::getNamespace("future")
[18:04:47.108]                         version <- ns[[".package"]][["version"]]
[18:04:47.108]                         if (is.null(version)) 
[18:04:47.108]                           version <- utils::packageVersion("future")
[18:04:47.108]                       }
[18:04:47.108]                       else {
[18:04:47.108]                         version <- NULL
[18:04:47.108]                       }
[18:04:47.108]                       if (!has_future || version < "1.8.0") {
[18:04:47.108]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.108]                           "", base::R.version$version.string), 
[18:04:47.108]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:47.108]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.108]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.108]                             "release", "version")], collapse = " "), 
[18:04:47.108]                           hostname = base::Sys.info()[["nodename"]])
[18:04:47.108]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.108]                           info)
[18:04:47.108]                         info <- base::paste(info, collapse = "; ")
[18:04:47.108]                         if (!has_future) {
[18:04:47.108]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.108]                             info)
[18:04:47.108]                         }
[18:04:47.108]                         else {
[18:04:47.108]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.108]                             info, version)
[18:04:47.108]                         }
[18:04:47.108]                         base::stop(msg)
[18:04:47.108]                       }
[18:04:47.108]                     })
[18:04:47.108]                   }
[18:04:47.108]                   ...future.strategy.old <- future::plan("list")
[18:04:47.108]                   options(future.plan = NULL)
[18:04:47.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.108]                 }
[18:04:47.108]                 ...future.workdir <- getwd()
[18:04:47.108]             }
[18:04:47.108]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.108]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.108]         }
[18:04:47.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.108]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.108]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.108]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.108]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.108]             base::names(...future.oldOptions))
[18:04:47.108]     }
[18:04:47.108]     if (FALSE) {
[18:04:47.108]     }
[18:04:47.108]     else {
[18:04:47.108]         if (TRUE) {
[18:04:47.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.108]                 open = "w")
[18:04:47.108]         }
[18:04:47.108]         else {
[18:04:47.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.108]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.108]         }
[18:04:47.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.108]             base::sink(type = "output", split = FALSE)
[18:04:47.108]             base::close(...future.stdout)
[18:04:47.108]         }, add = TRUE)
[18:04:47.108]     }
[18:04:47.108]     ...future.frame <- base::sys.nframe()
[18:04:47.108]     ...future.conditions <- base::list()
[18:04:47.108]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.108]     if (FALSE) {
[18:04:47.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.108]     }
[18:04:47.108]     ...future.result <- base::tryCatch({
[18:04:47.108]         base::withCallingHandlers({
[18:04:47.108]             ...future.value <- base::withVisible(base::local({
[18:04:47.108]                 x$a <- 1
[18:04:47.108]                 x
[18:04:47.108]             }))
[18:04:47.108]             future::FutureResult(value = ...future.value$value, 
[18:04:47.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.108]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.108]                     ...future.globalenv.names))
[18:04:47.108]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.108]         }, condition = base::local({
[18:04:47.108]             c <- base::c
[18:04:47.108]             inherits <- base::inherits
[18:04:47.108]             invokeRestart <- base::invokeRestart
[18:04:47.108]             length <- base::length
[18:04:47.108]             list <- base::list
[18:04:47.108]             seq.int <- base::seq.int
[18:04:47.108]             signalCondition <- base::signalCondition
[18:04:47.108]             sys.calls <- base::sys.calls
[18:04:47.108]             `[[` <- base::`[[`
[18:04:47.108]             `+` <- base::`+`
[18:04:47.108]             `<<-` <- base::`<<-`
[18:04:47.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.108]                   3L)]
[18:04:47.108]             }
[18:04:47.108]             function(cond) {
[18:04:47.108]                 is_error <- inherits(cond, "error")
[18:04:47.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.108]                   NULL)
[18:04:47.108]                 if (is_error) {
[18:04:47.108]                   sessionInformation <- function() {
[18:04:47.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.108]                       search = base::search(), system = base::Sys.info())
[18:04:47.108]                   }
[18:04:47.108]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.108]                     cond$call), session = sessionInformation(), 
[18:04:47.108]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.108]                   signalCondition(cond)
[18:04:47.108]                 }
[18:04:47.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.108]                 "immediateCondition"))) {
[18:04:47.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.108]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.108]                   if (TRUE && !signal) {
[18:04:47.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.108]                     {
[18:04:47.108]                       inherits <- base::inherits
[18:04:47.108]                       invokeRestart <- base::invokeRestart
[18:04:47.108]                       is.null <- base::is.null
[18:04:47.108]                       muffled <- FALSE
[18:04:47.108]                       if (inherits(cond, "message")) {
[18:04:47.108]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.108]                         if (muffled) 
[18:04:47.108]                           invokeRestart("muffleMessage")
[18:04:47.108]                       }
[18:04:47.108]                       else if (inherits(cond, "warning")) {
[18:04:47.108]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.108]                         if (muffled) 
[18:04:47.108]                           invokeRestart("muffleWarning")
[18:04:47.108]                       }
[18:04:47.108]                       else if (inherits(cond, "condition")) {
[18:04:47.108]                         if (!is.null(pattern)) {
[18:04:47.108]                           computeRestarts <- base::computeRestarts
[18:04:47.108]                           grepl <- base::grepl
[18:04:47.108]                           restarts <- computeRestarts(cond)
[18:04:47.108]                           for (restart in restarts) {
[18:04:47.108]                             name <- restart$name
[18:04:47.108]                             if (is.null(name)) 
[18:04:47.108]                               next
[18:04:47.108]                             if (!grepl(pattern, name)) 
[18:04:47.108]                               next
[18:04:47.108]                             invokeRestart(restart)
[18:04:47.108]                             muffled <- TRUE
[18:04:47.108]                             break
[18:04:47.108]                           }
[18:04:47.108]                         }
[18:04:47.108]                       }
[18:04:47.108]                       invisible(muffled)
[18:04:47.108]                     }
[18:04:47.108]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.108]                   }
[18:04:47.108]                 }
[18:04:47.108]                 else {
[18:04:47.108]                   if (TRUE) {
[18:04:47.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.108]                     {
[18:04:47.108]                       inherits <- base::inherits
[18:04:47.108]                       invokeRestart <- base::invokeRestart
[18:04:47.108]                       is.null <- base::is.null
[18:04:47.108]                       muffled <- FALSE
[18:04:47.108]                       if (inherits(cond, "message")) {
[18:04:47.108]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.108]                         if (muffled) 
[18:04:47.108]                           invokeRestart("muffleMessage")
[18:04:47.108]                       }
[18:04:47.108]                       else if (inherits(cond, "warning")) {
[18:04:47.108]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.108]                         if (muffled) 
[18:04:47.108]                           invokeRestart("muffleWarning")
[18:04:47.108]                       }
[18:04:47.108]                       else if (inherits(cond, "condition")) {
[18:04:47.108]                         if (!is.null(pattern)) {
[18:04:47.108]                           computeRestarts <- base::computeRestarts
[18:04:47.108]                           grepl <- base::grepl
[18:04:47.108]                           restarts <- computeRestarts(cond)
[18:04:47.108]                           for (restart in restarts) {
[18:04:47.108]                             name <- restart$name
[18:04:47.108]                             if (is.null(name)) 
[18:04:47.108]                               next
[18:04:47.108]                             if (!grepl(pattern, name)) 
[18:04:47.108]                               next
[18:04:47.108]                             invokeRestart(restart)
[18:04:47.108]                             muffled <- TRUE
[18:04:47.108]                             break
[18:04:47.108]                           }
[18:04:47.108]                         }
[18:04:47.108]                       }
[18:04:47.108]                       invisible(muffled)
[18:04:47.108]                     }
[18:04:47.108]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.108]                   }
[18:04:47.108]                 }
[18:04:47.108]             }
[18:04:47.108]         }))
[18:04:47.108]     }, error = function(ex) {
[18:04:47.108]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.108]                 ...future.rng), started = ...future.startTime, 
[18:04:47.108]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.108]             version = "1.8"), class = "FutureResult")
[18:04:47.108]     }, finally = {
[18:04:47.108]         if (!identical(...future.workdir, getwd())) 
[18:04:47.108]             setwd(...future.workdir)
[18:04:47.108]         {
[18:04:47.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.108]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.108]             }
[18:04:47.108]             base::options(...future.oldOptions)
[18:04:47.108]             if (.Platform$OS.type == "windows") {
[18:04:47.108]                 old_names <- names(...future.oldEnvVars)
[18:04:47.108]                 envs <- base::Sys.getenv()
[18:04:47.108]                 names <- names(envs)
[18:04:47.108]                 common <- intersect(names, old_names)
[18:04:47.108]                 added <- setdiff(names, old_names)
[18:04:47.108]                 removed <- setdiff(old_names, names)
[18:04:47.108]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.108]                   envs[common]]
[18:04:47.108]                 NAMES <- toupper(changed)
[18:04:47.108]                 args <- list()
[18:04:47.108]                 for (kk in seq_along(NAMES)) {
[18:04:47.108]                   name <- changed[[kk]]
[18:04:47.108]                   NAME <- NAMES[[kk]]
[18:04:47.108]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.108]                     next
[18:04:47.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.108]                 }
[18:04:47.108]                 NAMES <- toupper(added)
[18:04:47.108]                 for (kk in seq_along(NAMES)) {
[18:04:47.108]                   name <- added[[kk]]
[18:04:47.108]                   NAME <- NAMES[[kk]]
[18:04:47.108]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.108]                     next
[18:04:47.108]                   args[[name]] <- ""
[18:04:47.108]                 }
[18:04:47.108]                 NAMES <- toupper(removed)
[18:04:47.108]                 for (kk in seq_along(NAMES)) {
[18:04:47.108]                   name <- removed[[kk]]
[18:04:47.108]                   NAME <- NAMES[[kk]]
[18:04:47.108]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.108]                     next
[18:04:47.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.108]                 }
[18:04:47.108]                 if (length(args) > 0) 
[18:04:47.108]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.108]             }
[18:04:47.108]             else {
[18:04:47.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.108]             }
[18:04:47.108]             {
[18:04:47.108]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.108]                   0L) {
[18:04:47.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.108]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.108]                   base::options(opts)
[18:04:47.108]                 }
[18:04:47.108]                 {
[18:04:47.108]                   {
[18:04:47.108]                     NULL
[18:04:47.108]                     RNGkind("Mersenne-Twister")
[18:04:47.108]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:47.108]                       inherits = FALSE)
[18:04:47.108]                   }
[18:04:47.108]                   options(future.plan = NULL)
[18:04:47.108]                   if (is.na(NA_character_)) 
[18:04:47.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.108]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.108]                     .init = FALSE)
[18:04:47.108]                 }
[18:04:47.108]             }
[18:04:47.108]         }
[18:04:47.108]     })
[18:04:47.108]     if (TRUE) {
[18:04:47.108]         base::sink(type = "output", split = FALSE)
[18:04:47.108]         if (TRUE) {
[18:04:47.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.108]         }
[18:04:47.108]         else {
[18:04:47.108]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.108]         }
[18:04:47.108]         base::close(...future.stdout)
[18:04:47.108]         ...future.stdout <- NULL
[18:04:47.108]     }
[18:04:47.108]     ...future.result$conditions <- ...future.conditions
[18:04:47.108]     ...future.result$finished <- base::Sys.time()
[18:04:47.108]     ...future.result
[18:04:47.108] }
[18:04:47.111] assign_globals() ...
[18:04:47.112] List of 1
[18:04:47.112]  $ x: list()
[18:04:47.112]  - attr(*, "where")=List of 1
[18:04:47.112]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.112]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.112]  - attr(*, "resolved")= logi TRUE
[18:04:47.112]  - attr(*, "total_size")= num 0
[18:04:47.112]  - attr(*, "already-done")= logi TRUE
[18:04:47.120] - copied ‘x’ to environment
[18:04:47.120] assign_globals() ... done
[18:04:47.120] plan(): Setting new future strategy stack:
[18:04:47.121] List of future strategies:
[18:04:47.121] 1. sequential:
[18:04:47.121]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.121]    - tweaked: FALSE
[18:04:47.121]    - call: NULL
[18:04:47.122] plan(): nbrOfWorkers() = 1
[18:04:47.123] plan(): Setting new future strategy stack:
[18:04:47.124] List of future strategies:
[18:04:47.124] 1. sequential:
[18:04:47.124]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.124]    - tweaked: FALSE
[18:04:47.124]    - call: plan(strategy)
[18:04:47.125] plan(): nbrOfWorkers() = 1
[18:04:47.125] SequentialFuture started (and completed)
[18:04:47.125] - Launch lazy future ... done
[18:04:47.125] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.127] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.127] Searching for globals...
[18:04:47.131] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.131] Searching for globals ... DONE
[18:04:47.132] Resolving globals: TRUE
[18:04:47.132] Resolving any globals that are futures ...
[18:04:47.133] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.133] Resolving any globals that are futures ... DONE
[18:04:47.134] Resolving futures part of globals (recursively) ...
[18:04:47.134] resolve() on list ...
[18:04:47.134]  recursive: 99
[18:04:47.135]  length: 1
[18:04:47.135]  elements: ‘x’
[18:04:47.135]  length: 0 (resolved future 1)
[18:04:47.135] resolve() on list ... DONE
[18:04:47.135] - globals: [1] ‘x’
[18:04:47.136] Resolving futures part of globals (recursively) ... DONE
[18:04:47.136] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.137] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.137] - globals: [1] ‘x’
[18:04:47.137] 
[18:04:47.137] getGlobalsAndPackages() ... DONE
[18:04:47.138] run() for ‘Future’ ...
[18:04:47.138] - state: ‘created’
[18:04:47.138] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:47.139] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:47.139] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:47.139]   - Field: ‘label’
[18:04:47.140]   - Field: ‘local’
[18:04:47.140]   - Field: ‘owner’
[18:04:47.140]   - Field: ‘envir’
[18:04:47.140]   - Field: ‘packages’
[18:04:47.140]   - Field: ‘gc’
[18:04:47.141]   - Field: ‘conditions’
[18:04:47.141]   - Field: ‘expr’
[18:04:47.142]   - Field: ‘uuid’
[18:04:47.142]   - Field: ‘seed’
[18:04:47.142]   - Field: ‘version’
[18:04:47.142]   - Field: ‘result’
[18:04:47.142]   - Field: ‘asynchronous’
[18:04:47.143]   - Field: ‘calls’
[18:04:47.143]   - Field: ‘globals’
[18:04:47.143]   - Field: ‘stdout’
[18:04:47.143]   - Field: ‘earlySignal’
[18:04:47.143]   - Field: ‘lazy’
[18:04:47.144]   - Field: ‘state’
[18:04:47.144] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:47.144] - Launch lazy future ...
[18:04:47.144] Packages needed by the future expression (n = 0): <none>
[18:04:47.145] Packages needed by future strategies (n = 0): <none>
[18:04:47.146] {
[18:04:47.146]     {
[18:04:47.146]         {
[18:04:47.146]             ...future.startTime <- base::Sys.time()
[18:04:47.146]             {
[18:04:47.146]                 {
[18:04:47.146]                   {
[18:04:47.146]                     base::local({
[18:04:47.146]                       has_future <- base::requireNamespace("future", 
[18:04:47.146]                         quietly = TRUE)
[18:04:47.146]                       if (has_future) {
[18:04:47.146]                         ns <- base::getNamespace("future")
[18:04:47.146]                         version <- ns[[".package"]][["version"]]
[18:04:47.146]                         if (is.null(version)) 
[18:04:47.146]                           version <- utils::packageVersion("future")
[18:04:47.146]                       }
[18:04:47.146]                       else {
[18:04:47.146]                         version <- NULL
[18:04:47.146]                       }
[18:04:47.146]                       if (!has_future || version < "1.8.0") {
[18:04:47.146]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.146]                           "", base::R.version$version.string), 
[18:04:47.146]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:47.146]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.146]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.146]                             "release", "version")], collapse = " "), 
[18:04:47.146]                           hostname = base::Sys.info()[["nodename"]])
[18:04:47.146]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.146]                           info)
[18:04:47.146]                         info <- base::paste(info, collapse = "; ")
[18:04:47.146]                         if (!has_future) {
[18:04:47.146]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.146]                             info)
[18:04:47.146]                         }
[18:04:47.146]                         else {
[18:04:47.146]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.146]                             info, version)
[18:04:47.146]                         }
[18:04:47.146]                         base::stop(msg)
[18:04:47.146]                       }
[18:04:47.146]                     })
[18:04:47.146]                   }
[18:04:47.146]                   ...future.strategy.old <- future::plan("list")
[18:04:47.146]                   options(future.plan = NULL)
[18:04:47.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.146]                 }
[18:04:47.146]                 ...future.workdir <- getwd()
[18:04:47.146]             }
[18:04:47.146]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.146]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.146]         }
[18:04:47.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.146]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.146]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.146]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.146]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.146]             base::names(...future.oldOptions))
[18:04:47.146]     }
[18:04:47.146]     if (FALSE) {
[18:04:47.146]     }
[18:04:47.146]     else {
[18:04:47.146]         if (TRUE) {
[18:04:47.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.146]                 open = "w")
[18:04:47.146]         }
[18:04:47.146]         else {
[18:04:47.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.146]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.146]         }
[18:04:47.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.146]             base::sink(type = "output", split = FALSE)
[18:04:47.146]             base::close(...future.stdout)
[18:04:47.146]         }, add = TRUE)
[18:04:47.146]     }
[18:04:47.146]     ...future.frame <- base::sys.nframe()
[18:04:47.146]     ...future.conditions <- base::list()
[18:04:47.146]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.146]     if (FALSE) {
[18:04:47.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.146]     }
[18:04:47.146]     ...future.result <- base::tryCatch({
[18:04:47.146]         base::withCallingHandlers({
[18:04:47.146]             ...future.value <- base::withVisible(base::local({
[18:04:47.146]                 x$a <- 1
[18:04:47.146]                 x
[18:04:47.146]             }))
[18:04:47.146]             future::FutureResult(value = ...future.value$value, 
[18:04:47.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.146]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.146]                     ...future.globalenv.names))
[18:04:47.146]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.146]         }, condition = base::local({
[18:04:47.146]             c <- base::c
[18:04:47.146]             inherits <- base::inherits
[18:04:47.146]             invokeRestart <- base::invokeRestart
[18:04:47.146]             length <- base::length
[18:04:47.146]             list <- base::list
[18:04:47.146]             seq.int <- base::seq.int
[18:04:47.146]             signalCondition <- base::signalCondition
[18:04:47.146]             sys.calls <- base::sys.calls
[18:04:47.146]             `[[` <- base::`[[`
[18:04:47.146]             `+` <- base::`+`
[18:04:47.146]             `<<-` <- base::`<<-`
[18:04:47.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.146]                   3L)]
[18:04:47.146]             }
[18:04:47.146]             function(cond) {
[18:04:47.146]                 is_error <- inherits(cond, "error")
[18:04:47.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.146]                   NULL)
[18:04:47.146]                 if (is_error) {
[18:04:47.146]                   sessionInformation <- function() {
[18:04:47.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.146]                       search = base::search(), system = base::Sys.info())
[18:04:47.146]                   }
[18:04:47.146]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.146]                     cond$call), session = sessionInformation(), 
[18:04:47.146]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.146]                   signalCondition(cond)
[18:04:47.146]                 }
[18:04:47.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.146]                 "immediateCondition"))) {
[18:04:47.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.146]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.146]                   if (TRUE && !signal) {
[18:04:47.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.146]                     {
[18:04:47.146]                       inherits <- base::inherits
[18:04:47.146]                       invokeRestart <- base::invokeRestart
[18:04:47.146]                       is.null <- base::is.null
[18:04:47.146]                       muffled <- FALSE
[18:04:47.146]                       if (inherits(cond, "message")) {
[18:04:47.146]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.146]                         if (muffled) 
[18:04:47.146]                           invokeRestart("muffleMessage")
[18:04:47.146]                       }
[18:04:47.146]                       else if (inherits(cond, "warning")) {
[18:04:47.146]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.146]                         if (muffled) 
[18:04:47.146]                           invokeRestart("muffleWarning")
[18:04:47.146]                       }
[18:04:47.146]                       else if (inherits(cond, "condition")) {
[18:04:47.146]                         if (!is.null(pattern)) {
[18:04:47.146]                           computeRestarts <- base::computeRestarts
[18:04:47.146]                           grepl <- base::grepl
[18:04:47.146]                           restarts <- computeRestarts(cond)
[18:04:47.146]                           for (restart in restarts) {
[18:04:47.146]                             name <- restart$name
[18:04:47.146]                             if (is.null(name)) 
[18:04:47.146]                               next
[18:04:47.146]                             if (!grepl(pattern, name)) 
[18:04:47.146]                               next
[18:04:47.146]                             invokeRestart(restart)
[18:04:47.146]                             muffled <- TRUE
[18:04:47.146]                             break
[18:04:47.146]                           }
[18:04:47.146]                         }
[18:04:47.146]                       }
[18:04:47.146]                       invisible(muffled)
[18:04:47.146]                     }
[18:04:47.146]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.146]                   }
[18:04:47.146]                 }
[18:04:47.146]                 else {
[18:04:47.146]                   if (TRUE) {
[18:04:47.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.146]                     {
[18:04:47.146]                       inherits <- base::inherits
[18:04:47.146]                       invokeRestart <- base::invokeRestart
[18:04:47.146]                       is.null <- base::is.null
[18:04:47.146]                       muffled <- FALSE
[18:04:47.146]                       if (inherits(cond, "message")) {
[18:04:47.146]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.146]                         if (muffled) 
[18:04:47.146]                           invokeRestart("muffleMessage")
[18:04:47.146]                       }
[18:04:47.146]                       else if (inherits(cond, "warning")) {
[18:04:47.146]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.146]                         if (muffled) 
[18:04:47.146]                           invokeRestart("muffleWarning")
[18:04:47.146]                       }
[18:04:47.146]                       else if (inherits(cond, "condition")) {
[18:04:47.146]                         if (!is.null(pattern)) {
[18:04:47.146]                           computeRestarts <- base::computeRestarts
[18:04:47.146]                           grepl <- base::grepl
[18:04:47.146]                           restarts <- computeRestarts(cond)
[18:04:47.146]                           for (restart in restarts) {
[18:04:47.146]                             name <- restart$name
[18:04:47.146]                             if (is.null(name)) 
[18:04:47.146]                               next
[18:04:47.146]                             if (!grepl(pattern, name)) 
[18:04:47.146]                               next
[18:04:47.146]                             invokeRestart(restart)
[18:04:47.146]                             muffled <- TRUE
[18:04:47.146]                             break
[18:04:47.146]                           }
[18:04:47.146]                         }
[18:04:47.146]                       }
[18:04:47.146]                       invisible(muffled)
[18:04:47.146]                     }
[18:04:47.146]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.146]                   }
[18:04:47.146]                 }
[18:04:47.146]             }
[18:04:47.146]         }))
[18:04:47.146]     }, error = function(ex) {
[18:04:47.146]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.146]                 ...future.rng), started = ...future.startTime, 
[18:04:47.146]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.146]             version = "1.8"), class = "FutureResult")
[18:04:47.146]     }, finally = {
[18:04:47.146]         if (!identical(...future.workdir, getwd())) 
[18:04:47.146]             setwd(...future.workdir)
[18:04:47.146]         {
[18:04:47.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.146]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.146]             }
[18:04:47.146]             base::options(...future.oldOptions)
[18:04:47.146]             if (.Platform$OS.type == "windows") {
[18:04:47.146]                 old_names <- names(...future.oldEnvVars)
[18:04:47.146]                 envs <- base::Sys.getenv()
[18:04:47.146]                 names <- names(envs)
[18:04:47.146]                 common <- intersect(names, old_names)
[18:04:47.146]                 added <- setdiff(names, old_names)
[18:04:47.146]                 removed <- setdiff(old_names, names)
[18:04:47.146]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.146]                   envs[common]]
[18:04:47.146]                 NAMES <- toupper(changed)
[18:04:47.146]                 args <- list()
[18:04:47.146]                 for (kk in seq_along(NAMES)) {
[18:04:47.146]                   name <- changed[[kk]]
[18:04:47.146]                   NAME <- NAMES[[kk]]
[18:04:47.146]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.146]                     next
[18:04:47.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.146]                 }
[18:04:47.146]                 NAMES <- toupper(added)
[18:04:47.146]                 for (kk in seq_along(NAMES)) {
[18:04:47.146]                   name <- added[[kk]]
[18:04:47.146]                   NAME <- NAMES[[kk]]
[18:04:47.146]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.146]                     next
[18:04:47.146]                   args[[name]] <- ""
[18:04:47.146]                 }
[18:04:47.146]                 NAMES <- toupper(removed)
[18:04:47.146]                 for (kk in seq_along(NAMES)) {
[18:04:47.146]                   name <- removed[[kk]]
[18:04:47.146]                   NAME <- NAMES[[kk]]
[18:04:47.146]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.146]                     next
[18:04:47.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.146]                 }
[18:04:47.146]                 if (length(args) > 0) 
[18:04:47.146]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.146]             }
[18:04:47.146]             else {
[18:04:47.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.146]             }
[18:04:47.146]             {
[18:04:47.146]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.146]                   0L) {
[18:04:47.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.146]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.146]                   base::options(opts)
[18:04:47.146]                 }
[18:04:47.146]                 {
[18:04:47.146]                   {
[18:04:47.146]                     NULL
[18:04:47.146]                     RNGkind("Mersenne-Twister")
[18:04:47.146]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:47.146]                       inherits = FALSE)
[18:04:47.146]                   }
[18:04:47.146]                   options(future.plan = NULL)
[18:04:47.146]                   if (is.na(NA_character_)) 
[18:04:47.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.146]                     .init = FALSE)
[18:04:47.146]                 }
[18:04:47.146]             }
[18:04:47.146]         }
[18:04:47.146]     })
[18:04:47.146]     if (TRUE) {
[18:04:47.146]         base::sink(type = "output", split = FALSE)
[18:04:47.146]         if (TRUE) {
[18:04:47.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.146]         }
[18:04:47.146]         else {
[18:04:47.146]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.146]         }
[18:04:47.146]         base::close(...future.stdout)
[18:04:47.146]         ...future.stdout <- NULL
[18:04:47.146]     }
[18:04:47.146]     ...future.result$conditions <- ...future.conditions
[18:04:47.146]     ...future.result$finished <- base::Sys.time()
[18:04:47.146]     ...future.result
[18:04:47.146] }
[18:04:47.149] assign_globals() ...
[18:04:47.149] List of 1
[18:04:47.149]  $ x: list()
[18:04:47.149]  - attr(*, "where")=List of 1
[18:04:47.149]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.149]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.149]  - attr(*, "resolved")= logi TRUE
[18:04:47.149]  - attr(*, "total_size")= num 0
[18:04:47.149]  - attr(*, "already-done")= logi TRUE
[18:04:47.155] - copied ‘x’ to environment
[18:04:47.155] assign_globals() ... done
[18:04:47.156] plan(): Setting new future strategy stack:
[18:04:47.156] List of future strategies:
[18:04:47.156] 1. sequential:
[18:04:47.156]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.156]    - tweaked: FALSE
[18:04:47.156]    - call: NULL
[18:04:47.157] plan(): nbrOfWorkers() = 1
[18:04:47.158] plan(): Setting new future strategy stack:
[18:04:47.159] List of future strategies:
[18:04:47.159] 1. sequential:
[18:04:47.159]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.159]    - tweaked: FALSE
[18:04:47.159]    - call: plan(strategy)
[18:04:47.160] plan(): nbrOfWorkers() = 1
[18:04:47.160] SequentialFuture started (and completed)
[18:04:47.160] - Launch lazy future ... done
[18:04:47.161] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.162] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.162] Searching for globals...
[18:04:47.168] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[18:04:47.168] Searching for globals ... DONE
[18:04:47.168] Resolving globals: TRUE
[18:04:47.168] Resolving any globals that are futures ...
[18:04:47.169] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[18:04:47.169] Resolving any globals that are futures ... DONE
[18:04:47.170] 
[18:04:47.170] 
[18:04:47.170] getGlobalsAndPackages() ... DONE
[18:04:47.171] run() for ‘Future’ ...
[18:04:47.171] - state: ‘created’
[18:04:47.171] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:47.172] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:47.172] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:47.172]   - Field: ‘label’
[18:04:47.172]   - Field: ‘local’
[18:04:47.173]   - Field: ‘owner’
[18:04:47.173]   - Field: ‘envir’
[18:04:47.173]   - Field: ‘packages’
[18:04:47.173]   - Field: ‘gc’
[18:04:47.173]   - Field: ‘conditions’
[18:04:47.174]   - Field: ‘expr’
[18:04:47.174]   - Field: ‘uuid’
[18:04:47.174]   - Field: ‘seed’
[18:04:47.174]   - Field: ‘version’
[18:04:47.174]   - Field: ‘result’
[18:04:47.175]   - Field: ‘asynchronous’
[18:04:47.175]   - Field: ‘calls’
[18:04:47.175]   - Field: ‘globals’
[18:04:47.175]   - Field: ‘stdout’
[18:04:47.175]   - Field: ‘earlySignal’
[18:04:47.176]   - Field: ‘lazy’
[18:04:47.176]   - Field: ‘state’
[18:04:47.176] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:47.176] - Launch lazy future ...
[18:04:47.177] Packages needed by the future expression (n = 0): <none>
[18:04:47.177] Packages needed by future strategies (n = 0): <none>
[18:04:47.178] {
[18:04:47.178]     {
[18:04:47.178]         {
[18:04:47.178]             ...future.startTime <- base::Sys.time()
[18:04:47.178]             {
[18:04:47.178]                 {
[18:04:47.178]                   {
[18:04:47.178]                     base::local({
[18:04:47.178]                       has_future <- base::requireNamespace("future", 
[18:04:47.178]                         quietly = TRUE)
[18:04:47.178]                       if (has_future) {
[18:04:47.178]                         ns <- base::getNamespace("future")
[18:04:47.178]                         version <- ns[[".package"]][["version"]]
[18:04:47.178]                         if (is.null(version)) 
[18:04:47.178]                           version <- utils::packageVersion("future")
[18:04:47.178]                       }
[18:04:47.178]                       else {
[18:04:47.178]                         version <- NULL
[18:04:47.178]                       }
[18:04:47.178]                       if (!has_future || version < "1.8.0") {
[18:04:47.178]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.178]                           "", base::R.version$version.string), 
[18:04:47.178]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:47.178]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.178]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.178]                             "release", "version")], collapse = " "), 
[18:04:47.178]                           hostname = base::Sys.info()[["nodename"]])
[18:04:47.178]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.178]                           info)
[18:04:47.178]                         info <- base::paste(info, collapse = "; ")
[18:04:47.178]                         if (!has_future) {
[18:04:47.178]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.178]                             info)
[18:04:47.178]                         }
[18:04:47.178]                         else {
[18:04:47.178]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.178]                             info, version)
[18:04:47.178]                         }
[18:04:47.178]                         base::stop(msg)
[18:04:47.178]                       }
[18:04:47.178]                     })
[18:04:47.178]                   }
[18:04:47.178]                   ...future.strategy.old <- future::plan("list")
[18:04:47.178]                   options(future.plan = NULL)
[18:04:47.178]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.178]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.178]                 }
[18:04:47.178]                 ...future.workdir <- getwd()
[18:04:47.178]             }
[18:04:47.178]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.178]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.178]         }
[18:04:47.178]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.178]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.178]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.178]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.178]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.178]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.178]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.178]             base::names(...future.oldOptions))
[18:04:47.178]     }
[18:04:47.178]     if (FALSE) {
[18:04:47.178]     }
[18:04:47.178]     else {
[18:04:47.178]         if (TRUE) {
[18:04:47.178]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.178]                 open = "w")
[18:04:47.178]         }
[18:04:47.178]         else {
[18:04:47.178]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.178]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.178]         }
[18:04:47.178]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.178]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.178]             base::sink(type = "output", split = FALSE)
[18:04:47.178]             base::close(...future.stdout)
[18:04:47.178]         }, add = TRUE)
[18:04:47.178]     }
[18:04:47.178]     ...future.frame <- base::sys.nframe()
[18:04:47.178]     ...future.conditions <- base::list()
[18:04:47.178]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.178]     if (FALSE) {
[18:04:47.178]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.178]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.178]     }
[18:04:47.178]     ...future.result <- base::tryCatch({
[18:04:47.178]         base::withCallingHandlers({
[18:04:47.178]             ...future.value <- base::withVisible(base::local({
[18:04:47.178]                 x <- list(b = 2)
[18:04:47.178]                 x$a <- 1
[18:04:47.178]                 x
[18:04:47.178]             }))
[18:04:47.178]             future::FutureResult(value = ...future.value$value, 
[18:04:47.178]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.178]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.178]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.178]                     ...future.globalenv.names))
[18:04:47.178]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.178]         }, condition = base::local({
[18:04:47.178]             c <- base::c
[18:04:47.178]             inherits <- base::inherits
[18:04:47.178]             invokeRestart <- base::invokeRestart
[18:04:47.178]             length <- base::length
[18:04:47.178]             list <- base::list
[18:04:47.178]             seq.int <- base::seq.int
[18:04:47.178]             signalCondition <- base::signalCondition
[18:04:47.178]             sys.calls <- base::sys.calls
[18:04:47.178]             `[[` <- base::`[[`
[18:04:47.178]             `+` <- base::`+`
[18:04:47.178]             `<<-` <- base::`<<-`
[18:04:47.178]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.178]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.178]                   3L)]
[18:04:47.178]             }
[18:04:47.178]             function(cond) {
[18:04:47.178]                 is_error <- inherits(cond, "error")
[18:04:47.178]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.178]                   NULL)
[18:04:47.178]                 if (is_error) {
[18:04:47.178]                   sessionInformation <- function() {
[18:04:47.178]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.178]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.178]                       search = base::search(), system = base::Sys.info())
[18:04:47.178]                   }
[18:04:47.178]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.178]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.178]                     cond$call), session = sessionInformation(), 
[18:04:47.178]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.178]                   signalCondition(cond)
[18:04:47.178]                 }
[18:04:47.178]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.178]                 "immediateCondition"))) {
[18:04:47.178]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.178]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.178]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.178]                   if (TRUE && !signal) {
[18:04:47.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.178]                     {
[18:04:47.178]                       inherits <- base::inherits
[18:04:47.178]                       invokeRestart <- base::invokeRestart
[18:04:47.178]                       is.null <- base::is.null
[18:04:47.178]                       muffled <- FALSE
[18:04:47.178]                       if (inherits(cond, "message")) {
[18:04:47.178]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.178]                         if (muffled) 
[18:04:47.178]                           invokeRestart("muffleMessage")
[18:04:47.178]                       }
[18:04:47.178]                       else if (inherits(cond, "warning")) {
[18:04:47.178]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.178]                         if (muffled) 
[18:04:47.178]                           invokeRestart("muffleWarning")
[18:04:47.178]                       }
[18:04:47.178]                       else if (inherits(cond, "condition")) {
[18:04:47.178]                         if (!is.null(pattern)) {
[18:04:47.178]                           computeRestarts <- base::computeRestarts
[18:04:47.178]                           grepl <- base::grepl
[18:04:47.178]                           restarts <- computeRestarts(cond)
[18:04:47.178]                           for (restart in restarts) {
[18:04:47.178]                             name <- restart$name
[18:04:47.178]                             if (is.null(name)) 
[18:04:47.178]                               next
[18:04:47.178]                             if (!grepl(pattern, name)) 
[18:04:47.178]                               next
[18:04:47.178]                             invokeRestart(restart)
[18:04:47.178]                             muffled <- TRUE
[18:04:47.178]                             break
[18:04:47.178]                           }
[18:04:47.178]                         }
[18:04:47.178]                       }
[18:04:47.178]                       invisible(muffled)
[18:04:47.178]                     }
[18:04:47.178]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.178]                   }
[18:04:47.178]                 }
[18:04:47.178]                 else {
[18:04:47.178]                   if (TRUE) {
[18:04:47.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.178]                     {
[18:04:47.178]                       inherits <- base::inherits
[18:04:47.178]                       invokeRestart <- base::invokeRestart
[18:04:47.178]                       is.null <- base::is.null
[18:04:47.178]                       muffled <- FALSE
[18:04:47.178]                       if (inherits(cond, "message")) {
[18:04:47.178]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.178]                         if (muffled) 
[18:04:47.178]                           invokeRestart("muffleMessage")
[18:04:47.178]                       }
[18:04:47.178]                       else if (inherits(cond, "warning")) {
[18:04:47.178]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.178]                         if (muffled) 
[18:04:47.178]                           invokeRestart("muffleWarning")
[18:04:47.178]                       }
[18:04:47.178]                       else if (inherits(cond, "condition")) {
[18:04:47.178]                         if (!is.null(pattern)) {
[18:04:47.178]                           computeRestarts <- base::computeRestarts
[18:04:47.178]                           grepl <- base::grepl
[18:04:47.178]                           restarts <- computeRestarts(cond)
[18:04:47.178]                           for (restart in restarts) {
[18:04:47.178]                             name <- restart$name
[18:04:47.178]                             if (is.null(name)) 
[18:04:47.178]                               next
[18:04:47.178]                             if (!grepl(pattern, name)) 
[18:04:47.178]                               next
[18:04:47.178]                             invokeRestart(restart)
[18:04:47.178]                             muffled <- TRUE
[18:04:47.178]                             break
[18:04:47.178]                           }
[18:04:47.178]                         }
[18:04:47.178]                       }
[18:04:47.178]                       invisible(muffled)
[18:04:47.178]                     }
[18:04:47.178]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.178]                   }
[18:04:47.178]                 }
[18:04:47.178]             }
[18:04:47.178]         }))
[18:04:47.178]     }, error = function(ex) {
[18:04:47.178]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.178]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.178]                 ...future.rng), started = ...future.startTime, 
[18:04:47.178]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.178]             version = "1.8"), class = "FutureResult")
[18:04:47.178]     }, finally = {
[18:04:47.178]         if (!identical(...future.workdir, getwd())) 
[18:04:47.178]             setwd(...future.workdir)
[18:04:47.178]         {
[18:04:47.178]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.178]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.178]             }
[18:04:47.178]             base::options(...future.oldOptions)
[18:04:47.178]             if (.Platform$OS.type == "windows") {
[18:04:47.178]                 old_names <- names(...future.oldEnvVars)
[18:04:47.178]                 envs <- base::Sys.getenv()
[18:04:47.178]                 names <- names(envs)
[18:04:47.178]                 common <- intersect(names, old_names)
[18:04:47.178]                 added <- setdiff(names, old_names)
[18:04:47.178]                 removed <- setdiff(old_names, names)
[18:04:47.178]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.178]                   envs[common]]
[18:04:47.178]                 NAMES <- toupper(changed)
[18:04:47.178]                 args <- list()
[18:04:47.178]                 for (kk in seq_along(NAMES)) {
[18:04:47.178]                   name <- changed[[kk]]
[18:04:47.178]                   NAME <- NAMES[[kk]]
[18:04:47.178]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.178]                     next
[18:04:47.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.178]                 }
[18:04:47.178]                 NAMES <- toupper(added)
[18:04:47.178]                 for (kk in seq_along(NAMES)) {
[18:04:47.178]                   name <- added[[kk]]
[18:04:47.178]                   NAME <- NAMES[[kk]]
[18:04:47.178]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.178]                     next
[18:04:47.178]                   args[[name]] <- ""
[18:04:47.178]                 }
[18:04:47.178]                 NAMES <- toupper(removed)
[18:04:47.178]                 for (kk in seq_along(NAMES)) {
[18:04:47.178]                   name <- removed[[kk]]
[18:04:47.178]                   NAME <- NAMES[[kk]]
[18:04:47.178]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.178]                     next
[18:04:47.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.178]                 }
[18:04:47.178]                 if (length(args) > 0) 
[18:04:47.178]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.178]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.178]             }
[18:04:47.178]             else {
[18:04:47.178]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.178]             }
[18:04:47.178]             {
[18:04:47.178]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.178]                   0L) {
[18:04:47.178]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.178]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.178]                   base::options(opts)
[18:04:47.178]                 }
[18:04:47.178]                 {
[18:04:47.178]                   {
[18:04:47.178]                     NULL
[18:04:47.178]                     RNGkind("Mersenne-Twister")
[18:04:47.178]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:47.178]                       inherits = FALSE)
[18:04:47.178]                   }
[18:04:47.178]                   options(future.plan = NULL)
[18:04:47.178]                   if (is.na(NA_character_)) 
[18:04:47.178]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.178]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.178]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.178]                     .init = FALSE)
[18:04:47.178]                 }
[18:04:47.178]             }
[18:04:47.178]         }
[18:04:47.178]     })
[18:04:47.178]     if (TRUE) {
[18:04:47.178]         base::sink(type = "output", split = FALSE)
[18:04:47.178]         if (TRUE) {
[18:04:47.178]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.178]         }
[18:04:47.178]         else {
[18:04:47.178]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.178]         }
[18:04:47.178]         base::close(...future.stdout)
[18:04:47.178]         ...future.stdout <- NULL
[18:04:47.178]     }
[18:04:47.178]     ...future.result$conditions <- ...future.conditions
[18:04:47.178]     ...future.result$finished <- base::Sys.time()
[18:04:47.178]     ...future.result
[18:04:47.178] }
[18:04:47.181] plan(): Setting new future strategy stack:
[18:04:47.182] List of future strategies:
[18:04:47.182] 1. sequential:
[18:04:47.182]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.182]    - tweaked: FALSE
[18:04:47.182]    - call: NULL
[18:04:47.185] plan(): nbrOfWorkers() = 1
[18:04:47.187] plan(): Setting new future strategy stack:
[18:04:47.187] List of future strategies:
[18:04:47.187] 1. sequential:
[18:04:47.187]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.187]    - tweaked: FALSE
[18:04:47.187]    - call: plan(strategy)
[18:04:47.188] plan(): nbrOfWorkers() = 1
[18:04:47.188] SequentialFuture started (and completed)
[18:04:47.189] - Launch lazy future ... done
[18:04:47.189] run() for ‘SequentialFuture’ ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.190] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.190] Searching for globals...
[18:04:47.194] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:47.195] Searching for globals ... DONE
[18:04:47.195] Resolving globals: TRUE
[18:04:47.195] Resolving any globals that are futures ...
[18:04:47.195] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:47.196] Resolving any globals that are futures ... DONE
[18:04:47.196] Resolving futures part of globals (recursively) ...
[18:04:47.197] resolve() on list ...
[18:04:47.197]  recursive: 99
[18:04:47.197]  length: 1
[18:04:47.197]  elements: ‘x’
[18:04:47.198]  length: 0 (resolved future 1)
[18:04:47.198] resolve() on list ... DONE
[18:04:47.198] - globals: [1] ‘x’
[18:04:47.198] Resolving futures part of globals (recursively) ... DONE
[18:04:47.199] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.199] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.200] - globals: [1] ‘x’
[18:04:47.200] 
[18:04:47.200] getGlobalsAndPackages() ... DONE
[18:04:47.201] run() for ‘Future’ ...
[18:04:47.201] - state: ‘created’
[18:04:47.201] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:47.202] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:47.202] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:47.202]   - Field: ‘label’
[18:04:47.202]   - Field: ‘local’
[18:04:47.203]   - Field: ‘owner’
[18:04:47.203]   - Field: ‘envir’
[18:04:47.203]   - Field: ‘packages’
[18:04:47.203]   - Field: ‘gc’
[18:04:47.203]   - Field: ‘conditions’
[18:04:47.204]   - Field: ‘expr’
[18:04:47.204]   - Field: ‘uuid’
[18:04:47.204]   - Field: ‘seed’
[18:04:47.204]   - Field: ‘version’
[18:04:47.204]   - Field: ‘result’
[18:04:47.205]   - Field: ‘asynchronous’
[18:04:47.205]   - Field: ‘calls’
[18:04:47.205]   - Field: ‘globals’
[18:04:47.205]   - Field: ‘stdout’
[18:04:47.205]   - Field: ‘earlySignal’
[18:04:47.206]   - Field: ‘lazy’
[18:04:47.206]   - Field: ‘state’
[18:04:47.206] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:47.206] - Launch lazy future ...
[18:04:47.207] Packages needed by the future expression (n = 0): <none>
[18:04:47.207] Packages needed by future strategies (n = 0): <none>
[18:04:47.208] {
[18:04:47.208]     {
[18:04:47.208]         {
[18:04:47.208]             ...future.startTime <- base::Sys.time()
[18:04:47.208]             {
[18:04:47.208]                 {
[18:04:47.208]                   {
[18:04:47.208]                     base::local({
[18:04:47.208]                       has_future <- base::requireNamespace("future", 
[18:04:47.208]                         quietly = TRUE)
[18:04:47.208]                       if (has_future) {
[18:04:47.208]                         ns <- base::getNamespace("future")
[18:04:47.208]                         version <- ns[[".package"]][["version"]]
[18:04:47.208]                         if (is.null(version)) 
[18:04:47.208]                           version <- utils::packageVersion("future")
[18:04:47.208]                       }
[18:04:47.208]                       else {
[18:04:47.208]                         version <- NULL
[18:04:47.208]                       }
[18:04:47.208]                       if (!has_future || version < "1.8.0") {
[18:04:47.208]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.208]                           "", base::R.version$version.string), 
[18:04:47.208]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:47.208]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.208]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.208]                             "release", "version")], collapse = " "), 
[18:04:47.208]                           hostname = base::Sys.info()[["nodename"]])
[18:04:47.208]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.208]                           info)
[18:04:47.208]                         info <- base::paste(info, collapse = "; ")
[18:04:47.208]                         if (!has_future) {
[18:04:47.208]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.208]                             info)
[18:04:47.208]                         }
[18:04:47.208]                         else {
[18:04:47.208]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.208]                             info, version)
[18:04:47.208]                         }
[18:04:47.208]                         base::stop(msg)
[18:04:47.208]                       }
[18:04:47.208]                     })
[18:04:47.208]                   }
[18:04:47.208]                   ...future.strategy.old <- future::plan("list")
[18:04:47.208]                   options(future.plan = NULL)
[18:04:47.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.208]                 }
[18:04:47.208]                 ...future.workdir <- getwd()
[18:04:47.208]             }
[18:04:47.208]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.208]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.208]         }
[18:04:47.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.208]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.208]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.208]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.208]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.208]             base::names(...future.oldOptions))
[18:04:47.208]     }
[18:04:47.208]     if (FALSE) {
[18:04:47.208]     }
[18:04:47.208]     else {
[18:04:47.208]         if (TRUE) {
[18:04:47.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.208]                 open = "w")
[18:04:47.208]         }
[18:04:47.208]         else {
[18:04:47.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.208]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.208]         }
[18:04:47.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.208]             base::sink(type = "output", split = FALSE)
[18:04:47.208]             base::close(...future.stdout)
[18:04:47.208]         }, add = TRUE)
[18:04:47.208]     }
[18:04:47.208]     ...future.frame <- base::sys.nframe()
[18:04:47.208]     ...future.conditions <- base::list()
[18:04:47.208]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.208]     if (FALSE) {
[18:04:47.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.208]     }
[18:04:47.208]     ...future.result <- base::tryCatch({
[18:04:47.208]         base::withCallingHandlers({
[18:04:47.208]             ...future.value <- base::withVisible(base::local({
[18:04:47.208]                 x[["a"]] <- 1
[18:04:47.208]                 x
[18:04:47.208]             }))
[18:04:47.208]             future::FutureResult(value = ...future.value$value, 
[18:04:47.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.208]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.208]                     ...future.globalenv.names))
[18:04:47.208]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.208]         }, condition = base::local({
[18:04:47.208]             c <- base::c
[18:04:47.208]             inherits <- base::inherits
[18:04:47.208]             invokeRestart <- base::invokeRestart
[18:04:47.208]             length <- base::length
[18:04:47.208]             list <- base::list
[18:04:47.208]             seq.int <- base::seq.int
[18:04:47.208]             signalCondition <- base::signalCondition
[18:04:47.208]             sys.calls <- base::sys.calls
[18:04:47.208]             `[[` <- base::`[[`
[18:04:47.208]             `+` <- base::`+`
[18:04:47.208]             `<<-` <- base::`<<-`
[18:04:47.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.208]                   3L)]
[18:04:47.208]             }
[18:04:47.208]             function(cond) {
[18:04:47.208]                 is_error <- inherits(cond, "error")
[18:04:47.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.208]                   NULL)
[18:04:47.208]                 if (is_error) {
[18:04:47.208]                   sessionInformation <- function() {
[18:04:47.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.208]                       search = base::search(), system = base::Sys.info())
[18:04:47.208]                   }
[18:04:47.208]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.208]                     cond$call), session = sessionInformation(), 
[18:04:47.208]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.208]                   signalCondition(cond)
[18:04:47.208]                 }
[18:04:47.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.208]                 "immediateCondition"))) {
[18:04:47.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.208]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.208]                   if (TRUE && !signal) {
[18:04:47.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.208]                     {
[18:04:47.208]                       inherits <- base::inherits
[18:04:47.208]                       invokeRestart <- base::invokeRestart
[18:04:47.208]                       is.null <- base::is.null
[18:04:47.208]                       muffled <- FALSE
[18:04:47.208]                       if (inherits(cond, "message")) {
[18:04:47.208]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.208]                         if (muffled) 
[18:04:47.208]                           invokeRestart("muffleMessage")
[18:04:47.208]                       }
[18:04:47.208]                       else if (inherits(cond, "warning")) {
[18:04:47.208]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.208]                         if (muffled) 
[18:04:47.208]                           invokeRestart("muffleWarning")
[18:04:47.208]                       }
[18:04:47.208]                       else if (inherits(cond, "condition")) {
[18:04:47.208]                         if (!is.null(pattern)) {
[18:04:47.208]                           computeRestarts <- base::computeRestarts
[18:04:47.208]                           grepl <- base::grepl
[18:04:47.208]                           restarts <- computeRestarts(cond)
[18:04:47.208]                           for (restart in restarts) {
[18:04:47.208]                             name <- restart$name
[18:04:47.208]                             if (is.null(name)) 
[18:04:47.208]                               next
[18:04:47.208]                             if (!grepl(pattern, name)) 
[18:04:47.208]                               next
[18:04:47.208]                             invokeRestart(restart)
[18:04:47.208]                             muffled <- TRUE
[18:04:47.208]                             break
[18:04:47.208]                           }
[18:04:47.208]                         }
[18:04:47.208]                       }
[18:04:47.208]                       invisible(muffled)
[18:04:47.208]                     }
[18:04:47.208]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.208]                   }
[18:04:47.208]                 }
[18:04:47.208]                 else {
[18:04:47.208]                   if (TRUE) {
[18:04:47.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.208]                     {
[18:04:47.208]                       inherits <- base::inherits
[18:04:47.208]                       invokeRestart <- base::invokeRestart
[18:04:47.208]                       is.null <- base::is.null
[18:04:47.208]                       muffled <- FALSE
[18:04:47.208]                       if (inherits(cond, "message")) {
[18:04:47.208]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.208]                         if (muffled) 
[18:04:47.208]                           invokeRestart("muffleMessage")
[18:04:47.208]                       }
[18:04:47.208]                       else if (inherits(cond, "warning")) {
[18:04:47.208]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.208]                         if (muffled) 
[18:04:47.208]                           invokeRestart("muffleWarning")
[18:04:47.208]                       }
[18:04:47.208]                       else if (inherits(cond, "condition")) {
[18:04:47.208]                         if (!is.null(pattern)) {
[18:04:47.208]                           computeRestarts <- base::computeRestarts
[18:04:47.208]                           grepl <- base::grepl
[18:04:47.208]                           restarts <- computeRestarts(cond)
[18:04:47.208]                           for (restart in restarts) {
[18:04:47.208]                             name <- restart$name
[18:04:47.208]                             if (is.null(name)) 
[18:04:47.208]                               next
[18:04:47.208]                             if (!grepl(pattern, name)) 
[18:04:47.208]                               next
[18:04:47.208]                             invokeRestart(restart)
[18:04:47.208]                             muffled <- TRUE
[18:04:47.208]                             break
[18:04:47.208]                           }
[18:04:47.208]                         }
[18:04:47.208]                       }
[18:04:47.208]                       invisible(muffled)
[18:04:47.208]                     }
[18:04:47.208]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.208]                   }
[18:04:47.208]                 }
[18:04:47.208]             }
[18:04:47.208]         }))
[18:04:47.208]     }, error = function(ex) {
[18:04:47.208]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.208]                 ...future.rng), started = ...future.startTime, 
[18:04:47.208]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.208]             version = "1.8"), class = "FutureResult")
[18:04:47.208]     }, finally = {
[18:04:47.208]         if (!identical(...future.workdir, getwd())) 
[18:04:47.208]             setwd(...future.workdir)
[18:04:47.208]         {
[18:04:47.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.208]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.208]             }
[18:04:47.208]             base::options(...future.oldOptions)
[18:04:47.208]             if (.Platform$OS.type == "windows") {
[18:04:47.208]                 old_names <- names(...future.oldEnvVars)
[18:04:47.208]                 envs <- base::Sys.getenv()
[18:04:47.208]                 names <- names(envs)
[18:04:47.208]                 common <- intersect(names, old_names)
[18:04:47.208]                 added <- setdiff(names, old_names)
[18:04:47.208]                 removed <- setdiff(old_names, names)
[18:04:47.208]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.208]                   envs[common]]
[18:04:47.208]                 NAMES <- toupper(changed)
[18:04:47.208]                 args <- list()
[18:04:47.208]                 for (kk in seq_along(NAMES)) {
[18:04:47.208]                   name <- changed[[kk]]
[18:04:47.208]                   NAME <- NAMES[[kk]]
[18:04:47.208]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.208]                     next
[18:04:47.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.208]                 }
[18:04:47.208]                 NAMES <- toupper(added)
[18:04:47.208]                 for (kk in seq_along(NAMES)) {
[18:04:47.208]                   name <- added[[kk]]
[18:04:47.208]                   NAME <- NAMES[[kk]]
[18:04:47.208]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.208]                     next
[18:04:47.208]                   args[[name]] <- ""
[18:04:47.208]                 }
[18:04:47.208]                 NAMES <- toupper(removed)
[18:04:47.208]                 for (kk in seq_along(NAMES)) {
[18:04:47.208]                   name <- removed[[kk]]
[18:04:47.208]                   NAME <- NAMES[[kk]]
[18:04:47.208]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.208]                     next
[18:04:47.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.208]                 }
[18:04:47.208]                 if (length(args) > 0) 
[18:04:47.208]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.208]             }
[18:04:47.208]             else {
[18:04:47.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.208]             }
[18:04:47.208]             {
[18:04:47.208]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.208]                   0L) {
[18:04:47.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.208]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.208]                   base::options(opts)
[18:04:47.208]                 }
[18:04:47.208]                 {
[18:04:47.208]                   {
[18:04:47.208]                     NULL
[18:04:47.208]                     RNGkind("Mersenne-Twister")
[18:04:47.208]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:47.208]                       inherits = FALSE)
[18:04:47.208]                   }
[18:04:47.208]                   options(future.plan = NULL)
[18:04:47.208]                   if (is.na(NA_character_)) 
[18:04:47.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.208]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.208]                     .init = FALSE)
[18:04:47.208]                 }
[18:04:47.208]             }
[18:04:47.208]         }
[18:04:47.208]     })
[18:04:47.208]     if (TRUE) {
[18:04:47.208]         base::sink(type = "output", split = FALSE)
[18:04:47.208]         if (TRUE) {
[18:04:47.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.208]         }
[18:04:47.208]         else {
[18:04:47.208]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.208]         }
[18:04:47.208]         base::close(...future.stdout)
[18:04:47.208]         ...future.stdout <- NULL
[18:04:47.208]     }
[18:04:47.208]     ...future.result$conditions <- ...future.conditions
[18:04:47.208]     ...future.result$finished <- base::Sys.time()
[18:04:47.208]     ...future.result
[18:04:47.208] }
[18:04:47.211] assign_globals() ...
[18:04:47.212] List of 1
[18:04:47.212]  $ x: list()
[18:04:47.212]  - attr(*, "where")=List of 1
[18:04:47.212]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.212]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.212]  - attr(*, "resolved")= logi TRUE
[18:04:47.212]  - attr(*, "total_size")= num 0
[18:04:47.212]  - attr(*, "already-done")= logi TRUE
[18:04:47.217] - copied ‘x’ to environment
[18:04:47.217] assign_globals() ... done
[18:04:47.217] plan(): Setting new future strategy stack:
[18:04:47.218] List of future strategies:
[18:04:47.218] 1. sequential:
[18:04:47.218]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.218]    - tweaked: FALSE
[18:04:47.218]    - call: NULL
[18:04:47.219] plan(): nbrOfWorkers() = 1
[18:04:47.220] plan(): Setting new future strategy stack:
[18:04:47.221] List of future strategies:
[18:04:47.221] 1. sequential:
[18:04:47.221]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.221]    - tweaked: FALSE
[18:04:47.221]    - call: plan(strategy)
[18:04:47.222] plan(): nbrOfWorkers() = 1
[18:04:47.222] SequentialFuture started (and completed)
[18:04:47.222] - Launch lazy future ... done
[18:04:47.222] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.223] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.224] Searching for globals...
[18:04:47.228] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:47.228] Searching for globals ... DONE
[18:04:47.228] Resolving globals: TRUE
[18:04:47.229] Resolving any globals that are futures ...
[18:04:47.229] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:47.229] Resolving any globals that are futures ... DONE
[18:04:47.230] Resolving futures part of globals (recursively) ...
[18:04:47.230] resolve() on list ...
[18:04:47.231]  recursive: 99
[18:04:47.231]  length: 1
[18:04:47.231]  elements: ‘x’
[18:04:47.231]  length: 0 (resolved future 1)
[18:04:47.231] resolve() on list ... DONE
[18:04:47.232] - globals: [1] ‘x’
[18:04:47.232] Resolving futures part of globals (recursively) ... DONE
[18:04:47.232] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.233] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.233] - globals: [1] ‘x’
[18:04:47.233] 
[18:04:47.234] getGlobalsAndPackages() ... DONE
[18:04:47.234] run() for ‘Future’ ...
[18:04:47.234] - state: ‘created’
[18:04:47.235] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:47.235] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:47.235] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:47.236]   - Field: ‘label’
[18:04:47.236]   - Field: ‘local’
[18:04:47.236]   - Field: ‘owner’
[18:04:47.236]   - Field: ‘envir’
[18:04:47.237]   - Field: ‘packages’
[18:04:47.237]   - Field: ‘gc’
[18:04:47.237]   - Field: ‘conditions’
[18:04:47.237]   - Field: ‘expr’
[18:04:47.237]   - Field: ‘uuid’
[18:04:47.238]   - Field: ‘seed’
[18:04:47.238]   - Field: ‘version’
[18:04:47.238]   - Field: ‘result’
[18:04:47.238]   - Field: ‘asynchronous’
[18:04:47.238]   - Field: ‘calls’
[18:04:47.239]   - Field: ‘globals’
[18:04:47.239]   - Field: ‘stdout’
[18:04:47.239]   - Field: ‘earlySignal’
[18:04:47.239]   - Field: ‘lazy’
[18:04:47.239]   - Field: ‘state’
[18:04:47.239] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:47.240] - Launch lazy future ...
[18:04:47.240] Packages needed by the future expression (n = 0): <none>
[18:04:47.240] Packages needed by future strategies (n = 0): <none>
[18:04:47.241] {
[18:04:47.241]     {
[18:04:47.241]         {
[18:04:47.241]             ...future.startTime <- base::Sys.time()
[18:04:47.241]             {
[18:04:47.241]                 {
[18:04:47.241]                   {
[18:04:47.241]                     base::local({
[18:04:47.241]                       has_future <- base::requireNamespace("future", 
[18:04:47.241]                         quietly = TRUE)
[18:04:47.241]                       if (has_future) {
[18:04:47.241]                         ns <- base::getNamespace("future")
[18:04:47.241]                         version <- ns[[".package"]][["version"]]
[18:04:47.241]                         if (is.null(version)) 
[18:04:47.241]                           version <- utils::packageVersion("future")
[18:04:47.241]                       }
[18:04:47.241]                       else {
[18:04:47.241]                         version <- NULL
[18:04:47.241]                       }
[18:04:47.241]                       if (!has_future || version < "1.8.0") {
[18:04:47.241]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.241]                           "", base::R.version$version.string), 
[18:04:47.241]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:47.241]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.241]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.241]                             "release", "version")], collapse = " "), 
[18:04:47.241]                           hostname = base::Sys.info()[["nodename"]])
[18:04:47.241]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.241]                           info)
[18:04:47.241]                         info <- base::paste(info, collapse = "; ")
[18:04:47.241]                         if (!has_future) {
[18:04:47.241]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.241]                             info)
[18:04:47.241]                         }
[18:04:47.241]                         else {
[18:04:47.241]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.241]                             info, version)
[18:04:47.241]                         }
[18:04:47.241]                         base::stop(msg)
[18:04:47.241]                       }
[18:04:47.241]                     })
[18:04:47.241]                   }
[18:04:47.241]                   ...future.strategy.old <- future::plan("list")
[18:04:47.241]                   options(future.plan = NULL)
[18:04:47.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.241]                 }
[18:04:47.241]                 ...future.workdir <- getwd()
[18:04:47.241]             }
[18:04:47.241]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.241]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.241]         }
[18:04:47.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.241]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.241]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.241]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.241]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.241]             base::names(...future.oldOptions))
[18:04:47.241]     }
[18:04:47.241]     if (FALSE) {
[18:04:47.241]     }
[18:04:47.241]     else {
[18:04:47.241]         if (TRUE) {
[18:04:47.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.241]                 open = "w")
[18:04:47.241]         }
[18:04:47.241]         else {
[18:04:47.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.241]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.241]         }
[18:04:47.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.241]             base::sink(type = "output", split = FALSE)
[18:04:47.241]             base::close(...future.stdout)
[18:04:47.241]         }, add = TRUE)
[18:04:47.241]     }
[18:04:47.241]     ...future.frame <- base::sys.nframe()
[18:04:47.241]     ...future.conditions <- base::list()
[18:04:47.241]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.241]     if (FALSE) {
[18:04:47.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.241]     }
[18:04:47.241]     ...future.result <- base::tryCatch({
[18:04:47.241]         base::withCallingHandlers({
[18:04:47.241]             ...future.value <- base::withVisible(base::local({
[18:04:47.241]                 x[["a"]] <- 1
[18:04:47.241]                 x
[18:04:47.241]             }))
[18:04:47.241]             future::FutureResult(value = ...future.value$value, 
[18:04:47.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.241]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.241]                     ...future.globalenv.names))
[18:04:47.241]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.241]         }, condition = base::local({
[18:04:47.241]             c <- base::c
[18:04:47.241]             inherits <- base::inherits
[18:04:47.241]             invokeRestart <- base::invokeRestart
[18:04:47.241]             length <- base::length
[18:04:47.241]             list <- base::list
[18:04:47.241]             seq.int <- base::seq.int
[18:04:47.241]             signalCondition <- base::signalCondition
[18:04:47.241]             sys.calls <- base::sys.calls
[18:04:47.241]             `[[` <- base::`[[`
[18:04:47.241]             `+` <- base::`+`
[18:04:47.241]             `<<-` <- base::`<<-`
[18:04:47.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.241]                   3L)]
[18:04:47.241]             }
[18:04:47.241]             function(cond) {
[18:04:47.241]                 is_error <- inherits(cond, "error")
[18:04:47.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.241]                   NULL)
[18:04:47.241]                 if (is_error) {
[18:04:47.241]                   sessionInformation <- function() {
[18:04:47.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.241]                       search = base::search(), system = base::Sys.info())
[18:04:47.241]                   }
[18:04:47.241]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.241]                     cond$call), session = sessionInformation(), 
[18:04:47.241]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.241]                   signalCondition(cond)
[18:04:47.241]                 }
[18:04:47.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.241]                 "immediateCondition"))) {
[18:04:47.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.241]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.241]                   if (TRUE && !signal) {
[18:04:47.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.241]                     {
[18:04:47.241]                       inherits <- base::inherits
[18:04:47.241]                       invokeRestart <- base::invokeRestart
[18:04:47.241]                       is.null <- base::is.null
[18:04:47.241]                       muffled <- FALSE
[18:04:47.241]                       if (inherits(cond, "message")) {
[18:04:47.241]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.241]                         if (muffled) 
[18:04:47.241]                           invokeRestart("muffleMessage")
[18:04:47.241]                       }
[18:04:47.241]                       else if (inherits(cond, "warning")) {
[18:04:47.241]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.241]                         if (muffled) 
[18:04:47.241]                           invokeRestart("muffleWarning")
[18:04:47.241]                       }
[18:04:47.241]                       else if (inherits(cond, "condition")) {
[18:04:47.241]                         if (!is.null(pattern)) {
[18:04:47.241]                           computeRestarts <- base::computeRestarts
[18:04:47.241]                           grepl <- base::grepl
[18:04:47.241]                           restarts <- computeRestarts(cond)
[18:04:47.241]                           for (restart in restarts) {
[18:04:47.241]                             name <- restart$name
[18:04:47.241]                             if (is.null(name)) 
[18:04:47.241]                               next
[18:04:47.241]                             if (!grepl(pattern, name)) 
[18:04:47.241]                               next
[18:04:47.241]                             invokeRestart(restart)
[18:04:47.241]                             muffled <- TRUE
[18:04:47.241]                             break
[18:04:47.241]                           }
[18:04:47.241]                         }
[18:04:47.241]                       }
[18:04:47.241]                       invisible(muffled)
[18:04:47.241]                     }
[18:04:47.241]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.241]                   }
[18:04:47.241]                 }
[18:04:47.241]                 else {
[18:04:47.241]                   if (TRUE) {
[18:04:47.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.241]                     {
[18:04:47.241]                       inherits <- base::inherits
[18:04:47.241]                       invokeRestart <- base::invokeRestart
[18:04:47.241]                       is.null <- base::is.null
[18:04:47.241]                       muffled <- FALSE
[18:04:47.241]                       if (inherits(cond, "message")) {
[18:04:47.241]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.241]                         if (muffled) 
[18:04:47.241]                           invokeRestart("muffleMessage")
[18:04:47.241]                       }
[18:04:47.241]                       else if (inherits(cond, "warning")) {
[18:04:47.241]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.241]                         if (muffled) 
[18:04:47.241]                           invokeRestart("muffleWarning")
[18:04:47.241]                       }
[18:04:47.241]                       else if (inherits(cond, "condition")) {
[18:04:47.241]                         if (!is.null(pattern)) {
[18:04:47.241]                           computeRestarts <- base::computeRestarts
[18:04:47.241]                           grepl <- base::grepl
[18:04:47.241]                           restarts <- computeRestarts(cond)
[18:04:47.241]                           for (restart in restarts) {
[18:04:47.241]                             name <- restart$name
[18:04:47.241]                             if (is.null(name)) 
[18:04:47.241]                               next
[18:04:47.241]                             if (!grepl(pattern, name)) 
[18:04:47.241]                               next
[18:04:47.241]                             invokeRestart(restart)
[18:04:47.241]                             muffled <- TRUE
[18:04:47.241]                             break
[18:04:47.241]                           }
[18:04:47.241]                         }
[18:04:47.241]                       }
[18:04:47.241]                       invisible(muffled)
[18:04:47.241]                     }
[18:04:47.241]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.241]                   }
[18:04:47.241]                 }
[18:04:47.241]             }
[18:04:47.241]         }))
[18:04:47.241]     }, error = function(ex) {
[18:04:47.241]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.241]                 ...future.rng), started = ...future.startTime, 
[18:04:47.241]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.241]             version = "1.8"), class = "FutureResult")
[18:04:47.241]     }, finally = {
[18:04:47.241]         if (!identical(...future.workdir, getwd())) 
[18:04:47.241]             setwd(...future.workdir)
[18:04:47.241]         {
[18:04:47.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.241]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.241]             }
[18:04:47.241]             base::options(...future.oldOptions)
[18:04:47.241]             if (.Platform$OS.type == "windows") {
[18:04:47.241]                 old_names <- names(...future.oldEnvVars)
[18:04:47.241]                 envs <- base::Sys.getenv()
[18:04:47.241]                 names <- names(envs)
[18:04:47.241]                 common <- intersect(names, old_names)
[18:04:47.241]                 added <- setdiff(names, old_names)
[18:04:47.241]                 removed <- setdiff(old_names, names)
[18:04:47.241]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.241]                   envs[common]]
[18:04:47.241]                 NAMES <- toupper(changed)
[18:04:47.241]                 args <- list()
[18:04:47.241]                 for (kk in seq_along(NAMES)) {
[18:04:47.241]                   name <- changed[[kk]]
[18:04:47.241]                   NAME <- NAMES[[kk]]
[18:04:47.241]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.241]                     next
[18:04:47.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.241]                 }
[18:04:47.241]                 NAMES <- toupper(added)
[18:04:47.241]                 for (kk in seq_along(NAMES)) {
[18:04:47.241]                   name <- added[[kk]]
[18:04:47.241]                   NAME <- NAMES[[kk]]
[18:04:47.241]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.241]                     next
[18:04:47.241]                   args[[name]] <- ""
[18:04:47.241]                 }
[18:04:47.241]                 NAMES <- toupper(removed)
[18:04:47.241]                 for (kk in seq_along(NAMES)) {
[18:04:47.241]                   name <- removed[[kk]]
[18:04:47.241]                   NAME <- NAMES[[kk]]
[18:04:47.241]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.241]                     next
[18:04:47.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.241]                 }
[18:04:47.241]                 if (length(args) > 0) 
[18:04:47.241]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.241]             }
[18:04:47.241]             else {
[18:04:47.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.241]             }
[18:04:47.241]             {
[18:04:47.241]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.241]                   0L) {
[18:04:47.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.241]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.241]                   base::options(opts)
[18:04:47.241]                 }
[18:04:47.241]                 {
[18:04:47.241]                   {
[18:04:47.241]                     NULL
[18:04:47.241]                     RNGkind("Mersenne-Twister")
[18:04:47.241]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:47.241]                       inherits = FALSE)
[18:04:47.241]                   }
[18:04:47.241]                   options(future.plan = NULL)
[18:04:47.241]                   if (is.na(NA_character_)) 
[18:04:47.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.241]                     .init = FALSE)
[18:04:47.241]                 }
[18:04:47.241]             }
[18:04:47.241]         }
[18:04:47.241]     })
[18:04:47.241]     if (TRUE) {
[18:04:47.241]         base::sink(type = "output", split = FALSE)
[18:04:47.241]         if (TRUE) {
[18:04:47.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.241]         }
[18:04:47.241]         else {
[18:04:47.241]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.241]         }
[18:04:47.241]         base::close(...future.stdout)
[18:04:47.241]         ...future.stdout <- NULL
[18:04:47.241]     }
[18:04:47.241]     ...future.result$conditions <- ...future.conditions
[18:04:47.241]     ...future.result$finished <- base::Sys.time()
[18:04:47.241]     ...future.result
[18:04:47.241] }
[18:04:47.245] assign_globals() ...
[18:04:47.245] List of 1
[18:04:47.245]  $ x: list()
[18:04:47.245]  - attr(*, "where")=List of 1
[18:04:47.245]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.245]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.245]  - attr(*, "resolved")= logi TRUE
[18:04:47.245]  - attr(*, "total_size")= num 0
[18:04:47.245]  - attr(*, "already-done")= logi TRUE
[18:04:47.253] - copied ‘x’ to environment
[18:04:47.253] assign_globals() ... done
[18:04:47.254] plan(): Setting new future strategy stack:
[18:04:47.254] List of future strategies:
[18:04:47.254] 1. sequential:
[18:04:47.254]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.254]    - tweaked: FALSE
[18:04:47.254]    - call: NULL
[18:04:47.255] plan(): nbrOfWorkers() = 1
[18:04:47.256] plan(): Setting new future strategy stack:
[18:04:47.257] List of future strategies:
[18:04:47.257] 1. sequential:
[18:04:47.257]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.257]    - tweaked: FALSE
[18:04:47.257]    - call: plan(strategy)
[18:04:47.258] plan(): nbrOfWorkers() = 1
[18:04:47.258] SequentialFuture started (and completed)
[18:04:47.258] - Launch lazy future ... done
[18:04:47.259] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.260] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.260] Searching for globals...
[18:04:47.264] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:47.264] Searching for globals ... DONE
[18:04:47.265] Resolving globals: TRUE
[18:04:47.265] Resolving any globals that are futures ...
[18:04:47.265] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:47.265] Resolving any globals that are futures ... DONE
[18:04:47.266] Resolving futures part of globals (recursively) ...
[18:04:47.267] resolve() on list ...
[18:04:47.267]  recursive: 99
[18:04:47.267]  length: 1
[18:04:47.267]  elements: ‘x’
[18:04:47.268]  length: 0 (resolved future 1)
[18:04:47.268] resolve() on list ... DONE
[18:04:47.268] - globals: [1] ‘x’
[18:04:47.268] Resolving futures part of globals (recursively) ... DONE
[18:04:47.269] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.269] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.270] - globals: [1] ‘x’
[18:04:47.270] 
[18:04:47.270] getGlobalsAndPackages() ... DONE
[18:04:47.271] run() for ‘Future’ ...
[18:04:47.271] - state: ‘created’
[18:04:47.271] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:47.272] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:47.272] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:47.272]   - Field: ‘label’
[18:04:47.272]   - Field: ‘local’
[18:04:47.272]   - Field: ‘owner’
[18:04:47.273]   - Field: ‘envir’
[18:04:47.273]   - Field: ‘packages’
[18:04:47.273]   - Field: ‘gc’
[18:04:47.273]   - Field: ‘conditions’
[18:04:47.274]   - Field: ‘expr’
[18:04:47.274]   - Field: ‘uuid’
[18:04:47.274]   - Field: ‘seed’
[18:04:47.274]   - Field: ‘version’
[18:04:47.274]   - Field: ‘result’
[18:04:47.275]   - Field: ‘asynchronous’
[18:04:47.275]   - Field: ‘calls’
[18:04:47.275]   - Field: ‘globals’
[18:04:47.275]   - Field: ‘stdout’
[18:04:47.275]   - Field: ‘earlySignal’
[18:04:47.276]   - Field: ‘lazy’
[18:04:47.276]   - Field: ‘state’
[18:04:47.276] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:47.276] - Launch lazy future ...
[18:04:47.276] Packages needed by the future expression (n = 0): <none>
[18:04:47.277] Packages needed by future strategies (n = 0): <none>
[18:04:47.278] {
[18:04:47.278]     {
[18:04:47.278]         {
[18:04:47.278]             ...future.startTime <- base::Sys.time()
[18:04:47.278]             {
[18:04:47.278]                 {
[18:04:47.278]                   {
[18:04:47.278]                     base::local({
[18:04:47.278]                       has_future <- base::requireNamespace("future", 
[18:04:47.278]                         quietly = TRUE)
[18:04:47.278]                       if (has_future) {
[18:04:47.278]                         ns <- base::getNamespace("future")
[18:04:47.278]                         version <- ns[[".package"]][["version"]]
[18:04:47.278]                         if (is.null(version)) 
[18:04:47.278]                           version <- utils::packageVersion("future")
[18:04:47.278]                       }
[18:04:47.278]                       else {
[18:04:47.278]                         version <- NULL
[18:04:47.278]                       }
[18:04:47.278]                       if (!has_future || version < "1.8.0") {
[18:04:47.278]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.278]                           "", base::R.version$version.string), 
[18:04:47.278]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:47.278]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.278]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.278]                             "release", "version")], collapse = " "), 
[18:04:47.278]                           hostname = base::Sys.info()[["nodename"]])
[18:04:47.278]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.278]                           info)
[18:04:47.278]                         info <- base::paste(info, collapse = "; ")
[18:04:47.278]                         if (!has_future) {
[18:04:47.278]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.278]                             info)
[18:04:47.278]                         }
[18:04:47.278]                         else {
[18:04:47.278]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.278]                             info, version)
[18:04:47.278]                         }
[18:04:47.278]                         base::stop(msg)
[18:04:47.278]                       }
[18:04:47.278]                     })
[18:04:47.278]                   }
[18:04:47.278]                   ...future.strategy.old <- future::plan("list")
[18:04:47.278]                   options(future.plan = NULL)
[18:04:47.278]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.278]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.278]                 }
[18:04:47.278]                 ...future.workdir <- getwd()
[18:04:47.278]             }
[18:04:47.278]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.278]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.278]         }
[18:04:47.278]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.278]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.278]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.278]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.278]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.278]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.278]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.278]             base::names(...future.oldOptions))
[18:04:47.278]     }
[18:04:47.278]     if (FALSE) {
[18:04:47.278]     }
[18:04:47.278]     else {
[18:04:47.278]         if (TRUE) {
[18:04:47.278]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.278]                 open = "w")
[18:04:47.278]         }
[18:04:47.278]         else {
[18:04:47.278]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.278]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.278]         }
[18:04:47.278]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.278]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.278]             base::sink(type = "output", split = FALSE)
[18:04:47.278]             base::close(...future.stdout)
[18:04:47.278]         }, add = TRUE)
[18:04:47.278]     }
[18:04:47.278]     ...future.frame <- base::sys.nframe()
[18:04:47.278]     ...future.conditions <- base::list()
[18:04:47.278]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.278]     if (FALSE) {
[18:04:47.278]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.278]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.278]     }
[18:04:47.278]     ...future.result <- base::tryCatch({
[18:04:47.278]         base::withCallingHandlers({
[18:04:47.278]             ...future.value <- base::withVisible(base::local({
[18:04:47.278]                 x[["a"]] <- 1
[18:04:47.278]                 x
[18:04:47.278]             }))
[18:04:47.278]             future::FutureResult(value = ...future.value$value, 
[18:04:47.278]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.278]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.278]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.278]                     ...future.globalenv.names))
[18:04:47.278]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.278]         }, condition = base::local({
[18:04:47.278]             c <- base::c
[18:04:47.278]             inherits <- base::inherits
[18:04:47.278]             invokeRestart <- base::invokeRestart
[18:04:47.278]             length <- base::length
[18:04:47.278]             list <- base::list
[18:04:47.278]             seq.int <- base::seq.int
[18:04:47.278]             signalCondition <- base::signalCondition
[18:04:47.278]             sys.calls <- base::sys.calls
[18:04:47.278]             `[[` <- base::`[[`
[18:04:47.278]             `+` <- base::`+`
[18:04:47.278]             `<<-` <- base::`<<-`
[18:04:47.278]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.278]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.278]                   3L)]
[18:04:47.278]             }
[18:04:47.278]             function(cond) {
[18:04:47.278]                 is_error <- inherits(cond, "error")
[18:04:47.278]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.278]                   NULL)
[18:04:47.278]                 if (is_error) {
[18:04:47.278]                   sessionInformation <- function() {
[18:04:47.278]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.278]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.278]                       search = base::search(), system = base::Sys.info())
[18:04:47.278]                   }
[18:04:47.278]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.278]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.278]                     cond$call), session = sessionInformation(), 
[18:04:47.278]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.278]                   signalCondition(cond)
[18:04:47.278]                 }
[18:04:47.278]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.278]                 "immediateCondition"))) {
[18:04:47.278]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.278]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.278]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.278]                   if (TRUE && !signal) {
[18:04:47.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.278]                     {
[18:04:47.278]                       inherits <- base::inherits
[18:04:47.278]                       invokeRestart <- base::invokeRestart
[18:04:47.278]                       is.null <- base::is.null
[18:04:47.278]                       muffled <- FALSE
[18:04:47.278]                       if (inherits(cond, "message")) {
[18:04:47.278]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.278]                         if (muffled) 
[18:04:47.278]                           invokeRestart("muffleMessage")
[18:04:47.278]                       }
[18:04:47.278]                       else if (inherits(cond, "warning")) {
[18:04:47.278]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.278]                         if (muffled) 
[18:04:47.278]                           invokeRestart("muffleWarning")
[18:04:47.278]                       }
[18:04:47.278]                       else if (inherits(cond, "condition")) {
[18:04:47.278]                         if (!is.null(pattern)) {
[18:04:47.278]                           computeRestarts <- base::computeRestarts
[18:04:47.278]                           grepl <- base::grepl
[18:04:47.278]                           restarts <- computeRestarts(cond)
[18:04:47.278]                           for (restart in restarts) {
[18:04:47.278]                             name <- restart$name
[18:04:47.278]                             if (is.null(name)) 
[18:04:47.278]                               next
[18:04:47.278]                             if (!grepl(pattern, name)) 
[18:04:47.278]                               next
[18:04:47.278]                             invokeRestart(restart)
[18:04:47.278]                             muffled <- TRUE
[18:04:47.278]                             break
[18:04:47.278]                           }
[18:04:47.278]                         }
[18:04:47.278]                       }
[18:04:47.278]                       invisible(muffled)
[18:04:47.278]                     }
[18:04:47.278]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.278]                   }
[18:04:47.278]                 }
[18:04:47.278]                 else {
[18:04:47.278]                   if (TRUE) {
[18:04:47.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.278]                     {
[18:04:47.278]                       inherits <- base::inherits
[18:04:47.278]                       invokeRestart <- base::invokeRestart
[18:04:47.278]                       is.null <- base::is.null
[18:04:47.278]                       muffled <- FALSE
[18:04:47.278]                       if (inherits(cond, "message")) {
[18:04:47.278]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.278]                         if (muffled) 
[18:04:47.278]                           invokeRestart("muffleMessage")
[18:04:47.278]                       }
[18:04:47.278]                       else if (inherits(cond, "warning")) {
[18:04:47.278]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.278]                         if (muffled) 
[18:04:47.278]                           invokeRestart("muffleWarning")
[18:04:47.278]                       }
[18:04:47.278]                       else if (inherits(cond, "condition")) {
[18:04:47.278]                         if (!is.null(pattern)) {
[18:04:47.278]                           computeRestarts <- base::computeRestarts
[18:04:47.278]                           grepl <- base::grepl
[18:04:47.278]                           restarts <- computeRestarts(cond)
[18:04:47.278]                           for (restart in restarts) {
[18:04:47.278]                             name <- restart$name
[18:04:47.278]                             if (is.null(name)) 
[18:04:47.278]                               next
[18:04:47.278]                             if (!grepl(pattern, name)) 
[18:04:47.278]                               next
[18:04:47.278]                             invokeRestart(restart)
[18:04:47.278]                             muffled <- TRUE
[18:04:47.278]                             break
[18:04:47.278]                           }
[18:04:47.278]                         }
[18:04:47.278]                       }
[18:04:47.278]                       invisible(muffled)
[18:04:47.278]                     }
[18:04:47.278]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.278]                   }
[18:04:47.278]                 }
[18:04:47.278]             }
[18:04:47.278]         }))
[18:04:47.278]     }, error = function(ex) {
[18:04:47.278]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.278]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.278]                 ...future.rng), started = ...future.startTime, 
[18:04:47.278]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.278]             version = "1.8"), class = "FutureResult")
[18:04:47.278]     }, finally = {
[18:04:47.278]         if (!identical(...future.workdir, getwd())) 
[18:04:47.278]             setwd(...future.workdir)
[18:04:47.278]         {
[18:04:47.278]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.278]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.278]             }
[18:04:47.278]             base::options(...future.oldOptions)
[18:04:47.278]             if (.Platform$OS.type == "windows") {
[18:04:47.278]                 old_names <- names(...future.oldEnvVars)
[18:04:47.278]                 envs <- base::Sys.getenv()
[18:04:47.278]                 names <- names(envs)
[18:04:47.278]                 common <- intersect(names, old_names)
[18:04:47.278]                 added <- setdiff(names, old_names)
[18:04:47.278]                 removed <- setdiff(old_names, names)
[18:04:47.278]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.278]                   envs[common]]
[18:04:47.278]                 NAMES <- toupper(changed)
[18:04:47.278]                 args <- list()
[18:04:47.278]                 for (kk in seq_along(NAMES)) {
[18:04:47.278]                   name <- changed[[kk]]
[18:04:47.278]                   NAME <- NAMES[[kk]]
[18:04:47.278]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.278]                     next
[18:04:47.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.278]                 }
[18:04:47.278]                 NAMES <- toupper(added)
[18:04:47.278]                 for (kk in seq_along(NAMES)) {
[18:04:47.278]                   name <- added[[kk]]
[18:04:47.278]                   NAME <- NAMES[[kk]]
[18:04:47.278]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.278]                     next
[18:04:47.278]                   args[[name]] <- ""
[18:04:47.278]                 }
[18:04:47.278]                 NAMES <- toupper(removed)
[18:04:47.278]                 for (kk in seq_along(NAMES)) {
[18:04:47.278]                   name <- removed[[kk]]
[18:04:47.278]                   NAME <- NAMES[[kk]]
[18:04:47.278]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.278]                     next
[18:04:47.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.278]                 }
[18:04:47.278]                 if (length(args) > 0) 
[18:04:47.278]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.278]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.278]             }
[18:04:47.278]             else {
[18:04:47.278]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.278]             }
[18:04:47.278]             {
[18:04:47.278]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.278]                   0L) {
[18:04:47.278]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.278]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.278]                   base::options(opts)
[18:04:47.278]                 }
[18:04:47.278]                 {
[18:04:47.278]                   {
[18:04:47.278]                     NULL
[18:04:47.278]                     RNGkind("Mersenne-Twister")
[18:04:47.278]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:47.278]                       inherits = FALSE)
[18:04:47.278]                   }
[18:04:47.278]                   options(future.plan = NULL)
[18:04:47.278]                   if (is.na(NA_character_)) 
[18:04:47.278]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.278]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.278]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.278]                     .init = FALSE)
[18:04:47.278]                 }
[18:04:47.278]             }
[18:04:47.278]         }
[18:04:47.278]     })
[18:04:47.278]     if (TRUE) {
[18:04:47.278]         base::sink(type = "output", split = FALSE)
[18:04:47.278]         if (TRUE) {
[18:04:47.278]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.278]         }
[18:04:47.278]         else {
[18:04:47.278]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.278]         }
[18:04:47.278]         base::close(...future.stdout)
[18:04:47.278]         ...future.stdout <- NULL
[18:04:47.278]     }
[18:04:47.278]     ...future.result$conditions <- ...future.conditions
[18:04:47.278]     ...future.result$finished <- base::Sys.time()
[18:04:47.278]     ...future.result
[18:04:47.278] }
[18:04:47.281] assign_globals() ...
[18:04:47.281] List of 1
[18:04:47.281]  $ x: list()
[18:04:47.281]  - attr(*, "where")=List of 1
[18:04:47.281]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.281]  - attr(*, "resolved")= logi TRUE
[18:04:47.281]  - attr(*, "total_size")= num 0
[18:04:47.281]  - attr(*, "already-done")= logi TRUE
[18:04:47.287] - copied ‘x’ to environment
[18:04:47.287] assign_globals() ... done
[18:04:47.288] plan(): Setting new future strategy stack:
[18:04:47.288] List of future strategies:
[18:04:47.288] 1. sequential:
[18:04:47.288]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.288]    - tweaked: FALSE
[18:04:47.288]    - call: NULL
[18:04:47.289] plan(): nbrOfWorkers() = 1
[18:04:47.291] plan(): Setting new future strategy stack:
[18:04:47.291] List of future strategies:
[18:04:47.291] 1. sequential:
[18:04:47.291]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.291]    - tweaked: FALSE
[18:04:47.291]    - call: plan(strategy)
[18:04:47.292] plan(): nbrOfWorkers() = 1
[18:04:47.292] SequentialFuture started (and completed)
[18:04:47.293] - Launch lazy future ... done
[18:04:47.293] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.294] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.294] Searching for globals...
[18:04:47.299] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:47.299] Searching for globals ... DONE
[18:04:47.299] Resolving globals: TRUE
[18:04:47.300] Resolving any globals that are futures ...
[18:04:47.300] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:47.301] Resolving any globals that are futures ... DONE
[18:04:47.302] Resolving futures part of globals (recursively) ...
[18:04:47.303] resolve() on list ...
[18:04:47.303]  recursive: 99
[18:04:47.303]  length: 1
[18:04:47.303]  elements: ‘x’
[18:04:47.304]  length: 0 (resolved future 1)
[18:04:47.304] resolve() on list ... DONE
[18:04:47.304] - globals: [1] ‘x’
[18:04:47.304] Resolving futures part of globals (recursively) ... DONE
[18:04:47.305] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.305] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.306] - globals: [1] ‘x’
[18:04:47.306] 
[18:04:47.306] getGlobalsAndPackages() ... DONE
[18:04:47.307] run() for ‘Future’ ...
[18:04:47.307] - state: ‘created’
[18:04:47.307] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:47.308] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:47.308] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:47.308]   - Field: ‘label’
[18:04:47.308]   - Field: ‘local’
[18:04:47.309]   - Field: ‘owner’
[18:04:47.309]   - Field: ‘envir’
[18:04:47.309]   - Field: ‘packages’
[18:04:47.309]   - Field: ‘gc’
[18:04:47.309]   - Field: ‘conditions’
[18:04:47.310]   - Field: ‘expr’
[18:04:47.312]   - Field: ‘uuid’
[18:04:47.313]   - Field: ‘seed’
[18:04:47.313]   - Field: ‘version’
[18:04:47.313]   - Field: ‘result’
[18:04:47.313]   - Field: ‘asynchronous’
[18:04:47.313]   - Field: ‘calls’
[18:04:47.314]   - Field: ‘globals’
[18:04:47.314]   - Field: ‘stdout’
[18:04:47.314]   - Field: ‘earlySignal’
[18:04:47.314]   - Field: ‘lazy’
[18:04:47.314]   - Field: ‘state’
[18:04:47.315] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:47.315] - Launch lazy future ...
[18:04:47.315] Packages needed by the future expression (n = 0): <none>
[18:04:47.316] Packages needed by future strategies (n = 0): <none>
[18:04:47.317] {
[18:04:47.317]     {
[18:04:47.317]         {
[18:04:47.317]             ...future.startTime <- base::Sys.time()
[18:04:47.317]             {
[18:04:47.317]                 {
[18:04:47.317]                   {
[18:04:47.317]                     base::local({
[18:04:47.317]                       has_future <- base::requireNamespace("future", 
[18:04:47.317]                         quietly = TRUE)
[18:04:47.317]                       if (has_future) {
[18:04:47.317]                         ns <- base::getNamespace("future")
[18:04:47.317]                         version <- ns[[".package"]][["version"]]
[18:04:47.317]                         if (is.null(version)) 
[18:04:47.317]                           version <- utils::packageVersion("future")
[18:04:47.317]                       }
[18:04:47.317]                       else {
[18:04:47.317]                         version <- NULL
[18:04:47.317]                       }
[18:04:47.317]                       if (!has_future || version < "1.8.0") {
[18:04:47.317]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.317]                           "", base::R.version$version.string), 
[18:04:47.317]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:47.317]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.317]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.317]                             "release", "version")], collapse = " "), 
[18:04:47.317]                           hostname = base::Sys.info()[["nodename"]])
[18:04:47.317]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.317]                           info)
[18:04:47.317]                         info <- base::paste(info, collapse = "; ")
[18:04:47.317]                         if (!has_future) {
[18:04:47.317]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.317]                             info)
[18:04:47.317]                         }
[18:04:47.317]                         else {
[18:04:47.317]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.317]                             info, version)
[18:04:47.317]                         }
[18:04:47.317]                         base::stop(msg)
[18:04:47.317]                       }
[18:04:47.317]                     })
[18:04:47.317]                   }
[18:04:47.317]                   ...future.strategy.old <- future::plan("list")
[18:04:47.317]                   options(future.plan = NULL)
[18:04:47.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.317]                 }
[18:04:47.317]                 ...future.workdir <- getwd()
[18:04:47.317]             }
[18:04:47.317]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.317]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.317]         }
[18:04:47.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.317]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.317]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.317]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.317]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.317]             base::names(...future.oldOptions))
[18:04:47.317]     }
[18:04:47.317]     if (FALSE) {
[18:04:47.317]     }
[18:04:47.317]     else {
[18:04:47.317]         if (TRUE) {
[18:04:47.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.317]                 open = "w")
[18:04:47.317]         }
[18:04:47.317]         else {
[18:04:47.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.317]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.317]         }
[18:04:47.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.317]             base::sink(type = "output", split = FALSE)
[18:04:47.317]             base::close(...future.stdout)
[18:04:47.317]         }, add = TRUE)
[18:04:47.317]     }
[18:04:47.317]     ...future.frame <- base::sys.nframe()
[18:04:47.317]     ...future.conditions <- base::list()
[18:04:47.317]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.317]     if (FALSE) {
[18:04:47.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.317]     }
[18:04:47.317]     ...future.result <- base::tryCatch({
[18:04:47.317]         base::withCallingHandlers({
[18:04:47.317]             ...future.value <- base::withVisible(base::local({
[18:04:47.317]                 x["a"] <- list(1)
[18:04:47.317]                 x
[18:04:47.317]             }))
[18:04:47.317]             future::FutureResult(value = ...future.value$value, 
[18:04:47.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.317]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.317]                     ...future.globalenv.names))
[18:04:47.317]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.317]         }, condition = base::local({
[18:04:47.317]             c <- base::c
[18:04:47.317]             inherits <- base::inherits
[18:04:47.317]             invokeRestart <- base::invokeRestart
[18:04:47.317]             length <- base::length
[18:04:47.317]             list <- base::list
[18:04:47.317]             seq.int <- base::seq.int
[18:04:47.317]             signalCondition <- base::signalCondition
[18:04:47.317]             sys.calls <- base::sys.calls
[18:04:47.317]             `[[` <- base::`[[`
[18:04:47.317]             `+` <- base::`+`
[18:04:47.317]             `<<-` <- base::`<<-`
[18:04:47.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.317]                   3L)]
[18:04:47.317]             }
[18:04:47.317]             function(cond) {
[18:04:47.317]                 is_error <- inherits(cond, "error")
[18:04:47.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.317]                   NULL)
[18:04:47.317]                 if (is_error) {
[18:04:47.317]                   sessionInformation <- function() {
[18:04:47.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.317]                       search = base::search(), system = base::Sys.info())
[18:04:47.317]                   }
[18:04:47.317]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.317]                     cond$call), session = sessionInformation(), 
[18:04:47.317]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.317]                   signalCondition(cond)
[18:04:47.317]                 }
[18:04:47.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.317]                 "immediateCondition"))) {
[18:04:47.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.317]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.317]                   if (TRUE && !signal) {
[18:04:47.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.317]                     {
[18:04:47.317]                       inherits <- base::inherits
[18:04:47.317]                       invokeRestart <- base::invokeRestart
[18:04:47.317]                       is.null <- base::is.null
[18:04:47.317]                       muffled <- FALSE
[18:04:47.317]                       if (inherits(cond, "message")) {
[18:04:47.317]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.317]                         if (muffled) 
[18:04:47.317]                           invokeRestart("muffleMessage")
[18:04:47.317]                       }
[18:04:47.317]                       else if (inherits(cond, "warning")) {
[18:04:47.317]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.317]                         if (muffled) 
[18:04:47.317]                           invokeRestart("muffleWarning")
[18:04:47.317]                       }
[18:04:47.317]                       else if (inherits(cond, "condition")) {
[18:04:47.317]                         if (!is.null(pattern)) {
[18:04:47.317]                           computeRestarts <- base::computeRestarts
[18:04:47.317]                           grepl <- base::grepl
[18:04:47.317]                           restarts <- computeRestarts(cond)
[18:04:47.317]                           for (restart in restarts) {
[18:04:47.317]                             name <- restart$name
[18:04:47.317]                             if (is.null(name)) 
[18:04:47.317]                               next
[18:04:47.317]                             if (!grepl(pattern, name)) 
[18:04:47.317]                               next
[18:04:47.317]                             invokeRestart(restart)
[18:04:47.317]                             muffled <- TRUE
[18:04:47.317]                             break
[18:04:47.317]                           }
[18:04:47.317]                         }
[18:04:47.317]                       }
[18:04:47.317]                       invisible(muffled)
[18:04:47.317]                     }
[18:04:47.317]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.317]                   }
[18:04:47.317]                 }
[18:04:47.317]                 else {
[18:04:47.317]                   if (TRUE) {
[18:04:47.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.317]                     {
[18:04:47.317]                       inherits <- base::inherits
[18:04:47.317]                       invokeRestart <- base::invokeRestart
[18:04:47.317]                       is.null <- base::is.null
[18:04:47.317]                       muffled <- FALSE
[18:04:47.317]                       if (inherits(cond, "message")) {
[18:04:47.317]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.317]                         if (muffled) 
[18:04:47.317]                           invokeRestart("muffleMessage")
[18:04:47.317]                       }
[18:04:47.317]                       else if (inherits(cond, "warning")) {
[18:04:47.317]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.317]                         if (muffled) 
[18:04:47.317]                           invokeRestart("muffleWarning")
[18:04:47.317]                       }
[18:04:47.317]                       else if (inherits(cond, "condition")) {
[18:04:47.317]                         if (!is.null(pattern)) {
[18:04:47.317]                           computeRestarts <- base::computeRestarts
[18:04:47.317]                           grepl <- base::grepl
[18:04:47.317]                           restarts <- computeRestarts(cond)
[18:04:47.317]                           for (restart in restarts) {
[18:04:47.317]                             name <- restart$name
[18:04:47.317]                             if (is.null(name)) 
[18:04:47.317]                               next
[18:04:47.317]                             if (!grepl(pattern, name)) 
[18:04:47.317]                               next
[18:04:47.317]                             invokeRestart(restart)
[18:04:47.317]                             muffled <- TRUE
[18:04:47.317]                             break
[18:04:47.317]                           }
[18:04:47.317]                         }
[18:04:47.317]                       }
[18:04:47.317]                       invisible(muffled)
[18:04:47.317]                     }
[18:04:47.317]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.317]                   }
[18:04:47.317]                 }
[18:04:47.317]             }
[18:04:47.317]         }))
[18:04:47.317]     }, error = function(ex) {
[18:04:47.317]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.317]                 ...future.rng), started = ...future.startTime, 
[18:04:47.317]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.317]             version = "1.8"), class = "FutureResult")
[18:04:47.317]     }, finally = {
[18:04:47.317]         if (!identical(...future.workdir, getwd())) 
[18:04:47.317]             setwd(...future.workdir)
[18:04:47.317]         {
[18:04:47.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.317]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.317]             }
[18:04:47.317]             base::options(...future.oldOptions)
[18:04:47.317]             if (.Platform$OS.type == "windows") {
[18:04:47.317]                 old_names <- names(...future.oldEnvVars)
[18:04:47.317]                 envs <- base::Sys.getenv()
[18:04:47.317]                 names <- names(envs)
[18:04:47.317]                 common <- intersect(names, old_names)
[18:04:47.317]                 added <- setdiff(names, old_names)
[18:04:47.317]                 removed <- setdiff(old_names, names)
[18:04:47.317]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.317]                   envs[common]]
[18:04:47.317]                 NAMES <- toupper(changed)
[18:04:47.317]                 args <- list()
[18:04:47.317]                 for (kk in seq_along(NAMES)) {
[18:04:47.317]                   name <- changed[[kk]]
[18:04:47.317]                   NAME <- NAMES[[kk]]
[18:04:47.317]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.317]                     next
[18:04:47.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.317]                 }
[18:04:47.317]                 NAMES <- toupper(added)
[18:04:47.317]                 for (kk in seq_along(NAMES)) {
[18:04:47.317]                   name <- added[[kk]]
[18:04:47.317]                   NAME <- NAMES[[kk]]
[18:04:47.317]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.317]                     next
[18:04:47.317]                   args[[name]] <- ""
[18:04:47.317]                 }
[18:04:47.317]                 NAMES <- toupper(removed)
[18:04:47.317]                 for (kk in seq_along(NAMES)) {
[18:04:47.317]                   name <- removed[[kk]]
[18:04:47.317]                   NAME <- NAMES[[kk]]
[18:04:47.317]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.317]                     next
[18:04:47.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.317]                 }
[18:04:47.317]                 if (length(args) > 0) 
[18:04:47.317]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.317]             }
[18:04:47.317]             else {
[18:04:47.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.317]             }
[18:04:47.317]             {
[18:04:47.317]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.317]                   0L) {
[18:04:47.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.317]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.317]                   base::options(opts)
[18:04:47.317]                 }
[18:04:47.317]                 {
[18:04:47.317]                   {
[18:04:47.317]                     NULL
[18:04:47.317]                     RNGkind("Mersenne-Twister")
[18:04:47.317]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:47.317]                       inherits = FALSE)
[18:04:47.317]                   }
[18:04:47.317]                   options(future.plan = NULL)
[18:04:47.317]                   if (is.na(NA_character_)) 
[18:04:47.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.317]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.317]                     .init = FALSE)
[18:04:47.317]                 }
[18:04:47.317]             }
[18:04:47.317]         }
[18:04:47.317]     })
[18:04:47.317]     if (TRUE) {
[18:04:47.317]         base::sink(type = "output", split = FALSE)
[18:04:47.317]         if (TRUE) {
[18:04:47.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.317]         }
[18:04:47.317]         else {
[18:04:47.317]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.317]         }
[18:04:47.317]         base::close(...future.stdout)
[18:04:47.317]         ...future.stdout <- NULL
[18:04:47.317]     }
[18:04:47.317]     ...future.result$conditions <- ...future.conditions
[18:04:47.317]     ...future.result$finished <- base::Sys.time()
[18:04:47.317]     ...future.result
[18:04:47.317] }
[18:04:47.320] assign_globals() ...
[18:04:47.320] List of 1
[18:04:47.320]  $ x: list()
[18:04:47.320]  - attr(*, "where")=List of 1
[18:04:47.320]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.320]  - attr(*, "resolved")= logi TRUE
[18:04:47.320]  - attr(*, "total_size")= num 0
[18:04:47.320]  - attr(*, "already-done")= logi TRUE
[18:04:47.325] - copied ‘x’ to environment
[18:04:47.326] assign_globals() ... done
[18:04:47.326] plan(): Setting new future strategy stack:
[18:04:47.326] List of future strategies:
[18:04:47.326] 1. sequential:
[18:04:47.326]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.326]    - tweaked: FALSE
[18:04:47.326]    - call: NULL
[18:04:47.327] plan(): nbrOfWorkers() = 1
[18:04:47.329] plan(): Setting new future strategy stack:
[18:04:47.329] List of future strategies:
[18:04:47.329] 1. sequential:
[18:04:47.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.329]    - tweaked: FALSE
[18:04:47.329]    - call: plan(strategy)
[18:04:47.330] plan(): nbrOfWorkers() = 1
[18:04:47.331] SequentialFuture started (and completed)
[18:04:47.331] - Launch lazy future ... done
[18:04:47.331] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.332] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.332] Searching for globals...
[18:04:47.337] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:47.337] Searching for globals ... DONE
[18:04:47.337] Resolving globals: TRUE
[18:04:47.338] Resolving any globals that are futures ...
[18:04:47.338] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:47.338] Resolving any globals that are futures ... DONE
[18:04:47.339] Resolving futures part of globals (recursively) ...
[18:04:47.340] resolve() on list ...
[18:04:47.340]  recursive: 99
[18:04:47.340]  length: 1
[18:04:47.340]  elements: ‘x’
[18:04:47.340]  length: 0 (resolved future 1)
[18:04:47.341] resolve() on list ... DONE
[18:04:47.341] - globals: [1] ‘x’
[18:04:47.341] Resolving futures part of globals (recursively) ... DONE
[18:04:47.341] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.343] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.344] - globals: [1] ‘x’
[18:04:47.346] 
[18:04:47.346] getGlobalsAndPackages() ... DONE
[18:04:47.347] run() for ‘Future’ ...
[18:04:47.347] - state: ‘created’
[18:04:47.348] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:47.348] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:47.348] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:47.349]   - Field: ‘label’
[18:04:47.349]   - Field: ‘local’
[18:04:47.349]   - Field: ‘owner’
[18:04:47.349]   - Field: ‘envir’
[18:04:47.350]   - Field: ‘packages’
[18:04:47.350]   - Field: ‘gc’
[18:04:47.350]   - Field: ‘conditions’
[18:04:47.350]   - Field: ‘expr’
[18:04:47.350]   - Field: ‘uuid’
[18:04:47.351]   - Field: ‘seed’
[18:04:47.351]   - Field: ‘version’
[18:04:47.351]   - Field: ‘result’
[18:04:47.351]   - Field: ‘asynchronous’
[18:04:47.351]   - Field: ‘calls’
[18:04:47.352]   - Field: ‘globals’
[18:04:47.352]   - Field: ‘stdout’
[18:04:47.352]   - Field: ‘earlySignal’
[18:04:47.352]   - Field: ‘lazy’
[18:04:47.352]   - Field: ‘state’
[18:04:47.353] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:47.353] - Launch lazy future ...
[18:04:47.353] Packages needed by the future expression (n = 0): <none>
[18:04:47.353] Packages needed by future strategies (n = 0): <none>
[18:04:47.354] {
[18:04:47.354]     {
[18:04:47.354]         {
[18:04:47.354]             ...future.startTime <- base::Sys.time()
[18:04:47.354]             {
[18:04:47.354]                 {
[18:04:47.354]                   {
[18:04:47.354]                     base::local({
[18:04:47.354]                       has_future <- base::requireNamespace("future", 
[18:04:47.354]                         quietly = TRUE)
[18:04:47.354]                       if (has_future) {
[18:04:47.354]                         ns <- base::getNamespace("future")
[18:04:47.354]                         version <- ns[[".package"]][["version"]]
[18:04:47.354]                         if (is.null(version)) 
[18:04:47.354]                           version <- utils::packageVersion("future")
[18:04:47.354]                       }
[18:04:47.354]                       else {
[18:04:47.354]                         version <- NULL
[18:04:47.354]                       }
[18:04:47.354]                       if (!has_future || version < "1.8.0") {
[18:04:47.354]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.354]                           "", base::R.version$version.string), 
[18:04:47.354]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:47.354]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.354]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.354]                             "release", "version")], collapse = " "), 
[18:04:47.354]                           hostname = base::Sys.info()[["nodename"]])
[18:04:47.354]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.354]                           info)
[18:04:47.354]                         info <- base::paste(info, collapse = "; ")
[18:04:47.354]                         if (!has_future) {
[18:04:47.354]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.354]                             info)
[18:04:47.354]                         }
[18:04:47.354]                         else {
[18:04:47.354]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.354]                             info, version)
[18:04:47.354]                         }
[18:04:47.354]                         base::stop(msg)
[18:04:47.354]                       }
[18:04:47.354]                     })
[18:04:47.354]                   }
[18:04:47.354]                   ...future.strategy.old <- future::plan("list")
[18:04:47.354]                   options(future.plan = NULL)
[18:04:47.354]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.354]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.354]                 }
[18:04:47.354]                 ...future.workdir <- getwd()
[18:04:47.354]             }
[18:04:47.354]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.354]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.354]         }
[18:04:47.354]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.354]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.354]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.354]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.354]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.354]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.354]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.354]             base::names(...future.oldOptions))
[18:04:47.354]     }
[18:04:47.354]     if (FALSE) {
[18:04:47.354]     }
[18:04:47.354]     else {
[18:04:47.354]         if (TRUE) {
[18:04:47.354]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.354]                 open = "w")
[18:04:47.354]         }
[18:04:47.354]         else {
[18:04:47.354]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.354]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.354]         }
[18:04:47.354]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.354]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.354]             base::sink(type = "output", split = FALSE)
[18:04:47.354]             base::close(...future.stdout)
[18:04:47.354]         }, add = TRUE)
[18:04:47.354]     }
[18:04:47.354]     ...future.frame <- base::sys.nframe()
[18:04:47.354]     ...future.conditions <- base::list()
[18:04:47.354]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.354]     if (FALSE) {
[18:04:47.354]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.354]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.354]     }
[18:04:47.354]     ...future.result <- base::tryCatch({
[18:04:47.354]         base::withCallingHandlers({
[18:04:47.354]             ...future.value <- base::withVisible(base::local({
[18:04:47.354]                 x["a"] <- list(1)
[18:04:47.354]                 x
[18:04:47.354]             }))
[18:04:47.354]             future::FutureResult(value = ...future.value$value, 
[18:04:47.354]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.354]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.354]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.354]                     ...future.globalenv.names))
[18:04:47.354]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.354]         }, condition = base::local({
[18:04:47.354]             c <- base::c
[18:04:47.354]             inherits <- base::inherits
[18:04:47.354]             invokeRestart <- base::invokeRestart
[18:04:47.354]             length <- base::length
[18:04:47.354]             list <- base::list
[18:04:47.354]             seq.int <- base::seq.int
[18:04:47.354]             signalCondition <- base::signalCondition
[18:04:47.354]             sys.calls <- base::sys.calls
[18:04:47.354]             `[[` <- base::`[[`
[18:04:47.354]             `+` <- base::`+`
[18:04:47.354]             `<<-` <- base::`<<-`
[18:04:47.354]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.354]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.354]                   3L)]
[18:04:47.354]             }
[18:04:47.354]             function(cond) {
[18:04:47.354]                 is_error <- inherits(cond, "error")
[18:04:47.354]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.354]                   NULL)
[18:04:47.354]                 if (is_error) {
[18:04:47.354]                   sessionInformation <- function() {
[18:04:47.354]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.354]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.354]                       search = base::search(), system = base::Sys.info())
[18:04:47.354]                   }
[18:04:47.354]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.354]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.354]                     cond$call), session = sessionInformation(), 
[18:04:47.354]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.354]                   signalCondition(cond)
[18:04:47.354]                 }
[18:04:47.354]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.354]                 "immediateCondition"))) {
[18:04:47.354]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.354]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.354]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.354]                   if (TRUE && !signal) {
[18:04:47.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.354]                     {
[18:04:47.354]                       inherits <- base::inherits
[18:04:47.354]                       invokeRestart <- base::invokeRestart
[18:04:47.354]                       is.null <- base::is.null
[18:04:47.354]                       muffled <- FALSE
[18:04:47.354]                       if (inherits(cond, "message")) {
[18:04:47.354]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.354]                         if (muffled) 
[18:04:47.354]                           invokeRestart("muffleMessage")
[18:04:47.354]                       }
[18:04:47.354]                       else if (inherits(cond, "warning")) {
[18:04:47.354]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.354]                         if (muffled) 
[18:04:47.354]                           invokeRestart("muffleWarning")
[18:04:47.354]                       }
[18:04:47.354]                       else if (inherits(cond, "condition")) {
[18:04:47.354]                         if (!is.null(pattern)) {
[18:04:47.354]                           computeRestarts <- base::computeRestarts
[18:04:47.354]                           grepl <- base::grepl
[18:04:47.354]                           restarts <- computeRestarts(cond)
[18:04:47.354]                           for (restart in restarts) {
[18:04:47.354]                             name <- restart$name
[18:04:47.354]                             if (is.null(name)) 
[18:04:47.354]                               next
[18:04:47.354]                             if (!grepl(pattern, name)) 
[18:04:47.354]                               next
[18:04:47.354]                             invokeRestart(restart)
[18:04:47.354]                             muffled <- TRUE
[18:04:47.354]                             break
[18:04:47.354]                           }
[18:04:47.354]                         }
[18:04:47.354]                       }
[18:04:47.354]                       invisible(muffled)
[18:04:47.354]                     }
[18:04:47.354]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.354]                   }
[18:04:47.354]                 }
[18:04:47.354]                 else {
[18:04:47.354]                   if (TRUE) {
[18:04:47.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.354]                     {
[18:04:47.354]                       inherits <- base::inherits
[18:04:47.354]                       invokeRestart <- base::invokeRestart
[18:04:47.354]                       is.null <- base::is.null
[18:04:47.354]                       muffled <- FALSE
[18:04:47.354]                       if (inherits(cond, "message")) {
[18:04:47.354]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.354]                         if (muffled) 
[18:04:47.354]                           invokeRestart("muffleMessage")
[18:04:47.354]                       }
[18:04:47.354]                       else if (inherits(cond, "warning")) {
[18:04:47.354]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.354]                         if (muffled) 
[18:04:47.354]                           invokeRestart("muffleWarning")
[18:04:47.354]                       }
[18:04:47.354]                       else if (inherits(cond, "condition")) {
[18:04:47.354]                         if (!is.null(pattern)) {
[18:04:47.354]                           computeRestarts <- base::computeRestarts
[18:04:47.354]                           grepl <- base::grepl
[18:04:47.354]                           restarts <- computeRestarts(cond)
[18:04:47.354]                           for (restart in restarts) {
[18:04:47.354]                             name <- restart$name
[18:04:47.354]                             if (is.null(name)) 
[18:04:47.354]                               next
[18:04:47.354]                             if (!grepl(pattern, name)) 
[18:04:47.354]                               next
[18:04:47.354]                             invokeRestart(restart)
[18:04:47.354]                             muffled <- TRUE
[18:04:47.354]                             break
[18:04:47.354]                           }
[18:04:47.354]                         }
[18:04:47.354]                       }
[18:04:47.354]                       invisible(muffled)
[18:04:47.354]                     }
[18:04:47.354]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.354]                   }
[18:04:47.354]                 }
[18:04:47.354]             }
[18:04:47.354]         }))
[18:04:47.354]     }, error = function(ex) {
[18:04:47.354]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.354]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.354]                 ...future.rng), started = ...future.startTime, 
[18:04:47.354]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.354]             version = "1.8"), class = "FutureResult")
[18:04:47.354]     }, finally = {
[18:04:47.354]         if (!identical(...future.workdir, getwd())) 
[18:04:47.354]             setwd(...future.workdir)
[18:04:47.354]         {
[18:04:47.354]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.354]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.354]             }
[18:04:47.354]             base::options(...future.oldOptions)
[18:04:47.354]             if (.Platform$OS.type == "windows") {
[18:04:47.354]                 old_names <- names(...future.oldEnvVars)
[18:04:47.354]                 envs <- base::Sys.getenv()
[18:04:47.354]                 names <- names(envs)
[18:04:47.354]                 common <- intersect(names, old_names)
[18:04:47.354]                 added <- setdiff(names, old_names)
[18:04:47.354]                 removed <- setdiff(old_names, names)
[18:04:47.354]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.354]                   envs[common]]
[18:04:47.354]                 NAMES <- toupper(changed)
[18:04:47.354]                 args <- list()
[18:04:47.354]                 for (kk in seq_along(NAMES)) {
[18:04:47.354]                   name <- changed[[kk]]
[18:04:47.354]                   NAME <- NAMES[[kk]]
[18:04:47.354]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.354]                     next
[18:04:47.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.354]                 }
[18:04:47.354]                 NAMES <- toupper(added)
[18:04:47.354]                 for (kk in seq_along(NAMES)) {
[18:04:47.354]                   name <- added[[kk]]
[18:04:47.354]                   NAME <- NAMES[[kk]]
[18:04:47.354]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.354]                     next
[18:04:47.354]                   args[[name]] <- ""
[18:04:47.354]                 }
[18:04:47.354]                 NAMES <- toupper(removed)
[18:04:47.354]                 for (kk in seq_along(NAMES)) {
[18:04:47.354]                   name <- removed[[kk]]
[18:04:47.354]                   NAME <- NAMES[[kk]]
[18:04:47.354]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.354]                     next
[18:04:47.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.354]                 }
[18:04:47.354]                 if (length(args) > 0) 
[18:04:47.354]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.354]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.354]             }
[18:04:47.354]             else {
[18:04:47.354]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.354]             }
[18:04:47.354]             {
[18:04:47.354]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.354]                   0L) {
[18:04:47.354]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.354]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.354]                   base::options(opts)
[18:04:47.354]                 }
[18:04:47.354]                 {
[18:04:47.354]                   {
[18:04:47.354]                     NULL
[18:04:47.354]                     RNGkind("Mersenne-Twister")
[18:04:47.354]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:47.354]                       inherits = FALSE)
[18:04:47.354]                   }
[18:04:47.354]                   options(future.plan = NULL)
[18:04:47.354]                   if (is.na(NA_character_)) 
[18:04:47.354]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.354]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.354]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.354]                     .init = FALSE)
[18:04:47.354]                 }
[18:04:47.354]             }
[18:04:47.354]         }
[18:04:47.354]     })
[18:04:47.354]     if (TRUE) {
[18:04:47.354]         base::sink(type = "output", split = FALSE)
[18:04:47.354]         if (TRUE) {
[18:04:47.354]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.354]         }
[18:04:47.354]         else {
[18:04:47.354]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.354]         }
[18:04:47.354]         base::close(...future.stdout)
[18:04:47.354]         ...future.stdout <- NULL
[18:04:47.354]     }
[18:04:47.354]     ...future.result$conditions <- ...future.conditions
[18:04:47.354]     ...future.result$finished <- base::Sys.time()
[18:04:47.354]     ...future.result
[18:04:47.354] }
[18:04:47.358] assign_globals() ...
[18:04:47.358] List of 1
[18:04:47.358]  $ x: list()
[18:04:47.358]  - attr(*, "where")=List of 1
[18:04:47.358]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.358]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.358]  - attr(*, "resolved")= logi TRUE
[18:04:47.358]  - attr(*, "total_size")= num 0
[18:04:47.358]  - attr(*, "already-done")= logi TRUE
[18:04:47.364] - copied ‘x’ to environment
[18:04:47.364] assign_globals() ... done
[18:04:47.364] plan(): Setting new future strategy stack:
[18:04:47.365] List of future strategies:
[18:04:47.365] 1. sequential:
[18:04:47.365]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.365]    - tweaked: FALSE
[18:04:47.365]    - call: NULL
[18:04:47.366] plan(): nbrOfWorkers() = 1
[18:04:47.367] plan(): Setting new future strategy stack:
[18:04:47.367] List of future strategies:
[18:04:47.367] 1. sequential:
[18:04:47.367]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.367]    - tweaked: FALSE
[18:04:47.367]    - call: plan(strategy)
[18:04:47.368] plan(): nbrOfWorkers() = 1
[18:04:47.369] SequentialFuture started (and completed)
[18:04:47.371] - Launch lazy future ... done
[18:04:47.371] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.373] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.373] Searching for globals...
[18:04:47.382] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:47.383] Searching for globals ... DONE
[18:04:47.383] Resolving globals: TRUE
[18:04:47.383] Resolving any globals that are futures ...
[18:04:47.383] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:47.384] Resolving any globals that are futures ... DONE
[18:04:47.384] Resolving futures part of globals (recursively) ...
[18:04:47.388] resolve() on list ...
[18:04:47.388]  recursive: 99
[18:04:47.388]  length: 1
[18:04:47.388]  elements: ‘x’
[18:04:47.389]  length: 0 (resolved future 1)
[18:04:47.389] resolve() on list ... DONE
[18:04:47.389] - globals: [1] ‘x’
[18:04:47.389] Resolving futures part of globals (recursively) ... DONE
[18:04:47.389] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.390] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.390] - globals: [1] ‘x’
[18:04:47.391] 
[18:04:47.391] getGlobalsAndPackages() ... DONE
[18:04:47.391] run() for ‘Future’ ...
[18:04:47.392] - state: ‘created’
[18:04:47.392] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:47.392] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:47.393] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:47.393]   - Field: ‘label’
[18:04:47.393]   - Field: ‘local’
[18:04:47.393]   - Field: ‘owner’
[18:04:47.394]   - Field: ‘envir’
[18:04:47.394]   - Field: ‘packages’
[18:04:47.394]   - Field: ‘gc’
[18:04:47.394]   - Field: ‘conditions’
[18:04:47.394]   - Field: ‘expr’
[18:04:47.395]   - Field: ‘uuid’
[18:04:47.395]   - Field: ‘seed’
[18:04:47.395]   - Field: ‘version’
[18:04:47.395]   - Field: ‘result’
[18:04:47.395]   - Field: ‘asynchronous’
[18:04:47.396]   - Field: ‘calls’
[18:04:47.396]   - Field: ‘globals’
[18:04:47.396]   - Field: ‘stdout’
[18:04:47.396]   - Field: ‘earlySignal’
[18:04:47.396]   - Field: ‘lazy’
[18:04:47.397]   - Field: ‘state’
[18:04:47.397] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:47.397] - Launch lazy future ...
[18:04:47.397] Packages needed by the future expression (n = 0): <none>
[18:04:47.398] Packages needed by future strategies (n = 0): <none>
[18:04:47.398] {
[18:04:47.398]     {
[18:04:47.398]         {
[18:04:47.398]             ...future.startTime <- base::Sys.time()
[18:04:47.398]             {
[18:04:47.398]                 {
[18:04:47.398]                   {
[18:04:47.398]                     base::local({
[18:04:47.398]                       has_future <- base::requireNamespace("future", 
[18:04:47.398]                         quietly = TRUE)
[18:04:47.398]                       if (has_future) {
[18:04:47.398]                         ns <- base::getNamespace("future")
[18:04:47.398]                         version <- ns[[".package"]][["version"]]
[18:04:47.398]                         if (is.null(version)) 
[18:04:47.398]                           version <- utils::packageVersion("future")
[18:04:47.398]                       }
[18:04:47.398]                       else {
[18:04:47.398]                         version <- NULL
[18:04:47.398]                       }
[18:04:47.398]                       if (!has_future || version < "1.8.0") {
[18:04:47.398]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.398]                           "", base::R.version$version.string), 
[18:04:47.398]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:47.398]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.398]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.398]                             "release", "version")], collapse = " "), 
[18:04:47.398]                           hostname = base::Sys.info()[["nodename"]])
[18:04:47.398]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.398]                           info)
[18:04:47.398]                         info <- base::paste(info, collapse = "; ")
[18:04:47.398]                         if (!has_future) {
[18:04:47.398]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.398]                             info)
[18:04:47.398]                         }
[18:04:47.398]                         else {
[18:04:47.398]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.398]                             info, version)
[18:04:47.398]                         }
[18:04:47.398]                         base::stop(msg)
[18:04:47.398]                       }
[18:04:47.398]                     })
[18:04:47.398]                   }
[18:04:47.398]                   ...future.strategy.old <- future::plan("list")
[18:04:47.398]                   options(future.plan = NULL)
[18:04:47.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.398]                 }
[18:04:47.398]                 ...future.workdir <- getwd()
[18:04:47.398]             }
[18:04:47.398]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.398]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.398]         }
[18:04:47.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.398]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.398]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.398]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.398]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.398]             base::names(...future.oldOptions))
[18:04:47.398]     }
[18:04:47.398]     if (FALSE) {
[18:04:47.398]     }
[18:04:47.398]     else {
[18:04:47.398]         if (TRUE) {
[18:04:47.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.398]                 open = "w")
[18:04:47.398]         }
[18:04:47.398]         else {
[18:04:47.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.398]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.398]         }
[18:04:47.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.398]             base::sink(type = "output", split = FALSE)
[18:04:47.398]             base::close(...future.stdout)
[18:04:47.398]         }, add = TRUE)
[18:04:47.398]     }
[18:04:47.398]     ...future.frame <- base::sys.nframe()
[18:04:47.398]     ...future.conditions <- base::list()
[18:04:47.398]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.398]     if (FALSE) {
[18:04:47.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.398]     }
[18:04:47.398]     ...future.result <- base::tryCatch({
[18:04:47.398]         base::withCallingHandlers({
[18:04:47.398]             ...future.value <- base::withVisible(base::local({
[18:04:47.398]                 x["a"] <- list(1)
[18:04:47.398]                 x
[18:04:47.398]             }))
[18:04:47.398]             future::FutureResult(value = ...future.value$value, 
[18:04:47.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.398]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.398]                     ...future.globalenv.names))
[18:04:47.398]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.398]         }, condition = base::local({
[18:04:47.398]             c <- base::c
[18:04:47.398]             inherits <- base::inherits
[18:04:47.398]             invokeRestart <- base::invokeRestart
[18:04:47.398]             length <- base::length
[18:04:47.398]             list <- base::list
[18:04:47.398]             seq.int <- base::seq.int
[18:04:47.398]             signalCondition <- base::signalCondition
[18:04:47.398]             sys.calls <- base::sys.calls
[18:04:47.398]             `[[` <- base::`[[`
[18:04:47.398]             `+` <- base::`+`
[18:04:47.398]             `<<-` <- base::`<<-`
[18:04:47.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.398]                   3L)]
[18:04:47.398]             }
[18:04:47.398]             function(cond) {
[18:04:47.398]                 is_error <- inherits(cond, "error")
[18:04:47.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.398]                   NULL)
[18:04:47.398]                 if (is_error) {
[18:04:47.398]                   sessionInformation <- function() {
[18:04:47.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.398]                       search = base::search(), system = base::Sys.info())
[18:04:47.398]                   }
[18:04:47.398]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.398]                     cond$call), session = sessionInformation(), 
[18:04:47.398]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.398]                   signalCondition(cond)
[18:04:47.398]                 }
[18:04:47.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.398]                 "immediateCondition"))) {
[18:04:47.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.398]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.398]                   if (TRUE && !signal) {
[18:04:47.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.398]                     {
[18:04:47.398]                       inherits <- base::inherits
[18:04:47.398]                       invokeRestart <- base::invokeRestart
[18:04:47.398]                       is.null <- base::is.null
[18:04:47.398]                       muffled <- FALSE
[18:04:47.398]                       if (inherits(cond, "message")) {
[18:04:47.398]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.398]                         if (muffled) 
[18:04:47.398]                           invokeRestart("muffleMessage")
[18:04:47.398]                       }
[18:04:47.398]                       else if (inherits(cond, "warning")) {
[18:04:47.398]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.398]                         if (muffled) 
[18:04:47.398]                           invokeRestart("muffleWarning")
[18:04:47.398]                       }
[18:04:47.398]                       else if (inherits(cond, "condition")) {
[18:04:47.398]                         if (!is.null(pattern)) {
[18:04:47.398]                           computeRestarts <- base::computeRestarts
[18:04:47.398]                           grepl <- base::grepl
[18:04:47.398]                           restarts <- computeRestarts(cond)
[18:04:47.398]                           for (restart in restarts) {
[18:04:47.398]                             name <- restart$name
[18:04:47.398]                             if (is.null(name)) 
[18:04:47.398]                               next
[18:04:47.398]                             if (!grepl(pattern, name)) 
[18:04:47.398]                               next
[18:04:47.398]                             invokeRestart(restart)
[18:04:47.398]                             muffled <- TRUE
[18:04:47.398]                             break
[18:04:47.398]                           }
[18:04:47.398]                         }
[18:04:47.398]                       }
[18:04:47.398]                       invisible(muffled)
[18:04:47.398]                     }
[18:04:47.398]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.398]                   }
[18:04:47.398]                 }
[18:04:47.398]                 else {
[18:04:47.398]                   if (TRUE) {
[18:04:47.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.398]                     {
[18:04:47.398]                       inherits <- base::inherits
[18:04:47.398]                       invokeRestart <- base::invokeRestart
[18:04:47.398]                       is.null <- base::is.null
[18:04:47.398]                       muffled <- FALSE
[18:04:47.398]                       if (inherits(cond, "message")) {
[18:04:47.398]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.398]                         if (muffled) 
[18:04:47.398]                           invokeRestart("muffleMessage")
[18:04:47.398]                       }
[18:04:47.398]                       else if (inherits(cond, "warning")) {
[18:04:47.398]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.398]                         if (muffled) 
[18:04:47.398]                           invokeRestart("muffleWarning")
[18:04:47.398]                       }
[18:04:47.398]                       else if (inherits(cond, "condition")) {
[18:04:47.398]                         if (!is.null(pattern)) {
[18:04:47.398]                           computeRestarts <- base::computeRestarts
[18:04:47.398]                           grepl <- base::grepl
[18:04:47.398]                           restarts <- computeRestarts(cond)
[18:04:47.398]                           for (restart in restarts) {
[18:04:47.398]                             name <- restart$name
[18:04:47.398]                             if (is.null(name)) 
[18:04:47.398]                               next
[18:04:47.398]                             if (!grepl(pattern, name)) 
[18:04:47.398]                               next
[18:04:47.398]                             invokeRestart(restart)
[18:04:47.398]                             muffled <- TRUE
[18:04:47.398]                             break
[18:04:47.398]                           }
[18:04:47.398]                         }
[18:04:47.398]                       }
[18:04:47.398]                       invisible(muffled)
[18:04:47.398]                     }
[18:04:47.398]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.398]                   }
[18:04:47.398]                 }
[18:04:47.398]             }
[18:04:47.398]         }))
[18:04:47.398]     }, error = function(ex) {
[18:04:47.398]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.398]                 ...future.rng), started = ...future.startTime, 
[18:04:47.398]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.398]             version = "1.8"), class = "FutureResult")
[18:04:47.398]     }, finally = {
[18:04:47.398]         if (!identical(...future.workdir, getwd())) 
[18:04:47.398]             setwd(...future.workdir)
[18:04:47.398]         {
[18:04:47.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.398]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.398]             }
[18:04:47.398]             base::options(...future.oldOptions)
[18:04:47.398]             if (.Platform$OS.type == "windows") {
[18:04:47.398]                 old_names <- names(...future.oldEnvVars)
[18:04:47.398]                 envs <- base::Sys.getenv()
[18:04:47.398]                 names <- names(envs)
[18:04:47.398]                 common <- intersect(names, old_names)
[18:04:47.398]                 added <- setdiff(names, old_names)
[18:04:47.398]                 removed <- setdiff(old_names, names)
[18:04:47.398]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.398]                   envs[common]]
[18:04:47.398]                 NAMES <- toupper(changed)
[18:04:47.398]                 args <- list()
[18:04:47.398]                 for (kk in seq_along(NAMES)) {
[18:04:47.398]                   name <- changed[[kk]]
[18:04:47.398]                   NAME <- NAMES[[kk]]
[18:04:47.398]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.398]                     next
[18:04:47.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.398]                 }
[18:04:47.398]                 NAMES <- toupper(added)
[18:04:47.398]                 for (kk in seq_along(NAMES)) {
[18:04:47.398]                   name <- added[[kk]]
[18:04:47.398]                   NAME <- NAMES[[kk]]
[18:04:47.398]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.398]                     next
[18:04:47.398]                   args[[name]] <- ""
[18:04:47.398]                 }
[18:04:47.398]                 NAMES <- toupper(removed)
[18:04:47.398]                 for (kk in seq_along(NAMES)) {
[18:04:47.398]                   name <- removed[[kk]]
[18:04:47.398]                   NAME <- NAMES[[kk]]
[18:04:47.398]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.398]                     next
[18:04:47.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.398]                 }
[18:04:47.398]                 if (length(args) > 0) 
[18:04:47.398]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.398]             }
[18:04:47.398]             else {
[18:04:47.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.398]             }
[18:04:47.398]             {
[18:04:47.398]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.398]                   0L) {
[18:04:47.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.398]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.398]                   base::options(opts)
[18:04:47.398]                 }
[18:04:47.398]                 {
[18:04:47.398]                   {
[18:04:47.398]                     NULL
[18:04:47.398]                     RNGkind("Mersenne-Twister")
[18:04:47.398]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:47.398]                       inherits = FALSE)
[18:04:47.398]                   }
[18:04:47.398]                   options(future.plan = NULL)
[18:04:47.398]                   if (is.na(NA_character_)) 
[18:04:47.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.398]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.398]                     .init = FALSE)
[18:04:47.398]                 }
[18:04:47.398]             }
[18:04:47.398]         }
[18:04:47.398]     })
[18:04:47.398]     if (TRUE) {
[18:04:47.398]         base::sink(type = "output", split = FALSE)
[18:04:47.398]         if (TRUE) {
[18:04:47.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.398]         }
[18:04:47.398]         else {
[18:04:47.398]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.398]         }
[18:04:47.398]         base::close(...future.stdout)
[18:04:47.398]         ...future.stdout <- NULL
[18:04:47.398]     }
[18:04:47.398]     ...future.result$conditions <- ...future.conditions
[18:04:47.398]     ...future.result$finished <- base::Sys.time()
[18:04:47.398]     ...future.result
[18:04:47.398] }
[18:04:47.402] assign_globals() ...
[18:04:47.402] List of 1
[18:04:47.402]  $ x: list()
[18:04:47.402]  - attr(*, "where")=List of 1
[18:04:47.402]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.402]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.402]  - attr(*, "resolved")= logi TRUE
[18:04:47.402]  - attr(*, "total_size")= num 0
[18:04:47.402]  - attr(*, "already-done")= logi TRUE
[18:04:47.407] - copied ‘x’ to environment
[18:04:47.407] assign_globals() ... done
[18:04:47.408] plan(): Setting new future strategy stack:
[18:04:47.409] List of future strategies:
[18:04:47.409] 1. sequential:
[18:04:47.409]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.409]    - tweaked: FALSE
[18:04:47.409]    - call: NULL
[18:04:47.410] plan(): nbrOfWorkers() = 1
[18:04:47.411] plan(): Setting new future strategy stack:
[18:04:47.412] List of future strategies:
[18:04:47.412] 1. sequential:
[18:04:47.412]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.412]    - tweaked: FALSE
[18:04:47.412]    - call: plan(strategy)
[18:04:47.413] plan(): nbrOfWorkers() = 1
[18:04:47.413] SequentialFuture started (and completed)
[18:04:47.413] - Launch lazy future ... done
[18:04:47.414] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.415] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.415] Searching for globals...
[18:04:47.420] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[18:04:47.420] Searching for globals ... DONE
[18:04:47.420] Resolving globals: TRUE
[18:04:47.421] Resolving any globals that are futures ...
[18:04:47.421] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[18:04:47.421] Resolving any globals that are futures ... DONE
[18:04:47.422] Resolving futures part of globals (recursively) ...
[18:04:47.422] resolve() on list ...
[18:04:47.423]  recursive: 99
[18:04:47.423]  length: 2
[18:04:47.423]  elements: ‘x’, ‘name’
[18:04:47.423]  length: 1 (resolved future 1)
[18:04:47.424]  length: 0 (resolved future 2)
[18:04:47.424] resolve() on list ... DONE
[18:04:47.424] - globals: [2] ‘x’, ‘name’
[18:04:47.424] Resolving futures part of globals (recursively) ... DONE
[18:04:47.425] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:47.426] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[18:04:47.426] - globals: [2] ‘x’, ‘name’
[18:04:47.426] 
[18:04:47.427] getGlobalsAndPackages() ... DONE
[18:04:47.427] run() for ‘Future’ ...
[18:04:47.427] - state: ‘created’
[18:04:47.428] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:47.428] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:47.428] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:47.429]   - Field: ‘label’
[18:04:47.429]   - Field: ‘local’
[18:04:47.429]   - Field: ‘owner’
[18:04:47.429]   - Field: ‘envir’
[18:04:47.430]   - Field: ‘packages’
[18:04:47.430]   - Field: ‘gc’
[18:04:47.430]   - Field: ‘conditions’
[18:04:47.430]   - Field: ‘expr’
[18:04:47.430]   - Field: ‘uuid’
[18:04:47.431]   - Field: ‘seed’
[18:04:47.431]   - Field: ‘version’
[18:04:47.431]   - Field: ‘result’
[18:04:47.431]   - Field: ‘asynchronous’
[18:04:47.431]   - Field: ‘calls’
[18:04:47.432]   - Field: ‘globals’
[18:04:47.432]   - Field: ‘stdout’
[18:04:47.432]   - Field: ‘earlySignal’
[18:04:47.432]   - Field: ‘lazy’
[18:04:47.432]   - Field: ‘state’
[18:04:47.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:47.433] - Launch lazy future ...
[18:04:47.433] Packages needed by the future expression (n = 0): <none>
[18:04:47.433] Packages needed by future strategies (n = 0): <none>
[18:04:47.434] {
[18:04:47.434]     {
[18:04:47.434]         {
[18:04:47.434]             ...future.startTime <- base::Sys.time()
[18:04:47.434]             {
[18:04:47.434]                 {
[18:04:47.434]                   {
[18:04:47.434]                     base::local({
[18:04:47.434]                       has_future <- base::requireNamespace("future", 
[18:04:47.434]                         quietly = TRUE)
[18:04:47.434]                       if (has_future) {
[18:04:47.434]                         ns <- base::getNamespace("future")
[18:04:47.434]                         version <- ns[[".package"]][["version"]]
[18:04:47.434]                         if (is.null(version)) 
[18:04:47.434]                           version <- utils::packageVersion("future")
[18:04:47.434]                       }
[18:04:47.434]                       else {
[18:04:47.434]                         version <- NULL
[18:04:47.434]                       }
[18:04:47.434]                       if (!has_future || version < "1.8.0") {
[18:04:47.434]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.434]                           "", base::R.version$version.string), 
[18:04:47.434]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:47.434]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.434]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.434]                             "release", "version")], collapse = " "), 
[18:04:47.434]                           hostname = base::Sys.info()[["nodename"]])
[18:04:47.434]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.434]                           info)
[18:04:47.434]                         info <- base::paste(info, collapse = "; ")
[18:04:47.434]                         if (!has_future) {
[18:04:47.434]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.434]                             info)
[18:04:47.434]                         }
[18:04:47.434]                         else {
[18:04:47.434]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.434]                             info, version)
[18:04:47.434]                         }
[18:04:47.434]                         base::stop(msg)
[18:04:47.434]                       }
[18:04:47.434]                     })
[18:04:47.434]                   }
[18:04:47.434]                   ...future.strategy.old <- future::plan("list")
[18:04:47.434]                   options(future.plan = NULL)
[18:04:47.434]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.434]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.434]                 }
[18:04:47.434]                 ...future.workdir <- getwd()
[18:04:47.434]             }
[18:04:47.434]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.434]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.434]         }
[18:04:47.434]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.434]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.434]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.434]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.434]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.434]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.434]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.434]             base::names(...future.oldOptions))
[18:04:47.434]     }
[18:04:47.434]     if (FALSE) {
[18:04:47.434]     }
[18:04:47.434]     else {
[18:04:47.434]         if (TRUE) {
[18:04:47.434]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.434]                 open = "w")
[18:04:47.434]         }
[18:04:47.434]         else {
[18:04:47.434]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.434]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.434]         }
[18:04:47.434]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.434]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.434]             base::sink(type = "output", split = FALSE)
[18:04:47.434]             base::close(...future.stdout)
[18:04:47.434]         }, add = TRUE)
[18:04:47.434]     }
[18:04:47.434]     ...future.frame <- base::sys.nframe()
[18:04:47.434]     ...future.conditions <- base::list()
[18:04:47.434]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.434]     if (FALSE) {
[18:04:47.434]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.434]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.434]     }
[18:04:47.434]     ...future.result <- base::tryCatch({
[18:04:47.434]         base::withCallingHandlers({
[18:04:47.434]             ...future.value <- base::withVisible(base::local({
[18:04:47.434]                 x[name] <- list(1)
[18:04:47.434]                 x
[18:04:47.434]             }))
[18:04:47.434]             future::FutureResult(value = ...future.value$value, 
[18:04:47.434]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.434]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.434]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.434]                     ...future.globalenv.names))
[18:04:47.434]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.434]         }, condition = base::local({
[18:04:47.434]             c <- base::c
[18:04:47.434]             inherits <- base::inherits
[18:04:47.434]             invokeRestart <- base::invokeRestart
[18:04:47.434]             length <- base::length
[18:04:47.434]             list <- base::list
[18:04:47.434]             seq.int <- base::seq.int
[18:04:47.434]             signalCondition <- base::signalCondition
[18:04:47.434]             sys.calls <- base::sys.calls
[18:04:47.434]             `[[` <- base::`[[`
[18:04:47.434]             `+` <- base::`+`
[18:04:47.434]             `<<-` <- base::`<<-`
[18:04:47.434]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.434]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.434]                   3L)]
[18:04:47.434]             }
[18:04:47.434]             function(cond) {
[18:04:47.434]                 is_error <- inherits(cond, "error")
[18:04:47.434]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.434]                   NULL)
[18:04:47.434]                 if (is_error) {
[18:04:47.434]                   sessionInformation <- function() {
[18:04:47.434]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.434]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.434]                       search = base::search(), system = base::Sys.info())
[18:04:47.434]                   }
[18:04:47.434]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.434]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.434]                     cond$call), session = sessionInformation(), 
[18:04:47.434]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.434]                   signalCondition(cond)
[18:04:47.434]                 }
[18:04:47.434]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.434]                 "immediateCondition"))) {
[18:04:47.434]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.434]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.434]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.434]                   if (TRUE && !signal) {
[18:04:47.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.434]                     {
[18:04:47.434]                       inherits <- base::inherits
[18:04:47.434]                       invokeRestart <- base::invokeRestart
[18:04:47.434]                       is.null <- base::is.null
[18:04:47.434]                       muffled <- FALSE
[18:04:47.434]                       if (inherits(cond, "message")) {
[18:04:47.434]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.434]                         if (muffled) 
[18:04:47.434]                           invokeRestart("muffleMessage")
[18:04:47.434]                       }
[18:04:47.434]                       else if (inherits(cond, "warning")) {
[18:04:47.434]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.434]                         if (muffled) 
[18:04:47.434]                           invokeRestart("muffleWarning")
[18:04:47.434]                       }
[18:04:47.434]                       else if (inherits(cond, "condition")) {
[18:04:47.434]                         if (!is.null(pattern)) {
[18:04:47.434]                           computeRestarts <- base::computeRestarts
[18:04:47.434]                           grepl <- base::grepl
[18:04:47.434]                           restarts <- computeRestarts(cond)
[18:04:47.434]                           for (restart in restarts) {
[18:04:47.434]                             name <- restart$name
[18:04:47.434]                             if (is.null(name)) 
[18:04:47.434]                               next
[18:04:47.434]                             if (!grepl(pattern, name)) 
[18:04:47.434]                               next
[18:04:47.434]                             invokeRestart(restart)
[18:04:47.434]                             muffled <- TRUE
[18:04:47.434]                             break
[18:04:47.434]                           }
[18:04:47.434]                         }
[18:04:47.434]                       }
[18:04:47.434]                       invisible(muffled)
[18:04:47.434]                     }
[18:04:47.434]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.434]                   }
[18:04:47.434]                 }
[18:04:47.434]                 else {
[18:04:47.434]                   if (TRUE) {
[18:04:47.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.434]                     {
[18:04:47.434]                       inherits <- base::inherits
[18:04:47.434]                       invokeRestart <- base::invokeRestart
[18:04:47.434]                       is.null <- base::is.null
[18:04:47.434]                       muffled <- FALSE
[18:04:47.434]                       if (inherits(cond, "message")) {
[18:04:47.434]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.434]                         if (muffled) 
[18:04:47.434]                           invokeRestart("muffleMessage")
[18:04:47.434]                       }
[18:04:47.434]                       else if (inherits(cond, "warning")) {
[18:04:47.434]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.434]                         if (muffled) 
[18:04:47.434]                           invokeRestart("muffleWarning")
[18:04:47.434]                       }
[18:04:47.434]                       else if (inherits(cond, "condition")) {
[18:04:47.434]                         if (!is.null(pattern)) {
[18:04:47.434]                           computeRestarts <- base::computeRestarts
[18:04:47.434]                           grepl <- base::grepl
[18:04:47.434]                           restarts <- computeRestarts(cond)
[18:04:47.434]                           for (restart in restarts) {
[18:04:47.434]                             name <- restart$name
[18:04:47.434]                             if (is.null(name)) 
[18:04:47.434]                               next
[18:04:47.434]                             if (!grepl(pattern, name)) 
[18:04:47.434]                               next
[18:04:47.434]                             invokeRestart(restart)
[18:04:47.434]                             muffled <- TRUE
[18:04:47.434]                             break
[18:04:47.434]                           }
[18:04:47.434]                         }
[18:04:47.434]                       }
[18:04:47.434]                       invisible(muffled)
[18:04:47.434]                     }
[18:04:47.434]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.434]                   }
[18:04:47.434]                 }
[18:04:47.434]             }
[18:04:47.434]         }))
[18:04:47.434]     }, error = function(ex) {
[18:04:47.434]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.434]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.434]                 ...future.rng), started = ...future.startTime, 
[18:04:47.434]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.434]             version = "1.8"), class = "FutureResult")
[18:04:47.434]     }, finally = {
[18:04:47.434]         if (!identical(...future.workdir, getwd())) 
[18:04:47.434]             setwd(...future.workdir)
[18:04:47.434]         {
[18:04:47.434]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.434]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.434]             }
[18:04:47.434]             base::options(...future.oldOptions)
[18:04:47.434]             if (.Platform$OS.type == "windows") {
[18:04:47.434]                 old_names <- names(...future.oldEnvVars)
[18:04:47.434]                 envs <- base::Sys.getenv()
[18:04:47.434]                 names <- names(envs)
[18:04:47.434]                 common <- intersect(names, old_names)
[18:04:47.434]                 added <- setdiff(names, old_names)
[18:04:47.434]                 removed <- setdiff(old_names, names)
[18:04:47.434]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.434]                   envs[common]]
[18:04:47.434]                 NAMES <- toupper(changed)
[18:04:47.434]                 args <- list()
[18:04:47.434]                 for (kk in seq_along(NAMES)) {
[18:04:47.434]                   name <- changed[[kk]]
[18:04:47.434]                   NAME <- NAMES[[kk]]
[18:04:47.434]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.434]                     next
[18:04:47.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.434]                 }
[18:04:47.434]                 NAMES <- toupper(added)
[18:04:47.434]                 for (kk in seq_along(NAMES)) {
[18:04:47.434]                   name <- added[[kk]]
[18:04:47.434]                   NAME <- NAMES[[kk]]
[18:04:47.434]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.434]                     next
[18:04:47.434]                   args[[name]] <- ""
[18:04:47.434]                 }
[18:04:47.434]                 NAMES <- toupper(removed)
[18:04:47.434]                 for (kk in seq_along(NAMES)) {
[18:04:47.434]                   name <- removed[[kk]]
[18:04:47.434]                   NAME <- NAMES[[kk]]
[18:04:47.434]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.434]                     next
[18:04:47.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.434]                 }
[18:04:47.434]                 if (length(args) > 0) 
[18:04:47.434]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.434]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.434]             }
[18:04:47.434]             else {
[18:04:47.434]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.434]             }
[18:04:47.434]             {
[18:04:47.434]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.434]                   0L) {
[18:04:47.434]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.434]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.434]                   base::options(opts)
[18:04:47.434]                 }
[18:04:47.434]                 {
[18:04:47.434]                   {
[18:04:47.434]                     NULL
[18:04:47.434]                     RNGkind("Mersenne-Twister")
[18:04:47.434]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:47.434]                       inherits = FALSE)
[18:04:47.434]                   }
[18:04:47.434]                   options(future.plan = NULL)
[18:04:47.434]                   if (is.na(NA_character_)) 
[18:04:47.434]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.434]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.434]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.434]                     .init = FALSE)
[18:04:47.434]                 }
[18:04:47.434]             }
[18:04:47.434]         }
[18:04:47.434]     })
[18:04:47.434]     if (TRUE) {
[18:04:47.434]         base::sink(type = "output", split = FALSE)
[18:04:47.434]         if (TRUE) {
[18:04:47.434]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.434]         }
[18:04:47.434]         else {
[18:04:47.434]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.434]         }
[18:04:47.434]         base::close(...future.stdout)
[18:04:47.434]         ...future.stdout <- NULL
[18:04:47.434]     }
[18:04:47.434]     ...future.result$conditions <- ...future.conditions
[18:04:47.434]     ...future.result$finished <- base::Sys.time()
[18:04:47.434]     ...future.result
[18:04:47.434] }
[18:04:47.438] assign_globals() ...
[18:04:47.438] List of 2
[18:04:47.438]  $ x   : list()
[18:04:47.438]  $ name: chr "a"
[18:04:47.438]  - attr(*, "where")=List of 2
[18:04:47.438]   ..$ x   :<environment: R_EmptyEnv> 
[18:04:47.438]   ..$ name:<environment: R_EmptyEnv> 
[18:04:47.438]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.438]  - attr(*, "resolved")= logi TRUE
[18:04:47.438]  - attr(*, "total_size")= num 112
[18:04:47.438]  - attr(*, "already-done")= logi TRUE
[18:04:47.444] - copied ‘x’ to environment
[18:04:47.444] - copied ‘name’ to environment
[18:04:47.444] assign_globals() ... done
[18:04:47.445] plan(): Setting new future strategy stack:
[18:04:47.445] List of future strategies:
[18:04:47.445] 1. sequential:
[18:04:47.445]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.445]    - tweaked: FALSE
[18:04:47.445]    - call: NULL
[18:04:47.446] plan(): nbrOfWorkers() = 1
[18:04:47.448] plan(): Setting new future strategy stack:
[18:04:47.448] List of future strategies:
[18:04:47.448] 1. sequential:
[18:04:47.448]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.448]    - tweaked: FALSE
[18:04:47.448]    - call: plan(strategy)
[18:04:47.452] plan(): nbrOfWorkers() = 1
[18:04:47.452] SequentialFuture started (and completed)
[18:04:47.453] - Launch lazy future ... done
[18:04:47.453] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[18:04:47.470] plan(): Setting new future strategy stack:
[18:04:47.470] List of future strategies:
[18:04:47.470] 1. multicore:
[18:04:47.470]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:47.470]    - tweaked: FALSE
[18:04:47.470]    - call: plan(strategy)
[18:04:47.477] plan(): nbrOfWorkers() = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.477] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.478] Searching for globals...
[18:04:47.482] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.482] Searching for globals ... DONE
[18:04:47.482] Resolving globals: TRUE
[18:04:47.483] Resolving any globals that are futures ...
[18:04:47.483] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.483] Resolving any globals that are futures ... DONE
[18:04:47.484] Resolving futures part of globals (recursively) ...
[18:04:47.485] resolve() on list ...
[18:04:47.485]  recursive: 99
[18:04:47.485]  length: 1
[18:04:47.485]  elements: ‘x’
[18:04:47.486]  length: 0 (resolved future 1)
[18:04:47.486] resolve() on list ... DONE
[18:04:47.486] - globals: [1] ‘x’
[18:04:47.486] Resolving futures part of globals (recursively) ... DONE
[18:04:47.486] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.487] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.487] - globals: [1] ‘x’
[18:04:47.488] 
[18:04:47.488] getGlobalsAndPackages() ... DONE
[18:04:47.488] run() for ‘Future’ ...
[18:04:47.489] - state: ‘created’
[18:04:47.489] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:47.495] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:47.495] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:47.496]   - Field: ‘label’
[18:04:47.496]   - Field: ‘local’
[18:04:47.496]   - Field: ‘owner’
[18:04:47.496]   - Field: ‘envir’
[18:04:47.496]   - Field: ‘workers’
[18:04:47.497]   - Field: ‘packages’
[18:04:47.497]   - Field: ‘gc’
[18:04:47.497]   - Field: ‘job’
[18:04:47.497]   - Field: ‘conditions’
[18:04:47.497]   - Field: ‘expr’
[18:04:47.498]   - Field: ‘uuid’
[18:04:47.498]   - Field: ‘seed’
[18:04:47.498]   - Field: ‘version’
[18:04:47.498]   - Field: ‘result’
[18:04:47.498]   - Field: ‘asynchronous’
[18:04:47.499]   - Field: ‘calls’
[18:04:47.499]   - Field: ‘globals’
[18:04:47.499]   - Field: ‘stdout’
[18:04:47.499]   - Field: ‘earlySignal’
[18:04:47.499]   - Field: ‘lazy’
[18:04:47.500]   - Field: ‘state’
[18:04:47.500] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:47.500] - Launch lazy future ...
[18:04:47.502] Packages needed by the future expression (n = 0): <none>
[18:04:47.502] Packages needed by future strategies (n = 0): <none>
[18:04:47.503] {
[18:04:47.503]     {
[18:04:47.503]         {
[18:04:47.503]             ...future.startTime <- base::Sys.time()
[18:04:47.503]             {
[18:04:47.503]                 {
[18:04:47.503]                   {
[18:04:47.503]                     {
[18:04:47.503]                       base::local({
[18:04:47.503]                         has_future <- base::requireNamespace("future", 
[18:04:47.503]                           quietly = TRUE)
[18:04:47.503]                         if (has_future) {
[18:04:47.503]                           ns <- base::getNamespace("future")
[18:04:47.503]                           version <- ns[[".package"]][["version"]]
[18:04:47.503]                           if (is.null(version)) 
[18:04:47.503]                             version <- utils::packageVersion("future")
[18:04:47.503]                         }
[18:04:47.503]                         else {
[18:04:47.503]                           version <- NULL
[18:04:47.503]                         }
[18:04:47.503]                         if (!has_future || version < "1.8.0") {
[18:04:47.503]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.503]                             "", base::R.version$version.string), 
[18:04:47.503]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:47.503]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.503]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.503]                               "release", "version")], collapse = " "), 
[18:04:47.503]                             hostname = base::Sys.info()[["nodename"]])
[18:04:47.503]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.503]                             info)
[18:04:47.503]                           info <- base::paste(info, collapse = "; ")
[18:04:47.503]                           if (!has_future) {
[18:04:47.503]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.503]                               info)
[18:04:47.503]                           }
[18:04:47.503]                           else {
[18:04:47.503]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.503]                               info, version)
[18:04:47.503]                           }
[18:04:47.503]                           base::stop(msg)
[18:04:47.503]                         }
[18:04:47.503]                       })
[18:04:47.503]                     }
[18:04:47.503]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:47.503]                     base::options(mc.cores = 1L)
[18:04:47.503]                   }
[18:04:47.503]                   ...future.strategy.old <- future::plan("list")
[18:04:47.503]                   options(future.plan = NULL)
[18:04:47.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.503]                 }
[18:04:47.503]                 ...future.workdir <- getwd()
[18:04:47.503]             }
[18:04:47.503]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.503]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.503]         }
[18:04:47.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.503]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.503]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.503]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.503]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.503]             base::names(...future.oldOptions))
[18:04:47.503]     }
[18:04:47.503]     if (FALSE) {
[18:04:47.503]     }
[18:04:47.503]     else {
[18:04:47.503]         if (TRUE) {
[18:04:47.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.503]                 open = "w")
[18:04:47.503]         }
[18:04:47.503]         else {
[18:04:47.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.503]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.503]         }
[18:04:47.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.503]             base::sink(type = "output", split = FALSE)
[18:04:47.503]             base::close(...future.stdout)
[18:04:47.503]         }, add = TRUE)
[18:04:47.503]     }
[18:04:47.503]     ...future.frame <- base::sys.nframe()
[18:04:47.503]     ...future.conditions <- base::list()
[18:04:47.503]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.503]     if (FALSE) {
[18:04:47.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.503]     }
[18:04:47.503]     ...future.result <- base::tryCatch({
[18:04:47.503]         base::withCallingHandlers({
[18:04:47.503]             ...future.value <- base::withVisible(base::local({
[18:04:47.503]                 withCallingHandlers({
[18:04:47.503]                   {
[18:04:47.503]                     x$a <- 1
[18:04:47.503]                     x
[18:04:47.503]                   }
[18:04:47.503]                 }, immediateCondition = function(cond) {
[18:04:47.503]                   save_rds <- function (object, pathname, ...) 
[18:04:47.503]                   {
[18:04:47.503]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:47.503]                     if (file_test("-f", pathname_tmp)) {
[18:04:47.503]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.503]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:47.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.503]                         fi_tmp[["mtime"]])
[18:04:47.503]                     }
[18:04:47.503]                     tryCatch({
[18:04:47.503]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:47.503]                     }, error = function(ex) {
[18:04:47.503]                       msg <- conditionMessage(ex)
[18:04:47.503]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.503]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:47.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.503]                         fi_tmp[["mtime"]], msg)
[18:04:47.503]                       ex$message <- msg
[18:04:47.503]                       stop(ex)
[18:04:47.503]                     })
[18:04:47.503]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:47.503]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:47.503]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:47.503]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.503]                       fi <- file.info(pathname)
[18:04:47.503]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:47.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.503]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:47.503]                         fi[["size"]], fi[["mtime"]])
[18:04:47.503]                       stop(msg)
[18:04:47.503]                     }
[18:04:47.503]                     invisible(pathname)
[18:04:47.503]                   }
[18:04:47.503]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:47.503]                     rootPath = tempdir()) 
[18:04:47.503]                   {
[18:04:47.503]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:47.503]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:47.503]                       tmpdir = path, fileext = ".rds")
[18:04:47.503]                     save_rds(obj, file)
[18:04:47.503]                   }
[18:04:47.503]                   saveImmediateCondition(cond, path = "/tmp/RtmpGpkrBm/.future/immediateConditions")
[18:04:47.503]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.503]                   {
[18:04:47.503]                     inherits <- base::inherits
[18:04:47.503]                     invokeRestart <- base::invokeRestart
[18:04:47.503]                     is.null <- base::is.null
[18:04:47.503]                     muffled <- FALSE
[18:04:47.503]                     if (inherits(cond, "message")) {
[18:04:47.503]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:47.503]                       if (muffled) 
[18:04:47.503]                         invokeRestart("muffleMessage")
[18:04:47.503]                     }
[18:04:47.503]                     else if (inherits(cond, "warning")) {
[18:04:47.503]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:47.503]                       if (muffled) 
[18:04:47.503]                         invokeRestart("muffleWarning")
[18:04:47.503]                     }
[18:04:47.503]                     else if (inherits(cond, "condition")) {
[18:04:47.503]                       if (!is.null(pattern)) {
[18:04:47.503]                         computeRestarts <- base::computeRestarts
[18:04:47.503]                         grepl <- base::grepl
[18:04:47.503]                         restarts <- computeRestarts(cond)
[18:04:47.503]                         for (restart in restarts) {
[18:04:47.503]                           name <- restart$name
[18:04:47.503]                           if (is.null(name)) 
[18:04:47.503]                             next
[18:04:47.503]                           if (!grepl(pattern, name)) 
[18:04:47.503]                             next
[18:04:47.503]                           invokeRestart(restart)
[18:04:47.503]                           muffled <- TRUE
[18:04:47.503]                           break
[18:04:47.503]                         }
[18:04:47.503]                       }
[18:04:47.503]                     }
[18:04:47.503]                     invisible(muffled)
[18:04:47.503]                   }
[18:04:47.503]                   muffleCondition(cond)
[18:04:47.503]                 })
[18:04:47.503]             }))
[18:04:47.503]             future::FutureResult(value = ...future.value$value, 
[18:04:47.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.503]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.503]                     ...future.globalenv.names))
[18:04:47.503]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.503]         }, condition = base::local({
[18:04:47.503]             c <- base::c
[18:04:47.503]             inherits <- base::inherits
[18:04:47.503]             invokeRestart <- base::invokeRestart
[18:04:47.503]             length <- base::length
[18:04:47.503]             list <- base::list
[18:04:47.503]             seq.int <- base::seq.int
[18:04:47.503]             signalCondition <- base::signalCondition
[18:04:47.503]             sys.calls <- base::sys.calls
[18:04:47.503]             `[[` <- base::`[[`
[18:04:47.503]             `+` <- base::`+`
[18:04:47.503]             `<<-` <- base::`<<-`
[18:04:47.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.503]                   3L)]
[18:04:47.503]             }
[18:04:47.503]             function(cond) {
[18:04:47.503]                 is_error <- inherits(cond, "error")
[18:04:47.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.503]                   NULL)
[18:04:47.503]                 if (is_error) {
[18:04:47.503]                   sessionInformation <- function() {
[18:04:47.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.503]                       search = base::search(), system = base::Sys.info())
[18:04:47.503]                   }
[18:04:47.503]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.503]                     cond$call), session = sessionInformation(), 
[18:04:47.503]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.503]                   signalCondition(cond)
[18:04:47.503]                 }
[18:04:47.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.503]                 "immediateCondition"))) {
[18:04:47.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.503]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.503]                   if (TRUE && !signal) {
[18:04:47.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.503]                     {
[18:04:47.503]                       inherits <- base::inherits
[18:04:47.503]                       invokeRestart <- base::invokeRestart
[18:04:47.503]                       is.null <- base::is.null
[18:04:47.503]                       muffled <- FALSE
[18:04:47.503]                       if (inherits(cond, "message")) {
[18:04:47.503]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.503]                         if (muffled) 
[18:04:47.503]                           invokeRestart("muffleMessage")
[18:04:47.503]                       }
[18:04:47.503]                       else if (inherits(cond, "warning")) {
[18:04:47.503]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.503]                         if (muffled) 
[18:04:47.503]                           invokeRestart("muffleWarning")
[18:04:47.503]                       }
[18:04:47.503]                       else if (inherits(cond, "condition")) {
[18:04:47.503]                         if (!is.null(pattern)) {
[18:04:47.503]                           computeRestarts <- base::computeRestarts
[18:04:47.503]                           grepl <- base::grepl
[18:04:47.503]                           restarts <- computeRestarts(cond)
[18:04:47.503]                           for (restart in restarts) {
[18:04:47.503]                             name <- restart$name
[18:04:47.503]                             if (is.null(name)) 
[18:04:47.503]                               next
[18:04:47.503]                             if (!grepl(pattern, name)) 
[18:04:47.503]                               next
[18:04:47.503]                             invokeRestart(restart)
[18:04:47.503]                             muffled <- TRUE
[18:04:47.503]                             break
[18:04:47.503]                           }
[18:04:47.503]                         }
[18:04:47.503]                       }
[18:04:47.503]                       invisible(muffled)
[18:04:47.503]                     }
[18:04:47.503]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.503]                   }
[18:04:47.503]                 }
[18:04:47.503]                 else {
[18:04:47.503]                   if (TRUE) {
[18:04:47.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.503]                     {
[18:04:47.503]                       inherits <- base::inherits
[18:04:47.503]                       invokeRestart <- base::invokeRestart
[18:04:47.503]                       is.null <- base::is.null
[18:04:47.503]                       muffled <- FALSE
[18:04:47.503]                       if (inherits(cond, "message")) {
[18:04:47.503]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.503]                         if (muffled) 
[18:04:47.503]                           invokeRestart("muffleMessage")
[18:04:47.503]                       }
[18:04:47.503]                       else if (inherits(cond, "warning")) {
[18:04:47.503]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.503]                         if (muffled) 
[18:04:47.503]                           invokeRestart("muffleWarning")
[18:04:47.503]                       }
[18:04:47.503]                       else if (inherits(cond, "condition")) {
[18:04:47.503]                         if (!is.null(pattern)) {
[18:04:47.503]                           computeRestarts <- base::computeRestarts
[18:04:47.503]                           grepl <- base::grepl
[18:04:47.503]                           restarts <- computeRestarts(cond)
[18:04:47.503]                           for (restart in restarts) {
[18:04:47.503]                             name <- restart$name
[18:04:47.503]                             if (is.null(name)) 
[18:04:47.503]                               next
[18:04:47.503]                             if (!grepl(pattern, name)) 
[18:04:47.503]                               next
[18:04:47.503]                             invokeRestart(restart)
[18:04:47.503]                             muffled <- TRUE
[18:04:47.503]                             break
[18:04:47.503]                           }
[18:04:47.503]                         }
[18:04:47.503]                       }
[18:04:47.503]                       invisible(muffled)
[18:04:47.503]                     }
[18:04:47.503]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.503]                   }
[18:04:47.503]                 }
[18:04:47.503]             }
[18:04:47.503]         }))
[18:04:47.503]     }, error = function(ex) {
[18:04:47.503]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.503]                 ...future.rng), started = ...future.startTime, 
[18:04:47.503]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.503]             version = "1.8"), class = "FutureResult")
[18:04:47.503]     }, finally = {
[18:04:47.503]         if (!identical(...future.workdir, getwd())) 
[18:04:47.503]             setwd(...future.workdir)
[18:04:47.503]         {
[18:04:47.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.503]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.503]             }
[18:04:47.503]             base::options(...future.oldOptions)
[18:04:47.503]             if (.Platform$OS.type == "windows") {
[18:04:47.503]                 old_names <- names(...future.oldEnvVars)
[18:04:47.503]                 envs <- base::Sys.getenv()
[18:04:47.503]                 names <- names(envs)
[18:04:47.503]                 common <- intersect(names, old_names)
[18:04:47.503]                 added <- setdiff(names, old_names)
[18:04:47.503]                 removed <- setdiff(old_names, names)
[18:04:47.503]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.503]                   envs[common]]
[18:04:47.503]                 NAMES <- toupper(changed)
[18:04:47.503]                 args <- list()
[18:04:47.503]                 for (kk in seq_along(NAMES)) {
[18:04:47.503]                   name <- changed[[kk]]
[18:04:47.503]                   NAME <- NAMES[[kk]]
[18:04:47.503]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.503]                     next
[18:04:47.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.503]                 }
[18:04:47.503]                 NAMES <- toupper(added)
[18:04:47.503]                 for (kk in seq_along(NAMES)) {
[18:04:47.503]                   name <- added[[kk]]
[18:04:47.503]                   NAME <- NAMES[[kk]]
[18:04:47.503]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.503]                     next
[18:04:47.503]                   args[[name]] <- ""
[18:04:47.503]                 }
[18:04:47.503]                 NAMES <- toupper(removed)
[18:04:47.503]                 for (kk in seq_along(NAMES)) {
[18:04:47.503]                   name <- removed[[kk]]
[18:04:47.503]                   NAME <- NAMES[[kk]]
[18:04:47.503]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.503]                     next
[18:04:47.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.503]                 }
[18:04:47.503]                 if (length(args) > 0) 
[18:04:47.503]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.503]             }
[18:04:47.503]             else {
[18:04:47.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.503]             }
[18:04:47.503]             {
[18:04:47.503]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.503]                   0L) {
[18:04:47.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.503]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.503]                   base::options(opts)
[18:04:47.503]                 }
[18:04:47.503]                 {
[18:04:47.503]                   {
[18:04:47.503]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:47.503]                     NULL
[18:04:47.503]                   }
[18:04:47.503]                   options(future.plan = NULL)
[18:04:47.503]                   if (is.na(NA_character_)) 
[18:04:47.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.503]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.503]                     .init = FALSE)
[18:04:47.503]                 }
[18:04:47.503]             }
[18:04:47.503]         }
[18:04:47.503]     })
[18:04:47.503]     if (TRUE) {
[18:04:47.503]         base::sink(type = "output", split = FALSE)
[18:04:47.503]         if (TRUE) {
[18:04:47.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.503]         }
[18:04:47.503]         else {
[18:04:47.503]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.503]         }
[18:04:47.503]         base::close(...future.stdout)
[18:04:47.503]         ...future.stdout <- NULL
[18:04:47.503]     }
[18:04:47.503]     ...future.result$conditions <- ...future.conditions
[18:04:47.503]     ...future.result$finished <- base::Sys.time()
[18:04:47.503]     ...future.result
[18:04:47.503] }
[18:04:47.508] assign_globals() ...
[18:04:47.508] List of 1
[18:04:47.508]  $ x: list()
[18:04:47.508]  - attr(*, "where")=List of 1
[18:04:47.508]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.508]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.508]  - attr(*, "resolved")= logi TRUE
[18:04:47.508]  - attr(*, "total_size")= num 0
[18:04:47.508]  - attr(*, "already-done")= logi TRUE
[18:04:47.513] - copied ‘x’ to environment
[18:04:47.513] assign_globals() ... done
[18:04:47.513] requestCore(): workers = 2
[18:04:47.518] MulticoreFuture started
[18:04:47.522] plan(): Setting new future strategy stack:
[18:04:47.519] - Launch lazy future ... done
[18:04:47.523] run() for ‘MulticoreFuture’ ... done
[18:04:47.522] List of future strategies:
[18:04:47.522] 1. sequential:
[18:04:47.522]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.522]    - tweaked: FALSE
[18:04:47.522]    - call: NULL
[18:04:47.527] result() for MulticoreFuture ...
[18:04:47.526] plan(): nbrOfWorkers() = 1
[18:04:47.533] plan(): Setting new future strategy stack:
[18:04:47.534] List of future strategies:
[18:04:47.534] 1. multicore:
[18:04:47.534]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:47.534]    - tweaked: FALSE
[18:04:47.534]    - call: plan(strategy)
[18:04:47.550] plan(): nbrOfWorkers() = 2
[18:04:47.563] result() for MulticoreFuture ...
[18:04:47.564] result() for MulticoreFuture ... done
[18:04:47.564] result() for MulticoreFuture ... done
[18:04:47.564] result() for MulticoreFuture ...
[18:04:47.565] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.565] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.566] Searching for globals...
[18:04:47.571] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.571] Searching for globals ... DONE
[18:04:47.571] Resolving globals: TRUE
[18:04:47.572] Resolving any globals that are futures ...
[18:04:47.572] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.572] Resolving any globals that are futures ... DONE
[18:04:47.573] Resolving futures part of globals (recursively) ...
[18:04:47.574] resolve() on list ...
[18:04:47.574]  recursive: 99
[18:04:47.574]  length: 1
[18:04:47.574]  elements: ‘x’
[18:04:47.574]  length: 0 (resolved future 1)
[18:04:47.575] resolve() on list ... DONE
[18:04:47.575] - globals: [1] ‘x’
[18:04:47.575] Resolving futures part of globals (recursively) ... DONE
[18:04:47.576] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.576] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.577] - globals: [1] ‘x’
[18:04:47.577] 
[18:04:47.577] getGlobalsAndPackages() ... DONE
[18:04:47.578] run() for ‘Future’ ...
[18:04:47.578] - state: ‘created’
[18:04:47.578] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:47.585] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:47.585] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:47.586]   - Field: ‘label’
[18:04:47.586]   - Field: ‘local’
[18:04:47.586]   - Field: ‘owner’
[18:04:47.586]   - Field: ‘envir’
[18:04:47.587]   - Field: ‘workers’
[18:04:47.587]   - Field: ‘packages’
[18:04:47.587]   - Field: ‘gc’
[18:04:47.587]   - Field: ‘job’
[18:04:47.588]   - Field: ‘conditions’
[18:04:47.588]   - Field: ‘expr’
[18:04:47.588]   - Field: ‘uuid’
[18:04:47.588]   - Field: ‘seed’
[18:04:47.589]   - Field: ‘version’
[18:04:47.589]   - Field: ‘result’
[18:04:47.589]   - Field: ‘asynchronous’
[18:04:47.589]   - Field: ‘calls’
[18:04:47.589]   - Field: ‘globals’
[18:04:47.590]   - Field: ‘stdout’
[18:04:47.590]   - Field: ‘earlySignal’
[18:04:47.590]   - Field: ‘lazy’
[18:04:47.590]   - Field: ‘state’
[18:04:47.591] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:47.591] - Launch lazy future ...
[18:04:47.591] Packages needed by the future expression (n = 0): <none>
[18:04:47.592] Packages needed by future strategies (n = 0): <none>
[18:04:47.593] {
[18:04:47.593]     {
[18:04:47.593]         {
[18:04:47.593]             ...future.startTime <- base::Sys.time()
[18:04:47.593]             {
[18:04:47.593]                 {
[18:04:47.593]                   {
[18:04:47.593]                     {
[18:04:47.593]                       base::local({
[18:04:47.593]                         has_future <- base::requireNamespace("future", 
[18:04:47.593]                           quietly = TRUE)
[18:04:47.593]                         if (has_future) {
[18:04:47.593]                           ns <- base::getNamespace("future")
[18:04:47.593]                           version <- ns[[".package"]][["version"]]
[18:04:47.593]                           if (is.null(version)) 
[18:04:47.593]                             version <- utils::packageVersion("future")
[18:04:47.593]                         }
[18:04:47.593]                         else {
[18:04:47.593]                           version <- NULL
[18:04:47.593]                         }
[18:04:47.593]                         if (!has_future || version < "1.8.0") {
[18:04:47.593]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.593]                             "", base::R.version$version.string), 
[18:04:47.593]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:47.593]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.593]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.593]                               "release", "version")], collapse = " "), 
[18:04:47.593]                             hostname = base::Sys.info()[["nodename"]])
[18:04:47.593]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.593]                             info)
[18:04:47.593]                           info <- base::paste(info, collapse = "; ")
[18:04:47.593]                           if (!has_future) {
[18:04:47.593]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.593]                               info)
[18:04:47.593]                           }
[18:04:47.593]                           else {
[18:04:47.593]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.593]                               info, version)
[18:04:47.593]                           }
[18:04:47.593]                           base::stop(msg)
[18:04:47.593]                         }
[18:04:47.593]                       })
[18:04:47.593]                     }
[18:04:47.593]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:47.593]                     base::options(mc.cores = 1L)
[18:04:47.593]                   }
[18:04:47.593]                   ...future.strategy.old <- future::plan("list")
[18:04:47.593]                   options(future.plan = NULL)
[18:04:47.593]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.593]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.593]                 }
[18:04:47.593]                 ...future.workdir <- getwd()
[18:04:47.593]             }
[18:04:47.593]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.593]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.593]         }
[18:04:47.593]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.593]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.593]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.593]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.593]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.593]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.593]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.593]             base::names(...future.oldOptions))
[18:04:47.593]     }
[18:04:47.593]     if (FALSE) {
[18:04:47.593]     }
[18:04:47.593]     else {
[18:04:47.593]         if (TRUE) {
[18:04:47.593]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.593]                 open = "w")
[18:04:47.593]         }
[18:04:47.593]         else {
[18:04:47.593]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.593]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.593]         }
[18:04:47.593]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.593]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.593]             base::sink(type = "output", split = FALSE)
[18:04:47.593]             base::close(...future.stdout)
[18:04:47.593]         }, add = TRUE)
[18:04:47.593]     }
[18:04:47.593]     ...future.frame <- base::sys.nframe()
[18:04:47.593]     ...future.conditions <- base::list()
[18:04:47.593]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.593]     if (FALSE) {
[18:04:47.593]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.593]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.593]     }
[18:04:47.593]     ...future.result <- base::tryCatch({
[18:04:47.593]         base::withCallingHandlers({
[18:04:47.593]             ...future.value <- base::withVisible(base::local({
[18:04:47.593]                 withCallingHandlers({
[18:04:47.593]                   {
[18:04:47.593]                     x$a <- 1
[18:04:47.593]                     x
[18:04:47.593]                   }
[18:04:47.593]                 }, immediateCondition = function(cond) {
[18:04:47.593]                   save_rds <- function (object, pathname, ...) 
[18:04:47.593]                   {
[18:04:47.593]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:47.593]                     if (file_test("-f", pathname_tmp)) {
[18:04:47.593]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.593]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:47.593]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.593]                         fi_tmp[["mtime"]])
[18:04:47.593]                     }
[18:04:47.593]                     tryCatch({
[18:04:47.593]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:47.593]                     }, error = function(ex) {
[18:04:47.593]                       msg <- conditionMessage(ex)
[18:04:47.593]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.593]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:47.593]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.593]                         fi_tmp[["mtime"]], msg)
[18:04:47.593]                       ex$message <- msg
[18:04:47.593]                       stop(ex)
[18:04:47.593]                     })
[18:04:47.593]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:47.593]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:47.593]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:47.593]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.593]                       fi <- file.info(pathname)
[18:04:47.593]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:47.593]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.593]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:47.593]                         fi[["size"]], fi[["mtime"]])
[18:04:47.593]                       stop(msg)
[18:04:47.593]                     }
[18:04:47.593]                     invisible(pathname)
[18:04:47.593]                   }
[18:04:47.593]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:47.593]                     rootPath = tempdir()) 
[18:04:47.593]                   {
[18:04:47.593]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:47.593]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:47.593]                       tmpdir = path, fileext = ".rds")
[18:04:47.593]                     save_rds(obj, file)
[18:04:47.593]                   }
[18:04:47.593]                   saveImmediateCondition(cond, path = "/tmp/RtmpGpkrBm/.future/immediateConditions")
[18:04:47.593]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.593]                   {
[18:04:47.593]                     inherits <- base::inherits
[18:04:47.593]                     invokeRestart <- base::invokeRestart
[18:04:47.593]                     is.null <- base::is.null
[18:04:47.593]                     muffled <- FALSE
[18:04:47.593]                     if (inherits(cond, "message")) {
[18:04:47.593]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:47.593]                       if (muffled) 
[18:04:47.593]                         invokeRestart("muffleMessage")
[18:04:47.593]                     }
[18:04:47.593]                     else if (inherits(cond, "warning")) {
[18:04:47.593]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:47.593]                       if (muffled) 
[18:04:47.593]                         invokeRestart("muffleWarning")
[18:04:47.593]                     }
[18:04:47.593]                     else if (inherits(cond, "condition")) {
[18:04:47.593]                       if (!is.null(pattern)) {
[18:04:47.593]                         computeRestarts <- base::computeRestarts
[18:04:47.593]                         grepl <- base::grepl
[18:04:47.593]                         restarts <- computeRestarts(cond)
[18:04:47.593]                         for (restart in restarts) {
[18:04:47.593]                           name <- restart$name
[18:04:47.593]                           if (is.null(name)) 
[18:04:47.593]                             next
[18:04:47.593]                           if (!grepl(pattern, name)) 
[18:04:47.593]                             next
[18:04:47.593]                           invokeRestart(restart)
[18:04:47.593]                           muffled <- TRUE
[18:04:47.593]                           break
[18:04:47.593]                         }
[18:04:47.593]                       }
[18:04:47.593]                     }
[18:04:47.593]                     invisible(muffled)
[18:04:47.593]                   }
[18:04:47.593]                   muffleCondition(cond)
[18:04:47.593]                 })
[18:04:47.593]             }))
[18:04:47.593]             future::FutureResult(value = ...future.value$value, 
[18:04:47.593]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.593]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.593]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.593]                     ...future.globalenv.names))
[18:04:47.593]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.593]         }, condition = base::local({
[18:04:47.593]             c <- base::c
[18:04:47.593]             inherits <- base::inherits
[18:04:47.593]             invokeRestart <- base::invokeRestart
[18:04:47.593]             length <- base::length
[18:04:47.593]             list <- base::list
[18:04:47.593]             seq.int <- base::seq.int
[18:04:47.593]             signalCondition <- base::signalCondition
[18:04:47.593]             sys.calls <- base::sys.calls
[18:04:47.593]             `[[` <- base::`[[`
[18:04:47.593]             `+` <- base::`+`
[18:04:47.593]             `<<-` <- base::`<<-`
[18:04:47.593]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.593]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.593]                   3L)]
[18:04:47.593]             }
[18:04:47.593]             function(cond) {
[18:04:47.593]                 is_error <- inherits(cond, "error")
[18:04:47.593]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.593]                   NULL)
[18:04:47.593]                 if (is_error) {
[18:04:47.593]                   sessionInformation <- function() {
[18:04:47.593]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.593]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.593]                       search = base::search(), system = base::Sys.info())
[18:04:47.593]                   }
[18:04:47.593]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.593]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.593]                     cond$call), session = sessionInformation(), 
[18:04:47.593]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.593]                   signalCondition(cond)
[18:04:47.593]                 }
[18:04:47.593]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.593]                 "immediateCondition"))) {
[18:04:47.593]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.593]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.593]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.593]                   if (TRUE && !signal) {
[18:04:47.593]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.593]                     {
[18:04:47.593]                       inherits <- base::inherits
[18:04:47.593]                       invokeRestart <- base::invokeRestart
[18:04:47.593]                       is.null <- base::is.null
[18:04:47.593]                       muffled <- FALSE
[18:04:47.593]                       if (inherits(cond, "message")) {
[18:04:47.593]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.593]                         if (muffled) 
[18:04:47.593]                           invokeRestart("muffleMessage")
[18:04:47.593]                       }
[18:04:47.593]                       else if (inherits(cond, "warning")) {
[18:04:47.593]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.593]                         if (muffled) 
[18:04:47.593]                           invokeRestart("muffleWarning")
[18:04:47.593]                       }
[18:04:47.593]                       else if (inherits(cond, "condition")) {
[18:04:47.593]                         if (!is.null(pattern)) {
[18:04:47.593]                           computeRestarts <- base::computeRestarts
[18:04:47.593]                           grepl <- base::grepl
[18:04:47.593]                           restarts <- computeRestarts(cond)
[18:04:47.593]                           for (restart in restarts) {
[18:04:47.593]                             name <- restart$name
[18:04:47.593]                             if (is.null(name)) 
[18:04:47.593]                               next
[18:04:47.593]                             if (!grepl(pattern, name)) 
[18:04:47.593]                               next
[18:04:47.593]                             invokeRestart(restart)
[18:04:47.593]                             muffled <- TRUE
[18:04:47.593]                             break
[18:04:47.593]                           }
[18:04:47.593]                         }
[18:04:47.593]                       }
[18:04:47.593]                       invisible(muffled)
[18:04:47.593]                     }
[18:04:47.593]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.593]                   }
[18:04:47.593]                 }
[18:04:47.593]                 else {
[18:04:47.593]                   if (TRUE) {
[18:04:47.593]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.593]                     {
[18:04:47.593]                       inherits <- base::inherits
[18:04:47.593]                       invokeRestart <- base::invokeRestart
[18:04:47.593]                       is.null <- base::is.null
[18:04:47.593]                       muffled <- FALSE
[18:04:47.593]                       if (inherits(cond, "message")) {
[18:04:47.593]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.593]                         if (muffled) 
[18:04:47.593]                           invokeRestart("muffleMessage")
[18:04:47.593]                       }
[18:04:47.593]                       else if (inherits(cond, "warning")) {
[18:04:47.593]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.593]                         if (muffled) 
[18:04:47.593]                           invokeRestart("muffleWarning")
[18:04:47.593]                       }
[18:04:47.593]                       else if (inherits(cond, "condition")) {
[18:04:47.593]                         if (!is.null(pattern)) {
[18:04:47.593]                           computeRestarts <- base::computeRestarts
[18:04:47.593]                           grepl <- base::grepl
[18:04:47.593]                           restarts <- computeRestarts(cond)
[18:04:47.593]                           for (restart in restarts) {
[18:04:47.593]                             name <- restart$name
[18:04:47.593]                             if (is.null(name)) 
[18:04:47.593]                               next
[18:04:47.593]                             if (!grepl(pattern, name)) 
[18:04:47.593]                               next
[18:04:47.593]                             invokeRestart(restart)
[18:04:47.593]                             muffled <- TRUE
[18:04:47.593]                             break
[18:04:47.593]                           }
[18:04:47.593]                         }
[18:04:47.593]                       }
[18:04:47.593]                       invisible(muffled)
[18:04:47.593]                     }
[18:04:47.593]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.593]                   }
[18:04:47.593]                 }
[18:04:47.593]             }
[18:04:47.593]         }))
[18:04:47.593]     }, error = function(ex) {
[18:04:47.593]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.593]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.593]                 ...future.rng), started = ...future.startTime, 
[18:04:47.593]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.593]             version = "1.8"), class = "FutureResult")
[18:04:47.593]     }, finally = {
[18:04:47.593]         if (!identical(...future.workdir, getwd())) 
[18:04:47.593]             setwd(...future.workdir)
[18:04:47.593]         {
[18:04:47.593]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.593]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.593]             }
[18:04:47.593]             base::options(...future.oldOptions)
[18:04:47.593]             if (.Platform$OS.type == "windows") {
[18:04:47.593]                 old_names <- names(...future.oldEnvVars)
[18:04:47.593]                 envs <- base::Sys.getenv()
[18:04:47.593]                 names <- names(envs)
[18:04:47.593]                 common <- intersect(names, old_names)
[18:04:47.593]                 added <- setdiff(names, old_names)
[18:04:47.593]                 removed <- setdiff(old_names, names)
[18:04:47.593]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.593]                   envs[common]]
[18:04:47.593]                 NAMES <- toupper(changed)
[18:04:47.593]                 args <- list()
[18:04:47.593]                 for (kk in seq_along(NAMES)) {
[18:04:47.593]                   name <- changed[[kk]]
[18:04:47.593]                   NAME <- NAMES[[kk]]
[18:04:47.593]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.593]                     next
[18:04:47.593]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.593]                 }
[18:04:47.593]                 NAMES <- toupper(added)
[18:04:47.593]                 for (kk in seq_along(NAMES)) {
[18:04:47.593]                   name <- added[[kk]]
[18:04:47.593]                   NAME <- NAMES[[kk]]
[18:04:47.593]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.593]                     next
[18:04:47.593]                   args[[name]] <- ""
[18:04:47.593]                 }
[18:04:47.593]                 NAMES <- toupper(removed)
[18:04:47.593]                 for (kk in seq_along(NAMES)) {
[18:04:47.593]                   name <- removed[[kk]]
[18:04:47.593]                   NAME <- NAMES[[kk]]
[18:04:47.593]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.593]                     next
[18:04:47.593]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.593]                 }
[18:04:47.593]                 if (length(args) > 0) 
[18:04:47.593]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.593]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.593]             }
[18:04:47.593]             else {
[18:04:47.593]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.593]             }
[18:04:47.593]             {
[18:04:47.593]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.593]                   0L) {
[18:04:47.593]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.593]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.593]                   base::options(opts)
[18:04:47.593]                 }
[18:04:47.593]                 {
[18:04:47.593]                   {
[18:04:47.593]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:47.593]                     NULL
[18:04:47.593]                   }
[18:04:47.593]                   options(future.plan = NULL)
[18:04:47.593]                   if (is.na(NA_character_)) 
[18:04:47.593]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.593]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.593]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.593]                     .init = FALSE)
[18:04:47.593]                 }
[18:04:47.593]             }
[18:04:47.593]         }
[18:04:47.593]     })
[18:04:47.593]     if (TRUE) {
[18:04:47.593]         base::sink(type = "output", split = FALSE)
[18:04:47.593]         if (TRUE) {
[18:04:47.593]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.593]         }
[18:04:47.593]         else {
[18:04:47.593]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.593]         }
[18:04:47.593]         base::close(...future.stdout)
[18:04:47.593]         ...future.stdout <- NULL
[18:04:47.593]     }
[18:04:47.593]     ...future.result$conditions <- ...future.conditions
[18:04:47.593]     ...future.result$finished <- base::Sys.time()
[18:04:47.593]     ...future.result
[18:04:47.593] }
[18:04:47.597] assign_globals() ...
[18:04:47.597] List of 1
[18:04:47.597]  $ x: list()
[18:04:47.597]  - attr(*, "where")=List of 1
[18:04:47.597]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.597]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.597]  - attr(*, "resolved")= logi TRUE
[18:04:47.597]  - attr(*, "total_size")= num 0
[18:04:47.597]  - attr(*, "already-done")= logi TRUE
[18:04:47.603] - copied ‘x’ to environment
[18:04:47.603] assign_globals() ... done
[18:04:47.603] requestCore(): workers = 2
[18:04:47.607] MulticoreFuture started
[18:04:47.607] - Launch lazy future ... done
[18:04:47.608] run() for ‘MulticoreFuture’ ... done
[18:04:47.608] result() for MulticoreFuture ...
[18:04:47.608] plan(): Setting new future strategy stack:
[18:04:47.609] List of future strategies:
[18:04:47.609] 1. sequential:
[18:04:47.609]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.609]    - tweaked: FALSE
[18:04:47.609]    - call: NULL
[18:04:47.611] plan(): nbrOfWorkers() = 1
[18:04:47.616] plan(): Setting new future strategy stack:
[18:04:47.616] List of future strategies:
[18:04:47.616] 1. multicore:
[18:04:47.616]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:47.616]    - tweaked: FALSE
[18:04:47.616]    - call: plan(strategy)
[18:04:47.626] plan(): nbrOfWorkers() = 2
[18:04:47.628] result() for MulticoreFuture ...
[18:04:47.628] result() for MulticoreFuture ... done
[18:04:47.628] result() for MulticoreFuture ... done
[18:04:47.629] result() for MulticoreFuture ...
[18:04:47.629] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.630] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.631] Searching for globals...
[18:04:47.636] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.636] Searching for globals ... DONE
[18:04:47.637] Resolving globals: TRUE
[18:04:47.637] Resolving any globals that are futures ...
[18:04:47.637] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.637] Resolving any globals that are futures ... DONE
[18:04:47.638] Resolving futures part of globals (recursively) ...
[18:04:47.639] resolve() on list ...
[18:04:47.639]  recursive: 99
[18:04:47.639]  length: 1
[18:04:47.640]  elements: ‘x’
[18:04:47.640]  length: 0 (resolved future 1)
[18:04:47.640] resolve() on list ... DONE
[18:04:47.640] - globals: [1] ‘x’
[18:04:47.641] Resolving futures part of globals (recursively) ... DONE
[18:04:47.641] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.642] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.642] - globals: [1] ‘x’
[18:04:47.642] 
[18:04:47.643] getGlobalsAndPackages() ... DONE
[18:04:47.643] run() for ‘Future’ ...
[18:04:47.643] - state: ‘created’
[18:04:47.644] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:47.654] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:47.654] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:47.654]   - Field: ‘label’
[18:04:47.655]   - Field: ‘local’
[18:04:47.655]   - Field: ‘owner’
[18:04:47.655]   - Field: ‘envir’
[18:04:47.656]   - Field: ‘workers’
[18:04:47.656]   - Field: ‘packages’
[18:04:47.656]   - Field: ‘gc’
[18:04:47.656]   - Field: ‘job’
[18:04:47.657]   - Field: ‘conditions’
[18:04:47.657]   - Field: ‘expr’
[18:04:47.657]   - Field: ‘uuid’
[18:04:47.657]   - Field: ‘seed’
[18:04:47.658]   - Field: ‘version’
[18:04:47.658]   - Field: ‘result’
[18:04:47.658]   - Field: ‘asynchronous’
[18:04:47.658]   - Field: ‘calls’
[18:04:47.659]   - Field: ‘globals’
[18:04:47.659]   - Field: ‘stdout’
[18:04:47.659]   - Field: ‘earlySignal’
[18:04:47.659]   - Field: ‘lazy’
[18:04:47.659]   - Field: ‘state’
[18:04:47.660] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:47.660] - Launch lazy future ...
[18:04:47.661] Packages needed by the future expression (n = 0): <none>
[18:04:47.661] Packages needed by future strategies (n = 0): <none>
[18:04:47.662] {
[18:04:47.662]     {
[18:04:47.662]         {
[18:04:47.662]             ...future.startTime <- base::Sys.time()
[18:04:47.662]             {
[18:04:47.662]                 {
[18:04:47.662]                   {
[18:04:47.662]                     {
[18:04:47.662]                       base::local({
[18:04:47.662]                         has_future <- base::requireNamespace("future", 
[18:04:47.662]                           quietly = TRUE)
[18:04:47.662]                         if (has_future) {
[18:04:47.662]                           ns <- base::getNamespace("future")
[18:04:47.662]                           version <- ns[[".package"]][["version"]]
[18:04:47.662]                           if (is.null(version)) 
[18:04:47.662]                             version <- utils::packageVersion("future")
[18:04:47.662]                         }
[18:04:47.662]                         else {
[18:04:47.662]                           version <- NULL
[18:04:47.662]                         }
[18:04:47.662]                         if (!has_future || version < "1.8.0") {
[18:04:47.662]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.662]                             "", base::R.version$version.string), 
[18:04:47.662]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:47.662]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.662]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.662]                               "release", "version")], collapse = " "), 
[18:04:47.662]                             hostname = base::Sys.info()[["nodename"]])
[18:04:47.662]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.662]                             info)
[18:04:47.662]                           info <- base::paste(info, collapse = "; ")
[18:04:47.662]                           if (!has_future) {
[18:04:47.662]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.662]                               info)
[18:04:47.662]                           }
[18:04:47.662]                           else {
[18:04:47.662]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.662]                               info, version)
[18:04:47.662]                           }
[18:04:47.662]                           base::stop(msg)
[18:04:47.662]                         }
[18:04:47.662]                       })
[18:04:47.662]                     }
[18:04:47.662]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:47.662]                     base::options(mc.cores = 1L)
[18:04:47.662]                   }
[18:04:47.662]                   ...future.strategy.old <- future::plan("list")
[18:04:47.662]                   options(future.plan = NULL)
[18:04:47.662]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.662]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.662]                 }
[18:04:47.662]                 ...future.workdir <- getwd()
[18:04:47.662]             }
[18:04:47.662]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.662]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.662]         }
[18:04:47.662]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.662]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.662]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.662]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.662]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.662]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.662]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.662]             base::names(...future.oldOptions))
[18:04:47.662]     }
[18:04:47.662]     if (FALSE) {
[18:04:47.662]     }
[18:04:47.662]     else {
[18:04:47.662]         if (TRUE) {
[18:04:47.662]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.662]                 open = "w")
[18:04:47.662]         }
[18:04:47.662]         else {
[18:04:47.662]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.662]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.662]         }
[18:04:47.662]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.662]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.662]             base::sink(type = "output", split = FALSE)
[18:04:47.662]             base::close(...future.stdout)
[18:04:47.662]         }, add = TRUE)
[18:04:47.662]     }
[18:04:47.662]     ...future.frame <- base::sys.nframe()
[18:04:47.662]     ...future.conditions <- base::list()
[18:04:47.662]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.662]     if (FALSE) {
[18:04:47.662]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.662]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.662]     }
[18:04:47.662]     ...future.result <- base::tryCatch({
[18:04:47.662]         base::withCallingHandlers({
[18:04:47.662]             ...future.value <- base::withVisible(base::local({
[18:04:47.662]                 withCallingHandlers({
[18:04:47.662]                   {
[18:04:47.662]                     x$a <- 1
[18:04:47.662]                     x
[18:04:47.662]                   }
[18:04:47.662]                 }, immediateCondition = function(cond) {
[18:04:47.662]                   save_rds <- function (object, pathname, ...) 
[18:04:47.662]                   {
[18:04:47.662]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:47.662]                     if (file_test("-f", pathname_tmp)) {
[18:04:47.662]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.662]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:47.662]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.662]                         fi_tmp[["mtime"]])
[18:04:47.662]                     }
[18:04:47.662]                     tryCatch({
[18:04:47.662]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:47.662]                     }, error = function(ex) {
[18:04:47.662]                       msg <- conditionMessage(ex)
[18:04:47.662]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.662]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:47.662]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.662]                         fi_tmp[["mtime"]], msg)
[18:04:47.662]                       ex$message <- msg
[18:04:47.662]                       stop(ex)
[18:04:47.662]                     })
[18:04:47.662]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:47.662]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:47.662]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:47.662]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.662]                       fi <- file.info(pathname)
[18:04:47.662]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:47.662]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.662]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:47.662]                         fi[["size"]], fi[["mtime"]])
[18:04:47.662]                       stop(msg)
[18:04:47.662]                     }
[18:04:47.662]                     invisible(pathname)
[18:04:47.662]                   }
[18:04:47.662]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:47.662]                     rootPath = tempdir()) 
[18:04:47.662]                   {
[18:04:47.662]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:47.662]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:47.662]                       tmpdir = path, fileext = ".rds")
[18:04:47.662]                     save_rds(obj, file)
[18:04:47.662]                   }
[18:04:47.662]                   saveImmediateCondition(cond, path = "/tmp/RtmpGpkrBm/.future/immediateConditions")
[18:04:47.662]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.662]                   {
[18:04:47.662]                     inherits <- base::inherits
[18:04:47.662]                     invokeRestart <- base::invokeRestart
[18:04:47.662]                     is.null <- base::is.null
[18:04:47.662]                     muffled <- FALSE
[18:04:47.662]                     if (inherits(cond, "message")) {
[18:04:47.662]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:47.662]                       if (muffled) 
[18:04:47.662]                         invokeRestart("muffleMessage")
[18:04:47.662]                     }
[18:04:47.662]                     else if (inherits(cond, "warning")) {
[18:04:47.662]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:47.662]                       if (muffled) 
[18:04:47.662]                         invokeRestart("muffleWarning")
[18:04:47.662]                     }
[18:04:47.662]                     else if (inherits(cond, "condition")) {
[18:04:47.662]                       if (!is.null(pattern)) {
[18:04:47.662]                         computeRestarts <- base::computeRestarts
[18:04:47.662]                         grepl <- base::grepl
[18:04:47.662]                         restarts <- computeRestarts(cond)
[18:04:47.662]                         for (restart in restarts) {
[18:04:47.662]                           name <- restart$name
[18:04:47.662]                           if (is.null(name)) 
[18:04:47.662]                             next
[18:04:47.662]                           if (!grepl(pattern, name)) 
[18:04:47.662]                             next
[18:04:47.662]                           invokeRestart(restart)
[18:04:47.662]                           muffled <- TRUE
[18:04:47.662]                           break
[18:04:47.662]                         }
[18:04:47.662]                       }
[18:04:47.662]                     }
[18:04:47.662]                     invisible(muffled)
[18:04:47.662]                   }
[18:04:47.662]                   muffleCondition(cond)
[18:04:47.662]                 })
[18:04:47.662]             }))
[18:04:47.662]             future::FutureResult(value = ...future.value$value, 
[18:04:47.662]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.662]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.662]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.662]                     ...future.globalenv.names))
[18:04:47.662]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.662]         }, condition = base::local({
[18:04:47.662]             c <- base::c
[18:04:47.662]             inherits <- base::inherits
[18:04:47.662]             invokeRestart <- base::invokeRestart
[18:04:47.662]             length <- base::length
[18:04:47.662]             list <- base::list
[18:04:47.662]             seq.int <- base::seq.int
[18:04:47.662]             signalCondition <- base::signalCondition
[18:04:47.662]             sys.calls <- base::sys.calls
[18:04:47.662]             `[[` <- base::`[[`
[18:04:47.662]             `+` <- base::`+`
[18:04:47.662]             `<<-` <- base::`<<-`
[18:04:47.662]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.662]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.662]                   3L)]
[18:04:47.662]             }
[18:04:47.662]             function(cond) {
[18:04:47.662]                 is_error <- inherits(cond, "error")
[18:04:47.662]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.662]                   NULL)
[18:04:47.662]                 if (is_error) {
[18:04:47.662]                   sessionInformation <- function() {
[18:04:47.662]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.662]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.662]                       search = base::search(), system = base::Sys.info())
[18:04:47.662]                   }
[18:04:47.662]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.662]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.662]                     cond$call), session = sessionInformation(), 
[18:04:47.662]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.662]                   signalCondition(cond)
[18:04:47.662]                 }
[18:04:47.662]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.662]                 "immediateCondition"))) {
[18:04:47.662]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.662]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.662]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.662]                   if (TRUE && !signal) {
[18:04:47.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.662]                     {
[18:04:47.662]                       inherits <- base::inherits
[18:04:47.662]                       invokeRestart <- base::invokeRestart
[18:04:47.662]                       is.null <- base::is.null
[18:04:47.662]                       muffled <- FALSE
[18:04:47.662]                       if (inherits(cond, "message")) {
[18:04:47.662]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.662]                         if (muffled) 
[18:04:47.662]                           invokeRestart("muffleMessage")
[18:04:47.662]                       }
[18:04:47.662]                       else if (inherits(cond, "warning")) {
[18:04:47.662]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.662]                         if (muffled) 
[18:04:47.662]                           invokeRestart("muffleWarning")
[18:04:47.662]                       }
[18:04:47.662]                       else if (inherits(cond, "condition")) {
[18:04:47.662]                         if (!is.null(pattern)) {
[18:04:47.662]                           computeRestarts <- base::computeRestarts
[18:04:47.662]                           grepl <- base::grepl
[18:04:47.662]                           restarts <- computeRestarts(cond)
[18:04:47.662]                           for (restart in restarts) {
[18:04:47.662]                             name <- restart$name
[18:04:47.662]                             if (is.null(name)) 
[18:04:47.662]                               next
[18:04:47.662]                             if (!grepl(pattern, name)) 
[18:04:47.662]                               next
[18:04:47.662]                             invokeRestart(restart)
[18:04:47.662]                             muffled <- TRUE
[18:04:47.662]                             break
[18:04:47.662]                           }
[18:04:47.662]                         }
[18:04:47.662]                       }
[18:04:47.662]                       invisible(muffled)
[18:04:47.662]                     }
[18:04:47.662]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.662]                   }
[18:04:47.662]                 }
[18:04:47.662]                 else {
[18:04:47.662]                   if (TRUE) {
[18:04:47.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.662]                     {
[18:04:47.662]                       inherits <- base::inherits
[18:04:47.662]                       invokeRestart <- base::invokeRestart
[18:04:47.662]                       is.null <- base::is.null
[18:04:47.662]                       muffled <- FALSE
[18:04:47.662]                       if (inherits(cond, "message")) {
[18:04:47.662]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.662]                         if (muffled) 
[18:04:47.662]                           invokeRestart("muffleMessage")
[18:04:47.662]                       }
[18:04:47.662]                       else if (inherits(cond, "warning")) {
[18:04:47.662]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.662]                         if (muffled) 
[18:04:47.662]                           invokeRestart("muffleWarning")
[18:04:47.662]                       }
[18:04:47.662]                       else if (inherits(cond, "condition")) {
[18:04:47.662]                         if (!is.null(pattern)) {
[18:04:47.662]                           computeRestarts <- base::computeRestarts
[18:04:47.662]                           grepl <- base::grepl
[18:04:47.662]                           restarts <- computeRestarts(cond)
[18:04:47.662]                           for (restart in restarts) {
[18:04:47.662]                             name <- restart$name
[18:04:47.662]                             if (is.null(name)) 
[18:04:47.662]                               next
[18:04:47.662]                             if (!grepl(pattern, name)) 
[18:04:47.662]                               next
[18:04:47.662]                             invokeRestart(restart)
[18:04:47.662]                             muffled <- TRUE
[18:04:47.662]                             break
[18:04:47.662]                           }
[18:04:47.662]                         }
[18:04:47.662]                       }
[18:04:47.662]                       invisible(muffled)
[18:04:47.662]                     }
[18:04:47.662]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.662]                   }
[18:04:47.662]                 }
[18:04:47.662]             }
[18:04:47.662]         }))
[18:04:47.662]     }, error = function(ex) {
[18:04:47.662]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.662]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.662]                 ...future.rng), started = ...future.startTime, 
[18:04:47.662]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.662]             version = "1.8"), class = "FutureResult")
[18:04:47.662]     }, finally = {
[18:04:47.662]         if (!identical(...future.workdir, getwd())) 
[18:04:47.662]             setwd(...future.workdir)
[18:04:47.662]         {
[18:04:47.662]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.662]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.662]             }
[18:04:47.662]             base::options(...future.oldOptions)
[18:04:47.662]             if (.Platform$OS.type == "windows") {
[18:04:47.662]                 old_names <- names(...future.oldEnvVars)
[18:04:47.662]                 envs <- base::Sys.getenv()
[18:04:47.662]                 names <- names(envs)
[18:04:47.662]                 common <- intersect(names, old_names)
[18:04:47.662]                 added <- setdiff(names, old_names)
[18:04:47.662]                 removed <- setdiff(old_names, names)
[18:04:47.662]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.662]                   envs[common]]
[18:04:47.662]                 NAMES <- toupper(changed)
[18:04:47.662]                 args <- list()
[18:04:47.662]                 for (kk in seq_along(NAMES)) {
[18:04:47.662]                   name <- changed[[kk]]
[18:04:47.662]                   NAME <- NAMES[[kk]]
[18:04:47.662]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.662]                     next
[18:04:47.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.662]                 }
[18:04:47.662]                 NAMES <- toupper(added)
[18:04:47.662]                 for (kk in seq_along(NAMES)) {
[18:04:47.662]                   name <- added[[kk]]
[18:04:47.662]                   NAME <- NAMES[[kk]]
[18:04:47.662]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.662]                     next
[18:04:47.662]                   args[[name]] <- ""
[18:04:47.662]                 }
[18:04:47.662]                 NAMES <- toupper(removed)
[18:04:47.662]                 for (kk in seq_along(NAMES)) {
[18:04:47.662]                   name <- removed[[kk]]
[18:04:47.662]                   NAME <- NAMES[[kk]]
[18:04:47.662]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.662]                     next
[18:04:47.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.662]                 }
[18:04:47.662]                 if (length(args) > 0) 
[18:04:47.662]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.662]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.662]             }
[18:04:47.662]             else {
[18:04:47.662]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.662]             }
[18:04:47.662]             {
[18:04:47.662]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.662]                   0L) {
[18:04:47.662]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.662]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.662]                   base::options(opts)
[18:04:47.662]                 }
[18:04:47.662]                 {
[18:04:47.662]                   {
[18:04:47.662]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:47.662]                     NULL
[18:04:47.662]                   }
[18:04:47.662]                   options(future.plan = NULL)
[18:04:47.662]                   if (is.na(NA_character_)) 
[18:04:47.662]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.662]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.662]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.662]                     .init = FALSE)
[18:04:47.662]                 }
[18:04:47.662]             }
[18:04:47.662]         }
[18:04:47.662]     })
[18:04:47.662]     if (TRUE) {
[18:04:47.662]         base::sink(type = "output", split = FALSE)
[18:04:47.662]         if (TRUE) {
[18:04:47.662]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.662]         }
[18:04:47.662]         else {
[18:04:47.662]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.662]         }
[18:04:47.662]         base::close(...future.stdout)
[18:04:47.662]         ...future.stdout <- NULL
[18:04:47.662]     }
[18:04:47.662]     ...future.result$conditions <- ...future.conditions
[18:04:47.662]     ...future.result$finished <- base::Sys.time()
[18:04:47.662]     ...future.result
[18:04:47.662] }
[18:04:47.666] assign_globals() ...
[18:04:47.666] List of 1
[18:04:47.666]  $ x: list()
[18:04:47.666]  - attr(*, "where")=List of 1
[18:04:47.666]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.666]  - attr(*, "resolved")= logi TRUE
[18:04:47.666]  - attr(*, "total_size")= num 0
[18:04:47.666]  - attr(*, "already-done")= logi TRUE
[18:04:47.672] - copied ‘x’ to environment
[18:04:47.672] assign_globals() ... done
[18:04:47.673] requestCore(): workers = 2
[18:04:47.676] MulticoreFuture started
[18:04:47.677] - Launch lazy future ... done
[18:04:47.677] run() for ‘MulticoreFuture’ ... done
[18:04:47.678] result() for MulticoreFuture ...
[18:04:47.678] plan(): Setting new future strategy stack:
[18:04:47.678] List of future strategies:
[18:04:47.678] 1. sequential:
[18:04:47.678]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.678]    - tweaked: FALSE
[18:04:47.678]    - call: NULL
[18:04:47.681] plan(): nbrOfWorkers() = 1
[18:04:47.686] plan(): Setting new future strategy stack:
[18:04:47.686] List of future strategies:
[18:04:47.686] 1. multicore:
[18:04:47.686]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:47.686]    - tweaked: FALSE
[18:04:47.686]    - call: plan(strategy)
[18:04:47.697] plan(): nbrOfWorkers() = 2
[18:04:47.698] result() for MulticoreFuture ...
[18:04:47.699] result() for MulticoreFuture ... done
[18:04:47.699] result() for MulticoreFuture ... done
[18:04:47.699] result() for MulticoreFuture ...
[18:04:47.700] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.701] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.702] Searching for globals...
[18:04:47.707] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.707] Searching for globals ... DONE
[18:04:47.707] Resolving globals: TRUE
[18:04:47.708] Resolving any globals that are futures ...
[18:04:47.708] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:47.708] Resolving any globals that are futures ... DONE
[18:04:47.709] Resolving futures part of globals (recursively) ...
[18:04:47.710] resolve() on list ...
[18:04:47.710]  recursive: 99
[18:04:47.710]  length: 1
[18:04:47.710]  elements: ‘x’
[18:04:47.711]  length: 0 (resolved future 1)
[18:04:47.711] resolve() on list ... DONE
[18:04:47.711] - globals: [1] ‘x’
[18:04:47.711] Resolving futures part of globals (recursively) ... DONE
[18:04:47.712] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.713] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.713] - globals: [1] ‘x’
[18:04:47.713] 
[18:04:47.713] getGlobalsAndPackages() ... DONE
[18:04:47.714] run() for ‘Future’ ...
[18:04:47.714] - state: ‘created’
[18:04:47.715] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:47.722] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:47.723] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:47.723]   - Field: ‘label’
[18:04:47.723]   - Field: ‘local’
[18:04:47.723]   - Field: ‘owner’
[18:04:47.724]   - Field: ‘envir’
[18:04:47.724]   - Field: ‘workers’
[18:04:47.724]   - Field: ‘packages’
[18:04:47.724]   - Field: ‘gc’
[18:04:47.725]   - Field: ‘job’
[18:04:47.725]   - Field: ‘conditions’
[18:04:47.725]   - Field: ‘expr’
[18:04:47.725]   - Field: ‘uuid’
[18:04:47.726]   - Field: ‘seed’
[18:04:47.726]   - Field: ‘version’
[18:04:47.726]   - Field: ‘result’
[18:04:47.726]   - Field: ‘asynchronous’
[18:04:47.727]   - Field: ‘calls’
[18:04:47.727]   - Field: ‘globals’
[18:04:47.727]   - Field: ‘stdout’
[18:04:47.727]   - Field: ‘earlySignal’
[18:04:47.728]   - Field: ‘lazy’
[18:04:47.728]   - Field: ‘state’
[18:04:47.728] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:47.728] - Launch lazy future ...
[18:04:47.729] Packages needed by the future expression (n = 0): <none>
[18:04:47.729] Packages needed by future strategies (n = 0): <none>
[18:04:47.731] {
[18:04:47.731]     {
[18:04:47.731]         {
[18:04:47.731]             ...future.startTime <- base::Sys.time()
[18:04:47.731]             {
[18:04:47.731]                 {
[18:04:47.731]                   {
[18:04:47.731]                     {
[18:04:47.731]                       base::local({
[18:04:47.731]                         has_future <- base::requireNamespace("future", 
[18:04:47.731]                           quietly = TRUE)
[18:04:47.731]                         if (has_future) {
[18:04:47.731]                           ns <- base::getNamespace("future")
[18:04:47.731]                           version <- ns[[".package"]][["version"]]
[18:04:47.731]                           if (is.null(version)) 
[18:04:47.731]                             version <- utils::packageVersion("future")
[18:04:47.731]                         }
[18:04:47.731]                         else {
[18:04:47.731]                           version <- NULL
[18:04:47.731]                         }
[18:04:47.731]                         if (!has_future || version < "1.8.0") {
[18:04:47.731]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.731]                             "", base::R.version$version.string), 
[18:04:47.731]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:47.731]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.731]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.731]                               "release", "version")], collapse = " "), 
[18:04:47.731]                             hostname = base::Sys.info()[["nodename"]])
[18:04:47.731]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.731]                             info)
[18:04:47.731]                           info <- base::paste(info, collapse = "; ")
[18:04:47.731]                           if (!has_future) {
[18:04:47.731]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.731]                               info)
[18:04:47.731]                           }
[18:04:47.731]                           else {
[18:04:47.731]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.731]                               info, version)
[18:04:47.731]                           }
[18:04:47.731]                           base::stop(msg)
[18:04:47.731]                         }
[18:04:47.731]                       })
[18:04:47.731]                     }
[18:04:47.731]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:47.731]                     base::options(mc.cores = 1L)
[18:04:47.731]                   }
[18:04:47.731]                   ...future.strategy.old <- future::plan("list")
[18:04:47.731]                   options(future.plan = NULL)
[18:04:47.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.731]                 }
[18:04:47.731]                 ...future.workdir <- getwd()
[18:04:47.731]             }
[18:04:47.731]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.731]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.731]         }
[18:04:47.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.731]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.731]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.731]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.731]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.731]             base::names(...future.oldOptions))
[18:04:47.731]     }
[18:04:47.731]     if (FALSE) {
[18:04:47.731]     }
[18:04:47.731]     else {
[18:04:47.731]         if (TRUE) {
[18:04:47.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.731]                 open = "w")
[18:04:47.731]         }
[18:04:47.731]         else {
[18:04:47.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.731]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.731]         }
[18:04:47.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.731]             base::sink(type = "output", split = FALSE)
[18:04:47.731]             base::close(...future.stdout)
[18:04:47.731]         }, add = TRUE)
[18:04:47.731]     }
[18:04:47.731]     ...future.frame <- base::sys.nframe()
[18:04:47.731]     ...future.conditions <- base::list()
[18:04:47.731]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.731]     if (FALSE) {
[18:04:47.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.731]     }
[18:04:47.731]     ...future.result <- base::tryCatch({
[18:04:47.731]         base::withCallingHandlers({
[18:04:47.731]             ...future.value <- base::withVisible(base::local({
[18:04:47.731]                 withCallingHandlers({
[18:04:47.731]                   {
[18:04:47.731]                     x$a <- 1
[18:04:47.731]                     x
[18:04:47.731]                   }
[18:04:47.731]                 }, immediateCondition = function(cond) {
[18:04:47.731]                   save_rds <- function (object, pathname, ...) 
[18:04:47.731]                   {
[18:04:47.731]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:47.731]                     if (file_test("-f", pathname_tmp)) {
[18:04:47.731]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.731]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:47.731]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.731]                         fi_tmp[["mtime"]])
[18:04:47.731]                     }
[18:04:47.731]                     tryCatch({
[18:04:47.731]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:47.731]                     }, error = function(ex) {
[18:04:47.731]                       msg <- conditionMessage(ex)
[18:04:47.731]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.731]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:47.731]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.731]                         fi_tmp[["mtime"]], msg)
[18:04:47.731]                       ex$message <- msg
[18:04:47.731]                       stop(ex)
[18:04:47.731]                     })
[18:04:47.731]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:47.731]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:47.731]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:47.731]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.731]                       fi <- file.info(pathname)
[18:04:47.731]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:47.731]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.731]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:47.731]                         fi[["size"]], fi[["mtime"]])
[18:04:47.731]                       stop(msg)
[18:04:47.731]                     }
[18:04:47.731]                     invisible(pathname)
[18:04:47.731]                   }
[18:04:47.731]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:47.731]                     rootPath = tempdir()) 
[18:04:47.731]                   {
[18:04:47.731]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:47.731]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:47.731]                       tmpdir = path, fileext = ".rds")
[18:04:47.731]                     save_rds(obj, file)
[18:04:47.731]                   }
[18:04:47.731]                   saveImmediateCondition(cond, path = "/tmp/RtmpGpkrBm/.future/immediateConditions")
[18:04:47.731]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.731]                   {
[18:04:47.731]                     inherits <- base::inherits
[18:04:47.731]                     invokeRestart <- base::invokeRestart
[18:04:47.731]                     is.null <- base::is.null
[18:04:47.731]                     muffled <- FALSE
[18:04:47.731]                     if (inherits(cond, "message")) {
[18:04:47.731]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:47.731]                       if (muffled) 
[18:04:47.731]                         invokeRestart("muffleMessage")
[18:04:47.731]                     }
[18:04:47.731]                     else if (inherits(cond, "warning")) {
[18:04:47.731]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:47.731]                       if (muffled) 
[18:04:47.731]                         invokeRestart("muffleWarning")
[18:04:47.731]                     }
[18:04:47.731]                     else if (inherits(cond, "condition")) {
[18:04:47.731]                       if (!is.null(pattern)) {
[18:04:47.731]                         computeRestarts <- base::computeRestarts
[18:04:47.731]                         grepl <- base::grepl
[18:04:47.731]                         restarts <- computeRestarts(cond)
[18:04:47.731]                         for (restart in restarts) {
[18:04:47.731]                           name <- restart$name
[18:04:47.731]                           if (is.null(name)) 
[18:04:47.731]                             next
[18:04:47.731]                           if (!grepl(pattern, name)) 
[18:04:47.731]                             next
[18:04:47.731]                           invokeRestart(restart)
[18:04:47.731]                           muffled <- TRUE
[18:04:47.731]                           break
[18:04:47.731]                         }
[18:04:47.731]                       }
[18:04:47.731]                     }
[18:04:47.731]                     invisible(muffled)
[18:04:47.731]                   }
[18:04:47.731]                   muffleCondition(cond)
[18:04:47.731]                 })
[18:04:47.731]             }))
[18:04:47.731]             future::FutureResult(value = ...future.value$value, 
[18:04:47.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.731]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.731]                     ...future.globalenv.names))
[18:04:47.731]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.731]         }, condition = base::local({
[18:04:47.731]             c <- base::c
[18:04:47.731]             inherits <- base::inherits
[18:04:47.731]             invokeRestart <- base::invokeRestart
[18:04:47.731]             length <- base::length
[18:04:47.731]             list <- base::list
[18:04:47.731]             seq.int <- base::seq.int
[18:04:47.731]             signalCondition <- base::signalCondition
[18:04:47.731]             sys.calls <- base::sys.calls
[18:04:47.731]             `[[` <- base::`[[`
[18:04:47.731]             `+` <- base::`+`
[18:04:47.731]             `<<-` <- base::`<<-`
[18:04:47.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.731]                   3L)]
[18:04:47.731]             }
[18:04:47.731]             function(cond) {
[18:04:47.731]                 is_error <- inherits(cond, "error")
[18:04:47.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.731]                   NULL)
[18:04:47.731]                 if (is_error) {
[18:04:47.731]                   sessionInformation <- function() {
[18:04:47.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.731]                       search = base::search(), system = base::Sys.info())
[18:04:47.731]                   }
[18:04:47.731]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.731]                     cond$call), session = sessionInformation(), 
[18:04:47.731]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.731]                   signalCondition(cond)
[18:04:47.731]                 }
[18:04:47.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.731]                 "immediateCondition"))) {
[18:04:47.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.731]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.731]                   if (TRUE && !signal) {
[18:04:47.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.731]                     {
[18:04:47.731]                       inherits <- base::inherits
[18:04:47.731]                       invokeRestart <- base::invokeRestart
[18:04:47.731]                       is.null <- base::is.null
[18:04:47.731]                       muffled <- FALSE
[18:04:47.731]                       if (inherits(cond, "message")) {
[18:04:47.731]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.731]                         if (muffled) 
[18:04:47.731]                           invokeRestart("muffleMessage")
[18:04:47.731]                       }
[18:04:47.731]                       else if (inherits(cond, "warning")) {
[18:04:47.731]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.731]                         if (muffled) 
[18:04:47.731]                           invokeRestart("muffleWarning")
[18:04:47.731]                       }
[18:04:47.731]                       else if (inherits(cond, "condition")) {
[18:04:47.731]                         if (!is.null(pattern)) {
[18:04:47.731]                           computeRestarts <- base::computeRestarts
[18:04:47.731]                           grepl <- base::grepl
[18:04:47.731]                           restarts <- computeRestarts(cond)
[18:04:47.731]                           for (restart in restarts) {
[18:04:47.731]                             name <- restart$name
[18:04:47.731]                             if (is.null(name)) 
[18:04:47.731]                               next
[18:04:47.731]                             if (!grepl(pattern, name)) 
[18:04:47.731]                               next
[18:04:47.731]                             invokeRestart(restart)
[18:04:47.731]                             muffled <- TRUE
[18:04:47.731]                             break
[18:04:47.731]                           }
[18:04:47.731]                         }
[18:04:47.731]                       }
[18:04:47.731]                       invisible(muffled)
[18:04:47.731]                     }
[18:04:47.731]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.731]                   }
[18:04:47.731]                 }
[18:04:47.731]                 else {
[18:04:47.731]                   if (TRUE) {
[18:04:47.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.731]                     {
[18:04:47.731]                       inherits <- base::inherits
[18:04:47.731]                       invokeRestart <- base::invokeRestart
[18:04:47.731]                       is.null <- base::is.null
[18:04:47.731]                       muffled <- FALSE
[18:04:47.731]                       if (inherits(cond, "message")) {
[18:04:47.731]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.731]                         if (muffled) 
[18:04:47.731]                           invokeRestart("muffleMessage")
[18:04:47.731]                       }
[18:04:47.731]                       else if (inherits(cond, "warning")) {
[18:04:47.731]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.731]                         if (muffled) 
[18:04:47.731]                           invokeRestart("muffleWarning")
[18:04:47.731]                       }
[18:04:47.731]                       else if (inherits(cond, "condition")) {
[18:04:47.731]                         if (!is.null(pattern)) {
[18:04:47.731]                           computeRestarts <- base::computeRestarts
[18:04:47.731]                           grepl <- base::grepl
[18:04:47.731]                           restarts <- computeRestarts(cond)
[18:04:47.731]                           for (restart in restarts) {
[18:04:47.731]                             name <- restart$name
[18:04:47.731]                             if (is.null(name)) 
[18:04:47.731]                               next
[18:04:47.731]                             if (!grepl(pattern, name)) 
[18:04:47.731]                               next
[18:04:47.731]                             invokeRestart(restart)
[18:04:47.731]                             muffled <- TRUE
[18:04:47.731]                             break
[18:04:47.731]                           }
[18:04:47.731]                         }
[18:04:47.731]                       }
[18:04:47.731]                       invisible(muffled)
[18:04:47.731]                     }
[18:04:47.731]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.731]                   }
[18:04:47.731]                 }
[18:04:47.731]             }
[18:04:47.731]         }))
[18:04:47.731]     }, error = function(ex) {
[18:04:47.731]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.731]                 ...future.rng), started = ...future.startTime, 
[18:04:47.731]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.731]             version = "1.8"), class = "FutureResult")
[18:04:47.731]     }, finally = {
[18:04:47.731]         if (!identical(...future.workdir, getwd())) 
[18:04:47.731]             setwd(...future.workdir)
[18:04:47.731]         {
[18:04:47.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.731]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.731]             }
[18:04:47.731]             base::options(...future.oldOptions)
[18:04:47.731]             if (.Platform$OS.type == "windows") {
[18:04:47.731]                 old_names <- names(...future.oldEnvVars)
[18:04:47.731]                 envs <- base::Sys.getenv()
[18:04:47.731]                 names <- names(envs)
[18:04:47.731]                 common <- intersect(names, old_names)
[18:04:47.731]                 added <- setdiff(names, old_names)
[18:04:47.731]                 removed <- setdiff(old_names, names)
[18:04:47.731]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.731]                   envs[common]]
[18:04:47.731]                 NAMES <- toupper(changed)
[18:04:47.731]                 args <- list()
[18:04:47.731]                 for (kk in seq_along(NAMES)) {
[18:04:47.731]                   name <- changed[[kk]]
[18:04:47.731]                   NAME <- NAMES[[kk]]
[18:04:47.731]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.731]                     next
[18:04:47.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.731]                 }
[18:04:47.731]                 NAMES <- toupper(added)
[18:04:47.731]                 for (kk in seq_along(NAMES)) {
[18:04:47.731]                   name <- added[[kk]]
[18:04:47.731]                   NAME <- NAMES[[kk]]
[18:04:47.731]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.731]                     next
[18:04:47.731]                   args[[name]] <- ""
[18:04:47.731]                 }
[18:04:47.731]                 NAMES <- toupper(removed)
[18:04:47.731]                 for (kk in seq_along(NAMES)) {
[18:04:47.731]                   name <- removed[[kk]]
[18:04:47.731]                   NAME <- NAMES[[kk]]
[18:04:47.731]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.731]                     next
[18:04:47.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.731]                 }
[18:04:47.731]                 if (length(args) > 0) 
[18:04:47.731]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.731]             }
[18:04:47.731]             else {
[18:04:47.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.731]             }
[18:04:47.731]             {
[18:04:47.731]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.731]                   0L) {
[18:04:47.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.731]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.731]                   base::options(opts)
[18:04:47.731]                 }
[18:04:47.731]                 {
[18:04:47.731]                   {
[18:04:47.731]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:47.731]                     NULL
[18:04:47.731]                   }
[18:04:47.731]                   options(future.plan = NULL)
[18:04:47.731]                   if (is.na(NA_character_)) 
[18:04:47.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.731]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.731]                     .init = FALSE)
[18:04:47.731]                 }
[18:04:47.731]             }
[18:04:47.731]         }
[18:04:47.731]     })
[18:04:47.731]     if (TRUE) {
[18:04:47.731]         base::sink(type = "output", split = FALSE)
[18:04:47.731]         if (TRUE) {
[18:04:47.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.731]         }
[18:04:47.731]         else {
[18:04:47.731]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.731]         }
[18:04:47.731]         base::close(...future.stdout)
[18:04:47.731]         ...future.stdout <- NULL
[18:04:47.731]     }
[18:04:47.731]     ...future.result$conditions <- ...future.conditions
[18:04:47.731]     ...future.result$finished <- base::Sys.time()
[18:04:47.731]     ...future.result
[18:04:47.731] }
[18:04:47.736] assign_globals() ...
[18:04:47.736] List of 1
[18:04:47.736]  $ x: list()
[18:04:47.736]  - attr(*, "where")=List of 1
[18:04:47.736]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.736]  - attr(*, "resolved")= logi TRUE
[18:04:47.736]  - attr(*, "total_size")= num 0
[18:04:47.736]  - attr(*, "already-done")= logi TRUE
[18:04:47.742] - copied ‘x’ to environment
[18:04:47.742] assign_globals() ... done
[18:04:47.743] requestCore(): workers = 2
[18:04:47.746] MulticoreFuture started
[18:04:47.747] - Launch lazy future ... done
[18:04:47.748] run() for ‘MulticoreFuture’ ... done
[18:04:47.748] result() for MulticoreFuture ...
[18:04:47.750] plan(): Setting new future strategy stack:
[18:04:47.751] List of future strategies:
[18:04:47.751] 1. sequential:
[18:04:47.751]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.751]    - tweaked: FALSE
[18:04:47.751]    - call: NULL
[18:04:47.753] plan(): nbrOfWorkers() = 1
[18:04:47.757] plan(): Setting new future strategy stack:
[18:04:47.757] List of future strategies:
[18:04:47.757] 1. multicore:
[18:04:47.757]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:47.757]    - tweaked: FALSE
[18:04:47.757]    - call: plan(strategy)
[18:04:47.774] plan(): nbrOfWorkers() = 2
[18:04:47.778] result() for MulticoreFuture ...
[18:04:47.778] result() for MulticoreFuture ... done
[18:04:47.778] result() for MulticoreFuture ... done
[18:04:47.779] result() for MulticoreFuture ...
[18:04:47.779] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.780] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.781] Searching for globals...
[18:04:47.792] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[18:04:47.792] Searching for globals ... DONE
[18:04:47.793] Resolving globals: TRUE
[18:04:47.793] Resolving any globals that are futures ...
[18:04:47.793] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[18:04:47.793] Resolving any globals that are futures ... DONE
[18:04:47.794] 
[18:04:47.795] 
[18:04:47.795] getGlobalsAndPackages() ... DONE
[18:04:47.795] run() for ‘Future’ ...
[18:04:47.796] - state: ‘created’
[18:04:47.796] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:47.803] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:47.803] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:47.804]   - Field: ‘label’
[18:04:47.804]   - Field: ‘local’
[18:04:47.804]   - Field: ‘owner’
[18:04:47.804]   - Field: ‘envir’
[18:04:47.805]   - Field: ‘workers’
[18:04:47.805]   - Field: ‘packages’
[18:04:47.805]   - Field: ‘gc’
[18:04:47.805]   - Field: ‘job’
[18:04:47.806]   - Field: ‘conditions’
[18:04:47.806]   - Field: ‘expr’
[18:04:47.806]   - Field: ‘uuid’
[18:04:47.806]   - Field: ‘seed’
[18:04:47.807]   - Field: ‘version’
[18:04:47.807]   - Field: ‘result’
[18:04:47.807]   - Field: ‘asynchronous’
[18:04:47.807]   - Field: ‘calls’
[18:04:47.808]   - Field: ‘globals’
[18:04:47.808]   - Field: ‘stdout’
[18:04:47.808]   - Field: ‘earlySignal’
[18:04:47.808]   - Field: ‘lazy’
[18:04:47.809]   - Field: ‘state’
[18:04:47.809] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:47.809] - Launch lazy future ...
[18:04:47.810] Packages needed by the future expression (n = 0): <none>
[18:04:47.810] Packages needed by future strategies (n = 0): <none>
[18:04:47.811] {
[18:04:47.811]     {
[18:04:47.811]         {
[18:04:47.811]             ...future.startTime <- base::Sys.time()
[18:04:47.811]             {
[18:04:47.811]                 {
[18:04:47.811]                   {
[18:04:47.811]                     {
[18:04:47.811]                       base::local({
[18:04:47.811]                         has_future <- base::requireNamespace("future", 
[18:04:47.811]                           quietly = TRUE)
[18:04:47.811]                         if (has_future) {
[18:04:47.811]                           ns <- base::getNamespace("future")
[18:04:47.811]                           version <- ns[[".package"]][["version"]]
[18:04:47.811]                           if (is.null(version)) 
[18:04:47.811]                             version <- utils::packageVersion("future")
[18:04:47.811]                         }
[18:04:47.811]                         else {
[18:04:47.811]                           version <- NULL
[18:04:47.811]                         }
[18:04:47.811]                         if (!has_future || version < "1.8.0") {
[18:04:47.811]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.811]                             "", base::R.version$version.string), 
[18:04:47.811]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:47.811]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.811]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.811]                               "release", "version")], collapse = " "), 
[18:04:47.811]                             hostname = base::Sys.info()[["nodename"]])
[18:04:47.811]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.811]                             info)
[18:04:47.811]                           info <- base::paste(info, collapse = "; ")
[18:04:47.811]                           if (!has_future) {
[18:04:47.811]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.811]                               info)
[18:04:47.811]                           }
[18:04:47.811]                           else {
[18:04:47.811]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.811]                               info, version)
[18:04:47.811]                           }
[18:04:47.811]                           base::stop(msg)
[18:04:47.811]                         }
[18:04:47.811]                       })
[18:04:47.811]                     }
[18:04:47.811]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:47.811]                     base::options(mc.cores = 1L)
[18:04:47.811]                   }
[18:04:47.811]                   ...future.strategy.old <- future::plan("list")
[18:04:47.811]                   options(future.plan = NULL)
[18:04:47.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.811]                 }
[18:04:47.811]                 ...future.workdir <- getwd()
[18:04:47.811]             }
[18:04:47.811]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.811]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.811]         }
[18:04:47.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.811]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.811]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.811]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.811]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.811]             base::names(...future.oldOptions))
[18:04:47.811]     }
[18:04:47.811]     if (FALSE) {
[18:04:47.811]     }
[18:04:47.811]     else {
[18:04:47.811]         if (TRUE) {
[18:04:47.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.811]                 open = "w")
[18:04:47.811]         }
[18:04:47.811]         else {
[18:04:47.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.811]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.811]         }
[18:04:47.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.811]             base::sink(type = "output", split = FALSE)
[18:04:47.811]             base::close(...future.stdout)
[18:04:47.811]         }, add = TRUE)
[18:04:47.811]     }
[18:04:47.811]     ...future.frame <- base::sys.nframe()
[18:04:47.811]     ...future.conditions <- base::list()
[18:04:47.811]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.811]     if (FALSE) {
[18:04:47.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.811]     }
[18:04:47.811]     ...future.result <- base::tryCatch({
[18:04:47.811]         base::withCallingHandlers({
[18:04:47.811]             ...future.value <- base::withVisible(base::local({
[18:04:47.811]                 withCallingHandlers({
[18:04:47.811]                   {
[18:04:47.811]                     x <- list(b = 2)
[18:04:47.811]                     x$a <- 1
[18:04:47.811]                     x
[18:04:47.811]                   }
[18:04:47.811]                 }, immediateCondition = function(cond) {
[18:04:47.811]                   save_rds <- function (object, pathname, ...) 
[18:04:47.811]                   {
[18:04:47.811]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:47.811]                     if (file_test("-f", pathname_tmp)) {
[18:04:47.811]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.811]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:47.811]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.811]                         fi_tmp[["mtime"]])
[18:04:47.811]                     }
[18:04:47.811]                     tryCatch({
[18:04:47.811]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:47.811]                     }, error = function(ex) {
[18:04:47.811]                       msg <- conditionMessage(ex)
[18:04:47.811]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.811]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:47.811]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.811]                         fi_tmp[["mtime"]], msg)
[18:04:47.811]                       ex$message <- msg
[18:04:47.811]                       stop(ex)
[18:04:47.811]                     })
[18:04:47.811]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:47.811]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:47.811]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:47.811]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.811]                       fi <- file.info(pathname)
[18:04:47.811]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:47.811]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.811]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:47.811]                         fi[["size"]], fi[["mtime"]])
[18:04:47.811]                       stop(msg)
[18:04:47.811]                     }
[18:04:47.811]                     invisible(pathname)
[18:04:47.811]                   }
[18:04:47.811]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:47.811]                     rootPath = tempdir()) 
[18:04:47.811]                   {
[18:04:47.811]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:47.811]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:47.811]                       tmpdir = path, fileext = ".rds")
[18:04:47.811]                     save_rds(obj, file)
[18:04:47.811]                   }
[18:04:47.811]                   saveImmediateCondition(cond, path = "/tmp/RtmpGpkrBm/.future/immediateConditions")
[18:04:47.811]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.811]                   {
[18:04:47.811]                     inherits <- base::inherits
[18:04:47.811]                     invokeRestart <- base::invokeRestart
[18:04:47.811]                     is.null <- base::is.null
[18:04:47.811]                     muffled <- FALSE
[18:04:47.811]                     if (inherits(cond, "message")) {
[18:04:47.811]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:47.811]                       if (muffled) 
[18:04:47.811]                         invokeRestart("muffleMessage")
[18:04:47.811]                     }
[18:04:47.811]                     else if (inherits(cond, "warning")) {
[18:04:47.811]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:47.811]                       if (muffled) 
[18:04:47.811]                         invokeRestart("muffleWarning")
[18:04:47.811]                     }
[18:04:47.811]                     else if (inherits(cond, "condition")) {
[18:04:47.811]                       if (!is.null(pattern)) {
[18:04:47.811]                         computeRestarts <- base::computeRestarts
[18:04:47.811]                         grepl <- base::grepl
[18:04:47.811]                         restarts <- computeRestarts(cond)
[18:04:47.811]                         for (restart in restarts) {
[18:04:47.811]                           name <- restart$name
[18:04:47.811]                           if (is.null(name)) 
[18:04:47.811]                             next
[18:04:47.811]                           if (!grepl(pattern, name)) 
[18:04:47.811]                             next
[18:04:47.811]                           invokeRestart(restart)
[18:04:47.811]                           muffled <- TRUE
[18:04:47.811]                           break
[18:04:47.811]                         }
[18:04:47.811]                       }
[18:04:47.811]                     }
[18:04:47.811]                     invisible(muffled)
[18:04:47.811]                   }
[18:04:47.811]                   muffleCondition(cond)
[18:04:47.811]                 })
[18:04:47.811]             }))
[18:04:47.811]             future::FutureResult(value = ...future.value$value, 
[18:04:47.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.811]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.811]                     ...future.globalenv.names))
[18:04:47.811]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.811]         }, condition = base::local({
[18:04:47.811]             c <- base::c
[18:04:47.811]             inherits <- base::inherits
[18:04:47.811]             invokeRestart <- base::invokeRestart
[18:04:47.811]             length <- base::length
[18:04:47.811]             list <- base::list
[18:04:47.811]             seq.int <- base::seq.int
[18:04:47.811]             signalCondition <- base::signalCondition
[18:04:47.811]             sys.calls <- base::sys.calls
[18:04:47.811]             `[[` <- base::`[[`
[18:04:47.811]             `+` <- base::`+`
[18:04:47.811]             `<<-` <- base::`<<-`
[18:04:47.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.811]                   3L)]
[18:04:47.811]             }
[18:04:47.811]             function(cond) {
[18:04:47.811]                 is_error <- inherits(cond, "error")
[18:04:47.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.811]                   NULL)
[18:04:47.811]                 if (is_error) {
[18:04:47.811]                   sessionInformation <- function() {
[18:04:47.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.811]                       search = base::search(), system = base::Sys.info())
[18:04:47.811]                   }
[18:04:47.811]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.811]                     cond$call), session = sessionInformation(), 
[18:04:47.811]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.811]                   signalCondition(cond)
[18:04:47.811]                 }
[18:04:47.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.811]                 "immediateCondition"))) {
[18:04:47.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.811]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.811]                   if (TRUE && !signal) {
[18:04:47.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.811]                     {
[18:04:47.811]                       inherits <- base::inherits
[18:04:47.811]                       invokeRestart <- base::invokeRestart
[18:04:47.811]                       is.null <- base::is.null
[18:04:47.811]                       muffled <- FALSE
[18:04:47.811]                       if (inherits(cond, "message")) {
[18:04:47.811]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.811]                         if (muffled) 
[18:04:47.811]                           invokeRestart("muffleMessage")
[18:04:47.811]                       }
[18:04:47.811]                       else if (inherits(cond, "warning")) {
[18:04:47.811]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.811]                         if (muffled) 
[18:04:47.811]                           invokeRestart("muffleWarning")
[18:04:47.811]                       }
[18:04:47.811]                       else if (inherits(cond, "condition")) {
[18:04:47.811]                         if (!is.null(pattern)) {
[18:04:47.811]                           computeRestarts <- base::computeRestarts
[18:04:47.811]                           grepl <- base::grepl
[18:04:47.811]                           restarts <- computeRestarts(cond)
[18:04:47.811]                           for (restart in restarts) {
[18:04:47.811]                             name <- restart$name
[18:04:47.811]                             if (is.null(name)) 
[18:04:47.811]                               next
[18:04:47.811]                             if (!grepl(pattern, name)) 
[18:04:47.811]                               next
[18:04:47.811]                             invokeRestart(restart)
[18:04:47.811]                             muffled <- TRUE
[18:04:47.811]                             break
[18:04:47.811]                           }
[18:04:47.811]                         }
[18:04:47.811]                       }
[18:04:47.811]                       invisible(muffled)
[18:04:47.811]                     }
[18:04:47.811]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.811]                   }
[18:04:47.811]                 }
[18:04:47.811]                 else {
[18:04:47.811]                   if (TRUE) {
[18:04:47.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.811]                     {
[18:04:47.811]                       inherits <- base::inherits
[18:04:47.811]                       invokeRestart <- base::invokeRestart
[18:04:47.811]                       is.null <- base::is.null
[18:04:47.811]                       muffled <- FALSE
[18:04:47.811]                       if (inherits(cond, "message")) {
[18:04:47.811]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.811]                         if (muffled) 
[18:04:47.811]                           invokeRestart("muffleMessage")
[18:04:47.811]                       }
[18:04:47.811]                       else if (inherits(cond, "warning")) {
[18:04:47.811]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.811]                         if (muffled) 
[18:04:47.811]                           invokeRestart("muffleWarning")
[18:04:47.811]                       }
[18:04:47.811]                       else if (inherits(cond, "condition")) {
[18:04:47.811]                         if (!is.null(pattern)) {
[18:04:47.811]                           computeRestarts <- base::computeRestarts
[18:04:47.811]                           grepl <- base::grepl
[18:04:47.811]                           restarts <- computeRestarts(cond)
[18:04:47.811]                           for (restart in restarts) {
[18:04:47.811]                             name <- restart$name
[18:04:47.811]                             if (is.null(name)) 
[18:04:47.811]                               next
[18:04:47.811]                             if (!grepl(pattern, name)) 
[18:04:47.811]                               next
[18:04:47.811]                             invokeRestart(restart)
[18:04:47.811]                             muffled <- TRUE
[18:04:47.811]                             break
[18:04:47.811]                           }
[18:04:47.811]                         }
[18:04:47.811]                       }
[18:04:47.811]                       invisible(muffled)
[18:04:47.811]                     }
[18:04:47.811]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.811]                   }
[18:04:47.811]                 }
[18:04:47.811]             }
[18:04:47.811]         }))
[18:04:47.811]     }, error = function(ex) {
[18:04:47.811]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.811]                 ...future.rng), started = ...future.startTime, 
[18:04:47.811]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.811]             version = "1.8"), class = "FutureResult")
[18:04:47.811]     }, finally = {
[18:04:47.811]         if (!identical(...future.workdir, getwd())) 
[18:04:47.811]             setwd(...future.workdir)
[18:04:47.811]         {
[18:04:47.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.811]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.811]             }
[18:04:47.811]             base::options(...future.oldOptions)
[18:04:47.811]             if (.Platform$OS.type == "windows") {
[18:04:47.811]                 old_names <- names(...future.oldEnvVars)
[18:04:47.811]                 envs <- base::Sys.getenv()
[18:04:47.811]                 names <- names(envs)
[18:04:47.811]                 common <- intersect(names, old_names)
[18:04:47.811]                 added <- setdiff(names, old_names)
[18:04:47.811]                 removed <- setdiff(old_names, names)
[18:04:47.811]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.811]                   envs[common]]
[18:04:47.811]                 NAMES <- toupper(changed)
[18:04:47.811]                 args <- list()
[18:04:47.811]                 for (kk in seq_along(NAMES)) {
[18:04:47.811]                   name <- changed[[kk]]
[18:04:47.811]                   NAME <- NAMES[[kk]]
[18:04:47.811]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.811]                     next
[18:04:47.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.811]                 }
[18:04:47.811]                 NAMES <- toupper(added)
[18:04:47.811]                 for (kk in seq_along(NAMES)) {
[18:04:47.811]                   name <- added[[kk]]
[18:04:47.811]                   NAME <- NAMES[[kk]]
[18:04:47.811]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.811]                     next
[18:04:47.811]                   args[[name]] <- ""
[18:04:47.811]                 }
[18:04:47.811]                 NAMES <- toupper(removed)
[18:04:47.811]                 for (kk in seq_along(NAMES)) {
[18:04:47.811]                   name <- removed[[kk]]
[18:04:47.811]                   NAME <- NAMES[[kk]]
[18:04:47.811]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.811]                     next
[18:04:47.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.811]                 }
[18:04:47.811]                 if (length(args) > 0) 
[18:04:47.811]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.811]             }
[18:04:47.811]             else {
[18:04:47.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.811]             }
[18:04:47.811]             {
[18:04:47.811]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.811]                   0L) {
[18:04:47.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.811]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.811]                   base::options(opts)
[18:04:47.811]                 }
[18:04:47.811]                 {
[18:04:47.811]                   {
[18:04:47.811]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:47.811]                     NULL
[18:04:47.811]                   }
[18:04:47.811]                   options(future.plan = NULL)
[18:04:47.811]                   if (is.na(NA_character_)) 
[18:04:47.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.811]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.811]                     .init = FALSE)
[18:04:47.811]                 }
[18:04:47.811]             }
[18:04:47.811]         }
[18:04:47.811]     })
[18:04:47.811]     if (TRUE) {
[18:04:47.811]         base::sink(type = "output", split = FALSE)
[18:04:47.811]         if (TRUE) {
[18:04:47.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.811]         }
[18:04:47.811]         else {
[18:04:47.811]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.811]         }
[18:04:47.811]         base::close(...future.stdout)
[18:04:47.811]         ...future.stdout <- NULL
[18:04:47.811]     }
[18:04:47.811]     ...future.result$conditions <- ...future.conditions
[18:04:47.811]     ...future.result$finished <- base::Sys.time()
[18:04:47.811]     ...future.result
[18:04:47.811] }
[18:04:47.816] requestCore(): workers = 2
[18:04:47.819] MulticoreFuture started
[18:04:47.820] - Launch lazy future ... done
[18:04:47.821] run() for ‘MulticoreFuture’ ... done
[18:04:47.822] result() for MulticoreFuture ...
[18:04:47.824] plan(): Setting new future strategy stack:
[18:04:47.824] List of future strategies:
[18:04:47.824] 1. sequential:
[18:04:47.824]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.824]    - tweaked: FALSE
[18:04:47.824]    - call: NULL
[18:04:47.827] plan(): nbrOfWorkers() = 1
[18:04:47.831] plan(): Setting new future strategy stack:
[18:04:47.831] List of future strategies:
[18:04:47.831] 1. multicore:
[18:04:47.831]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:47.831]    - tweaked: FALSE
[18:04:47.831]    - call: plan(strategy)
[18:04:47.841] plan(): nbrOfWorkers() = 2
[18:04:47.843] result() for MulticoreFuture ...
[18:04:47.843] result() for MulticoreFuture ... done
[18:04:47.844] result() for MulticoreFuture ... done
[18:04:47.844] result() for MulticoreFuture ...
[18:04:47.844] result() for MulticoreFuture ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.845] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.846] Searching for globals...
[18:04:47.851] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:47.851] Searching for globals ... DONE
[18:04:47.851] Resolving globals: TRUE
[18:04:47.852] Resolving any globals that are futures ...
[18:04:47.852] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:47.852] Resolving any globals that are futures ... DONE
[18:04:47.853] Resolving futures part of globals (recursively) ...
[18:04:47.854] resolve() on list ...
[18:04:47.854]  recursive: 99
[18:04:47.854]  length: 1
[18:04:47.854]  elements: ‘x’
[18:04:47.855]  length: 0 (resolved future 1)
[18:04:47.855] resolve() on list ... DONE
[18:04:47.855] - globals: [1] ‘x’
[18:04:47.855] Resolving futures part of globals (recursively) ... DONE
[18:04:47.856] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.857] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.857] - globals: [1] ‘x’
[18:04:47.857] 
[18:04:47.857] getGlobalsAndPackages() ... DONE
[18:04:47.858] run() for ‘Future’ ...
[18:04:47.859] - state: ‘created’
[18:04:47.859] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:47.866] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:47.867] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:47.867]   - Field: ‘label’
[18:04:47.867]   - Field: ‘local’
[18:04:47.867]   - Field: ‘owner’
[18:04:47.868]   - Field: ‘envir’
[18:04:47.868]   - Field: ‘workers’
[18:04:47.868]   - Field: ‘packages’
[18:04:47.868]   - Field: ‘gc’
[18:04:47.869]   - Field: ‘job’
[18:04:47.869]   - Field: ‘conditions’
[18:04:47.869]   - Field: ‘expr’
[18:04:47.869]   - Field: ‘uuid’
[18:04:47.870]   - Field: ‘seed’
[18:04:47.870]   - Field: ‘version’
[18:04:47.870]   - Field: ‘result’
[18:04:47.870]   - Field: ‘asynchronous’
[18:04:47.871]   - Field: ‘calls’
[18:04:47.871]   - Field: ‘globals’
[18:04:47.871]   - Field: ‘stdout’
[18:04:47.871]   - Field: ‘earlySignal’
[18:04:47.871]   - Field: ‘lazy’
[18:04:47.872]   - Field: ‘state’
[18:04:47.872] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:47.872] - Launch lazy future ...
[18:04:47.873] Packages needed by the future expression (n = 0): <none>
[18:04:47.873] Packages needed by future strategies (n = 0): <none>
[18:04:47.874] {
[18:04:47.874]     {
[18:04:47.874]         {
[18:04:47.874]             ...future.startTime <- base::Sys.time()
[18:04:47.874]             {
[18:04:47.874]                 {
[18:04:47.874]                   {
[18:04:47.874]                     {
[18:04:47.874]                       base::local({
[18:04:47.874]                         has_future <- base::requireNamespace("future", 
[18:04:47.874]                           quietly = TRUE)
[18:04:47.874]                         if (has_future) {
[18:04:47.874]                           ns <- base::getNamespace("future")
[18:04:47.874]                           version <- ns[[".package"]][["version"]]
[18:04:47.874]                           if (is.null(version)) 
[18:04:47.874]                             version <- utils::packageVersion("future")
[18:04:47.874]                         }
[18:04:47.874]                         else {
[18:04:47.874]                           version <- NULL
[18:04:47.874]                         }
[18:04:47.874]                         if (!has_future || version < "1.8.0") {
[18:04:47.874]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.874]                             "", base::R.version$version.string), 
[18:04:47.874]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:47.874]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.874]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.874]                               "release", "version")], collapse = " "), 
[18:04:47.874]                             hostname = base::Sys.info()[["nodename"]])
[18:04:47.874]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.874]                             info)
[18:04:47.874]                           info <- base::paste(info, collapse = "; ")
[18:04:47.874]                           if (!has_future) {
[18:04:47.874]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.874]                               info)
[18:04:47.874]                           }
[18:04:47.874]                           else {
[18:04:47.874]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.874]                               info, version)
[18:04:47.874]                           }
[18:04:47.874]                           base::stop(msg)
[18:04:47.874]                         }
[18:04:47.874]                       })
[18:04:47.874]                     }
[18:04:47.874]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:47.874]                     base::options(mc.cores = 1L)
[18:04:47.874]                   }
[18:04:47.874]                   ...future.strategy.old <- future::plan("list")
[18:04:47.874]                   options(future.plan = NULL)
[18:04:47.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.874]                 }
[18:04:47.874]                 ...future.workdir <- getwd()
[18:04:47.874]             }
[18:04:47.874]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.874]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.874]         }
[18:04:47.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.874]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.874]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.874]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.874]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.874]             base::names(...future.oldOptions))
[18:04:47.874]     }
[18:04:47.874]     if (FALSE) {
[18:04:47.874]     }
[18:04:47.874]     else {
[18:04:47.874]         if (TRUE) {
[18:04:47.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.874]                 open = "w")
[18:04:47.874]         }
[18:04:47.874]         else {
[18:04:47.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.874]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.874]         }
[18:04:47.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.874]             base::sink(type = "output", split = FALSE)
[18:04:47.874]             base::close(...future.stdout)
[18:04:47.874]         }, add = TRUE)
[18:04:47.874]     }
[18:04:47.874]     ...future.frame <- base::sys.nframe()
[18:04:47.874]     ...future.conditions <- base::list()
[18:04:47.874]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.874]     if (FALSE) {
[18:04:47.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.874]     }
[18:04:47.874]     ...future.result <- base::tryCatch({
[18:04:47.874]         base::withCallingHandlers({
[18:04:47.874]             ...future.value <- base::withVisible(base::local({
[18:04:47.874]                 withCallingHandlers({
[18:04:47.874]                   {
[18:04:47.874]                     x[["a"]] <- 1
[18:04:47.874]                     x
[18:04:47.874]                   }
[18:04:47.874]                 }, immediateCondition = function(cond) {
[18:04:47.874]                   save_rds <- function (object, pathname, ...) 
[18:04:47.874]                   {
[18:04:47.874]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:47.874]                     if (file_test("-f", pathname_tmp)) {
[18:04:47.874]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.874]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:47.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.874]                         fi_tmp[["mtime"]])
[18:04:47.874]                     }
[18:04:47.874]                     tryCatch({
[18:04:47.874]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:47.874]                     }, error = function(ex) {
[18:04:47.874]                       msg <- conditionMessage(ex)
[18:04:47.874]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.874]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:47.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.874]                         fi_tmp[["mtime"]], msg)
[18:04:47.874]                       ex$message <- msg
[18:04:47.874]                       stop(ex)
[18:04:47.874]                     })
[18:04:47.874]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:47.874]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:47.874]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:47.874]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.874]                       fi <- file.info(pathname)
[18:04:47.874]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:47.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.874]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:47.874]                         fi[["size"]], fi[["mtime"]])
[18:04:47.874]                       stop(msg)
[18:04:47.874]                     }
[18:04:47.874]                     invisible(pathname)
[18:04:47.874]                   }
[18:04:47.874]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:47.874]                     rootPath = tempdir()) 
[18:04:47.874]                   {
[18:04:47.874]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:47.874]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:47.874]                       tmpdir = path, fileext = ".rds")
[18:04:47.874]                     save_rds(obj, file)
[18:04:47.874]                   }
[18:04:47.874]                   saveImmediateCondition(cond, path = "/tmp/RtmpGpkrBm/.future/immediateConditions")
[18:04:47.874]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.874]                   {
[18:04:47.874]                     inherits <- base::inherits
[18:04:47.874]                     invokeRestart <- base::invokeRestart
[18:04:47.874]                     is.null <- base::is.null
[18:04:47.874]                     muffled <- FALSE
[18:04:47.874]                     if (inherits(cond, "message")) {
[18:04:47.874]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:47.874]                       if (muffled) 
[18:04:47.874]                         invokeRestart("muffleMessage")
[18:04:47.874]                     }
[18:04:47.874]                     else if (inherits(cond, "warning")) {
[18:04:47.874]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:47.874]                       if (muffled) 
[18:04:47.874]                         invokeRestart("muffleWarning")
[18:04:47.874]                     }
[18:04:47.874]                     else if (inherits(cond, "condition")) {
[18:04:47.874]                       if (!is.null(pattern)) {
[18:04:47.874]                         computeRestarts <- base::computeRestarts
[18:04:47.874]                         grepl <- base::grepl
[18:04:47.874]                         restarts <- computeRestarts(cond)
[18:04:47.874]                         for (restart in restarts) {
[18:04:47.874]                           name <- restart$name
[18:04:47.874]                           if (is.null(name)) 
[18:04:47.874]                             next
[18:04:47.874]                           if (!grepl(pattern, name)) 
[18:04:47.874]                             next
[18:04:47.874]                           invokeRestart(restart)
[18:04:47.874]                           muffled <- TRUE
[18:04:47.874]                           break
[18:04:47.874]                         }
[18:04:47.874]                       }
[18:04:47.874]                     }
[18:04:47.874]                     invisible(muffled)
[18:04:47.874]                   }
[18:04:47.874]                   muffleCondition(cond)
[18:04:47.874]                 })
[18:04:47.874]             }))
[18:04:47.874]             future::FutureResult(value = ...future.value$value, 
[18:04:47.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.874]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.874]                     ...future.globalenv.names))
[18:04:47.874]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.874]         }, condition = base::local({
[18:04:47.874]             c <- base::c
[18:04:47.874]             inherits <- base::inherits
[18:04:47.874]             invokeRestart <- base::invokeRestart
[18:04:47.874]             length <- base::length
[18:04:47.874]             list <- base::list
[18:04:47.874]             seq.int <- base::seq.int
[18:04:47.874]             signalCondition <- base::signalCondition
[18:04:47.874]             sys.calls <- base::sys.calls
[18:04:47.874]             `[[` <- base::`[[`
[18:04:47.874]             `+` <- base::`+`
[18:04:47.874]             `<<-` <- base::`<<-`
[18:04:47.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.874]                   3L)]
[18:04:47.874]             }
[18:04:47.874]             function(cond) {
[18:04:47.874]                 is_error <- inherits(cond, "error")
[18:04:47.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.874]                   NULL)
[18:04:47.874]                 if (is_error) {
[18:04:47.874]                   sessionInformation <- function() {
[18:04:47.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.874]                       search = base::search(), system = base::Sys.info())
[18:04:47.874]                   }
[18:04:47.874]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.874]                     cond$call), session = sessionInformation(), 
[18:04:47.874]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.874]                   signalCondition(cond)
[18:04:47.874]                 }
[18:04:47.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.874]                 "immediateCondition"))) {
[18:04:47.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.874]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.874]                   if (TRUE && !signal) {
[18:04:47.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.874]                     {
[18:04:47.874]                       inherits <- base::inherits
[18:04:47.874]                       invokeRestart <- base::invokeRestart
[18:04:47.874]                       is.null <- base::is.null
[18:04:47.874]                       muffled <- FALSE
[18:04:47.874]                       if (inherits(cond, "message")) {
[18:04:47.874]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.874]                         if (muffled) 
[18:04:47.874]                           invokeRestart("muffleMessage")
[18:04:47.874]                       }
[18:04:47.874]                       else if (inherits(cond, "warning")) {
[18:04:47.874]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.874]                         if (muffled) 
[18:04:47.874]                           invokeRestart("muffleWarning")
[18:04:47.874]                       }
[18:04:47.874]                       else if (inherits(cond, "condition")) {
[18:04:47.874]                         if (!is.null(pattern)) {
[18:04:47.874]                           computeRestarts <- base::computeRestarts
[18:04:47.874]                           grepl <- base::grepl
[18:04:47.874]                           restarts <- computeRestarts(cond)
[18:04:47.874]                           for (restart in restarts) {
[18:04:47.874]                             name <- restart$name
[18:04:47.874]                             if (is.null(name)) 
[18:04:47.874]                               next
[18:04:47.874]                             if (!grepl(pattern, name)) 
[18:04:47.874]                               next
[18:04:47.874]                             invokeRestart(restart)
[18:04:47.874]                             muffled <- TRUE
[18:04:47.874]                             break
[18:04:47.874]                           }
[18:04:47.874]                         }
[18:04:47.874]                       }
[18:04:47.874]                       invisible(muffled)
[18:04:47.874]                     }
[18:04:47.874]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.874]                   }
[18:04:47.874]                 }
[18:04:47.874]                 else {
[18:04:47.874]                   if (TRUE) {
[18:04:47.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.874]                     {
[18:04:47.874]                       inherits <- base::inherits
[18:04:47.874]                       invokeRestart <- base::invokeRestart
[18:04:47.874]                       is.null <- base::is.null
[18:04:47.874]                       muffled <- FALSE
[18:04:47.874]                       if (inherits(cond, "message")) {
[18:04:47.874]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.874]                         if (muffled) 
[18:04:47.874]                           invokeRestart("muffleMessage")
[18:04:47.874]                       }
[18:04:47.874]                       else if (inherits(cond, "warning")) {
[18:04:47.874]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.874]                         if (muffled) 
[18:04:47.874]                           invokeRestart("muffleWarning")
[18:04:47.874]                       }
[18:04:47.874]                       else if (inherits(cond, "condition")) {
[18:04:47.874]                         if (!is.null(pattern)) {
[18:04:47.874]                           computeRestarts <- base::computeRestarts
[18:04:47.874]                           grepl <- base::grepl
[18:04:47.874]                           restarts <- computeRestarts(cond)
[18:04:47.874]                           for (restart in restarts) {
[18:04:47.874]                             name <- restart$name
[18:04:47.874]                             if (is.null(name)) 
[18:04:47.874]                               next
[18:04:47.874]                             if (!grepl(pattern, name)) 
[18:04:47.874]                               next
[18:04:47.874]                             invokeRestart(restart)
[18:04:47.874]                             muffled <- TRUE
[18:04:47.874]                             break
[18:04:47.874]                           }
[18:04:47.874]                         }
[18:04:47.874]                       }
[18:04:47.874]                       invisible(muffled)
[18:04:47.874]                     }
[18:04:47.874]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.874]                   }
[18:04:47.874]                 }
[18:04:47.874]             }
[18:04:47.874]         }))
[18:04:47.874]     }, error = function(ex) {
[18:04:47.874]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.874]                 ...future.rng), started = ...future.startTime, 
[18:04:47.874]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.874]             version = "1.8"), class = "FutureResult")
[18:04:47.874]     }, finally = {
[18:04:47.874]         if (!identical(...future.workdir, getwd())) 
[18:04:47.874]             setwd(...future.workdir)
[18:04:47.874]         {
[18:04:47.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.874]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.874]             }
[18:04:47.874]             base::options(...future.oldOptions)
[18:04:47.874]             if (.Platform$OS.type == "windows") {
[18:04:47.874]                 old_names <- names(...future.oldEnvVars)
[18:04:47.874]                 envs <- base::Sys.getenv()
[18:04:47.874]                 names <- names(envs)
[18:04:47.874]                 common <- intersect(names, old_names)
[18:04:47.874]                 added <- setdiff(names, old_names)
[18:04:47.874]                 removed <- setdiff(old_names, names)
[18:04:47.874]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.874]                   envs[common]]
[18:04:47.874]                 NAMES <- toupper(changed)
[18:04:47.874]                 args <- list()
[18:04:47.874]                 for (kk in seq_along(NAMES)) {
[18:04:47.874]                   name <- changed[[kk]]
[18:04:47.874]                   NAME <- NAMES[[kk]]
[18:04:47.874]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.874]                     next
[18:04:47.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.874]                 }
[18:04:47.874]                 NAMES <- toupper(added)
[18:04:47.874]                 for (kk in seq_along(NAMES)) {
[18:04:47.874]                   name <- added[[kk]]
[18:04:47.874]                   NAME <- NAMES[[kk]]
[18:04:47.874]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.874]                     next
[18:04:47.874]                   args[[name]] <- ""
[18:04:47.874]                 }
[18:04:47.874]                 NAMES <- toupper(removed)
[18:04:47.874]                 for (kk in seq_along(NAMES)) {
[18:04:47.874]                   name <- removed[[kk]]
[18:04:47.874]                   NAME <- NAMES[[kk]]
[18:04:47.874]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.874]                     next
[18:04:47.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.874]                 }
[18:04:47.874]                 if (length(args) > 0) 
[18:04:47.874]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.874]             }
[18:04:47.874]             else {
[18:04:47.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.874]             }
[18:04:47.874]             {
[18:04:47.874]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.874]                   0L) {
[18:04:47.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.874]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.874]                   base::options(opts)
[18:04:47.874]                 }
[18:04:47.874]                 {
[18:04:47.874]                   {
[18:04:47.874]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:47.874]                     NULL
[18:04:47.874]                   }
[18:04:47.874]                   options(future.plan = NULL)
[18:04:47.874]                   if (is.na(NA_character_)) 
[18:04:47.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.874]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.874]                     .init = FALSE)
[18:04:47.874]                 }
[18:04:47.874]             }
[18:04:47.874]         }
[18:04:47.874]     })
[18:04:47.874]     if (TRUE) {
[18:04:47.874]         base::sink(type = "output", split = FALSE)
[18:04:47.874]         if (TRUE) {
[18:04:47.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.874]         }
[18:04:47.874]         else {
[18:04:47.874]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.874]         }
[18:04:47.874]         base::close(...future.stdout)
[18:04:47.874]         ...future.stdout <- NULL
[18:04:47.874]     }
[18:04:47.874]     ...future.result$conditions <- ...future.conditions
[18:04:47.874]     ...future.result$finished <- base::Sys.time()
[18:04:47.874]     ...future.result
[18:04:47.874] }
[18:04:47.879] assign_globals() ...
[18:04:47.879] List of 1
[18:04:47.879]  $ x: list()
[18:04:47.879]  - attr(*, "where")=List of 1
[18:04:47.879]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.879]  - attr(*, "resolved")= logi TRUE
[18:04:47.879]  - attr(*, "total_size")= num 0
[18:04:47.879]  - attr(*, "already-done")= logi TRUE
[18:04:47.885] - copied ‘x’ to environment
[18:04:47.885] assign_globals() ... done
[18:04:47.885] requestCore(): workers = 2
[18:04:47.888] MulticoreFuture started
[18:04:47.889] - Launch lazy future ... done
[18:04:47.890] run() for ‘MulticoreFuture’ ... done
[18:04:47.890] plan(): Setting new future strategy stack:
[18:04:47.897] result() for MulticoreFuture ...
[18:04:47.891] List of future strategies:
[18:04:47.891] 1. sequential:
[18:04:47.891]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.891]    - tweaked: FALSE
[18:04:47.891]    - call: NULL
[18:04:47.899] plan(): nbrOfWorkers() = 1
[18:04:47.904] plan(): Setting new future strategy stack:
[18:04:47.904] List of future strategies:
[18:04:47.904] 1. multicore:
[18:04:47.904]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:47.904]    - tweaked: FALSE
[18:04:47.904]    - call: plan(strategy)
[18:04:47.914] plan(): nbrOfWorkers() = 2
[18:04:47.915] result() for MulticoreFuture ...
[18:04:47.916] result() for MulticoreFuture ... done
[18:04:47.916] result() for MulticoreFuture ... done
[18:04:47.916] result() for MulticoreFuture ...
[18:04:47.917] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.918] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.918] Searching for globals...
[18:04:47.924] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:47.924] Searching for globals ... DONE
[18:04:47.924] Resolving globals: TRUE
[18:04:47.924] Resolving any globals that are futures ...
[18:04:47.925] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:47.925] Resolving any globals that are futures ... DONE
[18:04:47.926] Resolving futures part of globals (recursively) ...
[18:04:47.926] resolve() on list ...
[18:04:47.927]  recursive: 99
[18:04:47.927]  length: 1
[18:04:47.927]  elements: ‘x’
[18:04:47.927]  length: 0 (resolved future 1)
[18:04:47.928] resolve() on list ... DONE
[18:04:47.928] - globals: [1] ‘x’
[18:04:47.928] Resolving futures part of globals (recursively) ... DONE
[18:04:47.929] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.929] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.930] - globals: [1] ‘x’
[18:04:47.930] 
[18:04:47.930] getGlobalsAndPackages() ... DONE
[18:04:47.931] run() for ‘Future’ ...
[18:04:47.931] - state: ‘created’
[18:04:47.931] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:47.938] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:47.939] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:47.939]   - Field: ‘label’
[18:04:47.939]   - Field: ‘local’
[18:04:47.939]   - Field: ‘owner’
[18:04:47.940]   - Field: ‘envir’
[18:04:47.940]   - Field: ‘workers’
[18:04:47.940]   - Field: ‘packages’
[18:04:47.940]   - Field: ‘gc’
[18:04:47.941]   - Field: ‘job’
[18:04:47.941]   - Field: ‘conditions’
[18:04:47.941]   - Field: ‘expr’
[18:04:47.941]   - Field: ‘uuid’
[18:04:47.942]   - Field: ‘seed’
[18:04:47.942]   - Field: ‘version’
[18:04:47.942]   - Field: ‘result’
[18:04:47.942]   - Field: ‘asynchronous’
[18:04:47.942]   - Field: ‘calls’
[18:04:47.943]   - Field: ‘globals’
[18:04:47.943]   - Field: ‘stdout’
[18:04:47.943]   - Field: ‘earlySignal’
[18:04:47.943]   - Field: ‘lazy’
[18:04:47.944]   - Field: ‘state’
[18:04:47.944] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:47.944] - Launch lazy future ...
[18:04:47.945] Packages needed by the future expression (n = 0): <none>
[18:04:47.945] Packages needed by future strategies (n = 0): <none>
[18:04:47.946] {
[18:04:47.946]     {
[18:04:47.946]         {
[18:04:47.946]             ...future.startTime <- base::Sys.time()
[18:04:47.946]             {
[18:04:47.946]                 {
[18:04:47.946]                   {
[18:04:47.946]                     {
[18:04:47.946]                       base::local({
[18:04:47.946]                         has_future <- base::requireNamespace("future", 
[18:04:47.946]                           quietly = TRUE)
[18:04:47.946]                         if (has_future) {
[18:04:47.946]                           ns <- base::getNamespace("future")
[18:04:47.946]                           version <- ns[[".package"]][["version"]]
[18:04:47.946]                           if (is.null(version)) 
[18:04:47.946]                             version <- utils::packageVersion("future")
[18:04:47.946]                         }
[18:04:47.946]                         else {
[18:04:47.946]                           version <- NULL
[18:04:47.946]                         }
[18:04:47.946]                         if (!has_future || version < "1.8.0") {
[18:04:47.946]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:47.946]                             "", base::R.version$version.string), 
[18:04:47.946]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:47.946]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:47.946]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:47.946]                               "release", "version")], collapse = " "), 
[18:04:47.946]                             hostname = base::Sys.info()[["nodename"]])
[18:04:47.946]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:47.946]                             info)
[18:04:47.946]                           info <- base::paste(info, collapse = "; ")
[18:04:47.946]                           if (!has_future) {
[18:04:47.946]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:47.946]                               info)
[18:04:47.946]                           }
[18:04:47.946]                           else {
[18:04:47.946]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:47.946]                               info, version)
[18:04:47.946]                           }
[18:04:47.946]                           base::stop(msg)
[18:04:47.946]                         }
[18:04:47.946]                       })
[18:04:47.946]                     }
[18:04:47.946]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:47.946]                     base::options(mc.cores = 1L)
[18:04:47.946]                   }
[18:04:47.946]                   ...future.strategy.old <- future::plan("list")
[18:04:47.946]                   options(future.plan = NULL)
[18:04:47.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:47.946]                 }
[18:04:47.946]                 ...future.workdir <- getwd()
[18:04:47.946]             }
[18:04:47.946]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:47.946]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:47.946]         }
[18:04:47.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:47.946]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:47.946]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:47.946]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:47.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:47.946]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:47.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:47.946]             base::names(...future.oldOptions))
[18:04:47.946]     }
[18:04:47.946]     if (FALSE) {
[18:04:47.946]     }
[18:04:47.946]     else {
[18:04:47.946]         if (TRUE) {
[18:04:47.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:47.946]                 open = "w")
[18:04:47.946]         }
[18:04:47.946]         else {
[18:04:47.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:47.946]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:47.946]         }
[18:04:47.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:47.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:47.946]             base::sink(type = "output", split = FALSE)
[18:04:47.946]             base::close(...future.stdout)
[18:04:47.946]         }, add = TRUE)
[18:04:47.946]     }
[18:04:47.946]     ...future.frame <- base::sys.nframe()
[18:04:47.946]     ...future.conditions <- base::list()
[18:04:47.946]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:47.946]     if (FALSE) {
[18:04:47.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:47.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:47.946]     }
[18:04:47.946]     ...future.result <- base::tryCatch({
[18:04:47.946]         base::withCallingHandlers({
[18:04:47.946]             ...future.value <- base::withVisible(base::local({
[18:04:47.946]                 withCallingHandlers({
[18:04:47.946]                   {
[18:04:47.946]                     x[["a"]] <- 1
[18:04:47.946]                     x
[18:04:47.946]                   }
[18:04:47.946]                 }, immediateCondition = function(cond) {
[18:04:47.946]                   save_rds <- function (object, pathname, ...) 
[18:04:47.946]                   {
[18:04:47.946]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:47.946]                     if (file_test("-f", pathname_tmp)) {
[18:04:47.946]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.946]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:47.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.946]                         fi_tmp[["mtime"]])
[18:04:47.946]                     }
[18:04:47.946]                     tryCatch({
[18:04:47.946]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:47.946]                     }, error = function(ex) {
[18:04:47.946]                       msg <- conditionMessage(ex)
[18:04:47.946]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.946]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:47.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.946]                         fi_tmp[["mtime"]], msg)
[18:04:47.946]                       ex$message <- msg
[18:04:47.946]                       stop(ex)
[18:04:47.946]                     })
[18:04:47.946]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:47.946]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:47.946]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:47.946]                       fi_tmp <- file.info(pathname_tmp)
[18:04:47.946]                       fi <- file.info(pathname)
[18:04:47.946]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:47.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:47.946]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:47.946]                         fi[["size"]], fi[["mtime"]])
[18:04:47.946]                       stop(msg)
[18:04:47.946]                     }
[18:04:47.946]                     invisible(pathname)
[18:04:47.946]                   }
[18:04:47.946]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:47.946]                     rootPath = tempdir()) 
[18:04:47.946]                   {
[18:04:47.946]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:47.946]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:47.946]                       tmpdir = path, fileext = ".rds")
[18:04:47.946]                     save_rds(obj, file)
[18:04:47.946]                   }
[18:04:47.946]                   saveImmediateCondition(cond, path = "/tmp/RtmpGpkrBm/.future/immediateConditions")
[18:04:47.946]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.946]                   {
[18:04:47.946]                     inherits <- base::inherits
[18:04:47.946]                     invokeRestart <- base::invokeRestart
[18:04:47.946]                     is.null <- base::is.null
[18:04:47.946]                     muffled <- FALSE
[18:04:47.946]                     if (inherits(cond, "message")) {
[18:04:47.946]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:47.946]                       if (muffled) 
[18:04:47.946]                         invokeRestart("muffleMessage")
[18:04:47.946]                     }
[18:04:47.946]                     else if (inherits(cond, "warning")) {
[18:04:47.946]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:47.946]                       if (muffled) 
[18:04:47.946]                         invokeRestart("muffleWarning")
[18:04:47.946]                     }
[18:04:47.946]                     else if (inherits(cond, "condition")) {
[18:04:47.946]                       if (!is.null(pattern)) {
[18:04:47.946]                         computeRestarts <- base::computeRestarts
[18:04:47.946]                         grepl <- base::grepl
[18:04:47.946]                         restarts <- computeRestarts(cond)
[18:04:47.946]                         for (restart in restarts) {
[18:04:47.946]                           name <- restart$name
[18:04:47.946]                           if (is.null(name)) 
[18:04:47.946]                             next
[18:04:47.946]                           if (!grepl(pattern, name)) 
[18:04:47.946]                             next
[18:04:47.946]                           invokeRestart(restart)
[18:04:47.946]                           muffled <- TRUE
[18:04:47.946]                           break
[18:04:47.946]                         }
[18:04:47.946]                       }
[18:04:47.946]                     }
[18:04:47.946]                     invisible(muffled)
[18:04:47.946]                   }
[18:04:47.946]                   muffleCondition(cond)
[18:04:47.946]                 })
[18:04:47.946]             }))
[18:04:47.946]             future::FutureResult(value = ...future.value$value, 
[18:04:47.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.946]                   ...future.rng), globalenv = if (FALSE) 
[18:04:47.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:47.946]                     ...future.globalenv.names))
[18:04:47.946]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:47.946]         }, condition = base::local({
[18:04:47.946]             c <- base::c
[18:04:47.946]             inherits <- base::inherits
[18:04:47.946]             invokeRestart <- base::invokeRestart
[18:04:47.946]             length <- base::length
[18:04:47.946]             list <- base::list
[18:04:47.946]             seq.int <- base::seq.int
[18:04:47.946]             signalCondition <- base::signalCondition
[18:04:47.946]             sys.calls <- base::sys.calls
[18:04:47.946]             `[[` <- base::`[[`
[18:04:47.946]             `+` <- base::`+`
[18:04:47.946]             `<<-` <- base::`<<-`
[18:04:47.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:47.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:47.946]                   3L)]
[18:04:47.946]             }
[18:04:47.946]             function(cond) {
[18:04:47.946]                 is_error <- inherits(cond, "error")
[18:04:47.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:47.946]                   NULL)
[18:04:47.946]                 if (is_error) {
[18:04:47.946]                   sessionInformation <- function() {
[18:04:47.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:47.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:47.946]                       search = base::search(), system = base::Sys.info())
[18:04:47.946]                   }
[18:04:47.946]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:47.946]                     cond$call), session = sessionInformation(), 
[18:04:47.946]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:47.946]                   signalCondition(cond)
[18:04:47.946]                 }
[18:04:47.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:47.946]                 "immediateCondition"))) {
[18:04:47.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:47.946]                   ...future.conditions[[length(...future.conditions) + 
[18:04:47.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:47.946]                   if (TRUE && !signal) {
[18:04:47.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.946]                     {
[18:04:47.946]                       inherits <- base::inherits
[18:04:47.946]                       invokeRestart <- base::invokeRestart
[18:04:47.946]                       is.null <- base::is.null
[18:04:47.946]                       muffled <- FALSE
[18:04:47.946]                       if (inherits(cond, "message")) {
[18:04:47.946]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.946]                         if (muffled) 
[18:04:47.946]                           invokeRestart("muffleMessage")
[18:04:47.946]                       }
[18:04:47.946]                       else if (inherits(cond, "warning")) {
[18:04:47.946]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.946]                         if (muffled) 
[18:04:47.946]                           invokeRestart("muffleWarning")
[18:04:47.946]                       }
[18:04:47.946]                       else if (inherits(cond, "condition")) {
[18:04:47.946]                         if (!is.null(pattern)) {
[18:04:47.946]                           computeRestarts <- base::computeRestarts
[18:04:47.946]                           grepl <- base::grepl
[18:04:47.946]                           restarts <- computeRestarts(cond)
[18:04:47.946]                           for (restart in restarts) {
[18:04:47.946]                             name <- restart$name
[18:04:47.946]                             if (is.null(name)) 
[18:04:47.946]                               next
[18:04:47.946]                             if (!grepl(pattern, name)) 
[18:04:47.946]                               next
[18:04:47.946]                             invokeRestart(restart)
[18:04:47.946]                             muffled <- TRUE
[18:04:47.946]                             break
[18:04:47.946]                           }
[18:04:47.946]                         }
[18:04:47.946]                       }
[18:04:47.946]                       invisible(muffled)
[18:04:47.946]                     }
[18:04:47.946]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.946]                   }
[18:04:47.946]                 }
[18:04:47.946]                 else {
[18:04:47.946]                   if (TRUE) {
[18:04:47.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:47.946]                     {
[18:04:47.946]                       inherits <- base::inherits
[18:04:47.946]                       invokeRestart <- base::invokeRestart
[18:04:47.946]                       is.null <- base::is.null
[18:04:47.946]                       muffled <- FALSE
[18:04:47.946]                       if (inherits(cond, "message")) {
[18:04:47.946]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:47.946]                         if (muffled) 
[18:04:47.946]                           invokeRestart("muffleMessage")
[18:04:47.946]                       }
[18:04:47.946]                       else if (inherits(cond, "warning")) {
[18:04:47.946]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:47.946]                         if (muffled) 
[18:04:47.946]                           invokeRestart("muffleWarning")
[18:04:47.946]                       }
[18:04:47.946]                       else if (inherits(cond, "condition")) {
[18:04:47.946]                         if (!is.null(pattern)) {
[18:04:47.946]                           computeRestarts <- base::computeRestarts
[18:04:47.946]                           grepl <- base::grepl
[18:04:47.946]                           restarts <- computeRestarts(cond)
[18:04:47.946]                           for (restart in restarts) {
[18:04:47.946]                             name <- restart$name
[18:04:47.946]                             if (is.null(name)) 
[18:04:47.946]                               next
[18:04:47.946]                             if (!grepl(pattern, name)) 
[18:04:47.946]                               next
[18:04:47.946]                             invokeRestart(restart)
[18:04:47.946]                             muffled <- TRUE
[18:04:47.946]                             break
[18:04:47.946]                           }
[18:04:47.946]                         }
[18:04:47.946]                       }
[18:04:47.946]                       invisible(muffled)
[18:04:47.946]                     }
[18:04:47.946]                     muffleCondition(cond, pattern = "^muffle")
[18:04:47.946]                   }
[18:04:47.946]                 }
[18:04:47.946]             }
[18:04:47.946]         }))
[18:04:47.946]     }, error = function(ex) {
[18:04:47.946]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:47.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:47.946]                 ...future.rng), started = ...future.startTime, 
[18:04:47.946]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:47.946]             version = "1.8"), class = "FutureResult")
[18:04:47.946]     }, finally = {
[18:04:47.946]         if (!identical(...future.workdir, getwd())) 
[18:04:47.946]             setwd(...future.workdir)
[18:04:47.946]         {
[18:04:47.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:47.946]                 ...future.oldOptions$nwarnings <- NULL
[18:04:47.946]             }
[18:04:47.946]             base::options(...future.oldOptions)
[18:04:47.946]             if (.Platform$OS.type == "windows") {
[18:04:47.946]                 old_names <- names(...future.oldEnvVars)
[18:04:47.946]                 envs <- base::Sys.getenv()
[18:04:47.946]                 names <- names(envs)
[18:04:47.946]                 common <- intersect(names, old_names)
[18:04:47.946]                 added <- setdiff(names, old_names)
[18:04:47.946]                 removed <- setdiff(old_names, names)
[18:04:47.946]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:47.946]                   envs[common]]
[18:04:47.946]                 NAMES <- toupper(changed)
[18:04:47.946]                 args <- list()
[18:04:47.946]                 for (kk in seq_along(NAMES)) {
[18:04:47.946]                   name <- changed[[kk]]
[18:04:47.946]                   NAME <- NAMES[[kk]]
[18:04:47.946]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.946]                     next
[18:04:47.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.946]                 }
[18:04:47.946]                 NAMES <- toupper(added)
[18:04:47.946]                 for (kk in seq_along(NAMES)) {
[18:04:47.946]                   name <- added[[kk]]
[18:04:47.946]                   NAME <- NAMES[[kk]]
[18:04:47.946]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.946]                     next
[18:04:47.946]                   args[[name]] <- ""
[18:04:47.946]                 }
[18:04:47.946]                 NAMES <- toupper(removed)
[18:04:47.946]                 for (kk in seq_along(NAMES)) {
[18:04:47.946]                   name <- removed[[kk]]
[18:04:47.946]                   NAME <- NAMES[[kk]]
[18:04:47.946]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:47.946]                     next
[18:04:47.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:47.946]                 }
[18:04:47.946]                 if (length(args) > 0) 
[18:04:47.946]                   base::do.call(base::Sys.setenv, args = args)
[18:04:47.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:47.946]             }
[18:04:47.946]             else {
[18:04:47.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:47.946]             }
[18:04:47.946]             {
[18:04:47.946]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:47.946]                   0L) {
[18:04:47.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:47.946]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:47.946]                   base::options(opts)
[18:04:47.946]                 }
[18:04:47.946]                 {
[18:04:47.946]                   {
[18:04:47.946]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:47.946]                     NULL
[18:04:47.946]                   }
[18:04:47.946]                   options(future.plan = NULL)
[18:04:47.946]                   if (is.na(NA_character_)) 
[18:04:47.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:47.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:47.946]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:47.946]                     .init = FALSE)
[18:04:47.946]                 }
[18:04:47.946]             }
[18:04:47.946]         }
[18:04:47.946]     })
[18:04:47.946]     if (TRUE) {
[18:04:47.946]         base::sink(type = "output", split = FALSE)
[18:04:47.946]         if (TRUE) {
[18:04:47.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:47.946]         }
[18:04:47.946]         else {
[18:04:47.946]             ...future.result["stdout"] <- base::list(NULL)
[18:04:47.946]         }
[18:04:47.946]         base::close(...future.stdout)
[18:04:47.946]         ...future.stdout <- NULL
[18:04:47.946]     }
[18:04:47.946]     ...future.result$conditions <- ...future.conditions
[18:04:47.946]     ...future.result$finished <- base::Sys.time()
[18:04:47.946]     ...future.result
[18:04:47.946] }
[18:04:47.950] assign_globals() ...
[18:04:47.951] List of 1
[18:04:47.951]  $ x: list()
[18:04:47.951]  - attr(*, "where")=List of 1
[18:04:47.951]   ..$ x:<environment: R_EmptyEnv> 
[18:04:47.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:47.951]  - attr(*, "resolved")= logi TRUE
[18:04:47.951]  - attr(*, "total_size")= num 0
[18:04:47.951]  - attr(*, "already-done")= logi TRUE
[18:04:47.956] - copied ‘x’ to environment
[18:04:47.956] assign_globals() ... done
[18:04:47.957] requestCore(): workers = 2
[18:04:47.960] MulticoreFuture started
[18:04:47.961] - Launch lazy future ... done
[18:04:47.961] run() for ‘MulticoreFuture’ ... done
[18:04:47.962] result() for MulticoreFuture ...
[18:04:47.962] plan(): Setting new future strategy stack:
[18:04:47.962] List of future strategies:
[18:04:47.962] 1. sequential:
[18:04:47.962]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:47.962]    - tweaked: FALSE
[18:04:47.962]    - call: NULL
[18:04:47.965] plan(): nbrOfWorkers() = 1
[18:04:47.970] plan(): Setting new future strategy stack:
[18:04:47.970] List of future strategies:
[18:04:47.970] 1. multicore:
[18:04:47.970]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:47.970]    - tweaked: FALSE
[18:04:47.970]    - call: plan(strategy)
[18:04:47.982] plan(): nbrOfWorkers() = 2
[18:04:47.983] result() for MulticoreFuture ...
[18:04:47.984] result() for MulticoreFuture ... done
[18:04:47.984] result() for MulticoreFuture ... done
[18:04:47.984] result() for MulticoreFuture ...
[18:04:47.985] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:47.986] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:47.987] Searching for globals...
[18:04:47.992] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:47.992] Searching for globals ... DONE
[18:04:47.992] Resolving globals: TRUE
[18:04:47.993] Resolving any globals that are futures ...
[18:04:47.993] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:47.993] Resolving any globals that are futures ... DONE
[18:04:47.994] Resolving futures part of globals (recursively) ...
[18:04:47.995] resolve() on list ...
[18:04:47.995]  recursive: 99
[18:04:47.995]  length: 1
[18:04:47.995]  elements: ‘x’
[18:04:47.996]  length: 0 (resolved future 1)
[18:04:47.996] resolve() on list ... DONE
[18:04:47.996] - globals: [1] ‘x’
[18:04:47.996] Resolving futures part of globals (recursively) ... DONE
[18:04:47.997] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:47.998] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:47.998] - globals: [1] ‘x’
[18:04:47.998] 
[18:04:47.998] getGlobalsAndPackages() ... DONE
[18:04:47.999] run() for ‘Future’ ...
[18:04:47.999] - state: ‘created’
[18:04:48.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:48.007] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:48.007] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:48.007]   - Field: ‘label’
[18:04:48.008]   - Field: ‘local’
[18:04:48.008]   - Field: ‘owner’
[18:04:48.008]   - Field: ‘envir’
[18:04:48.008]   - Field: ‘workers’
[18:04:48.009]   - Field: ‘packages’
[18:04:48.009]   - Field: ‘gc’
[18:04:48.009]   - Field: ‘job’
[18:04:48.009]   - Field: ‘conditions’
[18:04:48.010]   - Field: ‘expr’
[18:04:48.010]   - Field: ‘uuid’
[18:04:48.013]   - Field: ‘seed’
[18:04:48.014]   - Field: ‘version’
[18:04:48.014]   - Field: ‘result’
[18:04:48.014]   - Field: ‘asynchronous’
[18:04:48.014]   - Field: ‘calls’
[18:04:48.015]   - Field: ‘globals’
[18:04:48.015]   - Field: ‘stdout’
[18:04:48.015]   - Field: ‘earlySignal’
[18:04:48.015]   - Field: ‘lazy’
[18:04:48.016]   - Field: ‘state’
[18:04:48.016] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:48.016] - Launch lazy future ...
[18:04:48.017] Packages needed by the future expression (n = 0): <none>
[18:04:48.017] Packages needed by future strategies (n = 0): <none>
[18:04:48.018] {
[18:04:48.018]     {
[18:04:48.018]         {
[18:04:48.018]             ...future.startTime <- base::Sys.time()
[18:04:48.018]             {
[18:04:48.018]                 {
[18:04:48.018]                   {
[18:04:48.018]                     {
[18:04:48.018]                       base::local({
[18:04:48.018]                         has_future <- base::requireNamespace("future", 
[18:04:48.018]                           quietly = TRUE)
[18:04:48.018]                         if (has_future) {
[18:04:48.018]                           ns <- base::getNamespace("future")
[18:04:48.018]                           version <- ns[[".package"]][["version"]]
[18:04:48.018]                           if (is.null(version)) 
[18:04:48.018]                             version <- utils::packageVersion("future")
[18:04:48.018]                         }
[18:04:48.018]                         else {
[18:04:48.018]                           version <- NULL
[18:04:48.018]                         }
[18:04:48.018]                         if (!has_future || version < "1.8.0") {
[18:04:48.018]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:48.018]                             "", base::R.version$version.string), 
[18:04:48.018]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:48.018]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:48.018]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:48.018]                               "release", "version")], collapse = " "), 
[18:04:48.018]                             hostname = base::Sys.info()[["nodename"]])
[18:04:48.018]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:48.018]                             info)
[18:04:48.018]                           info <- base::paste(info, collapse = "; ")
[18:04:48.018]                           if (!has_future) {
[18:04:48.018]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:48.018]                               info)
[18:04:48.018]                           }
[18:04:48.018]                           else {
[18:04:48.018]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:48.018]                               info, version)
[18:04:48.018]                           }
[18:04:48.018]                           base::stop(msg)
[18:04:48.018]                         }
[18:04:48.018]                       })
[18:04:48.018]                     }
[18:04:48.018]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:48.018]                     base::options(mc.cores = 1L)
[18:04:48.018]                   }
[18:04:48.018]                   ...future.strategy.old <- future::plan("list")
[18:04:48.018]                   options(future.plan = NULL)
[18:04:48.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:48.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:48.018]                 }
[18:04:48.018]                 ...future.workdir <- getwd()
[18:04:48.018]             }
[18:04:48.018]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:48.018]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:48.018]         }
[18:04:48.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:48.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:48.018]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:48.018]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:48.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:48.018]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:48.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:48.018]             base::names(...future.oldOptions))
[18:04:48.018]     }
[18:04:48.018]     if (FALSE) {
[18:04:48.018]     }
[18:04:48.018]     else {
[18:04:48.018]         if (TRUE) {
[18:04:48.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:48.018]                 open = "w")
[18:04:48.018]         }
[18:04:48.018]         else {
[18:04:48.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:48.018]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:48.018]         }
[18:04:48.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:48.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:48.018]             base::sink(type = "output", split = FALSE)
[18:04:48.018]             base::close(...future.stdout)
[18:04:48.018]         }, add = TRUE)
[18:04:48.018]     }
[18:04:48.018]     ...future.frame <- base::sys.nframe()
[18:04:48.018]     ...future.conditions <- base::list()
[18:04:48.018]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:48.018]     if (FALSE) {
[18:04:48.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:48.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:48.018]     }
[18:04:48.018]     ...future.result <- base::tryCatch({
[18:04:48.018]         base::withCallingHandlers({
[18:04:48.018]             ...future.value <- base::withVisible(base::local({
[18:04:48.018]                 withCallingHandlers({
[18:04:48.018]                   {
[18:04:48.018]                     x[["a"]] <- 1
[18:04:48.018]                     x
[18:04:48.018]                   }
[18:04:48.018]                 }, immediateCondition = function(cond) {
[18:04:48.018]                   save_rds <- function (object, pathname, ...) 
[18:04:48.018]                   {
[18:04:48.018]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:48.018]                     if (file_test("-f", pathname_tmp)) {
[18:04:48.018]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.018]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:48.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.018]                         fi_tmp[["mtime"]])
[18:04:48.018]                     }
[18:04:48.018]                     tryCatch({
[18:04:48.018]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:48.018]                     }, error = function(ex) {
[18:04:48.018]                       msg <- conditionMessage(ex)
[18:04:48.018]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.018]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:48.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.018]                         fi_tmp[["mtime"]], msg)
[18:04:48.018]                       ex$message <- msg
[18:04:48.018]                       stop(ex)
[18:04:48.018]                     })
[18:04:48.018]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:48.018]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:48.018]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:48.018]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.018]                       fi <- file.info(pathname)
[18:04:48.018]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:48.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.018]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:48.018]                         fi[["size"]], fi[["mtime"]])
[18:04:48.018]                       stop(msg)
[18:04:48.018]                     }
[18:04:48.018]                     invisible(pathname)
[18:04:48.018]                   }
[18:04:48.018]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:48.018]                     rootPath = tempdir()) 
[18:04:48.018]                   {
[18:04:48.018]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:48.018]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:48.018]                       tmpdir = path, fileext = ".rds")
[18:04:48.018]                     save_rds(obj, file)
[18:04:48.018]                   }
[18:04:48.018]                   saveImmediateCondition(cond, path = "/tmp/RtmpGpkrBm/.future/immediateConditions")
[18:04:48.018]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.018]                   {
[18:04:48.018]                     inherits <- base::inherits
[18:04:48.018]                     invokeRestart <- base::invokeRestart
[18:04:48.018]                     is.null <- base::is.null
[18:04:48.018]                     muffled <- FALSE
[18:04:48.018]                     if (inherits(cond, "message")) {
[18:04:48.018]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:48.018]                       if (muffled) 
[18:04:48.018]                         invokeRestart("muffleMessage")
[18:04:48.018]                     }
[18:04:48.018]                     else if (inherits(cond, "warning")) {
[18:04:48.018]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:48.018]                       if (muffled) 
[18:04:48.018]                         invokeRestart("muffleWarning")
[18:04:48.018]                     }
[18:04:48.018]                     else if (inherits(cond, "condition")) {
[18:04:48.018]                       if (!is.null(pattern)) {
[18:04:48.018]                         computeRestarts <- base::computeRestarts
[18:04:48.018]                         grepl <- base::grepl
[18:04:48.018]                         restarts <- computeRestarts(cond)
[18:04:48.018]                         for (restart in restarts) {
[18:04:48.018]                           name <- restart$name
[18:04:48.018]                           if (is.null(name)) 
[18:04:48.018]                             next
[18:04:48.018]                           if (!grepl(pattern, name)) 
[18:04:48.018]                             next
[18:04:48.018]                           invokeRestart(restart)
[18:04:48.018]                           muffled <- TRUE
[18:04:48.018]                           break
[18:04:48.018]                         }
[18:04:48.018]                       }
[18:04:48.018]                     }
[18:04:48.018]                     invisible(muffled)
[18:04:48.018]                   }
[18:04:48.018]                   muffleCondition(cond)
[18:04:48.018]                 })
[18:04:48.018]             }))
[18:04:48.018]             future::FutureResult(value = ...future.value$value, 
[18:04:48.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:48.018]                   ...future.rng), globalenv = if (FALSE) 
[18:04:48.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:48.018]                     ...future.globalenv.names))
[18:04:48.018]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:48.018]         }, condition = base::local({
[18:04:48.018]             c <- base::c
[18:04:48.018]             inherits <- base::inherits
[18:04:48.018]             invokeRestart <- base::invokeRestart
[18:04:48.018]             length <- base::length
[18:04:48.018]             list <- base::list
[18:04:48.018]             seq.int <- base::seq.int
[18:04:48.018]             signalCondition <- base::signalCondition
[18:04:48.018]             sys.calls <- base::sys.calls
[18:04:48.018]             `[[` <- base::`[[`
[18:04:48.018]             `+` <- base::`+`
[18:04:48.018]             `<<-` <- base::`<<-`
[18:04:48.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:48.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:48.018]                   3L)]
[18:04:48.018]             }
[18:04:48.018]             function(cond) {
[18:04:48.018]                 is_error <- inherits(cond, "error")
[18:04:48.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:48.018]                   NULL)
[18:04:48.018]                 if (is_error) {
[18:04:48.018]                   sessionInformation <- function() {
[18:04:48.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:48.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:48.018]                       search = base::search(), system = base::Sys.info())
[18:04:48.018]                   }
[18:04:48.018]                   ...future.conditions[[length(...future.conditions) + 
[18:04:48.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:48.018]                     cond$call), session = sessionInformation(), 
[18:04:48.018]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:48.018]                   signalCondition(cond)
[18:04:48.018]                 }
[18:04:48.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:48.018]                 "immediateCondition"))) {
[18:04:48.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:48.018]                   ...future.conditions[[length(...future.conditions) + 
[18:04:48.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:48.018]                   if (TRUE && !signal) {
[18:04:48.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.018]                     {
[18:04:48.018]                       inherits <- base::inherits
[18:04:48.018]                       invokeRestart <- base::invokeRestart
[18:04:48.018]                       is.null <- base::is.null
[18:04:48.018]                       muffled <- FALSE
[18:04:48.018]                       if (inherits(cond, "message")) {
[18:04:48.018]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:48.018]                         if (muffled) 
[18:04:48.018]                           invokeRestart("muffleMessage")
[18:04:48.018]                       }
[18:04:48.018]                       else if (inherits(cond, "warning")) {
[18:04:48.018]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:48.018]                         if (muffled) 
[18:04:48.018]                           invokeRestart("muffleWarning")
[18:04:48.018]                       }
[18:04:48.018]                       else if (inherits(cond, "condition")) {
[18:04:48.018]                         if (!is.null(pattern)) {
[18:04:48.018]                           computeRestarts <- base::computeRestarts
[18:04:48.018]                           grepl <- base::grepl
[18:04:48.018]                           restarts <- computeRestarts(cond)
[18:04:48.018]                           for (restart in restarts) {
[18:04:48.018]                             name <- restart$name
[18:04:48.018]                             if (is.null(name)) 
[18:04:48.018]                               next
[18:04:48.018]                             if (!grepl(pattern, name)) 
[18:04:48.018]                               next
[18:04:48.018]                             invokeRestart(restart)
[18:04:48.018]                             muffled <- TRUE
[18:04:48.018]                             break
[18:04:48.018]                           }
[18:04:48.018]                         }
[18:04:48.018]                       }
[18:04:48.018]                       invisible(muffled)
[18:04:48.018]                     }
[18:04:48.018]                     muffleCondition(cond, pattern = "^muffle")
[18:04:48.018]                   }
[18:04:48.018]                 }
[18:04:48.018]                 else {
[18:04:48.018]                   if (TRUE) {
[18:04:48.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.018]                     {
[18:04:48.018]                       inherits <- base::inherits
[18:04:48.018]                       invokeRestart <- base::invokeRestart
[18:04:48.018]                       is.null <- base::is.null
[18:04:48.018]                       muffled <- FALSE
[18:04:48.018]                       if (inherits(cond, "message")) {
[18:04:48.018]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:48.018]                         if (muffled) 
[18:04:48.018]                           invokeRestart("muffleMessage")
[18:04:48.018]                       }
[18:04:48.018]                       else if (inherits(cond, "warning")) {
[18:04:48.018]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:48.018]                         if (muffled) 
[18:04:48.018]                           invokeRestart("muffleWarning")
[18:04:48.018]                       }
[18:04:48.018]                       else if (inherits(cond, "condition")) {
[18:04:48.018]                         if (!is.null(pattern)) {
[18:04:48.018]                           computeRestarts <- base::computeRestarts
[18:04:48.018]                           grepl <- base::grepl
[18:04:48.018]                           restarts <- computeRestarts(cond)
[18:04:48.018]                           for (restart in restarts) {
[18:04:48.018]                             name <- restart$name
[18:04:48.018]                             if (is.null(name)) 
[18:04:48.018]                               next
[18:04:48.018]                             if (!grepl(pattern, name)) 
[18:04:48.018]                               next
[18:04:48.018]                             invokeRestart(restart)
[18:04:48.018]                             muffled <- TRUE
[18:04:48.018]                             break
[18:04:48.018]                           }
[18:04:48.018]                         }
[18:04:48.018]                       }
[18:04:48.018]                       invisible(muffled)
[18:04:48.018]                     }
[18:04:48.018]                     muffleCondition(cond, pattern = "^muffle")
[18:04:48.018]                   }
[18:04:48.018]                 }
[18:04:48.018]             }
[18:04:48.018]         }))
[18:04:48.018]     }, error = function(ex) {
[18:04:48.018]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:48.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:48.018]                 ...future.rng), started = ...future.startTime, 
[18:04:48.018]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:48.018]             version = "1.8"), class = "FutureResult")
[18:04:48.018]     }, finally = {
[18:04:48.018]         if (!identical(...future.workdir, getwd())) 
[18:04:48.018]             setwd(...future.workdir)
[18:04:48.018]         {
[18:04:48.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:48.018]                 ...future.oldOptions$nwarnings <- NULL
[18:04:48.018]             }
[18:04:48.018]             base::options(...future.oldOptions)
[18:04:48.018]             if (.Platform$OS.type == "windows") {
[18:04:48.018]                 old_names <- names(...future.oldEnvVars)
[18:04:48.018]                 envs <- base::Sys.getenv()
[18:04:48.018]                 names <- names(envs)
[18:04:48.018]                 common <- intersect(names, old_names)
[18:04:48.018]                 added <- setdiff(names, old_names)
[18:04:48.018]                 removed <- setdiff(old_names, names)
[18:04:48.018]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:48.018]                   envs[common]]
[18:04:48.018]                 NAMES <- toupper(changed)
[18:04:48.018]                 args <- list()
[18:04:48.018]                 for (kk in seq_along(NAMES)) {
[18:04:48.018]                   name <- changed[[kk]]
[18:04:48.018]                   NAME <- NAMES[[kk]]
[18:04:48.018]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.018]                     next
[18:04:48.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:48.018]                 }
[18:04:48.018]                 NAMES <- toupper(added)
[18:04:48.018]                 for (kk in seq_along(NAMES)) {
[18:04:48.018]                   name <- added[[kk]]
[18:04:48.018]                   NAME <- NAMES[[kk]]
[18:04:48.018]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.018]                     next
[18:04:48.018]                   args[[name]] <- ""
[18:04:48.018]                 }
[18:04:48.018]                 NAMES <- toupper(removed)
[18:04:48.018]                 for (kk in seq_along(NAMES)) {
[18:04:48.018]                   name <- removed[[kk]]
[18:04:48.018]                   NAME <- NAMES[[kk]]
[18:04:48.018]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.018]                     next
[18:04:48.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:48.018]                 }
[18:04:48.018]                 if (length(args) > 0) 
[18:04:48.018]                   base::do.call(base::Sys.setenv, args = args)
[18:04:48.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:48.018]             }
[18:04:48.018]             else {
[18:04:48.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:48.018]             }
[18:04:48.018]             {
[18:04:48.018]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:48.018]                   0L) {
[18:04:48.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:48.018]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:48.018]                   base::options(opts)
[18:04:48.018]                 }
[18:04:48.018]                 {
[18:04:48.018]                   {
[18:04:48.018]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:48.018]                     NULL
[18:04:48.018]                   }
[18:04:48.018]                   options(future.plan = NULL)
[18:04:48.018]                   if (is.na(NA_character_)) 
[18:04:48.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:48.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:48.018]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:48.018]                     .init = FALSE)
[18:04:48.018]                 }
[18:04:48.018]             }
[18:04:48.018]         }
[18:04:48.018]     })
[18:04:48.018]     if (TRUE) {
[18:04:48.018]         base::sink(type = "output", split = FALSE)
[18:04:48.018]         if (TRUE) {
[18:04:48.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:48.018]         }
[18:04:48.018]         else {
[18:04:48.018]             ...future.result["stdout"] <- base::list(NULL)
[18:04:48.018]         }
[18:04:48.018]         base::close(...future.stdout)
[18:04:48.018]         ...future.stdout <- NULL
[18:04:48.018]     }
[18:04:48.018]     ...future.result$conditions <- ...future.conditions
[18:04:48.018]     ...future.result$finished <- base::Sys.time()
[18:04:48.018]     ...future.result
[18:04:48.018] }
[18:04:48.023] assign_globals() ...
[18:04:48.023] List of 1
[18:04:48.023]  $ x: list()
[18:04:48.023]  - attr(*, "where")=List of 1
[18:04:48.023]   ..$ x:<environment: R_EmptyEnv> 
[18:04:48.023]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:48.023]  - attr(*, "resolved")= logi TRUE
[18:04:48.023]  - attr(*, "total_size")= num 0
[18:04:48.023]  - attr(*, "already-done")= logi TRUE
[18:04:48.029] - copied ‘x’ to environment
[18:04:48.030] assign_globals() ... done
[18:04:48.030] requestCore(): workers = 2
[18:04:48.034] MulticoreFuture started
[18:04:48.036] - Launch lazy future ... done
[18:04:48.037] run() for ‘MulticoreFuture’ ... done
[18:04:48.039] plan(): Setting new future strategy stack:
[18:04:48.040] result() for MulticoreFuture ...
[18:04:48.039] List of future strategies:
[18:04:48.039] 1. sequential:
[18:04:48.039]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:48.039]    - tweaked: FALSE
[18:04:48.039]    - call: NULL
[18:04:48.043] plan(): nbrOfWorkers() = 1
[18:04:48.047] plan(): Setting new future strategy stack:
[18:04:48.048] List of future strategies:
[18:04:48.048] 1. multicore:
[18:04:48.048]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:48.048]    - tweaked: FALSE
[18:04:48.048]    - call: plan(strategy)
[18:04:48.058] plan(): nbrOfWorkers() = 2
[18:04:48.062] result() for MulticoreFuture ...
[18:04:48.062] result() for MulticoreFuture ... done
[18:04:48.062] result() for MulticoreFuture ... done
[18:04:48.062] result() for MulticoreFuture ...
[18:04:48.063] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:48.065] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:48.065] Searching for globals...
[18:04:48.072] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:48.072] Searching for globals ... DONE
[18:04:48.072] Resolving globals: TRUE
[18:04:48.073] Resolving any globals that are futures ...
[18:04:48.073] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:48.073] Resolving any globals that are futures ... DONE
[18:04:48.074] Resolving futures part of globals (recursively) ...
[18:04:48.075] resolve() on list ...
[18:04:48.075]  recursive: 99
[18:04:48.076]  length: 1
[18:04:48.076]  elements: ‘x’
[18:04:48.076]  length: 0 (resolved future 1)
[18:04:48.076] resolve() on list ... DONE
[18:04:48.077] - globals: [1] ‘x’
[18:04:48.077] Resolving futures part of globals (recursively) ... DONE
[18:04:48.077] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:48.078] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:48.078] - globals: [1] ‘x’
[18:04:48.079] 
[18:04:48.079] getGlobalsAndPackages() ... DONE
[18:04:48.080] run() for ‘Future’ ...
[18:04:48.080] - state: ‘created’
[18:04:48.080] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:48.087] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:48.088] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:48.088]   - Field: ‘label’
[18:04:48.089]   - Field: ‘local’
[18:04:48.089]   - Field: ‘owner’
[18:04:48.089]   - Field: ‘envir’
[18:04:48.089]   - Field: ‘workers’
[18:04:48.090]   - Field: ‘packages’
[18:04:48.090]   - Field: ‘gc’
[18:04:48.090]   - Field: ‘job’
[18:04:48.090]   - Field: ‘conditions’
[18:04:48.091]   - Field: ‘expr’
[18:04:48.091]   - Field: ‘uuid’
[18:04:48.091]   - Field: ‘seed’
[18:04:48.091]   - Field: ‘version’
[18:04:48.091]   - Field: ‘result’
[18:04:48.092]   - Field: ‘asynchronous’
[18:04:48.092]   - Field: ‘calls’
[18:04:48.092]   - Field: ‘globals’
[18:04:48.092]   - Field: ‘stdout’
[18:04:48.093]   - Field: ‘earlySignal’
[18:04:48.093]   - Field: ‘lazy’
[18:04:48.093]   - Field: ‘state’
[18:04:48.093] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:48.094] - Launch lazy future ...
[18:04:48.094] Packages needed by the future expression (n = 0): <none>
[18:04:48.095] Packages needed by future strategies (n = 0): <none>
[18:04:48.096] {
[18:04:48.096]     {
[18:04:48.096]         {
[18:04:48.096]             ...future.startTime <- base::Sys.time()
[18:04:48.096]             {
[18:04:48.096]                 {
[18:04:48.096]                   {
[18:04:48.096]                     {
[18:04:48.096]                       base::local({
[18:04:48.096]                         has_future <- base::requireNamespace("future", 
[18:04:48.096]                           quietly = TRUE)
[18:04:48.096]                         if (has_future) {
[18:04:48.096]                           ns <- base::getNamespace("future")
[18:04:48.096]                           version <- ns[[".package"]][["version"]]
[18:04:48.096]                           if (is.null(version)) 
[18:04:48.096]                             version <- utils::packageVersion("future")
[18:04:48.096]                         }
[18:04:48.096]                         else {
[18:04:48.096]                           version <- NULL
[18:04:48.096]                         }
[18:04:48.096]                         if (!has_future || version < "1.8.0") {
[18:04:48.096]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:48.096]                             "", base::R.version$version.string), 
[18:04:48.096]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:48.096]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:48.096]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:48.096]                               "release", "version")], collapse = " "), 
[18:04:48.096]                             hostname = base::Sys.info()[["nodename"]])
[18:04:48.096]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:48.096]                             info)
[18:04:48.096]                           info <- base::paste(info, collapse = "; ")
[18:04:48.096]                           if (!has_future) {
[18:04:48.096]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:48.096]                               info)
[18:04:48.096]                           }
[18:04:48.096]                           else {
[18:04:48.096]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:48.096]                               info, version)
[18:04:48.096]                           }
[18:04:48.096]                           base::stop(msg)
[18:04:48.096]                         }
[18:04:48.096]                       })
[18:04:48.096]                     }
[18:04:48.096]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:48.096]                     base::options(mc.cores = 1L)
[18:04:48.096]                   }
[18:04:48.096]                   ...future.strategy.old <- future::plan("list")
[18:04:48.096]                   options(future.plan = NULL)
[18:04:48.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:48.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:48.096]                 }
[18:04:48.096]                 ...future.workdir <- getwd()
[18:04:48.096]             }
[18:04:48.096]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:48.096]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:48.096]         }
[18:04:48.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:48.096]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:48.096]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:48.096]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:48.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:48.096]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:48.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:48.096]             base::names(...future.oldOptions))
[18:04:48.096]     }
[18:04:48.096]     if (FALSE) {
[18:04:48.096]     }
[18:04:48.096]     else {
[18:04:48.096]         if (TRUE) {
[18:04:48.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:48.096]                 open = "w")
[18:04:48.096]         }
[18:04:48.096]         else {
[18:04:48.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:48.096]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:48.096]         }
[18:04:48.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:48.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:48.096]             base::sink(type = "output", split = FALSE)
[18:04:48.096]             base::close(...future.stdout)
[18:04:48.096]         }, add = TRUE)
[18:04:48.096]     }
[18:04:48.096]     ...future.frame <- base::sys.nframe()
[18:04:48.096]     ...future.conditions <- base::list()
[18:04:48.096]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:48.096]     if (FALSE) {
[18:04:48.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:48.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:48.096]     }
[18:04:48.096]     ...future.result <- base::tryCatch({
[18:04:48.096]         base::withCallingHandlers({
[18:04:48.096]             ...future.value <- base::withVisible(base::local({
[18:04:48.096]                 withCallingHandlers({
[18:04:48.096]                   {
[18:04:48.096]                     x["a"] <- list(1)
[18:04:48.096]                     x
[18:04:48.096]                   }
[18:04:48.096]                 }, immediateCondition = function(cond) {
[18:04:48.096]                   save_rds <- function (object, pathname, ...) 
[18:04:48.096]                   {
[18:04:48.096]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:48.096]                     if (file_test("-f", pathname_tmp)) {
[18:04:48.096]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.096]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:48.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.096]                         fi_tmp[["mtime"]])
[18:04:48.096]                     }
[18:04:48.096]                     tryCatch({
[18:04:48.096]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:48.096]                     }, error = function(ex) {
[18:04:48.096]                       msg <- conditionMessage(ex)
[18:04:48.096]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.096]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:48.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.096]                         fi_tmp[["mtime"]], msg)
[18:04:48.096]                       ex$message <- msg
[18:04:48.096]                       stop(ex)
[18:04:48.096]                     })
[18:04:48.096]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:48.096]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:48.096]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:48.096]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.096]                       fi <- file.info(pathname)
[18:04:48.096]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:48.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.096]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:48.096]                         fi[["size"]], fi[["mtime"]])
[18:04:48.096]                       stop(msg)
[18:04:48.096]                     }
[18:04:48.096]                     invisible(pathname)
[18:04:48.096]                   }
[18:04:48.096]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:48.096]                     rootPath = tempdir()) 
[18:04:48.096]                   {
[18:04:48.096]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:48.096]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:48.096]                       tmpdir = path, fileext = ".rds")
[18:04:48.096]                     save_rds(obj, file)
[18:04:48.096]                   }
[18:04:48.096]                   saveImmediateCondition(cond, path = "/tmp/RtmpGpkrBm/.future/immediateConditions")
[18:04:48.096]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.096]                   {
[18:04:48.096]                     inherits <- base::inherits
[18:04:48.096]                     invokeRestart <- base::invokeRestart
[18:04:48.096]                     is.null <- base::is.null
[18:04:48.096]                     muffled <- FALSE
[18:04:48.096]                     if (inherits(cond, "message")) {
[18:04:48.096]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:48.096]                       if (muffled) 
[18:04:48.096]                         invokeRestart("muffleMessage")
[18:04:48.096]                     }
[18:04:48.096]                     else if (inherits(cond, "warning")) {
[18:04:48.096]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:48.096]                       if (muffled) 
[18:04:48.096]                         invokeRestart("muffleWarning")
[18:04:48.096]                     }
[18:04:48.096]                     else if (inherits(cond, "condition")) {
[18:04:48.096]                       if (!is.null(pattern)) {
[18:04:48.096]                         computeRestarts <- base::computeRestarts
[18:04:48.096]                         grepl <- base::grepl
[18:04:48.096]                         restarts <- computeRestarts(cond)
[18:04:48.096]                         for (restart in restarts) {
[18:04:48.096]                           name <- restart$name
[18:04:48.096]                           if (is.null(name)) 
[18:04:48.096]                             next
[18:04:48.096]                           if (!grepl(pattern, name)) 
[18:04:48.096]                             next
[18:04:48.096]                           invokeRestart(restart)
[18:04:48.096]                           muffled <- TRUE
[18:04:48.096]                           break
[18:04:48.096]                         }
[18:04:48.096]                       }
[18:04:48.096]                     }
[18:04:48.096]                     invisible(muffled)
[18:04:48.096]                   }
[18:04:48.096]                   muffleCondition(cond)
[18:04:48.096]                 })
[18:04:48.096]             }))
[18:04:48.096]             future::FutureResult(value = ...future.value$value, 
[18:04:48.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:48.096]                   ...future.rng), globalenv = if (FALSE) 
[18:04:48.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:48.096]                     ...future.globalenv.names))
[18:04:48.096]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:48.096]         }, condition = base::local({
[18:04:48.096]             c <- base::c
[18:04:48.096]             inherits <- base::inherits
[18:04:48.096]             invokeRestart <- base::invokeRestart
[18:04:48.096]             length <- base::length
[18:04:48.096]             list <- base::list
[18:04:48.096]             seq.int <- base::seq.int
[18:04:48.096]             signalCondition <- base::signalCondition
[18:04:48.096]             sys.calls <- base::sys.calls
[18:04:48.096]             `[[` <- base::`[[`
[18:04:48.096]             `+` <- base::`+`
[18:04:48.096]             `<<-` <- base::`<<-`
[18:04:48.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:48.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:48.096]                   3L)]
[18:04:48.096]             }
[18:04:48.096]             function(cond) {
[18:04:48.096]                 is_error <- inherits(cond, "error")
[18:04:48.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:48.096]                   NULL)
[18:04:48.096]                 if (is_error) {
[18:04:48.096]                   sessionInformation <- function() {
[18:04:48.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:48.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:48.096]                       search = base::search(), system = base::Sys.info())
[18:04:48.096]                   }
[18:04:48.096]                   ...future.conditions[[length(...future.conditions) + 
[18:04:48.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:48.096]                     cond$call), session = sessionInformation(), 
[18:04:48.096]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:48.096]                   signalCondition(cond)
[18:04:48.096]                 }
[18:04:48.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:48.096]                 "immediateCondition"))) {
[18:04:48.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:48.096]                   ...future.conditions[[length(...future.conditions) + 
[18:04:48.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:48.096]                   if (TRUE && !signal) {
[18:04:48.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.096]                     {
[18:04:48.096]                       inherits <- base::inherits
[18:04:48.096]                       invokeRestart <- base::invokeRestart
[18:04:48.096]                       is.null <- base::is.null
[18:04:48.096]                       muffled <- FALSE
[18:04:48.096]                       if (inherits(cond, "message")) {
[18:04:48.096]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:48.096]                         if (muffled) 
[18:04:48.096]                           invokeRestart("muffleMessage")
[18:04:48.096]                       }
[18:04:48.096]                       else if (inherits(cond, "warning")) {
[18:04:48.096]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:48.096]                         if (muffled) 
[18:04:48.096]                           invokeRestart("muffleWarning")
[18:04:48.096]                       }
[18:04:48.096]                       else if (inherits(cond, "condition")) {
[18:04:48.096]                         if (!is.null(pattern)) {
[18:04:48.096]                           computeRestarts <- base::computeRestarts
[18:04:48.096]                           grepl <- base::grepl
[18:04:48.096]                           restarts <- computeRestarts(cond)
[18:04:48.096]                           for (restart in restarts) {
[18:04:48.096]                             name <- restart$name
[18:04:48.096]                             if (is.null(name)) 
[18:04:48.096]                               next
[18:04:48.096]                             if (!grepl(pattern, name)) 
[18:04:48.096]                               next
[18:04:48.096]                             invokeRestart(restart)
[18:04:48.096]                             muffled <- TRUE
[18:04:48.096]                             break
[18:04:48.096]                           }
[18:04:48.096]                         }
[18:04:48.096]                       }
[18:04:48.096]                       invisible(muffled)
[18:04:48.096]                     }
[18:04:48.096]                     muffleCondition(cond, pattern = "^muffle")
[18:04:48.096]                   }
[18:04:48.096]                 }
[18:04:48.096]                 else {
[18:04:48.096]                   if (TRUE) {
[18:04:48.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.096]                     {
[18:04:48.096]                       inherits <- base::inherits
[18:04:48.096]                       invokeRestart <- base::invokeRestart
[18:04:48.096]                       is.null <- base::is.null
[18:04:48.096]                       muffled <- FALSE
[18:04:48.096]                       if (inherits(cond, "message")) {
[18:04:48.096]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:48.096]                         if (muffled) 
[18:04:48.096]                           invokeRestart("muffleMessage")
[18:04:48.096]                       }
[18:04:48.096]                       else if (inherits(cond, "warning")) {
[18:04:48.096]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:48.096]                         if (muffled) 
[18:04:48.096]                           invokeRestart("muffleWarning")
[18:04:48.096]                       }
[18:04:48.096]                       else if (inherits(cond, "condition")) {
[18:04:48.096]                         if (!is.null(pattern)) {
[18:04:48.096]                           computeRestarts <- base::computeRestarts
[18:04:48.096]                           grepl <- base::grepl
[18:04:48.096]                           restarts <- computeRestarts(cond)
[18:04:48.096]                           for (restart in restarts) {
[18:04:48.096]                             name <- restart$name
[18:04:48.096]                             if (is.null(name)) 
[18:04:48.096]                               next
[18:04:48.096]                             if (!grepl(pattern, name)) 
[18:04:48.096]                               next
[18:04:48.096]                             invokeRestart(restart)
[18:04:48.096]                             muffled <- TRUE
[18:04:48.096]                             break
[18:04:48.096]                           }
[18:04:48.096]                         }
[18:04:48.096]                       }
[18:04:48.096]                       invisible(muffled)
[18:04:48.096]                     }
[18:04:48.096]                     muffleCondition(cond, pattern = "^muffle")
[18:04:48.096]                   }
[18:04:48.096]                 }
[18:04:48.096]             }
[18:04:48.096]         }))
[18:04:48.096]     }, error = function(ex) {
[18:04:48.096]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:48.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:48.096]                 ...future.rng), started = ...future.startTime, 
[18:04:48.096]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:48.096]             version = "1.8"), class = "FutureResult")
[18:04:48.096]     }, finally = {
[18:04:48.096]         if (!identical(...future.workdir, getwd())) 
[18:04:48.096]             setwd(...future.workdir)
[18:04:48.096]         {
[18:04:48.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:48.096]                 ...future.oldOptions$nwarnings <- NULL
[18:04:48.096]             }
[18:04:48.096]             base::options(...future.oldOptions)
[18:04:48.096]             if (.Platform$OS.type == "windows") {
[18:04:48.096]                 old_names <- names(...future.oldEnvVars)
[18:04:48.096]                 envs <- base::Sys.getenv()
[18:04:48.096]                 names <- names(envs)
[18:04:48.096]                 common <- intersect(names, old_names)
[18:04:48.096]                 added <- setdiff(names, old_names)
[18:04:48.096]                 removed <- setdiff(old_names, names)
[18:04:48.096]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:48.096]                   envs[common]]
[18:04:48.096]                 NAMES <- toupper(changed)
[18:04:48.096]                 args <- list()
[18:04:48.096]                 for (kk in seq_along(NAMES)) {
[18:04:48.096]                   name <- changed[[kk]]
[18:04:48.096]                   NAME <- NAMES[[kk]]
[18:04:48.096]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.096]                     next
[18:04:48.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:48.096]                 }
[18:04:48.096]                 NAMES <- toupper(added)
[18:04:48.096]                 for (kk in seq_along(NAMES)) {
[18:04:48.096]                   name <- added[[kk]]
[18:04:48.096]                   NAME <- NAMES[[kk]]
[18:04:48.096]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.096]                     next
[18:04:48.096]                   args[[name]] <- ""
[18:04:48.096]                 }
[18:04:48.096]                 NAMES <- toupper(removed)
[18:04:48.096]                 for (kk in seq_along(NAMES)) {
[18:04:48.096]                   name <- removed[[kk]]
[18:04:48.096]                   NAME <- NAMES[[kk]]
[18:04:48.096]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.096]                     next
[18:04:48.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:48.096]                 }
[18:04:48.096]                 if (length(args) > 0) 
[18:04:48.096]                   base::do.call(base::Sys.setenv, args = args)
[18:04:48.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:48.096]             }
[18:04:48.096]             else {
[18:04:48.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:48.096]             }
[18:04:48.096]             {
[18:04:48.096]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:48.096]                   0L) {
[18:04:48.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:48.096]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:48.096]                   base::options(opts)
[18:04:48.096]                 }
[18:04:48.096]                 {
[18:04:48.096]                   {
[18:04:48.096]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:48.096]                     NULL
[18:04:48.096]                   }
[18:04:48.096]                   options(future.plan = NULL)
[18:04:48.096]                   if (is.na(NA_character_)) 
[18:04:48.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:48.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:48.096]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:48.096]                     .init = FALSE)
[18:04:48.096]                 }
[18:04:48.096]             }
[18:04:48.096]         }
[18:04:48.096]     })
[18:04:48.096]     if (TRUE) {
[18:04:48.096]         base::sink(type = "output", split = FALSE)
[18:04:48.096]         if (TRUE) {
[18:04:48.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:48.096]         }
[18:04:48.096]         else {
[18:04:48.096]             ...future.result["stdout"] <- base::list(NULL)
[18:04:48.096]         }
[18:04:48.096]         base::close(...future.stdout)
[18:04:48.096]         ...future.stdout <- NULL
[18:04:48.096]     }
[18:04:48.096]     ...future.result$conditions <- ...future.conditions
[18:04:48.096]     ...future.result$finished <- base::Sys.time()
[18:04:48.096]     ...future.result
[18:04:48.096] }
[18:04:48.101] assign_globals() ...
[18:04:48.101] List of 1
[18:04:48.101]  $ x: list()
[18:04:48.101]  - attr(*, "where")=List of 1
[18:04:48.101]   ..$ x:<environment: R_EmptyEnv> 
[18:04:48.101]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:48.101]  - attr(*, "resolved")= logi TRUE
[18:04:48.101]  - attr(*, "total_size")= num 0
[18:04:48.101]  - attr(*, "already-done")= logi TRUE
[18:04:48.107] - copied ‘x’ to environment
[18:04:48.107] assign_globals() ... done
[18:04:48.108] requestCore(): workers = 2
[18:04:48.111] MulticoreFuture started
[18:04:48.112] - Launch lazy future ... done
[18:04:48.115] plan(): Setting new future strategy stack:
[18:04:48.112] run() for ‘MulticoreFuture’ ... done
[18:04:48.117] result() for MulticoreFuture ...
[18:04:48.116] List of future strategies:
[18:04:48.116] 1. sequential:
[18:04:48.116]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:48.116]    - tweaked: FALSE
[18:04:48.116]    - call: NULL
[18:04:48.120] plan(): nbrOfWorkers() = 1
[18:04:48.124] plan(): Setting new future strategy stack:
[18:04:48.125] List of future strategies:
[18:04:48.125] 1. multicore:
[18:04:48.125]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:48.125]    - tweaked: FALSE
[18:04:48.125]    - call: plan(strategy)
[18:04:48.134] plan(): nbrOfWorkers() = 2
[18:04:48.139] result() for MulticoreFuture ...
[18:04:48.139] result() for MulticoreFuture ... done
[18:04:48.139] result() for MulticoreFuture ... done
[18:04:48.140] result() for MulticoreFuture ...
[18:04:48.140] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:48.141] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:48.142] Searching for globals...
[18:04:48.153] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:48.153] Searching for globals ... DONE
[18:04:48.153] Resolving globals: TRUE
[18:04:48.154] Resolving any globals that are futures ...
[18:04:48.154] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:48.154] Resolving any globals that are futures ... DONE
[18:04:48.155] Resolving futures part of globals (recursively) ...
[18:04:48.156] resolve() on list ...
[18:04:48.156]  recursive: 99
[18:04:48.157]  length: 1
[18:04:48.157]  elements: ‘x’
[18:04:48.157]  length: 0 (resolved future 1)
[18:04:48.158] resolve() on list ... DONE
[18:04:48.158] - globals: [1] ‘x’
[18:04:48.158] Resolving futures part of globals (recursively) ... DONE
[18:04:48.158] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:48.160] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:48.160] - globals: [1] ‘x’
[18:04:48.160] 
[18:04:48.160] getGlobalsAndPackages() ... DONE
[18:04:48.161] run() for ‘Future’ ...
[18:04:48.161] - state: ‘created’
[18:04:48.162] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:48.169] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:48.169] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:48.169]   - Field: ‘label’
[18:04:48.170]   - Field: ‘local’
[18:04:48.170]   - Field: ‘owner’
[18:04:48.170]   - Field: ‘envir’
[18:04:48.170]   - Field: ‘workers’
[18:04:48.171]   - Field: ‘packages’
[18:04:48.171]   - Field: ‘gc’
[18:04:48.171]   - Field: ‘job’
[18:04:48.171]   - Field: ‘conditions’
[18:04:48.172]   - Field: ‘expr’
[18:04:48.172]   - Field: ‘uuid’
[18:04:48.172]   - Field: ‘seed’
[18:04:48.172]   - Field: ‘version’
[18:04:48.173]   - Field: ‘result’
[18:04:48.173]   - Field: ‘asynchronous’
[18:04:48.173]   - Field: ‘calls’
[18:04:48.173]   - Field: ‘globals’
[18:04:48.174]   - Field: ‘stdout’
[18:04:48.174]   - Field: ‘earlySignal’
[18:04:48.174]   - Field: ‘lazy’
[18:04:48.174]   - Field: ‘state’
[18:04:48.175] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:48.175] - Launch lazy future ...
[18:04:48.176] Packages needed by the future expression (n = 0): <none>
[18:04:48.176] Packages needed by future strategies (n = 0): <none>
[18:04:48.177] {
[18:04:48.177]     {
[18:04:48.177]         {
[18:04:48.177]             ...future.startTime <- base::Sys.time()
[18:04:48.177]             {
[18:04:48.177]                 {
[18:04:48.177]                   {
[18:04:48.177]                     {
[18:04:48.177]                       base::local({
[18:04:48.177]                         has_future <- base::requireNamespace("future", 
[18:04:48.177]                           quietly = TRUE)
[18:04:48.177]                         if (has_future) {
[18:04:48.177]                           ns <- base::getNamespace("future")
[18:04:48.177]                           version <- ns[[".package"]][["version"]]
[18:04:48.177]                           if (is.null(version)) 
[18:04:48.177]                             version <- utils::packageVersion("future")
[18:04:48.177]                         }
[18:04:48.177]                         else {
[18:04:48.177]                           version <- NULL
[18:04:48.177]                         }
[18:04:48.177]                         if (!has_future || version < "1.8.0") {
[18:04:48.177]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:48.177]                             "", base::R.version$version.string), 
[18:04:48.177]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:48.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:48.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:48.177]                               "release", "version")], collapse = " "), 
[18:04:48.177]                             hostname = base::Sys.info()[["nodename"]])
[18:04:48.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:48.177]                             info)
[18:04:48.177]                           info <- base::paste(info, collapse = "; ")
[18:04:48.177]                           if (!has_future) {
[18:04:48.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:48.177]                               info)
[18:04:48.177]                           }
[18:04:48.177]                           else {
[18:04:48.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:48.177]                               info, version)
[18:04:48.177]                           }
[18:04:48.177]                           base::stop(msg)
[18:04:48.177]                         }
[18:04:48.177]                       })
[18:04:48.177]                     }
[18:04:48.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:48.177]                     base::options(mc.cores = 1L)
[18:04:48.177]                   }
[18:04:48.177]                   ...future.strategy.old <- future::plan("list")
[18:04:48.177]                   options(future.plan = NULL)
[18:04:48.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:48.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:48.177]                 }
[18:04:48.177]                 ...future.workdir <- getwd()
[18:04:48.177]             }
[18:04:48.177]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:48.177]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:48.177]         }
[18:04:48.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:48.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:48.177]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:48.177]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:48.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:48.177]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:48.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:48.177]             base::names(...future.oldOptions))
[18:04:48.177]     }
[18:04:48.177]     if (FALSE) {
[18:04:48.177]     }
[18:04:48.177]     else {
[18:04:48.177]         if (TRUE) {
[18:04:48.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:48.177]                 open = "w")
[18:04:48.177]         }
[18:04:48.177]         else {
[18:04:48.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:48.177]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:48.177]         }
[18:04:48.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:48.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:48.177]             base::sink(type = "output", split = FALSE)
[18:04:48.177]             base::close(...future.stdout)
[18:04:48.177]         }, add = TRUE)
[18:04:48.177]     }
[18:04:48.177]     ...future.frame <- base::sys.nframe()
[18:04:48.177]     ...future.conditions <- base::list()
[18:04:48.177]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:48.177]     if (FALSE) {
[18:04:48.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:48.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:48.177]     }
[18:04:48.177]     ...future.result <- base::tryCatch({
[18:04:48.177]         base::withCallingHandlers({
[18:04:48.177]             ...future.value <- base::withVisible(base::local({
[18:04:48.177]                 withCallingHandlers({
[18:04:48.177]                   {
[18:04:48.177]                     x["a"] <- list(1)
[18:04:48.177]                     x
[18:04:48.177]                   }
[18:04:48.177]                 }, immediateCondition = function(cond) {
[18:04:48.177]                   save_rds <- function (object, pathname, ...) 
[18:04:48.177]                   {
[18:04:48.177]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:48.177]                     if (file_test("-f", pathname_tmp)) {
[18:04:48.177]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.177]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:48.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.177]                         fi_tmp[["mtime"]])
[18:04:48.177]                     }
[18:04:48.177]                     tryCatch({
[18:04:48.177]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:48.177]                     }, error = function(ex) {
[18:04:48.177]                       msg <- conditionMessage(ex)
[18:04:48.177]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.177]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:48.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.177]                         fi_tmp[["mtime"]], msg)
[18:04:48.177]                       ex$message <- msg
[18:04:48.177]                       stop(ex)
[18:04:48.177]                     })
[18:04:48.177]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:48.177]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:48.177]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:48.177]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.177]                       fi <- file.info(pathname)
[18:04:48.177]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:48.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.177]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:48.177]                         fi[["size"]], fi[["mtime"]])
[18:04:48.177]                       stop(msg)
[18:04:48.177]                     }
[18:04:48.177]                     invisible(pathname)
[18:04:48.177]                   }
[18:04:48.177]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:48.177]                     rootPath = tempdir()) 
[18:04:48.177]                   {
[18:04:48.177]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:48.177]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:48.177]                       tmpdir = path, fileext = ".rds")
[18:04:48.177]                     save_rds(obj, file)
[18:04:48.177]                   }
[18:04:48.177]                   saveImmediateCondition(cond, path = "/tmp/RtmpGpkrBm/.future/immediateConditions")
[18:04:48.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.177]                   {
[18:04:48.177]                     inherits <- base::inherits
[18:04:48.177]                     invokeRestart <- base::invokeRestart
[18:04:48.177]                     is.null <- base::is.null
[18:04:48.177]                     muffled <- FALSE
[18:04:48.177]                     if (inherits(cond, "message")) {
[18:04:48.177]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:48.177]                       if (muffled) 
[18:04:48.177]                         invokeRestart("muffleMessage")
[18:04:48.177]                     }
[18:04:48.177]                     else if (inherits(cond, "warning")) {
[18:04:48.177]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:48.177]                       if (muffled) 
[18:04:48.177]                         invokeRestart("muffleWarning")
[18:04:48.177]                     }
[18:04:48.177]                     else if (inherits(cond, "condition")) {
[18:04:48.177]                       if (!is.null(pattern)) {
[18:04:48.177]                         computeRestarts <- base::computeRestarts
[18:04:48.177]                         grepl <- base::grepl
[18:04:48.177]                         restarts <- computeRestarts(cond)
[18:04:48.177]                         for (restart in restarts) {
[18:04:48.177]                           name <- restart$name
[18:04:48.177]                           if (is.null(name)) 
[18:04:48.177]                             next
[18:04:48.177]                           if (!grepl(pattern, name)) 
[18:04:48.177]                             next
[18:04:48.177]                           invokeRestart(restart)
[18:04:48.177]                           muffled <- TRUE
[18:04:48.177]                           break
[18:04:48.177]                         }
[18:04:48.177]                       }
[18:04:48.177]                     }
[18:04:48.177]                     invisible(muffled)
[18:04:48.177]                   }
[18:04:48.177]                   muffleCondition(cond)
[18:04:48.177]                 })
[18:04:48.177]             }))
[18:04:48.177]             future::FutureResult(value = ...future.value$value, 
[18:04:48.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:48.177]                   ...future.rng), globalenv = if (FALSE) 
[18:04:48.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:48.177]                     ...future.globalenv.names))
[18:04:48.177]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:48.177]         }, condition = base::local({
[18:04:48.177]             c <- base::c
[18:04:48.177]             inherits <- base::inherits
[18:04:48.177]             invokeRestart <- base::invokeRestart
[18:04:48.177]             length <- base::length
[18:04:48.177]             list <- base::list
[18:04:48.177]             seq.int <- base::seq.int
[18:04:48.177]             signalCondition <- base::signalCondition
[18:04:48.177]             sys.calls <- base::sys.calls
[18:04:48.177]             `[[` <- base::`[[`
[18:04:48.177]             `+` <- base::`+`
[18:04:48.177]             `<<-` <- base::`<<-`
[18:04:48.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:48.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:48.177]                   3L)]
[18:04:48.177]             }
[18:04:48.177]             function(cond) {
[18:04:48.177]                 is_error <- inherits(cond, "error")
[18:04:48.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:48.177]                   NULL)
[18:04:48.177]                 if (is_error) {
[18:04:48.177]                   sessionInformation <- function() {
[18:04:48.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:48.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:48.177]                       search = base::search(), system = base::Sys.info())
[18:04:48.177]                   }
[18:04:48.177]                   ...future.conditions[[length(...future.conditions) + 
[18:04:48.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:48.177]                     cond$call), session = sessionInformation(), 
[18:04:48.177]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:48.177]                   signalCondition(cond)
[18:04:48.177]                 }
[18:04:48.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:48.177]                 "immediateCondition"))) {
[18:04:48.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:48.177]                   ...future.conditions[[length(...future.conditions) + 
[18:04:48.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:48.177]                   if (TRUE && !signal) {
[18:04:48.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.177]                     {
[18:04:48.177]                       inherits <- base::inherits
[18:04:48.177]                       invokeRestart <- base::invokeRestart
[18:04:48.177]                       is.null <- base::is.null
[18:04:48.177]                       muffled <- FALSE
[18:04:48.177]                       if (inherits(cond, "message")) {
[18:04:48.177]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:48.177]                         if (muffled) 
[18:04:48.177]                           invokeRestart("muffleMessage")
[18:04:48.177]                       }
[18:04:48.177]                       else if (inherits(cond, "warning")) {
[18:04:48.177]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:48.177]                         if (muffled) 
[18:04:48.177]                           invokeRestart("muffleWarning")
[18:04:48.177]                       }
[18:04:48.177]                       else if (inherits(cond, "condition")) {
[18:04:48.177]                         if (!is.null(pattern)) {
[18:04:48.177]                           computeRestarts <- base::computeRestarts
[18:04:48.177]                           grepl <- base::grepl
[18:04:48.177]                           restarts <- computeRestarts(cond)
[18:04:48.177]                           for (restart in restarts) {
[18:04:48.177]                             name <- restart$name
[18:04:48.177]                             if (is.null(name)) 
[18:04:48.177]                               next
[18:04:48.177]                             if (!grepl(pattern, name)) 
[18:04:48.177]                               next
[18:04:48.177]                             invokeRestart(restart)
[18:04:48.177]                             muffled <- TRUE
[18:04:48.177]                             break
[18:04:48.177]                           }
[18:04:48.177]                         }
[18:04:48.177]                       }
[18:04:48.177]                       invisible(muffled)
[18:04:48.177]                     }
[18:04:48.177]                     muffleCondition(cond, pattern = "^muffle")
[18:04:48.177]                   }
[18:04:48.177]                 }
[18:04:48.177]                 else {
[18:04:48.177]                   if (TRUE) {
[18:04:48.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.177]                     {
[18:04:48.177]                       inherits <- base::inherits
[18:04:48.177]                       invokeRestart <- base::invokeRestart
[18:04:48.177]                       is.null <- base::is.null
[18:04:48.177]                       muffled <- FALSE
[18:04:48.177]                       if (inherits(cond, "message")) {
[18:04:48.177]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:48.177]                         if (muffled) 
[18:04:48.177]                           invokeRestart("muffleMessage")
[18:04:48.177]                       }
[18:04:48.177]                       else if (inherits(cond, "warning")) {
[18:04:48.177]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:48.177]                         if (muffled) 
[18:04:48.177]                           invokeRestart("muffleWarning")
[18:04:48.177]                       }
[18:04:48.177]                       else if (inherits(cond, "condition")) {
[18:04:48.177]                         if (!is.null(pattern)) {
[18:04:48.177]                           computeRestarts <- base::computeRestarts
[18:04:48.177]                           grepl <- base::grepl
[18:04:48.177]                           restarts <- computeRestarts(cond)
[18:04:48.177]                           for (restart in restarts) {
[18:04:48.177]                             name <- restart$name
[18:04:48.177]                             if (is.null(name)) 
[18:04:48.177]                               next
[18:04:48.177]                             if (!grepl(pattern, name)) 
[18:04:48.177]                               next
[18:04:48.177]                             invokeRestart(restart)
[18:04:48.177]                             muffled <- TRUE
[18:04:48.177]                             break
[18:04:48.177]                           }
[18:04:48.177]                         }
[18:04:48.177]                       }
[18:04:48.177]                       invisible(muffled)
[18:04:48.177]                     }
[18:04:48.177]                     muffleCondition(cond, pattern = "^muffle")
[18:04:48.177]                   }
[18:04:48.177]                 }
[18:04:48.177]             }
[18:04:48.177]         }))
[18:04:48.177]     }, error = function(ex) {
[18:04:48.177]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:48.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:48.177]                 ...future.rng), started = ...future.startTime, 
[18:04:48.177]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:48.177]             version = "1.8"), class = "FutureResult")
[18:04:48.177]     }, finally = {
[18:04:48.177]         if (!identical(...future.workdir, getwd())) 
[18:04:48.177]             setwd(...future.workdir)
[18:04:48.177]         {
[18:04:48.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:48.177]                 ...future.oldOptions$nwarnings <- NULL
[18:04:48.177]             }
[18:04:48.177]             base::options(...future.oldOptions)
[18:04:48.177]             if (.Platform$OS.type == "windows") {
[18:04:48.177]                 old_names <- names(...future.oldEnvVars)
[18:04:48.177]                 envs <- base::Sys.getenv()
[18:04:48.177]                 names <- names(envs)
[18:04:48.177]                 common <- intersect(names, old_names)
[18:04:48.177]                 added <- setdiff(names, old_names)
[18:04:48.177]                 removed <- setdiff(old_names, names)
[18:04:48.177]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:48.177]                   envs[common]]
[18:04:48.177]                 NAMES <- toupper(changed)
[18:04:48.177]                 args <- list()
[18:04:48.177]                 for (kk in seq_along(NAMES)) {
[18:04:48.177]                   name <- changed[[kk]]
[18:04:48.177]                   NAME <- NAMES[[kk]]
[18:04:48.177]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.177]                     next
[18:04:48.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:48.177]                 }
[18:04:48.177]                 NAMES <- toupper(added)
[18:04:48.177]                 for (kk in seq_along(NAMES)) {
[18:04:48.177]                   name <- added[[kk]]
[18:04:48.177]                   NAME <- NAMES[[kk]]
[18:04:48.177]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.177]                     next
[18:04:48.177]                   args[[name]] <- ""
[18:04:48.177]                 }
[18:04:48.177]                 NAMES <- toupper(removed)
[18:04:48.177]                 for (kk in seq_along(NAMES)) {
[18:04:48.177]                   name <- removed[[kk]]
[18:04:48.177]                   NAME <- NAMES[[kk]]
[18:04:48.177]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.177]                     next
[18:04:48.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:48.177]                 }
[18:04:48.177]                 if (length(args) > 0) 
[18:04:48.177]                   base::do.call(base::Sys.setenv, args = args)
[18:04:48.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:48.177]             }
[18:04:48.177]             else {
[18:04:48.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:48.177]             }
[18:04:48.177]             {
[18:04:48.177]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:48.177]                   0L) {
[18:04:48.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:48.177]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:48.177]                   base::options(opts)
[18:04:48.177]                 }
[18:04:48.177]                 {
[18:04:48.177]                   {
[18:04:48.177]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:48.177]                     NULL
[18:04:48.177]                   }
[18:04:48.177]                   options(future.plan = NULL)
[18:04:48.177]                   if (is.na(NA_character_)) 
[18:04:48.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:48.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:48.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:48.177]                     .init = FALSE)
[18:04:48.177]                 }
[18:04:48.177]             }
[18:04:48.177]         }
[18:04:48.177]     })
[18:04:48.177]     if (TRUE) {
[18:04:48.177]         base::sink(type = "output", split = FALSE)
[18:04:48.177]         if (TRUE) {
[18:04:48.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:48.177]         }
[18:04:48.177]         else {
[18:04:48.177]             ...future.result["stdout"] <- base::list(NULL)
[18:04:48.177]         }
[18:04:48.177]         base::close(...future.stdout)
[18:04:48.177]         ...future.stdout <- NULL
[18:04:48.177]     }
[18:04:48.177]     ...future.result$conditions <- ...future.conditions
[18:04:48.177]     ...future.result$finished <- base::Sys.time()
[18:04:48.177]     ...future.result
[18:04:48.177] }
[18:04:48.182] assign_globals() ...
[18:04:48.182] List of 1
[18:04:48.182]  $ x: list()
[18:04:48.182]  - attr(*, "where")=List of 1
[18:04:48.182]   ..$ x:<environment: R_EmptyEnv> 
[18:04:48.182]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:48.182]  - attr(*, "resolved")= logi TRUE
[18:04:48.182]  - attr(*, "total_size")= num 0
[18:04:48.182]  - attr(*, "already-done")= logi TRUE
[18:04:48.188] - copied ‘x’ to environment
[18:04:48.188] assign_globals() ... done
[18:04:48.189] requestCore(): workers = 2
[18:04:48.192] MulticoreFuture started
[18:04:48.193] - Launch lazy future ... done
[18:04:48.196] plan(): Setting new future strategy stack:
[18:04:48.193] run() for ‘MulticoreFuture’ ... done
[18:04:48.198] result() for MulticoreFuture ...
[18:04:48.197] List of future strategies:
[18:04:48.197] 1. sequential:
[18:04:48.197]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:48.197]    - tweaked: FALSE
[18:04:48.197]    - call: NULL
[18:04:48.201] plan(): nbrOfWorkers() = 1
[18:04:48.205] plan(): Setting new future strategy stack:
[18:04:48.206] List of future strategies:
[18:04:48.206] 1. multicore:
[18:04:48.206]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:48.206]    - tweaked: FALSE
[18:04:48.206]    - call: plan(strategy)
[18:04:48.216] plan(): nbrOfWorkers() = 2
[18:04:48.219] result() for MulticoreFuture ...
[18:04:48.220] result() for MulticoreFuture ... done
[18:04:48.220] result() for MulticoreFuture ... done
[18:04:48.220] result() for MulticoreFuture ...
[18:04:48.221] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:48.224] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:48.225] Searching for globals...
[18:04:48.231] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:48.231] Searching for globals ... DONE
[18:04:48.232] Resolving globals: TRUE
[18:04:48.232] Resolving any globals that are futures ...
[18:04:48.232] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:48.232] Resolving any globals that are futures ... DONE
[18:04:48.233] Resolving futures part of globals (recursively) ...
[18:04:48.234] resolve() on list ...
[18:04:48.234]  recursive: 99
[18:04:48.235]  length: 1
[18:04:48.235]  elements: ‘x’
[18:04:48.235]  length: 0 (resolved future 1)
[18:04:48.236] resolve() on list ... DONE
[18:04:48.236] - globals: [1] ‘x’
[18:04:48.236] Resolving futures part of globals (recursively) ... DONE
[18:04:48.236] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:48.237] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:48.238] - globals: [1] ‘x’
[18:04:48.238] 
[18:04:48.238] getGlobalsAndPackages() ... DONE
[18:04:48.239] run() for ‘Future’ ...
[18:04:48.239] - state: ‘created’
[18:04:48.240] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:48.247] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:48.247] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:48.248]   - Field: ‘label’
[18:04:48.248]   - Field: ‘local’
[18:04:48.248]   - Field: ‘owner’
[18:04:48.248]   - Field: ‘envir’
[18:04:48.249]   - Field: ‘workers’
[18:04:48.249]   - Field: ‘packages’
[18:04:48.249]   - Field: ‘gc’
[18:04:48.249]   - Field: ‘job’
[18:04:48.250]   - Field: ‘conditions’
[18:04:48.250]   - Field: ‘expr’
[18:04:48.250]   - Field: ‘uuid’
[18:04:48.250]   - Field: ‘seed’
[18:04:48.251]   - Field: ‘version’
[18:04:48.251]   - Field: ‘result’
[18:04:48.251]   - Field: ‘asynchronous’
[18:04:48.251]   - Field: ‘calls’
[18:04:48.252]   - Field: ‘globals’
[18:04:48.252]   - Field: ‘stdout’
[18:04:48.252]   - Field: ‘earlySignal’
[18:04:48.252]   - Field: ‘lazy’
[18:04:48.252]   - Field: ‘state’
[18:04:48.253] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:48.253] - Launch lazy future ...
[18:04:48.254] Packages needed by the future expression (n = 0): <none>
[18:04:48.254] Packages needed by future strategies (n = 0): <none>
[18:04:48.255] {
[18:04:48.255]     {
[18:04:48.255]         {
[18:04:48.255]             ...future.startTime <- base::Sys.time()
[18:04:48.255]             {
[18:04:48.255]                 {
[18:04:48.255]                   {
[18:04:48.255]                     {
[18:04:48.255]                       base::local({
[18:04:48.255]                         has_future <- base::requireNamespace("future", 
[18:04:48.255]                           quietly = TRUE)
[18:04:48.255]                         if (has_future) {
[18:04:48.255]                           ns <- base::getNamespace("future")
[18:04:48.255]                           version <- ns[[".package"]][["version"]]
[18:04:48.255]                           if (is.null(version)) 
[18:04:48.255]                             version <- utils::packageVersion("future")
[18:04:48.255]                         }
[18:04:48.255]                         else {
[18:04:48.255]                           version <- NULL
[18:04:48.255]                         }
[18:04:48.255]                         if (!has_future || version < "1.8.0") {
[18:04:48.255]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:48.255]                             "", base::R.version$version.string), 
[18:04:48.255]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:48.255]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:48.255]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:48.255]                               "release", "version")], collapse = " "), 
[18:04:48.255]                             hostname = base::Sys.info()[["nodename"]])
[18:04:48.255]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:48.255]                             info)
[18:04:48.255]                           info <- base::paste(info, collapse = "; ")
[18:04:48.255]                           if (!has_future) {
[18:04:48.255]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:48.255]                               info)
[18:04:48.255]                           }
[18:04:48.255]                           else {
[18:04:48.255]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:48.255]                               info, version)
[18:04:48.255]                           }
[18:04:48.255]                           base::stop(msg)
[18:04:48.255]                         }
[18:04:48.255]                       })
[18:04:48.255]                     }
[18:04:48.255]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:48.255]                     base::options(mc.cores = 1L)
[18:04:48.255]                   }
[18:04:48.255]                   ...future.strategy.old <- future::plan("list")
[18:04:48.255]                   options(future.plan = NULL)
[18:04:48.255]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:48.255]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:48.255]                 }
[18:04:48.255]                 ...future.workdir <- getwd()
[18:04:48.255]             }
[18:04:48.255]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:48.255]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:48.255]         }
[18:04:48.255]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:48.255]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:48.255]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:48.255]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:48.255]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:48.255]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:48.255]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:48.255]             base::names(...future.oldOptions))
[18:04:48.255]     }
[18:04:48.255]     if (FALSE) {
[18:04:48.255]     }
[18:04:48.255]     else {
[18:04:48.255]         if (TRUE) {
[18:04:48.255]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:48.255]                 open = "w")
[18:04:48.255]         }
[18:04:48.255]         else {
[18:04:48.255]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:48.255]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:48.255]         }
[18:04:48.255]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:48.255]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:48.255]             base::sink(type = "output", split = FALSE)
[18:04:48.255]             base::close(...future.stdout)
[18:04:48.255]         }, add = TRUE)
[18:04:48.255]     }
[18:04:48.255]     ...future.frame <- base::sys.nframe()
[18:04:48.255]     ...future.conditions <- base::list()
[18:04:48.255]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:48.255]     if (FALSE) {
[18:04:48.255]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:48.255]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:48.255]     }
[18:04:48.255]     ...future.result <- base::tryCatch({
[18:04:48.255]         base::withCallingHandlers({
[18:04:48.255]             ...future.value <- base::withVisible(base::local({
[18:04:48.255]                 withCallingHandlers({
[18:04:48.255]                   {
[18:04:48.255]                     x["a"] <- list(1)
[18:04:48.255]                     x
[18:04:48.255]                   }
[18:04:48.255]                 }, immediateCondition = function(cond) {
[18:04:48.255]                   save_rds <- function (object, pathname, ...) 
[18:04:48.255]                   {
[18:04:48.255]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:48.255]                     if (file_test("-f", pathname_tmp)) {
[18:04:48.255]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.255]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:48.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.255]                         fi_tmp[["mtime"]])
[18:04:48.255]                     }
[18:04:48.255]                     tryCatch({
[18:04:48.255]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:48.255]                     }, error = function(ex) {
[18:04:48.255]                       msg <- conditionMessage(ex)
[18:04:48.255]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.255]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:48.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.255]                         fi_tmp[["mtime"]], msg)
[18:04:48.255]                       ex$message <- msg
[18:04:48.255]                       stop(ex)
[18:04:48.255]                     })
[18:04:48.255]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:48.255]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:48.255]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:48.255]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.255]                       fi <- file.info(pathname)
[18:04:48.255]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:48.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.255]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:48.255]                         fi[["size"]], fi[["mtime"]])
[18:04:48.255]                       stop(msg)
[18:04:48.255]                     }
[18:04:48.255]                     invisible(pathname)
[18:04:48.255]                   }
[18:04:48.255]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:48.255]                     rootPath = tempdir()) 
[18:04:48.255]                   {
[18:04:48.255]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:48.255]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:48.255]                       tmpdir = path, fileext = ".rds")
[18:04:48.255]                     save_rds(obj, file)
[18:04:48.255]                   }
[18:04:48.255]                   saveImmediateCondition(cond, path = "/tmp/RtmpGpkrBm/.future/immediateConditions")
[18:04:48.255]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.255]                   {
[18:04:48.255]                     inherits <- base::inherits
[18:04:48.255]                     invokeRestart <- base::invokeRestart
[18:04:48.255]                     is.null <- base::is.null
[18:04:48.255]                     muffled <- FALSE
[18:04:48.255]                     if (inherits(cond, "message")) {
[18:04:48.255]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:48.255]                       if (muffled) 
[18:04:48.255]                         invokeRestart("muffleMessage")
[18:04:48.255]                     }
[18:04:48.255]                     else if (inherits(cond, "warning")) {
[18:04:48.255]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:48.255]                       if (muffled) 
[18:04:48.255]                         invokeRestart("muffleWarning")
[18:04:48.255]                     }
[18:04:48.255]                     else if (inherits(cond, "condition")) {
[18:04:48.255]                       if (!is.null(pattern)) {
[18:04:48.255]                         computeRestarts <- base::computeRestarts
[18:04:48.255]                         grepl <- base::grepl
[18:04:48.255]                         restarts <- computeRestarts(cond)
[18:04:48.255]                         for (restart in restarts) {
[18:04:48.255]                           name <- restart$name
[18:04:48.255]                           if (is.null(name)) 
[18:04:48.255]                             next
[18:04:48.255]                           if (!grepl(pattern, name)) 
[18:04:48.255]                             next
[18:04:48.255]                           invokeRestart(restart)
[18:04:48.255]                           muffled <- TRUE
[18:04:48.255]                           break
[18:04:48.255]                         }
[18:04:48.255]                       }
[18:04:48.255]                     }
[18:04:48.255]                     invisible(muffled)
[18:04:48.255]                   }
[18:04:48.255]                   muffleCondition(cond)
[18:04:48.255]                 })
[18:04:48.255]             }))
[18:04:48.255]             future::FutureResult(value = ...future.value$value, 
[18:04:48.255]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:48.255]                   ...future.rng), globalenv = if (FALSE) 
[18:04:48.255]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:48.255]                     ...future.globalenv.names))
[18:04:48.255]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:48.255]         }, condition = base::local({
[18:04:48.255]             c <- base::c
[18:04:48.255]             inherits <- base::inherits
[18:04:48.255]             invokeRestart <- base::invokeRestart
[18:04:48.255]             length <- base::length
[18:04:48.255]             list <- base::list
[18:04:48.255]             seq.int <- base::seq.int
[18:04:48.255]             signalCondition <- base::signalCondition
[18:04:48.255]             sys.calls <- base::sys.calls
[18:04:48.255]             `[[` <- base::`[[`
[18:04:48.255]             `+` <- base::`+`
[18:04:48.255]             `<<-` <- base::`<<-`
[18:04:48.255]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:48.255]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:48.255]                   3L)]
[18:04:48.255]             }
[18:04:48.255]             function(cond) {
[18:04:48.255]                 is_error <- inherits(cond, "error")
[18:04:48.255]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:48.255]                   NULL)
[18:04:48.255]                 if (is_error) {
[18:04:48.255]                   sessionInformation <- function() {
[18:04:48.255]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:48.255]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:48.255]                       search = base::search(), system = base::Sys.info())
[18:04:48.255]                   }
[18:04:48.255]                   ...future.conditions[[length(...future.conditions) + 
[18:04:48.255]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:48.255]                     cond$call), session = sessionInformation(), 
[18:04:48.255]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:48.255]                   signalCondition(cond)
[18:04:48.255]                 }
[18:04:48.255]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:48.255]                 "immediateCondition"))) {
[18:04:48.255]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:48.255]                   ...future.conditions[[length(...future.conditions) + 
[18:04:48.255]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:48.255]                   if (TRUE && !signal) {
[18:04:48.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.255]                     {
[18:04:48.255]                       inherits <- base::inherits
[18:04:48.255]                       invokeRestart <- base::invokeRestart
[18:04:48.255]                       is.null <- base::is.null
[18:04:48.255]                       muffled <- FALSE
[18:04:48.255]                       if (inherits(cond, "message")) {
[18:04:48.255]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:48.255]                         if (muffled) 
[18:04:48.255]                           invokeRestart("muffleMessage")
[18:04:48.255]                       }
[18:04:48.255]                       else if (inherits(cond, "warning")) {
[18:04:48.255]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:48.255]                         if (muffled) 
[18:04:48.255]                           invokeRestart("muffleWarning")
[18:04:48.255]                       }
[18:04:48.255]                       else if (inherits(cond, "condition")) {
[18:04:48.255]                         if (!is.null(pattern)) {
[18:04:48.255]                           computeRestarts <- base::computeRestarts
[18:04:48.255]                           grepl <- base::grepl
[18:04:48.255]                           restarts <- computeRestarts(cond)
[18:04:48.255]                           for (restart in restarts) {
[18:04:48.255]                             name <- restart$name
[18:04:48.255]                             if (is.null(name)) 
[18:04:48.255]                               next
[18:04:48.255]                             if (!grepl(pattern, name)) 
[18:04:48.255]                               next
[18:04:48.255]                             invokeRestart(restart)
[18:04:48.255]                             muffled <- TRUE
[18:04:48.255]                             break
[18:04:48.255]                           }
[18:04:48.255]                         }
[18:04:48.255]                       }
[18:04:48.255]                       invisible(muffled)
[18:04:48.255]                     }
[18:04:48.255]                     muffleCondition(cond, pattern = "^muffle")
[18:04:48.255]                   }
[18:04:48.255]                 }
[18:04:48.255]                 else {
[18:04:48.255]                   if (TRUE) {
[18:04:48.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.255]                     {
[18:04:48.255]                       inherits <- base::inherits
[18:04:48.255]                       invokeRestart <- base::invokeRestart
[18:04:48.255]                       is.null <- base::is.null
[18:04:48.255]                       muffled <- FALSE
[18:04:48.255]                       if (inherits(cond, "message")) {
[18:04:48.255]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:48.255]                         if (muffled) 
[18:04:48.255]                           invokeRestart("muffleMessage")
[18:04:48.255]                       }
[18:04:48.255]                       else if (inherits(cond, "warning")) {
[18:04:48.255]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:48.255]                         if (muffled) 
[18:04:48.255]                           invokeRestart("muffleWarning")
[18:04:48.255]                       }
[18:04:48.255]                       else if (inherits(cond, "condition")) {
[18:04:48.255]                         if (!is.null(pattern)) {
[18:04:48.255]                           computeRestarts <- base::computeRestarts
[18:04:48.255]                           grepl <- base::grepl
[18:04:48.255]                           restarts <- computeRestarts(cond)
[18:04:48.255]                           for (restart in restarts) {
[18:04:48.255]                             name <- restart$name
[18:04:48.255]                             if (is.null(name)) 
[18:04:48.255]                               next
[18:04:48.255]                             if (!grepl(pattern, name)) 
[18:04:48.255]                               next
[18:04:48.255]                             invokeRestart(restart)
[18:04:48.255]                             muffled <- TRUE
[18:04:48.255]                             break
[18:04:48.255]                           }
[18:04:48.255]                         }
[18:04:48.255]                       }
[18:04:48.255]                       invisible(muffled)
[18:04:48.255]                     }
[18:04:48.255]                     muffleCondition(cond, pattern = "^muffle")
[18:04:48.255]                   }
[18:04:48.255]                 }
[18:04:48.255]             }
[18:04:48.255]         }))
[18:04:48.255]     }, error = function(ex) {
[18:04:48.255]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:48.255]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:48.255]                 ...future.rng), started = ...future.startTime, 
[18:04:48.255]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:48.255]             version = "1.8"), class = "FutureResult")
[18:04:48.255]     }, finally = {
[18:04:48.255]         if (!identical(...future.workdir, getwd())) 
[18:04:48.255]             setwd(...future.workdir)
[18:04:48.255]         {
[18:04:48.255]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:48.255]                 ...future.oldOptions$nwarnings <- NULL
[18:04:48.255]             }
[18:04:48.255]             base::options(...future.oldOptions)
[18:04:48.255]             if (.Platform$OS.type == "windows") {
[18:04:48.255]                 old_names <- names(...future.oldEnvVars)
[18:04:48.255]                 envs <- base::Sys.getenv()
[18:04:48.255]                 names <- names(envs)
[18:04:48.255]                 common <- intersect(names, old_names)
[18:04:48.255]                 added <- setdiff(names, old_names)
[18:04:48.255]                 removed <- setdiff(old_names, names)
[18:04:48.255]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:48.255]                   envs[common]]
[18:04:48.255]                 NAMES <- toupper(changed)
[18:04:48.255]                 args <- list()
[18:04:48.255]                 for (kk in seq_along(NAMES)) {
[18:04:48.255]                   name <- changed[[kk]]
[18:04:48.255]                   NAME <- NAMES[[kk]]
[18:04:48.255]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.255]                     next
[18:04:48.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:48.255]                 }
[18:04:48.255]                 NAMES <- toupper(added)
[18:04:48.255]                 for (kk in seq_along(NAMES)) {
[18:04:48.255]                   name <- added[[kk]]
[18:04:48.255]                   NAME <- NAMES[[kk]]
[18:04:48.255]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.255]                     next
[18:04:48.255]                   args[[name]] <- ""
[18:04:48.255]                 }
[18:04:48.255]                 NAMES <- toupper(removed)
[18:04:48.255]                 for (kk in seq_along(NAMES)) {
[18:04:48.255]                   name <- removed[[kk]]
[18:04:48.255]                   NAME <- NAMES[[kk]]
[18:04:48.255]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.255]                     next
[18:04:48.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:48.255]                 }
[18:04:48.255]                 if (length(args) > 0) 
[18:04:48.255]                   base::do.call(base::Sys.setenv, args = args)
[18:04:48.255]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:48.255]             }
[18:04:48.255]             else {
[18:04:48.255]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:48.255]             }
[18:04:48.255]             {
[18:04:48.255]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:48.255]                   0L) {
[18:04:48.255]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:48.255]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:48.255]                   base::options(opts)
[18:04:48.255]                 }
[18:04:48.255]                 {
[18:04:48.255]                   {
[18:04:48.255]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:48.255]                     NULL
[18:04:48.255]                   }
[18:04:48.255]                   options(future.plan = NULL)
[18:04:48.255]                   if (is.na(NA_character_)) 
[18:04:48.255]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:48.255]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:48.255]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:48.255]                     .init = FALSE)
[18:04:48.255]                 }
[18:04:48.255]             }
[18:04:48.255]         }
[18:04:48.255]     })
[18:04:48.255]     if (TRUE) {
[18:04:48.255]         base::sink(type = "output", split = FALSE)
[18:04:48.255]         if (TRUE) {
[18:04:48.255]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:48.255]         }
[18:04:48.255]         else {
[18:04:48.255]             ...future.result["stdout"] <- base::list(NULL)
[18:04:48.255]         }
[18:04:48.255]         base::close(...future.stdout)
[18:04:48.255]         ...future.stdout <- NULL
[18:04:48.255]     }
[18:04:48.255]     ...future.result$conditions <- ...future.conditions
[18:04:48.255]     ...future.result$finished <- base::Sys.time()
[18:04:48.255]     ...future.result
[18:04:48.255] }
[18:04:48.260] assign_globals() ...
[18:04:48.260] List of 1
[18:04:48.260]  $ x: list()
[18:04:48.260]  - attr(*, "where")=List of 1
[18:04:48.260]   ..$ x:<environment: R_EmptyEnv> 
[18:04:48.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:48.260]  - attr(*, "resolved")= logi TRUE
[18:04:48.260]  - attr(*, "total_size")= num 0
[18:04:48.260]  - attr(*, "already-done")= logi TRUE
[18:04:48.270] - copied ‘x’ to environment
[18:04:48.270] assign_globals() ... done
[18:04:48.271] requestCore(): workers = 2
[18:04:48.274] MulticoreFuture started
[18:04:48.275] - Launch lazy future ... done
[18:04:48.275] run() for ‘MulticoreFuture’ ... done
[18:04:48.276] plan(): Setting new future strategy stack:
[18:04:48.276] result() for MulticoreFuture ...
[18:04:48.277] List of future strategies:
[18:04:48.277] 1. sequential:
[18:04:48.277]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:48.277]    - tweaked: FALSE
[18:04:48.277]    - call: NULL
[18:04:48.279] plan(): nbrOfWorkers() = 1
[18:04:48.283] plan(): Setting new future strategy stack:
[18:04:48.283] List of future strategies:
[18:04:48.283] 1. multicore:
[18:04:48.283]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:48.283]    - tweaked: FALSE
[18:04:48.283]    - call: plan(strategy)
[18:04:48.293] plan(): nbrOfWorkers() = 2
[18:04:48.297] result() for MulticoreFuture ...
[18:04:48.298] result() for MulticoreFuture ... done
[18:04:48.298] result() for MulticoreFuture ... done
[18:04:48.298] result() for MulticoreFuture ...
[18:04:48.299] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:48.301] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:48.302] Searching for globals...
[18:04:48.308] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[18:04:48.308] Searching for globals ... DONE
[18:04:48.308] Resolving globals: TRUE
[18:04:48.309] Resolving any globals that are futures ...
[18:04:48.309] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[18:04:48.309] Resolving any globals that are futures ... DONE
[18:04:48.310] Resolving futures part of globals (recursively) ...
[18:04:48.311] resolve() on list ...
[18:04:48.311]  recursive: 99
[18:04:48.312]  length: 2
[18:04:48.312]  elements: ‘x’, ‘name’
[18:04:48.312]  length: 1 (resolved future 1)
[18:04:48.312]  length: 0 (resolved future 2)
[18:04:48.313] resolve() on list ... DONE
[18:04:48.313] - globals: [2] ‘x’, ‘name’
[18:04:48.313] Resolving futures part of globals (recursively) ... DONE
[18:04:48.314] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:48.315] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[18:04:48.315] - globals: [2] ‘x’, ‘name’
[18:04:48.315] 
[18:04:48.316] getGlobalsAndPackages() ... DONE
[18:04:48.316] run() for ‘Future’ ...
[18:04:48.317] - state: ‘created’
[18:04:48.317] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:48.324] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:48.324] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:48.324]   - Field: ‘label’
[18:04:48.325]   - Field: ‘local’
[18:04:48.325]   - Field: ‘owner’
[18:04:48.325]   - Field: ‘envir’
[18:04:48.325]   - Field: ‘workers’
[18:04:48.326]   - Field: ‘packages’
[18:04:48.326]   - Field: ‘gc’
[18:04:48.326]   - Field: ‘job’
[18:04:48.326]   - Field: ‘conditions’
[18:04:48.327]   - Field: ‘expr’
[18:04:48.327]   - Field: ‘uuid’
[18:04:48.327]   - Field: ‘seed’
[18:04:48.327]   - Field: ‘version’
[18:04:48.327]   - Field: ‘result’
[18:04:48.328]   - Field: ‘asynchronous’
[18:04:48.328]   - Field: ‘calls’
[18:04:48.328]   - Field: ‘globals’
[18:04:48.328]   - Field: ‘stdout’
[18:04:48.329]   - Field: ‘earlySignal’
[18:04:48.329]   - Field: ‘lazy’
[18:04:48.329]   - Field: ‘state’
[18:04:48.329] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:48.330] - Launch lazy future ...
[18:04:48.330] Packages needed by the future expression (n = 0): <none>
[18:04:48.331] Packages needed by future strategies (n = 0): <none>
[18:04:48.332] {
[18:04:48.332]     {
[18:04:48.332]         {
[18:04:48.332]             ...future.startTime <- base::Sys.time()
[18:04:48.332]             {
[18:04:48.332]                 {
[18:04:48.332]                   {
[18:04:48.332]                     {
[18:04:48.332]                       base::local({
[18:04:48.332]                         has_future <- base::requireNamespace("future", 
[18:04:48.332]                           quietly = TRUE)
[18:04:48.332]                         if (has_future) {
[18:04:48.332]                           ns <- base::getNamespace("future")
[18:04:48.332]                           version <- ns[[".package"]][["version"]]
[18:04:48.332]                           if (is.null(version)) 
[18:04:48.332]                             version <- utils::packageVersion("future")
[18:04:48.332]                         }
[18:04:48.332]                         else {
[18:04:48.332]                           version <- NULL
[18:04:48.332]                         }
[18:04:48.332]                         if (!has_future || version < "1.8.0") {
[18:04:48.332]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:48.332]                             "", base::R.version$version.string), 
[18:04:48.332]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:48.332]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:48.332]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:48.332]                               "release", "version")], collapse = " "), 
[18:04:48.332]                             hostname = base::Sys.info()[["nodename"]])
[18:04:48.332]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:48.332]                             info)
[18:04:48.332]                           info <- base::paste(info, collapse = "; ")
[18:04:48.332]                           if (!has_future) {
[18:04:48.332]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:48.332]                               info)
[18:04:48.332]                           }
[18:04:48.332]                           else {
[18:04:48.332]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:48.332]                               info, version)
[18:04:48.332]                           }
[18:04:48.332]                           base::stop(msg)
[18:04:48.332]                         }
[18:04:48.332]                       })
[18:04:48.332]                     }
[18:04:48.332]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:48.332]                     base::options(mc.cores = 1L)
[18:04:48.332]                   }
[18:04:48.332]                   ...future.strategy.old <- future::plan("list")
[18:04:48.332]                   options(future.plan = NULL)
[18:04:48.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:48.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:48.332]                 }
[18:04:48.332]                 ...future.workdir <- getwd()
[18:04:48.332]             }
[18:04:48.332]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:48.332]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:48.332]         }
[18:04:48.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:48.332]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:48.332]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:48.332]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:48.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:48.332]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:48.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:48.332]             base::names(...future.oldOptions))
[18:04:48.332]     }
[18:04:48.332]     if (FALSE) {
[18:04:48.332]     }
[18:04:48.332]     else {
[18:04:48.332]         if (TRUE) {
[18:04:48.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:48.332]                 open = "w")
[18:04:48.332]         }
[18:04:48.332]         else {
[18:04:48.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:48.332]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:48.332]         }
[18:04:48.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:48.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:48.332]             base::sink(type = "output", split = FALSE)
[18:04:48.332]             base::close(...future.stdout)
[18:04:48.332]         }, add = TRUE)
[18:04:48.332]     }
[18:04:48.332]     ...future.frame <- base::sys.nframe()
[18:04:48.332]     ...future.conditions <- base::list()
[18:04:48.332]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:48.332]     if (FALSE) {
[18:04:48.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:48.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:48.332]     }
[18:04:48.332]     ...future.result <- base::tryCatch({
[18:04:48.332]         base::withCallingHandlers({
[18:04:48.332]             ...future.value <- base::withVisible(base::local({
[18:04:48.332]                 withCallingHandlers({
[18:04:48.332]                   {
[18:04:48.332]                     x[name] <- list(1)
[18:04:48.332]                     x
[18:04:48.332]                   }
[18:04:48.332]                 }, immediateCondition = function(cond) {
[18:04:48.332]                   save_rds <- function (object, pathname, ...) 
[18:04:48.332]                   {
[18:04:48.332]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:48.332]                     if (file_test("-f", pathname_tmp)) {
[18:04:48.332]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.332]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:48.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.332]                         fi_tmp[["mtime"]])
[18:04:48.332]                     }
[18:04:48.332]                     tryCatch({
[18:04:48.332]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:48.332]                     }, error = function(ex) {
[18:04:48.332]                       msg <- conditionMessage(ex)
[18:04:48.332]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.332]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:48.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.332]                         fi_tmp[["mtime"]], msg)
[18:04:48.332]                       ex$message <- msg
[18:04:48.332]                       stop(ex)
[18:04:48.332]                     })
[18:04:48.332]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:48.332]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:48.332]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:48.332]                       fi_tmp <- file.info(pathname_tmp)
[18:04:48.332]                       fi <- file.info(pathname)
[18:04:48.332]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:48.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:48.332]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:48.332]                         fi[["size"]], fi[["mtime"]])
[18:04:48.332]                       stop(msg)
[18:04:48.332]                     }
[18:04:48.332]                     invisible(pathname)
[18:04:48.332]                   }
[18:04:48.332]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:48.332]                     rootPath = tempdir()) 
[18:04:48.332]                   {
[18:04:48.332]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:48.332]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:48.332]                       tmpdir = path, fileext = ".rds")
[18:04:48.332]                     save_rds(obj, file)
[18:04:48.332]                   }
[18:04:48.332]                   saveImmediateCondition(cond, path = "/tmp/RtmpGpkrBm/.future/immediateConditions")
[18:04:48.332]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.332]                   {
[18:04:48.332]                     inherits <- base::inherits
[18:04:48.332]                     invokeRestart <- base::invokeRestart
[18:04:48.332]                     is.null <- base::is.null
[18:04:48.332]                     muffled <- FALSE
[18:04:48.332]                     if (inherits(cond, "message")) {
[18:04:48.332]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:48.332]                       if (muffled) 
[18:04:48.332]                         invokeRestart("muffleMessage")
[18:04:48.332]                     }
[18:04:48.332]                     else if (inherits(cond, "warning")) {
[18:04:48.332]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:48.332]                       if (muffled) 
[18:04:48.332]                         invokeRestart("muffleWarning")
[18:04:48.332]                     }
[18:04:48.332]                     else if (inherits(cond, "condition")) {
[18:04:48.332]                       if (!is.null(pattern)) {
[18:04:48.332]                         computeRestarts <- base::computeRestarts
[18:04:48.332]                         grepl <- base::grepl
[18:04:48.332]                         restarts <- computeRestarts(cond)
[18:04:48.332]                         for (restart in restarts) {
[18:04:48.332]                           name <- restart$name
[18:04:48.332]                           if (is.null(name)) 
[18:04:48.332]                             next
[18:04:48.332]                           if (!grepl(pattern, name)) 
[18:04:48.332]                             next
[18:04:48.332]                           invokeRestart(restart)
[18:04:48.332]                           muffled <- TRUE
[18:04:48.332]                           break
[18:04:48.332]                         }
[18:04:48.332]                       }
[18:04:48.332]                     }
[18:04:48.332]                     invisible(muffled)
[18:04:48.332]                   }
[18:04:48.332]                   muffleCondition(cond)
[18:04:48.332]                 })
[18:04:48.332]             }))
[18:04:48.332]             future::FutureResult(value = ...future.value$value, 
[18:04:48.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:48.332]                   ...future.rng), globalenv = if (FALSE) 
[18:04:48.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:48.332]                     ...future.globalenv.names))
[18:04:48.332]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:48.332]         }, condition = base::local({
[18:04:48.332]             c <- base::c
[18:04:48.332]             inherits <- base::inherits
[18:04:48.332]             invokeRestart <- base::invokeRestart
[18:04:48.332]             length <- base::length
[18:04:48.332]             list <- base::list
[18:04:48.332]             seq.int <- base::seq.int
[18:04:48.332]             signalCondition <- base::signalCondition
[18:04:48.332]             sys.calls <- base::sys.calls
[18:04:48.332]             `[[` <- base::`[[`
[18:04:48.332]             `+` <- base::`+`
[18:04:48.332]             `<<-` <- base::`<<-`
[18:04:48.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:48.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:48.332]                   3L)]
[18:04:48.332]             }
[18:04:48.332]             function(cond) {
[18:04:48.332]                 is_error <- inherits(cond, "error")
[18:04:48.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:48.332]                   NULL)
[18:04:48.332]                 if (is_error) {
[18:04:48.332]                   sessionInformation <- function() {
[18:04:48.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:48.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:48.332]                       search = base::search(), system = base::Sys.info())
[18:04:48.332]                   }
[18:04:48.332]                   ...future.conditions[[length(...future.conditions) + 
[18:04:48.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:48.332]                     cond$call), session = sessionInformation(), 
[18:04:48.332]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:48.332]                   signalCondition(cond)
[18:04:48.332]                 }
[18:04:48.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:48.332]                 "immediateCondition"))) {
[18:04:48.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:48.332]                   ...future.conditions[[length(...future.conditions) + 
[18:04:48.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:48.332]                   if (TRUE && !signal) {
[18:04:48.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.332]                     {
[18:04:48.332]                       inherits <- base::inherits
[18:04:48.332]                       invokeRestart <- base::invokeRestart
[18:04:48.332]                       is.null <- base::is.null
[18:04:48.332]                       muffled <- FALSE
[18:04:48.332]                       if (inherits(cond, "message")) {
[18:04:48.332]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:48.332]                         if (muffled) 
[18:04:48.332]                           invokeRestart("muffleMessage")
[18:04:48.332]                       }
[18:04:48.332]                       else if (inherits(cond, "warning")) {
[18:04:48.332]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:48.332]                         if (muffled) 
[18:04:48.332]                           invokeRestart("muffleWarning")
[18:04:48.332]                       }
[18:04:48.332]                       else if (inherits(cond, "condition")) {
[18:04:48.332]                         if (!is.null(pattern)) {
[18:04:48.332]                           computeRestarts <- base::computeRestarts
[18:04:48.332]                           grepl <- base::grepl
[18:04:48.332]                           restarts <- computeRestarts(cond)
[18:04:48.332]                           for (restart in restarts) {
[18:04:48.332]                             name <- restart$name
[18:04:48.332]                             if (is.null(name)) 
[18:04:48.332]                               next
[18:04:48.332]                             if (!grepl(pattern, name)) 
[18:04:48.332]                               next
[18:04:48.332]                             invokeRestart(restart)
[18:04:48.332]                             muffled <- TRUE
[18:04:48.332]                             break
[18:04:48.332]                           }
[18:04:48.332]                         }
[18:04:48.332]                       }
[18:04:48.332]                       invisible(muffled)
[18:04:48.332]                     }
[18:04:48.332]                     muffleCondition(cond, pattern = "^muffle")
[18:04:48.332]                   }
[18:04:48.332]                 }
[18:04:48.332]                 else {
[18:04:48.332]                   if (TRUE) {
[18:04:48.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:48.332]                     {
[18:04:48.332]                       inherits <- base::inherits
[18:04:48.332]                       invokeRestart <- base::invokeRestart
[18:04:48.332]                       is.null <- base::is.null
[18:04:48.332]                       muffled <- FALSE
[18:04:48.332]                       if (inherits(cond, "message")) {
[18:04:48.332]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:48.332]                         if (muffled) 
[18:04:48.332]                           invokeRestart("muffleMessage")
[18:04:48.332]                       }
[18:04:48.332]                       else if (inherits(cond, "warning")) {
[18:04:48.332]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:48.332]                         if (muffled) 
[18:04:48.332]                           invokeRestart("muffleWarning")
[18:04:48.332]                       }
[18:04:48.332]                       else if (inherits(cond, "condition")) {
[18:04:48.332]                         if (!is.null(pattern)) {
[18:04:48.332]                           computeRestarts <- base::computeRestarts
[18:04:48.332]                           grepl <- base::grepl
[18:04:48.332]                           restarts <- computeRestarts(cond)
[18:04:48.332]                           for (restart in restarts) {
[18:04:48.332]                             name <- restart$name
[18:04:48.332]                             if (is.null(name)) 
[18:04:48.332]                               next
[18:04:48.332]                             if (!grepl(pattern, name)) 
[18:04:48.332]                               next
[18:04:48.332]                             invokeRestart(restart)
[18:04:48.332]                             muffled <- TRUE
[18:04:48.332]                             break
[18:04:48.332]                           }
[18:04:48.332]                         }
[18:04:48.332]                       }
[18:04:48.332]                       invisible(muffled)
[18:04:48.332]                     }
[18:04:48.332]                     muffleCondition(cond, pattern = "^muffle")
[18:04:48.332]                   }
[18:04:48.332]                 }
[18:04:48.332]             }
[18:04:48.332]         }))
[18:04:48.332]     }, error = function(ex) {
[18:04:48.332]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:48.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:48.332]                 ...future.rng), started = ...future.startTime, 
[18:04:48.332]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:48.332]             version = "1.8"), class = "FutureResult")
[18:04:48.332]     }, finally = {
[18:04:48.332]         if (!identical(...future.workdir, getwd())) 
[18:04:48.332]             setwd(...future.workdir)
[18:04:48.332]         {
[18:04:48.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:48.332]                 ...future.oldOptions$nwarnings <- NULL
[18:04:48.332]             }
[18:04:48.332]             base::options(...future.oldOptions)
[18:04:48.332]             if (.Platform$OS.type == "windows") {
[18:04:48.332]                 old_names <- names(...future.oldEnvVars)
[18:04:48.332]                 envs <- base::Sys.getenv()
[18:04:48.332]                 names <- names(envs)
[18:04:48.332]                 common <- intersect(names, old_names)
[18:04:48.332]                 added <- setdiff(names, old_names)
[18:04:48.332]                 removed <- setdiff(old_names, names)
[18:04:48.332]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:48.332]                   envs[common]]
[18:04:48.332]                 NAMES <- toupper(changed)
[18:04:48.332]                 args <- list()
[18:04:48.332]                 for (kk in seq_along(NAMES)) {
[18:04:48.332]                   name <- changed[[kk]]
[18:04:48.332]                   NAME <- NAMES[[kk]]
[18:04:48.332]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.332]                     next
[18:04:48.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:48.332]                 }
[18:04:48.332]                 NAMES <- toupper(added)
[18:04:48.332]                 for (kk in seq_along(NAMES)) {
[18:04:48.332]                   name <- added[[kk]]
[18:04:48.332]                   NAME <- NAMES[[kk]]
[18:04:48.332]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.332]                     next
[18:04:48.332]                   args[[name]] <- ""
[18:04:48.332]                 }
[18:04:48.332]                 NAMES <- toupper(removed)
[18:04:48.332]                 for (kk in seq_along(NAMES)) {
[18:04:48.332]                   name <- removed[[kk]]
[18:04:48.332]                   NAME <- NAMES[[kk]]
[18:04:48.332]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:48.332]                     next
[18:04:48.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:48.332]                 }
[18:04:48.332]                 if (length(args) > 0) 
[18:04:48.332]                   base::do.call(base::Sys.setenv, args = args)
[18:04:48.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:48.332]             }
[18:04:48.332]             else {
[18:04:48.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:48.332]             }
[18:04:48.332]             {
[18:04:48.332]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:48.332]                   0L) {
[18:04:48.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:48.332]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:48.332]                   base::options(opts)
[18:04:48.332]                 }
[18:04:48.332]                 {
[18:04:48.332]                   {
[18:04:48.332]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:48.332]                     NULL
[18:04:48.332]                   }
[18:04:48.332]                   options(future.plan = NULL)
[18:04:48.332]                   if (is.na(NA_character_)) 
[18:04:48.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:48.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:48.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:48.332]                     .init = FALSE)
[18:04:48.332]                 }
[18:04:48.332]             }
[18:04:48.332]         }
[18:04:48.332]     })
[18:04:48.332]     if (TRUE) {
[18:04:48.332]         base::sink(type = "output", split = FALSE)
[18:04:48.332]         if (TRUE) {
[18:04:48.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:48.332]         }
[18:04:48.332]         else {
[18:04:48.332]             ...future.result["stdout"] <- base::list(NULL)
[18:04:48.332]         }
[18:04:48.332]         base::close(...future.stdout)
[18:04:48.332]         ...future.stdout <- NULL
[18:04:48.332]     }
[18:04:48.332]     ...future.result$conditions <- ...future.conditions
[18:04:48.332]     ...future.result$finished <- base::Sys.time()
[18:04:48.332]     ...future.result
[18:04:48.332] }
[18:04:48.337] assign_globals() ...
[18:04:48.337] List of 2
[18:04:48.337]  $ x   : list()
[18:04:48.337]  $ name: chr "a"
[18:04:48.337]  - attr(*, "where")=List of 2
[18:04:48.337]   ..$ x   :<environment: R_EmptyEnv> 
[18:04:48.337]   ..$ name:<environment: R_EmptyEnv> 
[18:04:48.337]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:48.337]  - attr(*, "resolved")= logi TRUE
[18:04:48.337]  - attr(*, "total_size")= num 112
[18:04:48.337]  - attr(*, "already-done")= logi TRUE
[18:04:48.344] - copied ‘x’ to environment
[18:04:48.344] - copied ‘name’ to environment
[18:04:48.344] assign_globals() ... done
[18:04:48.345] requestCore(): workers = 2
[18:04:48.348] MulticoreFuture started
[18:04:48.349] - Launch lazy future ... done
[18:04:48.349] run() for ‘MulticoreFuture’ ... done
[18:04:48.350] plan(): Setting new future strategy stack:
[18:04:48.350] result() for MulticoreFuture ...
[18:04:48.351] List of future strategies:
[18:04:48.351] 1. sequential:
[18:04:48.351]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:48.351]    - tweaked: FALSE
[18:04:48.351]    - call: NULL
[18:04:48.353] plan(): nbrOfWorkers() = 1
[18:04:48.357] plan(): Setting new future strategy stack:
[18:04:48.357] List of future strategies:
[18:04:48.357] 1. multicore:
[18:04:48.357]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:48.357]    - tweaked: FALSE
[18:04:48.357]    - call: plan(strategy)
[18:04:48.366] plan(): nbrOfWorkers() = 2
[18:04:48.368] result() for MulticoreFuture ...
[18:04:48.369] result() for MulticoreFuture ... done
[18:04:48.369] result() for MulticoreFuture ... done
[18:04:48.369] result() for MulticoreFuture ...
[18:04:48.370] result() for MulticoreFuture ... done
$a
[1] 1

- plan('multisession') ...
[18:04:48.373] plan(): Setting new future strategy stack:
[18:04:48.374] List of future strategies:
[18:04:48.374] 1. multisession:
[18:04:48.374]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:48.374]    - tweaked: FALSE
[18:04:48.374]    - call: plan(strategy)
[18:04:48.375] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:04:48.375] multisession:
[18:04:48.375] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:48.375] - tweaked: FALSE
[18:04:48.375] - call: plan(strategy)
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:48.391] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:48.391] Not searching for globals
[18:04:48.392] - globals: [0] <none>
[18:04:48.392] getGlobalsAndPackages() ... DONE
[18:04:48.393] [local output] makeClusterPSOCK() ...
[18:04:48.457] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:04:48.459] [local output] Base port: 11938
[18:04:48.460] [local output] Getting setup options for 2 cluster nodes ...
[18:04:48.460] [local output]  - Node 1 of 2 ...
[18:04:48.461] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:48.462] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpGpkrBm/worker.rank=1.parallelly.parent=324573.4f3dd74c620a3.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpGpkrBm/worker.rank=1.parallelly.parent=324573.4f3dd74c620a3.pid")'’
[18:04:48.730] - Possible to infer worker's PID: TRUE
[18:04:48.731] [local output] Rscript port: 11938

[18:04:48.731] [local output]  - Node 2 of 2 ...
[18:04:48.732] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:48.733] [local output] Rscript port: 11938

[18:04:48.734] [local output] Getting setup options for 2 cluster nodes ... done
[18:04:48.734] [local output]  - Parallel setup requested for some PSOCK nodes
[18:04:48.735] [local output] Setting up PSOCK nodes in parallel
[18:04:48.735] List of 36
[18:04:48.735]  $ worker          : chr "localhost"
[18:04:48.735]   ..- attr(*, "localhost")= logi TRUE
[18:04:48.735]  $ master          : chr "localhost"
[18:04:48.735]  $ port            : int 11938
[18:04:48.735]  $ connectTimeout  : num 120
[18:04:48.735]  $ timeout         : num 2592000
[18:04:48.735]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:04:48.735]  $ homogeneous     : logi TRUE
[18:04:48.735]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:04:48.735]  $ rscript_envs    : NULL
[18:04:48.735]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:48.735]  $ rscript_startup : NULL
[18:04:48.735]  $ rscript_sh      : chr "sh"
[18:04:48.735]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:48.735]  $ methods         : logi TRUE
[18:04:48.735]  $ socketOptions   : chr "no-delay"
[18:04:48.735]  $ useXDR          : logi FALSE
[18:04:48.735]  $ outfile         : chr "/dev/null"
[18:04:48.735]  $ renice          : int NA
[18:04:48.735]  $ rshcmd          : NULL
[18:04:48.735]  $ user            : chr(0) 
[18:04:48.735]  $ revtunnel       : logi FALSE
[18:04:48.735]  $ rshlogfile      : NULL
[18:04:48.735]  $ rshopts         : chr(0) 
[18:04:48.735]  $ rank            : int 1
[18:04:48.735]  $ manual          : logi FALSE
[18:04:48.735]  $ dryrun          : logi FALSE
[18:04:48.735]  $ quiet           : logi FALSE
[18:04:48.735]  $ setup_strategy  : chr "parallel"
[18:04:48.735]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:48.735]  $ pidfile         : chr "/tmp/RtmpGpkrBm/worker.rank=1.parallelly.parent=324573.4f3dd74c620a3.pid"
[18:04:48.735]  $ rshcmd_label    : NULL
[18:04:48.735]  $ rsh_call        : NULL
[18:04:48.735]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:48.735]  $ localMachine    : logi TRUE
[18:04:48.735]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:04:48.735]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:04:48.735]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:04:48.735]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:04:48.735]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:04:48.735]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:04:48.735]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:04:48.735]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:04:48.735]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:04:48.735]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:04:48.735]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:04:48.735]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:04:48.735]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:04:48.735]  $ arguments       :List of 28
[18:04:48.735]   ..$ worker          : chr "localhost"
[18:04:48.735]   ..$ master          : NULL
[18:04:48.735]   ..$ port            : int 11938
[18:04:48.735]   ..$ connectTimeout  : num 120
[18:04:48.735]   ..$ timeout         : num 2592000
[18:04:48.735]   ..$ rscript         : NULL
[18:04:48.735]   ..$ homogeneous     : NULL
[18:04:48.735]   ..$ rscript_args    : NULL
[18:04:48.735]   ..$ rscript_envs    : NULL
[18:04:48.735]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:48.735]   ..$ rscript_startup : NULL
[18:04:48.735]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:04:48.735]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:48.735]   ..$ methods         : logi TRUE
[18:04:48.735]   ..$ socketOptions   : chr "no-delay"
[18:04:48.735]   ..$ useXDR          : logi FALSE
[18:04:48.735]   ..$ outfile         : chr "/dev/null"
[18:04:48.735]   ..$ renice          : int NA
[18:04:48.735]   ..$ rshcmd          : NULL
[18:04:48.735]   ..$ user            : NULL
[18:04:48.735]   ..$ revtunnel       : logi NA
[18:04:48.735]   ..$ rshlogfile      : NULL
[18:04:48.735]   ..$ rshopts         : NULL
[18:04:48.735]   ..$ rank            : int 1
[18:04:48.735]   ..$ manual          : logi FALSE
[18:04:48.735]   ..$ dryrun          : logi FALSE
[18:04:48.735]   ..$ quiet           : logi FALSE
[18:04:48.735]   ..$ setup_strategy  : chr "parallel"
[18:04:48.735]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:04:48.769] [local output] System call to launch all workers:
[18:04:48.769] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpGpkrBm/worker.rank=1.parallelly.parent=324573.4f3dd74c620a3.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11938 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:04:48.769] [local output] Starting PSOCK main server
[18:04:48.778] [local output] Workers launched
[18:04:48.778] [local output] Waiting for workers to connect back
[18:04:48.778]  - [local output] 0 workers out of 2 ready
[18:04:49.133]  - [local output] 0 workers out of 2 ready
[18:04:49.134]  - [local output] 1 workers out of 2 ready
[18:04:49.142]  - [local output] 1 workers out of 2 ready
[18:04:49.143]  - [local output] 2 workers out of 2 ready
[18:04:49.143] [local output] Launching of workers completed
[18:04:49.143] [local output] Collecting session information from workers
[18:04:49.145] [local output]  - Worker #1 of 2
[18:04:49.146] [local output]  - Worker #2 of 2
[18:04:49.146] [local output] makeClusterPSOCK() ... done
[18:04:49.167] Packages needed by the future expression (n = 0): <none>
[18:04:49.168] Packages needed by future strategies (n = 0): <none>
[18:04:49.168] {
[18:04:49.168]     {
[18:04:49.168]         {
[18:04:49.168]             ...future.startTime <- base::Sys.time()
[18:04:49.168]             {
[18:04:49.168]                 {
[18:04:49.168]                   {
[18:04:49.168]                     {
[18:04:49.168]                       base::local({
[18:04:49.168]                         has_future <- base::requireNamespace("future", 
[18:04:49.168]                           quietly = TRUE)
[18:04:49.168]                         if (has_future) {
[18:04:49.168]                           ns <- base::getNamespace("future")
[18:04:49.168]                           version <- ns[[".package"]][["version"]]
[18:04:49.168]                           if (is.null(version)) 
[18:04:49.168]                             version <- utils::packageVersion("future")
[18:04:49.168]                         }
[18:04:49.168]                         else {
[18:04:49.168]                           version <- NULL
[18:04:49.168]                         }
[18:04:49.168]                         if (!has_future || version < "1.8.0") {
[18:04:49.168]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:49.168]                             "", base::R.version$version.string), 
[18:04:49.168]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:49.168]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:49.168]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:49.168]                               "release", "version")], collapse = " "), 
[18:04:49.168]                             hostname = base::Sys.info()[["nodename"]])
[18:04:49.168]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:49.168]                             info)
[18:04:49.168]                           info <- base::paste(info, collapse = "; ")
[18:04:49.168]                           if (!has_future) {
[18:04:49.168]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:49.168]                               info)
[18:04:49.168]                           }
[18:04:49.168]                           else {
[18:04:49.168]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:49.168]                               info, version)
[18:04:49.168]                           }
[18:04:49.168]                           base::stop(msg)
[18:04:49.168]                         }
[18:04:49.168]                       })
[18:04:49.168]                     }
[18:04:49.168]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:49.168]                     base::options(mc.cores = 1L)
[18:04:49.168]                   }
[18:04:49.168]                   ...future.strategy.old <- future::plan("list")
[18:04:49.168]                   options(future.plan = NULL)
[18:04:49.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:49.168]                 }
[18:04:49.168]                 ...future.workdir <- getwd()
[18:04:49.168]             }
[18:04:49.168]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:49.168]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:49.168]         }
[18:04:49.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:49.168]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:49.168]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:49.168]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:49.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:49.168]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:49.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:49.168]             base::names(...future.oldOptions))
[18:04:49.168]     }
[18:04:49.168]     if (FALSE) {
[18:04:49.168]     }
[18:04:49.168]     else {
[18:04:49.168]         if (TRUE) {
[18:04:49.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:49.168]                 open = "w")
[18:04:49.168]         }
[18:04:49.168]         else {
[18:04:49.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:49.168]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:49.168]         }
[18:04:49.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:49.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:49.168]             base::sink(type = "output", split = FALSE)
[18:04:49.168]             base::close(...future.stdout)
[18:04:49.168]         }, add = TRUE)
[18:04:49.168]     }
[18:04:49.168]     ...future.frame <- base::sys.nframe()
[18:04:49.168]     ...future.conditions <- base::list()
[18:04:49.168]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:49.168]     if (FALSE) {
[18:04:49.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:49.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:49.168]     }
[18:04:49.168]     ...future.result <- base::tryCatch({
[18:04:49.168]         base::withCallingHandlers({
[18:04:49.168]             ...future.value <- base::withVisible(base::local({
[18:04:49.168]                 ...future.makeSendCondition <- base::local({
[18:04:49.168]                   sendCondition <- NULL
[18:04:49.168]                   function(frame = 1L) {
[18:04:49.168]                     if (is.function(sendCondition)) 
[18:04:49.168]                       return(sendCondition)
[18:04:49.168]                     ns <- getNamespace("parallel")
[18:04:49.168]                     if (exists("sendData", mode = "function", 
[18:04:49.168]                       envir = ns)) {
[18:04:49.168]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:49.168]                         envir = ns)
[18:04:49.168]                       envir <- sys.frame(frame)
[18:04:49.168]                       master <- NULL
[18:04:49.168]                       while (!identical(envir, .GlobalEnv) && 
[18:04:49.168]                         !identical(envir, emptyenv())) {
[18:04:49.168]                         if (exists("master", mode = "list", envir = envir, 
[18:04:49.168]                           inherits = FALSE)) {
[18:04:49.168]                           master <- get("master", mode = "list", 
[18:04:49.168]                             envir = envir, inherits = FALSE)
[18:04:49.168]                           if (inherits(master, c("SOCKnode", 
[18:04:49.168]                             "SOCK0node"))) {
[18:04:49.168]                             sendCondition <<- function(cond) {
[18:04:49.168]                               data <- list(type = "VALUE", value = cond, 
[18:04:49.168]                                 success = TRUE)
[18:04:49.168]                               parallel_sendData(master, data)
[18:04:49.168]                             }
[18:04:49.168]                             return(sendCondition)
[18:04:49.168]                           }
[18:04:49.168]                         }
[18:04:49.168]                         frame <- frame + 1L
[18:04:49.168]                         envir <- sys.frame(frame)
[18:04:49.168]                       }
[18:04:49.168]                     }
[18:04:49.168]                     sendCondition <<- function(cond) NULL
[18:04:49.168]                   }
[18:04:49.168]                 })
[18:04:49.168]                 withCallingHandlers({
[18:04:49.168]                   NA
[18:04:49.168]                 }, immediateCondition = function(cond) {
[18:04:49.168]                   sendCondition <- ...future.makeSendCondition()
[18:04:49.168]                   sendCondition(cond)
[18:04:49.168]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.168]                   {
[18:04:49.168]                     inherits <- base::inherits
[18:04:49.168]                     invokeRestart <- base::invokeRestart
[18:04:49.168]                     is.null <- base::is.null
[18:04:49.168]                     muffled <- FALSE
[18:04:49.168]                     if (inherits(cond, "message")) {
[18:04:49.168]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:49.168]                       if (muffled) 
[18:04:49.168]                         invokeRestart("muffleMessage")
[18:04:49.168]                     }
[18:04:49.168]                     else if (inherits(cond, "warning")) {
[18:04:49.168]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:49.168]                       if (muffled) 
[18:04:49.168]                         invokeRestart("muffleWarning")
[18:04:49.168]                     }
[18:04:49.168]                     else if (inherits(cond, "condition")) {
[18:04:49.168]                       if (!is.null(pattern)) {
[18:04:49.168]                         computeRestarts <- base::computeRestarts
[18:04:49.168]                         grepl <- base::grepl
[18:04:49.168]                         restarts <- computeRestarts(cond)
[18:04:49.168]                         for (restart in restarts) {
[18:04:49.168]                           name <- restart$name
[18:04:49.168]                           if (is.null(name)) 
[18:04:49.168]                             next
[18:04:49.168]                           if (!grepl(pattern, name)) 
[18:04:49.168]                             next
[18:04:49.168]                           invokeRestart(restart)
[18:04:49.168]                           muffled <- TRUE
[18:04:49.168]                           break
[18:04:49.168]                         }
[18:04:49.168]                       }
[18:04:49.168]                     }
[18:04:49.168]                     invisible(muffled)
[18:04:49.168]                   }
[18:04:49.168]                   muffleCondition(cond)
[18:04:49.168]                 })
[18:04:49.168]             }))
[18:04:49.168]             future::FutureResult(value = ...future.value$value, 
[18:04:49.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.168]                   ...future.rng), globalenv = if (FALSE) 
[18:04:49.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:49.168]                     ...future.globalenv.names))
[18:04:49.168]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:49.168]         }, condition = base::local({
[18:04:49.168]             c <- base::c
[18:04:49.168]             inherits <- base::inherits
[18:04:49.168]             invokeRestart <- base::invokeRestart
[18:04:49.168]             length <- base::length
[18:04:49.168]             list <- base::list
[18:04:49.168]             seq.int <- base::seq.int
[18:04:49.168]             signalCondition <- base::signalCondition
[18:04:49.168]             sys.calls <- base::sys.calls
[18:04:49.168]             `[[` <- base::`[[`
[18:04:49.168]             `+` <- base::`+`
[18:04:49.168]             `<<-` <- base::`<<-`
[18:04:49.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:49.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:49.168]                   3L)]
[18:04:49.168]             }
[18:04:49.168]             function(cond) {
[18:04:49.168]                 is_error <- inherits(cond, "error")
[18:04:49.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:49.168]                   NULL)
[18:04:49.168]                 if (is_error) {
[18:04:49.168]                   sessionInformation <- function() {
[18:04:49.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:49.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:49.168]                       search = base::search(), system = base::Sys.info())
[18:04:49.168]                   }
[18:04:49.168]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:49.168]                     cond$call), session = sessionInformation(), 
[18:04:49.168]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:49.168]                   signalCondition(cond)
[18:04:49.168]                 }
[18:04:49.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:49.168]                 "immediateCondition"))) {
[18:04:49.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:49.168]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:49.168]                   if (TRUE && !signal) {
[18:04:49.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.168]                     {
[18:04:49.168]                       inherits <- base::inherits
[18:04:49.168]                       invokeRestart <- base::invokeRestart
[18:04:49.168]                       is.null <- base::is.null
[18:04:49.168]                       muffled <- FALSE
[18:04:49.168]                       if (inherits(cond, "message")) {
[18:04:49.168]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.168]                         if (muffled) 
[18:04:49.168]                           invokeRestart("muffleMessage")
[18:04:49.168]                       }
[18:04:49.168]                       else if (inherits(cond, "warning")) {
[18:04:49.168]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.168]                         if (muffled) 
[18:04:49.168]                           invokeRestart("muffleWarning")
[18:04:49.168]                       }
[18:04:49.168]                       else if (inherits(cond, "condition")) {
[18:04:49.168]                         if (!is.null(pattern)) {
[18:04:49.168]                           computeRestarts <- base::computeRestarts
[18:04:49.168]                           grepl <- base::grepl
[18:04:49.168]                           restarts <- computeRestarts(cond)
[18:04:49.168]                           for (restart in restarts) {
[18:04:49.168]                             name <- restart$name
[18:04:49.168]                             if (is.null(name)) 
[18:04:49.168]                               next
[18:04:49.168]                             if (!grepl(pattern, name)) 
[18:04:49.168]                               next
[18:04:49.168]                             invokeRestart(restart)
[18:04:49.168]                             muffled <- TRUE
[18:04:49.168]                             break
[18:04:49.168]                           }
[18:04:49.168]                         }
[18:04:49.168]                       }
[18:04:49.168]                       invisible(muffled)
[18:04:49.168]                     }
[18:04:49.168]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.168]                   }
[18:04:49.168]                 }
[18:04:49.168]                 else {
[18:04:49.168]                   if (TRUE) {
[18:04:49.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.168]                     {
[18:04:49.168]                       inherits <- base::inherits
[18:04:49.168]                       invokeRestart <- base::invokeRestart
[18:04:49.168]                       is.null <- base::is.null
[18:04:49.168]                       muffled <- FALSE
[18:04:49.168]                       if (inherits(cond, "message")) {
[18:04:49.168]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.168]                         if (muffled) 
[18:04:49.168]                           invokeRestart("muffleMessage")
[18:04:49.168]                       }
[18:04:49.168]                       else if (inherits(cond, "warning")) {
[18:04:49.168]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.168]                         if (muffled) 
[18:04:49.168]                           invokeRestart("muffleWarning")
[18:04:49.168]                       }
[18:04:49.168]                       else if (inherits(cond, "condition")) {
[18:04:49.168]                         if (!is.null(pattern)) {
[18:04:49.168]                           computeRestarts <- base::computeRestarts
[18:04:49.168]                           grepl <- base::grepl
[18:04:49.168]                           restarts <- computeRestarts(cond)
[18:04:49.168]                           for (restart in restarts) {
[18:04:49.168]                             name <- restart$name
[18:04:49.168]                             if (is.null(name)) 
[18:04:49.168]                               next
[18:04:49.168]                             if (!grepl(pattern, name)) 
[18:04:49.168]                               next
[18:04:49.168]                             invokeRestart(restart)
[18:04:49.168]                             muffled <- TRUE
[18:04:49.168]                             break
[18:04:49.168]                           }
[18:04:49.168]                         }
[18:04:49.168]                       }
[18:04:49.168]                       invisible(muffled)
[18:04:49.168]                     }
[18:04:49.168]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.168]                   }
[18:04:49.168]                 }
[18:04:49.168]             }
[18:04:49.168]         }))
[18:04:49.168]     }, error = function(ex) {
[18:04:49.168]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:49.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.168]                 ...future.rng), started = ...future.startTime, 
[18:04:49.168]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:49.168]             version = "1.8"), class = "FutureResult")
[18:04:49.168]     }, finally = {
[18:04:49.168]         if (!identical(...future.workdir, getwd())) 
[18:04:49.168]             setwd(...future.workdir)
[18:04:49.168]         {
[18:04:49.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:49.168]                 ...future.oldOptions$nwarnings <- NULL
[18:04:49.168]             }
[18:04:49.168]             base::options(...future.oldOptions)
[18:04:49.168]             if (.Platform$OS.type == "windows") {
[18:04:49.168]                 old_names <- names(...future.oldEnvVars)
[18:04:49.168]                 envs <- base::Sys.getenv()
[18:04:49.168]                 names <- names(envs)
[18:04:49.168]                 common <- intersect(names, old_names)
[18:04:49.168]                 added <- setdiff(names, old_names)
[18:04:49.168]                 removed <- setdiff(old_names, names)
[18:04:49.168]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:49.168]                   envs[common]]
[18:04:49.168]                 NAMES <- toupper(changed)
[18:04:49.168]                 args <- list()
[18:04:49.168]                 for (kk in seq_along(NAMES)) {
[18:04:49.168]                   name <- changed[[kk]]
[18:04:49.168]                   NAME <- NAMES[[kk]]
[18:04:49.168]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.168]                     next
[18:04:49.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.168]                 }
[18:04:49.168]                 NAMES <- toupper(added)
[18:04:49.168]                 for (kk in seq_along(NAMES)) {
[18:04:49.168]                   name <- added[[kk]]
[18:04:49.168]                   NAME <- NAMES[[kk]]
[18:04:49.168]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.168]                     next
[18:04:49.168]                   args[[name]] <- ""
[18:04:49.168]                 }
[18:04:49.168]                 NAMES <- toupper(removed)
[18:04:49.168]                 for (kk in seq_along(NAMES)) {
[18:04:49.168]                   name <- removed[[kk]]
[18:04:49.168]                   NAME <- NAMES[[kk]]
[18:04:49.168]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.168]                     next
[18:04:49.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.168]                 }
[18:04:49.168]                 if (length(args) > 0) 
[18:04:49.168]                   base::do.call(base::Sys.setenv, args = args)
[18:04:49.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:49.168]             }
[18:04:49.168]             else {
[18:04:49.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:49.168]             }
[18:04:49.168]             {
[18:04:49.168]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:49.168]                   0L) {
[18:04:49.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:49.168]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:49.168]                   base::options(opts)
[18:04:49.168]                 }
[18:04:49.168]                 {
[18:04:49.168]                   {
[18:04:49.168]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:49.168]                     NULL
[18:04:49.168]                   }
[18:04:49.168]                   options(future.plan = NULL)
[18:04:49.168]                   if (is.na(NA_character_)) 
[18:04:49.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:49.168]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:49.168]                     .init = FALSE)
[18:04:49.168]                 }
[18:04:49.168]             }
[18:04:49.168]         }
[18:04:49.168]     })
[18:04:49.168]     if (TRUE) {
[18:04:49.168]         base::sink(type = "output", split = FALSE)
[18:04:49.168]         if (TRUE) {
[18:04:49.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:49.168]         }
[18:04:49.168]         else {
[18:04:49.168]             ...future.result["stdout"] <- base::list(NULL)
[18:04:49.168]         }
[18:04:49.168]         base::close(...future.stdout)
[18:04:49.168]         ...future.stdout <- NULL
[18:04:49.168]     }
[18:04:49.168]     ...future.result$conditions <- ...future.conditions
[18:04:49.168]     ...future.result$finished <- base::Sys.time()
[18:04:49.168]     ...future.result
[18:04:49.168] }
[18:04:49.266] MultisessionFuture started
[18:04:49.267] result() for ClusterFuture ...
[18:04:49.267] receiveMessageFromWorker() for ClusterFuture ...
[18:04:49.268] - Validating connection of MultisessionFuture
[18:04:49.331] - received message: FutureResult
[18:04:49.331] - Received FutureResult
[18:04:49.332] - Erased future from FutureRegistry
[18:04:49.332] result() for ClusterFuture ...
[18:04:49.332] - result already collected: FutureResult
[18:04:49.333] result() for ClusterFuture ... done
[18:04:49.333] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:49.333] result() for ClusterFuture ... done
[18:04:49.333] result() for ClusterFuture ...
[18:04:49.334] - result already collected: FutureResult
[18:04:49.334] result() for ClusterFuture ... done
[18:04:49.334] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:04:49.344] plan(): nbrOfWorkers() = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:49.344] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:49.347] Searching for globals...
[18:04:49.353] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:49.353] Searching for globals ... DONE
[18:04:49.354] Resolving globals: TRUE
[18:04:49.354] Resolving any globals that are futures ...
[18:04:49.354] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:49.355] Resolving any globals that are futures ... DONE
[18:04:49.357] Resolving futures part of globals (recursively) ...
[18:04:49.357] resolve() on list ...
[18:04:49.358]  recursive: 99
[18:04:49.358]  length: 1
[18:04:49.358]  elements: ‘x’
[18:04:49.358]  length: 0 (resolved future 1)
[18:04:49.359] resolve() on list ... DONE
[18:04:49.359] - globals: [1] ‘x’
[18:04:49.359] Resolving futures part of globals (recursively) ... DONE
[18:04:49.360] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:49.361] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:49.361] - globals: [1] ‘x’
[18:04:49.361] 
[18:04:49.361] getGlobalsAndPackages() ... DONE
[18:04:49.362] run() for ‘Future’ ...
[18:04:49.362] - state: ‘created’
[18:04:49.363] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:49.389] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:49.389] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:49.389]   - Field: ‘node’
[18:04:49.389]   - Field: ‘label’
[18:04:49.390]   - Field: ‘local’
[18:04:49.390]   - Field: ‘owner’
[18:04:49.390]   - Field: ‘envir’
[18:04:49.390]   - Field: ‘workers’
[18:04:49.390]   - Field: ‘packages’
[18:04:49.391]   - Field: ‘gc’
[18:04:49.391]   - Field: ‘conditions’
[18:04:49.391]   - Field: ‘persistent’
[18:04:49.391]   - Field: ‘expr’
[18:04:49.392]   - Field: ‘uuid’
[18:04:49.392]   - Field: ‘seed’
[18:04:49.392]   - Field: ‘version’
[18:04:49.392]   - Field: ‘result’
[18:04:49.392]   - Field: ‘asynchronous’
[18:04:49.393]   - Field: ‘calls’
[18:04:49.393]   - Field: ‘globals’
[18:04:49.393]   - Field: ‘stdout’
[18:04:49.393]   - Field: ‘earlySignal’
[18:04:49.394]   - Field: ‘lazy’
[18:04:49.394]   - Field: ‘state’
[18:04:49.394] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:49.395] - Launch lazy future ...
[18:04:49.396] Packages needed by the future expression (n = 0): <none>
[18:04:49.396] Packages needed by future strategies (n = 0): <none>
[18:04:49.397] {
[18:04:49.397]     {
[18:04:49.397]         {
[18:04:49.397]             ...future.startTime <- base::Sys.time()
[18:04:49.397]             {
[18:04:49.397]                 {
[18:04:49.397]                   {
[18:04:49.397]                     {
[18:04:49.397]                       base::local({
[18:04:49.397]                         has_future <- base::requireNamespace("future", 
[18:04:49.397]                           quietly = TRUE)
[18:04:49.397]                         if (has_future) {
[18:04:49.397]                           ns <- base::getNamespace("future")
[18:04:49.397]                           version <- ns[[".package"]][["version"]]
[18:04:49.397]                           if (is.null(version)) 
[18:04:49.397]                             version <- utils::packageVersion("future")
[18:04:49.397]                         }
[18:04:49.397]                         else {
[18:04:49.397]                           version <- NULL
[18:04:49.397]                         }
[18:04:49.397]                         if (!has_future || version < "1.8.0") {
[18:04:49.397]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:49.397]                             "", base::R.version$version.string), 
[18:04:49.397]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:49.397]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:49.397]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:49.397]                               "release", "version")], collapse = " "), 
[18:04:49.397]                             hostname = base::Sys.info()[["nodename"]])
[18:04:49.397]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:49.397]                             info)
[18:04:49.397]                           info <- base::paste(info, collapse = "; ")
[18:04:49.397]                           if (!has_future) {
[18:04:49.397]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:49.397]                               info)
[18:04:49.397]                           }
[18:04:49.397]                           else {
[18:04:49.397]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:49.397]                               info, version)
[18:04:49.397]                           }
[18:04:49.397]                           base::stop(msg)
[18:04:49.397]                         }
[18:04:49.397]                       })
[18:04:49.397]                     }
[18:04:49.397]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:49.397]                     base::options(mc.cores = 1L)
[18:04:49.397]                   }
[18:04:49.397]                   ...future.strategy.old <- future::plan("list")
[18:04:49.397]                   options(future.plan = NULL)
[18:04:49.397]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.397]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:49.397]                 }
[18:04:49.397]                 ...future.workdir <- getwd()
[18:04:49.397]             }
[18:04:49.397]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:49.397]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:49.397]         }
[18:04:49.397]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:49.397]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:49.397]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:49.397]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:49.397]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:49.397]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:49.397]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:49.397]             base::names(...future.oldOptions))
[18:04:49.397]     }
[18:04:49.397]     if (FALSE) {
[18:04:49.397]     }
[18:04:49.397]     else {
[18:04:49.397]         if (TRUE) {
[18:04:49.397]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:49.397]                 open = "w")
[18:04:49.397]         }
[18:04:49.397]         else {
[18:04:49.397]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:49.397]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:49.397]         }
[18:04:49.397]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:49.397]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:49.397]             base::sink(type = "output", split = FALSE)
[18:04:49.397]             base::close(...future.stdout)
[18:04:49.397]         }, add = TRUE)
[18:04:49.397]     }
[18:04:49.397]     ...future.frame <- base::sys.nframe()
[18:04:49.397]     ...future.conditions <- base::list()
[18:04:49.397]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:49.397]     if (FALSE) {
[18:04:49.397]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:49.397]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:49.397]     }
[18:04:49.397]     ...future.result <- base::tryCatch({
[18:04:49.397]         base::withCallingHandlers({
[18:04:49.397]             ...future.value <- base::withVisible(base::local({
[18:04:49.397]                 ...future.makeSendCondition <- base::local({
[18:04:49.397]                   sendCondition <- NULL
[18:04:49.397]                   function(frame = 1L) {
[18:04:49.397]                     if (is.function(sendCondition)) 
[18:04:49.397]                       return(sendCondition)
[18:04:49.397]                     ns <- getNamespace("parallel")
[18:04:49.397]                     if (exists("sendData", mode = "function", 
[18:04:49.397]                       envir = ns)) {
[18:04:49.397]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:49.397]                         envir = ns)
[18:04:49.397]                       envir <- sys.frame(frame)
[18:04:49.397]                       master <- NULL
[18:04:49.397]                       while (!identical(envir, .GlobalEnv) && 
[18:04:49.397]                         !identical(envir, emptyenv())) {
[18:04:49.397]                         if (exists("master", mode = "list", envir = envir, 
[18:04:49.397]                           inherits = FALSE)) {
[18:04:49.397]                           master <- get("master", mode = "list", 
[18:04:49.397]                             envir = envir, inherits = FALSE)
[18:04:49.397]                           if (inherits(master, c("SOCKnode", 
[18:04:49.397]                             "SOCK0node"))) {
[18:04:49.397]                             sendCondition <<- function(cond) {
[18:04:49.397]                               data <- list(type = "VALUE", value = cond, 
[18:04:49.397]                                 success = TRUE)
[18:04:49.397]                               parallel_sendData(master, data)
[18:04:49.397]                             }
[18:04:49.397]                             return(sendCondition)
[18:04:49.397]                           }
[18:04:49.397]                         }
[18:04:49.397]                         frame <- frame + 1L
[18:04:49.397]                         envir <- sys.frame(frame)
[18:04:49.397]                       }
[18:04:49.397]                     }
[18:04:49.397]                     sendCondition <<- function(cond) NULL
[18:04:49.397]                   }
[18:04:49.397]                 })
[18:04:49.397]                 withCallingHandlers({
[18:04:49.397]                   {
[18:04:49.397]                     x$a <- 1
[18:04:49.397]                     x
[18:04:49.397]                   }
[18:04:49.397]                 }, immediateCondition = function(cond) {
[18:04:49.397]                   sendCondition <- ...future.makeSendCondition()
[18:04:49.397]                   sendCondition(cond)
[18:04:49.397]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.397]                   {
[18:04:49.397]                     inherits <- base::inherits
[18:04:49.397]                     invokeRestart <- base::invokeRestart
[18:04:49.397]                     is.null <- base::is.null
[18:04:49.397]                     muffled <- FALSE
[18:04:49.397]                     if (inherits(cond, "message")) {
[18:04:49.397]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:49.397]                       if (muffled) 
[18:04:49.397]                         invokeRestart("muffleMessage")
[18:04:49.397]                     }
[18:04:49.397]                     else if (inherits(cond, "warning")) {
[18:04:49.397]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:49.397]                       if (muffled) 
[18:04:49.397]                         invokeRestart("muffleWarning")
[18:04:49.397]                     }
[18:04:49.397]                     else if (inherits(cond, "condition")) {
[18:04:49.397]                       if (!is.null(pattern)) {
[18:04:49.397]                         computeRestarts <- base::computeRestarts
[18:04:49.397]                         grepl <- base::grepl
[18:04:49.397]                         restarts <- computeRestarts(cond)
[18:04:49.397]                         for (restart in restarts) {
[18:04:49.397]                           name <- restart$name
[18:04:49.397]                           if (is.null(name)) 
[18:04:49.397]                             next
[18:04:49.397]                           if (!grepl(pattern, name)) 
[18:04:49.397]                             next
[18:04:49.397]                           invokeRestart(restart)
[18:04:49.397]                           muffled <- TRUE
[18:04:49.397]                           break
[18:04:49.397]                         }
[18:04:49.397]                       }
[18:04:49.397]                     }
[18:04:49.397]                     invisible(muffled)
[18:04:49.397]                   }
[18:04:49.397]                   muffleCondition(cond)
[18:04:49.397]                 })
[18:04:49.397]             }))
[18:04:49.397]             future::FutureResult(value = ...future.value$value, 
[18:04:49.397]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.397]                   ...future.rng), globalenv = if (FALSE) 
[18:04:49.397]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:49.397]                     ...future.globalenv.names))
[18:04:49.397]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:49.397]         }, condition = base::local({
[18:04:49.397]             c <- base::c
[18:04:49.397]             inherits <- base::inherits
[18:04:49.397]             invokeRestart <- base::invokeRestart
[18:04:49.397]             length <- base::length
[18:04:49.397]             list <- base::list
[18:04:49.397]             seq.int <- base::seq.int
[18:04:49.397]             signalCondition <- base::signalCondition
[18:04:49.397]             sys.calls <- base::sys.calls
[18:04:49.397]             `[[` <- base::`[[`
[18:04:49.397]             `+` <- base::`+`
[18:04:49.397]             `<<-` <- base::`<<-`
[18:04:49.397]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:49.397]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:49.397]                   3L)]
[18:04:49.397]             }
[18:04:49.397]             function(cond) {
[18:04:49.397]                 is_error <- inherits(cond, "error")
[18:04:49.397]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:49.397]                   NULL)
[18:04:49.397]                 if (is_error) {
[18:04:49.397]                   sessionInformation <- function() {
[18:04:49.397]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:49.397]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:49.397]                       search = base::search(), system = base::Sys.info())
[18:04:49.397]                   }
[18:04:49.397]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.397]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:49.397]                     cond$call), session = sessionInformation(), 
[18:04:49.397]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:49.397]                   signalCondition(cond)
[18:04:49.397]                 }
[18:04:49.397]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:49.397]                 "immediateCondition"))) {
[18:04:49.397]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:49.397]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.397]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:49.397]                   if (TRUE && !signal) {
[18:04:49.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.397]                     {
[18:04:49.397]                       inherits <- base::inherits
[18:04:49.397]                       invokeRestart <- base::invokeRestart
[18:04:49.397]                       is.null <- base::is.null
[18:04:49.397]                       muffled <- FALSE
[18:04:49.397]                       if (inherits(cond, "message")) {
[18:04:49.397]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.397]                         if (muffled) 
[18:04:49.397]                           invokeRestart("muffleMessage")
[18:04:49.397]                       }
[18:04:49.397]                       else if (inherits(cond, "warning")) {
[18:04:49.397]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.397]                         if (muffled) 
[18:04:49.397]                           invokeRestart("muffleWarning")
[18:04:49.397]                       }
[18:04:49.397]                       else if (inherits(cond, "condition")) {
[18:04:49.397]                         if (!is.null(pattern)) {
[18:04:49.397]                           computeRestarts <- base::computeRestarts
[18:04:49.397]                           grepl <- base::grepl
[18:04:49.397]                           restarts <- computeRestarts(cond)
[18:04:49.397]                           for (restart in restarts) {
[18:04:49.397]                             name <- restart$name
[18:04:49.397]                             if (is.null(name)) 
[18:04:49.397]                               next
[18:04:49.397]                             if (!grepl(pattern, name)) 
[18:04:49.397]                               next
[18:04:49.397]                             invokeRestart(restart)
[18:04:49.397]                             muffled <- TRUE
[18:04:49.397]                             break
[18:04:49.397]                           }
[18:04:49.397]                         }
[18:04:49.397]                       }
[18:04:49.397]                       invisible(muffled)
[18:04:49.397]                     }
[18:04:49.397]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.397]                   }
[18:04:49.397]                 }
[18:04:49.397]                 else {
[18:04:49.397]                   if (TRUE) {
[18:04:49.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.397]                     {
[18:04:49.397]                       inherits <- base::inherits
[18:04:49.397]                       invokeRestart <- base::invokeRestart
[18:04:49.397]                       is.null <- base::is.null
[18:04:49.397]                       muffled <- FALSE
[18:04:49.397]                       if (inherits(cond, "message")) {
[18:04:49.397]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.397]                         if (muffled) 
[18:04:49.397]                           invokeRestart("muffleMessage")
[18:04:49.397]                       }
[18:04:49.397]                       else if (inherits(cond, "warning")) {
[18:04:49.397]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.397]                         if (muffled) 
[18:04:49.397]                           invokeRestart("muffleWarning")
[18:04:49.397]                       }
[18:04:49.397]                       else if (inherits(cond, "condition")) {
[18:04:49.397]                         if (!is.null(pattern)) {
[18:04:49.397]                           computeRestarts <- base::computeRestarts
[18:04:49.397]                           grepl <- base::grepl
[18:04:49.397]                           restarts <- computeRestarts(cond)
[18:04:49.397]                           for (restart in restarts) {
[18:04:49.397]                             name <- restart$name
[18:04:49.397]                             if (is.null(name)) 
[18:04:49.397]                               next
[18:04:49.397]                             if (!grepl(pattern, name)) 
[18:04:49.397]                               next
[18:04:49.397]                             invokeRestart(restart)
[18:04:49.397]                             muffled <- TRUE
[18:04:49.397]                             break
[18:04:49.397]                           }
[18:04:49.397]                         }
[18:04:49.397]                       }
[18:04:49.397]                       invisible(muffled)
[18:04:49.397]                     }
[18:04:49.397]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.397]                   }
[18:04:49.397]                 }
[18:04:49.397]             }
[18:04:49.397]         }))
[18:04:49.397]     }, error = function(ex) {
[18:04:49.397]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:49.397]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.397]                 ...future.rng), started = ...future.startTime, 
[18:04:49.397]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:49.397]             version = "1.8"), class = "FutureResult")
[18:04:49.397]     }, finally = {
[18:04:49.397]         if (!identical(...future.workdir, getwd())) 
[18:04:49.397]             setwd(...future.workdir)
[18:04:49.397]         {
[18:04:49.397]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:49.397]                 ...future.oldOptions$nwarnings <- NULL
[18:04:49.397]             }
[18:04:49.397]             base::options(...future.oldOptions)
[18:04:49.397]             if (.Platform$OS.type == "windows") {
[18:04:49.397]                 old_names <- names(...future.oldEnvVars)
[18:04:49.397]                 envs <- base::Sys.getenv()
[18:04:49.397]                 names <- names(envs)
[18:04:49.397]                 common <- intersect(names, old_names)
[18:04:49.397]                 added <- setdiff(names, old_names)
[18:04:49.397]                 removed <- setdiff(old_names, names)
[18:04:49.397]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:49.397]                   envs[common]]
[18:04:49.397]                 NAMES <- toupper(changed)
[18:04:49.397]                 args <- list()
[18:04:49.397]                 for (kk in seq_along(NAMES)) {
[18:04:49.397]                   name <- changed[[kk]]
[18:04:49.397]                   NAME <- NAMES[[kk]]
[18:04:49.397]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.397]                     next
[18:04:49.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.397]                 }
[18:04:49.397]                 NAMES <- toupper(added)
[18:04:49.397]                 for (kk in seq_along(NAMES)) {
[18:04:49.397]                   name <- added[[kk]]
[18:04:49.397]                   NAME <- NAMES[[kk]]
[18:04:49.397]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.397]                     next
[18:04:49.397]                   args[[name]] <- ""
[18:04:49.397]                 }
[18:04:49.397]                 NAMES <- toupper(removed)
[18:04:49.397]                 for (kk in seq_along(NAMES)) {
[18:04:49.397]                   name <- removed[[kk]]
[18:04:49.397]                   NAME <- NAMES[[kk]]
[18:04:49.397]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.397]                     next
[18:04:49.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.397]                 }
[18:04:49.397]                 if (length(args) > 0) 
[18:04:49.397]                   base::do.call(base::Sys.setenv, args = args)
[18:04:49.397]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:49.397]             }
[18:04:49.397]             else {
[18:04:49.397]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:49.397]             }
[18:04:49.397]             {
[18:04:49.397]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:49.397]                   0L) {
[18:04:49.397]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:49.397]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:49.397]                   base::options(opts)
[18:04:49.397]                 }
[18:04:49.397]                 {
[18:04:49.397]                   {
[18:04:49.397]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:49.397]                     NULL
[18:04:49.397]                   }
[18:04:49.397]                   options(future.plan = NULL)
[18:04:49.397]                   if (is.na(NA_character_)) 
[18:04:49.397]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.397]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:49.397]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:49.397]                     .init = FALSE)
[18:04:49.397]                 }
[18:04:49.397]             }
[18:04:49.397]         }
[18:04:49.397]     })
[18:04:49.397]     if (TRUE) {
[18:04:49.397]         base::sink(type = "output", split = FALSE)
[18:04:49.397]         if (TRUE) {
[18:04:49.397]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:49.397]         }
[18:04:49.397]         else {
[18:04:49.397]             ...future.result["stdout"] <- base::list(NULL)
[18:04:49.397]         }
[18:04:49.397]         base::close(...future.stdout)
[18:04:49.397]         ...future.stdout <- NULL
[18:04:49.397]     }
[18:04:49.397]     ...future.result$conditions <- ...future.conditions
[18:04:49.397]     ...future.result$finished <- base::Sys.time()
[18:04:49.397]     ...future.result
[18:04:49.397] }
[18:04:49.404] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[18:04:49.405] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[18:04:49.406] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[18:04:49.406] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[18:04:49.407] MultisessionFuture started
[18:04:49.407] - Launch lazy future ... done
[18:04:49.408] run() for ‘MultisessionFuture’ ... done
[18:04:49.408] result() for ClusterFuture ...
[18:04:49.408] receiveMessageFromWorker() for ClusterFuture ...
[18:04:49.408] - Validating connection of MultisessionFuture
[18:04:49.452] - received message: FutureResult
[18:04:49.452] - Received FutureResult
[18:04:49.452] - Erased future from FutureRegistry
[18:04:49.453] result() for ClusterFuture ...
[18:04:49.453] - result already collected: FutureResult
[18:04:49.453] result() for ClusterFuture ... done
[18:04:49.454] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:49.454] result() for ClusterFuture ... done
[18:04:49.454] result() for ClusterFuture ...
[18:04:49.454] - result already collected: FutureResult
[18:04:49.455] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:49.455] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:49.456] Searching for globals...
[18:04:49.461] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:49.462] Searching for globals ... DONE
[18:04:49.462] Resolving globals: TRUE
[18:04:49.462] Resolving any globals that are futures ...
[18:04:49.462] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:49.463] Resolving any globals that are futures ... DONE
[18:04:49.464] Resolving futures part of globals (recursively) ...
[18:04:49.464] resolve() on list ...
[18:04:49.464]  recursive: 99
[18:04:49.465]  length: 1
[18:04:49.465]  elements: ‘x’
[18:04:49.465]  length: 0 (resolved future 1)
[18:04:49.466] resolve() on list ... DONE
[18:04:49.466] - globals: [1] ‘x’
[18:04:49.466] Resolving futures part of globals (recursively) ... DONE
[18:04:49.466] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:49.467] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:49.468] - globals: [1] ‘x’
[18:04:49.468] 
[18:04:49.468] getGlobalsAndPackages() ... DONE
[18:04:49.469] run() for ‘Future’ ...
[18:04:49.469] - state: ‘created’
[18:04:49.469] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:49.495] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:49.495] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:49.496]   - Field: ‘node’
[18:04:49.496]   - Field: ‘label’
[18:04:49.496]   - Field: ‘local’
[18:04:49.496]   - Field: ‘owner’
[18:04:49.497]   - Field: ‘envir’
[18:04:49.497]   - Field: ‘workers’
[18:04:49.497]   - Field: ‘packages’
[18:04:49.497]   - Field: ‘gc’
[18:04:49.497]   - Field: ‘conditions’
[18:04:49.498]   - Field: ‘persistent’
[18:04:49.498]   - Field: ‘expr’
[18:04:49.498]   - Field: ‘uuid’
[18:04:49.498]   - Field: ‘seed’
[18:04:49.499]   - Field: ‘version’
[18:04:49.499]   - Field: ‘result’
[18:04:49.499]   - Field: ‘asynchronous’
[18:04:49.499]   - Field: ‘calls’
[18:04:49.500]   - Field: ‘globals’
[18:04:49.500]   - Field: ‘stdout’
[18:04:49.500]   - Field: ‘earlySignal’
[18:04:49.500]   - Field: ‘lazy’
[18:04:49.501]   - Field: ‘state’
[18:04:49.501] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:49.501] - Launch lazy future ...
[18:04:49.502] Packages needed by the future expression (n = 0): <none>
[18:04:49.502] Packages needed by future strategies (n = 0): <none>
[18:04:49.503] {
[18:04:49.503]     {
[18:04:49.503]         {
[18:04:49.503]             ...future.startTime <- base::Sys.time()
[18:04:49.503]             {
[18:04:49.503]                 {
[18:04:49.503]                   {
[18:04:49.503]                     {
[18:04:49.503]                       base::local({
[18:04:49.503]                         has_future <- base::requireNamespace("future", 
[18:04:49.503]                           quietly = TRUE)
[18:04:49.503]                         if (has_future) {
[18:04:49.503]                           ns <- base::getNamespace("future")
[18:04:49.503]                           version <- ns[[".package"]][["version"]]
[18:04:49.503]                           if (is.null(version)) 
[18:04:49.503]                             version <- utils::packageVersion("future")
[18:04:49.503]                         }
[18:04:49.503]                         else {
[18:04:49.503]                           version <- NULL
[18:04:49.503]                         }
[18:04:49.503]                         if (!has_future || version < "1.8.0") {
[18:04:49.503]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:49.503]                             "", base::R.version$version.string), 
[18:04:49.503]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:49.503]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:49.503]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:49.503]                               "release", "version")], collapse = " "), 
[18:04:49.503]                             hostname = base::Sys.info()[["nodename"]])
[18:04:49.503]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:49.503]                             info)
[18:04:49.503]                           info <- base::paste(info, collapse = "; ")
[18:04:49.503]                           if (!has_future) {
[18:04:49.503]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:49.503]                               info)
[18:04:49.503]                           }
[18:04:49.503]                           else {
[18:04:49.503]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:49.503]                               info, version)
[18:04:49.503]                           }
[18:04:49.503]                           base::stop(msg)
[18:04:49.503]                         }
[18:04:49.503]                       })
[18:04:49.503]                     }
[18:04:49.503]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:49.503]                     base::options(mc.cores = 1L)
[18:04:49.503]                   }
[18:04:49.503]                   ...future.strategy.old <- future::plan("list")
[18:04:49.503]                   options(future.plan = NULL)
[18:04:49.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:49.503]                 }
[18:04:49.503]                 ...future.workdir <- getwd()
[18:04:49.503]             }
[18:04:49.503]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:49.503]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:49.503]         }
[18:04:49.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:49.503]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:49.503]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:49.503]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:49.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:49.503]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:49.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:49.503]             base::names(...future.oldOptions))
[18:04:49.503]     }
[18:04:49.503]     if (FALSE) {
[18:04:49.503]     }
[18:04:49.503]     else {
[18:04:49.503]         if (TRUE) {
[18:04:49.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:49.503]                 open = "w")
[18:04:49.503]         }
[18:04:49.503]         else {
[18:04:49.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:49.503]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:49.503]         }
[18:04:49.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:49.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:49.503]             base::sink(type = "output", split = FALSE)
[18:04:49.503]             base::close(...future.stdout)
[18:04:49.503]         }, add = TRUE)
[18:04:49.503]     }
[18:04:49.503]     ...future.frame <- base::sys.nframe()
[18:04:49.503]     ...future.conditions <- base::list()
[18:04:49.503]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:49.503]     if (FALSE) {
[18:04:49.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:49.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:49.503]     }
[18:04:49.503]     ...future.result <- base::tryCatch({
[18:04:49.503]         base::withCallingHandlers({
[18:04:49.503]             ...future.value <- base::withVisible(base::local({
[18:04:49.503]                 ...future.makeSendCondition <- base::local({
[18:04:49.503]                   sendCondition <- NULL
[18:04:49.503]                   function(frame = 1L) {
[18:04:49.503]                     if (is.function(sendCondition)) 
[18:04:49.503]                       return(sendCondition)
[18:04:49.503]                     ns <- getNamespace("parallel")
[18:04:49.503]                     if (exists("sendData", mode = "function", 
[18:04:49.503]                       envir = ns)) {
[18:04:49.503]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:49.503]                         envir = ns)
[18:04:49.503]                       envir <- sys.frame(frame)
[18:04:49.503]                       master <- NULL
[18:04:49.503]                       while (!identical(envir, .GlobalEnv) && 
[18:04:49.503]                         !identical(envir, emptyenv())) {
[18:04:49.503]                         if (exists("master", mode = "list", envir = envir, 
[18:04:49.503]                           inherits = FALSE)) {
[18:04:49.503]                           master <- get("master", mode = "list", 
[18:04:49.503]                             envir = envir, inherits = FALSE)
[18:04:49.503]                           if (inherits(master, c("SOCKnode", 
[18:04:49.503]                             "SOCK0node"))) {
[18:04:49.503]                             sendCondition <<- function(cond) {
[18:04:49.503]                               data <- list(type = "VALUE", value = cond, 
[18:04:49.503]                                 success = TRUE)
[18:04:49.503]                               parallel_sendData(master, data)
[18:04:49.503]                             }
[18:04:49.503]                             return(sendCondition)
[18:04:49.503]                           }
[18:04:49.503]                         }
[18:04:49.503]                         frame <- frame + 1L
[18:04:49.503]                         envir <- sys.frame(frame)
[18:04:49.503]                       }
[18:04:49.503]                     }
[18:04:49.503]                     sendCondition <<- function(cond) NULL
[18:04:49.503]                   }
[18:04:49.503]                 })
[18:04:49.503]                 withCallingHandlers({
[18:04:49.503]                   {
[18:04:49.503]                     x$a <- 1
[18:04:49.503]                     x
[18:04:49.503]                   }
[18:04:49.503]                 }, immediateCondition = function(cond) {
[18:04:49.503]                   sendCondition <- ...future.makeSendCondition()
[18:04:49.503]                   sendCondition(cond)
[18:04:49.503]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.503]                   {
[18:04:49.503]                     inherits <- base::inherits
[18:04:49.503]                     invokeRestart <- base::invokeRestart
[18:04:49.503]                     is.null <- base::is.null
[18:04:49.503]                     muffled <- FALSE
[18:04:49.503]                     if (inherits(cond, "message")) {
[18:04:49.503]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:49.503]                       if (muffled) 
[18:04:49.503]                         invokeRestart("muffleMessage")
[18:04:49.503]                     }
[18:04:49.503]                     else if (inherits(cond, "warning")) {
[18:04:49.503]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:49.503]                       if (muffled) 
[18:04:49.503]                         invokeRestart("muffleWarning")
[18:04:49.503]                     }
[18:04:49.503]                     else if (inherits(cond, "condition")) {
[18:04:49.503]                       if (!is.null(pattern)) {
[18:04:49.503]                         computeRestarts <- base::computeRestarts
[18:04:49.503]                         grepl <- base::grepl
[18:04:49.503]                         restarts <- computeRestarts(cond)
[18:04:49.503]                         for (restart in restarts) {
[18:04:49.503]                           name <- restart$name
[18:04:49.503]                           if (is.null(name)) 
[18:04:49.503]                             next
[18:04:49.503]                           if (!grepl(pattern, name)) 
[18:04:49.503]                             next
[18:04:49.503]                           invokeRestart(restart)
[18:04:49.503]                           muffled <- TRUE
[18:04:49.503]                           break
[18:04:49.503]                         }
[18:04:49.503]                       }
[18:04:49.503]                     }
[18:04:49.503]                     invisible(muffled)
[18:04:49.503]                   }
[18:04:49.503]                   muffleCondition(cond)
[18:04:49.503]                 })
[18:04:49.503]             }))
[18:04:49.503]             future::FutureResult(value = ...future.value$value, 
[18:04:49.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.503]                   ...future.rng), globalenv = if (FALSE) 
[18:04:49.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:49.503]                     ...future.globalenv.names))
[18:04:49.503]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:49.503]         }, condition = base::local({
[18:04:49.503]             c <- base::c
[18:04:49.503]             inherits <- base::inherits
[18:04:49.503]             invokeRestart <- base::invokeRestart
[18:04:49.503]             length <- base::length
[18:04:49.503]             list <- base::list
[18:04:49.503]             seq.int <- base::seq.int
[18:04:49.503]             signalCondition <- base::signalCondition
[18:04:49.503]             sys.calls <- base::sys.calls
[18:04:49.503]             `[[` <- base::`[[`
[18:04:49.503]             `+` <- base::`+`
[18:04:49.503]             `<<-` <- base::`<<-`
[18:04:49.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:49.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:49.503]                   3L)]
[18:04:49.503]             }
[18:04:49.503]             function(cond) {
[18:04:49.503]                 is_error <- inherits(cond, "error")
[18:04:49.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:49.503]                   NULL)
[18:04:49.503]                 if (is_error) {
[18:04:49.503]                   sessionInformation <- function() {
[18:04:49.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:49.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:49.503]                       search = base::search(), system = base::Sys.info())
[18:04:49.503]                   }
[18:04:49.503]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:49.503]                     cond$call), session = sessionInformation(), 
[18:04:49.503]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:49.503]                   signalCondition(cond)
[18:04:49.503]                 }
[18:04:49.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:49.503]                 "immediateCondition"))) {
[18:04:49.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:49.503]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:49.503]                   if (TRUE && !signal) {
[18:04:49.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.503]                     {
[18:04:49.503]                       inherits <- base::inherits
[18:04:49.503]                       invokeRestart <- base::invokeRestart
[18:04:49.503]                       is.null <- base::is.null
[18:04:49.503]                       muffled <- FALSE
[18:04:49.503]                       if (inherits(cond, "message")) {
[18:04:49.503]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.503]                         if (muffled) 
[18:04:49.503]                           invokeRestart("muffleMessage")
[18:04:49.503]                       }
[18:04:49.503]                       else if (inherits(cond, "warning")) {
[18:04:49.503]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.503]                         if (muffled) 
[18:04:49.503]                           invokeRestart("muffleWarning")
[18:04:49.503]                       }
[18:04:49.503]                       else if (inherits(cond, "condition")) {
[18:04:49.503]                         if (!is.null(pattern)) {
[18:04:49.503]                           computeRestarts <- base::computeRestarts
[18:04:49.503]                           grepl <- base::grepl
[18:04:49.503]                           restarts <- computeRestarts(cond)
[18:04:49.503]                           for (restart in restarts) {
[18:04:49.503]                             name <- restart$name
[18:04:49.503]                             if (is.null(name)) 
[18:04:49.503]                               next
[18:04:49.503]                             if (!grepl(pattern, name)) 
[18:04:49.503]                               next
[18:04:49.503]                             invokeRestart(restart)
[18:04:49.503]                             muffled <- TRUE
[18:04:49.503]                             break
[18:04:49.503]                           }
[18:04:49.503]                         }
[18:04:49.503]                       }
[18:04:49.503]                       invisible(muffled)
[18:04:49.503]                     }
[18:04:49.503]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.503]                   }
[18:04:49.503]                 }
[18:04:49.503]                 else {
[18:04:49.503]                   if (TRUE) {
[18:04:49.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.503]                     {
[18:04:49.503]                       inherits <- base::inherits
[18:04:49.503]                       invokeRestart <- base::invokeRestart
[18:04:49.503]                       is.null <- base::is.null
[18:04:49.503]                       muffled <- FALSE
[18:04:49.503]                       if (inherits(cond, "message")) {
[18:04:49.503]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.503]                         if (muffled) 
[18:04:49.503]                           invokeRestart("muffleMessage")
[18:04:49.503]                       }
[18:04:49.503]                       else if (inherits(cond, "warning")) {
[18:04:49.503]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.503]                         if (muffled) 
[18:04:49.503]                           invokeRestart("muffleWarning")
[18:04:49.503]                       }
[18:04:49.503]                       else if (inherits(cond, "condition")) {
[18:04:49.503]                         if (!is.null(pattern)) {
[18:04:49.503]                           computeRestarts <- base::computeRestarts
[18:04:49.503]                           grepl <- base::grepl
[18:04:49.503]                           restarts <- computeRestarts(cond)
[18:04:49.503]                           for (restart in restarts) {
[18:04:49.503]                             name <- restart$name
[18:04:49.503]                             if (is.null(name)) 
[18:04:49.503]                               next
[18:04:49.503]                             if (!grepl(pattern, name)) 
[18:04:49.503]                               next
[18:04:49.503]                             invokeRestart(restart)
[18:04:49.503]                             muffled <- TRUE
[18:04:49.503]                             break
[18:04:49.503]                           }
[18:04:49.503]                         }
[18:04:49.503]                       }
[18:04:49.503]                       invisible(muffled)
[18:04:49.503]                     }
[18:04:49.503]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.503]                   }
[18:04:49.503]                 }
[18:04:49.503]             }
[18:04:49.503]         }))
[18:04:49.503]     }, error = function(ex) {
[18:04:49.503]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:49.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.503]                 ...future.rng), started = ...future.startTime, 
[18:04:49.503]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:49.503]             version = "1.8"), class = "FutureResult")
[18:04:49.503]     }, finally = {
[18:04:49.503]         if (!identical(...future.workdir, getwd())) 
[18:04:49.503]             setwd(...future.workdir)
[18:04:49.503]         {
[18:04:49.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:49.503]                 ...future.oldOptions$nwarnings <- NULL
[18:04:49.503]             }
[18:04:49.503]             base::options(...future.oldOptions)
[18:04:49.503]             if (.Platform$OS.type == "windows") {
[18:04:49.503]                 old_names <- names(...future.oldEnvVars)
[18:04:49.503]                 envs <- base::Sys.getenv()
[18:04:49.503]                 names <- names(envs)
[18:04:49.503]                 common <- intersect(names, old_names)
[18:04:49.503]                 added <- setdiff(names, old_names)
[18:04:49.503]                 removed <- setdiff(old_names, names)
[18:04:49.503]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:49.503]                   envs[common]]
[18:04:49.503]                 NAMES <- toupper(changed)
[18:04:49.503]                 args <- list()
[18:04:49.503]                 for (kk in seq_along(NAMES)) {
[18:04:49.503]                   name <- changed[[kk]]
[18:04:49.503]                   NAME <- NAMES[[kk]]
[18:04:49.503]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.503]                     next
[18:04:49.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.503]                 }
[18:04:49.503]                 NAMES <- toupper(added)
[18:04:49.503]                 for (kk in seq_along(NAMES)) {
[18:04:49.503]                   name <- added[[kk]]
[18:04:49.503]                   NAME <- NAMES[[kk]]
[18:04:49.503]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.503]                     next
[18:04:49.503]                   args[[name]] <- ""
[18:04:49.503]                 }
[18:04:49.503]                 NAMES <- toupper(removed)
[18:04:49.503]                 for (kk in seq_along(NAMES)) {
[18:04:49.503]                   name <- removed[[kk]]
[18:04:49.503]                   NAME <- NAMES[[kk]]
[18:04:49.503]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.503]                     next
[18:04:49.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.503]                 }
[18:04:49.503]                 if (length(args) > 0) 
[18:04:49.503]                   base::do.call(base::Sys.setenv, args = args)
[18:04:49.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:49.503]             }
[18:04:49.503]             else {
[18:04:49.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:49.503]             }
[18:04:49.503]             {
[18:04:49.503]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:49.503]                   0L) {
[18:04:49.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:49.503]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:49.503]                   base::options(opts)
[18:04:49.503]                 }
[18:04:49.503]                 {
[18:04:49.503]                   {
[18:04:49.503]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:49.503]                     NULL
[18:04:49.503]                   }
[18:04:49.503]                   options(future.plan = NULL)
[18:04:49.503]                   if (is.na(NA_character_)) 
[18:04:49.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:49.503]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:49.503]                     .init = FALSE)
[18:04:49.503]                 }
[18:04:49.503]             }
[18:04:49.503]         }
[18:04:49.503]     })
[18:04:49.503]     if (TRUE) {
[18:04:49.503]         base::sink(type = "output", split = FALSE)
[18:04:49.503]         if (TRUE) {
[18:04:49.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:49.503]         }
[18:04:49.503]         else {
[18:04:49.503]             ...future.result["stdout"] <- base::list(NULL)
[18:04:49.503]         }
[18:04:49.503]         base::close(...future.stdout)
[18:04:49.503]         ...future.stdout <- NULL
[18:04:49.503]     }
[18:04:49.503]     ...future.result$conditions <- ...future.conditions
[18:04:49.503]     ...future.result$finished <- base::Sys.time()
[18:04:49.503]     ...future.result
[18:04:49.503] }
[18:04:49.508] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[18:04:49.509] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[18:04:49.510] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[18:04:49.510] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[18:04:49.511] MultisessionFuture started
[18:04:49.511] - Launch lazy future ... done
[18:04:49.512] run() for ‘MultisessionFuture’ ... done
[18:04:49.512] result() for ClusterFuture ...
[18:04:49.512] receiveMessageFromWorker() for ClusterFuture ...
[18:04:49.513] - Validating connection of MultisessionFuture
[18:04:49.562] - received message: FutureResult
[18:04:49.562] - Received FutureResult
[18:04:49.562] - Erased future from FutureRegistry
[18:04:49.563] result() for ClusterFuture ...
[18:04:49.563] - result already collected: FutureResult
[18:04:49.563] result() for ClusterFuture ... done
[18:04:49.563] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:49.564] result() for ClusterFuture ... done
[18:04:49.564] result() for ClusterFuture ...
[18:04:49.564] - result already collected: FutureResult
[18:04:49.564] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:49.566] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:49.566] Searching for globals...
[18:04:49.571] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:49.572] Searching for globals ... DONE
[18:04:49.572] Resolving globals: TRUE
[18:04:49.572] Resolving any globals that are futures ...
[18:04:49.573] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:49.573] Resolving any globals that are futures ... DONE
[18:04:49.574] Resolving futures part of globals (recursively) ...
[18:04:49.574] resolve() on list ...
[18:04:49.575]  recursive: 99
[18:04:49.575]  length: 1
[18:04:49.575]  elements: ‘x’
[18:04:49.575]  length: 0 (resolved future 1)
[18:04:49.576] resolve() on list ... DONE
[18:04:49.576] - globals: [1] ‘x’
[18:04:49.576] Resolving futures part of globals (recursively) ... DONE
[18:04:49.577] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:49.578] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:49.578] - globals: [1] ‘x’
[18:04:49.578] 
[18:04:49.578] getGlobalsAndPackages() ... DONE
[18:04:49.579] run() for ‘Future’ ...
[18:04:49.579] - state: ‘created’
[18:04:49.580] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:49.607] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:49.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:49.608]   - Field: ‘node’
[18:04:49.608]   - Field: ‘label’
[18:04:49.608]   - Field: ‘local’
[18:04:49.609]   - Field: ‘owner’
[18:04:49.609]   - Field: ‘envir’
[18:04:49.609]   - Field: ‘workers’
[18:04:49.609]   - Field: ‘packages’
[18:04:49.609]   - Field: ‘gc’
[18:04:49.610]   - Field: ‘conditions’
[18:04:49.610]   - Field: ‘persistent’
[18:04:49.610]   - Field: ‘expr’
[18:04:49.610]   - Field: ‘uuid’
[18:04:49.610]   - Field: ‘seed’
[18:04:49.611]   - Field: ‘version’
[18:04:49.611]   - Field: ‘result’
[18:04:49.611]   - Field: ‘asynchronous’
[18:04:49.611]   - Field: ‘calls’
[18:04:49.611]   - Field: ‘globals’
[18:04:49.612]   - Field: ‘stdout’
[18:04:49.612]   - Field: ‘earlySignal’
[18:04:49.612]   - Field: ‘lazy’
[18:04:49.613]   - Field: ‘state’
[18:04:49.613] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:49.613] - Launch lazy future ...
[18:04:49.614] Packages needed by the future expression (n = 0): <none>
[18:04:49.614] Packages needed by future strategies (n = 0): <none>
[18:04:49.615] {
[18:04:49.615]     {
[18:04:49.615]         {
[18:04:49.615]             ...future.startTime <- base::Sys.time()
[18:04:49.615]             {
[18:04:49.615]                 {
[18:04:49.615]                   {
[18:04:49.615]                     {
[18:04:49.615]                       base::local({
[18:04:49.615]                         has_future <- base::requireNamespace("future", 
[18:04:49.615]                           quietly = TRUE)
[18:04:49.615]                         if (has_future) {
[18:04:49.615]                           ns <- base::getNamespace("future")
[18:04:49.615]                           version <- ns[[".package"]][["version"]]
[18:04:49.615]                           if (is.null(version)) 
[18:04:49.615]                             version <- utils::packageVersion("future")
[18:04:49.615]                         }
[18:04:49.615]                         else {
[18:04:49.615]                           version <- NULL
[18:04:49.615]                         }
[18:04:49.615]                         if (!has_future || version < "1.8.0") {
[18:04:49.615]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:49.615]                             "", base::R.version$version.string), 
[18:04:49.615]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:49.615]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:49.615]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:49.615]                               "release", "version")], collapse = " "), 
[18:04:49.615]                             hostname = base::Sys.info()[["nodename"]])
[18:04:49.615]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:49.615]                             info)
[18:04:49.615]                           info <- base::paste(info, collapse = "; ")
[18:04:49.615]                           if (!has_future) {
[18:04:49.615]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:49.615]                               info)
[18:04:49.615]                           }
[18:04:49.615]                           else {
[18:04:49.615]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:49.615]                               info, version)
[18:04:49.615]                           }
[18:04:49.615]                           base::stop(msg)
[18:04:49.615]                         }
[18:04:49.615]                       })
[18:04:49.615]                     }
[18:04:49.615]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:49.615]                     base::options(mc.cores = 1L)
[18:04:49.615]                   }
[18:04:49.615]                   ...future.strategy.old <- future::plan("list")
[18:04:49.615]                   options(future.plan = NULL)
[18:04:49.615]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.615]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:49.615]                 }
[18:04:49.615]                 ...future.workdir <- getwd()
[18:04:49.615]             }
[18:04:49.615]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:49.615]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:49.615]         }
[18:04:49.615]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:49.615]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:49.615]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:49.615]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:49.615]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:49.615]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:49.615]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:49.615]             base::names(...future.oldOptions))
[18:04:49.615]     }
[18:04:49.615]     if (FALSE) {
[18:04:49.615]     }
[18:04:49.615]     else {
[18:04:49.615]         if (TRUE) {
[18:04:49.615]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:49.615]                 open = "w")
[18:04:49.615]         }
[18:04:49.615]         else {
[18:04:49.615]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:49.615]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:49.615]         }
[18:04:49.615]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:49.615]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:49.615]             base::sink(type = "output", split = FALSE)
[18:04:49.615]             base::close(...future.stdout)
[18:04:49.615]         }, add = TRUE)
[18:04:49.615]     }
[18:04:49.615]     ...future.frame <- base::sys.nframe()
[18:04:49.615]     ...future.conditions <- base::list()
[18:04:49.615]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:49.615]     if (FALSE) {
[18:04:49.615]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:49.615]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:49.615]     }
[18:04:49.615]     ...future.result <- base::tryCatch({
[18:04:49.615]         base::withCallingHandlers({
[18:04:49.615]             ...future.value <- base::withVisible(base::local({
[18:04:49.615]                 ...future.makeSendCondition <- base::local({
[18:04:49.615]                   sendCondition <- NULL
[18:04:49.615]                   function(frame = 1L) {
[18:04:49.615]                     if (is.function(sendCondition)) 
[18:04:49.615]                       return(sendCondition)
[18:04:49.615]                     ns <- getNamespace("parallel")
[18:04:49.615]                     if (exists("sendData", mode = "function", 
[18:04:49.615]                       envir = ns)) {
[18:04:49.615]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:49.615]                         envir = ns)
[18:04:49.615]                       envir <- sys.frame(frame)
[18:04:49.615]                       master <- NULL
[18:04:49.615]                       while (!identical(envir, .GlobalEnv) && 
[18:04:49.615]                         !identical(envir, emptyenv())) {
[18:04:49.615]                         if (exists("master", mode = "list", envir = envir, 
[18:04:49.615]                           inherits = FALSE)) {
[18:04:49.615]                           master <- get("master", mode = "list", 
[18:04:49.615]                             envir = envir, inherits = FALSE)
[18:04:49.615]                           if (inherits(master, c("SOCKnode", 
[18:04:49.615]                             "SOCK0node"))) {
[18:04:49.615]                             sendCondition <<- function(cond) {
[18:04:49.615]                               data <- list(type = "VALUE", value = cond, 
[18:04:49.615]                                 success = TRUE)
[18:04:49.615]                               parallel_sendData(master, data)
[18:04:49.615]                             }
[18:04:49.615]                             return(sendCondition)
[18:04:49.615]                           }
[18:04:49.615]                         }
[18:04:49.615]                         frame <- frame + 1L
[18:04:49.615]                         envir <- sys.frame(frame)
[18:04:49.615]                       }
[18:04:49.615]                     }
[18:04:49.615]                     sendCondition <<- function(cond) NULL
[18:04:49.615]                   }
[18:04:49.615]                 })
[18:04:49.615]                 withCallingHandlers({
[18:04:49.615]                   {
[18:04:49.615]                     x$a <- 1
[18:04:49.615]                     x
[18:04:49.615]                   }
[18:04:49.615]                 }, immediateCondition = function(cond) {
[18:04:49.615]                   sendCondition <- ...future.makeSendCondition()
[18:04:49.615]                   sendCondition(cond)
[18:04:49.615]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.615]                   {
[18:04:49.615]                     inherits <- base::inherits
[18:04:49.615]                     invokeRestart <- base::invokeRestart
[18:04:49.615]                     is.null <- base::is.null
[18:04:49.615]                     muffled <- FALSE
[18:04:49.615]                     if (inherits(cond, "message")) {
[18:04:49.615]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:49.615]                       if (muffled) 
[18:04:49.615]                         invokeRestart("muffleMessage")
[18:04:49.615]                     }
[18:04:49.615]                     else if (inherits(cond, "warning")) {
[18:04:49.615]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:49.615]                       if (muffled) 
[18:04:49.615]                         invokeRestart("muffleWarning")
[18:04:49.615]                     }
[18:04:49.615]                     else if (inherits(cond, "condition")) {
[18:04:49.615]                       if (!is.null(pattern)) {
[18:04:49.615]                         computeRestarts <- base::computeRestarts
[18:04:49.615]                         grepl <- base::grepl
[18:04:49.615]                         restarts <- computeRestarts(cond)
[18:04:49.615]                         for (restart in restarts) {
[18:04:49.615]                           name <- restart$name
[18:04:49.615]                           if (is.null(name)) 
[18:04:49.615]                             next
[18:04:49.615]                           if (!grepl(pattern, name)) 
[18:04:49.615]                             next
[18:04:49.615]                           invokeRestart(restart)
[18:04:49.615]                           muffled <- TRUE
[18:04:49.615]                           break
[18:04:49.615]                         }
[18:04:49.615]                       }
[18:04:49.615]                     }
[18:04:49.615]                     invisible(muffled)
[18:04:49.615]                   }
[18:04:49.615]                   muffleCondition(cond)
[18:04:49.615]                 })
[18:04:49.615]             }))
[18:04:49.615]             future::FutureResult(value = ...future.value$value, 
[18:04:49.615]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.615]                   ...future.rng), globalenv = if (FALSE) 
[18:04:49.615]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:49.615]                     ...future.globalenv.names))
[18:04:49.615]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:49.615]         }, condition = base::local({
[18:04:49.615]             c <- base::c
[18:04:49.615]             inherits <- base::inherits
[18:04:49.615]             invokeRestart <- base::invokeRestart
[18:04:49.615]             length <- base::length
[18:04:49.615]             list <- base::list
[18:04:49.615]             seq.int <- base::seq.int
[18:04:49.615]             signalCondition <- base::signalCondition
[18:04:49.615]             sys.calls <- base::sys.calls
[18:04:49.615]             `[[` <- base::`[[`
[18:04:49.615]             `+` <- base::`+`
[18:04:49.615]             `<<-` <- base::`<<-`
[18:04:49.615]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:49.615]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:49.615]                   3L)]
[18:04:49.615]             }
[18:04:49.615]             function(cond) {
[18:04:49.615]                 is_error <- inherits(cond, "error")
[18:04:49.615]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:49.615]                   NULL)
[18:04:49.615]                 if (is_error) {
[18:04:49.615]                   sessionInformation <- function() {
[18:04:49.615]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:49.615]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:49.615]                       search = base::search(), system = base::Sys.info())
[18:04:49.615]                   }
[18:04:49.615]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.615]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:49.615]                     cond$call), session = sessionInformation(), 
[18:04:49.615]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:49.615]                   signalCondition(cond)
[18:04:49.615]                 }
[18:04:49.615]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:49.615]                 "immediateCondition"))) {
[18:04:49.615]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:49.615]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.615]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:49.615]                   if (TRUE && !signal) {
[18:04:49.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.615]                     {
[18:04:49.615]                       inherits <- base::inherits
[18:04:49.615]                       invokeRestart <- base::invokeRestart
[18:04:49.615]                       is.null <- base::is.null
[18:04:49.615]                       muffled <- FALSE
[18:04:49.615]                       if (inherits(cond, "message")) {
[18:04:49.615]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.615]                         if (muffled) 
[18:04:49.615]                           invokeRestart("muffleMessage")
[18:04:49.615]                       }
[18:04:49.615]                       else if (inherits(cond, "warning")) {
[18:04:49.615]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.615]                         if (muffled) 
[18:04:49.615]                           invokeRestart("muffleWarning")
[18:04:49.615]                       }
[18:04:49.615]                       else if (inherits(cond, "condition")) {
[18:04:49.615]                         if (!is.null(pattern)) {
[18:04:49.615]                           computeRestarts <- base::computeRestarts
[18:04:49.615]                           grepl <- base::grepl
[18:04:49.615]                           restarts <- computeRestarts(cond)
[18:04:49.615]                           for (restart in restarts) {
[18:04:49.615]                             name <- restart$name
[18:04:49.615]                             if (is.null(name)) 
[18:04:49.615]                               next
[18:04:49.615]                             if (!grepl(pattern, name)) 
[18:04:49.615]                               next
[18:04:49.615]                             invokeRestart(restart)
[18:04:49.615]                             muffled <- TRUE
[18:04:49.615]                             break
[18:04:49.615]                           }
[18:04:49.615]                         }
[18:04:49.615]                       }
[18:04:49.615]                       invisible(muffled)
[18:04:49.615]                     }
[18:04:49.615]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.615]                   }
[18:04:49.615]                 }
[18:04:49.615]                 else {
[18:04:49.615]                   if (TRUE) {
[18:04:49.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.615]                     {
[18:04:49.615]                       inherits <- base::inherits
[18:04:49.615]                       invokeRestart <- base::invokeRestart
[18:04:49.615]                       is.null <- base::is.null
[18:04:49.615]                       muffled <- FALSE
[18:04:49.615]                       if (inherits(cond, "message")) {
[18:04:49.615]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.615]                         if (muffled) 
[18:04:49.615]                           invokeRestart("muffleMessage")
[18:04:49.615]                       }
[18:04:49.615]                       else if (inherits(cond, "warning")) {
[18:04:49.615]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.615]                         if (muffled) 
[18:04:49.615]                           invokeRestart("muffleWarning")
[18:04:49.615]                       }
[18:04:49.615]                       else if (inherits(cond, "condition")) {
[18:04:49.615]                         if (!is.null(pattern)) {
[18:04:49.615]                           computeRestarts <- base::computeRestarts
[18:04:49.615]                           grepl <- base::grepl
[18:04:49.615]                           restarts <- computeRestarts(cond)
[18:04:49.615]                           for (restart in restarts) {
[18:04:49.615]                             name <- restart$name
[18:04:49.615]                             if (is.null(name)) 
[18:04:49.615]                               next
[18:04:49.615]                             if (!grepl(pattern, name)) 
[18:04:49.615]                               next
[18:04:49.615]                             invokeRestart(restart)
[18:04:49.615]                             muffled <- TRUE
[18:04:49.615]                             break
[18:04:49.615]                           }
[18:04:49.615]                         }
[18:04:49.615]                       }
[18:04:49.615]                       invisible(muffled)
[18:04:49.615]                     }
[18:04:49.615]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.615]                   }
[18:04:49.615]                 }
[18:04:49.615]             }
[18:04:49.615]         }))
[18:04:49.615]     }, error = function(ex) {
[18:04:49.615]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:49.615]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.615]                 ...future.rng), started = ...future.startTime, 
[18:04:49.615]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:49.615]             version = "1.8"), class = "FutureResult")
[18:04:49.615]     }, finally = {
[18:04:49.615]         if (!identical(...future.workdir, getwd())) 
[18:04:49.615]             setwd(...future.workdir)
[18:04:49.615]         {
[18:04:49.615]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:49.615]                 ...future.oldOptions$nwarnings <- NULL
[18:04:49.615]             }
[18:04:49.615]             base::options(...future.oldOptions)
[18:04:49.615]             if (.Platform$OS.type == "windows") {
[18:04:49.615]                 old_names <- names(...future.oldEnvVars)
[18:04:49.615]                 envs <- base::Sys.getenv()
[18:04:49.615]                 names <- names(envs)
[18:04:49.615]                 common <- intersect(names, old_names)
[18:04:49.615]                 added <- setdiff(names, old_names)
[18:04:49.615]                 removed <- setdiff(old_names, names)
[18:04:49.615]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:49.615]                   envs[common]]
[18:04:49.615]                 NAMES <- toupper(changed)
[18:04:49.615]                 args <- list()
[18:04:49.615]                 for (kk in seq_along(NAMES)) {
[18:04:49.615]                   name <- changed[[kk]]
[18:04:49.615]                   NAME <- NAMES[[kk]]
[18:04:49.615]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.615]                     next
[18:04:49.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.615]                 }
[18:04:49.615]                 NAMES <- toupper(added)
[18:04:49.615]                 for (kk in seq_along(NAMES)) {
[18:04:49.615]                   name <- added[[kk]]
[18:04:49.615]                   NAME <- NAMES[[kk]]
[18:04:49.615]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.615]                     next
[18:04:49.615]                   args[[name]] <- ""
[18:04:49.615]                 }
[18:04:49.615]                 NAMES <- toupper(removed)
[18:04:49.615]                 for (kk in seq_along(NAMES)) {
[18:04:49.615]                   name <- removed[[kk]]
[18:04:49.615]                   NAME <- NAMES[[kk]]
[18:04:49.615]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.615]                     next
[18:04:49.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.615]                 }
[18:04:49.615]                 if (length(args) > 0) 
[18:04:49.615]                   base::do.call(base::Sys.setenv, args = args)
[18:04:49.615]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:49.615]             }
[18:04:49.615]             else {
[18:04:49.615]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:49.615]             }
[18:04:49.615]             {
[18:04:49.615]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:49.615]                   0L) {
[18:04:49.615]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:49.615]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:49.615]                   base::options(opts)
[18:04:49.615]                 }
[18:04:49.615]                 {
[18:04:49.615]                   {
[18:04:49.615]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:49.615]                     NULL
[18:04:49.615]                   }
[18:04:49.615]                   options(future.plan = NULL)
[18:04:49.615]                   if (is.na(NA_character_)) 
[18:04:49.615]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.615]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:49.615]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:49.615]                     .init = FALSE)
[18:04:49.615]                 }
[18:04:49.615]             }
[18:04:49.615]         }
[18:04:49.615]     })
[18:04:49.615]     if (TRUE) {
[18:04:49.615]         base::sink(type = "output", split = FALSE)
[18:04:49.615]         if (TRUE) {
[18:04:49.615]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:49.615]         }
[18:04:49.615]         else {
[18:04:49.615]             ...future.result["stdout"] <- base::list(NULL)
[18:04:49.615]         }
[18:04:49.615]         base::close(...future.stdout)
[18:04:49.615]         ...future.stdout <- NULL
[18:04:49.615]     }
[18:04:49.615]     ...future.result$conditions <- ...future.conditions
[18:04:49.615]     ...future.result$finished <- base::Sys.time()
[18:04:49.615]     ...future.result
[18:04:49.615] }
[18:04:49.620] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[18:04:49.620] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[18:04:49.621] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[18:04:49.621] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[18:04:49.622] MultisessionFuture started
[18:04:49.623] - Launch lazy future ... done
[18:04:49.623] run() for ‘MultisessionFuture’ ... done
[18:04:49.623] result() for ClusterFuture ...
[18:04:49.623] receiveMessageFromWorker() for ClusterFuture ...
[18:04:49.624] - Validating connection of MultisessionFuture
[18:04:49.665] - received message: FutureResult
[18:04:49.666] - Received FutureResult
[18:04:49.666] - Erased future from FutureRegistry
[18:04:49.666] result() for ClusterFuture ...
[18:04:49.666] - result already collected: FutureResult
[18:04:49.667] result() for ClusterFuture ... done
[18:04:49.667] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:49.667] result() for ClusterFuture ... done
[18:04:49.667] result() for ClusterFuture ...
[18:04:49.667] - result already collected: FutureResult
[18:04:49.668] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:49.669] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:49.669] Searching for globals...
[18:04:49.673] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:49.673] Searching for globals ... DONE
[18:04:49.673] Resolving globals: TRUE
[18:04:49.673] Resolving any globals that are futures ...
[18:04:49.674] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[18:04:49.674] Resolving any globals that are futures ... DONE
[18:04:49.674] Resolving futures part of globals (recursively) ...
[18:04:49.675] resolve() on list ...
[18:04:49.675]  recursive: 99
[18:04:49.675]  length: 1
[18:04:49.675]  elements: ‘x’
[18:04:49.676]  length: 0 (resolved future 1)
[18:04:49.676] resolve() on list ... DONE
[18:04:49.676] - globals: [1] ‘x’
[18:04:49.676] Resolving futures part of globals (recursively) ... DONE
[18:04:49.677] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:49.677] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:49.677] - globals: [1] ‘x’
[18:04:49.678] 
[18:04:49.678] getGlobalsAndPackages() ... DONE
[18:04:49.678] run() for ‘Future’ ...
[18:04:49.679] - state: ‘created’
[18:04:49.679] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:49.701] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:49.701] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:49.702]   - Field: ‘node’
[18:04:49.702]   - Field: ‘label’
[18:04:49.702]   - Field: ‘local’
[18:04:49.702]   - Field: ‘owner’
[18:04:49.702]   - Field: ‘envir’
[18:04:49.703]   - Field: ‘workers’
[18:04:49.703]   - Field: ‘packages’
[18:04:49.703]   - Field: ‘gc’
[18:04:49.703]   - Field: ‘conditions’
[18:04:49.703]   - Field: ‘persistent’
[18:04:49.704]   - Field: ‘expr’
[18:04:49.704]   - Field: ‘uuid’
[18:04:49.704]   - Field: ‘seed’
[18:04:49.704]   - Field: ‘version’
[18:04:49.704]   - Field: ‘result’
[18:04:49.705]   - Field: ‘asynchronous’
[18:04:49.705]   - Field: ‘calls’
[18:04:49.705]   - Field: ‘globals’
[18:04:49.705]   - Field: ‘stdout’
[18:04:49.705]   - Field: ‘earlySignal’
[18:04:49.705]   - Field: ‘lazy’
[18:04:49.706]   - Field: ‘state’
[18:04:49.706] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:49.706] - Launch lazy future ...
[18:04:49.707] Packages needed by the future expression (n = 0): <none>
[18:04:49.707] Packages needed by future strategies (n = 0): <none>
[18:04:49.708] {
[18:04:49.708]     {
[18:04:49.708]         {
[18:04:49.708]             ...future.startTime <- base::Sys.time()
[18:04:49.708]             {
[18:04:49.708]                 {
[18:04:49.708]                   {
[18:04:49.708]                     {
[18:04:49.708]                       base::local({
[18:04:49.708]                         has_future <- base::requireNamespace("future", 
[18:04:49.708]                           quietly = TRUE)
[18:04:49.708]                         if (has_future) {
[18:04:49.708]                           ns <- base::getNamespace("future")
[18:04:49.708]                           version <- ns[[".package"]][["version"]]
[18:04:49.708]                           if (is.null(version)) 
[18:04:49.708]                             version <- utils::packageVersion("future")
[18:04:49.708]                         }
[18:04:49.708]                         else {
[18:04:49.708]                           version <- NULL
[18:04:49.708]                         }
[18:04:49.708]                         if (!has_future || version < "1.8.0") {
[18:04:49.708]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:49.708]                             "", base::R.version$version.string), 
[18:04:49.708]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:49.708]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:49.708]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:49.708]                               "release", "version")], collapse = " "), 
[18:04:49.708]                             hostname = base::Sys.info()[["nodename"]])
[18:04:49.708]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:49.708]                             info)
[18:04:49.708]                           info <- base::paste(info, collapse = "; ")
[18:04:49.708]                           if (!has_future) {
[18:04:49.708]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:49.708]                               info)
[18:04:49.708]                           }
[18:04:49.708]                           else {
[18:04:49.708]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:49.708]                               info, version)
[18:04:49.708]                           }
[18:04:49.708]                           base::stop(msg)
[18:04:49.708]                         }
[18:04:49.708]                       })
[18:04:49.708]                     }
[18:04:49.708]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:49.708]                     base::options(mc.cores = 1L)
[18:04:49.708]                   }
[18:04:49.708]                   ...future.strategy.old <- future::plan("list")
[18:04:49.708]                   options(future.plan = NULL)
[18:04:49.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:49.708]                 }
[18:04:49.708]                 ...future.workdir <- getwd()
[18:04:49.708]             }
[18:04:49.708]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:49.708]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:49.708]         }
[18:04:49.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:49.708]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:49.708]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:49.708]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:49.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:49.708]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:49.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:49.708]             base::names(...future.oldOptions))
[18:04:49.708]     }
[18:04:49.708]     if (FALSE) {
[18:04:49.708]     }
[18:04:49.708]     else {
[18:04:49.708]         if (TRUE) {
[18:04:49.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:49.708]                 open = "w")
[18:04:49.708]         }
[18:04:49.708]         else {
[18:04:49.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:49.708]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:49.708]         }
[18:04:49.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:49.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:49.708]             base::sink(type = "output", split = FALSE)
[18:04:49.708]             base::close(...future.stdout)
[18:04:49.708]         }, add = TRUE)
[18:04:49.708]     }
[18:04:49.708]     ...future.frame <- base::sys.nframe()
[18:04:49.708]     ...future.conditions <- base::list()
[18:04:49.708]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:49.708]     if (FALSE) {
[18:04:49.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:49.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:49.708]     }
[18:04:49.708]     ...future.result <- base::tryCatch({
[18:04:49.708]         base::withCallingHandlers({
[18:04:49.708]             ...future.value <- base::withVisible(base::local({
[18:04:49.708]                 ...future.makeSendCondition <- base::local({
[18:04:49.708]                   sendCondition <- NULL
[18:04:49.708]                   function(frame = 1L) {
[18:04:49.708]                     if (is.function(sendCondition)) 
[18:04:49.708]                       return(sendCondition)
[18:04:49.708]                     ns <- getNamespace("parallel")
[18:04:49.708]                     if (exists("sendData", mode = "function", 
[18:04:49.708]                       envir = ns)) {
[18:04:49.708]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:49.708]                         envir = ns)
[18:04:49.708]                       envir <- sys.frame(frame)
[18:04:49.708]                       master <- NULL
[18:04:49.708]                       while (!identical(envir, .GlobalEnv) && 
[18:04:49.708]                         !identical(envir, emptyenv())) {
[18:04:49.708]                         if (exists("master", mode = "list", envir = envir, 
[18:04:49.708]                           inherits = FALSE)) {
[18:04:49.708]                           master <- get("master", mode = "list", 
[18:04:49.708]                             envir = envir, inherits = FALSE)
[18:04:49.708]                           if (inherits(master, c("SOCKnode", 
[18:04:49.708]                             "SOCK0node"))) {
[18:04:49.708]                             sendCondition <<- function(cond) {
[18:04:49.708]                               data <- list(type = "VALUE", value = cond, 
[18:04:49.708]                                 success = TRUE)
[18:04:49.708]                               parallel_sendData(master, data)
[18:04:49.708]                             }
[18:04:49.708]                             return(sendCondition)
[18:04:49.708]                           }
[18:04:49.708]                         }
[18:04:49.708]                         frame <- frame + 1L
[18:04:49.708]                         envir <- sys.frame(frame)
[18:04:49.708]                       }
[18:04:49.708]                     }
[18:04:49.708]                     sendCondition <<- function(cond) NULL
[18:04:49.708]                   }
[18:04:49.708]                 })
[18:04:49.708]                 withCallingHandlers({
[18:04:49.708]                   {
[18:04:49.708]                     x$a <- 1
[18:04:49.708]                     x
[18:04:49.708]                   }
[18:04:49.708]                 }, immediateCondition = function(cond) {
[18:04:49.708]                   sendCondition <- ...future.makeSendCondition()
[18:04:49.708]                   sendCondition(cond)
[18:04:49.708]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.708]                   {
[18:04:49.708]                     inherits <- base::inherits
[18:04:49.708]                     invokeRestart <- base::invokeRestart
[18:04:49.708]                     is.null <- base::is.null
[18:04:49.708]                     muffled <- FALSE
[18:04:49.708]                     if (inherits(cond, "message")) {
[18:04:49.708]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:49.708]                       if (muffled) 
[18:04:49.708]                         invokeRestart("muffleMessage")
[18:04:49.708]                     }
[18:04:49.708]                     else if (inherits(cond, "warning")) {
[18:04:49.708]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:49.708]                       if (muffled) 
[18:04:49.708]                         invokeRestart("muffleWarning")
[18:04:49.708]                     }
[18:04:49.708]                     else if (inherits(cond, "condition")) {
[18:04:49.708]                       if (!is.null(pattern)) {
[18:04:49.708]                         computeRestarts <- base::computeRestarts
[18:04:49.708]                         grepl <- base::grepl
[18:04:49.708]                         restarts <- computeRestarts(cond)
[18:04:49.708]                         for (restart in restarts) {
[18:04:49.708]                           name <- restart$name
[18:04:49.708]                           if (is.null(name)) 
[18:04:49.708]                             next
[18:04:49.708]                           if (!grepl(pattern, name)) 
[18:04:49.708]                             next
[18:04:49.708]                           invokeRestart(restart)
[18:04:49.708]                           muffled <- TRUE
[18:04:49.708]                           break
[18:04:49.708]                         }
[18:04:49.708]                       }
[18:04:49.708]                     }
[18:04:49.708]                     invisible(muffled)
[18:04:49.708]                   }
[18:04:49.708]                   muffleCondition(cond)
[18:04:49.708]                 })
[18:04:49.708]             }))
[18:04:49.708]             future::FutureResult(value = ...future.value$value, 
[18:04:49.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.708]                   ...future.rng), globalenv = if (FALSE) 
[18:04:49.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:49.708]                     ...future.globalenv.names))
[18:04:49.708]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:49.708]         }, condition = base::local({
[18:04:49.708]             c <- base::c
[18:04:49.708]             inherits <- base::inherits
[18:04:49.708]             invokeRestart <- base::invokeRestart
[18:04:49.708]             length <- base::length
[18:04:49.708]             list <- base::list
[18:04:49.708]             seq.int <- base::seq.int
[18:04:49.708]             signalCondition <- base::signalCondition
[18:04:49.708]             sys.calls <- base::sys.calls
[18:04:49.708]             `[[` <- base::`[[`
[18:04:49.708]             `+` <- base::`+`
[18:04:49.708]             `<<-` <- base::`<<-`
[18:04:49.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:49.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:49.708]                   3L)]
[18:04:49.708]             }
[18:04:49.708]             function(cond) {
[18:04:49.708]                 is_error <- inherits(cond, "error")
[18:04:49.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:49.708]                   NULL)
[18:04:49.708]                 if (is_error) {
[18:04:49.708]                   sessionInformation <- function() {
[18:04:49.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:49.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:49.708]                       search = base::search(), system = base::Sys.info())
[18:04:49.708]                   }
[18:04:49.708]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:49.708]                     cond$call), session = sessionInformation(), 
[18:04:49.708]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:49.708]                   signalCondition(cond)
[18:04:49.708]                 }
[18:04:49.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:49.708]                 "immediateCondition"))) {
[18:04:49.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:49.708]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:49.708]                   if (TRUE && !signal) {
[18:04:49.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.708]                     {
[18:04:49.708]                       inherits <- base::inherits
[18:04:49.708]                       invokeRestart <- base::invokeRestart
[18:04:49.708]                       is.null <- base::is.null
[18:04:49.708]                       muffled <- FALSE
[18:04:49.708]                       if (inherits(cond, "message")) {
[18:04:49.708]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.708]                         if (muffled) 
[18:04:49.708]                           invokeRestart("muffleMessage")
[18:04:49.708]                       }
[18:04:49.708]                       else if (inherits(cond, "warning")) {
[18:04:49.708]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.708]                         if (muffled) 
[18:04:49.708]                           invokeRestart("muffleWarning")
[18:04:49.708]                       }
[18:04:49.708]                       else if (inherits(cond, "condition")) {
[18:04:49.708]                         if (!is.null(pattern)) {
[18:04:49.708]                           computeRestarts <- base::computeRestarts
[18:04:49.708]                           grepl <- base::grepl
[18:04:49.708]                           restarts <- computeRestarts(cond)
[18:04:49.708]                           for (restart in restarts) {
[18:04:49.708]                             name <- restart$name
[18:04:49.708]                             if (is.null(name)) 
[18:04:49.708]                               next
[18:04:49.708]                             if (!grepl(pattern, name)) 
[18:04:49.708]                               next
[18:04:49.708]                             invokeRestart(restart)
[18:04:49.708]                             muffled <- TRUE
[18:04:49.708]                             break
[18:04:49.708]                           }
[18:04:49.708]                         }
[18:04:49.708]                       }
[18:04:49.708]                       invisible(muffled)
[18:04:49.708]                     }
[18:04:49.708]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.708]                   }
[18:04:49.708]                 }
[18:04:49.708]                 else {
[18:04:49.708]                   if (TRUE) {
[18:04:49.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.708]                     {
[18:04:49.708]                       inherits <- base::inherits
[18:04:49.708]                       invokeRestart <- base::invokeRestart
[18:04:49.708]                       is.null <- base::is.null
[18:04:49.708]                       muffled <- FALSE
[18:04:49.708]                       if (inherits(cond, "message")) {
[18:04:49.708]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.708]                         if (muffled) 
[18:04:49.708]                           invokeRestart("muffleMessage")
[18:04:49.708]                       }
[18:04:49.708]                       else if (inherits(cond, "warning")) {
[18:04:49.708]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.708]                         if (muffled) 
[18:04:49.708]                           invokeRestart("muffleWarning")
[18:04:49.708]                       }
[18:04:49.708]                       else if (inherits(cond, "condition")) {
[18:04:49.708]                         if (!is.null(pattern)) {
[18:04:49.708]                           computeRestarts <- base::computeRestarts
[18:04:49.708]                           grepl <- base::grepl
[18:04:49.708]                           restarts <- computeRestarts(cond)
[18:04:49.708]                           for (restart in restarts) {
[18:04:49.708]                             name <- restart$name
[18:04:49.708]                             if (is.null(name)) 
[18:04:49.708]                               next
[18:04:49.708]                             if (!grepl(pattern, name)) 
[18:04:49.708]                               next
[18:04:49.708]                             invokeRestart(restart)
[18:04:49.708]                             muffled <- TRUE
[18:04:49.708]                             break
[18:04:49.708]                           }
[18:04:49.708]                         }
[18:04:49.708]                       }
[18:04:49.708]                       invisible(muffled)
[18:04:49.708]                     }
[18:04:49.708]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.708]                   }
[18:04:49.708]                 }
[18:04:49.708]             }
[18:04:49.708]         }))
[18:04:49.708]     }, error = function(ex) {
[18:04:49.708]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:49.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.708]                 ...future.rng), started = ...future.startTime, 
[18:04:49.708]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:49.708]             version = "1.8"), class = "FutureResult")
[18:04:49.708]     }, finally = {
[18:04:49.708]         if (!identical(...future.workdir, getwd())) 
[18:04:49.708]             setwd(...future.workdir)
[18:04:49.708]         {
[18:04:49.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:49.708]                 ...future.oldOptions$nwarnings <- NULL
[18:04:49.708]             }
[18:04:49.708]             base::options(...future.oldOptions)
[18:04:49.708]             if (.Platform$OS.type == "windows") {
[18:04:49.708]                 old_names <- names(...future.oldEnvVars)
[18:04:49.708]                 envs <- base::Sys.getenv()
[18:04:49.708]                 names <- names(envs)
[18:04:49.708]                 common <- intersect(names, old_names)
[18:04:49.708]                 added <- setdiff(names, old_names)
[18:04:49.708]                 removed <- setdiff(old_names, names)
[18:04:49.708]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:49.708]                   envs[common]]
[18:04:49.708]                 NAMES <- toupper(changed)
[18:04:49.708]                 args <- list()
[18:04:49.708]                 for (kk in seq_along(NAMES)) {
[18:04:49.708]                   name <- changed[[kk]]
[18:04:49.708]                   NAME <- NAMES[[kk]]
[18:04:49.708]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.708]                     next
[18:04:49.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.708]                 }
[18:04:49.708]                 NAMES <- toupper(added)
[18:04:49.708]                 for (kk in seq_along(NAMES)) {
[18:04:49.708]                   name <- added[[kk]]
[18:04:49.708]                   NAME <- NAMES[[kk]]
[18:04:49.708]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.708]                     next
[18:04:49.708]                   args[[name]] <- ""
[18:04:49.708]                 }
[18:04:49.708]                 NAMES <- toupper(removed)
[18:04:49.708]                 for (kk in seq_along(NAMES)) {
[18:04:49.708]                   name <- removed[[kk]]
[18:04:49.708]                   NAME <- NAMES[[kk]]
[18:04:49.708]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.708]                     next
[18:04:49.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.708]                 }
[18:04:49.708]                 if (length(args) > 0) 
[18:04:49.708]                   base::do.call(base::Sys.setenv, args = args)
[18:04:49.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:49.708]             }
[18:04:49.708]             else {
[18:04:49.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:49.708]             }
[18:04:49.708]             {
[18:04:49.708]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:49.708]                   0L) {
[18:04:49.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:49.708]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:49.708]                   base::options(opts)
[18:04:49.708]                 }
[18:04:49.708]                 {
[18:04:49.708]                   {
[18:04:49.708]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:49.708]                     NULL
[18:04:49.708]                   }
[18:04:49.708]                   options(future.plan = NULL)
[18:04:49.708]                   if (is.na(NA_character_)) 
[18:04:49.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:49.708]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:49.708]                     .init = FALSE)
[18:04:49.708]                 }
[18:04:49.708]             }
[18:04:49.708]         }
[18:04:49.708]     })
[18:04:49.708]     if (TRUE) {
[18:04:49.708]         base::sink(type = "output", split = FALSE)
[18:04:49.708]         if (TRUE) {
[18:04:49.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:49.708]         }
[18:04:49.708]         else {
[18:04:49.708]             ...future.result["stdout"] <- base::list(NULL)
[18:04:49.708]         }
[18:04:49.708]         base::close(...future.stdout)
[18:04:49.708]         ...future.stdout <- NULL
[18:04:49.708]     }
[18:04:49.708]     ...future.result$conditions <- ...future.conditions
[18:04:49.708]     ...future.result$finished <- base::Sys.time()
[18:04:49.708]     ...future.result
[18:04:49.708] }
[18:04:49.713] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[18:04:49.713] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[18:04:49.714] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[18:04:49.714] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[18:04:49.715] MultisessionFuture started
[18:04:49.715] - Launch lazy future ... done
[18:04:49.716] run() for ‘MultisessionFuture’ ... done
[18:04:49.716] result() for ClusterFuture ...
[18:04:49.716] receiveMessageFromWorker() for ClusterFuture ...
[18:04:49.716] - Validating connection of MultisessionFuture
[18:04:49.759] - received message: FutureResult
[18:04:49.760] - Received FutureResult
[18:04:49.760] - Erased future from FutureRegistry
[18:04:49.760] result() for ClusterFuture ...
[18:04:49.760] - result already collected: FutureResult
[18:04:49.761] result() for ClusterFuture ... done
[18:04:49.761] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:49.761] result() for ClusterFuture ... done
[18:04:49.761] result() for ClusterFuture ...
[18:04:49.761] - result already collected: FutureResult
[18:04:49.762] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:49.762] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:49.763] Searching for globals...
[18:04:49.768] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[18:04:49.768] Searching for globals ... DONE
[18:04:49.769] Resolving globals: TRUE
[18:04:49.769] Resolving any globals that are futures ...
[18:04:49.769] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[18:04:49.769] Resolving any globals that are futures ... DONE
[18:04:49.770] 
[18:04:49.770] 
[18:04:49.771] getGlobalsAndPackages() ... DONE
[18:04:49.771] run() for ‘Future’ ...
[18:04:49.771] - state: ‘created’
[18:04:49.772] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:49.797] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:49.798] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:49.798]   - Field: ‘node’
[18:04:49.798]   - Field: ‘label’
[18:04:49.798]   - Field: ‘local’
[18:04:49.799]   - Field: ‘owner’
[18:04:49.799]   - Field: ‘envir’
[18:04:49.799]   - Field: ‘workers’
[18:04:49.799]   - Field: ‘packages’
[18:04:49.800]   - Field: ‘gc’
[18:04:49.800]   - Field: ‘conditions’
[18:04:49.800]   - Field: ‘persistent’
[18:04:49.800]   - Field: ‘expr’
[18:04:49.800]   - Field: ‘uuid’
[18:04:49.801]   - Field: ‘seed’
[18:04:49.801]   - Field: ‘version’
[18:04:49.801]   - Field: ‘result’
[18:04:49.801]   - Field: ‘asynchronous’
[18:04:49.801]   - Field: ‘calls’
[18:04:49.802]   - Field: ‘globals’
[18:04:49.802]   - Field: ‘stdout’
[18:04:49.802]   - Field: ‘earlySignal’
[18:04:49.802]   - Field: ‘lazy’
[18:04:49.802]   - Field: ‘state’
[18:04:49.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:49.803] - Launch lazy future ...
[18:04:49.803] Packages needed by the future expression (n = 0): <none>
[18:04:49.804] Packages needed by future strategies (n = 0): <none>
[18:04:49.805] {
[18:04:49.805]     {
[18:04:49.805]         {
[18:04:49.805]             ...future.startTime <- base::Sys.time()
[18:04:49.805]             {
[18:04:49.805]                 {
[18:04:49.805]                   {
[18:04:49.805]                     {
[18:04:49.805]                       base::local({
[18:04:49.805]                         has_future <- base::requireNamespace("future", 
[18:04:49.805]                           quietly = TRUE)
[18:04:49.805]                         if (has_future) {
[18:04:49.805]                           ns <- base::getNamespace("future")
[18:04:49.805]                           version <- ns[[".package"]][["version"]]
[18:04:49.805]                           if (is.null(version)) 
[18:04:49.805]                             version <- utils::packageVersion("future")
[18:04:49.805]                         }
[18:04:49.805]                         else {
[18:04:49.805]                           version <- NULL
[18:04:49.805]                         }
[18:04:49.805]                         if (!has_future || version < "1.8.0") {
[18:04:49.805]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:49.805]                             "", base::R.version$version.string), 
[18:04:49.805]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:49.805]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:49.805]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:49.805]                               "release", "version")], collapse = " "), 
[18:04:49.805]                             hostname = base::Sys.info()[["nodename"]])
[18:04:49.805]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:49.805]                             info)
[18:04:49.805]                           info <- base::paste(info, collapse = "; ")
[18:04:49.805]                           if (!has_future) {
[18:04:49.805]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:49.805]                               info)
[18:04:49.805]                           }
[18:04:49.805]                           else {
[18:04:49.805]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:49.805]                               info, version)
[18:04:49.805]                           }
[18:04:49.805]                           base::stop(msg)
[18:04:49.805]                         }
[18:04:49.805]                       })
[18:04:49.805]                     }
[18:04:49.805]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:49.805]                     base::options(mc.cores = 1L)
[18:04:49.805]                   }
[18:04:49.805]                   ...future.strategy.old <- future::plan("list")
[18:04:49.805]                   options(future.plan = NULL)
[18:04:49.805]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.805]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:49.805]                 }
[18:04:49.805]                 ...future.workdir <- getwd()
[18:04:49.805]             }
[18:04:49.805]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:49.805]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:49.805]         }
[18:04:49.805]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:49.805]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:49.805]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:49.805]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:49.805]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:49.805]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:49.805]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:49.805]             base::names(...future.oldOptions))
[18:04:49.805]     }
[18:04:49.805]     if (FALSE) {
[18:04:49.805]     }
[18:04:49.805]     else {
[18:04:49.805]         if (TRUE) {
[18:04:49.805]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:49.805]                 open = "w")
[18:04:49.805]         }
[18:04:49.805]         else {
[18:04:49.805]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:49.805]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:49.805]         }
[18:04:49.805]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:49.805]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:49.805]             base::sink(type = "output", split = FALSE)
[18:04:49.805]             base::close(...future.stdout)
[18:04:49.805]         }, add = TRUE)
[18:04:49.805]     }
[18:04:49.805]     ...future.frame <- base::sys.nframe()
[18:04:49.805]     ...future.conditions <- base::list()
[18:04:49.805]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:49.805]     if (FALSE) {
[18:04:49.805]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:49.805]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:49.805]     }
[18:04:49.805]     ...future.result <- base::tryCatch({
[18:04:49.805]         base::withCallingHandlers({
[18:04:49.805]             ...future.value <- base::withVisible(base::local({
[18:04:49.805]                 ...future.makeSendCondition <- base::local({
[18:04:49.805]                   sendCondition <- NULL
[18:04:49.805]                   function(frame = 1L) {
[18:04:49.805]                     if (is.function(sendCondition)) 
[18:04:49.805]                       return(sendCondition)
[18:04:49.805]                     ns <- getNamespace("parallel")
[18:04:49.805]                     if (exists("sendData", mode = "function", 
[18:04:49.805]                       envir = ns)) {
[18:04:49.805]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:49.805]                         envir = ns)
[18:04:49.805]                       envir <- sys.frame(frame)
[18:04:49.805]                       master <- NULL
[18:04:49.805]                       while (!identical(envir, .GlobalEnv) && 
[18:04:49.805]                         !identical(envir, emptyenv())) {
[18:04:49.805]                         if (exists("master", mode = "list", envir = envir, 
[18:04:49.805]                           inherits = FALSE)) {
[18:04:49.805]                           master <- get("master", mode = "list", 
[18:04:49.805]                             envir = envir, inherits = FALSE)
[18:04:49.805]                           if (inherits(master, c("SOCKnode", 
[18:04:49.805]                             "SOCK0node"))) {
[18:04:49.805]                             sendCondition <<- function(cond) {
[18:04:49.805]                               data <- list(type = "VALUE", value = cond, 
[18:04:49.805]                                 success = TRUE)
[18:04:49.805]                               parallel_sendData(master, data)
[18:04:49.805]                             }
[18:04:49.805]                             return(sendCondition)
[18:04:49.805]                           }
[18:04:49.805]                         }
[18:04:49.805]                         frame <- frame + 1L
[18:04:49.805]                         envir <- sys.frame(frame)
[18:04:49.805]                       }
[18:04:49.805]                     }
[18:04:49.805]                     sendCondition <<- function(cond) NULL
[18:04:49.805]                   }
[18:04:49.805]                 })
[18:04:49.805]                 withCallingHandlers({
[18:04:49.805]                   {
[18:04:49.805]                     x <- list(b = 2)
[18:04:49.805]                     x$a <- 1
[18:04:49.805]                     x
[18:04:49.805]                   }
[18:04:49.805]                 }, immediateCondition = function(cond) {
[18:04:49.805]                   sendCondition <- ...future.makeSendCondition()
[18:04:49.805]                   sendCondition(cond)
[18:04:49.805]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.805]                   {
[18:04:49.805]                     inherits <- base::inherits
[18:04:49.805]                     invokeRestart <- base::invokeRestart
[18:04:49.805]                     is.null <- base::is.null
[18:04:49.805]                     muffled <- FALSE
[18:04:49.805]                     if (inherits(cond, "message")) {
[18:04:49.805]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:49.805]                       if (muffled) 
[18:04:49.805]                         invokeRestart("muffleMessage")
[18:04:49.805]                     }
[18:04:49.805]                     else if (inherits(cond, "warning")) {
[18:04:49.805]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:49.805]                       if (muffled) 
[18:04:49.805]                         invokeRestart("muffleWarning")
[18:04:49.805]                     }
[18:04:49.805]                     else if (inherits(cond, "condition")) {
[18:04:49.805]                       if (!is.null(pattern)) {
[18:04:49.805]                         computeRestarts <- base::computeRestarts
[18:04:49.805]                         grepl <- base::grepl
[18:04:49.805]                         restarts <- computeRestarts(cond)
[18:04:49.805]                         for (restart in restarts) {
[18:04:49.805]                           name <- restart$name
[18:04:49.805]                           if (is.null(name)) 
[18:04:49.805]                             next
[18:04:49.805]                           if (!grepl(pattern, name)) 
[18:04:49.805]                             next
[18:04:49.805]                           invokeRestart(restart)
[18:04:49.805]                           muffled <- TRUE
[18:04:49.805]                           break
[18:04:49.805]                         }
[18:04:49.805]                       }
[18:04:49.805]                     }
[18:04:49.805]                     invisible(muffled)
[18:04:49.805]                   }
[18:04:49.805]                   muffleCondition(cond)
[18:04:49.805]                 })
[18:04:49.805]             }))
[18:04:49.805]             future::FutureResult(value = ...future.value$value, 
[18:04:49.805]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.805]                   ...future.rng), globalenv = if (FALSE) 
[18:04:49.805]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:49.805]                     ...future.globalenv.names))
[18:04:49.805]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:49.805]         }, condition = base::local({
[18:04:49.805]             c <- base::c
[18:04:49.805]             inherits <- base::inherits
[18:04:49.805]             invokeRestart <- base::invokeRestart
[18:04:49.805]             length <- base::length
[18:04:49.805]             list <- base::list
[18:04:49.805]             seq.int <- base::seq.int
[18:04:49.805]             signalCondition <- base::signalCondition
[18:04:49.805]             sys.calls <- base::sys.calls
[18:04:49.805]             `[[` <- base::`[[`
[18:04:49.805]             `+` <- base::`+`
[18:04:49.805]             `<<-` <- base::`<<-`
[18:04:49.805]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:49.805]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:49.805]                   3L)]
[18:04:49.805]             }
[18:04:49.805]             function(cond) {
[18:04:49.805]                 is_error <- inherits(cond, "error")
[18:04:49.805]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:49.805]                   NULL)
[18:04:49.805]                 if (is_error) {
[18:04:49.805]                   sessionInformation <- function() {
[18:04:49.805]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:49.805]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:49.805]                       search = base::search(), system = base::Sys.info())
[18:04:49.805]                   }
[18:04:49.805]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.805]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:49.805]                     cond$call), session = sessionInformation(), 
[18:04:49.805]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:49.805]                   signalCondition(cond)
[18:04:49.805]                 }
[18:04:49.805]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:49.805]                 "immediateCondition"))) {
[18:04:49.805]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:49.805]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.805]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:49.805]                   if (TRUE && !signal) {
[18:04:49.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.805]                     {
[18:04:49.805]                       inherits <- base::inherits
[18:04:49.805]                       invokeRestart <- base::invokeRestart
[18:04:49.805]                       is.null <- base::is.null
[18:04:49.805]                       muffled <- FALSE
[18:04:49.805]                       if (inherits(cond, "message")) {
[18:04:49.805]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.805]                         if (muffled) 
[18:04:49.805]                           invokeRestart("muffleMessage")
[18:04:49.805]                       }
[18:04:49.805]                       else if (inherits(cond, "warning")) {
[18:04:49.805]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.805]                         if (muffled) 
[18:04:49.805]                           invokeRestart("muffleWarning")
[18:04:49.805]                       }
[18:04:49.805]                       else if (inherits(cond, "condition")) {
[18:04:49.805]                         if (!is.null(pattern)) {
[18:04:49.805]                           computeRestarts <- base::computeRestarts
[18:04:49.805]                           grepl <- base::grepl
[18:04:49.805]                           restarts <- computeRestarts(cond)
[18:04:49.805]                           for (restart in restarts) {
[18:04:49.805]                             name <- restart$name
[18:04:49.805]                             if (is.null(name)) 
[18:04:49.805]                               next
[18:04:49.805]                             if (!grepl(pattern, name)) 
[18:04:49.805]                               next
[18:04:49.805]                             invokeRestart(restart)
[18:04:49.805]                             muffled <- TRUE
[18:04:49.805]                             break
[18:04:49.805]                           }
[18:04:49.805]                         }
[18:04:49.805]                       }
[18:04:49.805]                       invisible(muffled)
[18:04:49.805]                     }
[18:04:49.805]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.805]                   }
[18:04:49.805]                 }
[18:04:49.805]                 else {
[18:04:49.805]                   if (TRUE) {
[18:04:49.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.805]                     {
[18:04:49.805]                       inherits <- base::inherits
[18:04:49.805]                       invokeRestart <- base::invokeRestart
[18:04:49.805]                       is.null <- base::is.null
[18:04:49.805]                       muffled <- FALSE
[18:04:49.805]                       if (inherits(cond, "message")) {
[18:04:49.805]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.805]                         if (muffled) 
[18:04:49.805]                           invokeRestart("muffleMessage")
[18:04:49.805]                       }
[18:04:49.805]                       else if (inherits(cond, "warning")) {
[18:04:49.805]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.805]                         if (muffled) 
[18:04:49.805]                           invokeRestart("muffleWarning")
[18:04:49.805]                       }
[18:04:49.805]                       else if (inherits(cond, "condition")) {
[18:04:49.805]                         if (!is.null(pattern)) {
[18:04:49.805]                           computeRestarts <- base::computeRestarts
[18:04:49.805]                           grepl <- base::grepl
[18:04:49.805]                           restarts <- computeRestarts(cond)
[18:04:49.805]                           for (restart in restarts) {
[18:04:49.805]                             name <- restart$name
[18:04:49.805]                             if (is.null(name)) 
[18:04:49.805]                               next
[18:04:49.805]                             if (!grepl(pattern, name)) 
[18:04:49.805]                               next
[18:04:49.805]                             invokeRestart(restart)
[18:04:49.805]                             muffled <- TRUE
[18:04:49.805]                             break
[18:04:49.805]                           }
[18:04:49.805]                         }
[18:04:49.805]                       }
[18:04:49.805]                       invisible(muffled)
[18:04:49.805]                     }
[18:04:49.805]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.805]                   }
[18:04:49.805]                 }
[18:04:49.805]             }
[18:04:49.805]         }))
[18:04:49.805]     }, error = function(ex) {
[18:04:49.805]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:49.805]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.805]                 ...future.rng), started = ...future.startTime, 
[18:04:49.805]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:49.805]             version = "1.8"), class = "FutureResult")
[18:04:49.805]     }, finally = {
[18:04:49.805]         if (!identical(...future.workdir, getwd())) 
[18:04:49.805]             setwd(...future.workdir)
[18:04:49.805]         {
[18:04:49.805]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:49.805]                 ...future.oldOptions$nwarnings <- NULL
[18:04:49.805]             }
[18:04:49.805]             base::options(...future.oldOptions)
[18:04:49.805]             if (.Platform$OS.type == "windows") {
[18:04:49.805]                 old_names <- names(...future.oldEnvVars)
[18:04:49.805]                 envs <- base::Sys.getenv()
[18:04:49.805]                 names <- names(envs)
[18:04:49.805]                 common <- intersect(names, old_names)
[18:04:49.805]                 added <- setdiff(names, old_names)
[18:04:49.805]                 removed <- setdiff(old_names, names)
[18:04:49.805]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:49.805]                   envs[common]]
[18:04:49.805]                 NAMES <- toupper(changed)
[18:04:49.805]                 args <- list()
[18:04:49.805]                 for (kk in seq_along(NAMES)) {
[18:04:49.805]                   name <- changed[[kk]]
[18:04:49.805]                   NAME <- NAMES[[kk]]
[18:04:49.805]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.805]                     next
[18:04:49.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.805]                 }
[18:04:49.805]                 NAMES <- toupper(added)
[18:04:49.805]                 for (kk in seq_along(NAMES)) {
[18:04:49.805]                   name <- added[[kk]]
[18:04:49.805]                   NAME <- NAMES[[kk]]
[18:04:49.805]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.805]                     next
[18:04:49.805]                   args[[name]] <- ""
[18:04:49.805]                 }
[18:04:49.805]                 NAMES <- toupper(removed)
[18:04:49.805]                 for (kk in seq_along(NAMES)) {
[18:04:49.805]                   name <- removed[[kk]]
[18:04:49.805]                   NAME <- NAMES[[kk]]
[18:04:49.805]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.805]                     next
[18:04:49.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.805]                 }
[18:04:49.805]                 if (length(args) > 0) 
[18:04:49.805]                   base::do.call(base::Sys.setenv, args = args)
[18:04:49.805]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:49.805]             }
[18:04:49.805]             else {
[18:04:49.805]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:49.805]             }
[18:04:49.805]             {
[18:04:49.805]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:49.805]                   0L) {
[18:04:49.805]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:49.805]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:49.805]                   base::options(opts)
[18:04:49.805]                 }
[18:04:49.805]                 {
[18:04:49.805]                   {
[18:04:49.805]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:49.805]                     NULL
[18:04:49.805]                   }
[18:04:49.805]                   options(future.plan = NULL)
[18:04:49.805]                   if (is.na(NA_character_)) 
[18:04:49.805]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.805]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:49.805]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:49.805]                     .init = FALSE)
[18:04:49.805]                 }
[18:04:49.805]             }
[18:04:49.805]         }
[18:04:49.805]     })
[18:04:49.805]     if (TRUE) {
[18:04:49.805]         base::sink(type = "output", split = FALSE)
[18:04:49.805]         if (TRUE) {
[18:04:49.805]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:49.805]         }
[18:04:49.805]         else {
[18:04:49.805]             ...future.result["stdout"] <- base::list(NULL)
[18:04:49.805]         }
[18:04:49.805]         base::close(...future.stdout)
[18:04:49.805]         ...future.stdout <- NULL
[18:04:49.805]     }
[18:04:49.805]     ...future.result$conditions <- ...future.conditions
[18:04:49.805]     ...future.result$finished <- base::Sys.time()
[18:04:49.805]     ...future.result
[18:04:49.805] }
[18:04:49.811] MultisessionFuture started
[18:04:49.811] - Launch lazy future ... done
[18:04:49.811] run() for ‘MultisessionFuture’ ... done
[18:04:49.811] result() for ClusterFuture ...
[18:04:49.812] receiveMessageFromWorker() for ClusterFuture ...
[18:04:49.812] - Validating connection of MultisessionFuture
[18:04:49.855] - received message: FutureResult
[18:04:49.855] - Received FutureResult
[18:04:49.856] - Erased future from FutureRegistry
[18:04:49.856] result() for ClusterFuture ...
[18:04:49.856] - result already collected: FutureResult
[18:04:49.856] result() for ClusterFuture ... done
[18:04:49.856] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:49.857] result() for ClusterFuture ... done
[18:04:49.857] result() for ClusterFuture ...
[18:04:49.857] - result already collected: FutureResult
[18:04:49.857] result() for ClusterFuture ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:49.858] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:49.858] Searching for globals...
[18:04:49.863] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:49.863] Searching for globals ... DONE
[18:04:49.863] Resolving globals: TRUE
[18:04:49.864] Resolving any globals that are futures ...
[18:04:49.864] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:49.864] Resolving any globals that are futures ... DONE
[18:04:49.865] Resolving futures part of globals (recursively) ...
[18:04:49.865] resolve() on list ...
[18:04:49.866]  recursive: 99
[18:04:49.866]  length: 1
[18:04:49.866]  elements: ‘x’
[18:04:49.866]  length: 0 (resolved future 1)
[18:04:49.867] resolve() on list ... DONE
[18:04:49.867] - globals: [1] ‘x’
[18:04:49.867] Resolving futures part of globals (recursively) ... DONE
[18:04:49.867] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:49.868] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:49.868] - globals: [1] ‘x’
[18:04:49.869] 
[18:04:49.869] getGlobalsAndPackages() ... DONE
[18:04:49.869] run() for ‘Future’ ...
[18:04:49.870] - state: ‘created’
[18:04:49.870] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:49.895] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:49.895] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:49.895]   - Field: ‘node’
[18:04:49.896]   - Field: ‘label’
[18:04:49.896]   - Field: ‘local’
[18:04:49.896]   - Field: ‘owner’
[18:04:49.896]   - Field: ‘envir’
[18:04:49.897]   - Field: ‘workers’
[18:04:49.897]   - Field: ‘packages’
[18:04:49.897]   - Field: ‘gc’
[18:04:49.897]   - Field: ‘conditions’
[18:04:49.897]   - Field: ‘persistent’
[18:04:49.898]   - Field: ‘expr’
[18:04:49.898]   - Field: ‘uuid’
[18:04:49.898]   - Field: ‘seed’
[18:04:49.898]   - Field: ‘version’
[18:04:49.898]   - Field: ‘result’
[18:04:49.899]   - Field: ‘asynchronous’
[18:04:49.899]   - Field: ‘calls’
[18:04:49.899]   - Field: ‘globals’
[18:04:49.899]   - Field: ‘stdout’
[18:04:49.899]   - Field: ‘earlySignal’
[18:04:49.899]   - Field: ‘lazy’
[18:04:49.900]   - Field: ‘state’
[18:04:49.900] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:49.900] - Launch lazy future ...
[18:04:49.901] Packages needed by the future expression (n = 0): <none>
[18:04:49.901] Packages needed by future strategies (n = 0): <none>
[18:04:49.902] {
[18:04:49.902]     {
[18:04:49.902]         {
[18:04:49.902]             ...future.startTime <- base::Sys.time()
[18:04:49.902]             {
[18:04:49.902]                 {
[18:04:49.902]                   {
[18:04:49.902]                     {
[18:04:49.902]                       base::local({
[18:04:49.902]                         has_future <- base::requireNamespace("future", 
[18:04:49.902]                           quietly = TRUE)
[18:04:49.902]                         if (has_future) {
[18:04:49.902]                           ns <- base::getNamespace("future")
[18:04:49.902]                           version <- ns[[".package"]][["version"]]
[18:04:49.902]                           if (is.null(version)) 
[18:04:49.902]                             version <- utils::packageVersion("future")
[18:04:49.902]                         }
[18:04:49.902]                         else {
[18:04:49.902]                           version <- NULL
[18:04:49.902]                         }
[18:04:49.902]                         if (!has_future || version < "1.8.0") {
[18:04:49.902]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:49.902]                             "", base::R.version$version.string), 
[18:04:49.902]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:49.902]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:49.902]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:49.902]                               "release", "version")], collapse = " "), 
[18:04:49.902]                             hostname = base::Sys.info()[["nodename"]])
[18:04:49.902]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:49.902]                             info)
[18:04:49.902]                           info <- base::paste(info, collapse = "; ")
[18:04:49.902]                           if (!has_future) {
[18:04:49.902]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:49.902]                               info)
[18:04:49.902]                           }
[18:04:49.902]                           else {
[18:04:49.902]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:49.902]                               info, version)
[18:04:49.902]                           }
[18:04:49.902]                           base::stop(msg)
[18:04:49.902]                         }
[18:04:49.902]                       })
[18:04:49.902]                     }
[18:04:49.902]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:49.902]                     base::options(mc.cores = 1L)
[18:04:49.902]                   }
[18:04:49.902]                   ...future.strategy.old <- future::plan("list")
[18:04:49.902]                   options(future.plan = NULL)
[18:04:49.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:49.902]                 }
[18:04:49.902]                 ...future.workdir <- getwd()
[18:04:49.902]             }
[18:04:49.902]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:49.902]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:49.902]         }
[18:04:49.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:49.902]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:49.902]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:49.902]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:49.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:49.902]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:49.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:49.902]             base::names(...future.oldOptions))
[18:04:49.902]     }
[18:04:49.902]     if (FALSE) {
[18:04:49.902]     }
[18:04:49.902]     else {
[18:04:49.902]         if (TRUE) {
[18:04:49.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:49.902]                 open = "w")
[18:04:49.902]         }
[18:04:49.902]         else {
[18:04:49.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:49.902]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:49.902]         }
[18:04:49.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:49.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:49.902]             base::sink(type = "output", split = FALSE)
[18:04:49.902]             base::close(...future.stdout)
[18:04:49.902]         }, add = TRUE)
[18:04:49.902]     }
[18:04:49.902]     ...future.frame <- base::sys.nframe()
[18:04:49.902]     ...future.conditions <- base::list()
[18:04:49.902]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:49.902]     if (FALSE) {
[18:04:49.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:49.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:49.902]     }
[18:04:49.902]     ...future.result <- base::tryCatch({
[18:04:49.902]         base::withCallingHandlers({
[18:04:49.902]             ...future.value <- base::withVisible(base::local({
[18:04:49.902]                 ...future.makeSendCondition <- base::local({
[18:04:49.902]                   sendCondition <- NULL
[18:04:49.902]                   function(frame = 1L) {
[18:04:49.902]                     if (is.function(sendCondition)) 
[18:04:49.902]                       return(sendCondition)
[18:04:49.902]                     ns <- getNamespace("parallel")
[18:04:49.902]                     if (exists("sendData", mode = "function", 
[18:04:49.902]                       envir = ns)) {
[18:04:49.902]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:49.902]                         envir = ns)
[18:04:49.902]                       envir <- sys.frame(frame)
[18:04:49.902]                       master <- NULL
[18:04:49.902]                       while (!identical(envir, .GlobalEnv) && 
[18:04:49.902]                         !identical(envir, emptyenv())) {
[18:04:49.902]                         if (exists("master", mode = "list", envir = envir, 
[18:04:49.902]                           inherits = FALSE)) {
[18:04:49.902]                           master <- get("master", mode = "list", 
[18:04:49.902]                             envir = envir, inherits = FALSE)
[18:04:49.902]                           if (inherits(master, c("SOCKnode", 
[18:04:49.902]                             "SOCK0node"))) {
[18:04:49.902]                             sendCondition <<- function(cond) {
[18:04:49.902]                               data <- list(type = "VALUE", value = cond, 
[18:04:49.902]                                 success = TRUE)
[18:04:49.902]                               parallel_sendData(master, data)
[18:04:49.902]                             }
[18:04:49.902]                             return(sendCondition)
[18:04:49.902]                           }
[18:04:49.902]                         }
[18:04:49.902]                         frame <- frame + 1L
[18:04:49.902]                         envir <- sys.frame(frame)
[18:04:49.902]                       }
[18:04:49.902]                     }
[18:04:49.902]                     sendCondition <<- function(cond) NULL
[18:04:49.902]                   }
[18:04:49.902]                 })
[18:04:49.902]                 withCallingHandlers({
[18:04:49.902]                   {
[18:04:49.902]                     x[["a"]] <- 1
[18:04:49.902]                     x
[18:04:49.902]                   }
[18:04:49.902]                 }, immediateCondition = function(cond) {
[18:04:49.902]                   sendCondition <- ...future.makeSendCondition()
[18:04:49.902]                   sendCondition(cond)
[18:04:49.902]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.902]                   {
[18:04:49.902]                     inherits <- base::inherits
[18:04:49.902]                     invokeRestart <- base::invokeRestart
[18:04:49.902]                     is.null <- base::is.null
[18:04:49.902]                     muffled <- FALSE
[18:04:49.902]                     if (inherits(cond, "message")) {
[18:04:49.902]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:49.902]                       if (muffled) 
[18:04:49.902]                         invokeRestart("muffleMessage")
[18:04:49.902]                     }
[18:04:49.902]                     else if (inherits(cond, "warning")) {
[18:04:49.902]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:49.902]                       if (muffled) 
[18:04:49.902]                         invokeRestart("muffleWarning")
[18:04:49.902]                     }
[18:04:49.902]                     else if (inherits(cond, "condition")) {
[18:04:49.902]                       if (!is.null(pattern)) {
[18:04:49.902]                         computeRestarts <- base::computeRestarts
[18:04:49.902]                         grepl <- base::grepl
[18:04:49.902]                         restarts <- computeRestarts(cond)
[18:04:49.902]                         for (restart in restarts) {
[18:04:49.902]                           name <- restart$name
[18:04:49.902]                           if (is.null(name)) 
[18:04:49.902]                             next
[18:04:49.902]                           if (!grepl(pattern, name)) 
[18:04:49.902]                             next
[18:04:49.902]                           invokeRestart(restart)
[18:04:49.902]                           muffled <- TRUE
[18:04:49.902]                           break
[18:04:49.902]                         }
[18:04:49.902]                       }
[18:04:49.902]                     }
[18:04:49.902]                     invisible(muffled)
[18:04:49.902]                   }
[18:04:49.902]                   muffleCondition(cond)
[18:04:49.902]                 })
[18:04:49.902]             }))
[18:04:49.902]             future::FutureResult(value = ...future.value$value, 
[18:04:49.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.902]                   ...future.rng), globalenv = if (FALSE) 
[18:04:49.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:49.902]                     ...future.globalenv.names))
[18:04:49.902]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:49.902]         }, condition = base::local({
[18:04:49.902]             c <- base::c
[18:04:49.902]             inherits <- base::inherits
[18:04:49.902]             invokeRestart <- base::invokeRestart
[18:04:49.902]             length <- base::length
[18:04:49.902]             list <- base::list
[18:04:49.902]             seq.int <- base::seq.int
[18:04:49.902]             signalCondition <- base::signalCondition
[18:04:49.902]             sys.calls <- base::sys.calls
[18:04:49.902]             `[[` <- base::`[[`
[18:04:49.902]             `+` <- base::`+`
[18:04:49.902]             `<<-` <- base::`<<-`
[18:04:49.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:49.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:49.902]                   3L)]
[18:04:49.902]             }
[18:04:49.902]             function(cond) {
[18:04:49.902]                 is_error <- inherits(cond, "error")
[18:04:49.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:49.902]                   NULL)
[18:04:49.902]                 if (is_error) {
[18:04:49.902]                   sessionInformation <- function() {
[18:04:49.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:49.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:49.902]                       search = base::search(), system = base::Sys.info())
[18:04:49.902]                   }
[18:04:49.902]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:49.902]                     cond$call), session = sessionInformation(), 
[18:04:49.902]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:49.902]                   signalCondition(cond)
[18:04:49.902]                 }
[18:04:49.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:49.902]                 "immediateCondition"))) {
[18:04:49.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:49.902]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:49.902]                   if (TRUE && !signal) {
[18:04:49.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.902]                     {
[18:04:49.902]                       inherits <- base::inherits
[18:04:49.902]                       invokeRestart <- base::invokeRestart
[18:04:49.902]                       is.null <- base::is.null
[18:04:49.902]                       muffled <- FALSE
[18:04:49.902]                       if (inherits(cond, "message")) {
[18:04:49.902]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.902]                         if (muffled) 
[18:04:49.902]                           invokeRestart("muffleMessage")
[18:04:49.902]                       }
[18:04:49.902]                       else if (inherits(cond, "warning")) {
[18:04:49.902]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.902]                         if (muffled) 
[18:04:49.902]                           invokeRestart("muffleWarning")
[18:04:49.902]                       }
[18:04:49.902]                       else if (inherits(cond, "condition")) {
[18:04:49.902]                         if (!is.null(pattern)) {
[18:04:49.902]                           computeRestarts <- base::computeRestarts
[18:04:49.902]                           grepl <- base::grepl
[18:04:49.902]                           restarts <- computeRestarts(cond)
[18:04:49.902]                           for (restart in restarts) {
[18:04:49.902]                             name <- restart$name
[18:04:49.902]                             if (is.null(name)) 
[18:04:49.902]                               next
[18:04:49.902]                             if (!grepl(pattern, name)) 
[18:04:49.902]                               next
[18:04:49.902]                             invokeRestart(restart)
[18:04:49.902]                             muffled <- TRUE
[18:04:49.902]                             break
[18:04:49.902]                           }
[18:04:49.902]                         }
[18:04:49.902]                       }
[18:04:49.902]                       invisible(muffled)
[18:04:49.902]                     }
[18:04:49.902]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.902]                   }
[18:04:49.902]                 }
[18:04:49.902]                 else {
[18:04:49.902]                   if (TRUE) {
[18:04:49.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.902]                     {
[18:04:49.902]                       inherits <- base::inherits
[18:04:49.902]                       invokeRestart <- base::invokeRestart
[18:04:49.902]                       is.null <- base::is.null
[18:04:49.902]                       muffled <- FALSE
[18:04:49.902]                       if (inherits(cond, "message")) {
[18:04:49.902]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.902]                         if (muffled) 
[18:04:49.902]                           invokeRestart("muffleMessage")
[18:04:49.902]                       }
[18:04:49.902]                       else if (inherits(cond, "warning")) {
[18:04:49.902]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.902]                         if (muffled) 
[18:04:49.902]                           invokeRestart("muffleWarning")
[18:04:49.902]                       }
[18:04:49.902]                       else if (inherits(cond, "condition")) {
[18:04:49.902]                         if (!is.null(pattern)) {
[18:04:49.902]                           computeRestarts <- base::computeRestarts
[18:04:49.902]                           grepl <- base::grepl
[18:04:49.902]                           restarts <- computeRestarts(cond)
[18:04:49.902]                           for (restart in restarts) {
[18:04:49.902]                             name <- restart$name
[18:04:49.902]                             if (is.null(name)) 
[18:04:49.902]                               next
[18:04:49.902]                             if (!grepl(pattern, name)) 
[18:04:49.902]                               next
[18:04:49.902]                             invokeRestart(restart)
[18:04:49.902]                             muffled <- TRUE
[18:04:49.902]                             break
[18:04:49.902]                           }
[18:04:49.902]                         }
[18:04:49.902]                       }
[18:04:49.902]                       invisible(muffled)
[18:04:49.902]                     }
[18:04:49.902]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.902]                   }
[18:04:49.902]                 }
[18:04:49.902]             }
[18:04:49.902]         }))
[18:04:49.902]     }, error = function(ex) {
[18:04:49.902]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:49.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.902]                 ...future.rng), started = ...future.startTime, 
[18:04:49.902]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:49.902]             version = "1.8"), class = "FutureResult")
[18:04:49.902]     }, finally = {
[18:04:49.902]         if (!identical(...future.workdir, getwd())) 
[18:04:49.902]             setwd(...future.workdir)
[18:04:49.902]         {
[18:04:49.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:49.902]                 ...future.oldOptions$nwarnings <- NULL
[18:04:49.902]             }
[18:04:49.902]             base::options(...future.oldOptions)
[18:04:49.902]             if (.Platform$OS.type == "windows") {
[18:04:49.902]                 old_names <- names(...future.oldEnvVars)
[18:04:49.902]                 envs <- base::Sys.getenv()
[18:04:49.902]                 names <- names(envs)
[18:04:49.902]                 common <- intersect(names, old_names)
[18:04:49.902]                 added <- setdiff(names, old_names)
[18:04:49.902]                 removed <- setdiff(old_names, names)
[18:04:49.902]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:49.902]                   envs[common]]
[18:04:49.902]                 NAMES <- toupper(changed)
[18:04:49.902]                 args <- list()
[18:04:49.902]                 for (kk in seq_along(NAMES)) {
[18:04:49.902]                   name <- changed[[kk]]
[18:04:49.902]                   NAME <- NAMES[[kk]]
[18:04:49.902]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.902]                     next
[18:04:49.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.902]                 }
[18:04:49.902]                 NAMES <- toupper(added)
[18:04:49.902]                 for (kk in seq_along(NAMES)) {
[18:04:49.902]                   name <- added[[kk]]
[18:04:49.902]                   NAME <- NAMES[[kk]]
[18:04:49.902]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.902]                     next
[18:04:49.902]                   args[[name]] <- ""
[18:04:49.902]                 }
[18:04:49.902]                 NAMES <- toupper(removed)
[18:04:49.902]                 for (kk in seq_along(NAMES)) {
[18:04:49.902]                   name <- removed[[kk]]
[18:04:49.902]                   NAME <- NAMES[[kk]]
[18:04:49.902]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.902]                     next
[18:04:49.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.902]                 }
[18:04:49.902]                 if (length(args) > 0) 
[18:04:49.902]                   base::do.call(base::Sys.setenv, args = args)
[18:04:49.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:49.902]             }
[18:04:49.902]             else {
[18:04:49.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:49.902]             }
[18:04:49.902]             {
[18:04:49.902]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:49.902]                   0L) {
[18:04:49.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:49.902]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:49.902]                   base::options(opts)
[18:04:49.902]                 }
[18:04:49.902]                 {
[18:04:49.902]                   {
[18:04:49.902]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:49.902]                     NULL
[18:04:49.902]                   }
[18:04:49.902]                   options(future.plan = NULL)
[18:04:49.902]                   if (is.na(NA_character_)) 
[18:04:49.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:49.902]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:49.902]                     .init = FALSE)
[18:04:49.902]                 }
[18:04:49.902]             }
[18:04:49.902]         }
[18:04:49.902]     })
[18:04:49.902]     if (TRUE) {
[18:04:49.902]         base::sink(type = "output", split = FALSE)
[18:04:49.902]         if (TRUE) {
[18:04:49.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:49.902]         }
[18:04:49.902]         else {
[18:04:49.902]             ...future.result["stdout"] <- base::list(NULL)
[18:04:49.902]         }
[18:04:49.902]         base::close(...future.stdout)
[18:04:49.902]         ...future.stdout <- NULL
[18:04:49.902]     }
[18:04:49.902]     ...future.result$conditions <- ...future.conditions
[18:04:49.902]     ...future.result$finished <- base::Sys.time()
[18:04:49.902]     ...future.result
[18:04:49.902] }
[18:04:49.906] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[18:04:49.907] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[18:04:49.908] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[18:04:49.908] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[18:04:49.909] MultisessionFuture started
[18:04:49.909] - Launch lazy future ... done
[18:04:49.910] run() for ‘MultisessionFuture’ ... done
[18:04:49.910] result() for ClusterFuture ...
[18:04:49.910] receiveMessageFromWorker() for ClusterFuture ...
[18:04:49.910] - Validating connection of MultisessionFuture
[18:04:49.953] - received message: FutureResult
[18:04:49.954] - Received FutureResult
[18:04:49.954] - Erased future from FutureRegistry
[18:04:49.954] result() for ClusterFuture ...
[18:04:49.955] - result already collected: FutureResult
[18:04:49.955] result() for ClusterFuture ... done
[18:04:49.955] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:49.955] result() for ClusterFuture ... done
[18:04:49.955] result() for ClusterFuture ...
[18:04:49.956] - result already collected: FutureResult
[18:04:49.956] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:49.956] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:49.957] Searching for globals...
[18:04:49.961] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:49.962] Searching for globals ... DONE
[18:04:49.962] Resolving globals: TRUE
[18:04:49.962] Resolving any globals that are futures ...
[18:04:49.962] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:49.962] Resolving any globals that are futures ... DONE
[18:04:49.963] Resolving futures part of globals (recursively) ...
[18:04:49.964] resolve() on list ...
[18:04:49.964]  recursive: 99
[18:04:49.964]  length: 1
[18:04:49.964]  elements: ‘x’
[18:04:49.965]  length: 0 (resolved future 1)
[18:04:49.965] resolve() on list ... DONE
[18:04:49.965] - globals: [1] ‘x’
[18:04:49.965] Resolving futures part of globals (recursively) ... DONE
[18:04:49.966] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:49.966] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:49.967] - globals: [1] ‘x’
[18:04:49.967] 
[18:04:49.967] getGlobalsAndPackages() ... DONE
[18:04:49.968] run() for ‘Future’ ...
[18:04:49.968] - state: ‘created’
[18:04:49.968] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:49.993] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:49.993] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:49.993]   - Field: ‘node’
[18:04:49.993]   - Field: ‘label’
[18:04:49.994]   - Field: ‘local’
[18:04:49.994]   - Field: ‘owner’
[18:04:49.994]   - Field: ‘envir’
[18:04:49.994]   - Field: ‘workers’
[18:04:49.994]   - Field: ‘packages’
[18:04:49.995]   - Field: ‘gc’
[18:04:49.995]   - Field: ‘conditions’
[18:04:49.995]   - Field: ‘persistent’
[18:04:49.995]   - Field: ‘expr’
[18:04:49.995]   - Field: ‘uuid’
[18:04:49.996]   - Field: ‘seed’
[18:04:49.996]   - Field: ‘version’
[18:04:49.996]   - Field: ‘result’
[18:04:49.996]   - Field: ‘asynchronous’
[18:04:49.996]   - Field: ‘calls’
[18:04:49.997]   - Field: ‘globals’
[18:04:49.997]   - Field: ‘stdout’
[18:04:49.997]   - Field: ‘earlySignal’
[18:04:49.997]   - Field: ‘lazy’
[18:04:49.997]   - Field: ‘state’
[18:04:49.998] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:49.998] - Launch lazy future ...
[18:04:49.998] Packages needed by the future expression (n = 0): <none>
[18:04:49.999] Packages needed by future strategies (n = 0): <none>
[18:04:49.999] {
[18:04:49.999]     {
[18:04:49.999]         {
[18:04:49.999]             ...future.startTime <- base::Sys.time()
[18:04:49.999]             {
[18:04:49.999]                 {
[18:04:49.999]                   {
[18:04:49.999]                     {
[18:04:49.999]                       base::local({
[18:04:49.999]                         has_future <- base::requireNamespace("future", 
[18:04:49.999]                           quietly = TRUE)
[18:04:49.999]                         if (has_future) {
[18:04:49.999]                           ns <- base::getNamespace("future")
[18:04:49.999]                           version <- ns[[".package"]][["version"]]
[18:04:49.999]                           if (is.null(version)) 
[18:04:49.999]                             version <- utils::packageVersion("future")
[18:04:49.999]                         }
[18:04:49.999]                         else {
[18:04:49.999]                           version <- NULL
[18:04:49.999]                         }
[18:04:49.999]                         if (!has_future || version < "1.8.0") {
[18:04:49.999]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:49.999]                             "", base::R.version$version.string), 
[18:04:49.999]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:49.999]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:49.999]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:49.999]                               "release", "version")], collapse = " "), 
[18:04:49.999]                             hostname = base::Sys.info()[["nodename"]])
[18:04:49.999]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:49.999]                             info)
[18:04:49.999]                           info <- base::paste(info, collapse = "; ")
[18:04:49.999]                           if (!has_future) {
[18:04:49.999]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:49.999]                               info)
[18:04:49.999]                           }
[18:04:49.999]                           else {
[18:04:49.999]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:49.999]                               info, version)
[18:04:49.999]                           }
[18:04:49.999]                           base::stop(msg)
[18:04:49.999]                         }
[18:04:49.999]                       })
[18:04:49.999]                     }
[18:04:49.999]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:49.999]                     base::options(mc.cores = 1L)
[18:04:49.999]                   }
[18:04:49.999]                   ...future.strategy.old <- future::plan("list")
[18:04:49.999]                   options(future.plan = NULL)
[18:04:49.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:49.999]                 }
[18:04:49.999]                 ...future.workdir <- getwd()
[18:04:49.999]             }
[18:04:49.999]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:49.999]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:49.999]         }
[18:04:49.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:49.999]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:49.999]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:49.999]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:49.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:49.999]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:49.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:49.999]             base::names(...future.oldOptions))
[18:04:49.999]     }
[18:04:49.999]     if (FALSE) {
[18:04:49.999]     }
[18:04:49.999]     else {
[18:04:49.999]         if (TRUE) {
[18:04:49.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:49.999]                 open = "w")
[18:04:49.999]         }
[18:04:49.999]         else {
[18:04:49.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:49.999]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:49.999]         }
[18:04:49.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:49.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:49.999]             base::sink(type = "output", split = FALSE)
[18:04:49.999]             base::close(...future.stdout)
[18:04:49.999]         }, add = TRUE)
[18:04:49.999]     }
[18:04:49.999]     ...future.frame <- base::sys.nframe()
[18:04:49.999]     ...future.conditions <- base::list()
[18:04:49.999]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:49.999]     if (FALSE) {
[18:04:49.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:49.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:49.999]     }
[18:04:49.999]     ...future.result <- base::tryCatch({
[18:04:49.999]         base::withCallingHandlers({
[18:04:49.999]             ...future.value <- base::withVisible(base::local({
[18:04:49.999]                 ...future.makeSendCondition <- base::local({
[18:04:49.999]                   sendCondition <- NULL
[18:04:49.999]                   function(frame = 1L) {
[18:04:49.999]                     if (is.function(sendCondition)) 
[18:04:49.999]                       return(sendCondition)
[18:04:49.999]                     ns <- getNamespace("parallel")
[18:04:49.999]                     if (exists("sendData", mode = "function", 
[18:04:49.999]                       envir = ns)) {
[18:04:49.999]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:49.999]                         envir = ns)
[18:04:49.999]                       envir <- sys.frame(frame)
[18:04:49.999]                       master <- NULL
[18:04:49.999]                       while (!identical(envir, .GlobalEnv) && 
[18:04:49.999]                         !identical(envir, emptyenv())) {
[18:04:49.999]                         if (exists("master", mode = "list", envir = envir, 
[18:04:49.999]                           inherits = FALSE)) {
[18:04:49.999]                           master <- get("master", mode = "list", 
[18:04:49.999]                             envir = envir, inherits = FALSE)
[18:04:49.999]                           if (inherits(master, c("SOCKnode", 
[18:04:49.999]                             "SOCK0node"))) {
[18:04:49.999]                             sendCondition <<- function(cond) {
[18:04:49.999]                               data <- list(type = "VALUE", value = cond, 
[18:04:49.999]                                 success = TRUE)
[18:04:49.999]                               parallel_sendData(master, data)
[18:04:49.999]                             }
[18:04:49.999]                             return(sendCondition)
[18:04:49.999]                           }
[18:04:49.999]                         }
[18:04:49.999]                         frame <- frame + 1L
[18:04:49.999]                         envir <- sys.frame(frame)
[18:04:49.999]                       }
[18:04:49.999]                     }
[18:04:49.999]                     sendCondition <<- function(cond) NULL
[18:04:49.999]                   }
[18:04:49.999]                 })
[18:04:49.999]                 withCallingHandlers({
[18:04:49.999]                   {
[18:04:49.999]                     x[["a"]] <- 1
[18:04:49.999]                     x
[18:04:49.999]                   }
[18:04:49.999]                 }, immediateCondition = function(cond) {
[18:04:49.999]                   sendCondition <- ...future.makeSendCondition()
[18:04:49.999]                   sendCondition(cond)
[18:04:49.999]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.999]                   {
[18:04:49.999]                     inherits <- base::inherits
[18:04:49.999]                     invokeRestart <- base::invokeRestart
[18:04:49.999]                     is.null <- base::is.null
[18:04:49.999]                     muffled <- FALSE
[18:04:49.999]                     if (inherits(cond, "message")) {
[18:04:49.999]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:49.999]                       if (muffled) 
[18:04:49.999]                         invokeRestart("muffleMessage")
[18:04:49.999]                     }
[18:04:49.999]                     else if (inherits(cond, "warning")) {
[18:04:49.999]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:49.999]                       if (muffled) 
[18:04:49.999]                         invokeRestart("muffleWarning")
[18:04:49.999]                     }
[18:04:49.999]                     else if (inherits(cond, "condition")) {
[18:04:49.999]                       if (!is.null(pattern)) {
[18:04:49.999]                         computeRestarts <- base::computeRestarts
[18:04:49.999]                         grepl <- base::grepl
[18:04:49.999]                         restarts <- computeRestarts(cond)
[18:04:49.999]                         for (restart in restarts) {
[18:04:49.999]                           name <- restart$name
[18:04:49.999]                           if (is.null(name)) 
[18:04:49.999]                             next
[18:04:49.999]                           if (!grepl(pattern, name)) 
[18:04:49.999]                             next
[18:04:49.999]                           invokeRestart(restart)
[18:04:49.999]                           muffled <- TRUE
[18:04:49.999]                           break
[18:04:49.999]                         }
[18:04:49.999]                       }
[18:04:49.999]                     }
[18:04:49.999]                     invisible(muffled)
[18:04:49.999]                   }
[18:04:49.999]                   muffleCondition(cond)
[18:04:49.999]                 })
[18:04:49.999]             }))
[18:04:49.999]             future::FutureResult(value = ...future.value$value, 
[18:04:49.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.999]                   ...future.rng), globalenv = if (FALSE) 
[18:04:49.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:49.999]                     ...future.globalenv.names))
[18:04:49.999]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:49.999]         }, condition = base::local({
[18:04:49.999]             c <- base::c
[18:04:49.999]             inherits <- base::inherits
[18:04:49.999]             invokeRestart <- base::invokeRestart
[18:04:49.999]             length <- base::length
[18:04:49.999]             list <- base::list
[18:04:49.999]             seq.int <- base::seq.int
[18:04:49.999]             signalCondition <- base::signalCondition
[18:04:49.999]             sys.calls <- base::sys.calls
[18:04:49.999]             `[[` <- base::`[[`
[18:04:49.999]             `+` <- base::`+`
[18:04:49.999]             `<<-` <- base::`<<-`
[18:04:49.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:49.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:49.999]                   3L)]
[18:04:49.999]             }
[18:04:49.999]             function(cond) {
[18:04:49.999]                 is_error <- inherits(cond, "error")
[18:04:49.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:49.999]                   NULL)
[18:04:49.999]                 if (is_error) {
[18:04:49.999]                   sessionInformation <- function() {
[18:04:49.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:49.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:49.999]                       search = base::search(), system = base::Sys.info())
[18:04:49.999]                   }
[18:04:49.999]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:49.999]                     cond$call), session = sessionInformation(), 
[18:04:49.999]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:49.999]                   signalCondition(cond)
[18:04:49.999]                 }
[18:04:49.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:49.999]                 "immediateCondition"))) {
[18:04:49.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:49.999]                   ...future.conditions[[length(...future.conditions) + 
[18:04:49.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:49.999]                   if (TRUE && !signal) {
[18:04:49.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.999]                     {
[18:04:49.999]                       inherits <- base::inherits
[18:04:49.999]                       invokeRestart <- base::invokeRestart
[18:04:49.999]                       is.null <- base::is.null
[18:04:49.999]                       muffled <- FALSE
[18:04:49.999]                       if (inherits(cond, "message")) {
[18:04:49.999]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.999]                         if (muffled) 
[18:04:49.999]                           invokeRestart("muffleMessage")
[18:04:49.999]                       }
[18:04:49.999]                       else if (inherits(cond, "warning")) {
[18:04:49.999]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.999]                         if (muffled) 
[18:04:49.999]                           invokeRestart("muffleWarning")
[18:04:49.999]                       }
[18:04:49.999]                       else if (inherits(cond, "condition")) {
[18:04:49.999]                         if (!is.null(pattern)) {
[18:04:49.999]                           computeRestarts <- base::computeRestarts
[18:04:49.999]                           grepl <- base::grepl
[18:04:49.999]                           restarts <- computeRestarts(cond)
[18:04:49.999]                           for (restart in restarts) {
[18:04:49.999]                             name <- restart$name
[18:04:49.999]                             if (is.null(name)) 
[18:04:49.999]                               next
[18:04:49.999]                             if (!grepl(pattern, name)) 
[18:04:49.999]                               next
[18:04:49.999]                             invokeRestart(restart)
[18:04:49.999]                             muffled <- TRUE
[18:04:49.999]                             break
[18:04:49.999]                           }
[18:04:49.999]                         }
[18:04:49.999]                       }
[18:04:49.999]                       invisible(muffled)
[18:04:49.999]                     }
[18:04:49.999]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.999]                   }
[18:04:49.999]                 }
[18:04:49.999]                 else {
[18:04:49.999]                   if (TRUE) {
[18:04:49.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:49.999]                     {
[18:04:49.999]                       inherits <- base::inherits
[18:04:49.999]                       invokeRestart <- base::invokeRestart
[18:04:49.999]                       is.null <- base::is.null
[18:04:49.999]                       muffled <- FALSE
[18:04:49.999]                       if (inherits(cond, "message")) {
[18:04:49.999]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:49.999]                         if (muffled) 
[18:04:49.999]                           invokeRestart("muffleMessage")
[18:04:49.999]                       }
[18:04:49.999]                       else if (inherits(cond, "warning")) {
[18:04:49.999]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:49.999]                         if (muffled) 
[18:04:49.999]                           invokeRestart("muffleWarning")
[18:04:49.999]                       }
[18:04:49.999]                       else if (inherits(cond, "condition")) {
[18:04:49.999]                         if (!is.null(pattern)) {
[18:04:49.999]                           computeRestarts <- base::computeRestarts
[18:04:49.999]                           grepl <- base::grepl
[18:04:49.999]                           restarts <- computeRestarts(cond)
[18:04:49.999]                           for (restart in restarts) {
[18:04:49.999]                             name <- restart$name
[18:04:49.999]                             if (is.null(name)) 
[18:04:49.999]                               next
[18:04:49.999]                             if (!grepl(pattern, name)) 
[18:04:49.999]                               next
[18:04:49.999]                             invokeRestart(restart)
[18:04:49.999]                             muffled <- TRUE
[18:04:49.999]                             break
[18:04:49.999]                           }
[18:04:49.999]                         }
[18:04:49.999]                       }
[18:04:49.999]                       invisible(muffled)
[18:04:49.999]                     }
[18:04:49.999]                     muffleCondition(cond, pattern = "^muffle")
[18:04:49.999]                   }
[18:04:49.999]                 }
[18:04:49.999]             }
[18:04:49.999]         }))
[18:04:49.999]     }, error = function(ex) {
[18:04:49.999]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:49.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:49.999]                 ...future.rng), started = ...future.startTime, 
[18:04:49.999]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:49.999]             version = "1.8"), class = "FutureResult")
[18:04:49.999]     }, finally = {
[18:04:49.999]         if (!identical(...future.workdir, getwd())) 
[18:04:49.999]             setwd(...future.workdir)
[18:04:49.999]         {
[18:04:49.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:49.999]                 ...future.oldOptions$nwarnings <- NULL
[18:04:49.999]             }
[18:04:49.999]             base::options(...future.oldOptions)
[18:04:49.999]             if (.Platform$OS.type == "windows") {
[18:04:49.999]                 old_names <- names(...future.oldEnvVars)
[18:04:49.999]                 envs <- base::Sys.getenv()
[18:04:49.999]                 names <- names(envs)
[18:04:49.999]                 common <- intersect(names, old_names)
[18:04:49.999]                 added <- setdiff(names, old_names)
[18:04:49.999]                 removed <- setdiff(old_names, names)
[18:04:49.999]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:49.999]                   envs[common]]
[18:04:49.999]                 NAMES <- toupper(changed)
[18:04:49.999]                 args <- list()
[18:04:49.999]                 for (kk in seq_along(NAMES)) {
[18:04:49.999]                   name <- changed[[kk]]
[18:04:49.999]                   NAME <- NAMES[[kk]]
[18:04:49.999]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.999]                     next
[18:04:49.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.999]                 }
[18:04:49.999]                 NAMES <- toupper(added)
[18:04:49.999]                 for (kk in seq_along(NAMES)) {
[18:04:49.999]                   name <- added[[kk]]
[18:04:49.999]                   NAME <- NAMES[[kk]]
[18:04:49.999]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.999]                     next
[18:04:49.999]                   args[[name]] <- ""
[18:04:49.999]                 }
[18:04:49.999]                 NAMES <- toupper(removed)
[18:04:49.999]                 for (kk in seq_along(NAMES)) {
[18:04:49.999]                   name <- removed[[kk]]
[18:04:49.999]                   NAME <- NAMES[[kk]]
[18:04:49.999]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:49.999]                     next
[18:04:49.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:49.999]                 }
[18:04:49.999]                 if (length(args) > 0) 
[18:04:49.999]                   base::do.call(base::Sys.setenv, args = args)
[18:04:49.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:49.999]             }
[18:04:49.999]             else {
[18:04:49.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:49.999]             }
[18:04:49.999]             {
[18:04:49.999]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:49.999]                   0L) {
[18:04:49.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:49.999]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:49.999]                   base::options(opts)
[18:04:49.999]                 }
[18:04:49.999]                 {
[18:04:49.999]                   {
[18:04:49.999]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:49.999]                     NULL
[18:04:49.999]                   }
[18:04:49.999]                   options(future.plan = NULL)
[18:04:49.999]                   if (is.na(NA_character_)) 
[18:04:49.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:49.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:49.999]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:49.999]                     .init = FALSE)
[18:04:49.999]                 }
[18:04:49.999]             }
[18:04:49.999]         }
[18:04:49.999]     })
[18:04:49.999]     if (TRUE) {
[18:04:49.999]         base::sink(type = "output", split = FALSE)
[18:04:49.999]         if (TRUE) {
[18:04:49.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:49.999]         }
[18:04:49.999]         else {
[18:04:49.999]             ...future.result["stdout"] <- base::list(NULL)
[18:04:49.999]         }
[18:04:49.999]         base::close(...future.stdout)
[18:04:49.999]         ...future.stdout <- NULL
[18:04:49.999]     }
[18:04:49.999]     ...future.result$conditions <- ...future.conditions
[18:04:49.999]     ...future.result$finished <- base::Sys.time()
[18:04:49.999]     ...future.result
[18:04:49.999] }
[18:04:50.005] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[18:04:50.005] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[18:04:50.006] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[18:04:50.006] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[18:04:50.007] MultisessionFuture started
[18:04:50.007] - Launch lazy future ... done
[18:04:50.008] run() for ‘MultisessionFuture’ ... done
[18:04:50.008] result() for ClusterFuture ...
[18:04:50.008] receiveMessageFromWorker() for ClusterFuture ...
[18:04:50.008] - Validating connection of MultisessionFuture
[18:04:50.051] - received message: FutureResult
[18:04:50.052] - Received FutureResult
[18:04:50.052] - Erased future from FutureRegistry
[18:04:50.052] result() for ClusterFuture ...
[18:04:50.053] - result already collected: FutureResult
[18:04:50.053] result() for ClusterFuture ... done
[18:04:50.053] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:50.053] result() for ClusterFuture ... done
[18:04:50.053] result() for ClusterFuture ...
[18:04:50.054] - result already collected: FutureResult
[18:04:50.054] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:50.055] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:50.055] Searching for globals...
[18:04:50.059] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:50.060] Searching for globals ... DONE
[18:04:50.060] Resolving globals: TRUE
[18:04:50.060] Resolving any globals that are futures ...
[18:04:50.060] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[18:04:50.061] Resolving any globals that are futures ... DONE
[18:04:50.061] Resolving futures part of globals (recursively) ...
[18:04:50.062] resolve() on list ...
[18:04:50.062]  recursive: 99
[18:04:50.062]  length: 1
[18:04:50.063]  elements: ‘x’
[18:04:50.063]  length: 0 (resolved future 1)
[18:04:50.063] resolve() on list ... DONE
[18:04:50.063] - globals: [1] ‘x’
[18:04:50.064] Resolving futures part of globals (recursively) ... DONE
[18:04:50.064] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:50.065] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:50.065] - globals: [1] ‘x’
[18:04:50.065] 
[18:04:50.065] getGlobalsAndPackages() ... DONE
[18:04:50.074] run() for ‘Future’ ...
[18:04:50.074] - state: ‘created’
[18:04:50.074] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:50.099] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:50.100] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:50.100]   - Field: ‘node’
[18:04:50.100]   - Field: ‘label’
[18:04:50.100]   - Field: ‘local’
[18:04:50.101]   - Field: ‘owner’
[18:04:50.101]   - Field: ‘envir’
[18:04:50.101]   - Field: ‘workers’
[18:04:50.101]   - Field: ‘packages’
[18:04:50.101]   - Field: ‘gc’
[18:04:50.102]   - Field: ‘conditions’
[18:04:50.102]   - Field: ‘persistent’
[18:04:50.102]   - Field: ‘expr’
[18:04:50.102]   - Field: ‘uuid’
[18:04:50.103]   - Field: ‘seed’
[18:04:50.103]   - Field: ‘version’
[18:04:50.103]   - Field: ‘result’
[18:04:50.103]   - Field: ‘asynchronous’
[18:04:50.103]   - Field: ‘calls’
[18:04:50.104]   - Field: ‘globals’
[18:04:50.104]   - Field: ‘stdout’
[18:04:50.104]   - Field: ‘earlySignal’
[18:04:50.104]   - Field: ‘lazy’
[18:04:50.104]   - Field: ‘state’
[18:04:50.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:50.105] - Launch lazy future ...
[18:04:50.105] Packages needed by the future expression (n = 0): <none>
[18:04:50.106] Packages needed by future strategies (n = 0): <none>
[18:04:50.106] {
[18:04:50.106]     {
[18:04:50.106]         {
[18:04:50.106]             ...future.startTime <- base::Sys.time()
[18:04:50.106]             {
[18:04:50.106]                 {
[18:04:50.106]                   {
[18:04:50.106]                     {
[18:04:50.106]                       base::local({
[18:04:50.106]                         has_future <- base::requireNamespace("future", 
[18:04:50.106]                           quietly = TRUE)
[18:04:50.106]                         if (has_future) {
[18:04:50.106]                           ns <- base::getNamespace("future")
[18:04:50.106]                           version <- ns[[".package"]][["version"]]
[18:04:50.106]                           if (is.null(version)) 
[18:04:50.106]                             version <- utils::packageVersion("future")
[18:04:50.106]                         }
[18:04:50.106]                         else {
[18:04:50.106]                           version <- NULL
[18:04:50.106]                         }
[18:04:50.106]                         if (!has_future || version < "1.8.0") {
[18:04:50.106]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:50.106]                             "", base::R.version$version.string), 
[18:04:50.106]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:50.106]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:50.106]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:50.106]                               "release", "version")], collapse = " "), 
[18:04:50.106]                             hostname = base::Sys.info()[["nodename"]])
[18:04:50.106]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:50.106]                             info)
[18:04:50.106]                           info <- base::paste(info, collapse = "; ")
[18:04:50.106]                           if (!has_future) {
[18:04:50.106]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:50.106]                               info)
[18:04:50.106]                           }
[18:04:50.106]                           else {
[18:04:50.106]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:50.106]                               info, version)
[18:04:50.106]                           }
[18:04:50.106]                           base::stop(msg)
[18:04:50.106]                         }
[18:04:50.106]                       })
[18:04:50.106]                     }
[18:04:50.106]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:50.106]                     base::options(mc.cores = 1L)
[18:04:50.106]                   }
[18:04:50.106]                   ...future.strategy.old <- future::plan("list")
[18:04:50.106]                   options(future.plan = NULL)
[18:04:50.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:50.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:50.106]                 }
[18:04:50.106]                 ...future.workdir <- getwd()
[18:04:50.106]             }
[18:04:50.106]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:50.106]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:50.106]         }
[18:04:50.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:50.106]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:50.106]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:50.106]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:50.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:50.106]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:50.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:50.106]             base::names(...future.oldOptions))
[18:04:50.106]     }
[18:04:50.106]     if (FALSE) {
[18:04:50.106]     }
[18:04:50.106]     else {
[18:04:50.106]         if (TRUE) {
[18:04:50.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:50.106]                 open = "w")
[18:04:50.106]         }
[18:04:50.106]         else {
[18:04:50.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:50.106]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:50.106]         }
[18:04:50.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:50.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:50.106]             base::sink(type = "output", split = FALSE)
[18:04:50.106]             base::close(...future.stdout)
[18:04:50.106]         }, add = TRUE)
[18:04:50.106]     }
[18:04:50.106]     ...future.frame <- base::sys.nframe()
[18:04:50.106]     ...future.conditions <- base::list()
[18:04:50.106]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:50.106]     if (FALSE) {
[18:04:50.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:50.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:50.106]     }
[18:04:50.106]     ...future.result <- base::tryCatch({
[18:04:50.106]         base::withCallingHandlers({
[18:04:50.106]             ...future.value <- base::withVisible(base::local({
[18:04:50.106]                 ...future.makeSendCondition <- base::local({
[18:04:50.106]                   sendCondition <- NULL
[18:04:50.106]                   function(frame = 1L) {
[18:04:50.106]                     if (is.function(sendCondition)) 
[18:04:50.106]                       return(sendCondition)
[18:04:50.106]                     ns <- getNamespace("parallel")
[18:04:50.106]                     if (exists("sendData", mode = "function", 
[18:04:50.106]                       envir = ns)) {
[18:04:50.106]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:50.106]                         envir = ns)
[18:04:50.106]                       envir <- sys.frame(frame)
[18:04:50.106]                       master <- NULL
[18:04:50.106]                       while (!identical(envir, .GlobalEnv) && 
[18:04:50.106]                         !identical(envir, emptyenv())) {
[18:04:50.106]                         if (exists("master", mode = "list", envir = envir, 
[18:04:50.106]                           inherits = FALSE)) {
[18:04:50.106]                           master <- get("master", mode = "list", 
[18:04:50.106]                             envir = envir, inherits = FALSE)
[18:04:50.106]                           if (inherits(master, c("SOCKnode", 
[18:04:50.106]                             "SOCK0node"))) {
[18:04:50.106]                             sendCondition <<- function(cond) {
[18:04:50.106]                               data <- list(type = "VALUE", value = cond, 
[18:04:50.106]                                 success = TRUE)
[18:04:50.106]                               parallel_sendData(master, data)
[18:04:50.106]                             }
[18:04:50.106]                             return(sendCondition)
[18:04:50.106]                           }
[18:04:50.106]                         }
[18:04:50.106]                         frame <- frame + 1L
[18:04:50.106]                         envir <- sys.frame(frame)
[18:04:50.106]                       }
[18:04:50.106]                     }
[18:04:50.106]                     sendCondition <<- function(cond) NULL
[18:04:50.106]                   }
[18:04:50.106]                 })
[18:04:50.106]                 withCallingHandlers({
[18:04:50.106]                   {
[18:04:50.106]                     x[["a"]] <- 1
[18:04:50.106]                     x
[18:04:50.106]                   }
[18:04:50.106]                 }, immediateCondition = function(cond) {
[18:04:50.106]                   sendCondition <- ...future.makeSendCondition()
[18:04:50.106]                   sendCondition(cond)
[18:04:50.106]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.106]                   {
[18:04:50.106]                     inherits <- base::inherits
[18:04:50.106]                     invokeRestart <- base::invokeRestart
[18:04:50.106]                     is.null <- base::is.null
[18:04:50.106]                     muffled <- FALSE
[18:04:50.106]                     if (inherits(cond, "message")) {
[18:04:50.106]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:50.106]                       if (muffled) 
[18:04:50.106]                         invokeRestart("muffleMessage")
[18:04:50.106]                     }
[18:04:50.106]                     else if (inherits(cond, "warning")) {
[18:04:50.106]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:50.106]                       if (muffled) 
[18:04:50.106]                         invokeRestart("muffleWarning")
[18:04:50.106]                     }
[18:04:50.106]                     else if (inherits(cond, "condition")) {
[18:04:50.106]                       if (!is.null(pattern)) {
[18:04:50.106]                         computeRestarts <- base::computeRestarts
[18:04:50.106]                         grepl <- base::grepl
[18:04:50.106]                         restarts <- computeRestarts(cond)
[18:04:50.106]                         for (restart in restarts) {
[18:04:50.106]                           name <- restart$name
[18:04:50.106]                           if (is.null(name)) 
[18:04:50.106]                             next
[18:04:50.106]                           if (!grepl(pattern, name)) 
[18:04:50.106]                             next
[18:04:50.106]                           invokeRestart(restart)
[18:04:50.106]                           muffled <- TRUE
[18:04:50.106]                           break
[18:04:50.106]                         }
[18:04:50.106]                       }
[18:04:50.106]                     }
[18:04:50.106]                     invisible(muffled)
[18:04:50.106]                   }
[18:04:50.106]                   muffleCondition(cond)
[18:04:50.106]                 })
[18:04:50.106]             }))
[18:04:50.106]             future::FutureResult(value = ...future.value$value, 
[18:04:50.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:50.106]                   ...future.rng), globalenv = if (FALSE) 
[18:04:50.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:50.106]                     ...future.globalenv.names))
[18:04:50.106]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:50.106]         }, condition = base::local({
[18:04:50.106]             c <- base::c
[18:04:50.106]             inherits <- base::inherits
[18:04:50.106]             invokeRestart <- base::invokeRestart
[18:04:50.106]             length <- base::length
[18:04:50.106]             list <- base::list
[18:04:50.106]             seq.int <- base::seq.int
[18:04:50.106]             signalCondition <- base::signalCondition
[18:04:50.106]             sys.calls <- base::sys.calls
[18:04:50.106]             `[[` <- base::`[[`
[18:04:50.106]             `+` <- base::`+`
[18:04:50.106]             `<<-` <- base::`<<-`
[18:04:50.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:50.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:50.106]                   3L)]
[18:04:50.106]             }
[18:04:50.106]             function(cond) {
[18:04:50.106]                 is_error <- inherits(cond, "error")
[18:04:50.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:50.106]                   NULL)
[18:04:50.106]                 if (is_error) {
[18:04:50.106]                   sessionInformation <- function() {
[18:04:50.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:50.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:50.106]                       search = base::search(), system = base::Sys.info())
[18:04:50.106]                   }
[18:04:50.106]                   ...future.conditions[[length(...future.conditions) + 
[18:04:50.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:50.106]                     cond$call), session = sessionInformation(), 
[18:04:50.106]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:50.106]                   signalCondition(cond)
[18:04:50.106]                 }
[18:04:50.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:50.106]                 "immediateCondition"))) {
[18:04:50.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:50.106]                   ...future.conditions[[length(...future.conditions) + 
[18:04:50.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:50.106]                   if (TRUE && !signal) {
[18:04:50.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.106]                     {
[18:04:50.106]                       inherits <- base::inherits
[18:04:50.106]                       invokeRestart <- base::invokeRestart
[18:04:50.106]                       is.null <- base::is.null
[18:04:50.106]                       muffled <- FALSE
[18:04:50.106]                       if (inherits(cond, "message")) {
[18:04:50.106]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:50.106]                         if (muffled) 
[18:04:50.106]                           invokeRestart("muffleMessage")
[18:04:50.106]                       }
[18:04:50.106]                       else if (inherits(cond, "warning")) {
[18:04:50.106]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:50.106]                         if (muffled) 
[18:04:50.106]                           invokeRestart("muffleWarning")
[18:04:50.106]                       }
[18:04:50.106]                       else if (inherits(cond, "condition")) {
[18:04:50.106]                         if (!is.null(pattern)) {
[18:04:50.106]                           computeRestarts <- base::computeRestarts
[18:04:50.106]                           grepl <- base::grepl
[18:04:50.106]                           restarts <- computeRestarts(cond)
[18:04:50.106]                           for (restart in restarts) {
[18:04:50.106]                             name <- restart$name
[18:04:50.106]                             if (is.null(name)) 
[18:04:50.106]                               next
[18:04:50.106]                             if (!grepl(pattern, name)) 
[18:04:50.106]                               next
[18:04:50.106]                             invokeRestart(restart)
[18:04:50.106]                             muffled <- TRUE
[18:04:50.106]                             break
[18:04:50.106]                           }
[18:04:50.106]                         }
[18:04:50.106]                       }
[18:04:50.106]                       invisible(muffled)
[18:04:50.106]                     }
[18:04:50.106]                     muffleCondition(cond, pattern = "^muffle")
[18:04:50.106]                   }
[18:04:50.106]                 }
[18:04:50.106]                 else {
[18:04:50.106]                   if (TRUE) {
[18:04:50.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.106]                     {
[18:04:50.106]                       inherits <- base::inherits
[18:04:50.106]                       invokeRestart <- base::invokeRestart
[18:04:50.106]                       is.null <- base::is.null
[18:04:50.106]                       muffled <- FALSE
[18:04:50.106]                       if (inherits(cond, "message")) {
[18:04:50.106]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:50.106]                         if (muffled) 
[18:04:50.106]                           invokeRestart("muffleMessage")
[18:04:50.106]                       }
[18:04:50.106]                       else if (inherits(cond, "warning")) {
[18:04:50.106]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:50.106]                         if (muffled) 
[18:04:50.106]                           invokeRestart("muffleWarning")
[18:04:50.106]                       }
[18:04:50.106]                       else if (inherits(cond, "condition")) {
[18:04:50.106]                         if (!is.null(pattern)) {
[18:04:50.106]                           computeRestarts <- base::computeRestarts
[18:04:50.106]                           grepl <- base::grepl
[18:04:50.106]                           restarts <- computeRestarts(cond)
[18:04:50.106]                           for (restart in restarts) {
[18:04:50.106]                             name <- restart$name
[18:04:50.106]                             if (is.null(name)) 
[18:04:50.106]                               next
[18:04:50.106]                             if (!grepl(pattern, name)) 
[18:04:50.106]                               next
[18:04:50.106]                             invokeRestart(restart)
[18:04:50.106]                             muffled <- TRUE
[18:04:50.106]                             break
[18:04:50.106]                           }
[18:04:50.106]                         }
[18:04:50.106]                       }
[18:04:50.106]                       invisible(muffled)
[18:04:50.106]                     }
[18:04:50.106]                     muffleCondition(cond, pattern = "^muffle")
[18:04:50.106]                   }
[18:04:50.106]                 }
[18:04:50.106]             }
[18:04:50.106]         }))
[18:04:50.106]     }, error = function(ex) {
[18:04:50.106]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:50.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:50.106]                 ...future.rng), started = ...future.startTime, 
[18:04:50.106]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:50.106]             version = "1.8"), class = "FutureResult")
[18:04:50.106]     }, finally = {
[18:04:50.106]         if (!identical(...future.workdir, getwd())) 
[18:04:50.106]             setwd(...future.workdir)
[18:04:50.106]         {
[18:04:50.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:50.106]                 ...future.oldOptions$nwarnings <- NULL
[18:04:50.106]             }
[18:04:50.106]             base::options(...future.oldOptions)
[18:04:50.106]             if (.Platform$OS.type == "windows") {
[18:04:50.106]                 old_names <- names(...future.oldEnvVars)
[18:04:50.106]                 envs <- base::Sys.getenv()
[18:04:50.106]                 names <- names(envs)
[18:04:50.106]                 common <- intersect(names, old_names)
[18:04:50.106]                 added <- setdiff(names, old_names)
[18:04:50.106]                 removed <- setdiff(old_names, names)
[18:04:50.106]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:50.106]                   envs[common]]
[18:04:50.106]                 NAMES <- toupper(changed)
[18:04:50.106]                 args <- list()
[18:04:50.106]                 for (kk in seq_along(NAMES)) {
[18:04:50.106]                   name <- changed[[kk]]
[18:04:50.106]                   NAME <- NAMES[[kk]]
[18:04:50.106]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.106]                     next
[18:04:50.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:50.106]                 }
[18:04:50.106]                 NAMES <- toupper(added)
[18:04:50.106]                 for (kk in seq_along(NAMES)) {
[18:04:50.106]                   name <- added[[kk]]
[18:04:50.106]                   NAME <- NAMES[[kk]]
[18:04:50.106]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.106]                     next
[18:04:50.106]                   args[[name]] <- ""
[18:04:50.106]                 }
[18:04:50.106]                 NAMES <- toupper(removed)
[18:04:50.106]                 for (kk in seq_along(NAMES)) {
[18:04:50.106]                   name <- removed[[kk]]
[18:04:50.106]                   NAME <- NAMES[[kk]]
[18:04:50.106]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.106]                     next
[18:04:50.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:50.106]                 }
[18:04:50.106]                 if (length(args) > 0) 
[18:04:50.106]                   base::do.call(base::Sys.setenv, args = args)
[18:04:50.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:50.106]             }
[18:04:50.106]             else {
[18:04:50.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:50.106]             }
[18:04:50.106]             {
[18:04:50.106]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:50.106]                   0L) {
[18:04:50.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:50.106]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:50.106]                   base::options(opts)
[18:04:50.106]                 }
[18:04:50.106]                 {
[18:04:50.106]                   {
[18:04:50.106]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:50.106]                     NULL
[18:04:50.106]                   }
[18:04:50.106]                   options(future.plan = NULL)
[18:04:50.106]                   if (is.na(NA_character_)) 
[18:04:50.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:50.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:50.106]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:50.106]                     .init = FALSE)
[18:04:50.106]                 }
[18:04:50.106]             }
[18:04:50.106]         }
[18:04:50.106]     })
[18:04:50.106]     if (TRUE) {
[18:04:50.106]         base::sink(type = "output", split = FALSE)
[18:04:50.106]         if (TRUE) {
[18:04:50.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:50.106]         }
[18:04:50.106]         else {
[18:04:50.106]             ...future.result["stdout"] <- base::list(NULL)
[18:04:50.106]         }
[18:04:50.106]         base::close(...future.stdout)
[18:04:50.106]         ...future.stdout <- NULL
[18:04:50.106]     }
[18:04:50.106]     ...future.result$conditions <- ...future.conditions
[18:04:50.106]     ...future.result$finished <- base::Sys.time()
[18:04:50.106]     ...future.result
[18:04:50.106] }
[18:04:50.112] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[18:04:50.112] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[18:04:50.113] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[18:04:50.113] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[18:04:50.114] MultisessionFuture started
[18:04:50.115] - Launch lazy future ... done
[18:04:50.115] run() for ‘MultisessionFuture’ ... done
[18:04:50.115] result() for ClusterFuture ...
[18:04:50.115] receiveMessageFromWorker() for ClusterFuture ...
[18:04:50.116] - Validating connection of MultisessionFuture
[18:04:50.159] - received message: FutureResult
[18:04:50.159] - Received FutureResult
[18:04:50.159] - Erased future from FutureRegistry
[18:04:50.159] result() for ClusterFuture ...
[18:04:50.160] - result already collected: FutureResult
[18:04:50.160] result() for ClusterFuture ... done
[18:04:50.160] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:50.160] result() for ClusterFuture ... done
[18:04:50.160] result() for ClusterFuture ...
[18:04:50.161] - result already collected: FutureResult
[18:04:50.161] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:50.162] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:50.162] Searching for globals...
[18:04:50.166] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:50.167] Searching for globals ... DONE
[18:04:50.167] Resolving globals: TRUE
[18:04:50.167] Resolving any globals that are futures ...
[18:04:50.167] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:50.168] Resolving any globals that are futures ... DONE
[18:04:50.168] Resolving futures part of globals (recursively) ...
[18:04:50.169] resolve() on list ...
[18:04:50.169]  recursive: 99
[18:04:50.169]  length: 1
[18:04:50.170]  elements: ‘x’
[18:04:50.170]  length: 0 (resolved future 1)
[18:04:50.170] resolve() on list ... DONE
[18:04:50.170] - globals: [1] ‘x’
[18:04:50.170] Resolving futures part of globals (recursively) ... DONE
[18:04:50.171] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:50.171] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:50.172] - globals: [1] ‘x’
[18:04:50.172] 
[18:04:50.172] getGlobalsAndPackages() ... DONE
[18:04:50.173] run() for ‘Future’ ...
[18:04:50.173] - state: ‘created’
[18:04:50.173] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:50.196] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:50.196] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:50.196]   - Field: ‘node’
[18:04:50.197]   - Field: ‘label’
[18:04:50.197]   - Field: ‘local’
[18:04:50.197]   - Field: ‘owner’
[18:04:50.197]   - Field: ‘envir’
[18:04:50.197]   - Field: ‘workers’
[18:04:50.198]   - Field: ‘packages’
[18:04:50.198]   - Field: ‘gc’
[18:04:50.198]   - Field: ‘conditions’
[18:04:50.198]   - Field: ‘persistent’
[18:04:50.198]   - Field: ‘expr’
[18:04:50.199]   - Field: ‘uuid’
[18:04:50.199]   - Field: ‘seed’
[18:04:50.199]   - Field: ‘version’
[18:04:50.199]   - Field: ‘result’
[18:04:50.199]   - Field: ‘asynchronous’
[18:04:50.200]   - Field: ‘calls’
[18:04:50.200]   - Field: ‘globals’
[18:04:50.200]   - Field: ‘stdout’
[18:04:50.200]   - Field: ‘earlySignal’
[18:04:50.200]   - Field: ‘lazy’
[18:04:50.201]   - Field: ‘state’
[18:04:50.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:50.201] - Launch lazy future ...
[18:04:50.201] Packages needed by the future expression (n = 0): <none>
[18:04:50.202] Packages needed by future strategies (n = 0): <none>
[18:04:50.202] {
[18:04:50.202]     {
[18:04:50.202]         {
[18:04:50.202]             ...future.startTime <- base::Sys.time()
[18:04:50.202]             {
[18:04:50.202]                 {
[18:04:50.202]                   {
[18:04:50.202]                     {
[18:04:50.202]                       base::local({
[18:04:50.202]                         has_future <- base::requireNamespace("future", 
[18:04:50.202]                           quietly = TRUE)
[18:04:50.202]                         if (has_future) {
[18:04:50.202]                           ns <- base::getNamespace("future")
[18:04:50.202]                           version <- ns[[".package"]][["version"]]
[18:04:50.202]                           if (is.null(version)) 
[18:04:50.202]                             version <- utils::packageVersion("future")
[18:04:50.202]                         }
[18:04:50.202]                         else {
[18:04:50.202]                           version <- NULL
[18:04:50.202]                         }
[18:04:50.202]                         if (!has_future || version < "1.8.0") {
[18:04:50.202]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:50.202]                             "", base::R.version$version.string), 
[18:04:50.202]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:50.202]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:50.202]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:50.202]                               "release", "version")], collapse = " "), 
[18:04:50.202]                             hostname = base::Sys.info()[["nodename"]])
[18:04:50.202]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:50.202]                             info)
[18:04:50.202]                           info <- base::paste(info, collapse = "; ")
[18:04:50.202]                           if (!has_future) {
[18:04:50.202]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:50.202]                               info)
[18:04:50.202]                           }
[18:04:50.202]                           else {
[18:04:50.202]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:50.202]                               info, version)
[18:04:50.202]                           }
[18:04:50.202]                           base::stop(msg)
[18:04:50.202]                         }
[18:04:50.202]                       })
[18:04:50.202]                     }
[18:04:50.202]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:50.202]                     base::options(mc.cores = 1L)
[18:04:50.202]                   }
[18:04:50.202]                   ...future.strategy.old <- future::plan("list")
[18:04:50.202]                   options(future.plan = NULL)
[18:04:50.202]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:50.202]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:50.202]                 }
[18:04:50.202]                 ...future.workdir <- getwd()
[18:04:50.202]             }
[18:04:50.202]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:50.202]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:50.202]         }
[18:04:50.202]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:50.202]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:50.202]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:50.202]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:50.202]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:50.202]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:50.202]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:50.202]             base::names(...future.oldOptions))
[18:04:50.202]     }
[18:04:50.202]     if (FALSE) {
[18:04:50.202]     }
[18:04:50.202]     else {
[18:04:50.202]         if (TRUE) {
[18:04:50.202]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:50.202]                 open = "w")
[18:04:50.202]         }
[18:04:50.202]         else {
[18:04:50.202]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:50.202]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:50.202]         }
[18:04:50.202]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:50.202]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:50.202]             base::sink(type = "output", split = FALSE)
[18:04:50.202]             base::close(...future.stdout)
[18:04:50.202]         }, add = TRUE)
[18:04:50.202]     }
[18:04:50.202]     ...future.frame <- base::sys.nframe()
[18:04:50.202]     ...future.conditions <- base::list()
[18:04:50.202]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:50.202]     if (FALSE) {
[18:04:50.202]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:50.202]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:50.202]     }
[18:04:50.202]     ...future.result <- base::tryCatch({
[18:04:50.202]         base::withCallingHandlers({
[18:04:50.202]             ...future.value <- base::withVisible(base::local({
[18:04:50.202]                 ...future.makeSendCondition <- base::local({
[18:04:50.202]                   sendCondition <- NULL
[18:04:50.202]                   function(frame = 1L) {
[18:04:50.202]                     if (is.function(sendCondition)) 
[18:04:50.202]                       return(sendCondition)
[18:04:50.202]                     ns <- getNamespace("parallel")
[18:04:50.202]                     if (exists("sendData", mode = "function", 
[18:04:50.202]                       envir = ns)) {
[18:04:50.202]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:50.202]                         envir = ns)
[18:04:50.202]                       envir <- sys.frame(frame)
[18:04:50.202]                       master <- NULL
[18:04:50.202]                       while (!identical(envir, .GlobalEnv) && 
[18:04:50.202]                         !identical(envir, emptyenv())) {
[18:04:50.202]                         if (exists("master", mode = "list", envir = envir, 
[18:04:50.202]                           inherits = FALSE)) {
[18:04:50.202]                           master <- get("master", mode = "list", 
[18:04:50.202]                             envir = envir, inherits = FALSE)
[18:04:50.202]                           if (inherits(master, c("SOCKnode", 
[18:04:50.202]                             "SOCK0node"))) {
[18:04:50.202]                             sendCondition <<- function(cond) {
[18:04:50.202]                               data <- list(type = "VALUE", value = cond, 
[18:04:50.202]                                 success = TRUE)
[18:04:50.202]                               parallel_sendData(master, data)
[18:04:50.202]                             }
[18:04:50.202]                             return(sendCondition)
[18:04:50.202]                           }
[18:04:50.202]                         }
[18:04:50.202]                         frame <- frame + 1L
[18:04:50.202]                         envir <- sys.frame(frame)
[18:04:50.202]                       }
[18:04:50.202]                     }
[18:04:50.202]                     sendCondition <<- function(cond) NULL
[18:04:50.202]                   }
[18:04:50.202]                 })
[18:04:50.202]                 withCallingHandlers({
[18:04:50.202]                   {
[18:04:50.202]                     x["a"] <- list(1)
[18:04:50.202]                     x
[18:04:50.202]                   }
[18:04:50.202]                 }, immediateCondition = function(cond) {
[18:04:50.202]                   sendCondition <- ...future.makeSendCondition()
[18:04:50.202]                   sendCondition(cond)
[18:04:50.202]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.202]                   {
[18:04:50.202]                     inherits <- base::inherits
[18:04:50.202]                     invokeRestart <- base::invokeRestart
[18:04:50.202]                     is.null <- base::is.null
[18:04:50.202]                     muffled <- FALSE
[18:04:50.202]                     if (inherits(cond, "message")) {
[18:04:50.202]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:50.202]                       if (muffled) 
[18:04:50.202]                         invokeRestart("muffleMessage")
[18:04:50.202]                     }
[18:04:50.202]                     else if (inherits(cond, "warning")) {
[18:04:50.202]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:50.202]                       if (muffled) 
[18:04:50.202]                         invokeRestart("muffleWarning")
[18:04:50.202]                     }
[18:04:50.202]                     else if (inherits(cond, "condition")) {
[18:04:50.202]                       if (!is.null(pattern)) {
[18:04:50.202]                         computeRestarts <- base::computeRestarts
[18:04:50.202]                         grepl <- base::grepl
[18:04:50.202]                         restarts <- computeRestarts(cond)
[18:04:50.202]                         for (restart in restarts) {
[18:04:50.202]                           name <- restart$name
[18:04:50.202]                           if (is.null(name)) 
[18:04:50.202]                             next
[18:04:50.202]                           if (!grepl(pattern, name)) 
[18:04:50.202]                             next
[18:04:50.202]                           invokeRestart(restart)
[18:04:50.202]                           muffled <- TRUE
[18:04:50.202]                           break
[18:04:50.202]                         }
[18:04:50.202]                       }
[18:04:50.202]                     }
[18:04:50.202]                     invisible(muffled)
[18:04:50.202]                   }
[18:04:50.202]                   muffleCondition(cond)
[18:04:50.202]                 })
[18:04:50.202]             }))
[18:04:50.202]             future::FutureResult(value = ...future.value$value, 
[18:04:50.202]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:50.202]                   ...future.rng), globalenv = if (FALSE) 
[18:04:50.202]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:50.202]                     ...future.globalenv.names))
[18:04:50.202]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:50.202]         }, condition = base::local({
[18:04:50.202]             c <- base::c
[18:04:50.202]             inherits <- base::inherits
[18:04:50.202]             invokeRestart <- base::invokeRestart
[18:04:50.202]             length <- base::length
[18:04:50.202]             list <- base::list
[18:04:50.202]             seq.int <- base::seq.int
[18:04:50.202]             signalCondition <- base::signalCondition
[18:04:50.202]             sys.calls <- base::sys.calls
[18:04:50.202]             `[[` <- base::`[[`
[18:04:50.202]             `+` <- base::`+`
[18:04:50.202]             `<<-` <- base::`<<-`
[18:04:50.202]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:50.202]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:50.202]                   3L)]
[18:04:50.202]             }
[18:04:50.202]             function(cond) {
[18:04:50.202]                 is_error <- inherits(cond, "error")
[18:04:50.202]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:50.202]                   NULL)
[18:04:50.202]                 if (is_error) {
[18:04:50.202]                   sessionInformation <- function() {
[18:04:50.202]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:50.202]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:50.202]                       search = base::search(), system = base::Sys.info())
[18:04:50.202]                   }
[18:04:50.202]                   ...future.conditions[[length(...future.conditions) + 
[18:04:50.202]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:50.202]                     cond$call), session = sessionInformation(), 
[18:04:50.202]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:50.202]                   signalCondition(cond)
[18:04:50.202]                 }
[18:04:50.202]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:50.202]                 "immediateCondition"))) {
[18:04:50.202]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:50.202]                   ...future.conditions[[length(...future.conditions) + 
[18:04:50.202]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:50.202]                   if (TRUE && !signal) {
[18:04:50.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.202]                     {
[18:04:50.202]                       inherits <- base::inherits
[18:04:50.202]                       invokeRestart <- base::invokeRestart
[18:04:50.202]                       is.null <- base::is.null
[18:04:50.202]                       muffled <- FALSE
[18:04:50.202]                       if (inherits(cond, "message")) {
[18:04:50.202]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:50.202]                         if (muffled) 
[18:04:50.202]                           invokeRestart("muffleMessage")
[18:04:50.202]                       }
[18:04:50.202]                       else if (inherits(cond, "warning")) {
[18:04:50.202]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:50.202]                         if (muffled) 
[18:04:50.202]                           invokeRestart("muffleWarning")
[18:04:50.202]                       }
[18:04:50.202]                       else if (inherits(cond, "condition")) {
[18:04:50.202]                         if (!is.null(pattern)) {
[18:04:50.202]                           computeRestarts <- base::computeRestarts
[18:04:50.202]                           grepl <- base::grepl
[18:04:50.202]                           restarts <- computeRestarts(cond)
[18:04:50.202]                           for (restart in restarts) {
[18:04:50.202]                             name <- restart$name
[18:04:50.202]                             if (is.null(name)) 
[18:04:50.202]                               next
[18:04:50.202]                             if (!grepl(pattern, name)) 
[18:04:50.202]                               next
[18:04:50.202]                             invokeRestart(restart)
[18:04:50.202]                             muffled <- TRUE
[18:04:50.202]                             break
[18:04:50.202]                           }
[18:04:50.202]                         }
[18:04:50.202]                       }
[18:04:50.202]                       invisible(muffled)
[18:04:50.202]                     }
[18:04:50.202]                     muffleCondition(cond, pattern = "^muffle")
[18:04:50.202]                   }
[18:04:50.202]                 }
[18:04:50.202]                 else {
[18:04:50.202]                   if (TRUE) {
[18:04:50.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.202]                     {
[18:04:50.202]                       inherits <- base::inherits
[18:04:50.202]                       invokeRestart <- base::invokeRestart
[18:04:50.202]                       is.null <- base::is.null
[18:04:50.202]                       muffled <- FALSE
[18:04:50.202]                       if (inherits(cond, "message")) {
[18:04:50.202]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:50.202]                         if (muffled) 
[18:04:50.202]                           invokeRestart("muffleMessage")
[18:04:50.202]                       }
[18:04:50.202]                       else if (inherits(cond, "warning")) {
[18:04:50.202]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:50.202]                         if (muffled) 
[18:04:50.202]                           invokeRestart("muffleWarning")
[18:04:50.202]                       }
[18:04:50.202]                       else if (inherits(cond, "condition")) {
[18:04:50.202]                         if (!is.null(pattern)) {
[18:04:50.202]                           computeRestarts <- base::computeRestarts
[18:04:50.202]                           grepl <- base::grepl
[18:04:50.202]                           restarts <- computeRestarts(cond)
[18:04:50.202]                           for (restart in restarts) {
[18:04:50.202]                             name <- restart$name
[18:04:50.202]                             if (is.null(name)) 
[18:04:50.202]                               next
[18:04:50.202]                             if (!grepl(pattern, name)) 
[18:04:50.202]                               next
[18:04:50.202]                             invokeRestart(restart)
[18:04:50.202]                             muffled <- TRUE
[18:04:50.202]                             break
[18:04:50.202]                           }
[18:04:50.202]                         }
[18:04:50.202]                       }
[18:04:50.202]                       invisible(muffled)
[18:04:50.202]                     }
[18:04:50.202]                     muffleCondition(cond, pattern = "^muffle")
[18:04:50.202]                   }
[18:04:50.202]                 }
[18:04:50.202]             }
[18:04:50.202]         }))
[18:04:50.202]     }, error = function(ex) {
[18:04:50.202]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:50.202]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:50.202]                 ...future.rng), started = ...future.startTime, 
[18:04:50.202]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:50.202]             version = "1.8"), class = "FutureResult")
[18:04:50.202]     }, finally = {
[18:04:50.202]         if (!identical(...future.workdir, getwd())) 
[18:04:50.202]             setwd(...future.workdir)
[18:04:50.202]         {
[18:04:50.202]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:50.202]                 ...future.oldOptions$nwarnings <- NULL
[18:04:50.202]             }
[18:04:50.202]             base::options(...future.oldOptions)
[18:04:50.202]             if (.Platform$OS.type == "windows") {
[18:04:50.202]                 old_names <- names(...future.oldEnvVars)
[18:04:50.202]                 envs <- base::Sys.getenv()
[18:04:50.202]                 names <- names(envs)
[18:04:50.202]                 common <- intersect(names, old_names)
[18:04:50.202]                 added <- setdiff(names, old_names)
[18:04:50.202]                 removed <- setdiff(old_names, names)
[18:04:50.202]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:50.202]                   envs[common]]
[18:04:50.202]                 NAMES <- toupper(changed)
[18:04:50.202]                 args <- list()
[18:04:50.202]                 for (kk in seq_along(NAMES)) {
[18:04:50.202]                   name <- changed[[kk]]
[18:04:50.202]                   NAME <- NAMES[[kk]]
[18:04:50.202]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.202]                     next
[18:04:50.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:50.202]                 }
[18:04:50.202]                 NAMES <- toupper(added)
[18:04:50.202]                 for (kk in seq_along(NAMES)) {
[18:04:50.202]                   name <- added[[kk]]
[18:04:50.202]                   NAME <- NAMES[[kk]]
[18:04:50.202]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.202]                     next
[18:04:50.202]                   args[[name]] <- ""
[18:04:50.202]                 }
[18:04:50.202]                 NAMES <- toupper(removed)
[18:04:50.202]                 for (kk in seq_along(NAMES)) {
[18:04:50.202]                   name <- removed[[kk]]
[18:04:50.202]                   NAME <- NAMES[[kk]]
[18:04:50.202]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.202]                     next
[18:04:50.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:50.202]                 }
[18:04:50.202]                 if (length(args) > 0) 
[18:04:50.202]                   base::do.call(base::Sys.setenv, args = args)
[18:04:50.202]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:50.202]             }
[18:04:50.202]             else {
[18:04:50.202]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:50.202]             }
[18:04:50.202]             {
[18:04:50.202]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:50.202]                   0L) {
[18:04:50.202]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:50.202]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:50.202]                   base::options(opts)
[18:04:50.202]                 }
[18:04:50.202]                 {
[18:04:50.202]                   {
[18:04:50.202]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:50.202]                     NULL
[18:04:50.202]                   }
[18:04:50.202]                   options(future.plan = NULL)
[18:04:50.202]                   if (is.na(NA_character_)) 
[18:04:50.202]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:50.202]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:50.202]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:50.202]                     .init = FALSE)
[18:04:50.202]                 }
[18:04:50.202]             }
[18:04:50.202]         }
[18:04:50.202]     })
[18:04:50.202]     if (TRUE) {
[18:04:50.202]         base::sink(type = "output", split = FALSE)
[18:04:50.202]         if (TRUE) {
[18:04:50.202]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:50.202]         }
[18:04:50.202]         else {
[18:04:50.202]             ...future.result["stdout"] <- base::list(NULL)
[18:04:50.202]         }
[18:04:50.202]         base::close(...future.stdout)
[18:04:50.202]         ...future.stdout <- NULL
[18:04:50.202]     }
[18:04:50.202]     ...future.result$conditions <- ...future.conditions
[18:04:50.202]     ...future.result$finished <- base::Sys.time()
[18:04:50.202]     ...future.result
[18:04:50.202] }
[18:04:50.208] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[18:04:50.208] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[18:04:50.209] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[18:04:50.209] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[18:04:50.210] MultisessionFuture started
[18:04:50.210] - Launch lazy future ... done
[18:04:50.210] run() for ‘MultisessionFuture’ ... done
[18:04:50.211] result() for ClusterFuture ...
[18:04:50.211] receiveMessageFromWorker() for ClusterFuture ...
[18:04:50.211] - Validating connection of MultisessionFuture
[18:04:50.254] - received message: FutureResult
[18:04:50.255] - Received FutureResult
[18:04:50.255] - Erased future from FutureRegistry
[18:04:50.255] result() for ClusterFuture ...
[18:04:50.255] - result already collected: FutureResult
[18:04:50.256] result() for ClusterFuture ... done
[18:04:50.256] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:50.256] result() for ClusterFuture ... done
[18:04:50.256] result() for ClusterFuture ...
[18:04:50.256] - result already collected: FutureResult
[18:04:50.257] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:50.257] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:50.258] Searching for globals...
[18:04:50.262] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:50.263] Searching for globals ... DONE
[18:04:50.263] Resolving globals: TRUE
[18:04:50.263] Resolving any globals that are futures ...
[18:04:50.263] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:50.263] Resolving any globals that are futures ... DONE
[18:04:50.264] Resolving futures part of globals (recursively) ...
[18:04:50.265] resolve() on list ...
[18:04:50.265]  recursive: 99
[18:04:50.265]  length: 1
[18:04:50.265]  elements: ‘x’
[18:04:50.266]  length: 0 (resolved future 1)
[18:04:50.266] resolve() on list ... DONE
[18:04:50.266] - globals: [1] ‘x’
[18:04:50.266] Resolving futures part of globals (recursively) ... DONE
[18:04:50.267] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:50.267] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:50.268] - globals: [1] ‘x’
[18:04:50.268] 
[18:04:50.268] getGlobalsAndPackages() ... DONE
[18:04:50.269] run() for ‘Future’ ...
[18:04:50.269] - state: ‘created’
[18:04:50.269] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:50.295] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:50.296] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:50.296]   - Field: ‘node’
[18:04:50.296]   - Field: ‘label’
[18:04:50.297]   - Field: ‘local’
[18:04:50.297]   - Field: ‘owner’
[18:04:50.297]   - Field: ‘envir’
[18:04:50.297]   - Field: ‘workers’
[18:04:50.297]   - Field: ‘packages’
[18:04:50.298]   - Field: ‘gc’
[18:04:50.298]   - Field: ‘conditions’
[18:04:50.298]   - Field: ‘persistent’
[18:04:50.298]   - Field: ‘expr’
[18:04:50.299]   - Field: ‘uuid’
[18:04:50.299]   - Field: ‘seed’
[18:04:50.299]   - Field: ‘version’
[18:04:50.299]   - Field: ‘result’
[18:04:50.299]   - Field: ‘asynchronous’
[18:04:50.300]   - Field: ‘calls’
[18:04:50.300]   - Field: ‘globals’
[18:04:50.300]   - Field: ‘stdout’
[18:04:50.300]   - Field: ‘earlySignal’
[18:04:50.300]   - Field: ‘lazy’
[18:04:50.301]   - Field: ‘state’
[18:04:50.301] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:50.301] - Launch lazy future ...
[18:04:50.302] Packages needed by the future expression (n = 0): <none>
[18:04:50.302] Packages needed by future strategies (n = 0): <none>
[18:04:50.303] {
[18:04:50.303]     {
[18:04:50.303]         {
[18:04:50.303]             ...future.startTime <- base::Sys.time()
[18:04:50.303]             {
[18:04:50.303]                 {
[18:04:50.303]                   {
[18:04:50.303]                     {
[18:04:50.303]                       base::local({
[18:04:50.303]                         has_future <- base::requireNamespace("future", 
[18:04:50.303]                           quietly = TRUE)
[18:04:50.303]                         if (has_future) {
[18:04:50.303]                           ns <- base::getNamespace("future")
[18:04:50.303]                           version <- ns[[".package"]][["version"]]
[18:04:50.303]                           if (is.null(version)) 
[18:04:50.303]                             version <- utils::packageVersion("future")
[18:04:50.303]                         }
[18:04:50.303]                         else {
[18:04:50.303]                           version <- NULL
[18:04:50.303]                         }
[18:04:50.303]                         if (!has_future || version < "1.8.0") {
[18:04:50.303]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:50.303]                             "", base::R.version$version.string), 
[18:04:50.303]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:50.303]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:50.303]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:50.303]                               "release", "version")], collapse = " "), 
[18:04:50.303]                             hostname = base::Sys.info()[["nodename"]])
[18:04:50.303]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:50.303]                             info)
[18:04:50.303]                           info <- base::paste(info, collapse = "; ")
[18:04:50.303]                           if (!has_future) {
[18:04:50.303]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:50.303]                               info)
[18:04:50.303]                           }
[18:04:50.303]                           else {
[18:04:50.303]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:50.303]                               info, version)
[18:04:50.303]                           }
[18:04:50.303]                           base::stop(msg)
[18:04:50.303]                         }
[18:04:50.303]                       })
[18:04:50.303]                     }
[18:04:50.303]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:50.303]                     base::options(mc.cores = 1L)
[18:04:50.303]                   }
[18:04:50.303]                   ...future.strategy.old <- future::plan("list")
[18:04:50.303]                   options(future.plan = NULL)
[18:04:50.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:50.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:50.303]                 }
[18:04:50.303]                 ...future.workdir <- getwd()
[18:04:50.303]             }
[18:04:50.303]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:50.303]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:50.303]         }
[18:04:50.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:50.303]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:50.303]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:50.303]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:50.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:50.303]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:50.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:50.303]             base::names(...future.oldOptions))
[18:04:50.303]     }
[18:04:50.303]     if (FALSE) {
[18:04:50.303]     }
[18:04:50.303]     else {
[18:04:50.303]         if (TRUE) {
[18:04:50.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:50.303]                 open = "w")
[18:04:50.303]         }
[18:04:50.303]         else {
[18:04:50.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:50.303]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:50.303]         }
[18:04:50.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:50.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:50.303]             base::sink(type = "output", split = FALSE)
[18:04:50.303]             base::close(...future.stdout)
[18:04:50.303]         }, add = TRUE)
[18:04:50.303]     }
[18:04:50.303]     ...future.frame <- base::sys.nframe()
[18:04:50.303]     ...future.conditions <- base::list()
[18:04:50.303]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:50.303]     if (FALSE) {
[18:04:50.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:50.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:50.303]     }
[18:04:50.303]     ...future.result <- base::tryCatch({
[18:04:50.303]         base::withCallingHandlers({
[18:04:50.303]             ...future.value <- base::withVisible(base::local({
[18:04:50.303]                 ...future.makeSendCondition <- base::local({
[18:04:50.303]                   sendCondition <- NULL
[18:04:50.303]                   function(frame = 1L) {
[18:04:50.303]                     if (is.function(sendCondition)) 
[18:04:50.303]                       return(sendCondition)
[18:04:50.303]                     ns <- getNamespace("parallel")
[18:04:50.303]                     if (exists("sendData", mode = "function", 
[18:04:50.303]                       envir = ns)) {
[18:04:50.303]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:50.303]                         envir = ns)
[18:04:50.303]                       envir <- sys.frame(frame)
[18:04:50.303]                       master <- NULL
[18:04:50.303]                       while (!identical(envir, .GlobalEnv) && 
[18:04:50.303]                         !identical(envir, emptyenv())) {
[18:04:50.303]                         if (exists("master", mode = "list", envir = envir, 
[18:04:50.303]                           inherits = FALSE)) {
[18:04:50.303]                           master <- get("master", mode = "list", 
[18:04:50.303]                             envir = envir, inherits = FALSE)
[18:04:50.303]                           if (inherits(master, c("SOCKnode", 
[18:04:50.303]                             "SOCK0node"))) {
[18:04:50.303]                             sendCondition <<- function(cond) {
[18:04:50.303]                               data <- list(type = "VALUE", value = cond, 
[18:04:50.303]                                 success = TRUE)
[18:04:50.303]                               parallel_sendData(master, data)
[18:04:50.303]                             }
[18:04:50.303]                             return(sendCondition)
[18:04:50.303]                           }
[18:04:50.303]                         }
[18:04:50.303]                         frame <- frame + 1L
[18:04:50.303]                         envir <- sys.frame(frame)
[18:04:50.303]                       }
[18:04:50.303]                     }
[18:04:50.303]                     sendCondition <<- function(cond) NULL
[18:04:50.303]                   }
[18:04:50.303]                 })
[18:04:50.303]                 withCallingHandlers({
[18:04:50.303]                   {
[18:04:50.303]                     x["a"] <- list(1)
[18:04:50.303]                     x
[18:04:50.303]                   }
[18:04:50.303]                 }, immediateCondition = function(cond) {
[18:04:50.303]                   sendCondition <- ...future.makeSendCondition()
[18:04:50.303]                   sendCondition(cond)
[18:04:50.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.303]                   {
[18:04:50.303]                     inherits <- base::inherits
[18:04:50.303]                     invokeRestart <- base::invokeRestart
[18:04:50.303]                     is.null <- base::is.null
[18:04:50.303]                     muffled <- FALSE
[18:04:50.303]                     if (inherits(cond, "message")) {
[18:04:50.303]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:50.303]                       if (muffled) 
[18:04:50.303]                         invokeRestart("muffleMessage")
[18:04:50.303]                     }
[18:04:50.303]                     else if (inherits(cond, "warning")) {
[18:04:50.303]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:50.303]                       if (muffled) 
[18:04:50.303]                         invokeRestart("muffleWarning")
[18:04:50.303]                     }
[18:04:50.303]                     else if (inherits(cond, "condition")) {
[18:04:50.303]                       if (!is.null(pattern)) {
[18:04:50.303]                         computeRestarts <- base::computeRestarts
[18:04:50.303]                         grepl <- base::grepl
[18:04:50.303]                         restarts <- computeRestarts(cond)
[18:04:50.303]                         for (restart in restarts) {
[18:04:50.303]                           name <- restart$name
[18:04:50.303]                           if (is.null(name)) 
[18:04:50.303]                             next
[18:04:50.303]                           if (!grepl(pattern, name)) 
[18:04:50.303]                             next
[18:04:50.303]                           invokeRestart(restart)
[18:04:50.303]                           muffled <- TRUE
[18:04:50.303]                           break
[18:04:50.303]                         }
[18:04:50.303]                       }
[18:04:50.303]                     }
[18:04:50.303]                     invisible(muffled)
[18:04:50.303]                   }
[18:04:50.303]                   muffleCondition(cond)
[18:04:50.303]                 })
[18:04:50.303]             }))
[18:04:50.303]             future::FutureResult(value = ...future.value$value, 
[18:04:50.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:50.303]                   ...future.rng), globalenv = if (FALSE) 
[18:04:50.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:50.303]                     ...future.globalenv.names))
[18:04:50.303]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:50.303]         }, condition = base::local({
[18:04:50.303]             c <- base::c
[18:04:50.303]             inherits <- base::inherits
[18:04:50.303]             invokeRestart <- base::invokeRestart
[18:04:50.303]             length <- base::length
[18:04:50.303]             list <- base::list
[18:04:50.303]             seq.int <- base::seq.int
[18:04:50.303]             signalCondition <- base::signalCondition
[18:04:50.303]             sys.calls <- base::sys.calls
[18:04:50.303]             `[[` <- base::`[[`
[18:04:50.303]             `+` <- base::`+`
[18:04:50.303]             `<<-` <- base::`<<-`
[18:04:50.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:50.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:50.303]                   3L)]
[18:04:50.303]             }
[18:04:50.303]             function(cond) {
[18:04:50.303]                 is_error <- inherits(cond, "error")
[18:04:50.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:50.303]                   NULL)
[18:04:50.303]                 if (is_error) {
[18:04:50.303]                   sessionInformation <- function() {
[18:04:50.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:50.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:50.303]                       search = base::search(), system = base::Sys.info())
[18:04:50.303]                   }
[18:04:50.303]                   ...future.conditions[[length(...future.conditions) + 
[18:04:50.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:50.303]                     cond$call), session = sessionInformation(), 
[18:04:50.303]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:50.303]                   signalCondition(cond)
[18:04:50.303]                 }
[18:04:50.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:50.303]                 "immediateCondition"))) {
[18:04:50.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:50.303]                   ...future.conditions[[length(...future.conditions) + 
[18:04:50.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:50.303]                   if (TRUE && !signal) {
[18:04:50.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.303]                     {
[18:04:50.303]                       inherits <- base::inherits
[18:04:50.303]                       invokeRestart <- base::invokeRestart
[18:04:50.303]                       is.null <- base::is.null
[18:04:50.303]                       muffled <- FALSE
[18:04:50.303]                       if (inherits(cond, "message")) {
[18:04:50.303]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:50.303]                         if (muffled) 
[18:04:50.303]                           invokeRestart("muffleMessage")
[18:04:50.303]                       }
[18:04:50.303]                       else if (inherits(cond, "warning")) {
[18:04:50.303]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:50.303]                         if (muffled) 
[18:04:50.303]                           invokeRestart("muffleWarning")
[18:04:50.303]                       }
[18:04:50.303]                       else if (inherits(cond, "condition")) {
[18:04:50.303]                         if (!is.null(pattern)) {
[18:04:50.303]                           computeRestarts <- base::computeRestarts
[18:04:50.303]                           grepl <- base::grepl
[18:04:50.303]                           restarts <- computeRestarts(cond)
[18:04:50.303]                           for (restart in restarts) {
[18:04:50.303]                             name <- restart$name
[18:04:50.303]                             if (is.null(name)) 
[18:04:50.303]                               next
[18:04:50.303]                             if (!grepl(pattern, name)) 
[18:04:50.303]                               next
[18:04:50.303]                             invokeRestart(restart)
[18:04:50.303]                             muffled <- TRUE
[18:04:50.303]                             break
[18:04:50.303]                           }
[18:04:50.303]                         }
[18:04:50.303]                       }
[18:04:50.303]                       invisible(muffled)
[18:04:50.303]                     }
[18:04:50.303]                     muffleCondition(cond, pattern = "^muffle")
[18:04:50.303]                   }
[18:04:50.303]                 }
[18:04:50.303]                 else {
[18:04:50.303]                   if (TRUE) {
[18:04:50.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.303]                     {
[18:04:50.303]                       inherits <- base::inherits
[18:04:50.303]                       invokeRestart <- base::invokeRestart
[18:04:50.303]                       is.null <- base::is.null
[18:04:50.303]                       muffled <- FALSE
[18:04:50.303]                       if (inherits(cond, "message")) {
[18:04:50.303]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:50.303]                         if (muffled) 
[18:04:50.303]                           invokeRestart("muffleMessage")
[18:04:50.303]                       }
[18:04:50.303]                       else if (inherits(cond, "warning")) {
[18:04:50.303]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:50.303]                         if (muffled) 
[18:04:50.303]                           invokeRestart("muffleWarning")
[18:04:50.303]                       }
[18:04:50.303]                       else if (inherits(cond, "condition")) {
[18:04:50.303]                         if (!is.null(pattern)) {
[18:04:50.303]                           computeRestarts <- base::computeRestarts
[18:04:50.303]                           grepl <- base::grepl
[18:04:50.303]                           restarts <- computeRestarts(cond)
[18:04:50.303]                           for (restart in restarts) {
[18:04:50.303]                             name <- restart$name
[18:04:50.303]                             if (is.null(name)) 
[18:04:50.303]                               next
[18:04:50.303]                             if (!grepl(pattern, name)) 
[18:04:50.303]                               next
[18:04:50.303]                             invokeRestart(restart)
[18:04:50.303]                             muffled <- TRUE
[18:04:50.303]                             break
[18:04:50.303]                           }
[18:04:50.303]                         }
[18:04:50.303]                       }
[18:04:50.303]                       invisible(muffled)
[18:04:50.303]                     }
[18:04:50.303]                     muffleCondition(cond, pattern = "^muffle")
[18:04:50.303]                   }
[18:04:50.303]                 }
[18:04:50.303]             }
[18:04:50.303]         }))
[18:04:50.303]     }, error = function(ex) {
[18:04:50.303]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:50.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:50.303]                 ...future.rng), started = ...future.startTime, 
[18:04:50.303]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:50.303]             version = "1.8"), class = "FutureResult")
[18:04:50.303]     }, finally = {
[18:04:50.303]         if (!identical(...future.workdir, getwd())) 
[18:04:50.303]             setwd(...future.workdir)
[18:04:50.303]         {
[18:04:50.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:50.303]                 ...future.oldOptions$nwarnings <- NULL
[18:04:50.303]             }
[18:04:50.303]             base::options(...future.oldOptions)
[18:04:50.303]             if (.Platform$OS.type == "windows") {
[18:04:50.303]                 old_names <- names(...future.oldEnvVars)
[18:04:50.303]                 envs <- base::Sys.getenv()
[18:04:50.303]                 names <- names(envs)
[18:04:50.303]                 common <- intersect(names, old_names)
[18:04:50.303]                 added <- setdiff(names, old_names)
[18:04:50.303]                 removed <- setdiff(old_names, names)
[18:04:50.303]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:50.303]                   envs[common]]
[18:04:50.303]                 NAMES <- toupper(changed)
[18:04:50.303]                 args <- list()
[18:04:50.303]                 for (kk in seq_along(NAMES)) {
[18:04:50.303]                   name <- changed[[kk]]
[18:04:50.303]                   NAME <- NAMES[[kk]]
[18:04:50.303]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.303]                     next
[18:04:50.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:50.303]                 }
[18:04:50.303]                 NAMES <- toupper(added)
[18:04:50.303]                 for (kk in seq_along(NAMES)) {
[18:04:50.303]                   name <- added[[kk]]
[18:04:50.303]                   NAME <- NAMES[[kk]]
[18:04:50.303]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.303]                     next
[18:04:50.303]                   args[[name]] <- ""
[18:04:50.303]                 }
[18:04:50.303]                 NAMES <- toupper(removed)
[18:04:50.303]                 for (kk in seq_along(NAMES)) {
[18:04:50.303]                   name <- removed[[kk]]
[18:04:50.303]                   NAME <- NAMES[[kk]]
[18:04:50.303]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.303]                     next
[18:04:50.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:50.303]                 }
[18:04:50.303]                 if (length(args) > 0) 
[18:04:50.303]                   base::do.call(base::Sys.setenv, args = args)
[18:04:50.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:50.303]             }
[18:04:50.303]             else {
[18:04:50.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:50.303]             }
[18:04:50.303]             {
[18:04:50.303]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:50.303]                   0L) {
[18:04:50.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:50.303]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:50.303]                   base::options(opts)
[18:04:50.303]                 }
[18:04:50.303]                 {
[18:04:50.303]                   {
[18:04:50.303]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:50.303]                     NULL
[18:04:50.303]                   }
[18:04:50.303]                   options(future.plan = NULL)
[18:04:50.303]                   if (is.na(NA_character_)) 
[18:04:50.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:50.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:50.303]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:50.303]                     .init = FALSE)
[18:04:50.303]                 }
[18:04:50.303]             }
[18:04:50.303]         }
[18:04:50.303]     })
[18:04:50.303]     if (TRUE) {
[18:04:50.303]         base::sink(type = "output", split = FALSE)
[18:04:50.303]         if (TRUE) {
[18:04:50.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:50.303]         }
[18:04:50.303]         else {
[18:04:50.303]             ...future.result["stdout"] <- base::list(NULL)
[18:04:50.303]         }
[18:04:50.303]         base::close(...future.stdout)
[18:04:50.303]         ...future.stdout <- NULL
[18:04:50.303]     }
[18:04:50.303]     ...future.result$conditions <- ...future.conditions
[18:04:50.303]     ...future.result$finished <- base::Sys.time()
[18:04:50.303]     ...future.result
[18:04:50.303] }
[18:04:50.308] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[18:04:50.308] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[18:04:50.309] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[18:04:50.309] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[18:04:50.311] MultisessionFuture started
[18:04:50.311] - Launch lazy future ... done
[18:04:50.311] run() for ‘MultisessionFuture’ ... done
[18:04:50.311] result() for ClusterFuture ...
[18:04:50.312] receiveMessageFromWorker() for ClusterFuture ...
[18:04:50.312] - Validating connection of MultisessionFuture
[18:04:50.355] - received message: FutureResult
[18:04:50.356] - Received FutureResult
[18:04:50.356] - Erased future from FutureRegistry
[18:04:50.356] result() for ClusterFuture ...
[18:04:50.357] - result already collected: FutureResult
[18:04:50.357] result() for ClusterFuture ... done
[18:04:50.357] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:50.357] result() for ClusterFuture ... done
[18:04:50.357] result() for ClusterFuture ...
[18:04:50.358] - result already collected: FutureResult
[18:04:50.358] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:50.359] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:50.359] Searching for globals...
[18:04:50.364] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:50.364] Searching for globals ... DONE
[18:04:50.365] Resolving globals: TRUE
[18:04:50.365] Resolving any globals that are futures ...
[18:04:50.365] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[18:04:50.365] Resolving any globals that are futures ... DONE
[18:04:50.366] Resolving futures part of globals (recursively) ...
[18:04:50.367] resolve() on list ...
[18:04:50.367]  recursive: 99
[18:04:50.368]  length: 1
[18:04:50.368]  elements: ‘x’
[18:04:50.368]  length: 0 (resolved future 1)
[18:04:50.368] resolve() on list ... DONE
[18:04:50.369] - globals: [1] ‘x’
[18:04:50.369] Resolving futures part of globals (recursively) ... DONE
[18:04:50.369] The total size of the 1 globals is 0 bytes (0 bytes)
[18:04:50.370] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[18:04:50.370] - globals: [1] ‘x’
[18:04:50.371] 
[18:04:50.371] getGlobalsAndPackages() ... DONE
[18:04:50.371] run() for ‘Future’ ...
[18:04:50.372] - state: ‘created’
[18:04:50.372] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:50.397] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:50.397] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:50.398]   - Field: ‘node’
[18:04:50.398]   - Field: ‘label’
[18:04:50.398]   - Field: ‘local’
[18:04:50.398]   - Field: ‘owner’
[18:04:50.398]   - Field: ‘envir’
[18:04:50.399]   - Field: ‘workers’
[18:04:50.399]   - Field: ‘packages’
[18:04:50.399]   - Field: ‘gc’
[18:04:50.399]   - Field: ‘conditions’
[18:04:50.400]   - Field: ‘persistent’
[18:04:50.400]   - Field: ‘expr’
[18:04:50.400]   - Field: ‘uuid’
[18:04:50.400]   - Field: ‘seed’
[18:04:50.400]   - Field: ‘version’
[18:04:50.401]   - Field: ‘result’
[18:04:50.401]   - Field: ‘asynchronous’
[18:04:50.401]   - Field: ‘calls’
[18:04:50.401]   - Field: ‘globals’
[18:04:50.401]   - Field: ‘stdout’
[18:04:50.402]   - Field: ‘earlySignal’
[18:04:50.402]   - Field: ‘lazy’
[18:04:50.402]   - Field: ‘state’
[18:04:50.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:50.402] - Launch lazy future ...
[18:04:50.403] Packages needed by the future expression (n = 0): <none>
[18:04:50.403] Packages needed by future strategies (n = 0): <none>
[18:04:50.404] {
[18:04:50.404]     {
[18:04:50.404]         {
[18:04:50.404]             ...future.startTime <- base::Sys.time()
[18:04:50.404]             {
[18:04:50.404]                 {
[18:04:50.404]                   {
[18:04:50.404]                     {
[18:04:50.404]                       base::local({
[18:04:50.404]                         has_future <- base::requireNamespace("future", 
[18:04:50.404]                           quietly = TRUE)
[18:04:50.404]                         if (has_future) {
[18:04:50.404]                           ns <- base::getNamespace("future")
[18:04:50.404]                           version <- ns[[".package"]][["version"]]
[18:04:50.404]                           if (is.null(version)) 
[18:04:50.404]                             version <- utils::packageVersion("future")
[18:04:50.404]                         }
[18:04:50.404]                         else {
[18:04:50.404]                           version <- NULL
[18:04:50.404]                         }
[18:04:50.404]                         if (!has_future || version < "1.8.0") {
[18:04:50.404]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:50.404]                             "", base::R.version$version.string), 
[18:04:50.404]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:50.404]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:50.404]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:50.404]                               "release", "version")], collapse = " "), 
[18:04:50.404]                             hostname = base::Sys.info()[["nodename"]])
[18:04:50.404]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:50.404]                             info)
[18:04:50.404]                           info <- base::paste(info, collapse = "; ")
[18:04:50.404]                           if (!has_future) {
[18:04:50.404]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:50.404]                               info)
[18:04:50.404]                           }
[18:04:50.404]                           else {
[18:04:50.404]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:50.404]                               info, version)
[18:04:50.404]                           }
[18:04:50.404]                           base::stop(msg)
[18:04:50.404]                         }
[18:04:50.404]                       })
[18:04:50.404]                     }
[18:04:50.404]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:50.404]                     base::options(mc.cores = 1L)
[18:04:50.404]                   }
[18:04:50.404]                   ...future.strategy.old <- future::plan("list")
[18:04:50.404]                   options(future.plan = NULL)
[18:04:50.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:50.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:50.404]                 }
[18:04:50.404]                 ...future.workdir <- getwd()
[18:04:50.404]             }
[18:04:50.404]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:50.404]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:50.404]         }
[18:04:50.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:50.404]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:50.404]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:50.404]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:50.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:50.404]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:50.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:50.404]             base::names(...future.oldOptions))
[18:04:50.404]     }
[18:04:50.404]     if (FALSE) {
[18:04:50.404]     }
[18:04:50.404]     else {
[18:04:50.404]         if (TRUE) {
[18:04:50.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:50.404]                 open = "w")
[18:04:50.404]         }
[18:04:50.404]         else {
[18:04:50.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:50.404]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:50.404]         }
[18:04:50.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:50.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:50.404]             base::sink(type = "output", split = FALSE)
[18:04:50.404]             base::close(...future.stdout)
[18:04:50.404]         }, add = TRUE)
[18:04:50.404]     }
[18:04:50.404]     ...future.frame <- base::sys.nframe()
[18:04:50.404]     ...future.conditions <- base::list()
[18:04:50.404]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:50.404]     if (FALSE) {
[18:04:50.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:50.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:50.404]     }
[18:04:50.404]     ...future.result <- base::tryCatch({
[18:04:50.404]         base::withCallingHandlers({
[18:04:50.404]             ...future.value <- base::withVisible(base::local({
[18:04:50.404]                 ...future.makeSendCondition <- base::local({
[18:04:50.404]                   sendCondition <- NULL
[18:04:50.404]                   function(frame = 1L) {
[18:04:50.404]                     if (is.function(sendCondition)) 
[18:04:50.404]                       return(sendCondition)
[18:04:50.404]                     ns <- getNamespace("parallel")
[18:04:50.404]                     if (exists("sendData", mode = "function", 
[18:04:50.404]                       envir = ns)) {
[18:04:50.404]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:50.404]                         envir = ns)
[18:04:50.404]                       envir <- sys.frame(frame)
[18:04:50.404]                       master <- NULL
[18:04:50.404]                       while (!identical(envir, .GlobalEnv) && 
[18:04:50.404]                         !identical(envir, emptyenv())) {
[18:04:50.404]                         if (exists("master", mode = "list", envir = envir, 
[18:04:50.404]                           inherits = FALSE)) {
[18:04:50.404]                           master <- get("master", mode = "list", 
[18:04:50.404]                             envir = envir, inherits = FALSE)
[18:04:50.404]                           if (inherits(master, c("SOCKnode", 
[18:04:50.404]                             "SOCK0node"))) {
[18:04:50.404]                             sendCondition <<- function(cond) {
[18:04:50.404]                               data <- list(type = "VALUE", value = cond, 
[18:04:50.404]                                 success = TRUE)
[18:04:50.404]                               parallel_sendData(master, data)
[18:04:50.404]                             }
[18:04:50.404]                             return(sendCondition)
[18:04:50.404]                           }
[18:04:50.404]                         }
[18:04:50.404]                         frame <- frame + 1L
[18:04:50.404]                         envir <- sys.frame(frame)
[18:04:50.404]                       }
[18:04:50.404]                     }
[18:04:50.404]                     sendCondition <<- function(cond) NULL
[18:04:50.404]                   }
[18:04:50.404]                 })
[18:04:50.404]                 withCallingHandlers({
[18:04:50.404]                   {
[18:04:50.404]                     x["a"] <- list(1)
[18:04:50.404]                     x
[18:04:50.404]                   }
[18:04:50.404]                 }, immediateCondition = function(cond) {
[18:04:50.404]                   sendCondition <- ...future.makeSendCondition()
[18:04:50.404]                   sendCondition(cond)
[18:04:50.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.404]                   {
[18:04:50.404]                     inherits <- base::inherits
[18:04:50.404]                     invokeRestart <- base::invokeRestart
[18:04:50.404]                     is.null <- base::is.null
[18:04:50.404]                     muffled <- FALSE
[18:04:50.404]                     if (inherits(cond, "message")) {
[18:04:50.404]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:50.404]                       if (muffled) 
[18:04:50.404]                         invokeRestart("muffleMessage")
[18:04:50.404]                     }
[18:04:50.404]                     else if (inherits(cond, "warning")) {
[18:04:50.404]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:50.404]                       if (muffled) 
[18:04:50.404]                         invokeRestart("muffleWarning")
[18:04:50.404]                     }
[18:04:50.404]                     else if (inherits(cond, "condition")) {
[18:04:50.404]                       if (!is.null(pattern)) {
[18:04:50.404]                         computeRestarts <- base::computeRestarts
[18:04:50.404]                         grepl <- base::grepl
[18:04:50.404]                         restarts <- computeRestarts(cond)
[18:04:50.404]                         for (restart in restarts) {
[18:04:50.404]                           name <- restart$name
[18:04:50.404]                           if (is.null(name)) 
[18:04:50.404]                             next
[18:04:50.404]                           if (!grepl(pattern, name)) 
[18:04:50.404]                             next
[18:04:50.404]                           invokeRestart(restart)
[18:04:50.404]                           muffled <- TRUE
[18:04:50.404]                           break
[18:04:50.404]                         }
[18:04:50.404]                       }
[18:04:50.404]                     }
[18:04:50.404]                     invisible(muffled)
[18:04:50.404]                   }
[18:04:50.404]                   muffleCondition(cond)
[18:04:50.404]                 })
[18:04:50.404]             }))
[18:04:50.404]             future::FutureResult(value = ...future.value$value, 
[18:04:50.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:50.404]                   ...future.rng), globalenv = if (FALSE) 
[18:04:50.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:50.404]                     ...future.globalenv.names))
[18:04:50.404]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:50.404]         }, condition = base::local({
[18:04:50.404]             c <- base::c
[18:04:50.404]             inherits <- base::inherits
[18:04:50.404]             invokeRestart <- base::invokeRestart
[18:04:50.404]             length <- base::length
[18:04:50.404]             list <- base::list
[18:04:50.404]             seq.int <- base::seq.int
[18:04:50.404]             signalCondition <- base::signalCondition
[18:04:50.404]             sys.calls <- base::sys.calls
[18:04:50.404]             `[[` <- base::`[[`
[18:04:50.404]             `+` <- base::`+`
[18:04:50.404]             `<<-` <- base::`<<-`
[18:04:50.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:50.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:50.404]                   3L)]
[18:04:50.404]             }
[18:04:50.404]             function(cond) {
[18:04:50.404]                 is_error <- inherits(cond, "error")
[18:04:50.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:50.404]                   NULL)
[18:04:50.404]                 if (is_error) {
[18:04:50.404]                   sessionInformation <- function() {
[18:04:50.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:50.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:50.404]                       search = base::search(), system = base::Sys.info())
[18:04:50.404]                   }
[18:04:50.404]                   ...future.conditions[[length(...future.conditions) + 
[18:04:50.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:50.404]                     cond$call), session = sessionInformation(), 
[18:04:50.404]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:50.404]                   signalCondition(cond)
[18:04:50.404]                 }
[18:04:50.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:50.404]                 "immediateCondition"))) {
[18:04:50.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:50.404]                   ...future.conditions[[length(...future.conditions) + 
[18:04:50.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:50.404]                   if (TRUE && !signal) {
[18:04:50.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.404]                     {
[18:04:50.404]                       inherits <- base::inherits
[18:04:50.404]                       invokeRestart <- base::invokeRestart
[18:04:50.404]                       is.null <- base::is.null
[18:04:50.404]                       muffled <- FALSE
[18:04:50.404]                       if (inherits(cond, "message")) {
[18:04:50.404]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:50.404]                         if (muffled) 
[18:04:50.404]                           invokeRestart("muffleMessage")
[18:04:50.404]                       }
[18:04:50.404]                       else if (inherits(cond, "warning")) {
[18:04:50.404]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:50.404]                         if (muffled) 
[18:04:50.404]                           invokeRestart("muffleWarning")
[18:04:50.404]                       }
[18:04:50.404]                       else if (inherits(cond, "condition")) {
[18:04:50.404]                         if (!is.null(pattern)) {
[18:04:50.404]                           computeRestarts <- base::computeRestarts
[18:04:50.404]                           grepl <- base::grepl
[18:04:50.404]                           restarts <- computeRestarts(cond)
[18:04:50.404]                           for (restart in restarts) {
[18:04:50.404]                             name <- restart$name
[18:04:50.404]                             if (is.null(name)) 
[18:04:50.404]                               next
[18:04:50.404]                             if (!grepl(pattern, name)) 
[18:04:50.404]                               next
[18:04:50.404]                             invokeRestart(restart)
[18:04:50.404]                             muffled <- TRUE
[18:04:50.404]                             break
[18:04:50.404]                           }
[18:04:50.404]                         }
[18:04:50.404]                       }
[18:04:50.404]                       invisible(muffled)
[18:04:50.404]                     }
[18:04:50.404]                     muffleCondition(cond, pattern = "^muffle")
[18:04:50.404]                   }
[18:04:50.404]                 }
[18:04:50.404]                 else {
[18:04:50.404]                   if (TRUE) {
[18:04:50.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.404]                     {
[18:04:50.404]                       inherits <- base::inherits
[18:04:50.404]                       invokeRestart <- base::invokeRestart
[18:04:50.404]                       is.null <- base::is.null
[18:04:50.404]                       muffled <- FALSE
[18:04:50.404]                       if (inherits(cond, "message")) {
[18:04:50.404]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:50.404]                         if (muffled) 
[18:04:50.404]                           invokeRestart("muffleMessage")
[18:04:50.404]                       }
[18:04:50.404]                       else if (inherits(cond, "warning")) {
[18:04:50.404]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:50.404]                         if (muffled) 
[18:04:50.404]                           invokeRestart("muffleWarning")
[18:04:50.404]                       }
[18:04:50.404]                       else if (inherits(cond, "condition")) {
[18:04:50.404]                         if (!is.null(pattern)) {
[18:04:50.404]                           computeRestarts <- base::computeRestarts
[18:04:50.404]                           grepl <- base::grepl
[18:04:50.404]                           restarts <- computeRestarts(cond)
[18:04:50.404]                           for (restart in restarts) {
[18:04:50.404]                             name <- restart$name
[18:04:50.404]                             if (is.null(name)) 
[18:04:50.404]                               next
[18:04:50.404]                             if (!grepl(pattern, name)) 
[18:04:50.404]                               next
[18:04:50.404]                             invokeRestart(restart)
[18:04:50.404]                             muffled <- TRUE
[18:04:50.404]                             break
[18:04:50.404]                           }
[18:04:50.404]                         }
[18:04:50.404]                       }
[18:04:50.404]                       invisible(muffled)
[18:04:50.404]                     }
[18:04:50.404]                     muffleCondition(cond, pattern = "^muffle")
[18:04:50.404]                   }
[18:04:50.404]                 }
[18:04:50.404]             }
[18:04:50.404]         }))
[18:04:50.404]     }, error = function(ex) {
[18:04:50.404]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:50.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:50.404]                 ...future.rng), started = ...future.startTime, 
[18:04:50.404]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:50.404]             version = "1.8"), class = "FutureResult")
[18:04:50.404]     }, finally = {
[18:04:50.404]         if (!identical(...future.workdir, getwd())) 
[18:04:50.404]             setwd(...future.workdir)
[18:04:50.404]         {
[18:04:50.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:50.404]                 ...future.oldOptions$nwarnings <- NULL
[18:04:50.404]             }
[18:04:50.404]             base::options(...future.oldOptions)
[18:04:50.404]             if (.Platform$OS.type == "windows") {
[18:04:50.404]                 old_names <- names(...future.oldEnvVars)
[18:04:50.404]                 envs <- base::Sys.getenv()
[18:04:50.404]                 names <- names(envs)
[18:04:50.404]                 common <- intersect(names, old_names)
[18:04:50.404]                 added <- setdiff(names, old_names)
[18:04:50.404]                 removed <- setdiff(old_names, names)
[18:04:50.404]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:50.404]                   envs[common]]
[18:04:50.404]                 NAMES <- toupper(changed)
[18:04:50.404]                 args <- list()
[18:04:50.404]                 for (kk in seq_along(NAMES)) {
[18:04:50.404]                   name <- changed[[kk]]
[18:04:50.404]                   NAME <- NAMES[[kk]]
[18:04:50.404]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.404]                     next
[18:04:50.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:50.404]                 }
[18:04:50.404]                 NAMES <- toupper(added)
[18:04:50.404]                 for (kk in seq_along(NAMES)) {
[18:04:50.404]                   name <- added[[kk]]
[18:04:50.404]                   NAME <- NAMES[[kk]]
[18:04:50.404]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.404]                     next
[18:04:50.404]                   args[[name]] <- ""
[18:04:50.404]                 }
[18:04:50.404]                 NAMES <- toupper(removed)
[18:04:50.404]                 for (kk in seq_along(NAMES)) {
[18:04:50.404]                   name <- removed[[kk]]
[18:04:50.404]                   NAME <- NAMES[[kk]]
[18:04:50.404]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.404]                     next
[18:04:50.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:50.404]                 }
[18:04:50.404]                 if (length(args) > 0) 
[18:04:50.404]                   base::do.call(base::Sys.setenv, args = args)
[18:04:50.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:50.404]             }
[18:04:50.404]             else {
[18:04:50.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:50.404]             }
[18:04:50.404]             {
[18:04:50.404]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:50.404]                   0L) {
[18:04:50.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:50.404]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:50.404]                   base::options(opts)
[18:04:50.404]                 }
[18:04:50.404]                 {
[18:04:50.404]                   {
[18:04:50.404]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:50.404]                     NULL
[18:04:50.404]                   }
[18:04:50.404]                   options(future.plan = NULL)
[18:04:50.404]                   if (is.na(NA_character_)) 
[18:04:50.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:50.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:50.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:50.404]                     .init = FALSE)
[18:04:50.404]                 }
[18:04:50.404]             }
[18:04:50.404]         }
[18:04:50.404]     })
[18:04:50.404]     if (TRUE) {
[18:04:50.404]         base::sink(type = "output", split = FALSE)
[18:04:50.404]         if (TRUE) {
[18:04:50.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:50.404]         }
[18:04:50.404]         else {
[18:04:50.404]             ...future.result["stdout"] <- base::list(NULL)
[18:04:50.404]         }
[18:04:50.404]         base::close(...future.stdout)
[18:04:50.404]         ...future.stdout <- NULL
[18:04:50.404]     }
[18:04:50.404]     ...future.result$conditions <- ...future.conditions
[18:04:50.404]     ...future.result$finished <- base::Sys.time()
[18:04:50.404]     ...future.result
[18:04:50.404] }
[18:04:50.409] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[18:04:50.410] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[18:04:50.411] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[18:04:50.411] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[18:04:50.412] MultisessionFuture started
[18:04:50.412] - Launch lazy future ... done
[18:04:50.413] run() for ‘MultisessionFuture’ ... done
[18:04:50.414] result() for ClusterFuture ...
[18:04:50.414] receiveMessageFromWorker() for ClusterFuture ...
[18:04:50.415] - Validating connection of MultisessionFuture
[18:04:50.456] - received message: FutureResult
[18:04:50.456] - Received FutureResult
[18:04:50.456] - Erased future from FutureRegistry
[18:04:50.457] result() for ClusterFuture ...
[18:04:50.457] - result already collected: FutureResult
[18:04:50.457] result() for ClusterFuture ... done
[18:04:50.457] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:50.458] result() for ClusterFuture ... done
[18:04:50.458] result() for ClusterFuture ...
[18:04:50.458] - result already collected: FutureResult
[18:04:50.458] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:50.459] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:50.460] Searching for globals...
[18:04:50.465] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[18:04:50.465] Searching for globals ... DONE
[18:04:50.465] Resolving globals: TRUE
[18:04:50.465] Resolving any globals that are futures ...
[18:04:50.466] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[18:04:50.466] Resolving any globals that are futures ... DONE
[18:04:50.467] Resolving futures part of globals (recursively) ...
[18:04:50.467] resolve() on list ...
[18:04:50.468]  recursive: 99
[18:04:50.468]  length: 2
[18:04:50.468]  elements: ‘x’, ‘name’
[18:04:50.468]  length: 1 (resolved future 1)
[18:04:50.469]  length: 0 (resolved future 2)
[18:04:50.469] resolve() on list ... DONE
[18:04:50.469] - globals: [2] ‘x’, ‘name’
[18:04:50.469] Resolving futures part of globals (recursively) ... DONE
[18:04:50.470] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:50.470] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[18:04:50.471] - globals: [2] ‘x’, ‘name’
[18:04:50.471] 
[18:04:50.471] getGlobalsAndPackages() ... DONE
[18:04:50.472] run() for ‘Future’ ...
[18:04:50.472] - state: ‘created’
[18:04:50.472] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:50.498] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:50.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:50.499]   - Field: ‘node’
[18:04:50.499]   - Field: ‘label’
[18:04:50.499]   - Field: ‘local’
[18:04:50.500]   - Field: ‘owner’
[18:04:50.500]   - Field: ‘envir’
[18:04:50.500]   - Field: ‘workers’
[18:04:50.500]   - Field: ‘packages’
[18:04:50.500]   - Field: ‘gc’
[18:04:50.501]   - Field: ‘conditions’
[18:04:50.501]   - Field: ‘persistent’
[18:04:50.501]   - Field: ‘expr’
[18:04:50.501]   - Field: ‘uuid’
[18:04:50.501]   - Field: ‘seed’
[18:04:50.502]   - Field: ‘version’
[18:04:50.502]   - Field: ‘result’
[18:04:50.502]   - Field: ‘asynchronous’
[18:04:50.502]   - Field: ‘calls’
[18:04:50.503]   - Field: ‘globals’
[18:04:50.503]   - Field: ‘stdout’
[18:04:50.503]   - Field: ‘earlySignal’
[18:04:50.504]   - Field: ‘lazy’
[18:04:50.504]   - Field: ‘state’
[18:04:50.504] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:50.504] - Launch lazy future ...
[18:04:50.505] Packages needed by the future expression (n = 0): <none>
[18:04:50.505] Packages needed by future strategies (n = 0): <none>
[18:04:50.506] {
[18:04:50.506]     {
[18:04:50.506]         {
[18:04:50.506]             ...future.startTime <- base::Sys.time()
[18:04:50.506]             {
[18:04:50.506]                 {
[18:04:50.506]                   {
[18:04:50.506]                     {
[18:04:50.506]                       base::local({
[18:04:50.506]                         has_future <- base::requireNamespace("future", 
[18:04:50.506]                           quietly = TRUE)
[18:04:50.506]                         if (has_future) {
[18:04:50.506]                           ns <- base::getNamespace("future")
[18:04:50.506]                           version <- ns[[".package"]][["version"]]
[18:04:50.506]                           if (is.null(version)) 
[18:04:50.506]                             version <- utils::packageVersion("future")
[18:04:50.506]                         }
[18:04:50.506]                         else {
[18:04:50.506]                           version <- NULL
[18:04:50.506]                         }
[18:04:50.506]                         if (!has_future || version < "1.8.0") {
[18:04:50.506]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:50.506]                             "", base::R.version$version.string), 
[18:04:50.506]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:50.506]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:50.506]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:50.506]                               "release", "version")], collapse = " "), 
[18:04:50.506]                             hostname = base::Sys.info()[["nodename"]])
[18:04:50.506]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:50.506]                             info)
[18:04:50.506]                           info <- base::paste(info, collapse = "; ")
[18:04:50.506]                           if (!has_future) {
[18:04:50.506]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:50.506]                               info)
[18:04:50.506]                           }
[18:04:50.506]                           else {
[18:04:50.506]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:50.506]                               info, version)
[18:04:50.506]                           }
[18:04:50.506]                           base::stop(msg)
[18:04:50.506]                         }
[18:04:50.506]                       })
[18:04:50.506]                     }
[18:04:50.506]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:50.506]                     base::options(mc.cores = 1L)
[18:04:50.506]                   }
[18:04:50.506]                   ...future.strategy.old <- future::plan("list")
[18:04:50.506]                   options(future.plan = NULL)
[18:04:50.506]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:50.506]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:50.506]                 }
[18:04:50.506]                 ...future.workdir <- getwd()
[18:04:50.506]             }
[18:04:50.506]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:50.506]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:50.506]         }
[18:04:50.506]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:50.506]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:50.506]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:50.506]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:50.506]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:50.506]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:50.506]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:50.506]             base::names(...future.oldOptions))
[18:04:50.506]     }
[18:04:50.506]     if (FALSE) {
[18:04:50.506]     }
[18:04:50.506]     else {
[18:04:50.506]         if (TRUE) {
[18:04:50.506]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:50.506]                 open = "w")
[18:04:50.506]         }
[18:04:50.506]         else {
[18:04:50.506]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:50.506]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:50.506]         }
[18:04:50.506]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:50.506]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:50.506]             base::sink(type = "output", split = FALSE)
[18:04:50.506]             base::close(...future.stdout)
[18:04:50.506]         }, add = TRUE)
[18:04:50.506]     }
[18:04:50.506]     ...future.frame <- base::sys.nframe()
[18:04:50.506]     ...future.conditions <- base::list()
[18:04:50.506]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:50.506]     if (FALSE) {
[18:04:50.506]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:50.506]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:50.506]     }
[18:04:50.506]     ...future.result <- base::tryCatch({
[18:04:50.506]         base::withCallingHandlers({
[18:04:50.506]             ...future.value <- base::withVisible(base::local({
[18:04:50.506]                 ...future.makeSendCondition <- base::local({
[18:04:50.506]                   sendCondition <- NULL
[18:04:50.506]                   function(frame = 1L) {
[18:04:50.506]                     if (is.function(sendCondition)) 
[18:04:50.506]                       return(sendCondition)
[18:04:50.506]                     ns <- getNamespace("parallel")
[18:04:50.506]                     if (exists("sendData", mode = "function", 
[18:04:50.506]                       envir = ns)) {
[18:04:50.506]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:50.506]                         envir = ns)
[18:04:50.506]                       envir <- sys.frame(frame)
[18:04:50.506]                       master <- NULL
[18:04:50.506]                       while (!identical(envir, .GlobalEnv) && 
[18:04:50.506]                         !identical(envir, emptyenv())) {
[18:04:50.506]                         if (exists("master", mode = "list", envir = envir, 
[18:04:50.506]                           inherits = FALSE)) {
[18:04:50.506]                           master <- get("master", mode = "list", 
[18:04:50.506]                             envir = envir, inherits = FALSE)
[18:04:50.506]                           if (inherits(master, c("SOCKnode", 
[18:04:50.506]                             "SOCK0node"))) {
[18:04:50.506]                             sendCondition <<- function(cond) {
[18:04:50.506]                               data <- list(type = "VALUE", value = cond, 
[18:04:50.506]                                 success = TRUE)
[18:04:50.506]                               parallel_sendData(master, data)
[18:04:50.506]                             }
[18:04:50.506]                             return(sendCondition)
[18:04:50.506]                           }
[18:04:50.506]                         }
[18:04:50.506]                         frame <- frame + 1L
[18:04:50.506]                         envir <- sys.frame(frame)
[18:04:50.506]                       }
[18:04:50.506]                     }
[18:04:50.506]                     sendCondition <<- function(cond) NULL
[18:04:50.506]                   }
[18:04:50.506]                 })
[18:04:50.506]                 withCallingHandlers({
[18:04:50.506]                   {
[18:04:50.506]                     x[name] <- list(1)
[18:04:50.506]                     x
[18:04:50.506]                   }
[18:04:50.506]                 }, immediateCondition = function(cond) {
[18:04:50.506]                   sendCondition <- ...future.makeSendCondition()
[18:04:50.506]                   sendCondition(cond)
[18:04:50.506]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.506]                   {
[18:04:50.506]                     inherits <- base::inherits
[18:04:50.506]                     invokeRestart <- base::invokeRestart
[18:04:50.506]                     is.null <- base::is.null
[18:04:50.506]                     muffled <- FALSE
[18:04:50.506]                     if (inherits(cond, "message")) {
[18:04:50.506]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:50.506]                       if (muffled) 
[18:04:50.506]                         invokeRestart("muffleMessage")
[18:04:50.506]                     }
[18:04:50.506]                     else if (inherits(cond, "warning")) {
[18:04:50.506]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:50.506]                       if (muffled) 
[18:04:50.506]                         invokeRestart("muffleWarning")
[18:04:50.506]                     }
[18:04:50.506]                     else if (inherits(cond, "condition")) {
[18:04:50.506]                       if (!is.null(pattern)) {
[18:04:50.506]                         computeRestarts <- base::computeRestarts
[18:04:50.506]                         grepl <- base::grepl
[18:04:50.506]                         restarts <- computeRestarts(cond)
[18:04:50.506]                         for (restart in restarts) {
[18:04:50.506]                           name <- restart$name
[18:04:50.506]                           if (is.null(name)) 
[18:04:50.506]                             next
[18:04:50.506]                           if (!grepl(pattern, name)) 
[18:04:50.506]                             next
[18:04:50.506]                           invokeRestart(restart)
[18:04:50.506]                           muffled <- TRUE
[18:04:50.506]                           break
[18:04:50.506]                         }
[18:04:50.506]                       }
[18:04:50.506]                     }
[18:04:50.506]                     invisible(muffled)
[18:04:50.506]                   }
[18:04:50.506]                   muffleCondition(cond)
[18:04:50.506]                 })
[18:04:50.506]             }))
[18:04:50.506]             future::FutureResult(value = ...future.value$value, 
[18:04:50.506]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:50.506]                   ...future.rng), globalenv = if (FALSE) 
[18:04:50.506]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:50.506]                     ...future.globalenv.names))
[18:04:50.506]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:50.506]         }, condition = base::local({
[18:04:50.506]             c <- base::c
[18:04:50.506]             inherits <- base::inherits
[18:04:50.506]             invokeRestart <- base::invokeRestart
[18:04:50.506]             length <- base::length
[18:04:50.506]             list <- base::list
[18:04:50.506]             seq.int <- base::seq.int
[18:04:50.506]             signalCondition <- base::signalCondition
[18:04:50.506]             sys.calls <- base::sys.calls
[18:04:50.506]             `[[` <- base::`[[`
[18:04:50.506]             `+` <- base::`+`
[18:04:50.506]             `<<-` <- base::`<<-`
[18:04:50.506]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:50.506]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:50.506]                   3L)]
[18:04:50.506]             }
[18:04:50.506]             function(cond) {
[18:04:50.506]                 is_error <- inherits(cond, "error")
[18:04:50.506]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:50.506]                   NULL)
[18:04:50.506]                 if (is_error) {
[18:04:50.506]                   sessionInformation <- function() {
[18:04:50.506]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:50.506]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:50.506]                       search = base::search(), system = base::Sys.info())
[18:04:50.506]                   }
[18:04:50.506]                   ...future.conditions[[length(...future.conditions) + 
[18:04:50.506]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:50.506]                     cond$call), session = sessionInformation(), 
[18:04:50.506]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:50.506]                   signalCondition(cond)
[18:04:50.506]                 }
[18:04:50.506]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:50.506]                 "immediateCondition"))) {
[18:04:50.506]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:50.506]                   ...future.conditions[[length(...future.conditions) + 
[18:04:50.506]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:50.506]                   if (TRUE && !signal) {
[18:04:50.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.506]                     {
[18:04:50.506]                       inherits <- base::inherits
[18:04:50.506]                       invokeRestart <- base::invokeRestart
[18:04:50.506]                       is.null <- base::is.null
[18:04:50.506]                       muffled <- FALSE
[18:04:50.506]                       if (inherits(cond, "message")) {
[18:04:50.506]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:50.506]                         if (muffled) 
[18:04:50.506]                           invokeRestart("muffleMessage")
[18:04:50.506]                       }
[18:04:50.506]                       else if (inherits(cond, "warning")) {
[18:04:50.506]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:50.506]                         if (muffled) 
[18:04:50.506]                           invokeRestart("muffleWarning")
[18:04:50.506]                       }
[18:04:50.506]                       else if (inherits(cond, "condition")) {
[18:04:50.506]                         if (!is.null(pattern)) {
[18:04:50.506]                           computeRestarts <- base::computeRestarts
[18:04:50.506]                           grepl <- base::grepl
[18:04:50.506]                           restarts <- computeRestarts(cond)
[18:04:50.506]                           for (restart in restarts) {
[18:04:50.506]                             name <- restart$name
[18:04:50.506]                             if (is.null(name)) 
[18:04:50.506]                               next
[18:04:50.506]                             if (!grepl(pattern, name)) 
[18:04:50.506]                               next
[18:04:50.506]                             invokeRestart(restart)
[18:04:50.506]                             muffled <- TRUE
[18:04:50.506]                             break
[18:04:50.506]                           }
[18:04:50.506]                         }
[18:04:50.506]                       }
[18:04:50.506]                       invisible(muffled)
[18:04:50.506]                     }
[18:04:50.506]                     muffleCondition(cond, pattern = "^muffle")
[18:04:50.506]                   }
[18:04:50.506]                 }
[18:04:50.506]                 else {
[18:04:50.506]                   if (TRUE) {
[18:04:50.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:50.506]                     {
[18:04:50.506]                       inherits <- base::inherits
[18:04:50.506]                       invokeRestart <- base::invokeRestart
[18:04:50.506]                       is.null <- base::is.null
[18:04:50.506]                       muffled <- FALSE
[18:04:50.506]                       if (inherits(cond, "message")) {
[18:04:50.506]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:50.506]                         if (muffled) 
[18:04:50.506]                           invokeRestart("muffleMessage")
[18:04:50.506]                       }
[18:04:50.506]                       else if (inherits(cond, "warning")) {
[18:04:50.506]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:50.506]                         if (muffled) 
[18:04:50.506]                           invokeRestart("muffleWarning")
[18:04:50.506]                       }
[18:04:50.506]                       else if (inherits(cond, "condition")) {
[18:04:50.506]                         if (!is.null(pattern)) {
[18:04:50.506]                           computeRestarts <- base::computeRestarts
[18:04:50.506]                           grepl <- base::grepl
[18:04:50.506]                           restarts <- computeRestarts(cond)
[18:04:50.506]                           for (restart in restarts) {
[18:04:50.506]                             name <- restart$name
[18:04:50.506]                             if (is.null(name)) 
[18:04:50.506]                               next
[18:04:50.506]                             if (!grepl(pattern, name)) 
[18:04:50.506]                               next
[18:04:50.506]                             invokeRestart(restart)
[18:04:50.506]                             muffled <- TRUE
[18:04:50.506]                             break
[18:04:50.506]                           }
[18:04:50.506]                         }
[18:04:50.506]                       }
[18:04:50.506]                       invisible(muffled)
[18:04:50.506]                     }
[18:04:50.506]                     muffleCondition(cond, pattern = "^muffle")
[18:04:50.506]                   }
[18:04:50.506]                 }
[18:04:50.506]             }
[18:04:50.506]         }))
[18:04:50.506]     }, error = function(ex) {
[18:04:50.506]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:50.506]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:50.506]                 ...future.rng), started = ...future.startTime, 
[18:04:50.506]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:50.506]             version = "1.8"), class = "FutureResult")
[18:04:50.506]     }, finally = {
[18:04:50.506]         if (!identical(...future.workdir, getwd())) 
[18:04:50.506]             setwd(...future.workdir)
[18:04:50.506]         {
[18:04:50.506]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:50.506]                 ...future.oldOptions$nwarnings <- NULL
[18:04:50.506]             }
[18:04:50.506]             base::options(...future.oldOptions)
[18:04:50.506]             if (.Platform$OS.type == "windows") {
[18:04:50.506]                 old_names <- names(...future.oldEnvVars)
[18:04:50.506]                 envs <- base::Sys.getenv()
[18:04:50.506]                 names <- names(envs)
[18:04:50.506]                 common <- intersect(names, old_names)
[18:04:50.506]                 added <- setdiff(names, old_names)
[18:04:50.506]                 removed <- setdiff(old_names, names)
[18:04:50.506]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:50.506]                   envs[common]]
[18:04:50.506]                 NAMES <- toupper(changed)
[18:04:50.506]                 args <- list()
[18:04:50.506]                 for (kk in seq_along(NAMES)) {
[18:04:50.506]                   name <- changed[[kk]]
[18:04:50.506]                   NAME <- NAMES[[kk]]
[18:04:50.506]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.506]                     next
[18:04:50.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:50.506]                 }
[18:04:50.506]                 NAMES <- toupper(added)
[18:04:50.506]                 for (kk in seq_along(NAMES)) {
[18:04:50.506]                   name <- added[[kk]]
[18:04:50.506]                   NAME <- NAMES[[kk]]
[18:04:50.506]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.506]                     next
[18:04:50.506]                   args[[name]] <- ""
[18:04:50.506]                 }
[18:04:50.506]                 NAMES <- toupper(removed)
[18:04:50.506]                 for (kk in seq_along(NAMES)) {
[18:04:50.506]                   name <- removed[[kk]]
[18:04:50.506]                   NAME <- NAMES[[kk]]
[18:04:50.506]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:50.506]                     next
[18:04:50.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:50.506]                 }
[18:04:50.506]                 if (length(args) > 0) 
[18:04:50.506]                   base::do.call(base::Sys.setenv, args = args)
[18:04:50.506]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:50.506]             }
[18:04:50.506]             else {
[18:04:50.506]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:50.506]             }
[18:04:50.506]             {
[18:04:50.506]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:50.506]                   0L) {
[18:04:50.506]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:50.506]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:50.506]                   base::options(opts)
[18:04:50.506]                 }
[18:04:50.506]                 {
[18:04:50.506]                   {
[18:04:50.506]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:50.506]                     NULL
[18:04:50.506]                   }
[18:04:50.506]                   options(future.plan = NULL)
[18:04:50.506]                   if (is.na(NA_character_)) 
[18:04:50.506]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:50.506]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:50.506]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:50.506]                     .init = FALSE)
[18:04:50.506]                 }
[18:04:50.506]             }
[18:04:50.506]         }
[18:04:50.506]     })
[18:04:50.506]     if (TRUE) {
[18:04:50.506]         base::sink(type = "output", split = FALSE)
[18:04:50.506]         if (TRUE) {
[18:04:50.506]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:50.506]         }
[18:04:50.506]         else {
[18:04:50.506]             ...future.result["stdout"] <- base::list(NULL)
[18:04:50.506]         }
[18:04:50.506]         base::close(...future.stdout)
[18:04:50.506]         ...future.stdout <- NULL
[18:04:50.506]     }
[18:04:50.506]     ...future.result$conditions <- ...future.conditions
[18:04:50.506]     ...future.result$finished <- base::Sys.time()
[18:04:50.506]     ...future.result
[18:04:50.506] }
[18:04:50.511] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[18:04:50.512] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[18:04:50.512] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[18:04:50.513] Exporting ‘name’ (112 bytes) to cluster node #1 ...
[18:04:50.514] Exporting ‘name’ (112 bytes) to cluster node #1 ... DONE
[18:04:50.514] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[18:04:50.515] MultisessionFuture started
[18:04:50.515] - Launch lazy future ... done
[18:04:50.515] run() for ‘MultisessionFuture’ ... done
[18:04:50.516] result() for ClusterFuture ...
[18:04:50.516] receiveMessageFromWorker() for ClusterFuture ...
[18:04:50.516] - Validating connection of MultisessionFuture
[18:04:50.559] - received message: FutureResult
[18:04:50.560] - Received FutureResult
[18:04:50.560] - Erased future from FutureRegistry
[18:04:50.560] result() for ClusterFuture ...
[18:04:50.561] - result already collected: FutureResult
[18:04:50.561] result() for ClusterFuture ... done
[18:04:50.561] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:50.561] result() for ClusterFuture ... done
[18:04:50.561] result() for ClusterFuture ...
[18:04:50.562] - result already collected: FutureResult
[18:04:50.562] result() for ClusterFuture ... done
$a
[1] 1

Testing with 2 cores ... DONE
> 
> message("*** Globals - subassignments w/ x$a <- value ... DONE")
*** Globals - subassignments w/ x$a <- value ... DONE
> 
> message("*** Globals - subassignments ... DONE")
*** Globals - subassignments ... DONE
> 
> source("incl/end.R")
[18:04:50.566] plan(): Setting new future strategy stack:
[18:04:50.567] List of future strategies:
[18:04:50.567] 1. FutureStrategy:
[18:04:50.567]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:50.567]    - tweaked: FALSE
[18:04:50.567]    - call: future::plan(oplan)
[18:04:50.568] plan(): nbrOfWorkers() = 1
> 
