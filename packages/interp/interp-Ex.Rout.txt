
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "interp"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('interp')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("akima")
> ### * akima
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: akima
> ### Title: Waveform Distortion Data for Bivariate Interpolation
> ### Aliases: akima
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(rgl)
> ##D data(akima)
> ##D # data
> ##D rgl.spheres(akima$x,akima$z , akima$y,0.5,color="red")
> ##D rgl.bbox()
> ##D # bivariate linear interpolation
> ##D # interp:
> ##D akima.li <- interp(akima$x, akima$y, akima$z, 
> ##D                    xo=seq(min(akima$x), max(akima$x), length = 100),
> ##D                    yo=seq(min(akima$y), max(akima$y), length = 100))
> ##D # interp surface:
> ##D rgl.surface(akima.li$x,akima.li$y,akima.li$z,color="green",alpha=c(0.5))
> ##D # interpp:
> ##D akima.p <- interpp(akima$x, akima$y, akima$z,
> ##D                     runif(200,min(akima$x),max(akima$x)),
> ##D                     runif(200,min(akima$y),max(akima$y)))
> ##D # interpp points:
> ##D rgl.points(akima.p$x,akima.p$z , akima.p$y,size=4,color="yellow")
> ##D 
> ##D # bivariate spline interpolation
> ##D # data
> ##D rgl.spheres(akima$x,akima$z , akima$y,0.5,color="red")
> ##D rgl.bbox()
> ##D # bivariate cubic spline interpolation
> ##D # interp:
> ##D akima.si <- interp(akima$x, akima$y, akima$z, 
> ##D                    xo=seq(min(akima$x), max(akima$x), length = 100),
> ##D                    yo=seq(min(akima$y), max(akima$y), length = 100),
> ##D                    linear = FALSE, extrap = TRUE)
> ##D # interp surface:
> ##D rgl.surface(akima.si$x,akima.si$y,akima.si$z,color="green",alpha=c(0.5))
> ##D # interpp:
> ##D akima.sp <- interpp(akima$x, akima$y, akima$z,
> ##D                     runif(200,min(akima$x),max(akima$x)),
> ##D                     runif(200,min(akima$y),max(akima$y)),
> ##D                    linear = FALSE, extrap = TRUE)
> ##D # interpp points:
> ##D rgl.points(akima.sp$x,akima.sp$z , akima.sp$y,size=4,color="yellow")
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("akima474")
> ### * akima474
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: akima474
> ### Title: Sample data from Akima's Bicubic Spline Interpolation code (TOMS
> ###   474)
> ### Aliases: akima474
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(rgl)
> ##D data(akima474)
> ##D # data
> ##D rgl.spheres(akima474$x,akima474$z , akima474$y,0.5,color="red")
> ##D rgl.bbox()
> ##D # bivariate linear interpolation
> ##D # interp:
> ##D akima474.li <- interp(akima474$x, akima474$y, akima474$z, 
> ##D                    xo=seq(min(akima474$x), max(akima474$x), length = 100),
> ##D                    yo=seq(min(akima474$y), max(akima474$y), length = 100))
> ##D # interp surface:
> ##D rgl.surface(akima474.li$x,akima474.li$y,akima474.li$z,color="green",alpha=c(0.5))
> ##D # interpp:
> ##D akima474.p <- interpp(akima474$x, akima474$y, akima474$z,
> ##D                     runif(200,min(akima474$x),max(akima474$x)),
> ##D                     runif(200,min(akima474$y),max(akima474$y)))
> ##D # interpp points:
> ##D rgl.points(akima474.p$x,akima474.p$z , akima474.p$y,size=4,color="yellow")
> ##D 
> ##D # bivariate spline interpolation
> ##D # data
> ##D rgl.spheres(akima474$x,akima474$z , akima474$y,0.5,color="red")
> ##D rgl.bbox()
> ##D # bivariate cubic spline interpolation
> ##D # interp:
> ##D akima474.si <- interp(akima474$x, akima474$y, akima474$z, 
> ##D                    xo=seq(min(akima474$x), max(akima474$x), length = 100),
> ##D                    yo=seq(min(akima474$y), max(akima474$y), length = 100),
> ##D                    linear = FALSE, extrap = TRUE)
> ##D # interp surface:
> ##D rgl.surface(akima474.si$x,akima474.si$y,akima474.si$z,color="green",alpha=c(0.5))
> ##D # interpp:
> ##D akima474.sp <- interpp(akima474$x, akima474$y, akima474$z,
> ##D                     runif(200,min(akima474$x),max(akima474$x)),
> ##D                     runif(200,min(akima474$y),max(akima474$y)),
> ##D                    linear = FALSE, extrap = TRUE)
> ##D # interpp points:
> ##D rgl.points(akima474.sp$x,akima474.sp$z , akima474.sp$y,size=4,color="yellow")
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("arcs")
> ### * arcs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: arcs
> ### Title: Extract a list of arcs from a triangulation object.
> ### Aliases: arcs
> ### Keywords: spatial dplot
> 
> ### ** Examples
> 
> data(franke)
> tr <- tri.mesh(franke$ds3)
> arcs(tr)
      from to
 [1,]   11  4
 [2,]    4  1
 [3,]    1 11
 [4,]   11 12
 [5,]   12  4
 [6,]    4  8
 [7,]    8  1
 [8,]    4  6
 [9,]    6 10
[10,]   10  4
[11,]   12  6
[12,]    5 16
[13,]   16 12
[14,]   12  5
[15,]   11  5
[16,]   16  6
[17,]   10  8
[18,]    3  6
[19,]    6 13
[20,]   13  3
[21,]   16 21
[22,]   21  6
[23,]   22 17
[24,]   17 16
[25,]   16 22
[26,]    5 22
[27,]   10  3
[28,]    3  8
[29,]   21 17
[30,]   17 15
[31,]   15 21
[32,]   21 13
[33,]   22 19
[34,]   19 17
[35,]    5 25
[36,]   25 22
[37,]   15 13
[38,]   23 15
[39,]   17 23
[40,]    3  2
[41,]    2  8
[42,]   13  9
[43,]    9  3
[44,]   13 14
[45,]   14  9
[46,]   15 14
[47,]   23 18
[48,]   18 15
[49,]   19 23
[50,]    7 19
[51,]   19 25
[52,]   25  7
[53,]    5  7
[54,]   18 14
[55,]   19 24
[56,]   24 23
[57,]    9  2
[58,]   20  9
[59,]   14 20
[60,]   18 20
[61,]   24 20
[62,]   18 24
[63,]   24  9
[64,]    7 24
> 
> 
> 
> cleanEx()
> nameEx("area")
> ### * area
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: area
> ### Title: Extract a list of triangle areas from a triangulation object.
> ### Aliases: area
> ### Keywords: spatial utilities
> 
> ### ** Examples
> 
> data(franke)
> tr <- tri.mesh(franke$ds3)
> area(tr)
 [1] 0.02187500 0.03281250 0.02421875 0.02656250 0.03656250 0.02492188
 [7] 0.03906250 0.02429687 0.03546875 0.02523438 0.02015625 0.02023437
[13] 0.02585937 0.01914063 0.01539063 0.02125000 0.01875000 0.01968750
[19] 0.04265625 0.02437500 0.02468750 0.02203125 0.05703125 0.03984375
[25] 0.02109375 0.01703125 0.01757812 0.02234375 0.03218750 0.01968750
[31] 0.03281250 0.01640625 0.05038281 0.06343750 0.02921875 0.02203125
[37] 0.03222656 0.02135156 0.03540625 0.00850000
> 
> 
> 
> cleanEx()
> nameEx("aspline")
> ### * aspline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aspline
> ### Title: Univariate Akima interpolation
> ### Aliases: aspline aSpline
> ### Keywords: arith dplot
> 
> ### ** Examples
> 
> ## regular spaced data
> x <- 1:10
> y <- c(rnorm(5), c(1,1,1,1,3))
> 
> xnew <- seq(-1, 11, 0.1)
> plot(x, y, ylim=c(-3, 3), xlim=range(xnew))
> ## stats::spline() for comparison
> lines(spline(x, y, xmin=min(xnew), xmax=max(xnew), n=200), col="blue")
> 
> lines(aspline(x, y, xnew, method="original"), col="red")
> lines(aspline(x, y, xnew, method="improved"), col="black", lty="dotted")
> lines(aspline(x, y, xnew, method="improved", degree=10), col="green", lty="dashed")
> 
> ## irregular spaced data
> x <- sort(runif(10, max=10))
> y <- c(rnorm(5), c(1,1,1,1,3))
> 
> xnew <- seq(-1, 11, 0.1)
> plot(x, y, ylim=c(-3, 3), xlim=range(xnew))
> ## stats::spline() for comparison
> lines(spline(x, y, xmin=min(xnew), xmax=max(xnew), n=200), col="blue")
> 
> lines(aspline(x, y, xnew, method="original"), col="red")
> lines(aspline(x, y, xnew, method="improved"), col="black", lty="dotted")
> lines(aspline(x, y, xnew, method="improved", degree=10), col="green", lty="dashed")
> 
> ## an example of Akima, 1991
> x <- c(-3, -2, -1, 0,  1,  2, 2.5, 3)
> y <- c( 0,  0,  0, 0, -1, -1, 0,   2)
> 
> plot(x, y, ylim=c(-3, 3))
> ## stats::spline() for comparison
> lines(spline(x, y, n=200), col="blue")
> 
> lines(aspline(x, y, n=200, method="original"), col="red")
> lines(aspline(x, y, n=200, method="improved"), col="black", lty="dotted")
> lines(aspline(x, y, n=200, method="improved", degree=10), col="green", lty="dashed")
> 
> 
> 
> cleanEx()
> nameEx("bicubic")
> ### * bicubic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bicubic
> ### Title: Bivariate Interpolation for Data on a Rectangular grid
> ### Aliases: bicubic
> ### Keywords: dplot
> 
> ### ** Examples
> 
> data(akima474)
> # interpolate at the diagonal of the grid [0,8]x[0,10]
> akima.bic <- bicubic(akima474$x,akima474$y,akima474$z,
+                      seq(0,8,length=50), seq(0,10,length=50))
Warning in bicubic(akima474$x, akima474$y, akima474$z, seq(0, 8, length = 50),  :
  this output is generated according to Akimas irregular grid splines, not the regular grid one! This is a temporary workaround until Akimas ACM algorithm 760 is reimplmented from scratch!
> plot(sqrt(akima.bic$x^2+akima.bic$y^2), akima.bic$z, type="l")
> 
> 
> 
> 
> cleanEx()
> nameEx("bicubic.grid")
> ### * bicubic.grid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bicubic.grid
> ### Title: Bicubic Interpolation for Data on a Rectangular grid
> ### Aliases: bicubic.grid
> ### Keywords: dplot
> 
> ### ** Examples
> 
> data(akima474)
> # interpolate at a grid [0,8]x[0,10]
> akima.bic <- bicubic.grid(akima474$x,akima474$y,akima474$z)
Warning in bicubic(x, y, z, xy[, 1], xy[, 2]) :
  this output is generated according to Akimas irregular grid splines, not the regular grid one! This is a temporary workaround until Akimas ACM algorithm 760 is reimplmented from scratch!
> zmin <- min(akima.bic$z, na.rm=TRUE)
> zmax <- max(akima.bic$z, na.rm=TRUE)
> breaks <- pretty(c(zmin,zmax),10)
> colors <- heat.colors(length(breaks)-1)
> image(akima.bic, breaks=breaks, col=colors)
> contour(akima.bic, levels=breaks,  add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("bilinear")
> ### * bilinear
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bilinear
> ### Title: Bilinear Interpolation for Data on a Rectangular grid
> ### Aliases: bilinear BiLinear
> ### Keywords: dplot
> 
> ### ** Examples
> 
> data(akima474)
> # interpolate at the diagonal of the grid [0,8]x[0,10]
> akima.bil <- bilinear(akima474$x,akima474$y,akima474$z,
+                      seq(0,8,length=50), seq(0,10,length=50))
> plot(sqrt(akima.bil$x^2+akima.bil$y^2), akima.bil$z, type="l")
> 
> 
> 
> cleanEx()
> nameEx("bilinear.grid")
> ### * bilinear.grid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bilinear.grid
> ### Title: Bilinear Interpolation for Data on a Rectangular grid
> ### Aliases: bilinear.grid BiLinear.grid
> ### Keywords: dplot
> 
> ### ** Examples
> 
> data(akima474)
> # interpolate at a grid [0,8]x[0,10]
> akima.bil <- bilinear.grid(akima474$x,akima474$y,akima474$z)
> zmin <- min(akima.bil$z, na.rm=TRUE)
> zmax <- max(akima.bil$z, na.rm=TRUE)
> breaks <- pretty(c(zmin,zmax),10)
> colors <- heat.colors(length(breaks)-1)
> image(akima.bil, breaks=breaks, col=colors)
> contour(akima.bil, levels=breaks, add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("cells")
> ### * cells
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cells
> ### Title: extract info about voronoi cells
> ### Aliases: cells
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(tritest)
> tritest.vm <- voronoi.mosaic(tritest$x,tritest$y)
> tritest.cells <- cells(tritest.vm)
> # higlight cell 12:
> plot(tritest.vm)
> polygon(t(tritest.cells[[12]]$nodes),col="green")
> # put cell area into cell center:
> text(tritest.cells[[12]]$center[1],
+      tritest.cells[[12]]$center[2],
+      tritest.cells[[12]]$area)
> 
> 
> 
> cleanEx()
> nameEx("circles")
> ### * circles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: circles
> ### Title: plot circles
> ### Aliases: circles
> ### Keywords: aplot
> 
> ### ** Examples
> 
> x<-rnorm(10)
> y<-rnorm(10)
> r<-runif(10,0,0.5)
> plot(x,y, xlim=c(-3,3), ylim=c(-3,3), pch="+")
> circles(x,y,r)
> 
> 
> 
> cleanEx()
> nameEx("circum")
> ### * circum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: circum
> ### Title: Determine the circumcircle (and some other characteristics) of a
> ###   triangle
> ### Aliases: circum
> ### Keywords: spatial
> 
> ### ** Examples
> 
> circum(c(0,1,0),c(0,0,1))
$x
[1] 0.5

$y
[1] 0.5

$aspect.ratio
[1] 0.4142136

$x
[1] 0.5

$y
[1] 0.5

$radius
[1] 0.7071067

$signed.area
[1] -0.5000001

> 
> tr <- list()
> tr$t1 <-list(x=c(0,1,0),y=c(0,0,1))
> tr$t2 <-list(x=c(0.5,0.9,0.7),y=c(0.2,0.9,1))
> tr$t3 <-list(x=c(0.05,0,0.3),y=c(0.2,0.7,0.1))
> plot(0,0,type="n",xlim=c(-0.5,1.5),ylim=c(-0.5,1.5))
> for(i in 1:3){
+     x <- tr[[i]]$x
+     y <- tr[[i]]$y
+     points(x,y,pch=c("1","2","3"),xlim=c(-0.5,1.5),ylim=c(-0.5,1.5))
+     cc =circum(x,y)
+     lines(c(x,x[1]),c(y,y[1]))
+     points(cc$x,cc$y)
+     if(cc$signed.area<0)
+       circles(cc$x,cc$y,cc$radius,col="blue",lty="dotted")
+     else
+       circles(cc$x,cc$y,cc$radius,col="red",lty="dotted")
+ }
> 
> 
> 
> cleanEx()
> nameEx("circumcircle")
> ### * circumcircle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: circumcircle
> ### Title: Determine the circumcircle of a set of points
> ### Aliases: circumcircle
> ### Keywords: spatial
> 
> ### ** Examples
> 
>  data(circtest)
>  # smallest circle:
>  circumcircle(circtest,num.touch=2,plot=TRUE)
$x
[1] -0.3085279

$y
[1] -0.3116673

$radius
[1] 3.043886

> 
>  # smallest circle with maximum touching points (3):
>  circumcircle(circtest,num.touch=3,plot=TRUE)
$x
[1] 0.3667301

$y
[1] -1.845474

$radius
[1] 3.474734

> 
>  # some stress test for this function,
>  data(circtest2)
>  # circtest2 was generated by:
>  # 100 random points almost one a circle:
>  # alpha <- runif(100,0,2*pi)
>  # x <- cos(alpha)
>  # y <- sin(alpha)
>  # circtest2<-list(x=cos(alpha)+runif(100,0,0.1),
>  #                 y=sin(alpha)+runif(100,0,0.1))
>  #  
>  circumcircle(circtest2,plot=TRUE)
$x
[1] 0.05383896

$y
[1] 0.03794901

$radius
[1] 1.049089

> 
> 
> 
> 
> cleanEx()
> nameEx("convex.hull")
> ### * convex.hull
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: convex.hull
> ### Title: Return the convex hull of a triangulation object
> ### Aliases: convex.hull ConvexHull
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## random points:
> rand.tr<-tri.mesh(runif(10),runif(10))
> plot(rand.tr)
> rand.ch<-convex.hull(rand.tr, plot.it=TRUE, add=TRUE, col="red")
> ## use a part of the quakes data set:
> data(quakes)
> quakes.part<-quakes[(quakes[,1]<=-17 & quakes[,1]>=-19.0 &
+                      quakes[,2]<=182.0 & quakes[,2]>=180.0),]
> quakes.tri<-tri.mesh(quakes.part$lon, quakes.part$lat, duplicate="remove")
> plot(quakes.tri)
> convex.hull(quakes.tri, plot.it=TRUE, add=TRUE, col="red")
> 
> 
> 
> cleanEx()
> nameEx("franke.data")
> ### * franke.data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: franke.data
> ### Title: Test datasets from Franke for interpolation of scattered data
> ### Aliases: franke.data franke.fn franke
> ### Keywords: datagen
> 
> ### ** Examples
> 
> ## generate Frankes data set for function 2 and dataset 3:
> data(franke)
> F23 <- franke.data(2,3,franke)
> str(F23)
List of 3
 $ x: num [1:25] 0.138 0.912 0.713 0.225 -0.05 ...
 $ y: num [1:25] 0.975 0.988 0.762 0.838 0.412 ...
 $ z: num [1:25] 0.222 0.176 0.158 0.222 0.222 ...
> 
> 
> 
> cleanEx()
> nameEx("identify.tri")
> ### * identify.tri
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: identify.triSht
> ### Title: Identify points in a triangulation plot
> ### Aliases: identify.triSht
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(franke)
> ##D tr <- tri.mesh(franke$ds3$x, franke$ds3$y)
> ##D plot(tr)
> ##D identify(tr)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("interp")
> ### * interp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interp
> ### Title: Interpolation function
> ### Aliases: interp
> ### Keywords: dplot math
> 
> ### ** Examples
> 
> ### Use all datasets from Franke, 1979:
> data(franke)
> ## x-y irregular grid points:
> oldseed <- set.seed(42)
> ni <- 64
> xi <- runif(ni,0,1)
> yi <- runif(ni,0,1)
> xyi <- cbind(xi,yi)
> ## linear interpolation
> fi <- franke.fn(xi,yi,1)
> IL <- interp(xi,yi,fi,nx=80,ny=80,method="linear")
> ## prepare breaks and colors that match for image and contour:
> breaks <- pretty(seq(min(IL$z,na.rm=TRUE),max(IL$z,na.rm=TRUE),length=11))
> db <- breaks[2]-breaks[1]
> nb <- length(breaks)
> breaks <- c(breaks[1]-db,breaks,breaks[nb]+db)
> colors <- terrain.colors(length(breaks)-1)
> image(IL,breaks=breaks,col=colors,main="Franke function 1",
+       sub=paste("linear interpolation, ", ni,"points"))
> contour(IL,add=TRUE,levels=breaks)
> points(xi,yi)
> ## spline interpolation
> fi <- franke.fn(xi,yi,1)
> IS <- interp(xi,yi,fi,method="akima",
+              kernel="gaussian",solver="QR")
> ## prepare breaks and colors that match for image and contour:
> breaks <- pretty(seq(min(IS$z,na.rm=TRUE),max(IS$z,na.rm=TRUE),length=11))
> db <- breaks[2]-breaks[1]
> nb <- length(breaks)
> breaks <- c(breaks[1]-db,breaks,breaks[nb]+db)
> colors <- terrain.colors(length(breaks)-1)
> image(IS,breaks=breaks,col=colors,main="Franke function 1",
+       sub=paste("spline interpolation, ", ni,"points"))
> contour(IS,add=TRUE,levels=breaks)
>         points(xi,yi)
> ## regular grid:
> nx <- 8; ny <- 8
> xg<-seq(0,1,length=nx)
> yg<-seq(0,1,length=ny)
> xx <- t(matrix(rep(xg,ny),nx,ny))
> yy <- matrix(rep(yg,nx),ny,nx)
> xyg<-expand.grid(xg,yg)
> ## linear interpolation
> fg <- outer(xg,yg,function(x,y)franke.fn(x,y,1))
> IL <- interp(xg,yg,fg,input="grid",method="linear")
> ## prepare breaks and colors that match for image and contour:
> breaks <- pretty(seq(min(IL$z,na.rm=TRUE),max(IL$z,na.rm=TRUE),length=11))
> db <- breaks[2]-breaks[1]
> nb <- length(breaks)
> breaks <- c(breaks[1]-db,breaks,breaks[nb]+db)
> colors <- terrain.colors(length(breaks)-1)
> image(IL,breaks=breaks,col=colors,main="Franke function 1",
+       sub=paste("linear interpolation, ", nx,"x",ny,"points"))
> contour(IL,add=TRUE,levels=breaks)
> points(xx,yy)
> ## spline interpolation
> fg <- outer(xg,yg,function(x,y)franke.fn(x,y,1))
> IS <- interp(xg,yg,fg,input="grid",method="akima",
+              kernel="gaussian",solver="QR")
> ## prepare breaks and colors that match for image and contour:
> breaks <- pretty(seq(min(IS$z,na.rm=TRUE),max(IS$z,na.rm=TRUE),length=11))
> db <- breaks[2]-breaks[1]
> nb <- length(breaks)
> breaks <- c(breaks[1]-db,breaks,breaks[nb]+db)
> colors <- terrain.colors(length(breaks)-1)
> image(IS,breaks=breaks,col=colors,main="Franke function 1",
+       sub=paste("spline interpolation, ", nx,"x",ny,"points"))
> contour(IS,add=TRUE,levels=breaks)
> points(xx,yy)
> 
> ## apply interp to sp data:
> require(sp)
Loading required package: sp
> ## convert Akima data set to a sp object 
> data(akima)
> asp <- SpatialPointsDataFrame(list(x=akima$x,y=akima$y),
+                               data = data.frame(z=akima$z))
> spplot(asp,"z")
> ## linear interpolation
> spli <- interp(asp, z="z", method="linear")
> ## the result is again a SpatialPointsDataFrame: 
> spplot(spli,"z")
> ## now with spline interpolation, slightly higher resolution
> spsi <- interp(asp, z="z", method="akima", nx=120, ny=120)
> spplot(spsi,"z")
> 
> ## now sp grids: reuse stuff from above
> spgr <- SpatialPixelsDataFrame(list(x=c(xx),y=c(yy)),
+                                data=data.frame(z=c(fg)))
> spplot(spgr)
> ## linear interpolation
> spli <- interp(spgr, z="z", method="linear", input="grid")
> ## the result is again a SpatialPointsDataFrame: 
> spplot(spli,"z")
> ## now with spline interpolation, slightly higher resolution
> spsi <- interp(spgr, z="z", method="akima", nx=240, ny=240)
> spplot(spsi,"z")
> 
> set.seed(oldseed)
> 
> 
> 
> cleanEx()

detaching ‘package:sp’

> nameEx("interp2xyz")
> ### * interp2xyz
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interp2xyz
> ### Title: From interp() Result, Produce 3-column Matrix
> ### Aliases: interp2xyz
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(akima)
> ak.spl <- with(akima, interp(x, y, z, method = "akima"))
> str(ak.spl)# list (x[i], y[j], z = <matrix>[i,j])
List of 3
 $ x: num [1:40] 0 0.641 1.282 1.923 2.564 ...
 $ y: num [1:40] 0 0.513 1.026 1.538 2.051 ...
 $ z: num [1:40, 1:40] 58.2 55.3 52.4 49.5 46.7 ...
> 
> ## Now transform to simple  (x,y,z)  matrix / data.frame :
> str(am <- interp2xyz(ak.spl))
 num [1:1600, 1:3] 0 0.641 1.282 1.923 2.564 ...
 - attr(*, "dimnames")=List of 2
  ..$ : NULL
  ..$ : chr [1:3] "x" "y" "z"
> str(ad <- interp2xyz(ak.spl, data.frame=TRUE))
'data.frame':	1600 obs. of  3 variables:
 $ x: num  0 0.641 1.282 1.923 2.564 ...
 $ y: num  0 0 0 0 0 0 0 0 0 0 ...
 $ z: num  58.2 55.3 52.4 49.5 46.7 ...
> ## and they are the same:
> stopifnot( am == ad | (is.na(am) & is.na(ad)) )
> 
> 
> 
> cleanEx()
> nameEx("interpp")
> ### * interpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interpp
> ### Title: Pointwise interpolate irregular gridded data
> ### Aliases: interpp
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ### Use all datasets from Franke, 1979:
> ### calculate z at shifted original locations.
> data(franke)
> for(i in 1:5)
+     for(j in 1:3){
+         FR <- franke.data(i,j,franke)
+         IL <- with(FR, interpp(x,y,z,x+0.1,y+0.1,linear=TRUE))
+         str(IL)
+     }
List of 3
 $ x: num [1:100] 0.123 0.122 0.102 0.14 0.132 ...
 $ y: num [1:100] 0.069 0.358 0.594 0.799 1.011 ...
 $ z: num [1:100] 0.96 0.837 0.41 0.299 NA ...
List of 3
 $ x: num [1:33] 0.1 0.1 0.1 0.6 0.2 0.25 0.4 0.2 0.15 1.1 ...
 $ y: num [1:33] 0.1 1.1 0.6 1.1 0.25 0.4 0.45 0.85 0.55 0.1 ...
 $ z: num [1:33] 0.986 NA 0.468 NA 1.125 ...
List of 3
 $ x: num [1:25] 0.238 1.012 0.812 0.325 0.05 ...
 $ y: num [1:25] 1.075 1.088 0.862 0.938 0.512 ...
 $ z: num [1:25] NA NA 0.0872 0.2133 0.4689 ...
List of 3
 $ x: num [1:100] 0.123 0.122 0.102 0.14 0.132 ...
 $ y: num [1:100] 0.069 0.358 0.594 0.799 1.011 ...
 $ z: num [1:100] 0.0647 0.2163 0.2222 0.2222 NA ...
List of 3
 $ x: num [1:33] 0.1 0.1 0.1 0.6 0.2 0.25 0.4 0.2 0.15 1.1 ...
 $ y: num [1:33] 0.1 1.1 0.6 1.1 0.25 0.4 0.45 0.85 0.55 0.1 ...
 $ z: num [1:33] 0.115 NA 0.216 NA 0.136 ...
List of 3
 $ x: num [1:25] 0.238 1.012 0.812 0.325 0.05 ...
 $ y: num [1:25] 1.075 1.088 0.862 0.938 0.512 ...
 $ z: num [1:25] NA NA 0.163 0.222 0.222 ...
List of 3
 $ x: num [1:100] 0.123 0.122 0.102 0.14 0.132 ...
 $ y: num [1:100] 0.069 0.358 0.594 0.799 1.011 ...
 $ z: num [1:100] 0.2593 0.1059 0.0324 0.1079 NA ...
List of 3
 $ x: num [1:33] 0.1 0.1 0.1 0.6 0.2 0.25 0.4 0.2 0.15 1.1 ...
 $ y: num [1:33] 0.1 1.1 0.6 1.1 0.25 0.4 0.45 0.85 0.55 0.1 ...
 $ z: num [1:33] 0.2311 NA 0.0701 NA 0.2118 ...
List of 3
 $ x: num [1:25] 0.238 1.012 0.812 0.325 0.05 ...
 $ y: num [1:25] 1.075 1.088 0.862 0.938 0.512 ...
 $ z: num [1:25] NA NA 0.0612 0.2286 0.0415 ...
List of 3
 $ x: num [1:100] 0.123 0.122 0.102 0.14 0.132 ...
 $ y: num [1:100] 0.069 0.358 0.594 0.799 1.011 ...
 $ z: num [1:100] 0.0632 0.1457 0.1429 0.1113 NA ...
List of 3
 $ x: num [1:33] 0.1 0.1 0.1 0.6 0.2 0.25 0.4 0.2 0.15 1.1 ...
 $ y: num [1:33] 0.1 1.1 0.6 1.1 0.25 0.4 0.45 0.85 0.55 0.1 ...
 $ z: num [1:33] 0.07 NA 0.124 NA 0.15 ...
List of 3
 $ x: num [1:25] 0.238 1.012 0.812 0.325 0.05 ...
 $ y: num [1:25] 1.075 1.088 0.862 0.938 0.512 ...
 $ z: num [1:25] NA NA 0.117 0.1 0.121 ...
List of 3
 $ x: num [1:100] 0.123 0.122 0.102 0.14 0.132 ...
 $ y: num [1:100] 0.069 0.358 0.594 0.799 1.011 ...
 $ z: num [1:100] 0.00044 0.01871 0.01459 0.00541 NA ...
List of 3
 $ x: num [1:33] 0.1 0.1 0.1 0.6 0.2 0.25 0.4 0.2 0.15 1.1 ...
 $ y: num [1:33] 0.1 1.1 0.6 1.1 0.25 0.4 0.45 0.85 0.55 0.1 ...
 $ z: num [1:33] 0.00108 NA 0.01274 NA 0.0138 ...
List of 3
 $ x: num [1:25] 0.238 1.012 0.812 0.325 0.05 ...
 $ y: num [1:25] 1.075 1.088 0.862 0.938 0.512 ...
 $ z: num [1:25] NA NA 0.01716 0.00391 0.01746 ...
> 
> 
> 
> cleanEx()
> nameEx("locpoly")
> ### * locpoly
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: locpoly
> ### Title: Local polynomial fit.
> ### Aliases: locpoly
> ### Keywords: models regression
> 
> ### ** Examples
> 
> 
> ## choose a kernel
> knl <- "gaussian"
> 
> ## choose global and local bandwidth 
> bwg <- 0.25 # *100% means: percentage of x- y-range used
> bwl <- 0.1  # *100% means: percentage of data set (nearest neighbours) used
> 
> ## a bivariate polynomial of degree 5:
> f <- function(x,y) 0.1+ 0.2*x-0.3*y+0.1*x*y+0.3*x^2*y-0.5*y^2*x+y^3*x^2+0.1*y^5
> 
> ## degree of model
> dg=3 
> 
> ## part 1:
> ## regular gridded data:
> ng<- 11 # x/y size of a square data grid
> 
> ## build and fill the grid with the theoretical values:
> 
> xg<-seq(0,1,length=ng)
> yg<-seq(0,1,length=ng)
> 
> # xg and yg as matrix matching fg
> nx <- length(xg)
> ny <- length(yg)
> xx <- t(matrix(rep(xg,ny),nx,ny))
> yy <- matrix(rep(yg,nx),ny,nx)
> 
> fg   <- outer(xg,yg,f)
> 
> ## local polynomial estimate
> ## global bw:
> ttg <- system.time(pdg <- locpoly(xg,yg,fg,
+   input="grid", pd="all", h=c(bwg,bwg), solver="QR", degree=dg, kernel=knl))
> ## time used:
> ttg
   user  system elapsed 
  0.068   0.000   0.067 
> 
> ## local bw:
> ttl <- system.time(pdl <- locpoly(xg,yg,fg,
+   input="grid", pd="all", h=bwl, solver="QR", degree=dg, kernel=knl))
> ## time used:
> ttl
   user  system elapsed 
  0.160   0.000   0.161 
> 
> image(pdl$x,pdl$y,pdl$z,main="f and its estimated first partial derivatives",
+       sub="colors: f, dotted: df/dx, dashed: df/dy")
> contour(pdl$x,pdl$y,pdl$zx,add=TRUE,lty="dotted")
> contour(pdl$x,pdl$y,pdl$zy,add=TRUE,lty="dashed")
> points(xx,yy,pch=".")
> 
> 
> ## part 2:
> ## irregular data,
> ## results will not be as good as with the regular 21*21=231 points.
> 
> nd<- 121 # size of data set
> 
> ## random irregular data
> oldseed <- set.seed(42)
> x<-runif(ng)
> y<-runif(ng)
> set.seed(oldseed)
> 
> z <- f(x,y)
> 
> ## global bw:
> ttg <- system.time(pdg <- interp::locpoly(x,y,z, xg,yg, pd="all",
+   h=c(bwg,bwg), solver="QR", degree=dg,kernel=knl))
> 
> ttg
   user  system elapsed 
  0.002   0.000   0.002 
> 
> ## local bw:
> ttl <- system.time(pdl <- interp::locpoly(x,y,z, xg,yg, pd="all",
+   h=bwl, solver="QR", degree=dg,kernel=knl))
> 
> ttl
   user  system elapsed 
  0.003   0.000   0.003 
> 
> image(pdl$x,pdl$y,pdl$z,main="f and its estimated first partial derivatives",
+       sub="colors: f, dotted: df/dx, dashed: df/dy")
> contour(pdl$x,pdl$y,pdl$zx,add=TRUE,lty="dotted")
> contour(pdl$x,pdl$y,pdl$zy,add=TRUE,lty="dashed")
> points(x,y,pch=".")
> 
> 
> 
> 
> cleanEx()
> nameEx("nearest.neighbours")
> ### * nearest.neighbours
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nearest.neighbours
> ### Title: Nearest neighbour structure for a data set
> ### Aliases: nearest.neighbours
> ### Keywords: utilities
> 
> ### ** Examples
> 
> data(franke)
> ## use only a small subset
> fd <- franke$ds1[1:5,]
> nearest.neighbours(fd$x,fd$y)
$index
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    2    3    1    4    5
[3,]    3    4    2    5    1
[4,]    4    3    5    2    1
[5,]    5    4    3    2    1

$dist
     [,1]      [,2]      [,3]      [,4]      [,5]
[1,]    0 0.2887147 0.5257926 0.7305571 0.9418279
[2,]    0 0.2374946 0.2887147 0.4420102 0.6531478
[3,]    0 0.2084088 0.2374946 0.4174614 0.5257926
[4,]    0 0.2084088 0.2115727 0.4420102 0.7305571
[5,]    0 0.2115727 0.4174614 0.6531478 0.9418279

> 
> 
> 
> cleanEx()
> nameEx("neighbours")
> ### * neighbours
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: neighbours
> ### Title: List of neighbours from a triangulation or voronoi object
> ### Aliases: neighbours
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(tritest)
> tritest.tr<-tri.mesh(tritest$x,tritest$y)
> tritest.nb<-neighbours(tritest.tr)
> 
> 
> 
> cleanEx()
> nameEx("on")
> ### * on
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: on
> ### Title: Determines if a point is on or left of the vector described by
> ###   two other points.
> ### Aliases: on left
> ### Keywords: utilities
> 
> ### ** Examples
> 
> y <- x <- c(0,1)
> ## should be TRUE
> on(x[1],y[1],x[2],y[2],0.5,0.5)
[1] TRUE
> ## note the default setting of eps leading to
> on(x[1],y[1],x[2],y[2],0.5,0.50000000000000001)
[1] TRUE
> ## also be TRUE
> 
> ## should be TRUE
> left(x[1],y[1],x[2],y[2],0.5,0.6)
[1] TRUE
> ## note the default setting of eps leading to
> left(x[1],y[1],x[2],y[2],0.5,0.50000000000000001)
[1] FALSE
> ## already resulting to FALSE
> 
> 
> 
> 
> cleanEx()
> nameEx("on.convex.hull")
> ### * on.convex.hull
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: on.convex.hull
> ### Title: Determines if points are on or in the convex hull of a
> ###   triangulation object
> ### Aliases: on.convex.hull in.convex.hull
> ### Keywords: spatial
> 
> ### ** Examples
> 
> # use a part of the quakes data set:
> data(quakes)
> quakes.part<-quakes[(quakes[,1]<=-10.78 & quakes[,1]>=-19.4 &
+                      quakes[,2]<=182.29 & quakes[,2]>=165.77),]
> q.tri<-tri.mesh(quakes.part$lon, quakes.part$lat, duplicate="remove")
> on.convex.hull(q.tri,quakes.part$lon[1:20],quakes.part$lat[1:20])
 [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
[13] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
> # Check with part of data set:
> # Note that points on the hull (see above) get marked FALSE below:
> in.convex.hull(q.tri,quakes.part$lon[1:20],quakes.part$lat[1:20])
 [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE
[13]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE
> # If points both on the hull and in the interior of the hull are meant 
> # disable strict mode:
> in.convex.hull(q.tri,quakes.part$lon[1:20],quakes.part$lat[1:20],strict=FALSE)
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[16] TRUE TRUE TRUE TRUE TRUE
> # something completely outside:
> in.convex.hull(q.tri,c(170,180),c(-20,-10))
[1] FALSE FALSE
> 
> 
> 
> cleanEx()
> nameEx("outer.convhull")
> ### * outer.convhull
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: outer.convhull
> ### Title: Version of outer which operates only in a convex hull
> ### Aliases: outer.convhull
> ### Keywords: spatial
> 
> ### ** Examples
> 
> x<-runif(20)
> y<-runif(20)
> z<-runif(20)
> z.lm<-lm(z~x+y)
> f.pred<-function(x,y)
+   {predict(z.lm,data.frame(x=as.vector(x),y=as.vector(y)))}
> xg<-seq(0,1,0.05)
> yg<-seq(0,1,0.05)
> image(xg,yg,outer.convhull(xg,yg,x,y,f.pred))
> points(x,y)
> 
> 
> 
> cleanEx()
> nameEx("plot.triSht")
> ### * plot.triSht
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.triSht
> ### Title: Plot a triangulation object
> ### Aliases: plot.triSht
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## random points
> plot(tri.mesh(rpois(100,lambda=20),rpois(100,lambda=20),duplicate="remove"))
> ## use a part of the quakes data set:
> data(quakes)
> quakes.part<-quakes[(quakes[,1]<=-10.78 & quakes[,1]>=-19.4 &
+                      quakes[,2]<=182.29 & quakes[,2]>=165.77),]
> quakes.tri<-tri.mesh(quakes.part$lon, quakes.part$lat, duplicate="remove")
> plot(quakes.tri)
> ## use the whole quakes data set
> ## (will not work with standard memory settings, hence commented out)
> ## plot(tri.mesh(quakes$lon, quakes$lat, duplicate="remove"), do.points=F)
> 
> 
> 
> cleanEx()
> nameEx("plot.voronoi")
> ### * plot.voronoi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.voronoi
> ### Title: Plot a voronoi object
> ### Aliases: plot.voronoi
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(franke)
> tr <- tri.mesh(franke$ds3)
> vr <- voronoi.mosaic(tr)
> plot(tr)
> plot(vr,add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("plot.voronoi.polygons")
> ### * plot.voronoi.polygons
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.voronoi.polygons
> ### Title: plots an voronoi.polygons object
> ### Aliases: plot.voronoi.polygons
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(franke)
> fd3 <- franke$ds3
> fd3.vm <- voronoi.mosaic(fd3$x,fd3$y)
> fd3.vp <- voronoi.polygons(fd3.vm)
> plot(fd3.vp)
> plot(fd3.vp,which=c(3,4,6,10))
> 
> 
> 
> cleanEx()
> nameEx("tri.find")
> ### * tri.find
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tri.find
> ### Title: Locate a point in a triangulation
> ### Aliases: tri.find
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(franke)
> tr<-tri.mesh(franke$ds3$x,franke$ds3$y)
> plot(tr)
> pnt<-list(x=0.3,y=0.4)
> triangle.with.pnt<-tri.find(tr,pnt$x,pnt$y)
> attach(triangle.with.pnt)
The following object is masked _by_ .GlobalEnv:

    tr

> lines(franke$ds3$x[c(i1,i2,i3,i1)],franke$ds3$y[c(i1,i2,i3,i1)],col="red")
> points(pnt$x,pnt$y)
> 
> 
> 
> cleanEx()

detaching ‘triangle.with.pnt’

> nameEx("tri.mesh")
> ### * tri.mesh
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tri.mesh
> ### Title: Delaunay triangulation
> ### Aliases: tri.mesh
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## use Frankes datasets:
> data(franke)
> tr1 <- tri.mesh(franke$ds3$x, franke$ds3$y)
> tr1
Delaunay triangulation, node and triangle indices:
triangle: nodes (a,b,c), neighbour triangles [i,j,k] 
1: (1,11,4), [2,3,0]
2: (12,4,11), [1,7,5]
3: (8,1,4), [1,9,0]
4: (10,4,6), [5,15,9]
5: (4,12,6), [8,4,2]
6: (12,5,16), [13,8,7]
7: (5,12,11), [2,0,6]
8: (12,16,6), [11,5,6]
9: (10,8,4), [3,4,14]
10: (13,3,6), [15,18,24]
11: (21,6,16), [8,17,18]
12: (16,22,17), [19,17,13]
13: (22,16,5), [6,20,12]
14: (3,8,10), [9,15,23]
15: (6,3,10), [14,4,10]
16: (15,21,17), [17,22,21]
17: (16,17,21), [16,11,12]
18: (13,6,21), [11,21,10]
19: (19,17,22), [12,31,28]
20: (25,22,5), [13,30,31]
21: (15,13,21), [18,16,26]
22: (17,23,15), [27,16,28]
23: (2,8,3), [14,34,0]
24: (9,3,13), [10,25,34]
25: (9,13,14), [26,35,24]
26: (13,15,14), [32,25,21]
27: (15,23,18), [39,32,22]
28: (19,23,17), [22,19,33]
29: (25,7,19), [40,31,30]
30: (7,25,5), [20,0,29]
31: (19,22,25), [20,29,19]
32: (15,18,14), [36,26,27]
33: (24,23,19), [28,40,39]
34: (9,2,3), [23,24,0]
35: (14,20,9), [38,25,36]
36: (14,18,20), [37,35,32]
37: (18,24,20), [38,36,39]
38: (24,9,20), [35,37,0]
39: (24,18,23), [27,33,37]
40: (24,19,7), [29,0,33]
boundary nodes:  1 11 5 7 24 9 2 8 
> tr2 <- tri.mesh(franke$ds2)
> summary(tr2)
triangulation:
Call: tri.mesh(x = franke$ds2) 
number of nodes: 33 
number of arcs: 88 
number of boundary nodes: 8 
number of triangles: 56 
> 
> 
> 
> cleanEx()
> nameEx("triangles")
> ### * triangles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: triangles
> ### Title: Extract a list of triangles from a triangulation object
> ### Aliases: triangles
> ### Keywords: spatial
> 
> ### ** Examples
> 
> # use the smallest Franke data set
> data(franke)
> fr3.tr<-tri.mesh(franke$ds3$x, franke$ds3$y)
> triangles(fr3.tr)
      node1 node2 node3 tr1 tr2 tr3 arc1 arc2 arc3
 [1,]     1    11     4   2   3   0    1    2    3
 [2,]    12     4    11   1   7   5    1    4    5
 [3,]     8     1     4   1   9   0    2    6    7
 [4,]    10     4     6   5  15   9    8    9   10
 [5,]     4    12     6   8   4   2   11    8    5
 [6,]    12     5    16  13   8   7   12   13   14
 [7,]     5    12    11   2   0   6    4   15   14
 [8,]    12    16     6  11   5   6   16   11   13
 [9,]    10     8     4   3   4  14    6   10   17
[10,]    13     3     6  15  18  24   18   19   20
[11,]    21     6    16   8  17  18   16   21   22
[12,]    16    22    17  19  17  13   23   24   25
[13,]    22    16     5   6  20  12   12   26   25
[14,]     3     8    10   9  15  23   17   27   28
[15,]     6     3    10  14   4  10   27    9   18
[16,]    15    21    17  17  22  21   29   30   31
[17,]    16    17    21  16  11  12   29   21   24
[18,]    13     6    21  11  21  10   22   32   19
[19,]    19    17    22  12  31  28   23   33   34
[20,]    25    22     5  13  30  31   26   35   36
[21,]    15    13    21  18  16  26   32   31   37
[22,]    17    23    15  27  16  28   38   30   39
[23,]     2     8     3  14  34   0   28   40   41
[24,]     9     3    13  10  25  34   20   42   43
[25,]     9    13    14  26  35  24   44   45   42
[26,]    13    15    14  32  25  21   46   44   37
[27,]    15    23    18  39  32  22   47   48   38
[28,]    19    23    17  22  19  33   39   34   49
[29,]    25     7    19  40  31  30   50   51   52
[30,]     7    25     5  20   0  29   35   53   52
[31,]    19    22    25  20  29  19   36   51   33
[32,]    15    18    14  36  26  27   54   46   48
[33,]    24    23    19  28  40  39   49   55   56
[34,]     9     2     3  23  24   0   40   43   57
[35,]    14    20     9  38  25  36   58   45   59
[36,]    14    18    20  37  35  32   60   59   54
[37,]    18    24    20  38  36  39   61   60   62
[38,]    24     9    20  35  37   0   58   61   63
[39,]    24    18    23  27  33  37   47   56   62
[40,]    24    19     7  29   0  33   50   64   55
> 
> 
> 
> cleanEx()
> nameEx("voronoi.area")
> ### * voronoi.area
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: voronoi.area
> ### Title: Calculate area of Voronoi polygons
> ### Aliases: voronoi.area
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(franke)
> fd3 <- franke$ds3
> fd3.vm <- voronoi.mosaic(fd3$x,fd3$y)
> fd3.vm.areas <- voronoi.area(fd3.vm)
> plot(fd3.vm)
> text(fd3$x, fd3$y, round(fd3.vm.areas,5))
> 
> 
> 
> cleanEx()
> nameEx("voronoi.mosaic")
> ### * voronoi.mosaic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: voronoi.mosaic
> ### Title: Voronoi mosaic
> ### Aliases: voronoi.mosaic
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(franke)
> fd <- franke$ds3
> vr <- voronoi.mosaic(fd$x, fd$y)
> summary(vr)
voronoi mosaic
Call: voronoi.mosaic(x = fd$x, y = fd$y) 
40 nodes
8 dummy nodes
> 
> 
> 
> cleanEx()
> nameEx("voronoi.polygons")
> ### * voronoi.polygons
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: voronoi.polygons
> ### Title: extract polygons from a voronoi mosaic
> ### Aliases: voronoi.polygons
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(franke)
> fd3 <- franke$ds3
> fd3.vm <- voronoi.mosaic(fd3$x,fd3$y)
> fd3.vp <- voronoi.polygons(fd3.vm)
> fd3.vp
[[1]]
NULL

[[2]]
NULL

[[3]]
             x         y
[1,] 0.6682398 0.9830357
[2,] 0.6035850 0.6813135
[3,] 0.6167763 0.6562500
[4,] 0.9000000 0.6562500
[5,] 0.9531250 0.7500000
[6,] 0.6791952 0.9934931

[[4]]
             x         y
[1,] 0.3128205 0.6910256
[2,] 0.3752941 0.7691177
[3,] 0.3886013 0.8800110
[4,] 0.2987903 0.9810484
[5,] 0.0781250 0.8406250
[6,] 0.1187500 0.7187500

[[5]]
NULL

[[6]]
             x         y
[1,] 0.6035850 0.6813135
[2,] 0.3752941 0.7691177
[3,] 0.3128205 0.6910256
[4,] 0.3404944 0.5637259
[5,] 0.3725291 0.5335756
[6,] 0.5826389 0.5635912
[7,] 0.6167763 0.6562500

[[7]]
NULL

[[8]]
NULL

[[9]]
NULL

[[10]]
             x         y
[1,] 0.3752941 0.7691177
[2,] 0.6035850 0.6813135
[3,] 0.6682398 0.9830357
[4,] 0.3886013 0.8800110

[[11]]
NULL

[[12]]
             x         y
[1,] 0.1187500 0.7187500
[2,] 0.0102500 0.5792500
[3,] 0.1120494 0.4304663
[4,] 0.3404944 0.5637259
[5,] 0.3128205 0.6910256

[[13]]
             x         y
[1,] 0.6167763 0.6562500
[2,] 0.5826389 0.5635912
[3,] 0.6356013 0.4349684
[4,] 0.7291284 0.4300459
[5,] 0.9000000 0.6388889
[6,] 0.9000000 0.6562500

[[14]]
             x         y
[1,] 1.0045455 0.4181818
[2,] 0.9000000 0.6388889
[3,] 0.7291284 0.4300459
[4,] 0.8264881 0.3132143
[5,] 0.8738032 0.3061170

[[15]]
             x         y
[1,] 0.5702206 0.3477941
[2,] 0.5792553 0.2574468
[3,] 0.6904167 0.1907500
[4,] 0.8264881 0.3132143
[5,] 0.7291284 0.4300459
[6,] 0.6356013 0.4349684

[[16]]
             x         y
[1,] 0.3165782 0.2978041
[2,] 0.3951563 0.3978125
[3,] 0.3725291 0.5335756
[4,] 0.3404944 0.5637259
[5,] 0.1120494 0.4304663
[6,] 0.1129343 0.4074585

[[17]]
             x         y
[1,] 0.5792553 0.2574468
[2,] 0.5702206 0.3477941
[3,] 0.3951563 0.3978125
[4,] 0.3165782 0.2978041
[5,] 0.3330357 0.1250000
[6,] 0.4227273 0.1250000

[[18]]
             x           y
[1,] 0.9600145  0.09058864
[2,] 0.8738032  0.30611703
[3,] 0.8264881  0.31321427
[4,] 0.6904167  0.19075000
[5,] 0.7689203 -0.09186314

[[19]]
             x           y
[1,] 0.3330357  0.12500000
[2,] 0.3001786  0.09625000
[3,] 0.2493325 -0.02239078
[4,] 0.4706865 -7.10571671
[5,] 0.7460724 -0.14859968
[6,] 0.4227273  0.12500000

[[20]]
             x          y
[1,] 1.0045455 0.41818181
[2,] 1.7035956 0.20542741
[3,] 0.9600145 0.09058864
[4,] 0.8738032 0.30611703

[[21]]
             x         y
[1,] 0.3725291 0.5335756
[2,] 0.3951563 0.3978125
[3,] 0.5702206 0.3477941
[4,] 0.6356013 0.4349684
[5,] 0.5826389 0.5635912

[[22]]
              x         y
[1,] 0.11293429 0.4074585
[2,] 0.01971154 0.2598558
[3,] 0.30017856 0.0962500
[4,] 0.33303571 0.1250000
[5,] 0.31657818 0.2978041

[[23]]
             x           y
[1,] 0.5792553  0.25744680
[2,] 0.6904167  0.19075000
[3,] 0.7689203 -0.09186314
[4,] 0.7460724 -0.14859968
[5,] 0.4227273  0.12500000

[[24]]
NULL

[[25]]
               x           y
[1,]  0.01971154  0.25985578
[2,] -0.24226190  0.12886904
[3,]  0.24933252 -0.02239078
[4,]  0.30017856  0.09625000

attr(,"class")
[1] "voronoi.polygons"
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  3.308 0.09 3.4 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
