
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "pbkrtest"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('pbkrtest')
Loading required package: lme4
Loading required package: Matrix
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("compare_column_space")
> ### * compare_column_space
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compare_column_space
> ### Title: Compare column spaces
> ### Aliases: compare_column_space
> 
> ### ** Examples
> 
> 
> A1 <- matrix(c(1,1,1,1,2,3), nrow=3)
> A2 <- A1[, 1, drop=FALSE]
> 
> compare_column_space(A1, A2)
[1] 1
> compare_column_space(A2, A1)
[1] 0
> compare_column_space(A1, A1)
[1] -1
> 
> 
> 
> 
> cleanEx()
> nameEx("data-beets")
> ### * data-beets
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data-beets
> ### Title: Sugar beets data
> ### Aliases: data-beets beets
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(beets)
> 
> beets$bh <- with(beets, interaction(block, harvest))
> summary(aov(yield ~ block + sow + harvest + Error(bh), beets))

Error: bh
          Df Sum Sq Mean Sq  F value   Pr(>F)    
block      2   11.3     5.7    4.018 0.199292    
harvest    1 1725.2  1725.2 1225.000 0.000815 ***
Residuals  2    2.8     1.4                      
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Error: Within
          Df Sum Sq Mean Sq F value   Pr(>F)    
sow        4   8369  2092.3   119.7 1.13e-13 ***
Residuals 20    349    17.5                     
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> summary(aov(sugpct ~ block + sow + harvest + Error(bh), beets))

Error: bh
          Df  Sum Sq Mean Sq F value Pr(>F)  
block      2 0.03267 0.01633   2.579 0.2794  
harvest    1 0.09633 0.09633  15.211 0.0599 .
Residuals  2 0.01267 0.00633                 
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Error: Within
          Df Sum Sq Mean Sq F value   Pr(>F)    
sow        4   1.01  0.2525     101 5.74e-13 ***
Residuals 20   0.05  0.0025                     
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> 
> 
> 
> cleanEx()
> nameEx("data-budworm")
> ### * data-budworm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data-budworm
> ### Title: Budworm data
> ### Aliases: data-budworm budworm
> ### Keywords: datasets
> 
> ### ** Examples
> 
> 
> data(budworm)
> 
> ## function to caclulate the empirical logits
> empirical.logit<- function(nevent,ntotal) {
+    y <- log((nevent + 0.5) / (ntotal - nevent + 0.5))
+    y
+ }
> 
> 
> # plot the empirical logits against log-dose
> 
> log.dose <- log(budworm$dose)
> emp.logit <- empirical.logit(budworm$ndead, budworm$ntotal)
> plot(log.dose, emp.logit, type='n', xlab='log-dose',ylab='emprirical logit')
> title('budworm: emprirical logits of probability to die ')
> male <- budworm$sex=='male'
> female <- budworm$sex=='female'
> lines(log.dose[male], emp.logit[male], type='b', lty=1, col=1)
> lines(log.dose[female], emp.logit[female], type='b', lty=2, col=2)
> legend(0.5, 2, legend=c('male', 'female'), lty=c(1,2), col=c(1,2))
> 
> ## Not run: 
> ##D * SAS example;
> ##D data budworm;
> ##D infile 'budworm.txt' firstobs=2;
> ##D input sex dose ndead ntotal;
> ##D run;
> ## End(Not run)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("get_ddf_Lb")
> ### * get_ddf_Lb
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_ddf_Lb
> ### Title: Adjusted denominator degrees of freedom for linear estimate for
> ###   linear mixed model.
> ### Aliases: get_ddf_Lb get_Lb_ddf get_Lb_ddf.lmerMod Lb_ddf
> ###   get_ddf_Lb.lmerMod ddf_Lb
> ### Keywords: inference models
> 
> ### ** Examples
> 
> 
> (fmLarge <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy))
Linear mixed model fit by REML ['lmerMod']
Formula: Reaction ~ Days + (Days | Subject)
   Data: sleepstudy
REML criterion at convergence: 1743.628
Random effects:
 Groups   Name        Std.Dev. Corr
 Subject  (Intercept) 24.741       
          Days         5.922   0.07
 Residual             25.592       
Number of obs: 180, groups:  Subject, 18
Fixed Effects:
(Intercept)         Days  
     251.41        10.47  
> ## removing Days
> (fmSmall <- lmer(Reaction ~ 1 + (Days|Subject), sleepstudy))
Linear mixed model fit by REML ['lmerMod']
Formula: Reaction ~ 1 + (Days | Subject)
   Data: sleepstudy
REML criterion at convergence: 1769.845
Random effects:
 Groups   Name        Std.Dev. Corr 
 Subject  (Intercept) 25.53         
          Days        11.93    -0.18
 Residual             25.59         
Number of obs: 180, groups:  Subject, 18
Fixed Effects:
(Intercept)  
      257.8  
> anova(fmLarge, fmSmall)
refitting model(s) with ML (instead of REML)
Data: sleepstudy
Models:
fmSmall: Reaction ~ 1 + (Days | Subject)
fmLarge: Reaction ~ Days + (Days | Subject)
        npar    AIC    BIC  logLik deviance  Chisq Df Pr(>Chisq)    
fmSmall    5 1785.5 1801.4 -887.74   1775.5                         
fmLarge    6 1763.9 1783.1 -875.97   1751.9 23.537  1  1.226e-06 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> KRmodcomp(fmLarge, fmSmall)  ## 17 denominator df's
large : Reaction ~ Days + (Days | Subject)
small : Reaction ~ 1 + (Days | Subject)
        stat    ndf    ddf F.scaling   p.value    
Ftest 45.853  1.000 17.000         1 3.264e-06 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> get_Lb_ddf(fmLarge, c(0, 1)) ## 17 denominator df's
[1] 17
> 
> # Notice: The restriction matrix L corresponding to the test above
> # can be found with
> L <- model2restriction_matrix(fmLarge, fmSmall)
> L
     [,1] [,2]
[1,]    0    1
> 
> 
> 
> 
> cleanEx()
> nameEx("get_modcomp")
> ### * get_modcomp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_modcomp
> ### Title: Extract (or "get") components from a 'KRmodcomp' object.
> ### Aliases: get_modcomp getKR getSAT
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> data(beets, package='pbkrtest')
> lg <- lmer(sugpct ~ block + sow + harvest + (1|block:harvest), 
+               data=beets, REML=FALSE)
> sm <- update(lg, .~. - harvest)
> modcomp <- KRmodcomp(lg, sm)
> getKR(modcomp, "ddf") # get denominator degrees of freedom.
[1] 2
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("kr-modcomp")
> ### * kr-modcomp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kr-modcomp
> ### Title: F-test and degrees of freedom based on Kenward-Roger
> ###   approximation
> ### Aliases: kr-modcomp KRmodcomp KRmodcomp.lmerMod KRmodcomp_internal
> ###   KRmodcomp.mer
> ### Keywords: inference models
> 
> ### ** Examples
> 
> 
> (fmLarge <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy))
Linear mixed model fit by REML ['lmerMod']
Formula: Reaction ~ Days + (Days | Subject)
   Data: sleepstudy
REML criterion at convergence: 1743.628
Random effects:
 Groups   Name        Std.Dev. Corr
 Subject  (Intercept) 24.741       
          Days         5.922   0.07
 Residual             25.592       
Number of obs: 180, groups:  Subject, 18
Fixed Effects:
(Intercept)         Days  
     251.41        10.47  
> ## removing Days
> (fmSmall <- lmer(Reaction ~ 1 + (Days|Subject), sleepstudy))
Linear mixed model fit by REML ['lmerMod']
Formula: Reaction ~ 1 + (Days | Subject)
   Data: sleepstudy
REML criterion at convergence: 1769.845
Random effects:
 Groups   Name        Std.Dev. Corr 
 Subject  (Intercept) 25.53         
          Days        11.93    -0.18
 Residual             25.59         
Number of obs: 180, groups:  Subject, 18
Fixed Effects:
(Intercept)  
      257.8  
> anova(fmLarge, fmSmall)
refitting model(s) with ML (instead of REML)
Data: sleepstudy
Models:
fmSmall: Reaction ~ 1 + (Days | Subject)
fmLarge: Reaction ~ Days + (Days | Subject)
        npar    AIC    BIC  logLik deviance  Chisq Df Pr(>Chisq)    
fmSmall    5 1785.5 1801.4 -887.74   1775.5                         
fmLarge    6 1763.9 1783.1 -875.97   1751.9 23.537  1  1.226e-06 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> KRmodcomp(fmLarge, fmSmall)
large : Reaction ~ Days + (Days | Subject)
small : Reaction ~ 1 + (Days | Subject)
        stat    ndf    ddf F.scaling   p.value    
Ftest 45.853  1.000 17.000         1 3.264e-06 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> ## The same test using a restriction matrix
> L <- cbind(0, 1)
> KRmodcomp(fmLarge, L)
large : Reaction ~ Days + (Days | Subject)
L = 
     [,1] [,2]
[1,]    0    1
        stat    ndf    ddf F.scaling   p.value    
Ftest 45.853  1.000 17.000         1 3.264e-06 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> ## Same example, but with independent intercept and slope effects:
> m.large  <- lmer(Reaction ~ Days + (1|Subject) + (0+Days|Subject), data = sleepstudy)
> m.small  <- lmer(Reaction ~ 1 + (1|Subject) + (0+Days|Subject), data = sleepstudy)
> anova(m.large, m.small)
refitting model(s) with ML (instead of REML)
Data: sleepstudy
Models:
m.small: Reaction ~ 1 + (1 | Subject) + (0 + Days | Subject)
m.large: Reaction ~ Days + (1 | Subject) + (0 + Days | Subject)
        npar    AIC    BIC logLik deviance Chisq Df Pr(>Chisq)    
m.small    4 1783.6 1796.4 -887.8   1775.6                        
m.large    5 1762.0 1778.0 -876.0   1752.0  23.6  1  1.186e-06 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> KRmodcomp(m.large, m.small)
large : Reaction ~ Days + (1 | Subject) + (0 + Days | Subject)
small : Reaction ~ 1 + (1 | Subject) + (0 + Days | Subject)
        stat    ndf    ddf F.scaling   p.value    
Ftest 45.046  1.000 18.188         1 2.571e-06 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("kr-vcovAdj")
> ### * kr-vcovAdj
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kr-vcovAdj
> ### Title: Adjusted covariance matrix for linear mixed models according to
> ###   Kenward and Roger
> ### Aliases: kr-vcovAdj vcovAdj vcovAdj.lmerMod vcovAdj_internal vcovAdj0
> ###   vcovAdj2 vcovAdj.mer LMM_Sigma_G get_SigmaG get_SigmaG.lmerMod
> ###   get_SigmaG.mer
> ### Keywords: inference models
> 
> ### ** Examples
> 
> 
> fm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
> class(fm1)
[1] "lmerMod"
attr(,"package")
[1] "lme4"
> 
> ## Here the adjusted and unadjusted covariance matrices are identical,
> ## but that is not generally the case:
> 
> v1 <- vcov(fm1)
> v2 <- vcovAdj(fm1, details=0)
> v2 / v1
2 x 2 Matrix of class "dgeMatrix"
            (Intercept) Days
(Intercept)           1    1
Days                  1    1
> 
> ## For comparison, an alternative estimate of the variance-covariance
> ## matrix is based on parametric bootstrap (and this is easily
> ## parallelized): 
> 
> ## Not run: 
> ##D nsim <- 100
> ##D sim <- simulate(fm.ml, nsim)
> ##D B <- lapply(sim, function(newy) try(fixef(refit(fm.ml, newresp=newy))))
> ##D B <- do.call(rbind, B)
> ##D v3 <- cov.wt(B)$cov
> ##D v2/v1
> ##D v3/v1
> ## End(Not run)
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("model-coerce")
> ### * model-coerce
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: model-coerce
> ### Title: Conversion between a model object and a restriction matrix
> ### Aliases: model-coerce model2restriction_matrix restriction_matrix2model
> ###   make_model_matrix make_restriction_matrix
> ### Keywords: utilities
> 
> ### ** Examples
> 
> library(pbkrtest)
> data("beets", package = "pbkrtest")
> sug <- lm(sugpct ~ block + sow + harvest, data=beets)
> sug.h <- update(sug, .~. - harvest)
> sug.s <- update(sug, .~. - sow)
> 
> ## Construct restriction matrices from models
> L.h <- model2restriction_matrix(sug, sug.h); L.h
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]    0    0    0    0    0    0    0    1
> L.s <- model2restriction_matrix(sug, sug.s); L.s
     [,1] [,2] [,3]       [,4]       [,5]       [,6]       [,7] [,8]
[1,]    0    0    0  0.9176629 -0.2294157 -0.2294157 -0.2294157    0
[2,]    0    0    0  0.0636285  0.8907987 -0.3181424 -0.3181424    0
[3,]    0    0    0  0.1048285  0.1048285  0.8386279 -0.5241424    0
[4,]    0    0    0 -0.3779645 -0.3779645 -0.3779645 -0.7559289    0
> 
> ## Construct submodels from restriction matrices
> mod.h <- restriction_matrix2model(sug, L.h); mod.h

Call:
lm(formula = sugpct ~ .X1 + .X2 + .X3 + .X4 + .X5 + .X6 + .X7 - 
    1, data = structure(list(.X1 = c(0, 0, 0, 0, 0, 1, 1, 1, 
1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 
0), .X2 = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1), .X3 = c(0, 0, 0, 1, 0, 
0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 
0, 0, 1, 0), .X4 = c(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 
0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0), .X5 = c(0, 1, 
0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 
0, 0, 0, 1, 0, 0, 0), .X6 = c(0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 
0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), .X7 = c(-1, 
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), sugpct = c(17.1, 
16.9, 16.6, 17, 17, 17, 17, 16.7, 16.4, 16.8, 16.6, 16.9, 17.1, 
16.8, 16.9, 17, 16.8, 16.5, 16.7, 17, 16.8, 16.9, 17, 17, 16.5, 
16.7, 16.6, 16.9, 16.9, 16.4), block = structure(c(1L, 1L, 1L, 
1L, 1L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L, 3L, 1L, 1L, 1L, 1L, 
1L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L, 3L), levels = c("block1", 
"block2", "block3"), class = "factor"), sow = structure(c(3L, 
4L, 5L, 2L, 1L, 3L, 2L, 4L, 5L, 1L, 5L, 2L, 3L, 4L, 1L, 2L, 1L, 
5L, 4L, 3L, 4L, 1L, 3L, 2L, 5L, 1L, 4L, 3L, 2L, 5L), levels = c("sow1", 
"sow2", "sow3", "sow4", "sow5"), class = "factor"), harvest = structure(c(1L, 
1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 
2L, 2L, 2L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L), levels = c("harv1", 
"harv2"), class = "factor")), class = "data.frame", row.names = c(NA, 
30L)))

Coefficients:
     .X1       .X2       .X3       .X4       .X5       .X6       .X7  
 -0.0500   -0.0800    0.1167    0.1667   -0.1000   -0.3500  -16.8933  

> mod.s <- restriction_matrix2model(sug, L.s); mod.s

Call:
lm(formula = sugpct ~ .X1 + .X2 + .X3 + .X4 - 1, data = structure(list(
    .X1 = c(0.481123223875107, 0.481123223875107, 0.481123223875107, 
    0.481123223875107, 0.481123223875107, -0.392222671930744, 
    -0.392222671930744, -0.392222671930744, -0.392222671930744, 
    -0.392222671930744, 0.405048328363511, 0.405048328363511, 
    0.405048328363511, 0.405048328363511, 0.405048328363511, 
    0.481123223875107, 0.481123223875107, 0.481123223875107, 
    0.481123223875107, 0.481123223875107, -0.392222671930744, 
    -0.392222671930744, -0.392222671930744, -0.392222671930744, 
    -0.392222671930744, 0.405048328363511, 0.405048328363511, 
    0.405048328363511, 0.405048328363511, 0.405048328363511), 
    .X2 = c(0.481123205404825, 0.481123205404825, 0.481123205404825, 
    0.481123205404825, 0.481123205404825, 0.816718357972269, 
    0.816718357972269, 0.816718357972269, 0.816718357972269, 
    0.816718357972269, -0.328751077922051, -0.32875107792205, 
    -0.328751077922051, -0.328751077922051, -0.328751077922051, 
    0.481123205404825, 0.481123205404825, 0.481123205404825, 
    0.481123205404825, 0.481123205404825, 0.816718357972269, 
    0.816718357972269, 0.816718357972269, 0.816718357972269, 
    0.816718357972269, -0.328751077922051, -0.328751077922051, 
    -0.328751077922051, -0.32875107792205, -0.328751077922051
    ), .X3 = c(0.732830747627998, 0.732830747627998, 0.732830747627998, 
    0.732830747627998, 0.732830747627998, 1.08587867617639, 1.08587867617639, 
    1.08587867617639, 1.08587867617639, 1.08587867617639, 1.31448034616536, 
    1.31448034616536, 1.31448034616536, 1.31448034616536, 1.31448034616536, 
    0.732830747627998, 0.732830747627998, 0.732830747627998, 
    0.732830747627998, 0.732830747627998, 1.08587867617639, 1.08587867617639, 
    1.08587867617639, 1.08587867617639, 1.08587867617639, 1.31448034616536, 
    1.31448034616536, 1.31448034616536, 1.31448034616536, 1.31448034616536
    ), .X4 = c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 
    1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1), sugpct = c(17.1, 
    16.9, 16.6, 17, 17, 17, 17, 16.7, 16.4, 16.8, 16.6, 16.9, 
    17.1, 16.8, 16.9, 17, 16.8, 16.5, 16.7, 17, 16.8, 16.9, 17, 
    17, 16.5, 16.7, 16.6, 16.9, 16.9, 16.4), block = structure(c(1L, 
    1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L, 3L, 1L, 
    1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L, 3L), levels = c("block1", 
    "block2", "block3"), class = "factor"), sow = structure(c(3L, 
    4L, 5L, 2L, 1L, 3L, 2L, 4L, 5L, 1L, 5L, 2L, 3L, 4L, 1L, 2L, 
    1L, 5L, 4L, 3L, 4L, 1L, 3L, 2L, 5L, 1L, 4L, 3L, 2L, 5L), levels = c("sow1", 
    "sow2", "sow3", "sow4", "sow5"), class = "factor"), harvest = structure(c(1L, 
    1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 1L, 2L, 
    2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L), levels = c("harv1", 
    "harv2"), class = "factor")), class = "data.frame", row.names = c(NA, 
30L)))

Coefficients:
    .X1      .X2      .X3      .X4  
 8.1888   8.1870  12.3329  -0.1133  

> 
> ## Sanity check: The models have the same fitted values and log likelihood
> plot(fitted(mod.h), fitted(sug.h))
> plot(fitted(mod.s), fitted(sug.s))
> logLik(mod.h)
'log Lik.' 36.03257 (df=8)
> logLik(sug.h)
'log Lik.' 36.03257 (df=8)
> logLik(mod.s)
'log Lik.' 7.397588 (df=5)
> logLik(sug.s)
'log Lik.' 7.397588 (df=5)
> 
> 
> 
> cleanEx()
> nameEx("pb-modcomp")
> ### * pb-modcomp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pb-modcomp
> ### Title: Model comparison using parametric bootstrap methods.
> ### Aliases: pb-modcomp PBmodcomp PBmodcomp.lm PBmodcomp.merMod getLRT
> ###   getLRT.lm getLRT.merMod plot.XXmodcomp PBmodcomp.mer getLRT.mer
> ###   seqPBmodcomp
> ### Keywords: inference models
> 
> ### ** Examples
> 
> 
> data(beets, package="pbkrtest")
> head(beets)
  harvest  block  sow yield sugpct
1   harv1 block1 sow3 128.0   17.1
2   harv1 block1 sow4 118.0   16.9
3   harv1 block1 sow5  95.0   16.6
4   harv1 block1 sow2 131.0   17.0
5   harv1 block1 sow1 136.5   17.0
6   harv2 block2 sow3 136.5   17.0
> 
> NSIM <- 50 ## Simulations in parametric bootstrap
> 
> ## Linear mixed effects model:
> sug   <- lmer(sugpct ~ block + sow + harvest + (1|block:harvest),
+               data=beets, REML=FALSE)
> sug.h <- update(sug, .~. -harvest)
> sug.s <- update(sug, .~. -sow)
boundary (singular) fit: see help('isSingular')
> 
> anova(sug, sug.h)
Data: beets
Models:
sug.h: sugpct ~ block + sow + (1 | block:harvest)
sug: sugpct ~ block + sow + harvest + (1 | block:harvest)
      npar     AIC     BIC logLik deviance  Chisq Df Pr(>Chisq)    
sug.h    9 -69.084 -56.473 43.542  -87.084                         
sug     10 -79.998 -65.986 49.999  -99.998 12.914  1  0.0003261 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> PBmodcomp(sug, sug.h, nsim=NSIM, cl=1)
Bootstrap test; time: 0.80 sec; samples: 50; extremes: 0;
large : sugpct ~ block + sow + harvest + (1 | block:harvest)
sugpct ~ block + sow + (1 | block:harvest)
         stat df   p.value    
LRT    12.914  1 0.0003261 ***
PBtest 12.914    0.0196078 *  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> anova(sug, sug.s)
Data: beets
Models:
sug.s: sugpct ~ block + harvest + (1 | block:harvest)
sug: sugpct ~ block + sow + harvest + (1 | block:harvest)
      npar     AIC     BIC logLik deviance  Chisq Df Pr(>Chisq)    
sug.s    6  -2.795   5.612  7.398  -14.795                         
sug     10 -79.998 -65.986 49.999  -99.998 85.203  4  < 2.2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> PBmodcomp(sug, sug.s, nsim=NSIM, cl=1)
boundary (singular) fit: see help('isSingular')
boundary (singular) fit: see help('isSingular')
Bootstrap test; time: 0.73 sec; samples: 50; extremes: 0;
large : sugpct ~ block + sow + harvest + (1 | block:harvest)
sugpct ~ block + harvest + (1 | block:harvest)
         stat df p.value    
LRT    85.203  4 < 2e-16 ***
PBtest 85.203    0.01961 *  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> ## Linear normal model:
> sug <- lm(sugpct ~ block + sow + harvest, data=beets)
> sug.h <- update(sug, .~. -harvest)
> sug.s <- update(sug, .~. -sow)
> 
> anova(sug, sug.h)
Analysis of Variance Table

Model 1: sugpct ~ block + sow + harvest
Model 2: sugpct ~ block + sow
  Res.Df      RSS Df Sum of Sq      F    Pr(>F)    
1     22 0.062667                                  
2     23 0.159000 -1 -0.096333 33.819 7.508e-06 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> PBmodcomp(sug, sug.h, nsim=NSIM, cl=1)
Bootstrap test; time: 0.09 sec; samples: 50; extremes: 0;
large : sugpct ~ block + sow + harvest
sugpct ~ block + sow
         stat df   p.value    
LRT    27.932  1 1.256e-07 ***
PBtest 27.932      0.01961 *  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> anova(sug, sug.s)
Analysis of Variance Table

Model 1: sugpct ~ block + sow + harvest
Model 2: sugpct ~ block + harvest
  Res.Df     RSS Df Sum of Sq      F    Pr(>F)    
1     22 0.06267                                  
2     26 1.07267 -4     -1.01 88.644 3.073e-13 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> PBmodcomp(sug, sug.s, nsim=NSIM, cl=1)
Bootstrap test; time: 0.09 sec; samples: 50; extremes: 0;
large : sugpct ~ block + sow + harvest
sugpct ~ block + harvest
         stat df p.value    
LRT    85.202  4 < 2e-16 ***
PBtest 85.202    0.01961 *  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> ## Generalized linear model
> counts    <- c(18, 17, 15, 20, 10, 20, 25, 13, 12)
> outcome   <- gl(3, 1, 9)
> treatment <- gl(3, 3)
> d.AD      <- data.frame(treatment, outcome, counts)
> head(d.AD)
  treatment outcome counts
1         1       1     18
2         1       2     17
3         1       3     15
4         2       1     20
5         2       2     10
6         2       3     20
> glm.D93   <- glm(counts ~ outcome + treatment, family = poisson())
> glm.D93.o <- update(glm.D93, .~. -outcome)
> glm.D93.t <- update(glm.D93, .~. -treatment)
> 
> anova(glm.D93, glm.D93.o, test="Chisq")
Analysis of Deviance Table

Model 1: counts ~ outcome + treatment
Model 2: counts ~ treatment
  Resid. Df Resid. Dev Df Deviance Pr(>Chi)  
1         4     5.1291                       
2         6    10.5814 -2  -5.4523  0.06547 .
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> PBmodcomp(glm.D93, glm.D93.o, nsim=NSIM, cl=1)
Bootstrap test; time: 0.12 sec; samples: 50; extremes: 1;
large : counts ~ outcome + treatment
counts ~ treatment
         stat df p.value  
LRT    5.4523  2 0.06547 .
PBtest 5.4523    0.03922 *
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> anova(glm.D93, glm.D93.t, test="Chisq")
Analysis of Deviance Table

Model 1: counts ~ outcome + treatment
Model 2: counts ~ outcome
  Resid. Df Resid. Dev Df    Deviance Pr(>Chi)
1         4     5.1291                        
2         6     5.1291 -2 -7.1054e-15        1
> PBmodcomp(glm.D93, glm.D93.t, nsim=NSIM, cl=1)
Bootstrap test; time: 0.12 sec; samples: 50; extremes: 50;
large : counts ~ outcome + treatment
counts ~ outcome
       stat df p.value
LRT       0  2       1
PBtest    0          1
> 
> ## Generalized linear mixed model (it takes a while to fit these)
> 
> ## Not run: 
> ##D (gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
> ##D               data = cbpp, family = binomial))
> ##D (gm2 <- update(gm1, .~.-period))
> ##D anova(gm1, gm2)
> ##D PBmodcomp(gm1, gm2)
> ## End(Not run)
> 
> 
> ## Not run: 
> ##D (fmLarge <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy))
> ##D ## removing Days
> ##D (fmSmall <- lmer(Reaction ~ 1 + (Days|Subject), sleepstudy))
> ##D anova(fmLarge, fmSmall)
> ##D PBmodcomp(fmLarge, fmSmall, cl=1)
> ##D 
> ##D ## The same test using a restriction matrix
> ##D L <- cbind(0,1)
> ##D PBmodcomp(fmLarge, L, cl=1)
> ##D 
> ##D ## Vanilla
> ##D PBmodcomp(beet0, beet_no.harv, nsim=NSIM, cl=1)
> ##D 
> ##D ## Simulate reference distribution separately:
> ##D refdist <- PBrefdist(beet0, beet_no.harv, nsim=1000)
> ##D PBmodcomp(beet0, beet_no.harv, ref=refdist, cl=1)
> ##D 
> ##D ## Do computations with multiple processors:
> ##D ## Number of cores:
> ##D (nc <- detectCores())
> ##D ## Create clusters
> ##D cl <- makeCluster(rep("localhost", nc))
> ##D 
> ##D ## Then do:
> ##D PBmodcomp(beet0, beet_no.harv, cl=cl)
> ##D 
> ##D ## Or in two steps:
> ##D refdist <- PBrefdist(beet0, beet_no.harv, nsim=NSIM, cl=cl)
> ##D PBmodcomp(beet0, beet_no.harv, ref=refdist)
> ##D 
> ##D ## It is recommended to stop the clusters before quitting R:
> ##D stopCluster(cl)
> ## End(Not run)
> 
> ## Linear and generalized linear models:
> 
> m11 <- lm(dist ~ speed + I(speed^2), data=cars)
> m10 <- update(m11, ~.-I(speed^2))
> anova(m11, m10)
Analysis of Variance Table

Model 1: dist ~ speed + I(speed^2)
Model 2: dist ~ speed
  Res.Df   RSS Df Sum of Sq     F Pr(>F)
1     47 10825                          
2     48 11354 -1   -528.81 2.296 0.1364
> 
> PBmodcomp(m11, m10, cl=1, nsim=NSIM)
Bootstrap test; time: 0.05 sec; samples: 50; extremes: 4;
large : dist ~ speed + I(speed^2)
dist ~ speed
         stat df p.value  
LRT    2.3848  1 0.12252  
PBtest 2.3848    0.09804 .
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> PBmodcomp(m11, ~.-I(speed^2), cl=1, nsim=NSIM)
Bootstrap test; time: 0.06 sec; samples: 50; extremes: 4;
large : dist ~ speed + I(speed^2)
dist ~ speed
         stat df p.value  
LRT    2.3848  1 0.12252  
PBtest 2.3848    0.09804 .
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> PBmodcomp(m11, c(0, 0, 1), cl=1, nsim=NSIM)
Bootstrap test; time: 0.06 sec; samples: 50; extremes: 5;
large : dist ~ speed + I(speed^2)
small : 
     [,1] [,2] [,3]
[1,]    0    0    1
         stat df p.value
LRT    2.3848  1  0.1225
PBtest 2.3848     0.1176
> 
> m21 <- glm(dist ~ speed + I(speed^2), family=Gamma("identity"), data=cars)
> m20 <- update(m21, ~.-I(speed^2))
> anova(m21, m20, test="Chisq")
Analysis of Deviance Table

Model 1: dist ~ speed + I(speed^2)
Model 2: dist ~ speed
  Resid. Df Resid. Dev Df Deviance Pr(>Chi)
1        47     7.6741                     
2        48     8.0945 -1 -0.42037    0.106
> 
> PBmodcomp(m21, m20, cl=1, nsim=NSIM)
Bootstrap test; time: 0.10 sec; samples: 50; extremes: 5;
large : dist ~ speed + I(speed^2)
dist ~ speed
         stat df p.value  
LRT    2.7364  1 0.09809 .
PBtest 2.7364    0.11765  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> PBmodcomp(m21, ~.-I(speed^2), cl=1, nsim=NSIM)
Bootstrap test; time: 0.10 sec; samples: 50; extremes: 4;
large : dist ~ speed + I(speed^2)
dist ~ speed
         stat df p.value  
LRT    2.7364  1 0.09809 .
PBtest 2.7364    0.09804 .
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> PBmodcomp(m21, c(0, 0, 1), cl=1, nsim=NSIM)
Bootstrap test; time: 0.11 sec; samples: 50; extremes: 12;
large : dist ~ speed + I(speed^2)
small : 
     [,1] [,2] [,3]
[1,]    0    0    1
         stat df p.value  
LRT    2.7364  1 0.09809 .
PBtest 2.7364    0.25490  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> 
> 
> 
> cleanEx()
> nameEx("pb-refdist")
> ### * pb-refdist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pb-refdist
> ### Title: Calculate reference distribution using parametric bootstrap
> ### Aliases: pb-refdist PBrefdist PBrefdist.merMod PBrefdist.lm
> ### Keywords: inference models
> 
> ### ** Examples
> 
> 
> data(beets)
> head(beets)
  harvest  block  sow yield sugpct
1   harv1 block1 sow3 128.0   17.1
2   harv1 block1 sow4 118.0   16.9
3   harv1 block1 sow5  95.0   16.6
4   harv1 block1 sow2 131.0   17.0
5   harv1 block1 sow1 136.5   17.0
6   harv2 block2 sow3 136.5   17.0
> beet0 <- lmer(sugpct ~ block + sow + harvest + (1|block:harvest), data=beets, REML=FALSE)
> beet_no.harv <- update(beet0, . ~ . -harvest)
> rd <- PBrefdist(beet0, beet_no.harv, nsim=20, cl=1)
> rd
 [1] 0.86051095 1.13491918 0.40496885 0.71527981 4.02449945 0.59058809
 [7] 1.10309559 0.08734952 0.66081574 2.66828296 4.82282420 1.84465055
[13] 0.11272254 1.28623213 6.34752883 0.01360985 0.54594002 6.41115301
[19] 0.03063532 1.10948394
attr(,"cl")
[1] 1
attr(,"ctime")
elapsed 
   0.31 
attr(,"stat")
        tobs           df      p.value 
1.291424e+01 1.000000e+00 3.260911e-04 
attr(,"samples")
       nsim        npos   n.extreme         pPB 
20.00000000 20.00000000  0.00000000  0.04761905 
attr(,"class")
[1] "refdist"
> ## Not run: 
> ##D ## Note: Many more simulations must be made in practice.
> ##D 
> ##D # Computations can be made in parallel using several processors:
> ##D 
> ##D # 1: On OSs that fork processes (that is, not on windows):
> ##D # --------------------------------------------------------
> ##D 
> ##D if (Sys.info()["sysname"] != "Windows"){
> ##D   N <- 2 ## Or N <- parallel::detectCores()
> ##D 
> ##D # N cores used in all calls to function in a session
> ##D   options("mc.cores"=N)
> ##D   rd <- PBrefdist(beet0, beet_no.harv, nsim=20)
> ##D 
> ##D # N cores used just in one specific call (when cl is set,
> ##D # options("mc.cores") is ignored):
> ##D   rd <- PBrefdist(beet0, beet_no.harv, nsim=20, cl=N)
> ##D }
> ##D 
> ##D # In fact, on Windows, the approach above also work but only when setting the
> ##D # number of cores to 1 (so there is to parallel computing)
> ##D 
> ##D # In all calls:
> ##D # options("mc.cores"=1)
> ##D # rd <- PBrefdist(beet0, beet_no.harv, nsim=20)
> ##D # Just once
> ##D # rd <- PBrefdist(beet0, beet_no.harv, nsim=20, cl=1)
> ##D 
> ##D # 2. On all platforms (also on Windows) one can do
> ##D # ------------------------------------------------
> ##D library(parallel)
> ##D N <- 2 ## Or N  <- detectCores()
> ##D clus <- makeCluster(rep("localhost", N))
> ##D 
> ##D # In all calls in a session
> ##D options("pb.cl"=clus)
> ##D rd <- PBrefdist(beet0, beet_no.harv, nsim=20)
> ##D 
> ##D # Just once:
> ##D rd <- PBrefdist(beet0, beet_no.harv, nsim=20, cl=clus)
> ##D stopCluster(clus)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("sat-modcomp")
> ### * sat-modcomp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sat-modcomp
> ### Title: F-test and degrees of freedom based on Satterthwaite
> ###   approximation
> ### Aliases: sat-modcomp SATmodcomp SATmodcomp.lmerMod
> ### Keywords: inference models
> 
> ### ** Examples
> 
> 
> (fm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy))
Linear mixed model fit by REML ['lmerMod']
Formula: Reaction ~ Days + (Days | Subject)
   Data: sleepstudy
REML criterion at convergence: 1743.628
Random effects:
 Groups   Name        Std.Dev. Corr
 Subject  (Intercept) 24.741       
          Days         5.922   0.07
 Residual             25.592       
Number of obs: 180, groups:  Subject, 18
Fixed Effects:
(Intercept)         Days  
     251.41        10.47  
> L1 <- cbind(0,1)
> SATmodcomp(fm1, L1)
large : Reaction ~ Days + (Days | Subject)
small (restriction matrix) : 
    
 0 1
     statistic    ndf ddf   p.value    
[1,]    45.853  1.000  17 3.264e-06 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> (fm2 <- lmer(Reaction ~ Days + I(Days^2) + (Days|Subject), sleepstudy))
Linear mixed model fit by REML ['lmerMod']
Formula: Reaction ~ Days + I(Days^2) + (Days | Subject)
   Data: sleepstudy
REML criterion at convergence: 1742.816
Random effects:
 Groups   Name        Std.Dev. Corr
 Subject  (Intercept) 24.761       
          Days         5.925   0.06
 Residual             25.534       
Number of obs: 180, groups:  Subject, 18
Fixed Effects:
(Intercept)         Days    I(Days^2)  
    255.449        7.434        0.337  
> 
> ## Test for no effect of Days. There are three ways of using the function:
> 
> ## 1) Define 2-df contrast - since L has 2 (linearly independent) rows
> ## the F-test is on 2 (numerator) df:
> L2 <- rbind(c(0, 1, 0), c(0, 0, 1))
> SATmodcomp(fm2, L2)
large : Reaction ~ Days + I(Days^2) + (Days | Subject)
small (restriction matrix) : 
      
 0 1 0
 0 0 1
     statistic    ndf    ddf   p.value    
[1,]    23.754  2.000 51.563 4.876e-08 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> ## 2) Use two model objects 
> fm3 <- update(fm2, ~. - Days - I(Days^2))
> SATmodcomp(fm2, fm3)
large : Reaction ~ Days + I(Days^2) + (Days | Subject)
small (restriction matrix) : 
                       
 0  0.1104315 0.9938837
 0 -0.9938837 0.1104315
     statistic    ndf    ddf   p.value    
[1,]    23.754  2.000 51.563 4.876e-08 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> ## 3) Specify restriction as formula
> SATmodcomp(fm2, ~. - Days - I(Days^2))
large : Reaction ~ Days + I(Days^2) + (Days | Subject)
small (restriction matrix) : 
                       
 0  0.1104315 0.9938837
 0 -0.9938837 0.1104315
     statistic    ndf    ddf   p.value    
[1,]    23.754  2.000 51.563 4.876e-08 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  5.578 1.794 5.388 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
