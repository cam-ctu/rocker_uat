
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "openssl"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('openssl')
Linking to: OpenSSL 3.0.2 15 Mar 2022
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("aes_cbc")
> ### * aes_cbc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aes_cbc
> ### Title: Symmetric AES encryption
> ### Aliases: aes_cbc aes_ctr_encrypt aes_ctr_decrypt aes_cbc_encrypt
> ###   aes_cbc_decrypt aes_gcm_encrypt aes_gcm_decrypt aes_keygen
> 
> ### ** Examples
> 
> # aes-256 requires 32 byte key
> passphrase <- charToRaw("This is super secret")
> key <- sha256(passphrase)
> 
> # symmetric encryption uses same key for decryption
> x <- serialize(iris, NULL)
> y <- aes_cbc_encrypt(x, key = key)
> x2 <- aes_cbc_decrypt(y, key = key)
> stopifnot(identical(x, x2))
> 
> 
> 
> cleanEx()
> nameEx("base64_encode")
> ### * base64_encode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: base64_encode
> ### Title: Encode and decode base64
> ### Aliases: base64_encode base64_decode
> 
> ### ** Examples
> 
> input <- charToRaw("foo = bar + 5")
> message <- base64_encode(input)
> output <- base64_decode(message)
> identical(output, input)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("bignum")
> ### * bignum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bignum
> ### Title: Big number arithmetic
> ### Aliases: bignum bignum_mod_exp bignum_mod_inv
> 
> ### ** Examples
> 
> # create a bignum
> x <- bignum(123L)
> y <- bignum("123456789123456789")
> z <- bignum("D41D8CD98F00B204E9800998ECF8427E", hex = TRUE)
> 
> # Basic arithmetic
> div <- z %/% y
> mod <- z %% y
> z2 <- div * y + mod
> stopifnot(z2 == z)
> stopifnot(div < z)
> 
> 
> 
> cleanEx()
> nameEx("certificates")
> ### * certificates
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cert_verify
> ### Title: X509 certificates
> ### Aliases: cert_verify certificates download_ssl_cert ca_bundle
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("curve25519")
> ### * curve25519
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: curve25519
> ### Title: Curve25519
> ### Aliases: curve25519 read_ed25519_key read_ed25519_pubkey
> ###   read_x25519_key read_x25519_pubkey ed25519_sign ed25519_verify
> ###   x25519_diffie_hellman
> 
> ### ** Examples
> 
> # Generate a keypair
> if(openssl_config()$x25519){
+ key <- ed25519_keygen()
+ pubkey <- as.list(key)$pubkey
+ 
+ # Sign message
+ msg <- serialize(iris, NULL)
+ sig <- ed25519_sign(msg, key)
+ 
+ # Verify the signature
+ ed25519_verify(msg, sig, pubkey)
+ 
+ # Diffie Hellman example:
+ key1 <- x25519_keygen()
+ key2 <- x25519_keygen()
+ 
+ # Both parties can derive the same secret
+ x25519_diffie_hellman(key1, key2$pubkey)
+ x25519_diffie_hellman(key2, key1$pubkey)
+ 
+ # Import/export sodium keys
+ rawkey <- sodium::sig_keygen()
+ rawpubkey <- sodium::sig_pubkey(rawkey)
+ key <- read_ed25519_key(rawkey)
+ pubkey <- read_ed25519_pubkey(rawpubkey)
+ 
+ # To get the raw key data back for use in sodium
+ as.list(key)$data
+ as.list(pubkey)$data
+ }
Error in loadNamespace(x) : there is no package called ‘sodium’
Calls: loadNamespace -> withRestarts -> withOneRestart -> doWithOneRestart
Execution halted
