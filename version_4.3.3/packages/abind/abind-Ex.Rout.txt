
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "abind"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('abind')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("abind")
> ### * abind
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: abind
> ### Title: Combine multi-dimensional arrays
> ### Aliases: abind
> ### Keywords: manip array
> 
> ### ** Examples
> 
> # Five different ways of binding together two matrices
> x <- matrix(1:12,3,4)
> y <- x+100
> dim(abind(x,y,along=0))     # binds on new dimension before first
[1] 2 3 4
> dim(abind(x,y,along=1))     # binds on first dimension
[1] 6 4
> dim(abind(x,y,along=1.5))
[1] 3 2 4
> dim(abind(x,y,along=2))
[1] 3 8
> dim(abind(x,y,along=3))
[1] 3 4 2
> dim(abind(x,y,rev.along=1)) # binds on last dimension
[1] 3 8
> dim(abind(x,y,rev.along=0)) # binds on new dimension after last
[1] 3 4 2
> 
> # Unlike cbind or rbind in that the default is to bind
> # along the last dimension of the inputs, which for vectors
> # means the result is a vector (because a vector is
> # treated as an array with length(dim(x))==1).
> abind(x=1:4,y=5:8)
x1 x2 x3 x4 y1 y2 y3 y4 
 1  2  3  4  5  6  7  8 
> # Like cbind
> abind(x=1:4,y=5:8,along=2)
     x y
[1,] 1 5
[2,] 2 6
[3,] 3 7
[4,] 4 8
> abind(x=1:4,matrix(5:20,nrow=4),along=2)
     x           
[1,] 1 5  9 13 17
[2,] 2 6 10 14 18
[3,] 3 7 11 15 19
[4,] 4 8 12 16 20
> abind(1:4,matrix(5:20,nrow=4),along=2)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20
> # Like rbind
> abind(x=1:4,matrix(5:20,nrow=4),along=1)
  [,1] [,2] [,3] [,4]
x    1    2    3    4
     5    9   13   17
     6   10   14   18
     7   11   15   19
     8   12   16   20
> abind(1:4,matrix(5:20,nrow=4),along=1)
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    4
[2,]    5    9   13   17
[3,]    6   10   14   18
[4,]    7   11   15   19
[5,]    8   12   16   20
> # Create a 3-d array out of two matrices
> abind(x=matrix(1:16,nrow=4),y=matrix(17:32,nrow=4),along=3)
, , x

     [,1] [,2] [,3] [,4]
[1,]    1    5    9   13
[2,]    2    6   10   14
[3,]    3    7   11   15
[4,]    4    8   12   16

, , y

     [,1] [,2] [,3] [,4]
[1,]   17   21   25   29
[2,]   18   22   26   30
[3,]   19   23   27   31
[4,]   20   24   28   32

> # Use of hier.names
> abind(x=cbind(a=1:3,b=4:6), y=cbind(a=7:9,b=10:12), hier.names=TRUE)
     x.a x.b y.a y.b
[1,]   1   4   7  10
[2,]   2   5   8  11
[3,]   3   6   9  12
> # Use a list argument
> abind(list(x=x, y=x), along=3)
, , x

     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

, , y

     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

> # Use lapply(..., get) to get the objects
> an <- c('x','y')
> names(an) <- an
> abind(lapply(an, get), along=3)
, , x

     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

, , y

     [,1] [,2] [,3] [,4]
[1,]  101  104  107  110
[2,]  102  105  108  111
[3,]  103  106  109  112

> 
> 
> 
> cleanEx()
> nameEx("acorn")
> ### * acorn
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: acorn
> ### Title: Return a corner of an array object (like head)
> ### Aliases: acorn ahead acorn.default
> ### Keywords: manip array
> 
> ### ** Examples
> 
> x <- array(1:24,dim=c(4,3,2),dimnames=rev(list(letters[1:2],LETTERS[1:3],letters[23:26])))
> acorn(x)
, , a

  A B  C
w 1 5  9
x 2 6 10
y 3 7 11
z 4 8 12

> acorn(x, 3)
, , a

  A B  C
w 1 5  9
x 2 6 10
y 3 7 11

> acorn(x, -3)
, , a

  A B  C
x 2 6 10
y 3 7 11
z 4 8 12

> acorn(x, 3, -2)
, , a

  B  C
w 5  9
x 6 10
y 7 11

> 
> 
> 
> cleanEx()
> nameEx("adrop")
> ### * adrop
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: adrop
> ### Title: Drop dimensions of an array object
> ### Aliases: adrop adrop.default
> ### Keywords: manip array
> 
> ### ** Examples
> 
> x <- array(1:24,dim=c(2,3,4),dimnames=list(letters[1:2],LETTERS[1:3],letters[23:26]))
> adrop(x[1,,,drop=FALSE],drop=1)
  w  x  y  z
A 1  7 13 19
B 3  9 15 21
C 5 11 17 23
> adrop(x[,1,,drop=FALSE],drop=2)
  w x  y  z
a 1 7 13 19
b 2 8 14 20
> adrop(x[,,1,drop=FALSE],drop=3)
  A B C
a 1 3 5
b 2 4 6
> adrop(x[1,1,1,drop=FALSE],drop=1)
  w
A 1
> adrop(x[1,1,1,drop=FALSE],drop=2)
  w
a 1
> adrop(x[1,1,1,drop=FALSE],drop=3)
  A
a 1
> adrop(x[1,1,1,drop=FALSE],drop=1:2)
w 
1 
> adrop(x[1,1,1,drop=FALSE],drop=1:2,one.d=TRUE)
w 
1 
> adrop(x[1,1,1,drop=FALSE],drop=1:2,named=FALSE)
[1] 1
> dim(adrop(x[1,1,1,drop=FALSE],drop=1:2,one.d=TRUE))
[1] 1
> dimnames(adrop(x[1,1,1,drop=FALSE],drop=1:2,one.d=TRUE))
[[1]]
[1] "w"

> names(adrop(x[1,1,1,drop=FALSE],drop=1:2,one.d=TRUE))
[1] "w"
> dim(adrop(x[1,1,1,drop=FALSE],drop=1:2))
NULL
> dimnames(adrop(x[1,1,1,drop=FALSE],drop=1:2))
NULL
> names(adrop(x[1,1,1,drop=FALSE],drop=1:2))
[1] "w"
> 
> 
> 
> cleanEx()
> nameEx("afill")
> ### * afill
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: afill
> ### Title: Fill an array with subarrays
> ### Aliases: afill afill<- afill<-.default
> ### Keywords: manip array
> 
> ### ** Examples
> 
> # fill a submatrix defined by the dimnames on y
> (x <- matrix(0, ncol=3, nrow=4, dimnames=list(letters[1:4], LETTERS[24:26])))
  X Y Z
a 0 0 0
b 0 0 0
c 0 0 0
d 0 0 0
> (y <- matrix(1:4, ncol=2, nrow=2, dimnames=list(letters[2:3], LETTERS[25:26])))
  Y Z
b 1 3
c 2 4
> afill(x) <- y
> x
  X Y Z
a 0 0 0
b 0 1 3
c 0 2 4
d 0 0 0
> all.equal(asub(x, dimnames(y)), y) # TRUE
[1] TRUE
> # fill a slice in a higher dimensional array
> x <- array(0, dim=c(2,4,3), dimnames=list(LETTERS[1:2], letters[1:4], LETTERS[24:26]))
> y <- matrix(1:4, ncol=2, nrow=2, dimnames=list(letters[2:3], LETTERS[25:26]))
> afill(x, 1, , ) <- y
> x[1,,]
  X Y Z
a 0 0 0
b 0 1 3
c 0 2 4
d 0 0 0
> x[2,,]
  X Y Z
a 0 0 0
b 0 0 0
c 0 0 0
d 0 0 0
> all.equal(asub(x, c(1,dimnames(y))), y) # TRUE
[1] TRUE
> # fill multiple slices
> x <- array(0, dim=c(2,4,3), dimnames=list(LETTERS[1:2], letters[1:4], LETTERS[24:26]))
> y <- matrix(1:4, ncol=2, nrow=2, dimnames=list(letters[2:3], LETTERS[25:26]))
> afill(x, TRUE, , ) <- y
> x[1,,]
  X Y Z
a 0 0 0
b 0 1 3
c 0 2 4
d 0 0 0
> x[2,,]
  X Y Z
a 0 0 0
b 0 1 3
c 0 2 4
d 0 0 0
> all.equal(asub(x, c(1,dimnames(y))), y) # TRUE
[1] TRUE
> all.equal(asub(x, c(2,dimnames(y))), y) # TRUE
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("asub")
> ### * asub
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asub
> ### Title: Arbitrary subsetting of array-like objects at specified indices
> ### Aliases: asub asub.default
> ### Keywords: manip array
> 
> ### ** Examples
> 
> x <- array(1:24,dim=c(2,3,4),dimnames=list(letters[1:2],LETTERS[1:3],letters[23:26]))
> asub(x, 1, 1, drop=FALSE)
, , w

  A B C
a 1 3 5

, , x

  A B  C
a 7 9 11

, , y

   A  B  C
a 13 15 17

, , z

   A  B  C
a 19 21 23

> asub(x, list(1:2,3:4), c(1,3))
, , y

   A  B  C
a 13 15 17
b 14 16 18

, , z

   A  B  C
a 19 21 23
b 20 22 24

> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.076 0.006 0.082 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
